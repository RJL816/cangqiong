/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackJsonp_bos-platform"] = self["webpackJsonp_bos-platform"] || []).push([[8560],{

/***/ "./src/workflow/actions/approvalRecordAction.js":
/*!******************************************************!*\
  !*** ./src/workflow/actions/approvalRecordAction.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\n__webpack_require__(/*! core-js/modules/es.symbol.js */ \"../../node_modules/core-js/modules/es.symbol.js\");\n__webpack_require__(/*! core-js/modules/es.symbol.description.js */ \"../../node_modules/core-js/modules/es.symbol.description.js\");\n__webpack_require__(/*! core-js/modules/es.symbol.iterator.js */ \"../../node_modules/core-js/modules/es.symbol.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.array.iterator.js */ \"../../node_modules/core-js/modules/es.array.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\n__webpack_require__(/*! core-js/modules/es.object.get-own-property-descriptor.js */ \"../../node_modules/core-js/modules/es.object.get-own-property-descriptor.js\");\n__webpack_require__(/*! core-js/modules/es.object.to-string.js */ \"../../node_modules/core-js/modules/es.object.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.string.iterator.js */ \"../../node_modules/core-js/modules/es.string.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.weak-map.js */ \"../../node_modules/core-js/modules/es.weak-map.js\");\n__webpack_require__(/*! core-js/modules/web.dom-collections.iterator.js */ \"../../node_modules/core-js/modules/web.dom-collections.iterator.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.SHOW_COORDINATE = exports.SHOW_AUTOCOORDINATE = exports.SHOW_APPROVALRECORD = void 0;\nexports.backToParentProcess = backToParentProcess;\nexports.clickCustomizeLink = clickCustomizeLink;\nexports.showApprovalsPage = showApprovalsPage;\nexports.showAttachmentInfo = showAttachmentInfo;\nexports.showAutoCoordinateInfo = showAutoCoordinateInfo;\nexports.showChildProcessInfo = showChildProcessInfo;\nexports.showCoordinateInfo = showCoordinateInfo;\nexports.showPersonInfo = showPersonInfo;\nexports.showTransferRecord = showTransferRecord;\nexports.showTransferRecordYZJ = showTransferRecordYZJ;\nvar _appModelFunction = __webpack_require__(/*! ../../model/appModelFunction */ \"./src/model/appModelFunction.js\");\nvar action = _interopRequireWildcard(__webpack_require__(/*! ../../action/action */ \"./src/action/action.js\"));\nfunction _getRequireWildcardCache(e) { if (\"function\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return { \"default\": e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\"default\" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n[\"default\"] = e, t && t.set(e, n), n; }\nvar SHOW_APPROVALRECORD = exports.SHOW_APPROVALRECORD = \"SHOW_APPROVALRECORD\";\nvar SHOW_COORDINATE = exports.SHOW_COORDINATE = \"SHOW_COORDINATE\";\nvar SHOW_AUTOCOORDINATE = exports.SHOW_AUTOCOORDINATE = \"SHOW_AUTOCOORDINATE\";\nfunction showApprovalsPage(model, _ref) {\n  var approvers = _ref.approvers,\n    signtype = _ref.signtype,\n    groupdecisiontype = _ref.groupdecisiontype,\n    throughrule = _ref.throughrule,\n    isDDOrQYWX = _ref.isDDOrQYWX;\n  return function (dispatch, getState) {\n    action.invokeControlService(model, 'showApprovalsPage', [approvers, signtype, groupdecisiontype, throughrule, isDDOrQYWX], (0, _appModelFunction.getPost)(model.pageId)(getState()), dispatch);\n  };\n}\nfunction showPersonInfo(model, _ref2) {\n  var userid = _ref2.userid;\n  return function (dispatch, getState) {\n    action.invokeControlService(model, 'showPersonInfo', [userid], (0, _appModelFunction.getPost)(model.pageId)(getState()), dispatch);\n  };\n}\nfunction showCoordinateInfo(model, _ref3) {\n  var taskid = _ref3.taskid,\n    userid = _ref3.userid,\n    autocoordinate = _ref3.autocoordinate;\n  return function (dispatch, getState) {\n    action.invokeControlService(model, 'showCoordinateInfo', [taskid, userid, autocoordinate], (0, _appModelFunction.getPost)(model.pageId)(getState()), dispatch);\n  };\n}\nfunction showAttachmentInfo(model, _ref4) {\n  var attachmentid = _ref4.attachmentid,\n    downloadurl = _ref4.downloadurl,\n    attachmentids = _ref4.attachmentids;\n  return function (dispatch, getState) {\n    action.invokeControlService(model, 'showAttachmentInfo', [attachmentid, downloadurl, attachmentids], (0, _appModelFunction.getPost)(model.pageId)(getState()), dispatch);\n  };\n}\nfunction clickCustomizeLink(model, params) {\n  return function (dispatch, getState) {\n    action.invokeControlService(model, 'clickCustomizeLink', [params], (0, _appModelFunction.getPost)(model.pageId)(getState()), dispatch);\n  };\n}\nfunction showTransferRecord(model, _ref5) {\n  var taskid = _ref5.taskid,\n    userid = _ref5.userid,\n    iscoordinate = _ref5.iscoordinate;\n  return function (dispatch, getState) {\n    action.invokeControlService(model, 'showTransferRecord', [taskid, userid, iscoordinate], (0, _appModelFunction.getPost)(model.pageId)(getState()), dispatch);\n  };\n}\nfunction showTransferRecordYZJ(model, _ref6) {\n  var value = _ref6.value,\n    iscoordinate = _ref6.iscoordinate;\n  return function (dispatch, getState) {\n    action.invokeControlService(model, 'showTransferRecordYZJ', [value, iscoordinate], (0, _appModelFunction.getPost)(model.pageId)(getState()), dispatch);\n  };\n}\nfunction showAutoCoordinateInfo(model, _ref7) {\n  var groupid = _ref7.groupid;\n  return function (dispatch, getState) {\n    action.invokeControlService(model, 'showAutoCoordinateInfo', [groupid], (0, _appModelFunction.getPost)(model.pageId)(getState()), dispatch);\n  };\n}\nfunction showChildProcessInfo(model, _ref8) {\n  var params = _ref8.params,\n    procinstid = _ref8.procinstid,\n    subcrosstenantinfo = _ref8.subcrosstenantinfo;\n  return function (dispatch, getState) {\n    action.invokeControlService(model, 'showChildProcessInfo', [params, procinstid, subcrosstenantinfo], (0, _appModelFunction.getPost)(model.pageId)(getState()), dispatch);\n  };\n}\nfunction backToParentProcess(model, _ref9) {\n  var params = _ref9.params,\n    superprocInstid = _ref9.superprocInstid;\n  return function (dispatch, getState) {\n    action.invokeControlService(model, 'backToParentProcess', [params, superprocInstid], (0, _appModelFunction.getPost)(model.pageId)(getState()), dispatch);\n  };\n}\n\n//# sourceURL=webpack://bos-platform/./src/workflow/actions/approvalRecordAction.js?");

/***/ }),

/***/ "./src/workflow/actions/index.js":
/*!***************************************!*\
  !*** ./src/workflow/actions/index.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\n__webpack_require__(/*! core-js/modules/es.symbol.js */ \"../../node_modules/core-js/modules/es.symbol.js\");\n__webpack_require__(/*! core-js/modules/es.symbol.description.js */ \"../../node_modules/core-js/modules/es.symbol.description.js\");\n__webpack_require__(/*! core-js/modules/es.symbol.iterator.js */ \"../../node_modules/core-js/modules/es.symbol.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.array.iterator.js */ \"../../node_modules/core-js/modules/es.array.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\n__webpack_require__(/*! core-js/modules/es.object.get-own-property-descriptor.js */ \"../../node_modules/core-js/modules/es.object.get-own-property-descriptor.js\");\n__webpack_require__(/*! core-js/modules/es.string.iterator.js */ \"../../node_modules/core-js/modules/es.string.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.weak-map.js */ \"../../node_modules/core-js/modules/es.weak-map.js\");\n__webpack_require__(/*! core-js/modules/web.dom-collections.iterator.js */ \"../../node_modules/core-js/modules/web.dom-collections.iterator.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.updateUiMetadata = exports.showFloatLayer = exports.setUpdateControl = exports.setUiMetadata = exports.setSelectControl = exports.hideFloaterLayer = exports.fetchUiMetadata = exports.fetchExtUiMetadata = exports.cleanActivatedCell = exports.activateCell = void 0;\n__webpack_require__(/*! core-js/modules/es.array.concat.js */ \"../../node_modules/core-js/modules/es.array.concat.js\");\n__webpack_require__(/*! core-js/modules/es.array.for-each.js */ \"../../node_modules/core-js/modules/es.array.for-each.js\");\n__webpack_require__(/*! core-js/modules/es.object.to-string.js */ \"../../node_modules/core-js/modules/es.object.to-string.js\");\n__webpack_require__(/*! core-js/modules/web.dom-collections.for-each.js */ \"../../node_modules/core-js/modules/web.dom-collections.for-each.js\");\nvar api = _interopRequireWildcard(__webpack_require__(/*! ../../designer/utils/api */ \"./src/designer/utils/api.js\"));\nvar _actionNames = __webpack_require__(/*! ../constants/actionNames */ \"./src/workflow/constants/actionNames.js\");\nvar _constants = __webpack_require__(/*! ../constants */ \"./src/workflow/constants/index.js\");\nfunction _getRequireWildcardCache(e) { if (\"function\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return { \"default\": e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\"default\" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n[\"default\"] = e, t && t.set(e, n), n; }\nvar setUiMetadata = exports.setUiMetadata = function setUiMetadata(metadata) {\n  return {\n    type: _actionNames.set_ui_metadata,\n    metadata: metadata\n  };\n};\nvar updateUiMetadata = exports.updateUiMetadata = function updateUiMetadata(metadata) {\n  return {\n    type: _actionNames.update_ui_metadata,\n    metadata: metadata\n  };\n};\n\n//获取ui控件配置文件\nvar fetchUiMetadata = exports.fetchUiMetadata = function fetchUiMetadata(modelType, modelVer, callback) {\n  return function (dispatch) {\n    api.getUiMetadata(modelType).then(function (json) {\n      dispatch(setUiMetadata(json));\n      if (typeof callback === \"function\") {\n        callback();\n      }\n      //加载扩展分组\n      var catgs = json.Categories;\n      if (catgs) {\n        var len = catgs.length;\n        while (len--) {\n          if (catgs[len].Id === _constants.EXTENDED_CONTROL) {\n            var name = catgs[len].Name;\n            if (name) {\n              var extMds = name.split(';');\n              extMds.forEach(function (md) {\n                //TODO: version\n                dispatch(fetchExtUiMetadata(md, null));\n              });\n            }\n            break;\n          }\n        }\n      }\n      var storeKey = \"\".concat(_constants.STORE_KEY_PREFIX, \".\").concat(modelType, \".\").concat(modelVer);\n      window.localStorage[storeKey] = JSON.stringify(json);\n    })[\"catch\"](function (error) {\n      console.error(error.message, error.stack);\n    });\n  };\n};\n\n//加载并合并扩展控件\nvar fetchExtUiMetadata = exports.fetchExtUiMetadata = function fetchExtUiMetadata(modelType, modelVer) {\n  return function (dispatch) {\n    api.getUiMetadata(modelType).then(function (json) {\n      dispatch(updateUiMetadata(json));\n    })[\"catch\"](function (error) {\n      console.error(error.message, error.stack);\n    });\n  };\n};\n\n//选中元素\nvar setSelectControl = exports.setSelectControl = function setSelectControl(_ref) {\n  var id = _ref.id,\n    group = _ref.group,\n    ctrlType = _ref.ctrlType,\n    _ref$collapsed = _ref.collapsed,\n    collapsed = _ref$collapsed === void 0 ? false : _ref$collapsed;\n  return {\n    type: _actionNames.set_select_control,\n    id: id,\n    group: group,\n    ctrlType: ctrlType,\n    collapsed: collapsed\n  };\n};\n\n//修改元素属性\nvar setUpdateControl = exports.setUpdateControl = function setUpdateControl(_ref2) {\n  var id = _ref2.id,\n    propName = _ref2.propName,\n    value = _ref2.value;\n  return {\n    type: _actionNames.set_update_control,\n    id: id,\n    propName: propName,\n    value: value\n  };\n};\n\n//查看流程图选中元素\nvar activateCell = exports.activateCell = function activateCell(_ref3) {\n  var id = _ref3.id,\n    procInstId = _ref3.procInstId,\n    billId = _ref3.billId,\n    title = _ref3.title,\n    showRecords = _ref3.showRecords;\n  return {\n    type: _actionNames.activate_cell,\n    id: id,\n    procInstId: procInstId,\n    billId: billId,\n    title: title,\n    showRecords: showRecords\n  };\n};\n\n//显示浮动层\nvar showFloatLayer = exports.showFloatLayer = function showFloatLayer(_ref4) {\n  var id = _ref4.id,\n    procInstId = _ref4.procInstId,\n    billId = _ref4.billId,\n    title = _ref4.title,\n    left = _ref4.left,\n    top = _ref4.top,\n    showFloatLayer = _ref4.showFloatLayer,\n    pageId = _ref4.pageId;\n  return {\n    type: _actionNames.show_floatlayer,\n    id: id,\n    procInstId: procInstId,\n    billId: billId,\n    title: title,\n    left: left,\n    top: top,\n    showFloatLayer: showFloatLayer,\n    pageId: pageId\n  };\n};\n\n//隐藏浮动层\nvar hideFloaterLayer = exports.hideFloaterLayer = function hideFloaterLayer(_ref5) {\n  var showFloatLayer = _ref5.showFloatLayer;\n  return {\n    type: _actionNames.hide_floatlayer,\n    showFloatLayer: showFloatLayer\n  };\n};\n\n//清除节点的选中状态\nvar cleanActivatedCell = exports.cleanActivatedCell = function cleanActivatedCell() {\n  return {\n    type: _actionNames.clean_activated\n  };\n};\n\n//# sourceURL=webpack://bos-platform/./src/workflow/actions/index.js?");

/***/ }),

/***/ "./src/workflow/actions/workflowAction.js":
/*!************************************************!*\
  !*** ./src/workflow/actions/workflowAction.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\n__webpack_require__(/*! core-js/modules/es.symbol.js */ \"../../node_modules/core-js/modules/es.symbol.js\");\n__webpack_require__(/*! core-js/modules/es.symbol.description.js */ \"../../node_modules/core-js/modules/es.symbol.description.js\");\n__webpack_require__(/*! core-js/modules/es.symbol.iterator.js */ \"../../node_modules/core-js/modules/es.symbol.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.array.iterator.js */ \"../../node_modules/core-js/modules/es.array.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\n__webpack_require__(/*! core-js/modules/es.object.get-own-property-descriptor.js */ \"../../node_modules/core-js/modules/es.object.get-own-property-descriptor.js\");\n__webpack_require__(/*! core-js/modules/es.object.to-string.js */ \"../../node_modules/core-js/modules/es.object.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.string.iterator.js */ \"../../node_modules/core-js/modules/es.string.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.weak-map.js */ \"../../node_modules/core-js/modules/es.weak-map.js\");\n__webpack_require__(/*! core-js/modules/web.dom-collections.iterator.js */ \"../../node_modules/core-js/modules/web.dom-collections.iterator.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.property_editor_click = property_editor_click;\nexports.setPostData = setPostData;\nvar _immutable = _interopRequireDefault(__webpack_require__(/*! immutable */ \"webpack/sharing/consume/default/immutable/immutable?f2ca\"));\nvar action = _interopRequireWildcard(__webpack_require__(/*! ../../action/action */ \"./src/action/action.js\"));\nfunction _getRequireWildcardCache(e) { if (\"function\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return { \"default\": e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\"default\" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n[\"default\"] = e, t && t.set(e, n), n; }\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction property_editor_click(model, methodName) {\n  var args = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  return action.invokeControlService(model, methodName, args);\n}\nfunction setPostData(model, data) {\n  return action.updateControl(model, data, false);\n}\n\n//# sourceURL=webpack://bos-platform/./src/workflow/actions/workflowAction.js?");

/***/ }),

/***/ "./src/workflow/components/ApprovalHistoryRecord.js":
/*!**********************************************************!*\
  !*** ./src/workflow/components/ApprovalHistoryRecord.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\n__webpack_require__(/*! core-js/modules/es.symbol.iterator.js */ \"../../node_modules/core-js/modules/es.symbol.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.symbol.to-primitive.js */ \"../../node_modules/core-js/modules/es.symbol.to-primitive.js\");\n__webpack_require__(/*! core-js/modules/es.array.iterator.js */ \"../../node_modules/core-js/modules/es.array.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.date.to-primitive.js */ \"../../node_modules/core-js/modules/es.date.to-primitive.js\");\n__webpack_require__(/*! core-js/modules/es.number.constructor.js */ \"../../node_modules/core-js/modules/es.number.constructor.js\");\n__webpack_require__(/*! core-js/modules/es.object.assign.js */ \"../../node_modules/core-js/modules/es.object.assign.js\");\n__webpack_require__(/*! core-js/modules/es.object.create.js */ \"../../node_modules/core-js/modules/es.object.create.js\");\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\n__webpack_require__(/*! core-js/modules/es.object.get-own-property-descriptor.js */ \"../../node_modules/core-js/modules/es.object.get-own-property-descriptor.js\");\n__webpack_require__(/*! core-js/modules/es.object.get-prototype-of.js */ \"../../node_modules/core-js/modules/es.object.get-prototype-of.js\");\n__webpack_require__(/*! core-js/modules/es.reflect.construct.js */ \"../../node_modules/core-js/modules/es.reflect.construct.js\");\n__webpack_require__(/*! core-js/modules/es.string.iterator.js */ \"../../node_modules/core-js/modules/es.string.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.weak-map.js */ \"../../node_modules/core-js/modules/es.weak-map.js\");\n__webpack_require__(/*! core-js/modules/web.dom-collections.iterator.js */ \"../../node_modules/core-js/modules/web.dom-collections.iterator.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.symbol.js */ \"../../node_modules/core-js/modules/es.symbol.js\");\n__webpack_require__(/*! core-js/modules/es.symbol.description.js */ \"../../node_modules/core-js/modules/es.symbol.description.js\");\n__webpack_require__(/*! core-js/modules/es.array.concat.js */ \"../../node_modules/core-js/modules/es.array.concat.js\");\n__webpack_require__(/*! core-js/modules/es.array.map.js */ \"../../node_modules/core-js/modules/es.array.map.js\");\n__webpack_require__(/*! core-js/modules/es.array.splice.js */ \"../../node_modules/core-js/modules/es.array.splice.js\");\n__webpack_require__(/*! core-js/modules/es.date.to-string.js */ \"../../node_modules/core-js/modules/es.date.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.function.bind.js */ \"../../node_modules/core-js/modules/es.function.bind.js\");\n__webpack_require__(/*! core-js/modules/es.object.set-prototype-of.js */ \"../../node_modules/core-js/modules/es.object.set-prototype-of.js\");\n__webpack_require__(/*! core-js/modules/es.object.to-string.js */ \"../../node_modules/core-js/modules/es.object.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.promise.js */ \"../../node_modules/core-js/modules/es.promise.js\");\n__webpack_require__(/*! core-js/modules/es.regexp.exec.js */ \"../../node_modules/core-js/modules/es.regexp.exec.js\");\n__webpack_require__(/*! core-js/modules/es.regexp.to-string.js */ \"../../node_modules/core-js/modules/es.regexp.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.string.replace.js */ \"../../node_modules/core-js/modules/es.string.replace.js\");\n__webpack_require__(/*! core-js/modules/es.string.trim.js */ \"../../node_modules/core-js/modules/es.string.trim.js\");\n__webpack_require__(/*! core-js/modules/web.timers.js */ \"../../node_modules/core-js/modules/web.timers.js\");\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"webpack/sharing/consume/default/react/react?dca2\"));\nvar _propTypes = _interopRequireDefault(__webpack_require__(/*! prop-types */ \"../../node_modules/prop-types/index.js\"));\nvar _ApprovalHistoryRecord2 = _interopRequireDefault(__webpack_require__(/*! ../css/ApprovalHistoryRecord.less */ \"./src/workflow/css/ApprovalHistoryRecord.less\"));\nvar _immutable = __webpack_require__(/*! immutable */ \"webpack/sharing/consume/default/immutable/immutable?f2ca\");\nvar _moren = _interopRequireDefault(__webpack_require__(/*! ../images/moren2.png */ \"./src/workflow/images/moren2.png\"));\nvar _moren2 = _interopRequireDefault(__webpack_require__(/*! ../images/moren.png */ \"./src/workflow/images/moren.png\"));\nvar _auto_audit = _interopRequireDefault(__webpack_require__(/*! ../images/auto_audit.png */ \"./src/workflow/images/auto_audit.png\"));\nvar _callActivity = _interopRequireDefault(__webpack_require__(/*! ../images/callActivity.png */ \"./src/workflow/images/callActivity.png\"));\nvar _classnames = _interopRequireDefault(__webpack_require__(/*! classnames */ \"../../node_modules/classnames/index.js\"));\nvar _workflowUtil = __webpack_require__(/*! ../util/workflowUtil */ \"./src/workflow/util/workflowUtil.js\");\nvar _intlApi = __webpack_require__(/*! ../../i18n/intlApi */ \"./src/i18n/intlApi.js\");\nvar _formservice = _interopRequireDefault(__webpack_require__(/*! ../../api/formservice */ \"./src/api/formservice.js\"));\nvar _appModelFunction = __webpack_require__(/*! ../../model/appModelFunction */ \"./src/model/appModelFunction.js\");\nvar _GlobalDataCacher = __webpack_require__(/*! @/model/GlobalDataCacher */ \"./src/model/GlobalDataCacher.js\");\nvar _symbolConst = __webpack_require__(/*! @/constant/symbolConst */ \"./src/constant/symbolConst.js\");\nvar _attachmentConst = __webpack_require__(/*! @/constant/attachmentConst */ \"./src/constant/attachmentConst.js\");\nvar _componentutil = __webpack_require__(/*! @/util/componentutil */ \"./src/util/componentutil.js\");\nvar _approvalRecordAction = _interopRequireWildcard(__webpack_require__(/*! ../actions/approvalRecordAction */ \"./src/workflow/actions/approvalRecordAction.js\"));\nvar _mxGraphConstant = __webpack_require__(/*! ../constants/mxGraphConstant */ \"./src/workflow/constants/mxGraphConstant.js\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction _getRequireWildcardCache(e) { if (\"function\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return { \"default\": e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\"default\" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n[\"default\"] = e, t && t.set(e, n), n; }\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); } /*\n * 流程图查看审批记录组件,为了和审批记录组件区分，命名为：ApprovalHistoryRecord\n */ //TODO:平台暂不支持Svg打包，暂使用base64\n//import icon_retract_normal from '../images/retract_normal.svg';\nvar ApprovalHistoryRecord = /*#__PURE__*/function (_Component) {\n  _inherits(ApprovalHistoryRecord, _Component);\n  function ApprovalHistoryRecord(props) {\n    var _this;\n    _classCallCheck(this, ApprovalHistoryRecord);\n    _this = _callSuper(this, ApprovalHistoryRecord, [props]);\n    _this.state = {\n      show: false,\n      showAuditPoint: false,\n      showHistoryState: (0, _immutable.Map)({}),\n      latestRecord: null,\n      historyRecords: []\n    };\n    return _this;\n  }\n  _createClass(ApprovalHistoryRecord, [{\n    key: \"componentWillReceiveProps\",\n    value: function componentWillReceiveProps(nextProps) {\n      this.setState({\n        show: !!nextProps.showRecords\n      });\n    }\n  }, {\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(nextProps, nextState) {\n      return !(0, _immutable.is)(this.state.show, nextState.show) || !(0, _immutable.is)(this.state.showAuditPoint, nextState.showAuditPoint) || !(0, _immutable.is)(this.state.showHistoryState, nextState.showHistoryState) || !(0, _immutable.is)(this.props.approvalRecords, nextProps.approvalRecords) || !(0, _immutable.is)(this.props.activatedCell, nextProps.activatedCell) || !(0, _immutable.is)(this.props.coordinateRecords, nextProps.coordinateRecords);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var display = this.state.show ? 'flex' : 'none';\n      var title = '';\n      var cell = this.props.activatedCell;\n      var latestRecords = null;\n      var historyRecords = null;\n      var showHistory = false;\n      if (cell && cell.size && this.state.show) {\n        title = cell.get('title');\n        var id = cell.get('id');\n        var approvalRecords = this.props.approvalRecords;\n        showHistory = !!this.state.showHistoryState.get(id);\n        //最新审批记录数据\n        latestRecords = this.getApprovalRecords(approvalRecords, id, title, false);\n        if (showHistory) {\n          //旧的审批记录数据\n          historyRecords = this.getApprovalRecords(approvalRecords, id, title, true);\n        }\n      } else {\n        display = 'none';\n      }\n      return /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _ApprovalHistoryRecord2[\"default\"]['approval-history-record'],\n        style: {\n          display: display\n        }\n      }, /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _ApprovalHistoryRecord2[\"default\"]['record-header']\n      }, /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _ApprovalHistoryRecord2[\"default\"]['record-title']\n      }, (0, _intlApi.getLangMsg)({\n        key: \"ApprovalHistoryRecord.jiedianxiangqing\"\n      })), /*#__PURE__*/_react[\"default\"].createElement(\"img\", {\n        className: _ApprovalHistoryRecord2[\"default\"]['icon-retract'],\n        src: _mxGraphConstant.ICON_RETRACT,\n        alt: (0, _intlApi.getLangMsg)({\n          key: \"ApprovalHistoryRecord.shouqi\"\n        }),\n        title: (0, _intlApi.getLangMsg)({\n          key: \"ApprovalHistoryRecord.shouqi\"\n        }),\n        onClick: this.handleRetractClick.bind(this),\n        onMouseOut: this.handleRetractHover.bind(this),\n        onMouseOver: this.handleRetractHover.bind(this)\n      }), /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _ApprovalHistoryRecord2[\"default\"]['backToParentProcess'],\n        style: {\n          display: this.props.initialData.superProcInstId ? '' : 'none'\n        },\n        onClick: this.backToParentProcess.bind(this)\n      }, (0, _intlApi.getLangMsg)({\n        key: \"ApprovalHistoryRecord.fanhuifuliucheng\"\n      }))), /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _ApprovalHistoryRecord2[\"default\"].records\n      }, _react[\"default\"].Children.toArray(latestRecords), /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _ApprovalHistoryRecord2[\"default\"]['historic-record']\n      }, (0, _intlApi.getLangMsg)({\n        key: \"ApprovalHistoryRecord.jiudejilu\"\n      }), /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n        className: _ApprovalHistoryRecord2[\"default\"]['link-control'],\n        onClick: this.switchShowRecords.bind(this)\n      }, showHistory ? (0, _intlApi.getLangMsg)({\n        key: \"ApprovalHistoryRecord.yincang\"\n      }) : (0, _intlApi.getLangMsg)({\n        key: \"ApprovalHistoryRecord.zhankai\"\n      }))), /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _ApprovalHistoryRecord2[\"default\"]['historic-records'],\n        style: {\n          display: showHistory ? 'block' : 'none'\n        }\n      }, historyRecords)));\n    }\n  }, {\n    key: \"getApprovalRecords\",\n    value: function getApprovalRecords(approvalRecords, id, title, historic) {\n      var records = [];\n      var recordDatas = null;\n      var key = null;\n      if (!historic) {\n        key = \"\".concat(id, \"-latestRecords\");\n      } else {\n        key = \"\".concat(id, \"-historyRecords\");\n      }\n      if (approvalRecords && (recordDatas = approvalRecords.get(key))) {\n        var approvalRecordDatas = recordDatas['datas'];\n        if (!historic) {\n          records.push( /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n            className: _ApprovalHistoryRecord2[\"default\"]['latest-record']\n          }, (0, _intlApi.getLangMsg)({\n            key: \"ApprovalHistoryRecord.zuixinjilu\"\n          })));\n        }\n        if (approvalRecordDatas && approvalRecordDatas.length) {\n          for (var i = 0; i < approvalRecordDatas.length; i++) {\n            var isGroup = false;\n            if (historic && i + 1 < approvalRecordDatas.length && approvalRecordDatas[i].groupId != approvalRecordDatas[i + 1].groupId) {\n              isGroup = true;\n            }\n            var isFirstYZJNode = false;\n            if (approvalRecordDatas.length > 1 && approvalRecordDatas[i].avatar == undefined) {\n              isFirstYZJNode = true;\n            }\n            records.push( /*#__PURE__*/_react[\"default\"].createElement(ApprovalHistoryItem, _extends({\n              title: title,\n              key: \"\".concat(!historic ? '' : 'history-', \"record-\").concat(i),\n              isFirstYZJNode: isFirstYZJNode,\n              isGroup: isGroup,\n              transferName: recordDatas.transferName,\n              coordinateName: recordDatas.coordinateName,\n              historic: historic,\n              config: this.props.config,\n              activatedCell: this.props.activatedCell,\n              coordinateRecords: this.props.coordinateRecords\n            }, approvalRecordDatas[i])));\n          }\n        } else {\n          records.push( /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n            className: _ApprovalHistoryRecord2[\"default\"]['no-record']\n          }, (0, _intlApi.getLangMsg)({\n            key: \"ApprovalHistoryRecord.norecords\"\n          })));\n        }\n        if (!historic) {\n          var showCoordinate = recordDatas['showCoordinate'];\n          if (showCoordinate) {\n            records.push( /*#__PURE__*/_react[\"default\"].createElement(CoordinateRecords, {\n              key: \"coordinate-recoredz\",\n              activatedCell: this.props.activatedCell,\n              transferName: recordDatas.transferName,\n              coordinateName: recordDatas.coordinateName,\n              coordinateRecords: this.props.coordinateRecords\n            }));\n          }\n        }\n        //自动协办记录\n        var showAutoCoordinate = recordDatas['showAutoCoordinate'];\n        if (showAutoCoordinate) {\n          var groupId = recordDatas['autoCoordinateGroupId'];\n          records.push( /*#__PURE__*/_react[\"default\"].createElement(AutoCoordinateRecords, {\n            key: \"auto-coordinate-recoredz\",\n            groupId: groupId,\n            transferName: recordDatas.transferName,\n            coordinateName: recordDatas.coordinateName,\n            coordinateRecords: this.props.coordinateRecords\n          }));\n        }\n\n        //审批要点\n        if (!historic) {\n          //审批要点标题\n          var auditPointsTitle = recordDatas['datas-auditPointsTitle'] || (0, _intlApi.getLangMsg)({\n            key: \"ApprovalHistoryRecord.shenpiyaodian\"\n          });\n          var auditPointRecords = recordDatas['datas-auditPoints'];\n          if (auditPointRecords && auditPointRecords.length) {\n            records.push( /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n              className: _ApprovalHistoryRecord2[\"default\"]['auditpoints-title']\n            }, auditPointsTitle, /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n              className: _ApprovalHistoryRecord2[\"default\"]['link-control'],\n              onClick: this.switchShowAuditPointRecords.bind(this)\n            }, !this.state.showAuditPoint ? (0, _intlApi.getLangMsg)({\n              key: \"ApprovalHistoryRecord.zhankai\"\n            }) : (0, _intlApi.getLangMsg)({\n              key: \"ApprovalHistoryRecord.yincang\"\n            }))));\n            records.push( /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n              style: {\n                display: this.state.showAuditPoint ? 'block' : 'none'\n              }\n            }, this.addAuditPointItem(auditPointRecords, title)));\n          }\n        }\n        return records;\n      } else {\n        this.loadApprovalRecords(historic);\n      }\n    }\n  }, {\n    key: \"addAuditPointItem\",\n    value: function addAuditPointItem(auditPointRecords, title) {\n      var items = [];\n      for (var i = 0; i < auditPointRecords.length; i++) {\n        items.push( /*#__PURE__*/_react[\"default\"].createElement(AuditPointHistoryItem, _extends({\n          title: title,\n          key: 'latest-'.concat(\"record-\", i)\n        }, auditPointRecords[i])));\n      }\n      return items;\n    }\n  }, {\n    key: \"loadApprovalRecords\",\n    value: function loadApprovalRecords(historic) {\n      var cell = this.props.activatedCell;\n      this.context.invokeAction(this.context.model, 'loadApprovalRecords', [cell.get('id'), cell.get('procInstId'), cell.get('billId'), historic]);\n    }\n  }, {\n    key: \"handleRetractHover\",\n    value: function handleRetractHover(evt) {\n      evt.target.src = \"mouseover\" === evt.type ? _mxGraphConstant.ICON_RETRACT_HOVER : _mxGraphConstant.ICON_RETRACT;\n    }\n  }, {\n    key: \"handleRetractClick\",\n    value: function handleRetractClick(evt) {\n      var _this2 = this;\n      this.setState({\n        show: !this.state.show\n      });\n      setTimeout(function () {\n        _this2.props.refreshEditor(true, false);\n      }, 0);\n    }\n  }, {\n    key: \"switchShowRecords\",\n    value: function switchShowRecords(evt) {\n      var cell = this.props.activatedCell;\n      if (cell) {\n        this.setState({\n          showHistoryState: this.state.showHistoryState.update(cell.get('id'), false, function (value) {\n            return !value;\n          })\n        });\n      }\n    }\n  }, {\n    key: \"switchShowAuditPointRecords\",\n    value: function switchShowAuditPointRecords(evt) {\n      this.setState({\n        showAuditPoint: !this.state.showAuditPoint\n      });\n    }\n  }, {\n    key: \"backToParentProcess\",\n    value: function backToParentProcess(evt) {\n      this.context.invokeAction(this.context.model, 'backToParentProcess', [this.props.initialData.superProcInstId, this.props.config.formId]);\n    }\n  }]);\n  return ApprovalHistoryRecord;\n}(_react.Component);\nApprovalHistoryRecord.contextTypes = {\n  invokeAction: _propTypes[\"default\"].func,\n  model: _propTypes[\"default\"].object\n};\nvar ApprovalHistoryItem = /*#__PURE__*/function (_Component2) {\n  _inherits(ApprovalHistoryItem, _Component2);\n  function ApprovalHistoryItem(props) {\n    var _this3;\n    _classCallCheck(this, ApprovalHistoryItem);\n    _this3 = _callSuper(this, ApprovalHistoryItem, [props]);\n    _this3.state = {\n      showCoordinate: false\n    };\n    _this3.signature = undefined;\n    _this3.subCrossTenantInfo = undefined;\n    return _this3;\n  }\n  _createClass(ApprovalHistoryItem, [{\n    key: \"render\",\n    value: function render() {\n      var _this4 = this;\n      var fileServer = this.context.model.getFormConfig();\n      var image = this.props.avatar ? this.props.avatar : this.props.userStr == '-1' ? _auto_audit[\"default\"] : _moren2[\"default\"];\n      if (this.props.callActivity) {\n        image = _callActivity[\"default\"];\n      }\n      if (this.props.isFirstYZJNode) {\n        image = _moren[\"default\"];\n      }\n      var avatar = (0, _workflowUtil.getImageUrl)(image, fileServer);\n      var title = \"\".concat(this.props.activityName || '', \" \").concat(this.props.assignee || '');\n      var message = this.props.message;\n      var sanitizeResult = (0, _workflowUtil.sanitize)(this.props.result);\n      var messageDiv = null;\n      var isPC = this.context.model.getDataProperty('isPC');\n      if (message) {\n        var signature = (0, _workflowUtil.createSignatureApprovalRecord)(false, isPC, this.props.signature);\n        var ret = [];\n        if (this.props.callActivity) {\n          message = (0, _workflowUtil.sanitize)(message);\n          ret.push( /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n            className: (0, _classnames[\"default\"])(_ApprovalHistoryRecord2[\"default\"]['comment-content'], _ApprovalHistoryRecord2[\"default\"]['comment-callActivity']),\n            onClick: this.showChildProcessInfo.bind(this),\n            dangerouslySetInnerHTML: {\n              __html: message\n            }\n          }));\n        } else {\n          var strs = message.split('<br/>');\n          if (strs.length > 1) {\n            for (var i = 0; i < strs.length; i++) {\n              var str = (0, _workflowUtil.sanitize)(strs[i]);\n              ret.push( /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n                title: str,\n                className: _ApprovalHistoryRecord2[\"default\"][\"msg\"],\n                dangerouslySetInnerHTML: {\n                  __html: str\n                }\n              }));\n            }\n          } else {\n            message = (0, _workflowUtil.sanitize)(message);\n            ret.push( /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n              title: message,\n              className: _ApprovalHistoryRecord2[\"default\"][\"msg\"],\n              dangerouslySetInnerHTML: {\n                __html: message\n              }\n            }));\n          }\n        }\n        if (ret.length === 1) {\n          ret.push(signature);\n        } else if (ret.length > 1) {\n          ret.splice(ret.length - 1, 0, signature);\n        }\n        messageDiv = /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n          className: _ApprovalHistoryRecord2[\"default\"]['comment-content']\n        }, ret);\n      }\n      var marginBottom = \"0px\";\n      if (this.props.isGroup) {\n        marginBottom = \"10px\";\n      }\n      var attachmentClass = this.props.attachments && this.props.attachments.length > 0 ? \"block\" : \"none\";\n      var coordinateTitle = this.state.showCoordinate == true ? (0, _intlApi.getLangMsg)({\n        key: \"ApprovalHistoryRecord.shouqixieban\"\n      }).replace(/\\%s/, this.props.coordinateName) : this.props.coordinateName;\n      return /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        style: {\n          marginBottom: marginBottom\n        }\n      }, /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _ApprovalHistoryRecord2[\"default\"]['record-item']\n      }, /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _ApprovalHistoryRecord2[\"default\"].avatar\n      }, /*#__PURE__*/_react[\"default\"].createElement(\"img\", {\n        width: \"38px\",\n        height: \"38px\",\n        style: {\n          borderRadius: '50%'\n        },\n        alt: (0, _intlApi.getLangMsg)({\n          key: \"ApprovalHistoryRecord.yonghutouxiang\"\n        }),\n        src: avatar\n      })), /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _ApprovalHistoryRecord2[\"default\"].info\n      }, /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        title: title,\n        className: _ApprovalHistoryRecord2[\"default\"].assignee\n      }, title), /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _ApprovalHistoryRecord2[\"default\"].time\n      }, this.props.time), /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n        className: _ApprovalHistoryRecord2[\"default\"].result,\n        title: sanitizeResult,\n        dangerouslySetInnerHTML: {\n          __html: sanitizeResult\n        }\n      }), /*#__PURE__*/_react[\"default\"].createElement(\"img\", {\n        className: _ApprovalHistoryRecord2[\"default\"]['icon-comment'],\n        style: {\n          display: this.props.openId ? 'block' : 'none'\n        },\n        onClick: this.handleCommentClick.bind(this),\n        src: _mxGraphConstant.ICON_COMMENT,\n        onMouseOut: this.handleCommentHover.bind(this),\n        onMouseOver: this.handleCommentHover.bind(this)\n      }), messageDiv, /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _ApprovalHistoryRecord2[\"default\"].procAttach,\n        style: {\n          display: attachmentClass\n        }\n      }, this.props.attachments && this.props.attachments.length > 0 ? this.props.attachments.map(function (item, index) {\n        return /*#__PURE__*/_react[\"default\"].createElement(AttachmentItem, _extends({}, item, {\n          dispatch: _this4.context.dispatch,\n          model: _this4.context.model,\n          attachmentIds: _this4.props.state,\n          key: index\n        }));\n      }) : \"\"))), /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _ApprovalHistoryRecord2[\"default\"]['btn-panel']\n      }, this.props.userStr ? (0, _workflowUtil.createCustomizedLinks)(this.props, function (e, params) {\n        _this4.handleCustomLinkClick(_this4.context, params);\n      }) : \"\", this.props.coordinate ? /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n        onClick: this.switchCoordinate.bind(this)\n      }, coordinateTitle) : \"\", this.props.showTransferRecord ? /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n        onClick: this.showTransferRecord.bind(this)\n      }, (0, _intlApi.getLangMsg)({\n        key: \"ApprovalHistoryRecord.zhuangjiaolishi\"\n      }).replace(/\\%s/, this.props.transferName)) : \"\"), this.props.coordinate ? /*#__PURE__*/_react[\"default\"].createElement(CoordinateRecords, {\n        key: \"coordinate-recoreds\",\n        showCoordinate: this.state.showCoordinate,\n        transferName: this.props.transferName,\n        coordinateName: this.props.coordinateName,\n        userId: this.props.userId,\n        taskId: this.props.taskId,\n        coordinateRecords: this.props.coordinateRecords\n      }) : '');\n    }\n  }, {\n    key: \"handleCustomLinkClick\",\n    value: function handleCustomLinkClick(context, params) {\n      context.invokeAction(context.model, 'clickCustomizeLink', [params]);\n    }\n  }, {\n    key: \"handleCommentHover\",\n    value: function handleCommentHover(evt) {\n      if (this.props.openId) {\n        evt.target.src = \"mouseover\" === evt.type ? _mxGraphConstant.ICON_COMMENT_HOVER : _mxGraphConstant.ICON_COMMENT;\n      }\n    }\n  }, {\n    key: \"handleCommentClick\",\n    value: function handleCommentClick(evt) {\n      if (this.props.openId) {\n        this.context.invokeAction(this.context.model, 'openYzjChat', [[this.props.openId], this.props.assignee]);\n      }\n    }\n  }, {\n    key: \"showTransferRecord\",\n    value: function showTransferRecord(evt) {\n      this.context.invokeAction(this.context.model, 'showTransferRecord', [this.props.taskId, this.props.userStr, false]);\n    }\n  }, {\n    key: \"switchCoordinate\",\n    value: function switchCoordinate(evt) {\n      this.setState({\n        showCoordinate: !this.state.showCoordinate\n      });\n    }\n  }, {\n    key: \"showChildProcessInfo\",\n    value: function showChildProcessInfo(evt) {\n      this.context.invokeAction(this.context.model, 'showChildProcessInfo', [this.props.procInstId, this.props.config.formId, this.props.subCrossTenantInfo]);\n    }\n  }]);\n  return ApprovalHistoryItem;\n}(_react.Component);\nApprovalHistoryItem.contextTypes = {\n  dispatch: _propTypes[\"default\"].func,\n  invokeAction: _propTypes[\"default\"].func,\n  model: _propTypes[\"default\"].object\n};\nvar AutoCoordinateRecords = /*#__PURE__*/function (_Component3) {\n  _inherits(AutoCoordinateRecords, _Component3);\n  function AutoCoordinateRecords(props) {\n    var _this5;\n    _classCallCheck(this, AutoCoordinateRecords);\n    _this5 = _callSuper(this, AutoCoordinateRecords, [props]);\n    _this5.state = {\n      autoShowCoordinate: false\n    };\n    return _this5;\n  }\n  _createClass(AutoCoordinateRecords, [{\n    key: \"render\",\n    value: function render() {\n      var _this6 = this;\n      var coordinateDetailStyle = this.state.autoShowCoordinate == true ? 'block' : 'none';\n      var coordinateRecoreds = this.showAutoCoordinateInfo(this.context.model, this.props.groupId);\n      var coordinateTitle = this.state.autoShowCoordinate == true ? (0, _intlApi.getLangMsg)({\n        key: \"ApprovalHistoryRecord.shouqizidongxieban\"\n      }).replace(/\\%s/, this.props.coordinateName) : (0, _intlApi.getLangMsg)({\n        key: \"ApprovalHistoryRecord.zidongxieban\"\n      }).replace(/\\%s/, this.props.coordinateName);\n      return /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _ApprovalHistoryRecord2[\"default\"]['historic-coordinate']\n      }, /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _ApprovalHistoryRecord2[\"default\"]['title'],\n        onClick: this.switchAutoCoordinate.bind(this)\n      }, coordinateTitle), coordinateRecoreds && coordinateRecoreds.length > 0 ? /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _ApprovalHistoryRecord2[\"default\"]['detail'],\n        style: {\n          display: coordinateDetailStyle\n        }\n      }, /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _ApprovalHistoryRecord2[\"default\"]['headline']\n      }, coordinateRecoreds.length, (0, _intlApi.getLangMsg)({\n        key: \"ApprovalHistoryRecord.tiaozidongxiebanjianyi\"\n      }).replace(/\\%s/, this.props.coordinateName)), coordinateRecoreds.map(function (item, index) {\n        return /*#__PURE__*/_react[\"default\"].createElement(CoordinateRecordItem, _extends({}, item, {\n          transferName: _this6.props.transferName,\n          coordinateName: _this6.props.coordinateName,\n          key: index\n        }));\n      })) : '');\n    }\n  }, {\n    key: \"showAutoCoordinateInfo\",\n    value: function showAutoCoordinateInfo(model, groupId) {\n      if (this.props.coordinateRecords == undefined) {\n        this.context.invokeAction(this.context.model, 'showAutoCoordinateInfo', [groupId]);\n        return [];\n      }\n      var coordinateRecoreds = this.props.coordinateRecords[\"autoCoordinate_\" + groupId];\n      if (coordinateRecoreds == undefined) {\n        this.context.invokeAction(this.context.model, 'showAutoCoordinateInfo', [groupId]);\n        return [];\n      } else {\n        return coordinateRecoreds;\n      }\n    }\n  }, {\n    key: \"switchAutoCoordinate\",\n    value: function switchAutoCoordinate(evt) {\n      this.setState({\n        autoShowCoordinate: !this.state.autoShowCoordinate\n      });\n    }\n  }]);\n  return AutoCoordinateRecords;\n}(_react.Component);\nAutoCoordinateRecords.contextTypes = {\n  invokeAction: _propTypes[\"default\"].func,\n  model: _propTypes[\"default\"].object\n};\nvar CoordinateRecords = /*#__PURE__*/function (_Component4) {\n  _inherits(CoordinateRecords, _Component4);\n  function CoordinateRecords(props) {\n    _classCallCheck(this, CoordinateRecords);\n    return _callSuper(this, CoordinateRecords, [props]);\n  }\n  _createClass(CoordinateRecords, [{\n    key: \"render\",\n    value: function render() {\n      var _this7 = this;\n      var coordinateDetailStyle = this.props.showCoordinate == true ? 'block' : 'none';\n      var coordinateRecoreds = [];\n      if (this.props.activatedCell == undefined) {\n        coordinateRecoreds = this.getCoordinateRecoreds(this.context.model, this.props.taskId, this.props.userId);\n      } else {\n        coordinateRecoreds = this.getCoordinateRecoredsByProcInstIsd(this.context.model, this.props.activatedCell);\n      }\n      return /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _ApprovalHistoryRecord2[\"default\"]['historic-coordinate']\n      }, coordinateRecoreds && coordinateRecoreds.length > 0 ? /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _ApprovalHistoryRecord2[\"default\"]['detail'],\n        style: {\n          display: coordinateDetailStyle\n        }\n      }, /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _ApprovalHistoryRecord2[\"default\"]['headline']\n      }, coordinateRecoreds.length, (0, _intlApi.getLangMsg)({\n        key: \"ApprovalHistoryRecord.tiaoxiebanjianyi\"\n      }).replace(/\\%s/, this.props.coordinateName)), coordinateRecoreds.map(function (item, index) {\n        return /*#__PURE__*/_react[\"default\"].createElement(CoordinateRecordItem, _extends({}, item, {\n          transferName: _this7.props.transferName,\n          coordinateName: _this7.props.coordinateName,\n          key: index\n        }));\n      })) : '');\n    }\n  }, {\n    key: \"getCoordinateRecoredsByProcInstIsd\",\n    value: function getCoordinateRecoredsByProcInstIsd(model, activatedCell) {\n      var cellId = activatedCell.get('id');\n      var procInstId = activatedCell.get('procInstId');\n      if (this.props.coordinateRecords == undefined) {\n        this.context.invokeAction(this.context.model, 'showCoordinateInfoByProcInstIsd', [procInstId, cellId]);\n        return [];\n      }\n      var coordinateRecoreds = this.props.coordinateRecords[\"coordinate_\" + procInstId + \"_\" + cellId];\n      if (coordinateRecoreds == undefined) {\n        this.context.invokeAction(this.context.model, 'showCoordinateInfoByProcInstIsd', [procInstId, cellId]);\n        return [];\n      } else {\n        return coordinateRecoreds;\n      }\n    }\n  }, {\n    key: \"getCoordinateRecoreds\",\n    value: function getCoordinateRecoreds(model, taskId, userId, activatedCell) {\n      if (this.props.coordinateRecords == undefined) {\n        this.context.invokeAction(this.context.model, 'showCoordinateInfo', [this.props.taskId, this.props.userId + \"\"]);\n        return [];\n      }\n      var coordinateRecoreds = this.props.coordinateRecords[\"coordinate_\" + taskId + \"_\" + userId];\n      if (coordinateRecoreds == undefined) {\n        this.context.invokeAction(this.context.model, 'showCoordinateInfo', [this.props.taskId, this.props.userId + \"\"]);\n        return [];\n      } else {\n        return coordinateRecoreds;\n      }\n    }\n  }]);\n  return CoordinateRecords;\n}(_react.Component);\nCoordinateRecords.contextTypes = {\n  invokeAction: _propTypes[\"default\"].func,\n  model: _propTypes[\"default\"].object\n};\nvar CoordinateRecordItem = /*#__PURE__*/function (_Component5) {\n  _inherits(CoordinateRecordItem, _Component5);\n  function CoordinateRecordItem(props) {\n    _classCallCheck(this, CoordinateRecordItem);\n    return _callSuper(this, CoordinateRecordItem, [props]);\n  }\n  _createClass(CoordinateRecordItem, [{\n    key: \"render\",\n    value: function render() {\n      var _this8 = this;\n      var coordinateName = this.props.assignee || \"\";\n      if (this.props.time == \"\" || this.props.time == undefined) {\n        coordinateName = this.props.assignee.split(\" \")[1].trim();\n      }\n      var coordinatingClass = this.props.time == \"\" || this.props.time == undefined ? \"block\" : \"none\";\n      var attachmentClass = this.props.attachments && this.props.attachments.length > 0 ? \"block\" : \"none\";\n      var fileServer = this.context.model.getFormConfig();\n      var userAvatar = (0, _workflowUtil.getImageUrl)(this.props.avatar, fileServer);\n      var isPC = this.context.model.getDataProperty('isPC');\n      return /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _ApprovalHistoryRecord2[\"default\"][\"coordinateRecord\"]\n      }, /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        style: {\n          display: \"flex\"\n        }\n      }, /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _ApprovalHistoryRecord2[\"default\"][\"left\"]\n      }, /*#__PURE__*/_react[\"default\"].createElement(\"img\", {\n        className: _ApprovalHistoryRecord2[\"default\"][\"avatar\"],\n        alt: (0, _intlApi.getLangMsg)({\n          key: \"ApprovalHistoryRecord.yonghutouxiang\"\n        }),\n        src: userAvatar == \"\" || userAvatar == undefined ? _moren2[\"default\"] : userAvatar\n      })), /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _ApprovalHistoryRecord2[\"default\"][\"right\"]\n      }, /*#__PURE__*/_react[\"default\"].createElement(\"div\", null, /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _ApprovalHistoryRecord2[\"default\"][\"coordinateName\"]\n      }, /*#__PURE__*/_react[\"default\"].createElement(\"span\", null, this.props.ownerName), /*#__PURE__*/_react[\"default\"].createElement(\"span\", null, (0, _intlApi.getLangMsg)({\n        key: \"ApprovalHistoryRecord.yaoqingkongge\"\n      })), /*#__PURE__*/_react[\"default\"].createElement(\"span\", null, coordinateName), /*#__PURE__*/_react[\"default\"].createElement(\"span\", null, (0, _intlApi.getLangMsg)({\n        key: \"ApprovalHistoryRecord.xiebankongge\"\n      }).replace(/\\%s/, this.props.coordinateName)), /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n        className: _ApprovalHistoryRecord2[\"default\"][\"coordinating\"],\n        style: {\n          display: coordinatingClass\n        }\n      }, (0, _intlApi.getLangMsg)({\n        key: \"ApprovalHistoryRecord.zhengzaixieban\"\n      }).replace(/\\%s/, this.props.coordinateName))), /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n        className: _ApprovalHistoryRecord2[\"default\"][\"time\"]\n      }, this.props.time)), /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _ApprovalHistoryRecord2[\"default\"][\"message\"]\n      }, (0, _workflowUtil.crateCoordinateInviteOpinions)(this.props)), (0, _workflowUtil.createSignatureApprovalRecord)(false, isPC, this.props.signature))), /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _ApprovalHistoryRecord2[\"default\"]['btn-panel']\n      }, this.props.showTransferRecord ? /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n        onClick: this.showTransferRecord.bind(this)\n      }, (0, _intlApi.getLangMsg)({\n        key: \"ApprovalHistoryRecord.zhuangjiaolishi\"\n      }).replace(/\\%s/, this.props.transferName)) : \"\"), /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _ApprovalHistoryRecord2[\"default\"][\"fujian\"],\n        style: {\n          display: attachmentClass\n        }\n      }, this.props.attachments && this.props.attachments.length > 0 ? this.props.attachments.map(function (item, index) {\n        return /*#__PURE__*/_react[\"default\"].createElement(AttachmentItem, _extends({}, item, {\n          dispatch: _this8.context.dispatch,\n          model: _this8.context.model,\n          attachmentIds: _this8.props.state,\n          key: index\n        }));\n      }) : \"\"));\n    }\n  }, {\n    key: \"showTransferRecord\",\n    value: function showTransferRecord(evt) {\n      this.context.invokeAction(this.context.model, 'showTransferRecord', [this.props.taskId, this.props.userStr, true]);\n    }\n  }]);\n  return CoordinateRecordItem;\n}(_react.Component);\nCoordinateRecordItem.contextTypes = {\n  dispatch: _propTypes[\"default\"].func,\n  invokeAction: _propTypes[\"default\"].func,\n  model: _propTypes[\"default\"].object\n};\nvar AttachmentItem = /*#__PURE__*/function (_Component6) {\n  _inherits(AttachmentItem, _Component6);\n  function AttachmentItem(props) {\n    var _this9;\n    _classCallCheck(this, AttachmentItem);\n    _this9 = _callSuper(this, AttachmentItem, [props]);\n    _this9.getFileSize = function (size) {\n      var fileSize = 0;\n      if (size > 1024 * 1024) {\n        return fileSize = (Math.round(size * 100 / (1024 * 1024)) / 100).toString() + 'MB';\n      } else {\n        return fileSize = (Math.round(size * 100 / 1024) / 100).toString() + 'KB';\n      }\n    };\n    _this9.state = {\n      visiable: false\n    };\n    _this9.handleMouseover = _this9.handleMouseover.bind(_assertThisInitialized(_this9));\n    _this9.handleMouseleave = _this9.handleMouseleave.bind(_assertThisInitialized(_this9));\n    return _this9;\n  }\n  _createClass(AttachmentItem, [{\n    key: \"handleMouseover\",\n    value: function handleMouseover() {\n      this.setState({\n        visiable: true\n      });\n    }\n  }, {\n    key: \"handleMouseleave\",\n    value: function handleMouseleave() {\n      this.setState({\n        visiable: false\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var coordinateName = this.props.assignee ? this.props.assignee.split(\"|\")[0].trim() : \"\";\n      var fileSize = \"(\" + this.getFileSize(this.props.fileSize) + \")\";\n      return /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _ApprovalHistoryRecord2[\"default\"][\"attachment\"],\n        onMouseOver: this.handleMouseover,\n        onMouseLeave: this.handleMouseleave\n      }, /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n        className: (0, _classnames[\"default\"])(_ApprovalHistoryRecord2[\"default\"][\"attach-icon\"], \"kdfont kdfont-fujian\")\n      }), /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n        className: _ApprovalHistoryRecord2[\"default\"][\"filename\"],\n        title: this.props.fileName,\n        onClick: this.previewAttachment.bind(this)\n      }, this.props.fileName), /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n        className: _ApprovalHistoryRecord2[\"default\"][\"filesize\"]\n      }, fileSize), /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n        className: _ApprovalHistoryRecord2[\"default\"][\"operate\"],\n        style: {\n          display: this.state.visiable ? \"flex\" : \"none\"\n        }\n      }, /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n        className: _ApprovalHistoryRecord2[\"default\"][\"fileyulan\"],\n        onClick: this.previewAttachment.bind(this)\n      }, (0, _intlApi.getLangMsg)({\n        key: \"KDApprovalRecord.yulan\"\n      })), /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n        className: _ApprovalHistoryRecord2[\"default\"][\"filexiazai\"],\n        onClick: this.downloadAttachment.bind(this)\n      }, (0, _intlApi.getLangMsg)({\n        key: \"KDApprovalRecord.xiazai\"\n      }))));\n    }\n  }, {\n    key: \"downloadAttachment\",\n    value: function downloadAttachment() {\n      window.open(this.props.downloadUrl);\n    }\n  }, {\n    key: \"previewAttachment\",\n    value: function previewAttachment() {\n      if (this.props.previewUrl) {\n        this.props.dispatch((0, _approvalRecordAction.showAttachmentInfo)(this.props.model, {\n          attachmentid: this.props.id,\n          downloadurl: this.props.downloadUrl,\n          attachmentids: this.props.attachmentIds\n        }));\n      } else {\n        window.open(this.props.downloadUrl);\n      }\n    }\n  }]);\n  return AttachmentItem;\n}(_react.Component);\nvar AuditPointHistoryItem = /*#__PURE__*/function (_Component7) {\n  _inherits(AuditPointHistoryItem, _Component7);\n  function AuditPointHistoryItem() {\n    _classCallCheck(this, AuditPointHistoryItem);\n    return _callSuper(this, AuditPointHistoryItem, arguments);\n  }\n  _createClass(AuditPointHistoryItem, [{\n    key: \"render\",\n    value: function render() {\n      var checkResult = this.props.checkResult;\n      var result = null;\n      var statusImage = null;\n      if (checkResult && checkResult == \"approve\") {\n        statusImage = \"icons/pc/state/success_28_28.png\";\n        result = (0, _intlApi.getLangMsg)({\n          key: \"ApprovalHistoryRecord.tongguo\"\n        });\n      } else if (checkResult && checkResult == \"failed\") {\n        statusImage = \"icons/pc/other/deleteicon_hover.png\";\n        result = (0, _intlApi.getLangMsg)({\n          key: \"ApprovalHistoryRecord.butongguo\"\n        });\n      } else if (checkResult && checkResult == \"unconfirmed\") {\n        statusImage = \"icons/pc/state/queren_48_48.png\";\n        result = (0, _intlApi.getLangMsg)({\n          key: \"ApprovalHistoryRecord.daiqueren\"\n        });\n      } else {\n        statusImage = \"icons/pc/state/remind_28_28.png\";\n      }\n      // 显示名称\n      var displayName = this.props.displayName;\n      // 未通过原因\n      var failedReason = this.props.failedReason;\n      //详细说明\n      var description = this.props.description;\n      if (displayName) {\n        displayName = this.props.displayName;\n      } else {\n        displayName = description;\n      }\n      return /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _ApprovalHistoryRecord2[\"default\"]['record-auditpoints']\n      }, /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _ApprovalHistoryRecord2[\"default\"].auditPointsItem\n      }, /*#__PURE__*/_react[\"default\"].createElement(\"img\", {\n        className: _ApprovalHistoryRecord2[\"default\"].statusImage,\n        style: {\n          borderRadius: '10%'\n        },\n        src: statusImage\n      }), /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _ApprovalHistoryRecord2[\"default\"].displayName,\n        title: displayName\n      }, displayName), /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _ApprovalHistoryRecord2[\"default\"].result\n      }, result)), /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _ApprovalHistoryRecord2[\"default\"].failedReason\n      }, /*#__PURE__*/_react[\"default\"].createElement(\"div\", null, failedReason)));\n    }\n  }]);\n  return AuditPointHistoryItem;\n}(_react.Component);\nAuditPointHistoryItem.contextTypes = {\n  invokeAction: _propTypes[\"default\"].func,\n  model: _propTypes[\"default\"].object\n};\nvar _default = exports[\"default\"] = ApprovalHistoryRecord;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/components/ApprovalHistoryRecord.js?");

/***/ }),

/***/ "./src/workflow/components/ApprovalRecordComponents/KDApprovalRecord.js":
/*!******************************************************************************!*\
  !*** ./src/workflow/components/ApprovalRecordComponents/KDApprovalRecord.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.symbol.iterator.js */ \"../../node_modules/core-js/modules/es.symbol.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.symbol.to-primitive.js */ \"../../node_modules/core-js/modules/es.symbol.to-primitive.js\");\n__webpack_require__(/*! core-js/modules/es.array.from.js */ \"../../node_modules/core-js/modules/es.array.from.js\");\n__webpack_require__(/*! core-js/modules/es.array.iterator.js */ \"../../node_modules/core-js/modules/es.array.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.array.slice.js */ \"../../node_modules/core-js/modules/es.array.slice.js\");\n__webpack_require__(/*! core-js/modules/es.date.to-primitive.js */ \"../../node_modules/core-js/modules/es.date.to-primitive.js\");\n__webpack_require__(/*! core-js/modules/es.function.name.js */ \"../../node_modules/core-js/modules/es.function.name.js\");\n__webpack_require__(/*! core-js/modules/es.number.constructor.js */ \"../../node_modules/core-js/modules/es.number.constructor.js\");\n__webpack_require__(/*! core-js/modules/es.object.assign.js */ \"../../node_modules/core-js/modules/es.object.assign.js\");\n__webpack_require__(/*! core-js/modules/es.object.create.js */ \"../../node_modules/core-js/modules/es.object.create.js\");\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\n__webpack_require__(/*! core-js/modules/es.object.get-own-property-descriptor.js */ \"../../node_modules/core-js/modules/es.object.get-own-property-descriptor.js\");\n__webpack_require__(/*! core-js/modules/es.object.get-prototype-of.js */ \"../../node_modules/core-js/modules/es.object.get-prototype-of.js\");\n__webpack_require__(/*! core-js/modules/es.reflect.construct.js */ \"../../node_modules/core-js/modules/es.reflect.construct.js\");\n__webpack_require__(/*! core-js/modules/es.string.iterator.js */ \"../../node_modules/core-js/modules/es.string.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.weak-map.js */ \"../../node_modules/core-js/modules/es.weak-map.js\");\n__webpack_require__(/*! core-js/modules/web.dom-collections.iterator.js */ \"../../node_modules/core-js/modules/web.dom-collections.iterator.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.symbol.js */ \"../../node_modules/core-js/modules/es.symbol.js\");\n__webpack_require__(/*! core-js/modules/es.symbol.description.js */ \"../../node_modules/core-js/modules/es.symbol.description.js\");\n__webpack_require__(/*! core-js/modules/es.array.concat.js */ \"../../node_modules/core-js/modules/es.array.concat.js\");\n__webpack_require__(/*! core-js/modules/es.array.for-each.js */ \"../../node_modules/core-js/modules/es.array.for-each.js\");\n__webpack_require__(/*! core-js/modules/es.array.index-of.js */ \"../../node_modules/core-js/modules/es.array.index-of.js\");\n__webpack_require__(/*! core-js/modules/es.array.is-array.js */ \"../../node_modules/core-js/modules/es.array.is-array.js\");\n__webpack_require__(/*! core-js/modules/es.array.join.js */ \"../../node_modules/core-js/modules/es.array.join.js\");\n__webpack_require__(/*! core-js/modules/es.array.map.js */ \"../../node_modules/core-js/modules/es.array.map.js\");\n__webpack_require__(/*! core-js/modules/es.date.to-string.js */ \"../../node_modules/core-js/modules/es.date.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.function.bind.js */ \"../../node_modules/core-js/modules/es.function.bind.js\");\n__webpack_require__(/*! core-js/modules/es.object.keys.js */ \"../../node_modules/core-js/modules/es.object.keys.js\");\n__webpack_require__(/*! core-js/modules/es.object.set-prototype-of.js */ \"../../node_modules/core-js/modules/es.object.set-prototype-of.js\");\n__webpack_require__(/*! core-js/modules/es.object.to-string.js */ \"../../node_modules/core-js/modules/es.object.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.promise.js */ \"../../node_modules/core-js/modules/es.promise.js\");\n__webpack_require__(/*! core-js/modules/es.regexp.exec.js */ \"../../node_modules/core-js/modules/es.regexp.exec.js\");\n__webpack_require__(/*! core-js/modules/es.regexp.to-string.js */ \"../../node_modules/core-js/modules/es.regexp.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.string.replace.js */ \"../../node_modules/core-js/modules/es.string.replace.js\");\n__webpack_require__(/*! core-js/modules/es.string.trim.js */ \"../../node_modules/core-js/modules/es.string.trim.js\");\n__webpack_require__(/*! core-js/modules/web.dom-collections.for-each.js */ \"../../node_modules/core-js/modules/web.dom-collections.for-each.js\");\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"webpack/sharing/consume/default/react/react?dca2\"));\nvar _propTypes = _interopRequireDefault(__webpack_require__(/*! prop-types */ \"../../node_modules/prop-types/index.js\"));\nvar _classnames = _interopRequireDefault(__webpack_require__(/*! classnames */ \"../../node_modules/classnames/index.js\"));\nvar _ApprovalRecord = _interopRequireDefault(__webpack_require__(/*! ../../css/ApprovalRecord.less */ \"./src/workflow/css/ApprovalRecord.less\"));\nvar _approvalRecordAction = _interopRequireWildcard(__webpack_require__(/*! ../../actions/approvalRecordAction */ \"./src/workflow/actions/approvalRecordAction.js\"));\nvar _appModelFunction = __webpack_require__(/*! ../../../model/appModelFunction */ \"./src/model/appModelFunction.js\");\nvar _action = __webpack_require__(/*! ../../../action/action */ \"./src/action/action.js\");\nvar _refuse = _interopRequireDefault(__webpack_require__(/*! ../../images/refuse.png */ \"./src/workflow/images/refuse.png\"));\nvar _agree = _interopRequireDefault(__webpack_require__(/*! ../../images/agree.png */ \"./src/workflow/images/agree.png\"));\nvar _auto_audit = _interopRequireDefault(__webpack_require__(/*! ../../images/auto_audit.png */ \"./src/workflow/images/auto_audit.png\"));\nvar _waiting = _interopRequireDefault(__webpack_require__(/*! ../../images/waiting.png */ \"./src/workflow/images/waiting.png\"));\nvar _callActivity = _interopRequireDefault(__webpack_require__(/*! ../../images/callActivity.png */ \"./src/workflow/images/callActivity.png\"));\nvar _refuse2 = _interopRequireDefault(__webpack_require__(/*! ../../images/refuse2.png */ \"./src/workflow/images/refuse2.png\"));\nvar _agree2 = _interopRequireDefault(__webpack_require__(/*! ../../images/agree2.png */ \"./src/workflow/images/agree2.png\"));\nvar _waiting2 = _interopRequireDefault(__webpack_require__(/*! ../../images/waiting2.png */ \"./src/workflow/images/waiting2.png\"));\nvar _moren = _interopRequireDefault(__webpack_require__(/*! ../../images/moren2.png */ \"./src/workflow/images/moren2.png\"));\nvar _moren2 = _interopRequireDefault(__webpack_require__(/*! ../../images/moren.png */ \"./src/workflow/images/moren.png\"));\nvar _handleRotate = _interopRequireDefault(__webpack_require__(/*! ../../images/handle-rotate.png */ \"./src/workflow/images/handle-rotate.png\"));\nvar _Tooltip = _interopRequireDefault(__webpack_require__(/*! ../../../component/common/Tooltip */ \"./src/component/common/Tooltip.jsx\"));\nvar _workflowUtil = __webpack_require__(/*! ../../util/workflowUtil */ \"./src/workflow/util/workflowUtil.js\");\nvar _KDYzjChat = _interopRequireDefault(__webpack_require__(/*! ../KDYzjChat */ \"./src/workflow/components/KDYzjChat.js\"));\nvar _immutable = __webpack_require__(/*! immutable */ \"webpack/sharing/consume/default/immutable/immutable?f2ca\");\nvar _tooltipaction = __webpack_require__(/*! ../../../action/tooltipaction */ \"./src/action/tooltipaction.js\");\nvar _trace = _interopRequireDefault(__webpack_require__(/*! ../../../util/trace */ \"./src/util/trace.js\"));\nvar _KDApprovalRecordNew = _interopRequireDefault(__webpack_require__(/*! ./KDApprovalRecordNew */ \"./src/workflow/components/ApprovalRecordComponents/KDApprovalRecordNew.js\"));\nvar _intlApi = __webpack_require__(/*! ../../../i18n/intlApi */ \"./src/i18n/intlApi.js\");\nvar _formservice = _interopRequireDefault(__webpack_require__(/*! ../../../api/formservice */ \"./src/api/formservice.js\"));\nvar _withnotapprovalrecord = _interopRequireDefault(__webpack_require__(/*! ../../images/withnotapprovalrecord2.png */ \"./src/workflow/images/withnotapprovalrecord2.png\"));\nvar _GlobalDataCacher = __webpack_require__(/*! @/model/GlobalDataCacher */ \"./src/model/GlobalDataCacher.js\");\nvar _symbolConst = __webpack_require__(/*! @/constant/symbolConst */ \"./src/constant/symbolConst.js\");\nvar _attachmentConst = __webpack_require__(/*! @/constant/attachmentConst */ \"./src/constant/attachmentConst.js\");\nvar _componentutil = __webpack_require__(/*! @/util/componentutil */ \"./src/util/componentutil.js\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction _getRequireWildcardCache(e) { if (\"function\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return { \"default\": e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\"default\" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n[\"default\"] = e, t && t.set(e, n), n; }\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction listenTray() {\n  var yzjChatWindow = $('#im-chat-container');\n  var cls = _ApprovalRecord[\"default\"].chatPosition;\n  if (yzjChatWindow.length > 0 && yzjChatWindow.hasClass(cls)) {\n    yzjChatWindow.removeClass(cls);\n  }\n}\nvar ApprovalRecord = exports[\"default\"] = /*#__PURE__*/function (_Component) {\n  _inherits(ApprovalRecord, _Component);\n  function ApprovalRecord(props) {\n    var _this;\n    _classCallCheck(this, ApprovalRecord);\n    _this = _callSuper(this, ApprovalRecord, [props]);\n    _this.data = {\n      openIds: [],\n      groupIds: {}\n    };\n    return _this;\n  }\n  _createClass(ApprovalRecord, [{\n    key: \"_openChatWindow\",\n    value: function _openChatWindow(groupId) {\n      var tray = $('.im-tray');\n      var cls = _ApprovalRecord[\"default\"].chatPosition;\n      tray.unbind('click', listenTray);\n      window.pcyzjShare.openChat({\n        groupId: groupId\n      });\n      $('#im-session-left').toggleClass('im-listAppear');\n      if (tray.length > 0) {\n        $('#im-chat-container').addClass(cls);\n        tray.bind('click', listenTray);\n      }\n    }\n  }, {\n    key: \"_chatClick\",\n    value: function _chatClick(e, openId, name, trusteeOpenIds) {\n      var _this$props = this.props,\n        model = _this$props.model,\n        dispatch = _this$props.dispatch;\n      var m = model.state;\n      var isPC = model.getDataProperty('isPC');\n      var openIds = [];\n      var clickScene = 'chat';\n      if (openId == 'moreChat') {\n        openIds = this.data.openIds;\n        clickScene = 'moreChat';\n      } else {\n        if (Array.isArray(trusteeOpenIds) && trusteeOpenIds.length != 0) {\n          var _iterator = _createForOfIteratorHelper(trusteeOpenIds),\n            _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var id = _step.value;\n              openIds.push(id);\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        }\n        openIds.push(openId);\n      }\n      var arg = [{\n        openIds: openIds,\n        groupName: name,\n        clickScene: clickScene\n      }];\n      var param = [{\n        key: model.key,\n        methodName: 'itemClick',\n        args: arg,\n        postData: []\n      }];\n      if (isPC == 'false') {\n        this.getGroupId(param, openId);\n      } else {\n        var groupId = this.data.groupIds[openId];\n        if (groupId) {\n          this._openChatWindow(groupId);\n        } else {\n          this.getGroupId(param, openId);\n        }\n      }\n    }\n  }, {\n    key: \"getGroupId\",\n    value: function getGroupId(param, openId) {\n      var _this2 = this;\n      var tmp = {};\n      var _this$props2 = this.props,\n        model = _this$props2.model,\n        dispatch = _this$props2.dispatch;\n      var pageId = model.getDataProperty('pageId') || model.pageId;\n      var AppId = (0, _appModelFunction.getAppId)(pageId)(store.getState());\n      tmp.pageId = model.pageId;\n      tmp.params = param;\n      var that = this;\n      var url = 'form/batchInvokeAction.do';\n      var post = Object.keys(tmp).map(function (key) {\n        return key + '=' + _this2.encodeParam(tmp[key]);\n      }).join('&');\n      post = 'appId=' + this.encodeParam(AppId) + '&' + post;\n      fetch(url, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded;charset=utf-8;',\n          ajax: true,\n          traceId: (0, _trace[\"default\"])()\n        },\n        body: post,\n        mode: 'cors',\n        credentials: 'include'\n      }).then(function (response) {\n        if (response.ok) {\n          return response.json();\n        } else {\n          throw new Error(response.statusText);\n        }\n      }).then(function (json) {\n        (0, _action.doPostActions)(model.pageId, json, dispatch);\n      });\n    }\n  }, {\n    key: \"encodeParam\",\n    value: function encodeParam(value) {\n      if (_typeof(value) === 'object') {\n        return encodeURIComponent(JSON.stringify(value));\n      }\n      return encodeURIComponent(value);\n    }\n  }, {\n    key: \"_renderChild\",\n    value: function _renderChild(children) {\n      var _this3 = this;\n      var _this$props3 = this.props,\n        model = _this$props3.model,\n        dispatch = _this$props3.dispatch;\n      var m = model.state;\n      var isPC = model.getDataProperty('isPC');\n      var hideChat = model.getDataProperty('hideChat');\n      var noTimeLine = model.getDataProperty('noTimeLine') || '';\n      var list = [];\n      var size = list.length;\n      var ids = this.data.openIds;\n      var fileServer = model.getFormConfig();\n      var pageId = model.pageId,\n        key = model.key;\n      var dataPageId = \"\".concat(pageId, \"_\").concat(key, \"_tips\");\n      children.forEach(function (value, index, array) {\n        if (value.openId && ids.indexOf(value.openId) == -1) {\n          _this3.data.openIds.push(value.openId);\n        }\n        var userAvatar = (0, _workflowUtil.getImageUrl)(value.avatar, fileServer);\n        var optionColor = '#666666';\n        if (value.decisionType == 'reject' || value.decisionType == 'forceReject') {\n          optionColor = isPC == 'false' ? '#F35959' : '#FF3737';\n        }\n        var params = value.taskId + '_' + value.userStr;\n        if (hideChat) {\n          params = value.taskId + '_' + value.userStr + '_' + 0;\n        } else {\n          params = value.taskId + '_' + value.userStr + '_' + 1;\n        }\n        var tips = (0, _immutable.fromJS)({\n          type: 'bill',\n          billno: params,\n          link: false\n        });\n        var addSignMsg = '';\n        if ((value.handleState == 'willApproval' || value.decisionType == 'approve' || value.decisionType == 'reject') && array.length == 1 && value.nodeType && value.nodeType.indexOf('YunzhijiaTask') == -1) {\n          addSignMsg = value.addSignMsg;\n        }\n        if (Array.isArray(value.trusteeOpenIds) && value.trusteeOpenIds.length != 0) {\n          var _iterator2 = _createForOfIteratorHelper(value.trusteeOpenIds),\n            _step2;\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var id = _step2.value;\n              ids.push(id);\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        }\n        var auditMessage = (0, _workflowUtil.sanitize)(value.message);\n        var addSignMessage = (0, _workflowUtil.sanitize)(addSignMsg || '');\n        var sanitizeResult = (0, _workflowUtil.sanitize)(value.result);\n        var attachmentClass = value.attachments && value.attachments.length > 0 ? 'block' : 'none';\n        var userImgIcon = value.decisionType != 'wait' && userAvatar ? userAvatar : value.userStr == '-1' ? _auto_audit[\"default\"] : _moren2[\"default\"];\n        if (value.callActivity) {\n          userImgIcon = _callActivity[\"default\"];\n        }\n        list.push( /*#__PURE__*/_react[\"default\"].createElement(\"div\", null, /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n          className: isPC == 'false' ? _ApprovalRecord[\"default\"].contentMobile : _ApprovalRecord[\"default\"].content,\n          style: {\n            marginTop: index == 0 ? '14px' : '0px',\n            marginLeft: !noTimeLine ? '20px' : '0px'\n          },\n          key: 'children' + index\n        }, /*#__PURE__*/_react[\"default\"].createElement(\"img\", {\n          className: _ApprovalRecord[\"default\"].userImg,\n          src: userImgIcon,\n          alt: \"\"\n        }), /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n          className: _ApprovalRecord[\"default\"].textWrap\n        }, index > 0 ? /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n          className: isPC == 'false' ? _ApprovalRecord[\"default\"].aGroupMobile : _ApprovalRecord[\"default\"].aGroup\n        }) : '', /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n          className: _ApprovalRecord[\"default\"].textContent\n        }, /*#__PURE__*/_react[\"default\"].createElement(\"h4\", {\n          className: isPC == 'false' ? _ApprovalRecord[\"default\"].textContenthMobile : _ApprovalRecord[\"default\"].textContenth\n        }, /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n          dangerouslySetInnerHTML: {\n            __html: (0, _workflowUtil.sanitize)(value.activityName)\n          }\n        }), /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n          dangerouslySetInnerHTML: {\n            __html: (0, _workflowUtil.sanitize)(value.subactivityname)\n          }\n        }), value.assignee, /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n          dangerouslySetInnerHTML: {\n            __html: sanitizeResult\n          }\n        })), value.openId && !hideChat ? /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n          className: isPC == 'false' ? _ApprovalRecord[\"default\"].talkImgPhone : _ApprovalRecord[\"default\"].talkImg + ' kdfont kdfont-goutong',\n          onClick: function onClick(e) {\n            _this3._chatClick.bind(_this3)(e, value.openId, value.assignee, value.trusteeOpenIds);\n          }\n        }) : ''), /*#__PURE__*/_react[\"default\"].createElement(\"p\", {\n          className: _ApprovalRecord[\"default\"].time\n        }, value.time), value.callActivity ? /*#__PURE__*/_react[\"default\"].createElement(\"p\", {\n          className: (0, _classnames[\"default\"])(_ApprovalRecord[\"default\"].option, _ApprovalRecord[\"default\"]['option-callActivity']),\n          onClick: function onClick(e) {\n            _this3.showChildProcessInfo.bind(_this3)(e, value.procInstId, value.subCrossTenantInfo);\n          },\n          style: {\n            display: value.message ? 'block' : 'none'\n          },\n          dangerouslySetInnerHTML: {\n            __html: auditMessage\n          }\n        }) : /*#__PURE__*/_react[\"default\"].createElement(\"p\", {\n          className: _ApprovalRecord[\"default\"].option,\n          style: {\n            color: optionColor,\n            display: value.message ? 'block' : 'none'\n          },\n          dangerouslySetInnerHTML: {\n            __html: auditMessage\n          }\n        }), (0, _workflowUtil.createSignatureApprovalRecord)(false, isPC, value.signature), /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n          className: _ApprovalRecord[\"default\"].addSignMsg,\n          style: {\n            backgroundColor: isPC == 'false' ? 'white' : '#F5F6F8'\n          },\n          dangerouslySetInnerHTML: {\n            __html: addSignMessage\n          }\n        }), /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n          className: _ApprovalRecord[\"default\"].procAttach,\n          style: {\n            display: attachmentClass,\n            width: ''\n          }\n        }, value.attachments && value.attachments.length > 0 ? value.attachments.map(function (item, index) {\n          return /*#__PURE__*/_react[\"default\"].createElement(AttachmentItem, _extends({}, item, {\n            dispatch: _this3.props.dispatch,\n            model: _this3.props.model,\n            attachmentIds: value.state,\n            key: index\n          }));\n        }) : ''))), /*#__PURE__*/_react[\"default\"].createElement(ControlPanel, {\n          item: value,\n          isPC: isPC,\n          dispatch: dispatch,\n          model: model\n        })));\n      });\n      return list;\n    }\n  }, {\n    key: \"showChildProcessInfo\",\n    value: function showChildProcessInfo(e, procInstId, subCrossTenantInfo) {\n      var params = {};\n      params.pageId = this.props.model.getDataProperty('pageId');\n      params.isPC = this.props.model.getDataProperty('isPC');\n      params.hideMoreChat = this.props.model.getDataProperty('hideMoreChat');\n      params.hideChat = this.props.model.getDataProperty('hideChat');\n      params.noTimeLine = this.props.model.getDataProperty('noTimeLine');\n      params.approvalIsNew = this.props.model.getDataProperty('approvalIsNew');\n      params.isDDOrQYWX = this.props.model.getDataProperty('isDDOrQYWX');\n      this.props.dispatch((0, _approvalRecordAction.showChildProcessInfo)(this.props.model, {\n        params: params,\n        procinstid: procInstId,\n        subcrosstenantinfo: subCrossTenantInfo\n      }));\n    }\n  }, {\n    key: \"_renderItem\",\n    value: function _renderItem(approvalRecordItems) {\n      var _this4 = this;\n      var _this$props4 = this.props,\n        model = _this$props4.model,\n        dispatch = _this$props4.dispatch;\n      var m = model.state;\n      var isPC = model.getDataProperty('isPC');\n      var noTimeLine = model.getDataProperty('noTimeLine') || '';\n      var hideMoreChat = model.getDataProperty('hideMoreChat');\n      var that = this;\n      var list = [];\n      var preGroup = '';\n      approvalRecordItems.forEach(function (value, index, array) {\n        var nodeTypeImg = isPC == 'false' ? _agree2[\"default\"] : _agree[\"default\"];\n        if (value.groupDecisionType == 'reject' || value.groupDecisionType == 'forceReject') {\n          nodeTypeImg = isPC == 'false' ? _refuse2[\"default\"] : _refuse[\"default\"];\n        } else if (value.groupDecisionType == 'wait') {\n          nodeTypeImg = _waiting2[\"default\"];\n        }\n        var throughRule = value.throughRule ? /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n          className: _ApprovalRecord[\"default\"].textContent,\n          style: {\n            marginBottom: '6px'\n          }\n        }, /*#__PURE__*/_react[\"default\"].createElement(\"h4\", {\n          className: isPC == 'false' ? _ApprovalRecord[\"default\"].textContenthMobile : _ApprovalRecord[\"default\"].textContenth\n        }, /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n          dangerouslySetInnerHTML: {\n            __html: value.throughRule\n          }\n        }))) : '';\n        var addSignMessage = (0, _workflowUtil.sanitize)(value.addSignMsg || '');\n        var contentClass = isPC == 'false' ? _ApprovalRecord[\"default\"].contentMobile : _ApprovalRecord[\"default\"].content;\n        list.push( /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n          className: _ApprovalRecord[\"default\"].rowStyle,\n          style: {\n            width: !noTimeLine ? '90%' : '100%'\n          },\n          key: 'approvalRecord' + index\n        }, /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n          className: index == approvalRecordItems.length - 1 ? (0, _classnames[\"default\"])(_ApprovalRecord[\"default\"].timeLine, _ApprovalRecord[\"default\"].lastNode) : _ApprovalRecord[\"default\"].timeLine\n        }, !noTimeLine ? /*#__PURE__*/_react[\"default\"].createElement(\"img\", {\n          className: _ApprovalRecord[\"default\"].circle,\n          src: nodeTypeImg,\n          alt: \"\"\n        }) : ''), value.activityName ? /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n          className: contentClass,\n          style: {\n            marginBottom: '-14px',\n            borderBottom: '1px solid #D9DADA'\n          }\n        }, /*#__PURE__*/_react[\"default\"].createElement(\"img\", {\n          className: _ApprovalRecord[\"default\"].userImg,\n          src: _moren[\"default\"],\n          alt: \"\"\n        }), /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n          className: _ApprovalRecord[\"default\"].textWrap\n        }, /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n          className: _ApprovalRecord[\"default\"].textContent\n        }, /*#__PURE__*/_react[\"default\"].createElement(\"h4\", {\n          className: isPC == 'false' ? _ApprovalRecord[\"default\"].textContenthMobile : _ApprovalRecord[\"default\"].textContenth\n        }, /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n          dangerouslySetInnerHTML: {\n            __html: (0, _workflowUtil.sanitize)(value.activityName)\n          }\n        }))), throughRule, /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n          className: _ApprovalRecord[\"default\"].addSignMsg,\n          style: {\n            backgroundColor: isPC == 'false' ? 'white' : '#F5F6F8'\n          },\n          dangerouslySetInnerHTML: {\n            __html: addSignMessage\n          }\n        }))) : '', value.children.length > 0 ? that._renderChild(value.children) : '', value.showAutoCoordinate ? /*#__PURE__*/_react[\"default\"].createElement(AutoCoordinateRecords, {\n          key: \"auto-coordinate-records\",\n          isPC: isPC,\n          group: value.group,\n          dispatch: dispatch,\n          model: model\n        }) : ''));\n      });\n      if (!hideMoreChat) {\n        var tips = (0, _intlApi.getLangMsg)({\n          key: 'ApprovalRecord.faqiqunliao'\n        });\n        list.push( /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n          className: isPC == 'false' ? (0, _classnames[\"default\"])(_ApprovalRecord[\"default\"].groupChatMobile) : (0, _classnames[\"default\"])(_ApprovalRecord[\"default\"].groupChat, 'kd-button'),\n          key: \"approvalRecord\",\n          onClick: function onClick(e) {\n            _this4._chatClick.bind(_this4)(e, 'moreChat', '', []);\n          }\n        }, /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n          title: tips,\n          style: {\n            whiteSpace: 'break-spaces'\n          }\n        }, tips)));\n      }\n      return list;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props5 = this.props,\n        model = _this$props5.model,\n        dispatch = _this$props5.dispatch;\n      var isPC = model.getDataProperty('isPC') || '';\n      var noTimeLine = model.getDataProperty('noTimeLine') || '';\n      var containerSty = !noTimeLine ? _ApprovalRecord[\"default\"].containerStyle : _ApprovalRecord[\"default\"].containerStyleNoLine;\n      var m = model.state;\n      var approvalRecordItems = model.getDataProperty('approvalRecords');\n      var approvalIsNew = model.getDataProperty('approvalIsNew');\n      var fileServer = model.getFormConfig();\n      // let withnotapprovalrecordImage = \"images/pc/emotion/withnotapprovalrecord2.png\";\n      var isSubProcess = model.getDataProperty('superProcInstId');\n      if (!(approvalRecordItems instanceof Array)) {\n        return '';\n      } else if (approvalRecordItems.length == 0) {\n        return /*#__PURE__*/_react[\"default\"].createElement(\"div\", null, /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n          className: _ApprovalRecord[\"default\"].backToParentProcess,\n          style: {\n            display: isSubProcess ? 'block' : 'none',\n            width: !noTimeLine ? '90%' : '100%'\n          },\n          onClick: this.backToParentProcess.bind(this)\n        }, (0, _intlApi.getLangMsg)({\n          key: 'ApprovalHistoryRecord.fanhuifuliucheng'\n        })), /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n          className: _ApprovalRecord[\"default\"].withoutApprovalRecord\n        }, /*#__PURE__*/_react[\"default\"].createElement(\"img\", {\n          src: _withnotapprovalrecord[\"default\"]\n        })), /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n          className: _ApprovalRecord[\"default\"].description\n        }, (0, _intlApi.getLangMsg)({\n          key: 'KDApprovalRecord.zanwushenpijilu'\n        })));\n      } else {\n        if (isPC == 'true' || !approvalIsNew) {\n          return /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n            className: containerSty,\n            style: {\n              marginBottom: isPC == 'false' && !noTimeLine ? '60px' : '0px'\n            }\n          }, /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n            className: _ApprovalRecord[\"default\"].backToParentProcess,\n            style: {\n              display: isSubProcess ? 'block' : 'none',\n              width: !noTimeLine ? '90%' : '100%'\n            },\n            onClick: this.backToParentProcess.bind(this)\n          }, (0, _intlApi.getLangMsg)({\n            key: 'ApprovalHistoryRecord.fanhuifuliucheng'\n          })), this._renderItem(approvalRecordItems), /*#__PURE__*/_react[\"default\"].createElement(_KDYzjChat[\"default\"], {\n            model: model\n          }));\n        } else {\n          return /*#__PURE__*/_react[\"default\"].createElement(_KDApprovalRecordNew[\"default\"], {\n            dispatch: dispatch,\n            model: model\n          });\n        }\n      }\n    }\n  }, {\n    key: \"backToParentProcess\",\n    value: function backToParentProcess(e) {\n      var params = {};\n      params.pageId = this.props.model.getDataProperty('pageId');\n      params.isPC = this.props.model.getDataProperty('isPC');\n      params.hideMoreChat = this.props.model.getDataProperty('hideMoreChat');\n      params.hideChat = this.props.model.getDataProperty('hideChat');\n      params.noTimeLine = this.props.model.getDataProperty('noTimeLine');\n      params.approvalIsNew = this.props.model.getDataProperty('approvalIsNew');\n      params.isDDOrQYWX = this.props.model.getDataProperty('isDDOrQYWX');\n      var superProcInstId = this.props.model.getDataProperty('superProcInstId');\n      this.props.dispatch((0, _approvalRecordAction.backToParentProcess)(this.props.model, {\n        params: params,\n        superprocInstid: superProcInstId\n      }));\n    }\n  }]);\n  return ApprovalRecord;\n}(_react.Component);\nvar ControlPanel = /*#__PURE__*/function (_Component2) {\n  _inherits(ControlPanel, _Component2);\n  function ControlPanel(props) {\n    var _this5;\n    _classCallCheck(this, ControlPanel);\n    _this5 = _callSuper(this, ControlPanel, [props]);\n    _this5.state = {\n      unfoldCoordinate: false\n    };\n    return _this5;\n  }\n  _createClass(ControlPanel, [{\n    key: \"render\",\n    value: function render() {\n      var _this6 = this;\n      var _this$props6 = this.props,\n        isPC = _this$props6.isPC,\n        item = _this$props6.item,\n        dispatch = _this$props6.dispatch,\n        model = _this$props6.model;\n      var coordinateTitle = this.state.unfoldCoordinate == false ? model.getDataProperty('coordinateName') : (0, _intlApi.getLangMsg)({\n        key: 'ApprovalHistoryRecord.shouqixieban'\n      }).replace(/\\%s/, model.getDataProperty('coordinateName'));\n      return /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        style: {\n          backgroundColor: isPC == 'false' ? 'white' : '#F5F6F8',\n          marginLeft: '20px',\n          width: '100%'\n        }\n      }, /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _ApprovalRecord[\"default\"]['btn-panel']\n      }, (0, _workflowUtil.createCustomizedLinks)(item, function (e, params) {\n        _this6.props.dispatch((0, _approvalRecordAction.clickCustomizeLink)(_this6.props.model, params));\n      }), item.coordinate ? /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n        onClick: this.switchCoordinate.bind(this)\n      }, coordinateTitle) : '', item.showTransferRecord ? /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n        onClick: this.showTransferRecord.bind(this)\n      }, (0, _intlApi.getLangMsg)({\n        key: 'ApprovalHistoryRecord.zhuangjiaolishi'\n      }).replace(/\\%s/, model.getDataProperty('transferName'))) : ''), item.coordinate ? /*#__PURE__*/_react[\"default\"].createElement(CoordinateRecords, {\n        key: \"coordinate-records\",\n        showCoordinate: !this.state.unfoldCoordinate,\n        isPC: isPC,\n        taskId: item.taskId,\n        userId: item.userStr,\n        dispatch: dispatch,\n        model: model\n      }) : '');\n    }\n  }, {\n    key: \"switchCoordinate\",\n    value: function switchCoordinate(evt) {\n      if (!this.state.unfoldCoordinate) {\n        var _this$props7 = this.props,\n          item = _this$props7.item,\n          dispatch = _this$props7.dispatch,\n          model = _this$props7.model;\n        this.props.dispatch((0, _approvalRecordAction.showCoordinateInfo)(this.props.model, {\n          taskid: item.taskId,\n          userid: item.userStr,\n          autocoordinate: false\n        }));\n      }\n      this.setState({\n        unfoldCoordinate: !this.state.unfoldCoordinate\n      });\n    }\n  }, {\n    key: \"showTransferRecord\",\n    value: function showTransferRecord(e) {\n      var _this$props$item = this.props.item,\n        taskId = _this$props$item.taskId,\n        userStr = _this$props$item.userStr;\n      this.props.dispatch((0, _approvalRecordAction.showTransferRecord)(this.props.model, {\n        taskid: taskId,\n        userid: userStr,\n        iscoordinate: false\n      }));\n    }\n  }]);\n  return ControlPanel;\n}(_react.Component);\nvar AutoCoordinateRecords = /*#__PURE__*/function (_Component3) {\n  _inherits(AutoCoordinateRecords, _Component3);\n  function AutoCoordinateRecords(props) {\n    var _this7;\n    _classCallCheck(this, AutoCoordinateRecords);\n    _this7 = _callSuper(this, AutoCoordinateRecords, [props]);\n    _this7.state = {\n      showAutoCoordinate: true\n    };\n    return _this7;\n  }\n  _createClass(AutoCoordinateRecords, [{\n    key: \"render\",\n    value: function render() {\n      var _this8 = this;\n      var coordinateRecords = this.props.model.getDataProperty('autocoordinate_' + this.props.group);\n      var coordinateTitle = this.state.showAutoCoordinate == true ? (0, _intlApi.getLangMsg)({\n        key: 'ApprovalHistoryRecord.zidongxieban'\n      }).replace(/\\%s/, this.props.model.getDataProperty('coordinateName')) : (0, _intlApi.getLangMsg)({\n        key: 'ApprovalHistoryRecord.shouqizidongxieban'\n      }).replace(/\\%s/, this.props.model.getDataProperty('coordinateName'));\n      return /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _ApprovalRecord[\"default\"]['coordinate-record'],\n        style: {\n          display: 'flex',\n          backgroundColor: this.props.isPC == 'false' ? '#fff' : '#F5F6F8'\n        }\n      }, /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _ApprovalRecord[\"default\"].coordinate,\n        onClick: function onClick(e) {\n          _this8.switchAutoCoordinate.bind(_this8)(e, _this8.props.group);\n        }\n      }, coordinateTitle), coordinateRecords && coordinateRecords.length > 0 ? /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        style: {\n          display: this.state.showAutoCoordinate ? 'none' : 'block'\n        }\n      }, /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _ApprovalRecord[\"default\"].title\n      }, coordinateRecords.length, (0, _intlApi.getLangMsg)({\n        key: 'ApprovalHistoryRecord.tiaozidongxiebanjianyi'\n      }).replace(/\\%s/, this.props.model.getDataProperty('coordinateName'))), coordinateRecords.map(function (item, index) {\n        return /*#__PURE__*/_react[\"default\"].createElement(CoordinateRecordItem, _extends({}, item, {\n          dispatch: _this8.props.dispatch,\n          model: _this8.props.model,\n          key: index\n        }));\n      })) : '');\n    }\n  }, {\n    key: \"switchAutoCoordinate\",\n    value: function switchAutoCoordinate(e, groupId) {\n      this.setState({\n        showAutoCoordinate: !this.state.showAutoCoordinate\n      });\n      if (this.state.showAutoCoordinate == true) {\n        this.props.dispatch((0, _approvalRecordAction.showAutoCoordinateInfo)(this.props.model, {\n          groupid: groupId\n        }));\n      }\n    }\n  }]);\n  return AutoCoordinateRecords;\n}(_react.Component);\nvar CoordinateRecords = /*#__PURE__*/function (_Component4) {\n  _inherits(CoordinateRecords, _Component4);\n  function CoordinateRecords() {\n    _classCallCheck(this, CoordinateRecords);\n    return _callSuper(this, CoordinateRecords, arguments);\n  }\n  _createClass(CoordinateRecords, [{\n    key: \"render\",\n    value: function render() {\n      var _this9 = this;\n      var coordinateRecords = this.props.model.getDataProperty('coordinate_' + this.props.taskId + '_' + this.props.userId);\n      return /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _ApprovalRecord[\"default\"]['coordinate-record'],\n        style: {\n          display: 'flex',\n          backgroundColor: this.props.isPC == 'false' ? '#fff' : '#F5F6F8',\n          marginLeft: '0px'\n        }\n      }, coordinateRecords && coordinateRecords.length > 0 ? /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        style: {\n          display: this.props.showCoordinate ? 'none' : 'block'\n        }\n      }, /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _ApprovalRecord[\"default\"].title\n      }, coordinateRecords.length, (0, _intlApi.getLangMsg)({\n        key: 'ApprovalHistoryRecord.tiaoxiebanjianyi'\n      }).replace(/\\%s/, this.props.model.getDataProperty('coordinateName'))), coordinateRecords.map(function (item, index) {\n        return /*#__PURE__*/_react[\"default\"].createElement(CoordinateRecordItem, _extends({}, item, {\n          dispatch: _this9.props.dispatch,\n          model: _this9.props.model,\n          key: index\n        }));\n      })) : '');\n    }\n  }]);\n  return CoordinateRecords;\n}(_react.Component);\nvar CoordinateRecordItem = /*#__PURE__*/function (_Component5) {\n  _inherits(CoordinateRecordItem, _Component5);\n  function CoordinateRecordItem() {\n    _classCallCheck(this, CoordinateRecordItem);\n    return _callSuper(this, CoordinateRecordItem, arguments);\n  }\n  _createClass(CoordinateRecordItem, [{\n    key: \"render\",\n    value: function render() {\n      var _this10 = this;\n      var model = this.props.model;\n      var isPC = model.getDataProperty('isPC');\n      var coordinateName = this.props.assignee || '';\n      if ((this.props.time == '' || this.props.time == undefined) && this.props.assignee.split(' ').length >= 2) {\n        coordinateName = this.props.assignee.split(' ')[1].trim();\n      }\n      var coordinatingClass = this.props.time == '' || this.props.time == undefined ? 'block' : 'none';\n      var attachmentClass = this.props.attachments && this.props.attachments.length > 0 ? 'block' : 'none';\n      var timeClass = this.props.time == '' || this.props.time == undefined ? 'none' : 'block';\n      var coordinateTransRecord = '';\n      if (this.props.showTransferRecord) {\n        coordinateTransRecord = /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n          className: _ApprovalRecord[\"default\"].showCoordinateTransfer,\n          onClick: function onClick(e) {\n            _this10.showTransferRecord.bind(_this10)(e, _this10.props.taskId, _this10.props.userStr, true);\n          }\n        }, (0, _intlApi.getLangMsg)({\n          key: 'ApprovalHistoryRecord.zhuangjiaolishi'\n        }).replace(/\\%s/, this.props.model.getDataProperty('transferName')));\n      }\n      var fileServer = model.getFormConfig();\n      var userAvatar = (0, _workflowUtil.getImageUrl)(this.props.avatar, fileServer);\n      return /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _ApprovalRecord[\"default\"].coordinateRecord\n      }, /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        style: {\n          display: 'flex'\n        }\n      }, /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _ApprovalRecord[\"default\"].left\n      }, /*#__PURE__*/_react[\"default\"].createElement(\"img\", {\n        className: _ApprovalRecord[\"default\"].avatar,\n        src: userAvatar == '' || userAvatar == undefined ? _moren2[\"default\"] : userAvatar\n      })), /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _ApprovalRecord[\"default\"].right\n      }, /*#__PURE__*/_react[\"default\"].createElement(\"div\", null, /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _ApprovalRecord[\"default\"].coordinateName\n      }, /*#__PURE__*/_react[\"default\"].createElement(\"span\", null, this.props.ownerName), /*#__PURE__*/_react[\"default\"].createElement(\"span\", null, (0, _intlApi.getLangMsg)({\n        key: 'ApprovalHistoryRecord.yaoqingkongge'\n      })), /*#__PURE__*/_react[\"default\"].createElement(\"span\", null, coordinateName), /*#__PURE__*/_react[\"default\"].createElement(\"span\", null, (0, _intlApi.getLangMsg)({\n        key: 'ApprovalHistoryRecord.xiebankongge'\n      }).replace(/\\%s/, this.props.model.getDataProperty('coordinateName'))), /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n        className: _ApprovalRecord[\"default\"].coordinating,\n        style: {\n          display: coordinatingClass\n        }\n      }, (0, _intlApi.getLangMsg)({\n        key: 'ApprovalHistoryRecord.zhengzaixieban'\n      }).replace(/\\%s/, this.props.model.getDataProperty('coordinateName')))), /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n        className: _ApprovalRecord[\"default\"].time,\n        style: {\n          display: timeClass\n        }\n      }, this.props.time)), /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _ApprovalRecord[\"default\"].message\n      }, (0, _workflowUtil.crateCoordinateInviteOpinions)(this.props)), (0, _workflowUtil.createSignatureApprovalRecord)(false, isPC, this.props.signature))), coordinateTransRecord, /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _ApprovalRecord[\"default\"].fujian,\n        style: {\n          display: attachmentClass\n        }\n      }, this.props.attachments && this.props.attachments.length > 0 ? this.props.attachments.map(function (item, index) {\n        return /*#__PURE__*/_react[\"default\"].createElement(AttachmentItem, _extends({}, item, {\n          dispatch: _this10.props.dispatch,\n          model: _this10.props.model,\n          attachmentIds: _this10.props.state,\n          key: index\n        }));\n      }) : ''));\n    }\n  }, {\n    key: \"showTransferRecord\",\n    value: function showTransferRecord(e, taskId, userId, coordinate) {\n      this.props.dispatch((0, _approvalRecordAction.showTransferRecord)(this.props.model, {\n        taskid: taskId,\n        userid: userId,\n        iscoordinate: coordinate\n      }));\n    }\n  }]);\n  return CoordinateRecordItem;\n}(_react.Component);\nvar AttachmentItem = /*#__PURE__*/function (_Component6) {\n  _inherits(AttachmentItem, _Component6);\n  function AttachmentItem(props) {\n    var _this11;\n    _classCallCheck(this, AttachmentItem);\n    _this11 = _callSuper(this, AttachmentItem, [props]);\n    _this11.getFileSize = function (size) {\n      var fileSize = 0;\n      if (size > 1024 * 1024) {\n        return fileSize = (Math.round(size * 100 / (1024 * 1024)) / 100).toString() + 'MB';\n      } else {\n        return fileSize = (Math.round(size * 100 / 1024) / 100).toString() + 'KB';\n      }\n    };\n    _this11.state = {\n      visiable: false\n    };\n    _this11.handleMouseover = _this11.handleMouseover.bind(_assertThisInitialized(_this11));\n    _this11.handleMouseleave = _this11.handleMouseleave.bind(_assertThisInitialized(_this11));\n    return _this11;\n  }\n  _createClass(AttachmentItem, [{\n    key: \"handleMouseover\",\n    value: function handleMouseover() {\n      this.setState({\n        visiable: true\n      });\n    }\n  }, {\n    key: \"handleMouseleave\",\n    value: function handleMouseleave() {\n      this.setState({\n        visiable: false\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var model = this.props.model;\n      var isPC = model.getDataProperty('isPC') == 'true';\n      var fileSize = '(' + this.getFileSize(this.props.fileSize) + ')';\n      var attachmentClass = isPC ? 'attachment' : 'attachmentForMob';\n      if (isPC) {\n        return /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n          className: _ApprovalRecord[\"default\"][attachmentClass],\n          onMouseOver: this.handleMouseover,\n          onMouseLeave: this.handleMouseleave\n        }, /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n          className: (0, _classnames[\"default\"])(_ApprovalRecord[\"default\"]['attach-icon'], 'kdfont kdfont-fujian')\n        }), /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n          className: _ApprovalRecord[\"default\"].filename,\n          title: this.props.fileName,\n          onClick: this.previewAttachment.bind(this)\n        }, this.props.fileName), /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n          className: _ApprovalRecord[\"default\"].filesize\n        }, fileSize), /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n          className: _ApprovalRecord[\"default\"].operate,\n          style: {\n            display: this.state.visiable ? 'flex' : 'none'\n          }\n        }, /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n          className: _ApprovalRecord[\"default\"].fileyulan,\n          onClick: this.previewAttachment.bind(this)\n        }, (0, _intlApi.getLangMsg)({\n          key: 'KDApprovalRecord.yulan'\n        })), /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n          className: _ApprovalRecord[\"default\"].filexiazai,\n          onClick: this.downloadAttachment.bind(this)\n        }, (0, _intlApi.getLangMsg)({\n          key: 'KDApprovalRecord.xiazai'\n        }))));\n      } else {\n        return /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n          className: _ApprovalRecord[\"default\"][attachmentClass],\n          onClick: this.previewAttachment.bind(this)\n        }, /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n          className: (0, _classnames[\"default\"])(_ApprovalRecord[\"default\"]['attach-icon'], 'kdfont kdfont-fujian')\n        }), /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n          className: _ApprovalRecord[\"default\"].filename,\n          title: this.props.fileName\n        }, this.props.fileName), /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n          className: _ApprovalRecord[\"default\"].filesize\n        }, fileSize));\n      }\n    }\n  }, {\n    key: \"downloadAttachment\",\n    value: function downloadAttachment() {\n      window.open(this.props.downloadUrl);\n    }\n  }, {\n    key: \"previewAttachment\",\n    value: function previewAttachment() {\n      if (this.props.model.getDataProperty('isPC') == 'true') {\n        if (this.props.previewUrl) {\n          this.props.dispatch((0, _approvalRecordAction.showAttachmentInfo)(this.props.model, {\n            attachmentid: this.props.id,\n            downloadurl: this.props.downloadUrl,\n            attachmentids: this.props.attachmentIds\n          }));\n        } else {\n          window.open(this.props.downloadUrl);\n        }\n      } else {\n        this.props.dispatch((0, _approvalRecordAction.showAttachmentInfo)(this.props.model, {\n          attachmentid: this.props.id,\n          downloadurl: this.props.downloadUrl,\n          attachmentids: this.props.attachmentIds\n        }));\n      }\n    }\n  }]);\n  return AttachmentItem;\n}(_react.Component);\n\n//# sourceURL=webpack://bos-platform/./src/workflow/components/ApprovalRecordComponents/KDApprovalRecord.js?");

/***/ }),

/***/ "./src/workflow/components/ApprovalRecordComponents/KDApprovalRecordNew.js":
/*!*********************************************************************************!*\
  !*** ./src/workflow/components/ApprovalRecordComponents/KDApprovalRecordNew.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.symbol.js */ \"../../node_modules/core-js/modules/es.symbol.js\");\n__webpack_require__(/*! core-js/modules/es.symbol.description.js */ \"../../node_modules/core-js/modules/es.symbol.description.js\");\n__webpack_require__(/*! core-js/modules/es.symbol.iterator.js */ \"../../node_modules/core-js/modules/es.symbol.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.symbol.to-primitive.js */ \"../../node_modules/core-js/modules/es.symbol.to-primitive.js\");\n__webpack_require__(/*! core-js/modules/es.array.from.js */ \"../../node_modules/core-js/modules/es.array.from.js\");\n__webpack_require__(/*! core-js/modules/es.array.iterator.js */ \"../../node_modules/core-js/modules/es.array.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.array.slice.js */ \"../../node_modules/core-js/modules/es.array.slice.js\");\n__webpack_require__(/*! core-js/modules/es.date.to-primitive.js */ \"../../node_modules/core-js/modules/es.date.to-primitive.js\");\n__webpack_require__(/*! core-js/modules/es.function.name.js */ \"../../node_modules/core-js/modules/es.function.name.js\");\n__webpack_require__(/*! core-js/modules/es.number.constructor.js */ \"../../node_modules/core-js/modules/es.number.constructor.js\");\n__webpack_require__(/*! core-js/modules/es.object.assign.js */ \"../../node_modules/core-js/modules/es.object.assign.js\");\n__webpack_require__(/*! core-js/modules/es.object.create.js */ \"../../node_modules/core-js/modules/es.object.create.js\");\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\n__webpack_require__(/*! core-js/modules/es.object.get-own-property-descriptor.js */ \"../../node_modules/core-js/modules/es.object.get-own-property-descriptor.js\");\n__webpack_require__(/*! core-js/modules/es.object.get-prototype-of.js */ \"../../node_modules/core-js/modules/es.object.get-prototype-of.js\");\n__webpack_require__(/*! core-js/modules/es.reflect.construct.js */ \"../../node_modules/core-js/modules/es.reflect.construct.js\");\n__webpack_require__(/*! core-js/modules/es.string.iterator.js */ \"../../node_modules/core-js/modules/es.string.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.weak-map.js */ \"../../node_modules/core-js/modules/es.weak-map.js\");\n__webpack_require__(/*! core-js/modules/web.dom-collections.iterator.js */ \"../../node_modules/core-js/modules/web.dom-collections.iterator.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.concat.js */ \"../../node_modules/core-js/modules/es.array.concat.js\");\n__webpack_require__(/*! core-js/modules/es.array.for-each.js */ \"../../node_modules/core-js/modules/es.array.for-each.js\");\n__webpack_require__(/*! core-js/modules/es.array.index-of.js */ \"../../node_modules/core-js/modules/es.array.index-of.js\");\n__webpack_require__(/*! core-js/modules/es.array.is-array.js */ \"../../node_modules/core-js/modules/es.array.is-array.js\");\n__webpack_require__(/*! core-js/modules/es.array.join.js */ \"../../node_modules/core-js/modules/es.array.join.js\");\n__webpack_require__(/*! core-js/modules/es.array.map.js */ \"../../node_modules/core-js/modules/es.array.map.js\");\n__webpack_require__(/*! core-js/modules/es.date.now.js */ \"../../node_modules/core-js/modules/es.date.now.js\");\n__webpack_require__(/*! core-js/modules/es.date.to-string.js */ \"../../node_modules/core-js/modules/es.date.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.function.bind.js */ \"../../node_modules/core-js/modules/es.function.bind.js\");\n__webpack_require__(/*! core-js/modules/es.object.keys.js */ \"../../node_modules/core-js/modules/es.object.keys.js\");\n__webpack_require__(/*! core-js/modules/es.object.set-prototype-of.js */ \"../../node_modules/core-js/modules/es.object.set-prototype-of.js\");\n__webpack_require__(/*! core-js/modules/es.object.to-string.js */ \"../../node_modules/core-js/modules/es.object.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.promise.js */ \"../../node_modules/core-js/modules/es.promise.js\");\n__webpack_require__(/*! core-js/modules/es.regexp.exec.js */ \"../../node_modules/core-js/modules/es.regexp.exec.js\");\n__webpack_require__(/*! core-js/modules/es.regexp.to-string.js */ \"../../node_modules/core-js/modules/es.regexp.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.string.replace.js */ \"../../node_modules/core-js/modules/es.string.replace.js\");\n__webpack_require__(/*! core-js/modules/es.string.trim.js */ \"../../node_modules/core-js/modules/es.string.trim.js\");\n__webpack_require__(/*! core-js/modules/web.dom-collections.for-each.js */ \"../../node_modules/core-js/modules/web.dom-collections.for-each.js\");\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"webpack/sharing/consume/default/react/react?dca2\"));\nvar _classnames = _interopRequireDefault(__webpack_require__(/*! classnames */ \"../../node_modules/classnames/index.js\"));\nvar _ApprovalRecord = _interopRequireDefault(__webpack_require__(/*! ../../css/ApprovalRecord.less */ \"./src/workflow/css/ApprovalRecord.less\"));\nvar _ApprovalRecordNew = _interopRequireDefault(__webpack_require__(/*! ../../css/ApprovalRecordNew.less */ \"./src/workflow/css/ApprovalRecordNew.less\"));\nvar _approvalRecordAction = __webpack_require__(/*! ../../actions/approvalRecordAction */ \"./src/workflow/actions/approvalRecordAction.js\");\nvar _appModelFunction = __webpack_require__(/*! ../../../model/appModelFunction */ \"./src/model/appModelFunction.js\");\nvar _action = __webpack_require__(/*! ../../../action/action */ \"./src/action/action.js\");\nvar _auto_audit = _interopRequireDefault(__webpack_require__(/*! ../../images/auto_audit.png */ \"./src/workflow/images/auto_audit.png\"));\nvar _callActivity = _interopRequireDefault(__webpack_require__(/*! ../../images/callActivity.png */ \"./src/workflow/images/callActivity.png\"));\nvar _moren = _interopRequireDefault(__webpack_require__(/*! ../../images/moren2.png */ \"./src/workflow/images/moren2.png\"));\nvar _moren2 = _interopRequireDefault(__webpack_require__(/*! ../../images/moren.png */ \"./src/workflow/images/moren.png\"));\nvar _up = _interopRequireDefault(__webpack_require__(/*! ../../images/up.png */ \"./src/workflow/images/up.png\"));\nvar _workflowUtil = __webpack_require__(/*! ../../util/workflowUtil */ \"./src/workflow/util/workflowUtil.js\");\nvar _KDYzjChat = _interopRequireDefault(__webpack_require__(/*! ../KDYzjChat */ \"./src/workflow/components/KDYzjChat.js\"));\nvar _trace = _interopRequireDefault(__webpack_require__(/*! ../../../util/trace */ \"./src/util/trace.js\"));\nvar _clientApi = _interopRequireDefault(__webpack_require__(/*! @/plugin/clientApi */ \"./src/plugin/clientApi.js\"));\nvar _intlApi = __webpack_require__(/*! ../../../i18n/intlApi */ \"./src/i18n/intlApi.js\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction _getRequireWildcardCache(e) { if (\"function\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return { \"default\": e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\"default\" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n[\"default\"] = e, t && t.set(e, n), n; }\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction listenTray() {\n  var yzjChatWindow = $('#im-chat-container');\n  var cls = _ApprovalRecordNew[\"default\"].chatPosition;\n  if (yzjChatWindow.length > 0 && yzjChatWindow.hasClass(cls)) {\n    yzjChatWindow.removeClass(cls);\n  }\n}\nvar KDApprovalRecordNew = exports[\"default\"] = /*#__PURE__*/function (_Component) {\n  _inherits(KDApprovalRecordNew, _Component);\n  function KDApprovalRecordNew(props) {\n    var _this;\n    _classCallCheck(this, KDApprovalRecordNew);\n    _this = _callSuper(this, KDApprovalRecordNew, [props]);\n    _this.data = {\n      openIds: [],\n      groupIds: {}\n    };\n    _this.state = {\n      tipHover: 0,\n      attachementsWidth: 180\n    };\n    return _this;\n  }\n  _createClass(KDApprovalRecordNew, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      if (this.refs.contentMobile) {\n        this.setState({\n          attachementsWidth: this.refs.contentMobile.offsetWidth - 75\n        });\n      }\n    }\n  }, {\n    key: \"_openChatWindow\",\n    value: function _openChatWindow(groupId) {\n      var tray = $('.im-tray');\n      var cls = _ApprovalRecordNew[\"default\"].chatPosition;\n      tray.unbind('click', listenTray);\n      window.pcyzjShare.openChat({\n        groupId: groupId\n      });\n      $('#im-session-left').toggleClass('im-listAppear');\n      if (tray.length > 0) {\n        $('#im-chat-container').addClass(cls);\n        tray.bind('click', listenTray);\n      }\n    }\n  }, {\n    key: \"_chatClick\",\n    value: function _chatClick(e, openId, name) {\n      var model = this.props.model;\n      var isPC = model.getDataProperty('isPC');\n      var openIds = [];\n      if (openId == 'moreChat') {\n        openIds = this.data.openIds;\n      } else {\n        openIds.push(openId);\n      }\n      var arg = [{\n        openIds: openIds,\n        groupName: name\n      }];\n      var param = [{\n        key: model.key,\n        methodName: 'itemClick',\n        args: arg,\n        postData: []\n      }];\n      if (isPC == 'false') {\n        this.getGroupId(param, openId);\n      } else {\n        var groupId = this.data.groupIds[openId];\n        if (groupId) {\n          this._openChatWindow(groupId);\n        } else {\n          this.getGroupId(param, openId);\n        }\n      }\n    }\n  }, {\n    key: \"getGroupId\",\n    value: function getGroupId(param, openId) {\n      var _this2 = this;\n      var tmp = {};\n      var _this$props = this.props,\n        model = _this$props.model,\n        dispatch = _this$props.dispatch;\n      var pageId = model.getDataProperty('pageId') || model.pageId;\n      var AppId = (0, _appModelFunction.getAppId)(pageId)(window.store.getState());\n      tmp.pageId = model.pageId;\n      tmp.params = param;\n      var url = 'form/batchInvokeAction.do';\n      var post = Object.keys(tmp).map(function (key) {\n        return key + '=' + _this2.encodeParam(tmp[key]);\n      }).join('&');\n      post = post + '&appId=' + this.encodeParam(AppId);\n      window.fetch(url, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded;charset=utf-8;',\n          ajax: true,\n          traceId: (0, _trace[\"default\"])()\n        },\n        body: post,\n        mode: 'cors',\n        credentials: 'include'\n      }).then(function (response) {\n        if (response.ok) {\n          return response.json();\n        } else {\n          throw new Error(response.statusText);\n        }\n      }).then(function (json) {\n        (0, _action.doPostActions)(model.pageId, json, dispatch);\n      });\n    }\n  }, {\n    key: \"encodeParam\",\n    value: function encodeParam(value) {\n      if (_typeof(value) === 'object') {\n        return encodeURIComponent(JSON.stringify(value));\n      }\n      return encodeURIComponent(value);\n    }\n  }, {\n    key: \"_renderChild\",\n    value: function _renderChild(children, flag) {\n      var _this3 = this;\n      var _this$props2 = this.props,\n        model = _this$props2.model,\n        dispatch = _this$props2.dispatch;\n      var isPC = model.getDataProperty('isPC') || '';\n      var hideChat = model.getDataProperty('hideChat');\n      var isDDOrQYWX = model.getDataProperty('isDDOrQYWX');\n      var list = [];\n      var ids = this.data.openIds;\n      var fileServer = model.getFormConfig();\n      children.forEach(function (value, index, array) {\n        if (value.openId && ids.indexOf(value.openId) == -1) {\n          _this3.data.openIds.push(value.openId);\n        }\n        var userAvatar = (0, _workflowUtil.getImageUrl)(value.avatar, fileServer);\n        var timeFormat = value.formatStrTime;\n        // 后台数据结构最好做下调整，考虑对另外一种视图的影响，就先这么控制\n        var lastNodeClass = value.groupDecisionType == 'wait' && value.decisionType != 'approve' && value.decisionType != 'reject' ? 'unvisible' : '';\n        var stateInfo;\n        var stateInfoClass;\n        var resultInfo = (0, _workflowUtil.sanitize)(value.message);\n        var firstResultInfoClass;\n        var firstAssigneeClass;\n        var firstTimeClass;\n        var firstAssigneeStateClass;\n        var assigneeStateType;\n        var assigneeName;\n        var sanitizeResult = (0, _workflowUtil.sanitize)(value.result);\n        if (value.assignee == undefined) {\n          assigneeName = (0, _intlApi.getLangMsg)({\n            key: 'KDApprovalRecordNew.chulizhong'\n          });\n        } else {\n          assigneeName = value.assignee;\n        }\n        // let assigneeName = value.assignee.split(\"|\")[0];\n        if (value.groupDecisionType == 'wait') {\n          // stateInfo = \"待\"+assigneeName+\" 审批\";\n          if (assigneeName != (0, _intlApi.getLangMsg)({\n            key: 'KDApprovalRecordNew.chulizhong'\n          })) {\n            stateInfo = (0, _intlApi.getLangMsg)({\n              key: 'KDApprovalRecordNew.dai'\n            }) + ' ' + assigneeName.trim() + ' ' + (0, _intlApi.getLangMsg)({\n              key: 'KDApprovalRecordNew.shenpi'\n            });\n          } else {\n            stateInfo = assigneeName;\n          }\n          stateInfoClass = 'stateInfoClassWait';\n        } else if (value.groupDecisionType == 'submit') {\n          if (flag) {\n            resultInfo = (0, _intlApi.getLangMsg)({\n              key: 'KDApprovalRecordNew.faqishenpi'\n            });\n          } else {\n            resultInfo = (0, _intlApi.getLangMsg)({\n              key: 'KDApprovalRecordNew.yitijiao'\n            });\n          }\n          firstResultInfoClass = 'firstResultInfoClass';\n          firstAssigneeClass = 'firstAssigneeClass';\n          firstTimeClass = 'firstTimeClass';\n          firstAssigneeStateClass = 'unvisible';\n        } else if (value.groupDecisionType == 'manualSuspended') {\n          stateInfo = (0, _intlApi.getLangMsg)({\n            key: 'KDApprovalRecordNew.yishoudongguaqi'\n          });\n        }\n        if (value.decisionType == 'approve') {\n          stateInfo = (0, _intlApi.getLangMsg)({\n            key: 'KDApprovalRecordNew.yishenpi'\n          });\n          assigneeStateType = 'assigneeStateAgree';\n        } else if (value.decisionType == 'reject') {\n          stateInfo = (0, _intlApi.getLangMsg)({\n            key: 'KDApprovalRecordNew.yibohui'\n          });\n          stateInfoClass = 'stateInfoClassReject';\n          assigneeStateType = 'assigneeStateRefuse';\n        } else if (value.decisionType == 'terminate') {\n          stateInfo = (0, _intlApi.getLangMsg)({\n            key: 'KDApprovalRecordNew.shenpizhongzhi'\n          });\n          stateInfoClass = 'stateInfoClassReject';\n          assigneeStateType = 'assigneeStateTerminate';\n        } else if (value.decisionType == 'forceReject') {\n          stateInfo = (0, _intlApi.getLangMsg)({\n            key: 'KDApprovalRecordNew.yiqiangzhibohui'\n          });\n          stateInfoClass = 'stateInfoClassReject';\n          assigneeStateType = 'assigneeStateRefuse';\n        }\n        if (value.decisionType == 'approve' || value.decisionType == 'reject') {\n          value.groupDecisionType = value.decisionType;\n        }\n        if (Array.isArray(value.trusteeOpenIds) && value.trusteeOpenIds.length != 0) {\n          var _iterator = _createForOfIteratorHelper(value.trusteeOpenIds),\n            _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var id = _step.value;\n              ids.push(id);\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        }\n        var submitNodeClass = value.groupDecisionType == 'submit' || value.huiqiansuccess == true ? 'unvisible' : '';\n        var isAutoNodeClaass = value.userId == -1 ? 'unvisible' : '';\n        if (value.groupDecisionType == 'wait' && value.handleState == 'dismissed' && value.artificialNode == true) {\n          list.push( /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n            className: _ApprovalRecordNew[\"default\"].contentMobile,\n            key: 'children' + index\n          }, /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n            className: _ApprovalRecordNew[\"default\"].textWrap1\n          }, /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n            className: _ApprovalRecordNew[\"default\"].textWrap\n          }, /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n            style: {\n              display: 'flex'\n            }\n          }, /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n            className: (0, _classnames[\"default\"])(_ApprovalRecordNew[\"default\"].assignee, _ApprovalRecordNew[\"default\"].assigneeDismissedClass),\n            dangerouslySetInnerHTML: {\n              __html: assigneeName\n            }\n          })), /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n            className: _ApprovalRecordNew[\"default\"].stateInfoDismissedClass,\n            dangerouslySetInnerHTML: {\n              __html: (0, _intlApi.getLangMsg)({\n                key: 'KDApprovalRecordNew.daitijiao'\n              })\n            }\n          }))), /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n            className: _ApprovalRecord[\"default\"]['btn-panel']\n          }, (0, _workflowUtil.createCustomizedLinks)(value, function (e, params) {\n            _this3.props.dispatch((0, _approvalRecordAction.clickCustomizeLink)(_this3.props.model, params));\n          })), value.coordinate == true ? /*#__PURE__*/_react[\"default\"].createElement(CoordinateRecords, {\n            taskId: value.taskId,\n            userId: value.userStr,\n            dispatch: dispatch,\n            model: model,\n            autoCoordinate: true\n          }) : '', value.showTransferRecord == true ? /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n            className: _ApprovalRecordNew[\"default\"]['coordinate-record'],\n            onClick: function onClick(e) {\n              _this3.showTransferRecord.bind(_this3)(e, value);\n            }\n          }, /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n            className: _ApprovalRecordNew[\"default\"].coordinate\n          }, /*#__PURE__*/_react[\"default\"].createElement(\"span\", null, (0, _intlApi.getLangMsg)({\n            key: 'ApprovalHistoryRecord.zhuangjiaolishi'\n          }).replace(/\\%s/, _this3.props.model.getDataProperty('transferName'))), /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n            className: (0, _classnames[\"default\"])(_ApprovalRecordNew[\"default\"].arrow, _ApprovalRecordNew[\"default\"].arrowleft)\n          }))) : ' '));\n        } else if (value.callActivity) {\n          list.push( /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n            className: _ApprovalRecordNew[\"default\"].contentMobile,\n            key: 'children' + index\n          }, /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n            className: (0, _classnames[\"default\"])(_ApprovalRecordNew[\"default\"].textWrap, _ApprovalRecordNew[\"default\"][submitNodeClass])\n          }, /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n            className: _ApprovalRecordNew[\"default\"].textContent\n          }, /*#__PURE__*/_react[\"default\"].createElement(\"h4\", {\n            className: _ApprovalRecordNew[\"default\"].textContenthMobile\n          }, /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n            dangerouslySetInnerHTML: {\n              __html: value.activityName\n            }\n          })))), /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n            className: (0, _classnames[\"default\"])(_ApprovalRecordNew[\"default\"].textWrap1, _ApprovalRecordNew[\"default\"][lastNodeClass])\n          }, /*#__PURE__*/_react[\"default\"].createElement(\"div\", null, /*#__PURE__*/_react[\"default\"].createElement(\"img\", {\n            className: _ApprovalRecordNew[\"default\"].userImg,\n            src: _callActivity[\"default\"],\n            alt: (0, _intlApi.getLangMsg)({\n              key: 'ApprovalHistoryRecord.yonghutouxiang'\n            })\n          }), /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n            className: (0, _classnames[\"default\"])(_ApprovalRecordNew[\"default\"].assigneeState, _ApprovalRecordNew[\"default\"][assigneeStateType], _ApprovalRecordNew[\"default\"][firstAssigneeStateClass])\n          })), /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n            className: _ApprovalRecordNew[\"default\"].textWrap\n          }, /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n            className: (0, _classnames[\"default\"])(_ApprovalRecordNew[\"default\"].callActivityResult, _ApprovalRecordNew[\"default\"][value.decisionType == 'wait' ? 'stateInfoClassWait' : 'stateInfoClassApprove']),\n            dangerouslySetInnerHTML: {\n              __html: sanitizeResult\n            }\n          }), /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n            className: _ApprovalRecordNew[\"default\"].callActivityName,\n            onClick: function onClick(e) {\n              _this3.showChildProcessInfo.bind(_this3)(e, value.procInstId, value.subCrossTenantInfo);\n            }\n          }, value.message), /*#__PURE__*/_react[\"default\"].createElement(\"p\", {\n            className: (0, _classnames[\"default\"])(_ApprovalRecordNew[\"default\"].time, _ApprovalRecordNew[\"default\"][firstTimeClass])\n          }, timeFormat)))));\n        } else {\n          var addSignMessage = (0, _workflowUtil.sanitize)(value.addSignMsg || '');\n          var attachmentClass = value.attachments && value.attachments.length > 0 ? 'block' : 'none';\n          var _isPC = model.getDataProperty('isPC');\n          list.push( /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n            className: _ApprovalRecordNew[\"default\"].contentMobile,\n            ref: \"contentMobile\",\n            key: 'children' + index\n          }, /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n            className: (0, _classnames[\"default\"])(_ApprovalRecordNew[\"default\"].textWrap, _ApprovalRecordNew[\"default\"][submitNodeClass])\n          }, /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n            className: _ApprovalRecordNew[\"default\"].textContent\n          }, /*#__PURE__*/_react[\"default\"].createElement(\"h4\", {\n            className: _ApprovalRecordNew[\"default\"].textContenthMobile\n          }, /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n            dangerouslySetInnerHTML: {\n              __html: value.activityName\n            }\n          })), /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n            className: (0, _classnames[\"default\"])(_ApprovalRecordNew[\"default\"].textContextState, _ApprovalRecordNew[\"default\"][stateInfoClass]),\n            dangerouslySetInnerHTML: {\n              __html: stateInfo\n            }\n          }), /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n            className: (0, _classnames[\"default\"])(_ApprovalRecordNew[\"default\"].textContextArrow, _ApprovalRecordNew[\"default\"][isAutoNodeClaass]),\n            onClick: function onClick(e) {\n              return _this3.showApprovalsPage(e, [value], value.groupType, value.groupDecisionType, value.throughRule, isDDOrQYWX);\n            }\n          }), /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n            className: _ApprovalRecordNew[\"default\"].addSignMsg,\n            dangerouslySetInnerHTML: {\n              __html: addSignMessage\n            }\n          }))), (value.showAutoCoordinate == true || value.coordinate == true) && value.groupDecisionType == 'wait' ? /*#__PURE__*/_react[\"default\"].createElement(CoordinateRecords, {\n            taskId: value.taskId,\n            userId: value.userStr,\n            dispatch: dispatch,\n            model: model,\n            getFormatTime: function getFormatTime(time) {\n              return _this3.getFormatTime(time);\n            },\n            autoCoordinate: true\n          }) : '', value.groupDecisionType != 'wait' && value.showAutoCoordinate == true ? /*#__PURE__*/_react[\"default\"].createElement(AutoCoordinateRecords, {\n            group: value.group,\n            dispatch: dispatch,\n            model: model\n          }) : '', /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n            className: (0, _classnames[\"default\"])(_ApprovalRecordNew[\"default\"].textWrap1, _ApprovalRecordNew[\"default\"][lastNodeClass])\n          }, /*#__PURE__*/_react[\"default\"].createElement(\"div\", null, /*#__PURE__*/_react[\"default\"].createElement(\"img\", {\n            className: _ApprovalRecordNew[\"default\"].userImg,\n            src: userAvatar || (value.userStr == '-1' ? _auto_audit[\"default\"] : _moren2[\"default\"]),\n            alt: (0, _intlApi.getLangMsg)({\n              key: 'ApprovalHistoryRecord.yonghutouxiang'\n            }),\n            onClick: function onClick(e) {\n              return _this3.showPersonInfo(e, value.openId, value.userStr, isDDOrQYWX);\n            }\n          }), /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n            className: (0, _classnames[\"default\"])(_ApprovalRecordNew[\"default\"].assigneeState, _ApprovalRecordNew[\"default\"][assigneeStateType], _ApprovalRecordNew[\"default\"][firstAssigneeStateClass])\n          })), /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n            className: _ApprovalRecordNew[\"default\"].textWrap\n          }, /*#__PURE__*/_react[\"default\"].createElement(\"span\", null, /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n            className: (0, _classnames[\"default\"])(_ApprovalRecordNew[\"default\"].assignee, _ApprovalRecordNew[\"default\"][firstAssigneeClass])\n          }, assigneeName), /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n            className: (0, _classnames[\"default\"])(_ApprovalRecordNew[\"default\"].result, _ApprovalRecordNew[\"default\"][firstResultInfoClass]),\n            dangerouslySetInnerHTML: {\n              __html: resultInfo\n            }\n          }), (0, _workflowUtil.createSignatureApprovalRecord)(true, _isPC, value.signature), /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n            className: _ApprovalRecordNew[\"default\"].procAttach,\n            style: {\n              display: attachmentClass,\n              width: _this3.state.attachementsWidth + 'px'\n            }\n          }, value.attachments && value.attachments.length > 0 ? value.attachments.map(function (item, index) {\n            return /*#__PURE__*/_react[\"default\"].createElement(AttachmentItem, _extends({}, item, {\n              dispatch: _this3.props.dispatch,\n              model: _this3.props.model,\n              attachmentIds: value.state,\n              key: index\n            }));\n          }) : '')), /*#__PURE__*/_react[\"default\"].createElement(\"p\", {\n            className: (0, _classnames[\"default\"])(_ApprovalRecordNew[\"default\"].time, _ApprovalRecordNew[\"default\"][firstTimeClass])\n          }, timeFormat))), /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n            className: _ApprovalRecord[\"default\"]['btn-panel']\n          }, (0, _workflowUtil.createCustomizedLinks)(value, function (e, params) {\n            _this3.props.dispatch((0, _approvalRecordAction.clickCustomizeLink)(_this3.props.model, params));\n          })), value.coordinate == true && value.groupDecisionType != 'wait' ? /*#__PURE__*/_react[\"default\"].createElement(CoordinateRecords, {\n            taskId: value.taskId,\n            userId: value.userStr,\n            dispatch: dispatch,\n            model: model,\n            getFormatTime: function getFormatTime(time) {\n              return _this3.getFormatTime(time);\n            },\n            autoCoordinate: false\n          }) : '', value.showTransferRecord == true ? /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n            className: _ApprovalRecordNew[\"default\"]['coordinate-record'],\n            onClick: function onClick(e) {\n              _this3.showTransferRecord.bind(_this3)(e, value);\n            }\n          }, /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n            className: _ApprovalRecordNew[\"default\"].coordinate\n          }, /*#__PURE__*/_react[\"default\"].createElement(\"span\", null, (0, _intlApi.getLangMsg)({\n            key: 'ApprovalHistoryRecord.zhuangjiaolishi'\n          }).replace(/\\%s/, _this3.props.model.getDataProperty('transferName'))), /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n            className: (0, _classnames[\"default\"])(_ApprovalRecordNew[\"default\"].arrow, _ApprovalRecordNew[\"default\"].arrowleft)\n          }))) : ' '));\n        }\n      });\n      return list;\n    }\n  }, {\n    key: \"showChildProcessInfo\",\n    value: function showChildProcessInfo(e, procInstId, subCrossTenantInfo) {\n      var params = {};\n      params.pageId = this.props.model.getDataProperty('pageId');\n      params.isPC = this.props.model.getDataProperty('isPC');\n      params.hideMoreChat = this.props.model.getDataProperty('hideMoreChat');\n      params.hideChat = this.props.model.getDataProperty('hideChat');\n      params.noTimeLine = this.props.model.getDataProperty('noTimeLine');\n      params.approvalIsNew = this.props.model.getDataProperty('approvalIsNew');\n      params.isDDOrQYWX = this.props.model.getDataProperty('isDDOrQYWX');\n      this.props.dispatch((0, _approvalRecordAction.showChildProcessInfo)(this.props.model, {\n        params: params,\n        procinstid: procInstId,\n        subcrosstenantinfo: subCrossTenantInfo\n      }));\n    }\n  }, {\n    key: \"showPersonInfo\",\n    value: function showPersonInfo(e, openId, userId, isDDOrQYWX) {\n      if (userId == -1) {\n        return;\n      }\n      if (openId) {\n        (0, _clientApi[\"default\"])('personInfo', {\n          data: {\n            openId: openId\n          }\n        });\n      } else {\n        this.props.dispatch((0, _approvalRecordAction.showPersonInfo)(this.props.model, {\n          userid: userId + ''\n        }));\n      }\n    }\n  }, {\n    key: \"showTransferRecord\",\n    value: function showTransferRecord(e, value) {\n      this.props.dispatch((0, _approvalRecordAction.showTransferRecord)(this.props.model, {\n        taskid: value.taskId,\n        userid: value.userStr,\n        iscoordinate: false\n      }));\n    }\n  }, {\n    key: \"showTransferRecordYZJ\",\n    value: function showTransferRecordYZJ(e, value) {\n      this.props.dispatch((0, _approvalRecordAction.showTransferRecordYZJ)(this.props.model, {\n        value: value,\n        iscoordinate: false\n      }));\n    }\n  }, {\n    key: \"getFormatTime\",\n    value: function getFormatTime(time) {\n      if (time == null || time == '' || time == undefined) {\n        return null;\n      }\n      var date = new Date(time);\n      var M = date.getMonth() + 1 < 10 ? '0' + (date.getMonth() + 1) : date.getMonth() + 1;\n      var D = date.getDate() < 10 ? '0' + date.getDate() : date.getDate();\n      var h = date.getHours() < 10 ? '0' + date.getHours() : date.getHours();\n      var m = date.getMinutes() < 10 ? '0' + date.getMinutes() : date.getMinutes();\n      return M + '/' + D + ' ' + h + ':' + m;\n    }\n  }, {\n    key: \"setTipHover\",\n    value: function setTipHover(e) {\n      var tipHover = this.state.tipHover;\n      tipHover = tipHover == 0 ? 1 : 0;\n      this.setState({\n        tipHover: tipHover\n      });\n    }\n  }, {\n    key: \"_renderItem\",\n    value: function _renderItem(approvalRecordItems) {\n      var _this4 = this;\n      var _this$props3 = this.props,\n        model = _this$props3.model,\n        dispatch = _this$props3.dispatch;\n      var noTimeLine = model.getDataProperty('noTimeLine') || '';\n      var isDDOrQYWX = model.getDataProperty('isDDOrQYWX');\n      var list = [];\n      approvalRecordItems.forEach(function (value, index, array) {\n        var nodeTypeImg = 'agree';\n        var timeLineColor = 'timeLineAgree';\n        if (value.groupDecisionType == 'reject' || value.groupDecisionType == 'forceReject' || value.groupDecisionType == 'terminate') {\n          nodeTypeImg = 'refuse';\n          timeLineColor = 'timeLineRefuse';\n        } else if (value.groupDecisionType == 'wait' || value.groupDecisionType == 'manualSuspended') {\n          nodeTypeImg = 'waiting';\n          timeLineColor = 'timeLineWait';\n        }\n        var firstCircleClass = value.groupDecisionType == 'submit' ? 'firstCircle' : '';\n        var waitChildren = [];\n        var finishChildren = [];\n        if (value.activityName && value.children.length > 0) {\n          for (var i = 0; i < value.children.length > 0; i++) {\n            if (value.children[i].decisionType == 'approve' || value.children[i].decisionType == 'reject' || value.children[i].decisionType == 'terminate' || value.children[i].decisionType == 'forceReject') {\n              value.children[i].huiqiansuccess = true;\n              finishChildren.push(value.children[i]);\n            } else {\n              waitChildren.push(value.children[i]);\n            }\n          }\n        } else if (value.children.length > 0 && value.groupType) {\n          for (var _i = 0; _i < value.children.length > 0; _i++) {\n            value.children[_i].groupType = value.groupType;\n            value.children[_i].throughRule = value.throughRule;\n          }\n        }\n        var stateInfo = (0, _intlApi.getLangMsg)({\n          key: 'KDApprovalRecordNew.dai'\n        }) + ' ';\n        if (waitChildren.length > 0 && waitChildren.length <= 3) {\n          for (var _i2 = 0; _i2 < waitChildren.length; _i2++) {\n            // let assignee = waitChildren[i].assignee.split(\"|\")[0];\n            var assignee = void 0;\n            if (waitChildren[_i2].assignee == undefined) {\n              assignee = (0, _intlApi.getLangMsg)({\n                key: 'KDApprovalRecordNew.chulizhong'\n              });\n            } else {\n              assignee = waitChildren[_i2].assignee;\n            }\n            stateInfo += assignee + ' ';\n          }\n        } else if (waitChildren.length > 3) {\n          for (var _i3 = 0; _i3 < 3; _i3++) {\n            // let assignee = waitChildren[i].assignee.split(\"|\")[0];\n            var _assignee = void 0;\n            if (waitChildren[_i3].assignee == undefined) {\n              _assignee = (0, _intlApi.getLangMsg)({\n                key: 'KDApprovalRecordNew.chulizhong'\n              });\n            } else {\n              _assignee = waitChildren[_i3].assignee;\n            }\n            stateInfo += _assignee + ' ';\n          }\n          stateInfo += (0, _intlApi.getLangMsg)({\n            key: 'KDApprovalRecordNew.deng'\n          }) + waitChildren.length + (0, _intlApi.getLangMsg)({\n            key: 'KDApprovalRecordNew.ren'\n          });\n        }\n        stateInfo += ' ' + (0, _intlApi.getLangMsg)({\n          key: 'KDApprovalRecordNew.shenpi'\n        });\n        if (value.groupDecisionType == 'manualSuspended') {\n          stateInfo = (0, _intlApi.getLangMsg)({\n            key: 'KDApprovalRecordNew.yishoudongguaqi'\n          });\n        }\n        var stateInfoClass;\n        if (value.activityName) {\n          if (value.groupDecisionType == 'approve') {\n            stateInfo = (0, _intlApi.getLangMsg)({\n              key: 'KDApprovalRecordNew.yishenpi'\n            });\n          } else if (value.groupDecisionType == 'reject') {\n            stateInfo = (0, _intlApi.getLangMsg)({\n              key: 'KDApprovalRecordNew.yibohui'\n            });\n            stateInfoClass = 'stateInfoClassReject';\n          } else if (value.groupDecisionType == 'terminate') {\n            stateInfo = (0, _intlApi.getLangMsg)({\n              key: 'KDApprovalRecordNew.shenpizhongzhi'\n            });\n            stateInfoClass = 'stateInfoClassReject';\n          } else if (value.groupDecisionType == 'forceReject') {\n            stateInfo = (0, _intlApi.getLangMsg)({\n              key: 'KDApprovalRecordNew.yiqiangzhibohui'\n            });\n            stateInfoClass = 'stateInfoClassReject';\n          }\n        }\n        if (waitChildren.length > 0) {\n          stateInfoClass = 'stateInfoClassWait';\n        }\n        if (value.callActivity) {\n          stateInfo = (0, _intlApi.getLangMsg)({\n            key: 'KDApprovalRecordNew.chulizhong'\n          });\n        }\n        for (var _i4 = 0; _i4 < value.children.length > 0; _i4++) {\n          if (value.groupDecisionType == 'terminate') {\n            value.children[_i4].groupDecisionType = value.groupDecisionType;\n          }\n          value.children[_i4].showAutoCoordinate = false;\n          if (value.showAutoCoordinate && !value.activityName) {\n            value.children[_i4].showAutoCoordinate = true;\n          }\n        }\n        var showTransferRecordValue = false;\n        var childrenValue = {};\n        for (var _i5 = 0; _i5 < value.children.length > 0; _i5++) {\n          if (value.children[_i5].showTransferRecord == true && value.children[_i5].groupDecisionType == 'wait') {\n            showTransferRecordValue = true;\n            var childrenTaskId = value.children[_i5].taskId;\n            var childrenUserStr = value.children[_i5].userStr;\n            childrenValue[childrenTaskId] = childrenUserStr;\n          }\n        }\n        var addSignMessage = (0, _workflowUtil.sanitize)(value.addSignMsg || '');\n        var flag = index == array.length - 1;\n        list.push( /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n          className: _ApprovalRecordNew[\"default\"].rowStyle,\n          style: {\n            width: '100%'\n          },\n          key: 'approvalRecord' + index\n        }, /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n          className: index == approvalRecordItems.length - 1 ? (0, _classnames[\"default\"])(_ApprovalRecordNew[\"default\"].timeLine, _ApprovalRecordNew[\"default\"].lastNode, _ApprovalRecordNew[\"default\"][timeLineColor]) : (0, _classnames[\"default\"])(_ApprovalRecordNew[\"default\"].timeLine, _ApprovalRecordNew[\"default\"][timeLineColor])\n        }, !noTimeLine ? /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n          className: (0, _classnames[\"default\"])(_ApprovalRecordNew[\"default\"].circle, _ApprovalRecordNew[\"default\"][nodeTypeImg], _ApprovalRecordNew[\"default\"][firstCircleClass])\n        }) : ''), value.activityName ? /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n          className: _ApprovalRecordNew[\"default\"].contentMobile\n        }, /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n          className: (0, _classnames[\"default\"])(_ApprovalRecordNew[\"default\"].textWrap, _ApprovalRecordNew[\"default\"][''])\n        }, /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n          className: _ApprovalRecordNew[\"default\"].textContent\n        }, /*#__PURE__*/_react[\"default\"].createElement(\"h4\", {\n          className: _ApprovalRecordNew[\"default\"].textContenthMobile\n        }, /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n          dangerouslySetInnerHTML: {\n            __html: value.activityName\n          }\n        })), /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n          className: (0, _classnames[\"default\"])(_ApprovalRecordNew[\"default\"].textContextState, _ApprovalRecordNew[\"default\"][stateInfoClass]),\n          dangerouslySetInnerHTML: {\n            __html: stateInfo\n          }\n        }), /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n          className: _ApprovalRecordNew[\"default\"].textContextArrow,\n          onClick: function onClick(e) {\n            return _this4.showApprovalsPage(e, value.children, value.groupType, value.groupDecisionType, value.throughRule, isDDOrQYWX);\n          }\n        }))), /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n          className: _ApprovalRecordNew[\"default\"].addSignMsg,\n          dangerouslySetInnerHTML: {\n            __html: addSignMessage\n          }\n        }), /*#__PURE__*/_react[\"default\"].createElement(LinksPanel, {\n          children: waitChildren,\n          dispatch: dispatch,\n          model: model\n        }), (value.showCoordnate == true || value.showAutoCoordinate == true) && value.groupDecisionType == 'wait' ? /*#__PURE__*/_react[\"default\"].createElement(CoordinatingRecord, {\n          children: value.children,\n          dispatch: dispatch,\n          model: model,\n          getFormatTime: function getFormatTime(time) {\n            return _this4.getFormatTime(time);\n          }\n        }) : '', showTransferRecordValue == true && value.groupDecisionType == 'wait' ? /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n          className: _ApprovalRecordNew[\"default\"]['coordinate-record'],\n          onClick: function onClick(e) {\n            _this4.showTransferRecordYZJ.bind(_this4)(e, childrenValue, false);\n          }\n        }, /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n          className: _ApprovalRecordNew[\"default\"].coordinate\n        }, /*#__PURE__*/_react[\"default\"].createElement(\"span\", null, (0, _intlApi.getLangMsg)({\n          key: 'ApprovalHistoryRecord.zhuangjiaolishi'\n        }).replace(/\\%s/, _this4.props.model.getDataProperty('transferName'))), /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n          className: (0, _classnames[\"default\"])(_ApprovalRecordNew[\"default\"].arrow, _ApprovalRecordNew[\"default\"].arrowleft)\n        }))) : ' ', value.groupDecisionType != 'wait' && value.showAutoCoordinate == true ? /*#__PURE__*/_react[\"default\"].createElement(AutoCoordinateRecords, {\n          group: value.group,\n          dispatch: dispatch,\n          model: model\n        }) : '') : '', value.activityName ? _this4._renderChild(finishChildren, flag) : _this4._renderChild(value.children, flag)));\n      });\n      /* if (!hideMoreChat) {\n        list.push(\n          <div className={isPC == 'false' ? classnames(styles['groupChatMobile']) : classnames(styles['groupChat'], 'kd-button')} key={'approvalRecord'} onClick={(e) => { this._chatClick.bind(this)(e, 'moreChat', '') }}>\n            <span>发起群聊沟通</span>\n          </div>\n          )\n      } */\n      return list;\n    }\n  }, {\n    key: \"showApprovalsPage\",\n    value: function showApprovalsPage(e, approvers, signType, groupDecisionType, throughRule, isDDOrQYWX) {\n      // 避免重复点击\n      var clickTime = Date.now();\n      if (!this.lastClickTime || Math.abs(this.lastClickTime - clickTime) > 1000) {\n        this.lastClickTime = clickTime;\n        this.props.dispatch((0, _approvalRecordAction.showApprovalsPage)(this.props.model, {\n          approvers: approvers,\n          signtype: signType || '',\n          groupdecisiontype: groupDecisionType || '',\n          throughrule: throughRule || '',\n          isDDOrQYWX: isDDOrQYWX == undefined ? false : isDDOrQYWX\n        }));\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var model = this.props.model;\n      var isPC = model.getDataProperty('isPC') || '';\n      var noTimeLine = model.getDataProperty('noTimeLine') || '';\n      var containerSty = !noTimeLine ? _ApprovalRecordNew[\"default\"].containerStyle : _ApprovalRecordNew[\"default\"].containerStyleNoLine;\n      var m = model.state;\n      var approvalRecordItems = model.getDataProperty('approvalRecords');\n      var isSubProcess = model.getDataProperty('superProcInstId');\n      return /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: containerSty,\n        style: {\n          marginBottom: isPC == 'false' && !noTimeLine ? '60px' : '0px'\n        }\n      }, /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _ApprovalRecordNew[\"default\"].backToParentProcess,\n        style: {\n          display: isSubProcess ? 'block' : 'none',\n          width: !noTimeLine ? '90%' : '100%'\n        },\n        onClick: this.backToParentProcess.bind(this)\n      }, (0, _intlApi.getLangMsg)({\n        key: 'ApprovalHistoryRecord.fanhuifuliucheng'\n      })), this._renderItem(approvalRecordItems), /*#__PURE__*/_react[\"default\"].createElement(_KDYzjChat[\"default\"], {\n        model: model\n      }));\n    }\n  }, {\n    key: \"backToParentProcess\",\n    value: function backToParentProcess(e) {\n      var params = {};\n      params.pageId = this.props.model.getDataProperty('pageId');\n      params.isPC = this.props.model.getDataProperty('isPC');\n      params.hideMoreChat = this.props.model.getDataProperty('hideMoreChat');\n      params.hideChat = this.props.model.getDataProperty('hideChat');\n      params.noTimeLine = this.props.model.getDataProperty('noTimeLine');\n      params.approvalIsNew = this.props.model.getDataProperty('approvalIsNew');\n      params.isDDOrQYWX = this.props.model.getDataProperty('isDDOrQYWX');\n      var superProcInstId = this.props.model.getDataProperty('superProcInstId');\n      this.props.dispatch((0, _approvalRecordAction.backToParentProcess)(this.props.model, {\n        params: params,\n        superprocInstid: superProcInstId\n      }));\n    }\n  }]);\n  return KDApprovalRecordNew;\n}(_react.Component);\nvar CoordinatingRecord = /*#__PURE__*/function (_Component2) {\n  _inherits(CoordinatingRecord, _Component2);\n  function CoordinatingRecord() {\n    _classCallCheck(this, CoordinatingRecord);\n    return _callSuper(this, CoordinatingRecord, arguments);\n  }\n  _createClass(CoordinatingRecord, [{\n    key: \"render\",\n    value: function render() {\n      var _this5 = this;\n      var children = this.props.children;\n      if (children.length == 0) {\n        return '';\n      }\n      var taskId = '';\n      var userId = '';\n      for (var i = 0; i < children.length; i++) {\n        if (children[i].groupDecisionType == 'wait') {\n          taskId += children[i].taskId + ',';\n          userId += children[i].userId + ',';\n        }\n      }\n      return /*#__PURE__*/_react[\"default\"].createElement(CoordinateRecords, {\n        taskId: taskId.substring(0, taskId.length - 1),\n        userId: userId.substring(0, userId.length - 1),\n        dispatch: this.props.dispatch,\n        model: this.props.model,\n        getFormatTime: function getFormatTime(time) {\n          return _this5.props.getFormatTime(time);\n        },\n        autoCoordinate: true\n      });\n    }\n  }]);\n  return CoordinatingRecord;\n}(_react.Component);\nvar AutoCoordinateRecords = /*#__PURE__*/function (_Component3) {\n  _inherits(AutoCoordinateRecords, _Component3);\n  function AutoCoordinateRecords(props) {\n    var _this6;\n    _classCallCheck(this, AutoCoordinateRecords);\n    _this6 = _callSuper(this, AutoCoordinateRecords, [props]);\n    _this6.state = {\n      showAutoCoordinate: true\n    };\n    return _this6;\n  }\n  _createClass(AutoCoordinateRecords, [{\n    key: \"render\",\n    value: function render() {\n      var _this7 = this;\n      var coordinateRecords = this.props.model.getDataProperty('autocoordinate_' + this.props.group);\n      var coordinateTitle = (0, _intlApi.getLangMsg)({\n        key: 'ApprovalHistoryRecord.chakanzidongxieban'\n      }).replace(/\\%s/, this.props.model.getDataProperty('coordinateName'));\n      if (this.state.showAutoCoordinate == false && coordinateRecords && coordinateRecords.length > 0) {\n        coordinateTitle = coordinateRecords.length + (0, _intlApi.getLangMsg)({\n          key: 'ApprovalHistoryRecord.tiaozidongxiebanjianyi'\n        }).replace(/\\%s/, this.props.model.getDataProperty('coordinateName'));\n      }\n      var arrowDirection = this.state.showAutoCoordinate ? 'arrowleft' : 'arrowdown';\n      return /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _ApprovalRecordNew[\"default\"]['coordinate-record']\n      }, /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _ApprovalRecordNew[\"default\"].coordinate,\n        onClick: function onClick(e) {\n          _this7.switchAutoCoordinate.bind(_this7)(e, _this7.props.group);\n        }\n      }, /*#__PURE__*/_react[\"default\"].createElement(\"span\", null, coordinateTitle), /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n        className: (0, _classnames[\"default\"])(_ApprovalRecordNew[\"default\"].arrow, _ApprovalRecordNew[\"default\"][arrowDirection])\n      })), coordinateRecords && coordinateRecords.length > 0 ? /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        style: {\n          display: this.state.showAutoCoordinate ? 'none' : 'block'\n        }\n      }, coordinateRecords.map(function (item, index) {\n        return /*#__PURE__*/_react[\"default\"].createElement(CoordinateRecordItem, _extends({}, item, {\n          key: index,\n          dispatch: _this7.props.dispatch,\n          model: _this7.props.model\n        }));\n      })) : '');\n    }\n  }, {\n    key: \"switchAutoCoordinate\",\n    value: function switchAutoCoordinate(e, groupId) {\n      this.setState({\n        showAutoCoordinate: !this.state.showAutoCoordinate\n      });\n      if (this.state.showAutoCoordinate == true) {\n        this.props.dispatch((0, _approvalRecordAction.showAutoCoordinateInfo)(this.props.model, {\n          groupid: groupId\n        }));\n      }\n    }\n  }]);\n  return AutoCoordinateRecords;\n}(_react.Component);\nvar CoordinateRecords = /*#__PURE__*/function (_Component4) {\n  _inherits(CoordinateRecords, _Component4);\n  function CoordinateRecords(props) {\n    var _this8;\n    _classCallCheck(this, CoordinateRecords);\n    _this8 = _callSuper(this, CoordinateRecords, [props]);\n    _this8.state = {\n      showCoordinate: true\n    };\n    return _this8;\n  }\n  _createClass(CoordinateRecords, [{\n    key: \"render\",\n    value: function render() {\n      var _this9 = this;\n      var coordinateRecords = this.props.model.getDataProperty('coordinate_' + this.props.taskId + '_' + this.props.userId);\n      var coordinateTitle = (0, _intlApi.getLangMsg)({\n        key: 'ApprovalHistoryRecord.chakanxieban'\n      }).replace(/\\%s/, this.props.model.getDataProperty('coordinateName'));\n      if (this.state.showCoordinate == false && coordinateRecords && coordinateRecords.length > 0) {\n        coordinateTitle = coordinateRecords.length + (0, _intlApi.getLangMsg)({\n          key: 'ApprovalHistoryRecord.tiaoxiebanjianyi'\n        }).replace(/\\%s/, this.props.model.getDataProperty('coordinateName'));\n      }\n      var arrowDirection = this.state.showCoordinate ? 'arrowleft' : 'arrowdown';\n      return /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _ApprovalRecordNew[\"default\"]['coordinate-record']\n      }, /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _ApprovalRecordNew[\"default\"].coordinate,\n        onClick: function onClick(e) {\n          _this9.switchCoordinate.bind(_this9)(e, _this9.props.taskId, _this9.props.userId);\n        }\n      }, /*#__PURE__*/_react[\"default\"].createElement(\"span\", null, coordinateTitle), /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n        className: (0, _classnames[\"default\"])(_ApprovalRecordNew[\"default\"].arrow, _ApprovalRecordNew[\"default\"][arrowDirection])\n      })), coordinateRecords && coordinateRecords.length > 0 ? /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        style: {\n          display: this.state.showCoordinate ? 'none' : 'block'\n        }\n      }, coordinateRecords.map(function (item, index) {\n        return /*#__PURE__*/_react[\"default\"].createElement(CoordinateRecordItem, _extends({}, item, {\n          key: index,\n          dispatch: _this9.props.dispatch,\n          model: _this9.props.model,\n          getFormatTime: function getFormatTime(time) {\n            return _this9.props.getFormatTime(time);\n          }\n        }));\n      })) : '');\n    }\n  }, {\n    key: \"switchCoordinate\",\n    value: function switchCoordinate(e, taskId, userId) {\n      this.setState({\n        showCoordinate: !this.state.showCoordinate\n      });\n      if (this.state.showCoordinate == true) {\n        var autoCoordinate = this.props.autoCoordinate == undefined ? false : this.props.autoCoordinate;\n        this.props.dispatch((0, _approvalRecordAction.showCoordinateInfo)(this.props.model, {\n          taskid: taskId,\n          userid: userId,\n          autocoordinate: autoCoordinate\n        }));\n      }\n    }\n  }]);\n  return CoordinateRecords;\n}(_react.Component);\nvar CoordinateRecordItem = /*#__PURE__*/function (_Component5) {\n  _inherits(CoordinateRecordItem, _Component5);\n  function CoordinateRecordItem() {\n    _classCallCheck(this, CoordinateRecordItem);\n    return _callSuper(this, CoordinateRecordItem, arguments);\n  }\n  _createClass(CoordinateRecordItem, [{\n    key: \"render\",\n    value: function render() {\n      var _this10 = this;\n      var model = this.props.model;\n      var coordinateName = this.props.assignee || '';\n      if ((this.props.time == '' || this.props.time == undefined) && this.props.assignee.split(' ').length >= 2) {\n        coordinateName = this.props.assignee.split(' ')[1].trim();\n      }\n      var coordinatingClass = this.props.time == '' || this.props.time == undefined ? 'inline-block' : 'none';\n      var attachmentClass = this.props.attachments && this.props.attachments.length > 0 ? 'block' : 'none';\n      var coordinateTransRecord = '';\n      if (this.props.showTransferRecord) {\n        coordinateTransRecord = /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n          className: _ApprovalRecordNew[\"default\"].showCoordinateTransfer,\n          onClick: function onClick(e) {\n            _this10.showTransferRecord.bind(_this10)(e, _this10.props.taskId, _this10.props.userStr);\n          }\n        }, /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n          style: {\n            color: '#5e80eb',\n            'margin-right': '3px',\n            \"float\": 'right'\n          }\n        }, \" \", (0, _intlApi.getLangMsg)({\n          key: 'ApprovalHistoryRecord.zhuangjiaolishi'\n        }).replace(/\\%s/, this.props.model.getDataProperty('transferName'))));\n      }\n      var fileServer = model.getFormConfig();\n      var userAvatar = (0, _workflowUtil.getImageUrl)(this.props.avatar, fileServer);\n      var isPC = this.props.model.getDataProperty('isPC');\n      return /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _ApprovalRecordNew[\"default\"].coordinateRecord\n      }, /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        style: {\n          display: 'flex'\n        }\n      }, /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _ApprovalRecordNew[\"default\"].left\n      }, /*#__PURE__*/_react[\"default\"].createElement(\"img\", {\n        className: _ApprovalRecordNew[\"default\"].avatar,\n        src: userAvatar == '' || userAvatar == undefined ? _moren2[\"default\"] : userAvatar\n      })), /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _ApprovalRecordNew[\"default\"].right\n      }, /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _ApprovalRecordNew[\"default\"].coordinateName,\n        style: {\n          marginTop: this.props.time == '' || this.props.time == undefined ? '5px' : '0px'\n        }\n      }, /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n        className: _ApprovalRecordNew[\"default\"].coordinateName\n      }, coordinateName), /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n        className: _ApprovalRecordNew[\"default\"].time\n      }, this.props.time), /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n        className: _ApprovalRecordNew[\"default\"].coordinating,\n        style: {\n          display: coordinatingClass\n        }\n      }, (0, _intlApi.getLangMsg)({\n        key: 'ApprovalHistoryRecord.zhengzaixieban'\n      }).replace(/\\%s/, this.props.model.getDataProperty('coordinateName')))), /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _ApprovalRecordNew[\"default\"].message\n      }, (0, _workflowUtil.crateCoordinateInviteOpinions)(this.props)), (0, _workflowUtil.createSignatureApprovalRecord)(true, isPC, this.props.signature))), coordinateTransRecord, /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _ApprovalRecordNew[\"default\"].fujian,\n        style: {\n          display: attachmentClass\n        }\n      }, this.props.attachments && this.props.attachments.length > 0 ? this.props.attachments.map(function (item, index) {\n        return /*#__PURE__*/_react[\"default\"].createElement(AttachmentItem, _extends({}, item, {\n          dispatch: _this10.props.dispatch,\n          model: _this10.props.model,\n          attachmentIds: _this10.props.state,\n          key: index\n        }));\n      }) : ''));\n    }\n  }, {\n    key: \"showTransferRecord\",\n    value: function showTransferRecord(e, taskId, userId) {\n      this.props.dispatch((0, _approvalRecordAction.showTransferRecord)(this.props.model, {\n        taskid: taskId,\n        userid: userId,\n        iscoordinate: true\n      }));\n    }\n  }]);\n  return CoordinateRecordItem;\n}(_react.Component);\nvar LinksPanel = /*#__PURE__*/function (_Component6) {\n  _inherits(LinksPanel, _Component6);\n  function LinksPanel(props) {\n    var _this11;\n    _classCallCheck(this, LinksPanel);\n    _this11 = _callSuper(this, LinksPanel, [props]);\n    _this11.state = {\n      expand: false\n    };\n    return _this11;\n  }\n  _createClass(LinksPanel, [{\n    key: \"render\",\n    value: function render() {\n      var ret = [];\n      var _this$props4 = this.props,\n        children = _this$props4.children,\n        model = _this$props4.model,\n        dispatch = _this$props4.dispatch;\n      if (!children || !children.length) {\n        return ret;\n      }\n      var hasLink = false;\n      var title = '';\n      for (var i = 0; i < children.length; i++) {\n        var child = children[i];\n        if (!hasLink && child.links && child.links.length) {\n          hasLink = true;\n          for (var j = 0; j < child.links.length; j++) {\n            var link = child.links[j];\n            if (link.groupName) {\n              title = link.groupName;\n              break;\n            }\n          }\n        }\n        ret.push( /*#__PURE__*/_react[\"default\"].createElement(LinkPanel, {\n          child: child,\n          model: model,\n          dispatch: dispatch\n        }));\n      }\n      if (!hasLink) {\n        return [];\n      }\n      return /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _ApprovalRecordNew[\"default\"]['links-panel']\n      }, /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _ApprovalRecordNew[\"default\"]['panel-title'],\n        onClick: this.switchExpandState.bind(this)\n      }, /*#__PURE__*/_react[\"default\"].createElement(\"span\", null, title || (0, _intlApi.getLangMsg)({\n        key: 'KDApprovalRecordNew.more'\n      })), /*#__PURE__*/_react[\"default\"].createElement(\"img\", {\n        src: _up[\"default\"]\n      })), /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        style: {\n          display: this.state.expand ? 'block' : 'none'\n        }\n      }, ret));\n    }\n  }, {\n    key: \"switchExpandState\",\n    value: function switchExpandState() {\n      this.setState({\n        expand: !this.state.expand\n      });\n    }\n  }]);\n  return LinksPanel;\n}(_react.Component);\nvar LinkPanel = /*#__PURE__*/function (_Component7) {\n  _inherits(LinkPanel, _Component7);\n  function LinkPanel() {\n    _classCallCheck(this, LinkPanel);\n    return _callSuper(this, LinkPanel, arguments);\n  }\n  _createClass(LinkPanel, [{\n    key: \"render\",\n    value: function render() {\n      var _this12 = this;\n      var child = this.props.child;\n      return /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _ApprovalRecordNew[\"default\"].panel\n      }, /*#__PURE__*/_react[\"default\"].createElement(\"img\", {\n        className: _ApprovalRecordNew[\"default\"].avatar,\n        src: child.avatar\n      }), /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _ApprovalRecordNew[\"default\"].text\n      }, child.assignee), /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: (0, _classnames[\"default\"])(_ApprovalRecord[\"default\"]['btn-panel'], _ApprovalRecordNew[\"default\"].links)\n      }, (0, _workflowUtil.createCustomizedLinks)(child, function (e, params) {\n        _this12.props.dispatch((0, _approvalRecordAction.clickCustomizeLink)(_this12.props.model, params));\n      })));\n    }\n  }]);\n  return LinkPanel;\n}(_react.Component);\nvar AttachmentItem = /*#__PURE__*/function (_Component8) {\n  _inherits(AttachmentItem, _Component8);\n  function AttachmentItem() {\n    var _this13;\n    _classCallCheck(this, AttachmentItem);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this13 = _callSuper(this, AttachmentItem, [].concat(args));\n    _this13.getFileSize = function (size) {\n      if (size > 1024 * 1024) {\n        return (Math.round(size * 100 / (1024 * 1024)) / 100).toString() + 'MB';\n      } else {\n        return (Math.round(size * 100 / 1024) / 100).toString() + 'KB';\n      }\n    };\n    return _this13;\n  }\n  _createClass(AttachmentItem, [{\n    key: \"render\",\n    value: function render() {\n      var fileSize = '(' + this.getFileSize(this.props.fileSize) + ')';\n      return /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _ApprovalRecordNew[\"default\"].attachment,\n        onClick: this.downloadAttachment.bind(this)\n      }, /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n        className: (0, _classnames[\"default\"])(_ApprovalRecordNew[\"default\"]['attach-icon'], 'kdfont kdfont-fujian')\n      }), /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n        className: _ApprovalRecordNew[\"default\"].filename,\n        title: this.props.fileName\n      }, this.props.fileName), /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n        className: _ApprovalRecordNew[\"default\"].filesize\n      }, fileSize));\n    }\n  }, {\n    key: \"downloadAttachment\",\n    value: function downloadAttachment() {\n      this.props.dispatch((0, _approvalRecordAction.showAttachmentInfo)(this.props.model, {\n        attachmentid: this.props.id,\n        downloadurl: this.props.downloadUrl,\n        attachmentids: this.props.attachmentIds\n      }));\n    }\n  }]);\n  return AttachmentItem;\n}(_react.Component);\n\n//# sourceURL=webpack://bos-platform/./src/workflow/components/ApprovalRecordComponents/KDApprovalRecordNew.js?");

/***/ }),

/***/ "./src/workflow/components/BillSummaryInfo.js":
/*!****************************************************!*\
  !*** ./src/workflow/components/BillSummaryInfo.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\n__webpack_require__(/*! core-js/modules/es.symbol.js */ \"../../node_modules/core-js/modules/es.symbol.js\");\n__webpack_require__(/*! core-js/modules/es.symbol.description.js */ \"../../node_modules/core-js/modules/es.symbol.description.js\");\n__webpack_require__(/*! core-js/modules/es.symbol.iterator.js */ \"../../node_modules/core-js/modules/es.symbol.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.symbol.to-primitive.js */ \"../../node_modules/core-js/modules/es.symbol.to-primitive.js\");\n__webpack_require__(/*! core-js/modules/es.array.iterator.js */ \"../../node_modules/core-js/modules/es.array.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.date.to-primitive.js */ \"../../node_modules/core-js/modules/es.date.to-primitive.js\");\n__webpack_require__(/*! core-js/modules/es.number.constructor.js */ \"../../node_modules/core-js/modules/es.number.constructor.js\");\n__webpack_require__(/*! core-js/modules/es.object.create.js */ \"../../node_modules/core-js/modules/es.object.create.js\");\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\n__webpack_require__(/*! core-js/modules/es.object.get-own-property-descriptor.js */ \"../../node_modules/core-js/modules/es.object.get-own-property-descriptor.js\");\n__webpack_require__(/*! core-js/modules/es.object.get-prototype-of.js */ \"../../node_modules/core-js/modules/es.object.get-prototype-of.js\");\n__webpack_require__(/*! core-js/modules/es.object.to-string.js */ \"../../node_modules/core-js/modules/es.object.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.reflect.construct.js */ \"../../node_modules/core-js/modules/es.reflect.construct.js\");\n__webpack_require__(/*! core-js/modules/es.string.iterator.js */ \"../../node_modules/core-js/modules/es.string.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.weak-map.js */ \"../../node_modules/core-js/modules/es.weak-map.js\");\n__webpack_require__(/*! core-js/modules/web.dom-collections.iterator.js */ \"../../node_modules/core-js/modules/web.dom-collections.iterator.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.function.bind.js */ \"../../node_modules/core-js/modules/es.function.bind.js\");\n__webpack_require__(/*! core-js/modules/es.object.set-prototype-of.js */ \"../../node_modules/core-js/modules/es.object.set-prototype-of.js\");\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"webpack/sharing/consume/default/react/react?dca2\"));\nvar _propTypes = _interopRequireDefault(__webpack_require__(/*! prop-types */ \"../../node_modules/prop-types/index.js\"));\nvar _BillSummaryInfo2 = _interopRequireDefault(__webpack_require__(/*! ../css/BillSummaryInfo.less */ \"./src/workflow/css/BillSummaryInfo.less\"));\nvar _reactTooltip = _interopRequireDefault(__webpack_require__(/*! react-tooltip */ \"../../node_modules/react-tooltip/dist/index.es.js\"));\nvar _immutable = __webpack_require__(/*! immutable */ \"webpack/sharing/consume/default/immutable/immutable?f2ca\");\nvar _tooltipaction = __webpack_require__(/*! ../../action/tooltipaction */ \"./src/action/tooltipaction.js\");\nvar _Tooltip = _interopRequireDefault(__webpack_require__(/*! ../../component/common/Tooltip */ \"./src/component/common/Tooltip.jsx\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction _getRequireWildcardCache(e) { if (\"function\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return { \"default\": e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\"default\" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n[\"default\"] = e, t && t.set(e, n), n; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nvar BillSummaryInfo = /*#__PURE__*/function (_Component) {\n  _inherits(BillSummaryInfo, _Component);\n  function BillSummaryInfo(props) {\n    var _this;\n    _classCallCheck(this, BillSummaryInfo);\n    _this = _callSuper(this, BillSummaryInfo, [props]);\n    _this.state = {\n      time: \"\"\n    };\n    return _this;\n  }\n  _createClass(BillSummaryInfo, [{\n    key: \"componentWillReceiveProps\",\n    value: function componentWillReceiveProps(nextProps) {\n      if (nextProps && nextProps.billSummaryInfo && nextProps.billSummaryInfo.time) {\n        this.setState({\n          time: nextProps.billSummaryInfo.time\n        });\n      }\n    }\n  }, {\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(nextProps, nextState) {\n      return !(0, _immutable.is)(this.state.time, nextState.time);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n      var tips = (0, _immutable.fromJS)({\n        'type': 'bill',\n        'place': 'left',\n        'link': false,\n        'billno': '***',\n        'showIcon': true,\n        'iconClassName': '***'\n      });\n      var display = this.props.config && this.props.config.formId == \"wf_viewflowchartmobile\" ? \"none\" : \"flex\";\n      return /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        ref: \"billSummaryInfo\",\n        className: _BillSummaryInfo2[\"default\"]['billSummaryInfo'],\n        style: {\n          display: display\n        }\n      }, /*#__PURE__*/_react[\"default\"].createElement(_Tooltip[\"default\"], {\n        ref: \"billSummaryInfotip\",\n        tips: tips,\n        showFormByTips: function showFormByTips(formId, targetCtrlKey) {\n          return dispatch((0, _tooltipaction.showFormByTips)(_this2.context.model.pageId, _this2.context.model.key, formId, targetCtrlKey, 'click'));\n        }\n      }));\n    }\n  }, {\n    key: \"componentWillUpdate\",\n    value: function componentWillUpdate(nextProps, nextState) {\n      if (nextState && nextState.time && nextProps.container && nextProps.billSummaryInfo) {\n        var params = {\n          height: nextProps.container.offsetHeight,\n          type: \"billSummary\",\n          procInstId: nextProps.billSummaryInfo.procInstId,\n          historicActivityInstanceId: nextProps.billSummaryInfo.historicActivityInstanceId\n        };\n        var paramStr = JSON.stringify(params);\n        this.context.dispatch((0, _tooltipaction.showFormByTips)(this.context.model.pageId, this.context.model.key, paramStr, this.refs.billSummaryInfotip.uuid, 'hover'));\n      }\n    }\n  }]);\n  return BillSummaryInfo;\n}(_react.Component);\nBillSummaryInfo.contextTypes = {\n  dispatch: _propTypes[\"default\"].func,\n  invokeAction: _propTypes[\"default\"].func,\n  model: _propTypes[\"default\"].object\n};\nvar _default = exports[\"default\"] = BillSummaryInfo;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/components/BillSummaryInfo.js?");

/***/ }),

/***/ "./src/workflow/components/Diagram.js":
/*!********************************************!*\
  !*** ./src/workflow/components/Diagram.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\n__webpack_require__(/*! core-js/modules/es.symbol.js */ \"../../node_modules/core-js/modules/es.symbol.js\");\n__webpack_require__(/*! core-js/modules/es.symbol.description.js */ \"../../node_modules/core-js/modules/es.symbol.description.js\");\n__webpack_require__(/*! core-js/modules/es.symbol.iterator.js */ \"../../node_modules/core-js/modules/es.symbol.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.symbol.to-primitive.js */ \"../../node_modules/core-js/modules/es.symbol.to-primitive.js\");\n__webpack_require__(/*! core-js/modules/es.array.iterator.js */ \"../../node_modules/core-js/modules/es.array.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.date.to-primitive.js */ \"../../node_modules/core-js/modules/es.date.to-primitive.js\");\n__webpack_require__(/*! core-js/modules/es.number.constructor.js */ \"../../node_modules/core-js/modules/es.number.constructor.js\");\n__webpack_require__(/*! core-js/modules/es.object.create.js */ \"../../node_modules/core-js/modules/es.object.create.js\");\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\n__webpack_require__(/*! core-js/modules/es.object.get-own-property-descriptor.js */ \"../../node_modules/core-js/modules/es.object.get-own-property-descriptor.js\");\n__webpack_require__(/*! core-js/modules/es.object.get-prototype-of.js */ \"../../node_modules/core-js/modules/es.object.get-prototype-of.js\");\n__webpack_require__(/*! core-js/modules/es.object.to-string.js */ \"../../node_modules/core-js/modules/es.object.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.reflect.construct.js */ \"../../node_modules/core-js/modules/es.reflect.construct.js\");\n__webpack_require__(/*! core-js/modules/es.string.iterator.js */ \"../../node_modules/core-js/modules/es.string.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.weak-map.js */ \"../../node_modules/core-js/modules/es.weak-map.js\");\n__webpack_require__(/*! core-js/modules/web.dom-collections.iterator.js */ \"../../node_modules/core-js/modules/web.dom-collections.iterator.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.concat.js */ \"../../node_modules/core-js/modules/es.array.concat.js\");\n__webpack_require__(/*! core-js/modules/es.function.bind.js */ \"../../node_modules/core-js/modules/es.function.bind.js\");\n__webpack_require__(/*! core-js/modules/es.object.keys.js */ \"../../node_modules/core-js/modules/es.object.keys.js\");\n__webpack_require__(/*! core-js/modules/es.object.set-prototype-of.js */ \"../../node_modules/core-js/modules/es.object.set-prototype-of.js\");\n__webpack_require__(/*! core-js/modules/es.regexp.exec.js */ \"../../node_modules/core-js/modules/es.regexp.exec.js\");\n__webpack_require__(/*! core-js/modules/es.string.replace.js */ \"../../node_modules/core-js/modules/es.string.replace.js\");\n__webpack_require__(/*! core-js/modules/web.timers.js */ \"../../node_modules/core-js/modules/web.timers.js\");\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"webpack/sharing/consume/default/react/react?dca2\"));\nvar _propTypes = _interopRequireDefault(__webpack_require__(/*! prop-types */ \"../../node_modules/prop-types/index.js\"));\nvar _Diagram2 = _interopRequireDefault(__webpack_require__(/*! ../css/Diagram.less */ \"./src/workflow/css/Diagram.less\"));\nvar _lodash = _interopRequireDefault(__webpack_require__(/*! lodash */ \"../../node_modules/lodash/lodash.js\"));\nvar _immutable = _interopRequireWildcard(__webpack_require__(/*! immutable */ \"webpack/sharing/consume/default/immutable/immutable?f2ca\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxGraphModel = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxGraphModel.js */ \"./src/workflow/mxClient/mxGraphModel.js\"));\nvar _mxCodec = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxCodec.js */ \"./src/workflow/mxClient/mxCodec.js\"));\nvar _mxPoint = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxPoint.js */ \"./src/workflow/mxClient/mxPoint.js\"));\nvar _mxEdgeStyle = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxEdgeStyle.js */ \"./src/workflow/mxClient/mxEdgeStyle.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxConstants */ \"./src/workflow/mxClient/mxConstants.js\"));\nvar _FloatToolbar = _interopRequireDefault(__webpack_require__(/*! ./FloatToolbar */ \"./src/workflow/components/FloatToolbar.js\"));\nvar _graphUtil = __webpack_require__(/*! ../util/graphUtil */ \"./src/workflow/util/graphUtil.js\");\nvar _mxGraphConstant = __webpack_require__(/*! ../constants/mxGraphConstant */ \"./src/workflow/constants/mxGraphConstant.js\");\nvar _workflowUtil = __webpack_require__(/*! ../util/workflowUtil */ \"./src/workflow/util/workflowUtil.js\");\nvar _mxMouseEvent = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxMouseEvent */ \"./src/workflow/mxClient/mxMouseEvent.js\"));\nvar _CardMouseListener = _interopRequireDefault(__webpack_require__(/*! ../mxGraph/CardMouseListener.js */ \"./src/workflow/mxGraph/CardMouseListener.js\"));\nvar _intlApi = __webpack_require__(/*! ../../i18n/intlApi */ \"./src/i18n/intlApi.js\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction _getRequireWildcardCache(e) { if (\"function\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return { \"default\": e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\"default\" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n[\"default\"] = e, t && t.set(e, n), n; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nvar Diagram = /*#__PURE__*/function (_Component) {\n  _inherits(Diagram, _Component);\n  function Diagram(props) {\n    var _this;\n    _classCallCheck(this, Diagram);\n    _this = _callSuper(this, Diagram, [props]);\n    //用于在刷新时比较两次xml是否相同，不同时才重新渲染画布\n    _this.graphXml = \"\";\n    _this.graphJson = \"\";\n    //用于在刷新后重新选中当前节点\n    _this.time = \"\";\n    //添加change事件监听\n    var graph = props.editorUi.editor.graph;\n    graph.addListener(_mxGraphConstant.EVENT.FOLD_CELLS, _this.foldCells.bind(_assertThisInitialized(_this)));\n    graph.addListener(_mxGraphConstant.EVENT.AFTER_FOLD_CELLS, _this.afterFoldCells.bind(_assertThisInitialized(_this)));\n    return _this;\n  }\n  _createClass(Diagram, [{\n    key: \"componentWillReceiveProps\",\n    value: function componentWillReceiveProps(nextProps) {\n      var _this2 = this;\n      var initialData = nextProps.initialData;\n      var ui = nextProps.editorUi;\n      var graph = ui.editor.graph;\n      if (initialData) {\n        graph.flowType = initialData.flowType;\n        if ((0, _workflowUtil.isBizFlow)(graph.flowType)) {\n          this.refs.container.style.backgroundColor = '#F9FBFF';\n        } else {\n          this.refs.container.style.backgroundColor = '#FFFFFF';\n        }\n      }\n      //TODO 增加其他属性的判断\n      if (initialData) {\n        var isXmlData = initialData.graph_xml && !_lodash[\"default\"].isEqual(initialData.graph_xml, this.graphXml);\n        var isJsonData = initialData.graph_json && !_lodash[\"default\"].isEqual(initialData.graph_json, this.graphJson);\n        if (isXmlData || isJsonData) {\n          var editor = this.props.editorUi.editor;\n          var animation = initialData.animation;\n          var formId = this.props.config.formId;\n          if (isJsonData && initialData.isBillRelationGraph) {\n            //json格式数据暂时只支持单据关系图\n            var json = initialData.graph_json;\n            this.initTreeLayoutGraph(graph, json, true);\n            this.graphJson = json;\n            this.graphXml = null;\n          } else {\n            if (formId == 'bpm_billrelation_graph') {\n              //单据关系图切换时需要还原样式\n              graph.resetStylesheet();\n            }\n            var xml = initialData.graph_xml;\n            var doc = _mxGraphUtils[\"default\"].parseXml(xml);\n            editor.setGraphXml(doc.documentElement, this.props.config.formId);\n            this.graphXml = xml;\n            this.graphJson = null;\n          }\n          editor.setModified(false);\n          editor.undoManager.clear();\n          this.props.refreshEditor();\n          if (isXmlData) {\n            if (initialData.selected_cellId) {\n              (0, _graphUtil.selectNode)(graph, initialData.selected_cellId);\n            } else {\n              //选中流程\n              (0, _graphUtil.selectProcess)(graph);\n            }\n            var cellId = initialData.autoSizeCellId;\n            if (cellId) {\n              //如果当前流程在子流程中，展开的子流程需要自适应\n              var subProcess = graph.getModel().getCell(cellId);\n              if (graph.isAutoSizeCell(subProcess)) {\n                graph.autoSizeCell(subProcess, false);\n              }\n            }\n          }\n          this.props.showLoading(false);\n          this.reloadGraph(graph);\n          if (animation) {\n            ui.actions.get('animation').funct(animation);\n          }\n        }\n      }\n      //子流程\n      var subProcData = nextProps.subProcData;\n      if (subProcData && !(0, _immutable.is)(this.props.subProcData, subProcData)) {\n        this.showSubProcess(graph, subProcData);\n      }\n      //查看流程图选中节点\n      if (initialData && initialData.time && !_lodash[\"default\"].isEqual(initialData.time, this.time)) {\n        /*if(initialData.currentCellId){\r\n        \tselectCell(graph, initialData.currentCellId);\r\n        }else{*/\n        this.props.resetApprovalRecords();\n        setTimeout(function () {\n          _this2.props.refreshEditor(true, false);\n        }, 0);\n        //}\n        this.time = initialData.time;\n      }\n    }\n  }, {\n    key: \"switchLayout\",\n    value: function switchLayout(graph, horizontal) {\n      this.props.showLoading(true);\n      this.initTreeLayoutGraph(graph, null, horizontal);\n      this.props.showLoading(false);\n    }\n  }, {\n    key: \"initTreeLayoutGraph\",\n    value: function initTreeLayoutGraph(graph, data, horizontal) {\n      var model = graph.getModel();\n      var style = graph.getStylesheet().getDefaultEdgeStyle();\n      style[_mxConstants[\"default\"].STYLE_ROUNDED] = true;\n      style[_mxConstants[\"default\"].STYLE_STROKEWIDTH] = 2;\n      style[_mxConstants[\"default\"].STYLE_STROKECOLOR] = \"#a1cfff\";\n      style[_mxConstants[\"default\"].STYLE_EXIT_X] = horizontal ? 1.0 : 0.5;\n      style[_mxConstants[\"default\"].STYLE_EXIT_Y] = horizontal ? 0.5 : 1.0;\n      style[_mxConstants[\"default\"].STYLE_EXIT_PERIMETER] = 0;\n      style[_mxConstants[\"default\"].STYLE_ENTRY_X] = horizontal ? 0 : 0.5;\n      style[_mxConstants[\"default\"].STYLE_ENTRY_Y] = horizontal ? 0.5 : 0;\n      style[_mxConstants[\"default\"].STYLE_ENTRY_PERIMETER] = 0;\n      style[_mxConstants[\"default\"].STYLE_EDGE] = _mxEdgeStyle[\"default\"].OrthConnector;\n      style.strokeColor_important = \"#a1cfff\";\n      graph.horizontalLayout = horizontal;\n      try {\n        graph.initializing = true;\n        var editor = this.props.editorUi.editor;\n        editor.resetGraph();\n        model.clear();\n\n        //需要创建图标的线\n        var edgeDataMap = {};\n        //虚节点\n        var virtualCells = [];\n        //源和目标节点都存在，直接连线\n        var directConnectData = {};\n        model.beginUpdate();\n        try {\n          data = data || this.props.initialData.graph_json;\n          var ret = JSON.parse(data);\n          var rootInfo = ret.root;\n          if (rootInfo) {\n            var rootCell = this.insertGraphCell(graph, rootInfo, virtualCells, edgeDataMap, directConnectData);\n            if (rootInfo.virtual) {\n              virtualCells.push(rootCell);\n            }\n          }\n        } finally {\n          model.endUpdate();\n        }\n        if (virtualCells.length) {\n          model.beginUpdate();\n          try {\n            //移除虚节点\n            graph.removeCells(virtualCells);\n          } finally {\n            model.endUpdate();\n          }\n        }\n        model.beginUpdate();\n        try {\n          //处理特殊位置的线\n          var parent = graph.getDefaultParent();\n          for (var srcId in directConnectData) {\n            var source = model.getCell(srcId);\n            var _data = directConnectData[srcId];\n            var info = _data.info;\n            var datas = info.datas || {};\n            var targets = _data.targets;\n            for (var i in targets) {\n              var target = targets[i];\n              var _style = this.getEdgeOptimalStyle(horizontal, source, target);\n              var edge = graph.insertEdge(parent, null, '', source, target, _style);\n              parent.insert(edge, 0);\n              if (_style != null) {\n                continue;\n              }\n              //标准位置的线创建线上图标\n              var edgeData = {\n                status: info.status,\n                plugin: info.stausPlugin,\n                entityNumber: datas.entityNumber,\n                businessKey: datas.businessKey\n              };\n              edgeDataMap[edge.id] = edgeData;\n            }\n          }\n        } finally {\n          model.endUpdate();\n        }\n        model.beginUpdate();\n        try {\n          //创建线上图标\n          for (var edgeId in edgeDataMap) {\n            var _edge = model.getCell(edgeId);\n            if (!_edge) {\n              continue;\n            }\n            var _edgeData = edgeDataMap[edgeId];\n            this.insertEdgeIcon(horizontal, graph, _edge, _edgeData);\n          }\n        } finally {\n          model.endUpdate();\n        }\n        var container = graph.container;\n        var bounds = graph.getGraphBounds();\n        container.scrollLeft = bounds.x + bounds.width / 2 - container.clientWidth / 2;\n        container.scrollTop = bounds.y + bounds.height / 2 - container.clientHeight / 2;\n      } finally {\n        graph.initializing = false;\n      }\n    }\n  }, {\n    key: \"getEdgeOptimalStyle\",\n    value: function getEdgeOptimalStyle(horizontal, source, target) {\n      var srcGeometry = source.geometry;\n      var tgtGeometry = target.geometry;\n      var x1 = srcGeometry.x;\n      var y1 = srcGeometry.y;\n      var x2 = tgtGeometry.x;\n      var y2 = tgtGeometry.y;\n      var width = srcGeometry.width;\n      var height = srcGeometry.height;\n      //节点距离\n      var distance = 80;\n      if (horizontal) {\n        //横向\n        if (x2 > x1 && x2 - (x1 + width) <= distance) {\n          //标准位置，不用设置样式\n          return null;\n        } else {\n          if (y2 == y1) {\n            //同一水平位置，从下出，从下进\n            return \"exitX=0.5;exitY=1;entryX=0.5;entryY=1;\";\n          } else if (y2 > y1) {\n            //目标节点在下方，从下出，从上进\n            return \"exitX=0.5;exitY=1;entryX=0.5;entryY=0;\";\n          } else {\n            //目标节点在上方，从上出，从下进\n            return \"exitX=0.5;exitY=0;entryX=0.5;entryY=1;\";\n          }\n        }\n      } else {\n        //竖向\n        if (y2 > y1 && y2 - (y1 + height) <= distance) {\n          //标准位置，不用设置样式\n          return null;\n        } else {\n          if (x2 == x1) {\n            //同一竖直位置，从右出，从右进\n            return \"exitX=1;exitY=0.5;entryX=1;entryY=0.5;\";\n          } else if (x2 > x1) {\n            //目标节点在右侧，从右出，从左进\n            return \"exitX=1;exitY=0.5;entryX=0;entryY=0.5;\";\n          } else {\n            //目标节点在左侧，从左出，从右进\n            return \"exitX=0;exitY=0.5;entryX=1;entryY=0.5;\";\n          }\n        }\n      }\n    }\n  }, {\n    key: \"insertEdgeIcon\",\n    value: function insertEdgeIcon(horizontal, graph, edge, edgeData) {\n      var iconWidth = 24;\n      var iconHeight = 24;\n      var source = edge.source;\n      var target = edge.target;\n      var x = -12;\n      var y = -12;\n      if (source && target) {\n        var srcGeometry = source.geometry;\n        var tgtGeometry = target.geometry;\n        if (horizontal) {\n          var x1 = srcGeometry.x + srcGeometry.width;\n          var y1 = srcGeometry.y + srcGeometry.height / 2;\n          var x2 = tgtGeometry.x;\n          var y2 = tgtGeometry.y + tgtGeometry.height / 2;\n          x = (x1 - x2) / 4 - iconWidth / 2;\n          y = (y1 - y2) / 2 - iconHeight / 2;\n        } else {\n          var _x = srcGeometry.x + srcGeometry.width / 2;\n          var _y = srcGeometry.y + srcGeometry.height;\n          var _x2 = tgtGeometry.x + tgtGeometry.width / 2;\n          var _y2 = tgtGeometry.y;\n          x = (_x - _x2) / 2 - iconWidth / 2;\n          y = (_y - _y2) / 4 - iconHeight / 2;\n        }\n      }\n      var status = edgeData.status;\n      var iconType = '';\n      var iconTip = '';\n      if (status == 'underway') {\n        iconType = 'IconUnderway';\n        iconTip = (0, _intlApi.getLangMsg)({\n          key: \"WFDiagram.edgeIconUnderwayTip\"\n        });\n      } else {\n        iconType = 'IconComplete';\n        iconTip = (0, _intlApi.getLangMsg)({\n          key: \"WFDiagram.edgeIconCompleteTip\"\n        });\n      }\n      var icon = graph.insertVertex(edge, \"\".concat(edge.id, \"_child\"), null, 0, 0, iconWidth, iconHeight, \"shape=ierp.billrelation.\".concat(iconType, \";\"), true);\n      icon.geometry.offset = new _mxPoint[\"default\"](x, y);\n      icon.properties.plugin = edgeData.plugin;\n      icon.properties.entityNumber = edgeData.entityNumber;\n      icon.properties.businessKey = edgeData.businessKey;\n      icon.properties.title = iconTip;\n    }\n  }, {\n    key: \"insertGraphCell\",\n    value: function insertGraphCell(graph, info, virtualCells, edgeDataMap, directConnectData) {\n      var parent = graph.getDefaultParent();\n      var vertex = graph.insertVertex(parent, info.cellId, info.text, null, null, 216, 132, \"shape=\".concat(info.type, \";whiteSpace=wrap;spacingLeft=50;spacingRight=10;overflow=hidden;resizable=0;\"));\n      vertex.type = info.type;\n      vertex.properties = _lodash[\"default\"].assign({}, vertex.properties, info.datas);\n      if (info.current) {\n        var currentIcon = graph.insertVertex(vertex, \"\".concat(info.cellId, \"_child\"), null, 0, 0, 32, 32, 'shape=ierp.billrelation.Location', true);\n        currentIcon.geometry.offset = new _mxPoint[\"default\"](-16, -16);\n      }\n      var targets = info.targets;\n      var model = graph.getModel();\n      var len = targets && targets.length;\n      var lastEdgeId = null;\n      for (var j in targets) {\n        var target = targets[j];\n        var next = model.getCell(target.cellId);\n        if (!next) {\n          //创建节点\n          next = this.insertGraphCell(graph, target, virtualCells, edgeDataMap, directConnectData);\n          if (target.virtual) {\n            virtualCells.push(next);\n          }\n        } else {\n          //记录需要直接连线的信息\n          var data = directConnectData[vertex.id];\n          if (!data) {\n            data = {\n              info: info,\n              targets: []\n            };\n            directConnectData[vertex.id] = data;\n          }\n          data.targets.push(next);\n          continue;\n        }\n        var edge = graph.insertEdge(parent, null, '', vertex, next);\n        edge.geometry.x = 1;\n        edge.geometry.y = 0;\n        lastEdgeId = \"\".concat(edge.id);\n      }\n      if (lastEdgeId) {\n        //图标加到最后一条线上\n        var datas = info.datas || {};\n        edgeDataMap[lastEdgeId] = {\n          status: info.status,\n          plugin: info.stausPlugin,\n          entityNumber: datas.entityNumber,\n          businessKey: datas.businessKey\n        };\n      }\n      return vertex;\n    }\n  }, {\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(nextProps, nextState) {\n      //渲染一次即可\n      if (this.props.initialData && nextProps.initialData) {\n        return this.props.initialData.isBillRelationGraph != nextProps.initialData.isBillRelationGraph;\n      }\n      return false;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this3 = this;\n      var shrinkDivStyle = {\n        position: 'absolute',\n        top: '30px',\n        right: '30px',\n        zIndex: 1,\n        cursor: 'pointer',\n        display: 'none',\n        transform: 'rotate(-180deg)'\n      };\n      var style = {\n        flexGrow: '1'\n      };\n      if (!this.props.editable) {\n        style.position = 'relative';\n      }\n      var graph = this.props.editorUi.editor.graph;\n      var isBillRelationGraph = this.props.initialData && this.props.initialData.isBillRelationGraph;\n      return /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        style: style\n      }, /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        ref: \"container\",\n        id: \"diagram\",\n        className: _Diagram2[\"default\"][\"geDiagramContainer\"],\n        style: {\n          position: 'absolute'\n        }\n      }), /*#__PURE__*/_react[\"default\"].createElement(_FloatToolbar[\"default\"], {\n        graph: graph,\n        isBillRelationGraph: isBillRelationGraph,\n        actions: this.props.editorUi.actions,\n        config: this.props.config,\n        showLoading: this.props.showLoading,\n        clicked: function clicked() {\n          _this3.floatToolBarClicked();\n        },\n        switchLayout: function switchLayout(horizontal) {\n          _this3.switchLayout(graph, horizontal);\n        }\n      }), /*#__PURE__*/_react[\"default\"].createElement(\"img\", {\n        ref: \"shrink\",\n        onClick: this.shrink.bind(this),\n        style: shrinkDivStyle,\n        src: _mxGraphConstant.ICON_RETRACT\n      }));\n    }\n  }, {\n    key: \"shrink\",\n    value: function shrink() {\n      var model = this.context.model;\n      var config = model.getFormConfig();\n      var cell = this.props.editorUi.editor.graph.getSelectionCell();\n      //由于展开/收缩右侧属性面板时，画布要refresh，所以rightpanel的显示隐藏放到前端，否则refresh时计算的值不对\n      this.toggleConfigurePanel(model.pageId, false);\n      this.context.invokeAction(model, 'handleEvent', [config.formId, 'expandedConfigurePanel', {\n        type: cell.getType(),\n        itemId: cell.getId()\n      }]);\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this4 = this;\n      var model = this.context.model;\n      model.sub_Event('shrinkConfigurePanel', function () {\n        var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n        _this4.toggleConfigurePanel(model.pageId, true);\n      });\n      var graph = this.props.editorUi.editor.graph;\n      if (this.props.editable === false) {\n        this.addMouseListener(graph, model);\n      }\n    }\n  }, {\n    key: \"addMouseListener\",\n    value: function addMouseListener(graph, model) {\n      if (this.props.config.formId != \"bpm_billrelation_graph\") {\n        return;\n      }\n      //单据关系图Listener\n      this.cardListener = new _CardMouseListener[\"default\"](graph, function (event, callback) {\n        model.sub_Event(event, callback);\n      });\n      //单据上下游关系图鼠标事件\n      graph.addMouseListener(this.cardListener);\n    }\n  }, {\n    key: \"toggleConfigurePanel\",\n    value: function toggleConfigurePanel(pageId, shrink) {\n      var _this5 = this;\n      var shrinkDiv = this.refs.shrink;\n      shrinkDiv.style.display = shrink ? 'block' : 'none';\n      var rightpanel = document.querySelector(\"div[id=\\\"\".concat(pageId, \"\\\"] div#\").concat(_mxGraphConstant.CONFIG_PANEL_ID));\n      rightpanel && (rightpanel.style.display = shrink ? 'none' : 'flex');\n      setTimeout(function () {\n        _this5.props.refreshEditor();\n      }, 0);\n    }\n  }, {\n    key: \"foldCells\",\n    value: function foldCells(graph, evt) {\n      var cells = evt.properties.cells;\n      if (cells.length) {\n        var cell = cells[0];\n        if (cell.isContainable() === true && cell.isCollapsed() === false) {\n          var subProcData = this.props.subProcData,\n            subProcId = cell.getProperty(\"subProcessId\"),\n            subProcChanged = subProcData && subProcData.get(_mxGraphConstant.CURRENT_SUBPROCESS_ID) !== subProcId;\n          //从未展开过或子流程ID发生变化时需要重新加载\n          if (!cell.children || !cell.children.length || subProcChanged) {\n            if (subProcChanged) {\n              var graphModel = graph.model;\n              try {\n                graphModel.beginUpdate();\n                cell.children = [];\n              } finally {\n                graphModel.endUpdate();\n              }\n            }\n            //事件子流程\n            this.loadSubProcess(subProcId, cell.getId());\n          }\n        }\n      }\n    }\n  }, {\n    key: \"afterFoldCells\",\n    value: function afterFoldCells(graph, evt) {\n      var activatedCell = this.props.activatedCell;\n      if (activatedCell) {\n        var drawPane = graph.container.querySelector('svg #drawPane');\n        var cellPane = drawPane.querySelector(\"#\".concat(graph.getModel().getCell(activatedCell.get('id')).mxObjectId));\n        //子流程展开收缩会重新渲染，如果是当前激活的节点，需要重新添加选中的class\n        if (cellPane && !cellPane.classList.contains(_Diagram2[\"default\"].activatedCell)) {\n          cellPane.classList.add(_Diagram2[\"default\"].activatedCell);\n        }\n        var cells = evt.properties.cells;\n        var cell = null;\n        if (cells && cells.length && graph.isAutoSizeCell(cell = cells[0]) && cell.isCollapsed() === false && cell.autoSizeWhenFirst) {\n          //查看流程图中已流转的子流程第一次展开\n          delete cell.autoSizeWhenFirst;\n          graph.autoSizeCell(cell, false);\n        }\n      }\n    }\n  }, {\n    key: \"showSubProcess\",\n    value: function showSubProcess(graph, subProcData) {\n      var graphModel = graph.model;\n      var datas = subProcData.toJS();\n      var key = datas[_mxGraphConstant.CURRENT_SUBPROCESS_KEY];\n      var data = datas[key];\n      if (!data) {\n        return;\n      }\n      //TODO: node_1是否后续会调整\n      data = data.replace(/\"node_1\"/g, \"\\\"\".concat(key, \"\\\"\"));\n      var doc = _mxGraphUtils[\"default\"].parseXml(data);\n      var node = doc.documentElement;\n      var dec = new _mxCodec[\"default\"](node.ownerDocument);\n      var model = new _mxGraphModel[\"default\"]();\n      dec.decode(node, model);\n      var root = model.getBPMNRoot();\n      var children = root.children;\n      if (children && children.length) {\n        var subProcess = graphModel.getCell(key);\n        var subProcGeo = subProcess.geometry;\n        try {\n          graphModel.beginUpdate();\n          var len = children.length;\n          var child = null;\n          var maxCellGeo = null;\n          var geo = null;\n          var shiftingY = null;\n          //找到最宽的cell用于计算每个cell的x偏移\n          for (var i = 0; i < len; i++) {\n            child = children[i];\n            geo = child.geometry;\n            //TODO：启动节点type发生变化时的处理\n            if (child.type === 'StartSignalEvent') {\n              shiftingY = _mxConstants[\"default\"].DEFAULT_STARTSIZE - geo.y;\n            }\n            if (maxCellGeo == null || maxCellGeo.width < geo.width) {\n              maxCellGeo = geo;\n            }\n          }\n          //调整子流程的偏移位置\n          var shiftingX = _mxConstants[\"default\"].DEFAULT_SWIMLANE_PADDING - maxCellGeo.x;\n          while (len--) {\n            child = children[0];\n            geo = child.geometry;\n            child.geometry.translate(shiftingX, shiftingY);\n            graphModel.add(subProcess, child);\n          }\n        } finally {\n          graphModel.endUpdate();\n        }\n        //自动调整子流程的大小\n        if (graph.isAutoSizeCell(subProcess)) {\n          graph.autoSizeCell(subProcess, false);\n        }\n      }\n    }\n  }, {\n    key: \"loadSubProcess\",\n    value: function loadSubProcess(subProcessId, id) {\n      if (!subProcessId) {\n        return;\n      }\n      var model = this.context.model;\n      var config = model.getFormConfig();\n      var params = {\n        subProcessId: subProcessId,\n        id: id,\n        formId: config.formId\n      };\n      params[_mxGraphConstant.INITCLASS] = 'kd.bos.workflow.design.subprocess.WorkflowSubProcessInit';\n      this.context.invokeAction(model, 'loadSubProcessData', ['', params]);\n    }\n  }, {\n    key: \"reloadGraph\",\n    value: function reloadGraph(graph) {\n      if (this.cardListener) {\n        this.cardListener.reset(graph);\n      }\n    }\n  }, {\n    key: \"floatToolBarClicked\",\n    value: function floatToolBarClicked() {\n      if (this.cardListener) {\n        var graph = this.props.editorUi.editor.graph;\n        var evt = new _mxMouseEvent[\"default\"]();\n        this.cardListener.mouseDown(graph, evt);\n      }\n    }\n  }]);\n  return Diagram;\n}(_react.Component);\nDiagram.contextTypes = {\n  invokeAction: _propTypes[\"default\"].func,\n  model: _propTypes[\"default\"].object\n};\nvar _default = exports[\"default\"] = Diagram;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/components/Diagram.js?");

/***/ }),

/***/ "./src/workflow/components/EditorUi.js":
/*!*********************************************!*\
  !*** ./src/workflow/components/EditorUi.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\n__webpack_require__(/*! core-js/modules/es.symbol.js */ \"../../node_modules/core-js/modules/es.symbol.js\");\n__webpack_require__(/*! core-js/modules/es.symbol.description.js */ \"../../node_modules/core-js/modules/es.symbol.description.js\");\n__webpack_require__(/*! core-js/modules/es.symbol.iterator.js */ \"../../node_modules/core-js/modules/es.symbol.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.symbol.to-primitive.js */ \"../../node_modules/core-js/modules/es.symbol.to-primitive.js\");\n__webpack_require__(/*! core-js/modules/es.array.filter.js */ \"../../node_modules/core-js/modules/es.array.filter.js\");\n__webpack_require__(/*! core-js/modules/es.date.to-primitive.js */ \"../../node_modules/core-js/modules/es.date.to-primitive.js\");\n__webpack_require__(/*! core-js/modules/es.number.constructor.js */ \"../../node_modules/core-js/modules/es.number.constructor.js\");\n__webpack_require__(/*! core-js/modules/es.object.create.js */ \"../../node_modules/core-js/modules/es.object.create.js\");\n__webpack_require__(/*! core-js/modules/es.object.define-properties.js */ \"../../node_modules/core-js/modules/es.object.define-properties.js\");\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\n__webpack_require__(/*! core-js/modules/es.object.get-own-property-descriptor.js */ \"../../node_modules/core-js/modules/es.object.get-own-property-descriptor.js\");\n__webpack_require__(/*! core-js/modules/es.object.get-own-property-descriptors.js */ \"../../node_modules/core-js/modules/es.object.get-own-property-descriptors.js\");\n__webpack_require__(/*! core-js/modules/es.object.get-prototype-of.js */ \"../../node_modules/core-js/modules/es.object.get-prototype-of.js\");\n__webpack_require__(/*! core-js/modules/es.reflect.construct.js */ \"../../node_modules/core-js/modules/es.reflect.construct.js\");\n__webpack_require__(/*! core-js/modules/es.weak-map.js */ \"../../node_modules/core-js/modules/es.weak-map.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.concat.js */ \"../../node_modules/core-js/modules/es.array.concat.js\");\n__webpack_require__(/*! core-js/modules/es.array.for-each.js */ \"../../node_modules/core-js/modules/es.array.for-each.js\");\n__webpack_require__(/*! core-js/modules/es.array.index-of.js */ \"../../node_modules/core-js/modules/es.array.index-of.js\");\n__webpack_require__(/*! core-js/modules/es.array.iterator.js */ \"../../node_modules/core-js/modules/es.array.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.array.last-index-of.js */ \"../../node_modules/core-js/modules/es.array.last-index-of.js\");\n__webpack_require__(/*! core-js/modules/es.array.slice.js */ \"../../node_modules/core-js/modules/es.array.slice.js\");\n__webpack_require__(/*! core-js/modules/es.array.splice.js */ \"../../node_modules/core-js/modules/es.array.splice.js\");\n__webpack_require__(/*! core-js/modules/es.function.bind.js */ \"../../node_modules/core-js/modules/es.function.bind.js\");\n__webpack_require__(/*! core-js/modules/es.object.assign.js */ \"../../node_modules/core-js/modules/es.object.assign.js\");\n__webpack_require__(/*! core-js/modules/es.object.keys.js */ \"../../node_modules/core-js/modules/es.object.keys.js\");\n__webpack_require__(/*! core-js/modules/es.object.set-prototype-of.js */ \"../../node_modules/core-js/modules/es.object.set-prototype-of.js\");\n__webpack_require__(/*! core-js/modules/es.object.to-string.js */ \"../../node_modules/core-js/modules/es.object.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.parse-float.js */ \"../../node_modules/core-js/modules/es.parse-float.js\");\n__webpack_require__(/*! core-js/modules/es.parse-int.js */ \"../../node_modules/core-js/modules/es.parse-int.js\");\n__webpack_require__(/*! core-js/modules/es.regexp.constructor.js */ \"../../node_modules/core-js/modules/es.regexp.constructor.js\");\n__webpack_require__(/*! core-js/modules/es.regexp.exec.js */ \"../../node_modules/core-js/modules/es.regexp.exec.js\");\n__webpack_require__(/*! core-js/modules/es.regexp.to-string.js */ \"../../node_modules/core-js/modules/es.regexp.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.string.iterator.js */ \"../../node_modules/core-js/modules/es.string.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.string.replace.js */ \"../../node_modules/core-js/modules/es.string.replace.js\");\n__webpack_require__(/*! core-js/modules/es.string.trim.js */ \"../../node_modules/core-js/modules/es.string.trim.js\");\n__webpack_require__(/*! core-js/modules/web.dom-collections.for-each.js */ \"../../node_modules/core-js/modules/web.dom-collections.for-each.js\");\n__webpack_require__(/*! core-js/modules/web.dom-collections.iterator.js */ \"../../node_modules/core-js/modules/web.dom-collections.iterator.js\");\n__webpack_require__(/*! core-js/modules/web.timers.js */ \"../../node_modules/core-js/modules/web.timers.js\");\n__webpack_require__(/*! core-js/modules/web.url.js */ \"../../node_modules/core-js/modules/web.url.js\");\n__webpack_require__(/*! core-js/modules/web.url-search-params.js */ \"../../node_modules/core-js/modules/web.url-search-params.js\");\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"webpack/sharing/consume/default/react/react?dca2\"));\nvar _propTypes = _interopRequireDefault(__webpack_require__(/*! prop-types */ \"../../node_modules/prop-types/index.js\"));\nvar _GraphComponent2 = _interopRequireDefault(__webpack_require__(/*! ./GraphComponent */ \"./src/workflow/components/GraphComponent.js\"));\nvar _mxGraphConstant = __webpack_require__(/*! ../constants/mxGraphConstant */ \"./src/workflow/constants/mxGraphConstant.js\");\nvar _Diagram = _interopRequireDefault(__webpack_require__(/*! ./Diagram */ \"./src/workflow/components/Diagram.js\"));\nvar _LoadingGIF = _interopRequireDefault(__webpack_require__(/*! ../../component/common/LoadingGIF */ \"./src/component/common/LoadingGIF.js\"));\nvar _Bill = _interopRequireDefault(__webpack_require__(/*! ../../component/web/Bill.less */ \"./src/component/web/Bill.less\"));\nvar _action = __webpack_require__(/*! ../../action/action */ \"./src/action/action.js\");\nvar _server = __webpack_require__(/*! @/action/actionname/global/system/server */ \"./src/action/actionname/global/system/server/index.js\");\nvar _intlApi = __webpack_require__(/*! ../../i18n/intlApi */ \"./src/i18n/intlApi.js\");\nvar actionCreators = _interopRequireWildcard(__webpack_require__(/*! ../actions */ \"./src/workflow/actions/index.js\"));\nvar _constants = __webpack_require__(/*! ../constants */ \"./src/workflow/constants/index.js\");\nvar _reactRedux = __webpack_require__(/*! react-redux */ \"../../node_modules/react-redux/es/index.js\");\nvar _notifyMsg = _interopRequireDefault(__webpack_require__(/*! ../../designer/utils/notifyMsg */ \"./src/designer/utils/notifyMsg.js\"));\nvar _immutable = __webpack_require__(/*! immutable */ \"webpack/sharing/consume/default/immutable/immutable?f2ca\");\nvar _lodash = _interopRequireDefault(__webpack_require__(/*! lodash */ \"../../node_modules/lodash/lodash.js\"));\nvar _ApprovalHistoryRecord = _interopRequireDefault(__webpack_require__(/*! ./ApprovalHistoryRecord */ \"./src/workflow/components/ApprovalHistoryRecord.js\"));\nvar _KDYzjChat = _interopRequireDefault(__webpack_require__(/*! ./KDYzjChat */ \"./src/workflow/components/KDYzjChat.js\"));\nvar _Editor = _interopRequireDefault(__webpack_require__(/*! ../mxGraph/Editor.js */ \"./src/workflow/mxGraph/Editor.js\"));\nvar _mxKeyHandler = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxKeyHandler.js */ \"./src/workflow/mxClient/mxKeyHandler.js\"));\nvar _mxGraphHandler = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxGraphHandler.js */ \"./src/workflow/mxClient/mxGraphHandler.js\"));\nvar _mxConnectionHandler = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxConnectionHandler.js */ \"./src/workflow/mxClient/mxConnectionHandler.js\"));\nvar _mxPopupMenu = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxPopupMenu.js */ \"./src/workflow/mxClient/mxPopupMenu.js\"));\nvar _OpenDialog = _interopRequireDefault(__webpack_require__(/*! ../mxGraph/OpenDialog.js */ \"./src/workflow/mxGraph/OpenDialog.js\"));\nvar _mxClient = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxClient.js */ \"./src/workflow/mxClient/mxClient.js\"));\nvar _LinkDialog = _interopRequireDefault(__webpack_require__(/*! ../mxGraph/LinkDialog.js */ \"./src/workflow/mxGraph/LinkDialog.js\"));\nvar _mxOutline = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxOutline.js */ \"./src/workflow/mxClient/mxOutline.js\"));\nvar _mxMorphing = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxMorphing.js */ \"./src/workflow/mxClient/mxMorphing.js\"));\nvar _OpenFile = _interopRequireDefault(__webpack_require__(/*! ../mxGraph/OpenFile.js */ \"./src/workflow/mxGraph/OpenFile.js\"));\nvar _mxEventSource = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxEventSource.js */ \"./src/workflow/mxClient/mxEventSource.js\"));\nvar _Actions = _interopRequireDefault(__webpack_require__(/*! ../mxGraph/Actions.js */ \"./src/workflow/mxGraph/Actions.js\"));\nvar _Menus = _interopRequireDefault(__webpack_require__(/*! ../mxGraph/Menus.js */ \"./src/workflow/mxGraph/Menus.js\"));\nvar _mxEventObject = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxEventObject.js */ \"./src/workflow/mxClient/mxEventObject.js\"));\nvar _mxImage = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxImage.js */ \"./src/workflow/mxClient/mxImage.js\"));\nvar _mxEvent = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxEvent.js */ \"./src/workflow/mxClient/mxEvent.js\"));\nvar _mxClipboard = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxClipboard.js */ \"./src/workflow/mxClient/mxClipboard.js\"));\nvar _ColorDialog = _interopRequireDefault(__webpack_require__(/*! ../mxGraph/ColorDialog.js */ \"./src/workflow/mxGraph/ColorDialog.js\"));\nvar _mxCellRenderer = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxCellRenderer.js */ \"./src/workflow/mxClient/mxCellRenderer.js\"));\nvar _mxRectangle = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxRectangle.js */ \"./src/workflow/mxClient/mxRectangle.js\"));\nvar _Dialog = _interopRequireDefault(__webpack_require__(/*! ../mxGraph/Dialog.js */ \"./src/workflow/mxGraph/Dialog.js\"));\nvar _FilenameDialog = _interopRequireDefault(__webpack_require__(/*! ../mxGraph/FilenameDialog.js */ \"./src/workflow/mxGraph/FilenameDialog.js\"));\nvar _HoverIcons = _interopRequireDefault(__webpack_require__(/*! ../mxGraph/HoverIcons.js */ \"./src/workflow/mxGraph/HoverIcons.js\"));\nvar _mxPoint = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxPoint.js */ \"./src/workflow/mxClient/mxPoint.js\"));\nvar _mxResources = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxResources.js */ \"./src/workflow/mxClient/mxResources.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nvar _mxGraph = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxGraph */ \"./src/workflow/mxClient/mxGraph.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxUtils = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxUtils.js */ \"./src/workflow/mxClient/mxUtils.js\"));\nvar _mxCell = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxCell.js */ \"./src/workflow/mxClient/mxCell.js\"));\nvar _mxGeometry = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxGeometry.js */ \"./src/workflow/mxClient/mxGeometry.js\"));\nvar _mxStencilRegistry = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxStencilRegistry.js */ \"./src/workflow/mxClient/mxStencilRegistry.js\"));\nvar _mxCompactTreeLayout = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxCompactTreeLayout.js */ \"./src/workflow/mxClient/mxCompactTreeLayout.js\"));\nvar _mxLayoutManager = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxLayoutManager.js */ \"./src/workflow/mxClient/mxLayoutManager.js\"));\nvar _Diagram2 = _interopRequireDefault(__webpack_require__(/*! ../css/Diagram.less */ \"./src/workflow/css/Diagram.less\"));\nvar _graphUtil = __webpack_require__(/*! ../util/graphUtil */ \"./src/workflow/util/graphUtil.js\");\nvar _FloatLayer = _interopRequireDefault(__webpack_require__(/*! ./FloatLayer */ \"./src/workflow/components/FloatLayer.js\"));\nvar _BillSummaryInfo = _interopRequireDefault(__webpack_require__(/*! ./BillSummaryInfo */ \"./src/workflow/components/BillSummaryInfo.js\"));\nvar _tooltipaction = __webpack_require__(/*! ../../action/tooltipaction */ \"./src/action/tooltipaction.js\");\nvar _Tooltip = _interopRequireDefault(__webpack_require__(/*! ../../component/common/Tooltip */ \"./src/component/common/Tooltip.jsx\"));\nvar _workflowUtil = __webpack_require__(/*! ../util/workflowUtil */ \"./src/workflow/util/workflowUtil.js\");\nvar _GlobalDataCacher = __webpack_require__(/*! @/model/GlobalDataCacher */ \"./src/model/GlobalDataCacher.js\");\nvar _symbolConst = __webpack_require__(/*! @/constant/symbolConst */ \"./src/constant/symbolConst.js\");\nfunction _getRequireWildcardCache(e) { if (\"function\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return { \"default\": e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\"default\" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n[\"default\"] = e, t && t.set(e, n), n; }\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); } /**\n * Copyright (c) 2006-2012, JGraph Ltd\n */ /**\n * Constructs a new graph editor\n */ //import Sidebar from './Sidebar';\n//import Format from './Format';\n//import Hsplit from './Hsplit';\n//import Loading from './Loading';\nvar EditorUi = /*#__PURE__*/function (_GraphComponent) {\n  _inherits(EditorUi, _GraphComponent);\n  function EditorUi(props) {\n    var _this;\n    _classCallCheck(this, EditorUi);\n    _this = _callSuper(this, EditorUi, [props]);\n    _this.state = {\n      initialData: {}\n    };\n    _mxEventSource[\"default\"].call(_assertThisInitialized(_this));\n    _this.destroyFunctions = [];\n    _mxGraph[\"default\"].prototype.gridEnabled = false;\n    _this.editor = new _Editor[\"default\"](null, null, null, null, _this.props.config.formId);\n    var lightbox = null;\n    var graph = _this.editor.graph;\n    graph.lightbox = lightbox;\n\n    //是否可编辑\n    if (_this.props.editable === false) {\n      graph.setEnabled(false);\n    }\n\n    //不允许将子节点移出父节点\n    //graph.graphHandler.setRemoveCellsFromParent(false);\n    //在graph disable的时候允许折叠/展开操作\n    graph.cellRenderer.forceControlClickHandler = true;\n\n    //重写判断cell是否可折叠方法，只要样式中有foldable=1即可折叠\n    graph.isCellFoldable = function (cell) {\n      var state = this.view.getState(cell);\n      var style = state != null ? state.style : this.getCellStyle(cell);\n      return style[_mxConstants[\"default\"].STYLE_FOLDABLE] == 1;\n    };\n\n    //重写getStyle，用来切换折叠节点的显示样式\n    graph.model.getStyle = function (cell) {\n      if (!cell) {\n        return null;\n      }\n      var style = cell.style;\n      if (cell.isContainable() !== true) {\n        return style;\n      }\n      var openStyle = {\n        align: 'left',\n        'fillColor': '#44A6F8',\n        'fontColor': '#FFFFFF',\n        'rounded': 1\n      };\n      var expandStyle = {\n        shape: 'swimlane',\n        spacingLeft: 20,\n        strokeColor: '#4D9AF3'\n      };\n      var collapseStyle = {\n        shape: cell.getShape(),\n        spacingLeft: 50,\n        strokeColor: '#BBBBBB'\n      };\n      var clearOpenStyle = function clearOpenStyle(style) {\n        for (var key in openStyle) {\n          style = style.replace(new RegExp(\"\".concat(key, \"=[#\\\\w]+;\"), 'g'), '');\n        }\n        return style;\n      };\n      var addOpenStyle = function addOpenStyle(style) {\n        for (var key in openStyle) {\n          style = style.replace(new RegExp(\"\".concat(key, \"=[#\\\\w]+;\"), 'g'), '') + \"\".concat(key, \"=\").concat(openStyle[key], \";\");\n        }\n        return style;\n      };\n      var replaceStyle = function replaceStyle(style, newStyle) {\n        for (var key in newStyle) {\n          style = style.replace(new RegExp(\"(\".concat(key, \"=)[#\\\\w]+;\"), 'g'), \"$1\".concat(newStyle[key], \";\"));\n        }\n        return style;\n      };\n      if (graph.isCellCollapsed(cell)) {\n        style = replaceStyle(clearOpenStyle(style), collapseStyle);\n      } else {\n        style = replaceStyle(addOpenStyle(style), expandStyle);\n      }\n      return style;\n    };\n\n    // Pre-fetches submenu image or replaces with embedded image if supported\n    if (_mxClient[\"default\"].IS_SVG) {\n      _mxPopupMenu[\"default\"].prototype.submenuImage = 'data:image/gif;base64,R0lGODlhCQAJAIAAAP///zMzMyH5BAEAAAAALAAAAAAJAAkAAAIPhI8WebHsHopSOVgb26AAADs=';\n    } else {\n      new Image().src = _mxPopupMenu[\"default\"].prototype.submenuImage;\n    }\n\n    // Pre-fetches connect image\n    if (!_mxClient[\"default\"].IS_SVG && _mxConnectionHandler[\"default\"].prototype.connectImage != null) {\n      new Image().src = _mxConnectionHandler[\"default\"].prototype.connectImage.src;\n    }\n\n    // Disables graph and forced panning in chromeless mode\n    if (_this.editor.chromeless) {\n      graph.isEnabled = function () {\n        return false;\n      };\n      graph.panningHandler.isForcePanningEvent = function (me) {\n        return !_mxEvent[\"default\"].isPopupTrigger(me.getEvent());\n      };\n    }\n    // Creates the user interface\n    _this.actions = new _Actions[\"default\"](_assertThisInitialized(_this));\n    _this.menus = _this.createMenus();\n\n    //debounce\n    _this.loadingTimer = null;\n    return _this;\n  }\n  _createClass(EditorUi, [{\n    key: \"getChildContext\",\n    value: function getChildContext() {\n      return {\n        notifyMsg: _notifyMsg[\"default\"].bind(null, this.context.model.pageId)\n      };\n    }\n  }, {\n    key: \"componentWillReceiveProps\",\n    value: function componentWillReceiveProps(nextProps) {\n      var nextData = nextProps.initialData;\n      this.setState({\n        initialData: nextData\n      });\n      nextData && (window.resourceVersion = nextData.version);\n      if (this.props.initialData === null && nextData && nextData.isBillRelationGraph) {\n        this.afterLoadInitData();\n      }\n    }\n  }, {\n    key: \"afterLoadInitData\",\n    value: function afterLoadInitData() {\n      var config = this.props.config;\n      var clientParams = config.clientParams;\n      if (clientParams && Object.keys(clientParams).length) {\n        var model = this.context.model;\n        var params = Object.assign({\n          key: model.key\n        }, clientParams);\n        this.context.invokeAction(model, 'afterLoadData', [config.formId, params]);\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.removeValidateEventListener && this.removeValidateEventListener();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var editable = this.props.editable;\n      var contentStyle = {\n        display: 'flex',\n        width: '100%',\n        flexGrow: 1,\n        backgroundColor: '#E2E7EF'\n      };\n      var rightStyle = {\n        display: 'flex',\n        flexDirection: 'column',\n        flexShrink: '0',\n        flexGrow: '0',\n        backgroundColor: '#F2F2F5'\n      };\n      if (_mxClient[\"default\"].IS_FF || _mxClient[\"default\"].IS_EDGE) {\n        contentStyle.height = '100%';\n      } else {\n        contentStyle.maxHeight = '100%';\n        contentStyle.minHeight = '100%';\n      }\n      var approvalRecordsCtl = /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        style: {\n          display: 'flex',\n          flexDirection: 'column',\n          flexGrow: '1',\n          height: '100%',\n          backgroundColor: '#E2E7EF'\n        }\n      }, /*#__PURE__*/_react[\"default\"].createElement(_ApprovalHistoryRecord[\"default\"], {\n        showRecords: this.props.ui.get('showApprovalRecords'),\n        activatedCell: this.props.ui.get('activatedCell'),\n        approvalRecords: this.props.approvalRecords,\n        coordinateRecords: this.props.coordinateRecords,\n        refreshEditor: this.refresh.bind(this),\n        initialData: this.state.initialData,\n        config: this.props.config\n      }), /*#__PURE__*/_react[\"default\"].createElement(_KDYzjChat[\"default\"], {\n        model: this.context.model\n      }));\n      var uiRight = /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        ref: \"right\",\n        className: \"ui-right\",\n        style: rightStyle\n      }, editable === false ? approvalRecordsCtl : null);\n      return /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        ref: \"container\",\n        className: \"ui-content\",\n        style: contentStyle\n      }, /*#__PURE__*/_react[\"default\"].createElement(_Diagram[\"default\"], {\n        ref: \"diagram\",\n        editorUi: this,\n        resetApprovalRecords: this.resetApprovalRecords.bind(this),\n        selected_control: this.props.ui.get('selected_control'),\n        setSelectControl: this.props.setSelectControl,\n        initialData: this.state.initialData,\n        subProcData: this.props.subProcData,\n        refreshEditor: this.refresh.bind(this),\n        showLoading: this.showLoading.bind(this),\n        editable: editable,\n        config: this.props.config,\n        ui: this.props.ui\n      }), /*#__PURE__*/_react[\"default\"].createElement(_BillSummaryInfo[\"default\"], {\n        billSummaryInfo: this.props.billSummaryInfo,\n        container: this.refs.container,\n        config: this.props.config\n      }), /*#__PURE__*/_react[\"default\"].createElement(_FloatLayer[\"default\"], {\n        showFloatLayer: this.props.ui.get('showFloatLayer'),\n        updateFloatLayer: this.props.ui.get('updateFloatLayer'),\n        initialData: this.props.initialData\n      }), uiRight, /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        ref: \"loading\",\n        className: _Bill[\"default\"]['wait-load-data'],\n        style: {\n          opacity: 0.8,\n          backgroundColor: '#FFF'\n        }\n      }, /*#__PURE__*/_react[\"default\"].createElement(_LoadingGIF[\"default\"], null)));\n    }\n  }, {\n    key: \"loadInitData\",\n    value: function loadInitData() {\n      var config = this.props.config;\n      var clientParams = config.clientParams;\n      if (clientParams && Object.keys(clientParams).length) {\n        var model = this.context.model;\n        var params = Object.assign({\n          key: model.key\n        }, clientParams);\n        this.context.invokeAction(model, 'loadData', [config.formId, params]);\n      }\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {\n      if (this.props.initialData && this.props.initialData.updateProcInstId) {\n        this.editor.graph.sizeDidChange();\n      }\n    }\n  }, {\n    key: \"getInvokeCustomEventFunc\",\n    value: function getInvokeCustomEventFunc() {\n      var model = this.context.model;\n      var config = model.getFormConfig();\n      var invokeAction = this.context.invokeAction;\n      return function (event, params) {\n        invokeAction(model, 'handleEvent', [config.formId, event, params]);\n      };\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this2 = this;\n      this.loading = this.refs.loading; //.refs.container;\n\n      var rootDiv = document.querySelector(\"div[id=\\\"\".concat(this.context.model.pageId, \"\\\"]\"));\n      if (rootDiv) {\n        rootDiv.appendChild(this.loading);\n      }\n      var graph = this.editor.graph;\n      graph.invokeCustomEvent = this.getInvokeCustomEventFunc();\n      //加载初始数据\n      this.loadInitData();\n      this.removeValidateEventListener = (0, _GlobalDataCacher.addDataChangeListener)(_symbolConst.KEY_VALIDATE_EVENT, function (_ref) {\n        var _ref$pageId = _ref.pageId,\n          pageId = _ref$pageId === void 0 ? '' : _ref$pageId;\n        if (pageId !== _this2.context.model.pageId) {\n          return;\n        }\n        _this2.save.bind(_this2)();\n      });\n      var ctxModel = this.context.model;\n      var dispatch = this.context.dispatch;\n      var pageId = ctxModel.pageId;\n      graph.pageId = pageId;\n      ctxModel.sub_Event('addNodeToDiagram', function () {\n        var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n        var datas = args[0];\n        datas.forEach(function (data) {\n          var baseType = data.baseType,\n            type = data.type,\n            template = data.template,\n            style = data.style,\n            value = data.value,\n            containable = data.containable;\n          _this2.addCellsFromSidebar(baseType, type, template, style, value, containable);\n        });\n      });\n      ctxModel.sub_Event('exportImage', function () {\n        var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n        var datas = args[0];\n        datas.forEach(function (data) {\n          var fileName = data.fileName;\n          _this2.exportImage(fileName);\n        });\n      });\n      ctxModel.sub_Event('updateProperty', function () {\n        var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n        var datas = args[0];\n        datas.forEach(function (data) {\n          var itemId = data.itemId,\n            group = data.group,\n            property = data.property,\n            value = data.value;\n          var graphModel = graph.model;\n          var cell = graphModel.getCell(itemId);\n          cell.setOriginPageId(pageId);\n          //TODO: REDO\n          cell && graphModel.setProperty(cell, group || 'base', property, value, null);\n        });\n      });\n      ctxModel.sub_Event('deleteProperty', function () {\n        var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n        var datas = args[0];\n        datas.forEach(function (data) {\n          var itemId = data.itemId,\n            property = data.property;\n          var graphModel = graph.model;\n          var cell = graphModel.getCell(itemId);\n          var properties = cell && cell.properties;\n          if (!properties) {\n            return;\n          }\n          var props = property.split(\".\");\n          if (props.length > 1) {\n            var group = properties[props[0]];\n            group && delete group[props[1]];\n          } else {\n            delete properties[property];\n          }\n        });\n      });\n      ctxModel.sub_Event('updatePageCount', function () {\n        var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n        var datas = args[0];\n        datas.forEach(function (data) {\n          if (data.increment) {\n            graph.configurePageCount++;\n          } else if (--graph.configurePageCount == 0) {\n            _this2.showLoading(false);\n          }\n        });\n      });\n      ctxModel.sub_Event('showBlock', function () {\n        var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n        var datas = args[0];\n        datas.forEach(function (data) {\n          _this2.showLoading(data.block);\n        });\n      });\n      ctxModel.sub_Event('close', function () {\n        var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n        var datas = args[0];\n        datas.forEach(function (data) {\n          delete window.editors[data.pageId];\n        });\n      });\n      ctxModel.sub_Event('selectProcess', function () {\n        var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n        graph.clearSelection();\n        (0, _graphUtil.selectProcess)(graph);\n      });\n      ctxModel.sub_Event('selectNode', function () {\n        var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n        var datas = args[0];\n        datas.forEach(function (data) {\n          graph.clearSelection();\n          (0, _graphUtil.selectNode)(graph, data.cellId);\n        });\n      });\n      ctxModel.sub_Event('changeStyle', function () {\n        var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n        var datas = args[0];\n        datas.forEach(function (data) {\n          var itemId = data.itemId,\n            newStyle = data.newStyle;\n          var cell = graph.getModel().getCell(itemId);\n          graph.setCellStyle(_mxUtils[\"default\"].trim(newStyle), [cell]);\n        });\n      });\n      ctxModel.sub_Event('print', function () {\n        var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n        var datas = args[0];\n        datas.forEach(function (data) {\n          console && console.log(data.json);\n        });\n      });\n      ctxModel.sub_Event('paste', function () {\n        var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n        var datas = args[0];\n        _this2.clipboardPaste(graph, true);\n      });\n      this.container = this.refs.container || document.body;\n\n      //this.centerContainer = this.refs.center;\n      this.diagramContainer = this.refs.diagram.refs.container;\n      //this.hsplit = this.refs.hsplit.refs.container;\n\n      this.rightContainer = this.refs.right;\n\n      //添加选中节点变化的监听\n      graph.getSelectionModel().addListener(_mxGraphConstant.EVENT.CHANGE, this.update.bind(this));\n      graph.addListener(_mxGraphConstant.EVENT.AFTER_DELETE_CELLS, this.afterDeleteCellsListener.bind(this));\n      graph.addListener(_mxGraphConstant.EVENT.REMOVE_CELLS, this.removeCellsListener.bind(this));\n      graph.addListener(_mxEvent[\"default\"].PASTE_CELLS, this.pasteCellsListener.bind(this));\n      graph.addListener(_mxEvent[\"default\"].SPLIT_EDGE, this.splitEdgeListener.bind(this));\n      graph.addListener(_mxEvent[\"default\"].MOVE_CELLS, this.moveCellsListener.bind(this));\n\n      //this.refresh();\n\n      // Disables HTML and text selection\n      var textEditing = _mxGraphUtils[\"default\"].bind(this, function (evt) {\n        if (evt == null) {\n          evt = window.event;\n        }\n        if (this.isSelectionAllowed(evt)) {\n          return true;\n        }\n        return graph.isEditing();\n      });\n\n      // And uses built-in context menu while editing\n      if (!this.editor.chromeless) {\n        if (_mxClient[\"default\"].IS_IE && (typeof document.documentMode === 'undefined' || document.documentMode < 9)) {\n          _mxEvent[\"default\"].addListener(this.diagramContainer, 'contextmenu', textEditing);\n        } else {\n          // Allows browser context menu outside of diagram and sidebar\n          this.diagramContainer.oncontextmenu = textEditing;\n        }\n      } else {\n        graph.panningHandler.usePopupTrigger = false;\n      }\n\n      // Contains the main graph instance inside the given panel\n\n      var params = this.props.config.clientParams || {};\n      var isBillRelationGraph = params.isBillRelationGraph;\n      var graphFireEvet = graph.fireEvent;\n      graph.fireEvent = _mxGraphUtils[\"default\"].bind(graph, function () {\n        if (graph.initializing !== true) {\n          graphFireEvet.apply(this, arguments);\n        }\n      });\n      var isServerRender = params.serverRender;\n      if (isBillRelationGraph && !isServerRender) {\n        graph.initLayoutManager = _mxGraphUtils[\"default\"].bind(graph, function () {\n          var layout = new _mxCompactTreeLayout[\"default\"](this, true);\n          layout.useBoundingBox = false;\n          layout.edgeRouting = false;\n          layout.levelDistance = 60;\n          layout.nodeDistance = 20;\n          layout.resetEdges = false;\n          layout.isVertexMovable = function (cell) {\n            return true;\n          };\n          var layoutMgr = new _mxLayoutManager[\"default\"](this);\n          layoutMgr.getLayout = function (cell) {\n            if (cell.getChildCount() > 0) {\n              layout.horizontal = graph.horizontalLayout != null ? graph.horizontalLayout : layout.horizontal;\n              return layout;\n            }\n          };\n        });\n      }\n      graph.init(this.diagramContainer);\n\n      // Intercepts links with no target attribute and opens in new window\n      graph.cellRenderer.initializeLabel = function (state, shape) {\n        _mxCellRenderer[\"default\"].prototype.initializeLabel.apply(this, arguments);\n        _mxEvent[\"default\"].addListener(shape.node, 'click', function (evt) {\n          var elt = _mxEvent[\"default\"].getSource(evt);\n          while (elt != null && elt != shape.node) {\n            if (elt.nodeName == 'A') {\n              if (elt.getAttribute('target') == null && elt.getAttribute('href') != null) {\n                window.open(elt.getAttribute('href'));\n                _mxEvent[\"default\"].consume(evt);\n              }\n              break;\n            }\n            elt = elt.parentNode;\n          }\n        });\n      };\n      graph.graphHandler.moveCells = function (cells, dx, dy, clone, target, evt) {\n        var result;\n        var validate = true;\n        if (target && cells && cells.length) {\n          for (var _i = 0; _i < cells.length; _i++) {\n            var cell = cells[_i];\n            if ((target.type == 'Pool' || target.type == 'Lane') && _mxGraphUtils[\"default\"].isBoundaryEvent(cell.type)) {\n              validate = false;\n              break;\n            }\n            if (target.type == 'Pool' && cell.type != 'Lane') {\n              result = (0, _intlApi.getLangMsg)({\n                key: \"WFEditorUi.moveElementToPoolTip\"\n              });\n              validate = false;\n              break;\n            }\n          }\n        }\n        if (!validate) {\n          if (result) {\n            var action = {\n              p: [{\n                \"duration\": 3000,\n                \"type\": 2,\n                \"content\": result\n              }],\n              a: _server.SHOW_NOTIFICATION_MESSAGE\n            };\n            (0, _action.doPostActions)(pageId, [action], dispatch);\n          }\n        } else {\n          _mxGraphHandler[\"default\"].prototype.moveCells.apply(this, arguments);\n        }\n      };\n\n      // Creates hover icons\n      this.hoverIcons = this.createHoverIcons();\n\n      // Adds tooltip when mouse is over scrollbars to show space-drag panning option\n      _mxEvent[\"default\"].addListener(this.diagramContainer, 'mousemove', _mxGraphUtils[\"default\"].bind(this, function (evt) {\n        var off = _mxUtils[\"default\"].getOffset(this.diagramContainer);\n        if (_mxEvent[\"default\"].getClientX(evt) - off.x - this.diagramContainer.clientWidth > 0 || _mxEvent[\"default\"].getClientY(evt) - off.y - this.diagramContainer.clientHeight > 0) {\n          this.diagramContainer.setAttribute('title', _mxResources[\"default\"].get('panTooltip'));\n        } else {\n          this.diagramContainer.removeAttribute('title');\n        }\n      }));\n\n      // Escape key hides dialogs, adds space+drag panning\n      var spaceKeyPressed = false;\n\n      // Overrides hovericons to disable while space key is pressed\n      var hoverIconsIsResetEvent = this.hoverIcons.isResetEvent;\n      this.hoverIcons.isResetEvent = function (evt, allowShift) {\n        return spaceKeyPressed || hoverIconsIsResetEvent.apply(this, arguments);\n      };\n      this.keydownHandler = _mxGraphUtils[\"default\"].bind(this, function (evt) {\n        if (evt.which == 32 /* Space */) {\n          spaceKeyPressed = true;\n          this.hoverIcons.reset();\n          graph.container.style.cursor = 'move';\n\n          // Disables scroll after space keystroke with scrollbars\n          if (!graph.isEditing() && _mxEvent[\"default\"].getSource(evt) == graph.container) {\n            _mxEvent[\"default\"].consume(evt);\n          }\n        } else if (!_mxEvent[\"default\"].isConsumed(evt) && evt.keyCode == 27 /* Escape */) {\n          this.hideDialog();\n        }\n      });\n      _mxEvent[\"default\"].addListener(document, 'keydown', this.keydownHandler);\n      this.keyupHandler = _mxGraphUtils[\"default\"].bind(this, function (evt) {\n        graph.container.style.cursor = '';\n        spaceKeyPressed = false;\n      });\n      _mxEvent[\"default\"].addListener(document, 'keyup', this.keyupHandler);\n\n      // Forces panning for middle and right mouse buttons\n      var panningHandlerIsForcePanningEvent = graph.panningHandler.isForcePanningEvent;\n      graph.panningHandler.isForcePanningEvent = function (me) {\n        // Ctrl+left button is reported as right button in FF on Mac\n        return panningHandlerIsForcePanningEvent.apply(this, arguments) || spaceKeyPressed || _mxEvent[\"default\"].isMouseEvent(me.getEvent()) && (this.usePopupTrigger || !_mxEvent[\"default\"].isPopupTrigger(me.getEvent())) && (!_mxEvent[\"default\"].isControlDown(me.getEvent()) && _mxEvent[\"default\"].isRightMouseButton(me.getEvent()) || _mxEvent[\"default\"].isMiddleMouseButton(me.getEvent()));\n      };\n\n      // Control-enter applies editing value\n      // FIXME: Fix for HTML editing\n      var cellEditorIsStopEditingEvent = graph.cellEditor.isStopEditingEvent;\n      graph.cellEditor.isStopEditingEvent = function (evt) {\n        return cellEditorIsStopEditingEvent.apply(this, arguments) || evt.keyCode == 13 && _mxEvent[\"default\"].isControlDown(evt);\n      };\n\n      // Switches toolbar for text editing\n      var textMode = false;\n      var fontMenu = null;\n      var sizeMenu = null;\n      var nodes = null;\n      var ui = this;\n\n      // Overrides cell editor to update toolbar\n      var cellEditorStartEditing = graph.cellEditor.startEditing;\n      graph.cellEditor.startEditing = function () {\n        cellEditorStartEditing.apply(this, arguments);\n        if (graph.cellEditor.isContentEditing()) {\n          var updating = false;\n          var updateCssHandler = function updateCssHandler() {\n            if (!updating) {\n              updating = true;\n              window.setTimeout(function () {\n                var selectedElement = graph.getSelectedElement();\n                var node = selectedElement;\n                while (node != null && node.nodeType != _mxConstants[\"default\"].NODETYPE_ELEMENT) {\n                  node = node.parentNode;\n                }\n                if (node != null) {\n                  var css = _mxUtils[\"default\"].getCurrentStyle(node);\n                  if (css != null && ui.toolbar != null) {\n                    // Strips leading and trailing quotes\n                    var ff = css.fontFamily;\n                    if (ff.charAt(0) == '\\'') {\n                      ff = ff.substring(1);\n                    }\n                    if (ff.charAt(ff.length - 1) == '\\'') {\n                      ff = ff.substring(0, ff.length - 1);\n                    }\n                  }\n                }\n                updating = false;\n              }, 0);\n            }\n          };\n          _mxEvent[\"default\"].addListener(graph.cellEditor.textarea, 'input', updateCssHandler);\n          _mxEvent[\"default\"].addListener(graph.cellEditor.textarea, 'touchend', updateCssHandler);\n          _mxEvent[\"default\"].addListener(graph.cellEditor.textarea, 'mouseup', updateCssHandler);\n          _mxEvent[\"default\"].addListener(graph.cellEditor.textarea, 'keyup', updateCssHandler);\n          updateCssHandler();\n        }\n      };\n      var cellEditorStopEditing = graph.cellEditor.stopEditing;\n      graph.cellEditor.stopEditing = function (cell, trigger) {\n        cellEditorStopEditing.apply(this, arguments);\n      };\n\n      // Enables scrollbars and sets cursor style for the container\n      graph.container.setAttribute('tabindex', '0');\n      graph.container.style.cursor = 'default';\n\n      // Workaround for page scroll if embedded via iframe\n      if (window.self === window.top && graph.container.parentNode != null) {\n        graph.container.focus();\n      }\n\n      // Keeps graph container focused on mouse down\n      var graphFireMouseEvent = graph.fireMouseEvent;\n      graph.fireMouseEvent = function (evtName, me, sender) {\n        if (evtName == _mxEvent[\"default\"].MOUSE_DOWN) {\n          this.container.focus();\n        }\n        graphFireMouseEvent.apply(this, arguments);\n      };\n\n      // Configures automatic expand on mouseover\n      graph.popupMenuHandler.autoExpand = true;\n\n      // Installs context menu\n      if (this.menus != null) {\n        graph.popupMenuHandler.factoryMethod = _mxGraphUtils[\"default\"].bind(this, function (menu, cell, evt) {\n          this.menus.createPopupMenu(menu, cell, evt);\n        });\n      }\n\n      // Hides context menu\n      _mxEvent[\"default\"].addGestureListeners(document, _mxGraphUtils[\"default\"].bind(this, function (evt) {\n        graph.popupMenuHandler.hideMenu();\n      }));\n\n      // Create handler for key events\n      this.keyHandler = this.createKeyHandler(this.editor);\n\n      // Getter for key handler\n      this.getKeyHandler = function () {\n        return this.keyHandler;\n      };\n\n      // Stores the current style and assigns it to new cells\n      var styles = ['rounded', 'shadow', 'glass', 'dashed', 'dashPattern', 'comic', 'labelBackgroundColor'];\n      var connectStyles = ['shape', 'edgeStyle', 'curved', 'rounded', 'elbow', 'comic'];\n\n      // Note: Everything that is not in styles is ignored (styles is augmented below)\n      this.setDefaultStyle = function (cell) {\n        var state = graph.view.getState(cell);\n        if (state != null) {\n          // Ignores default styles\n          var clone = cell.clone();\n          clone.style = '';\n          var defaultStyle = graph.getCellStyle(clone);\n          var values = [];\n          var keys = [];\n          for (var key in state.style) {\n            if (defaultStyle[key] != state.style[key]) {\n              values.push(state.style[key]);\n              keys.push(key);\n            }\n          }\n\n          // Handles special case for value \"none\"\n          var cellStyle = graph.getModel().getStyle(state.cell);\n          var tokens = cellStyle != null ? cellStyle.split(';') : [];\n          for (var i = 0; i < tokens.length; i++) {\n            var tmp = tokens[i];\n            var pos = tmp.indexOf('=');\n            if (pos >= 0) {\n              var key = tmp.substring(0, pos);\n              var value = tmp.substring(pos + 1);\n              if (defaultStyle[key] != null && value == 'none') {\n                values.push(value);\n                keys.push(key);\n              }\n            }\n          }\n\n          // Resets current style\n          if (graph.getModel().isEdge(state.cell)) {\n            graph.currentEdgeStyle = {};\n          } else {\n            graph.currentVertexStyle = {};\n          }\n          this.fireEvent(new _mxEventObject[\"default\"]('styleChanged', 'keys', keys, 'values', values, 'cells', [state.cell]));\n        }\n      };\n      this.clearDefaultStyle = function () {\n        graph.currentEdgeStyle = graph.defaultEdgeStyle;\n        graph.currentVertexStyle = {};\n\n        // Updates UI\n        this.fireEvent(new _mxEventObject[\"default\"]('styleChanged', 'keys', [], 'values', [], 'cells', []));\n      };\n\n      // Keys that should be ignored if the cell has a value (known: new default for all cells is html=1 so\n      // for the html key this effecticely only works for edges inserted via the connection handler)\n      var valueStyles = ['fontFamily', 'fontSize', 'fontColor'];\n\n      // Keys that always update the current edge style regardless of selection\n      var alwaysEdgeStyles = ['edgeStyle', 'startArrow', 'startFill', 'startSize', 'endArrow', 'endFill', 'endSize', 'jettySize', 'orthogonalLoop'];\n\n      // Keys that are ignored together (if one appears all are ignored)\n      var keyGroups = [['startArrow', 'startFill', 'startSize', 'endArrow', 'endFill', 'endSize', 'jettySize', 'orthogonalLoop'], ['strokeColor', 'strokeWidth'], ['fillColor', 'gradientColor'], valueStyles, ['align'], ['html']];\n\n      // Adds all keys used above to the styles array\n      for (var i = 0; i < keyGroups.length; i++) {\n        for (var j = 0; j < keyGroups[i].length; j++) {\n          styles.push(keyGroups[i][j]);\n        }\n      }\n      for (var i = 0; i < connectStyles.length; i++) {\n        styles.push(connectStyles[i]);\n      }\n\n      // Implements a global current style for edges and vertices that is applied to new cells\n      var insertHandler = function insertHandler(cells, asText) {\n        graph.getModel().beginUpdate();\n        try {\n          var cell = null;\n          // Applies only basic text styles\n          if (asText) {\n            var edge = graph.getModel().isEdge(cell);\n            var current = edge ? graph.currentEdgeStyle : graph.currentVertexStyle;\n            var textStyles = ['fontSize', 'fontFamily', 'fontColor'];\n            for (var j = 0; j < textStyles.length; j++) {\n              var value = current[textStyles[j]];\n              if (value != null) {\n                graph.setCellStyles(textStyles[j], value, cells);\n              }\n            }\n          } else {\n            for (var i = 0; i < cells.length; i++) {\n              cell = cells[i];\n\n              // Removes styles defined in the cell style from the styles to be applied\n              var cellStyle = graph.getModel().getStyle(cell);\n              var tokens = cellStyle != null ? cellStyle.split(';') : [];\n              var appliedStyles = styles.slice();\n              for (var j = 0; j < tokens.length; j++) {\n                var tmp = tokens[j];\n                var pos = tmp.indexOf('=');\n                if (pos >= 0) {\n                  var key = tmp.substring(0, pos);\n                  var index = _mxUtils[\"default\"].indexOf(appliedStyles, key);\n                  if (index >= 0) {\n                    appliedStyles.splice(index, 1);\n                  }\n\n                  // Handles special cases where one defined style ignores other styles\n                  for (var k = 0; k < keyGroups.length; k++) {\n                    var group = keyGroups[k];\n                    if (_mxUtils[\"default\"].indexOf(group, key) >= 0) {\n                      for (var l = 0; l < group.length; l++) {\n                        var index2 = _mxUtils[\"default\"].indexOf(appliedStyles, group[l]);\n                        if (index2 >= 0) {\n                          appliedStyles.splice(index2, 1);\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n\n              // Applies the current style to the cell\n              var edge = graph.getModel().isEdge(cell);\n              var current = edge ? graph.currentEdgeStyle : graph.currentVertexStyle;\n              for (var j = 0; j < appliedStyles.length; j++) {\n                var key = appliedStyles[j];\n                var styleValue = current[key];\n                if (styleValue != null && (key != 'shape' || edge)) {\n                  // Special case: Connect styles are not applied here but in the connection handler\n                  if (!edge || _mxUtils[\"default\"].indexOf(connectStyles, key) < 0) {\n                    graph.setCellStyles(key, styleValue, [cell]);\n                  }\n                }\n              }\n            }\n          }\n        } finally {\n          graph.getModel().endUpdate();\n        }\n      };\n      graph.addListener('cellsInserted', function (sender, evt) {\n        insertHandler(evt.getProperty('cells'));\n        ui.insertCellsListener(evt);\n      });\n      graph.addListener('textInserted', function (sender, evt) {\n        insertHandler(evt.getProperty('cells'), true);\n      });\n      graph.connectionHandler.addListener(_mxEvent[\"default\"].CONNECT, function (sender, evt) {\n        var cells = [evt.getProperty('cell')];\n        if (evt.getProperty('terminalInserted')) {\n          cells.push(evt.getProperty('terminal'));\n        }\n        insertHandler(cells);\n        ui.connectListener(evt);\n      });\n      graph.addListener(_mxEvent[\"default\"].CONNECT_CELL, function (sender, evt) {\n        ui.connectListener(evt);\n      });\n      this.addListener('styleChanged', _mxGraphUtils[\"default\"].bind(this, function (sender, evt) {\n        // Checks if edges and/or vertices were modified\n        var cells = evt.getProperty('cells');\n        var vertex = false;\n        var edge = false;\n        if (cells.length > 0) {\n          for (var i = 0; i < cells.length; i++) {\n            vertex = graph.getModel().isVertex(cells[i]) || vertex;\n            edge = graph.getModel().isEdge(cells[i]) || edge;\n            if (edge && vertex) {\n              break;\n            }\n          }\n        } else {\n          vertex = true;\n          edge = true;\n        }\n        var keys = evt.getProperty('keys');\n        var values = evt.getProperty('values');\n        for (var i = 0; i < keys.length; i++) {\n          var common = _mxUtils[\"default\"].indexOf(valueStyles, keys[i]) >= 0;\n\n          // Ignores transparent stroke colors\n          if (keys[i] != 'strokeColor' || values[i] != null && values[i] != 'none') {\n            // Special case: Edge style and shape\n            if (_mxUtils[\"default\"].indexOf(connectStyles, keys[i]) >= 0) {\n              if (edge || _mxUtils[\"default\"].indexOf(alwaysEdgeStyles, keys[i]) >= 0) {\n                if (values[i] == null) {\n                  delete graph.currentEdgeStyle[keys[i]];\n                } else {\n                  graph.currentEdgeStyle[keys[i]] = values[i];\n                }\n              }\n              // Uses style for vertex if defined in styleselse\n              if (vertex && _mxUtils[\"default\"].indexOf(styles, keys[i]) >= 0) {\n                if (values[i] == null) {\n                  delete graph.currentVertexStyle[keys[i]];\n                } else {\n                  graph.currentVertexStyle[keys[i]] = values[i];\n                }\n              }\n            } else if (_mxUtils[\"default\"].indexOf(styles, keys[i]) >= 0) {\n              if (vertex || common) {\n                if (values[i] == null) {\n                  delete graph.currentVertexStyle[keys[i]];\n                } else {\n                  graph.currentVertexStyle[keys[i]] = values[i];\n                }\n              }\n              if (edge || common || _mxUtils[\"default\"].indexOf(alwaysEdgeStyles, keys[i]) >= 0) {\n                if (values[i] == null) {\n                  delete graph.currentEdgeStyle[keys[i]];\n                } else {\n                  graph.currentEdgeStyle[keys[i]] = values[i];\n                }\n              }\n            }\n          }\n        }\n        if (this.toolbar != null) {\n          this.toolbar.setFontName(graph.currentVertexStyle['fontFamily'] || _mxGraphConstant.MENU.defaultFont);\n          this.toolbar.setFontSize(graph.currentVertexStyle['fontSize'] || _mxGraphConstant.MENU.defaultFontSize);\n          if (this.toolbar.edgeStyleMenu != null) {\n            // Updates toolbar icon for edge style\n            var edgeStyleDiv = this.toolbar.edgeStyleMenu.getElementsByTagName('div')[0];\n            if (graph.currentEdgeStyle['edgeStyle'] == 'orthogonalEdgeStyle' && graph.currentEdgeStyle['curved'] == '1') {\n              edgeStyleDiv.className = 'geSprite geSprite-curved';\n            } else if (graph.currentEdgeStyle['edgeStyle'] == 'straight' || graph.currentEdgeStyle['edgeStyle'] == 'none' || graph.currentEdgeStyle['edgeStyle'] == null) {\n              edgeStyleDiv.className = 'geSprite geSprite-straight';\n            } else if (graph.currentEdgeStyle['edgeStyle'] == 'entityRelationEdgeStyle') {\n              edgeStyleDiv.className = 'geSprite geSprite-entity';\n            } else if (graph.currentEdgeStyle['edgeStyle'] == 'elbowEdgeStyle') {\n              edgeStyleDiv.className = 'geSprite geSprite-' + (graph.currentEdgeStyle['elbow'] == 'vertical' ? 'verticalelbow' : 'horizontalelbow');\n            } else if (graph.currentEdgeStyle['edgeStyle'] == 'isometricEdgeStyle') {\n              edgeStyleDiv.className = 'geSprite geSprite-' + (graph.currentEdgeStyle['elbow'] == 'vertical' ? 'verticalisometric' : 'horizontalisometric');\n            } else {\n              edgeStyleDiv.className = 'geSprite geSprite-orthogonal';\n            }\n          }\n          if (this.toolbar.edgeShapeMenu != null) {\n            // Updates icon for edge shape\n            var edgeShapeDiv = this.toolbar.edgeShapeMenu.getElementsByTagName('div')[0];\n            if (graph.currentEdgeStyle['shape'] == 'link') {\n              edgeShapeDiv.className = 'geSprite geSprite-linkedge';\n            } else if (graph.currentEdgeStyle['shape'] == 'flexArrow') {\n              edgeShapeDiv.className = 'geSprite geSprite-arrow';\n            } else if (graph.currentEdgeStyle['shape'] == 'arrow') {\n              edgeShapeDiv.className = 'geSprite geSprite-simplearrow';\n            } else {\n              edgeShapeDiv.className = 'geSprite geSprite-connection';\n            }\n          }\n\n          // Updates icon for optinal line start shape\n          if (this.toolbar.lineStartMenu != null) {\n            var lineStartDiv = this.toolbar.lineStartMenu.getElementsByTagName('div')[0];\n            lineStartDiv.className = this.getCssClassForMarker('start', graph.currentEdgeStyle['shape'], graph.currentEdgeStyle[_mxConstants[\"default\"].STYLE_STARTARROW], _mxUtils[\"default\"].getValue(graph.currentEdgeStyle, 'startFill', '1'));\n          }\n\n          // Updates icon for optinal line end shape\n          if (this.toolbar.lineEndMenu != null) {\n            var lineEndDiv = this.toolbar.lineEndMenu.getElementsByTagName('div')[0];\n            lineEndDiv.className = this.getCssClassForMarker('end', graph.currentEdgeStyle['shape'], graph.currentEdgeStyle[_mxConstants[\"default\"].STYLE_ENDARROW], _mxUtils[\"default\"].getValue(graph.currentEdgeStyle, 'endFill', '1'));\n          }\n        }\n      }));\n\n      // Update font size and font family labels\n      if (this.toolbar != null) {\n        var update = _mxGraphUtils[\"default\"].bind(this, function () {\n          var ff = graph.currentVertexStyle['fontFamily'] || 'Helvetica';\n          var fs = String(graph.currentVertexStyle['fontSize'] || '12');\n          var state = graph.getView().getState(graph.getSelectionCell());\n          if (state != null) {\n            ff = state.style[_mxConstants[\"default\"].STYLE_FONTFAMILY] || ff;\n            fs = state.style[_mxConstants[\"default\"].STYLE_FONTSIZE] || fs;\n            if (ff.length > 10) {\n              ff = ff.substring(0, 8) + '...';\n            }\n          }\n          this.toolbar.setFontName(ff);\n          this.toolbar.setFontSize(fs);\n        });\n        graph.getSelectionModel().addListener(_mxEvent[\"default\"].CHANGE, update);\n        graph.getModel().addListener(_mxEvent[\"default\"].CHANGE, update);\n      }\n\n      // Makes sure the current layer is visible when cells are added\n      graph.addListener(_mxEvent[\"default\"].CELLS_ADDED, function (sender, evt) {\n        var cells = evt.getProperty('cells');\n        var parent = evt.getProperty('parent');\n        if (graph.getModel().isLayer(parent) && !graph.isCellVisible(parent) && cells != null && cells.length > 0) {\n          graph.getModel().setVisible(parent, true);\n        }\n      });\n\n      // Global handler to hide the current menu\n      this.gestureHandler = _mxGraphUtils[\"default\"].bind(this, function (evt) {\n        if (this.currentMenu != null && _mxEvent[\"default\"].getSource(evt) != this.currentMenu.div) {\n          this.hideCurrentMenu();\n        }\n      });\n      _mxEvent[\"default\"].addGestureListeners(document, this.gestureHandler);\n\n      // Updates the editor UI after the window has been resized or the orientation changes\n      // Timeout is workaround for old IE versions which have a delay for DOM client sizes.\n      // Should not use delay > 0 to avoid handle multiple repaints during window resize\n      this.resizeHandler = _mxGraphUtils[\"default\"].bind(this, function () {\n        window.setTimeout(_mxGraphUtils[\"default\"].bind(this, function () {\n          this.refresh();\n        }), 0);\n      });\n      _mxEvent[\"default\"].addListener(window, 'resize', this.resizeHandler);\n      this.orientationChangeHandler = _mxGraphUtils[\"default\"].bind(this, function () {\n        this.refresh();\n      });\n      _mxEvent[\"default\"].addListener(window, 'orientationchange', this.orientationChangeHandler);\n\n      // Workaround for bug on iOS see\n      // http://stackoverflow.com/questions/19012135/ios-7-ipad-safari-landscape-innerheight-outerheight-layout-issue\n      if (_mxClient[\"default\"].IS_IOS && !window.navigator.standalone) {\n        this.scrollHandler = _mxGraphUtils[\"default\"].bind(this, function () {\n          window.scrollTo(0, 0);\n        });\n        _mxEvent[\"default\"].addListener(window, 'scroll', this.scrollHandler);\n      }\n\n      /**\n       * Sets the initial scrollbar locations after a file was loaded.\n       */\n      this.editor.addListener('resetGraphView', _mxGraphUtils[\"default\"].bind(this, function () {\n        this.resetScrollbars();\n      }));\n\n      /**\n       * Repaints the grid.\n       */\n      this.addListener('gridEnabledChanged', _mxGraphUtils[\"default\"].bind(this, function () {\n        graph.view.validateBackground();\n      }));\n      this.addListener('backgroundColorChanged', _mxGraphUtils[\"default\"].bind(this, function () {\n        graph.view.validateBackground();\n      }));\n\n      /**\n       * Repaints the grid.\n       */\n      graph.addListener('gridSizeChanged', _mxGraphUtils[\"default\"].bind(this, function () {\n        if (graph.isGridEnabled()) {\n          graph.view.validateBackground();\n        }\n      }));\n      if (this.props.editable === false && this.props.showNodeDetails === true) {\n        //TODO: 代码移动到Diagram\n        var svg = this.diagramContainer.querySelector('svg'),\n          defSvg = document.querySelector('svg.defs'),\n          clientParams = this.props.config.clientParams,\n          billId = clientParams.billId || '',\n          activateCell = this.props.activateCell,\n          showFloatLayer = this.props.showFloatLayer,\n          hideFloaterLayer = this.props.hideFloaterLayer,\n          pageId = this.context.model.pageId;\n        if (!defSvg.querySelector('#box-shadow')) {\n          defSvg.appendChild(this.createBoxShadowFilter());\n        }\n        //查看流程图高亮效果\n        graph.addMouseListener({\n          mouseDown: function mouseDown(sender, me) {\n            var cell = null;\n            //不显示审批记录的节点不用处理\n            if (me.state && (cell = me.state.cell) && cell.isVertex() && cell.showRecords) {\n              var procInstId = _this2.props.config.clientParams.procInstId || '';\n              //业务流\n              if (_this2.props.initialData) {\n                var drawPane = svg.querySelector('#drawPane'),\n                  cellPane = drawPane.querySelector(\"#\".concat(cell.mxObjectId)),\n                  activatedCellCls = _Diagram2[\"default\"].activatedCell,\n                  actCell = drawPane.querySelector(\".\".concat(activatedCellCls));\n                _mxGraphUtils[\"default\"].removeClass(actCell, activatedCellCls);\n                _mxGraphUtils[\"default\"].addClass(cellPane, activatedCellCls);\n                if (!(0, _workflowUtil.isBizFlow)(_this2.props.initialData.flowType)) {\n                  activateCell({\n                    id: cell.id,\n                    procInstId: procInstId,\n                    billId: billId,\n                    title: cell.getProperty('name'),\n                    showRecords: cell.showRecords\n                  });\n                  _this2.refresh(true, false);\n                }\n                //触发change事件\n                var businessKey = cell.properties && cell.properties.businessKey;\n                var activityInstId = cell.properties && cell.properties.activityInstId;\n                var _params = [_this2.props.config.formId, cell.getType(), cell.getId(), {\n                  businessKey: businessKey,\n                  activityInstId: activityInstId\n                }];\n                _this2.context.invokeAction(_this2.context.model, 'change', _params);\n              }\n            } else if (cell && cell.clickable) {\n              var props = cell.properties || {};\n              var _params2 = [_this2.props.config.formId, cell.getType(), cell.getId(), _objectSpread({}, props)];\n              _this2.context.invokeAction(_this2.context.model, 'change', _params2);\n            }\n          },\n          mouseMove: function mouseMove(sender, me) {\n            var cell = null;\n            //业务流\n            if (_this2.props.initialData && _this2.props.initialData.flowType == \"BizFlow\") {\n              //不显示审批记录的节点不用处理\n              if (me.state && (cell = me.state.cell) && cell.isVertex() && cell.showRecords) {\n                var procInstId = _this2.props.config.clientParams.procInstId || '';\n                var left = me.state.x - me.state.view.graph.container.scrollLeft + me.state.width;\n                var top = me.state.y - me.state.view.graph.container.scrollTop - 5;\n                showFloatLayer({\n                  id: cell.getId(),\n                  procInstId: procInstId,\n                  billId: billId,\n                  title: cell.getProperty('name'),\n                  left: left,\n                  top: top,\n                  showFloatLayer: cell.showRecords,\n                  pageId: pageId\n                });\n              } else {\n                hideFloaterLayer({\n                  showFloatLayer: false\n                });\n              }\n            }\n          },\n          mouseUp: function mouseUp() {}\n        });\n      }\n\n      // Resets UI, updates action and menu states\n      this.editor.resetGraph();\n      this.init();\n      // Fires as the last step if no file was loaded\n      this.editor.graph.view.validate();\n\n      // Required only in special cases where an initial file is opened\n      // and the minimumGraphSize changes and CSS must be updated.\n      this.editor.graph.sizeDidChange();\n      this.editor.fireEvent(new _mxEventObject[\"default\"]('resetGraphView'));\n      window.editors = window.editors || {};\n      window.editors[this.context.model.pageId] = this;\n    }\n  }, {\n    key: \"fetchUiMetadata\",\n    value: function fetchUiMetadata(modelType, modelVer, callback) {\n      //TODO: 模型内容确定后打开缓存\n      //domainModel使用localStorage缓存\n      /*let storeKey= `${STORE_KEY_PREFIX}.${modelType}.${modelVer}`;\n      let uiMeta = window.localStorage[storeKey];\n      if(uiMeta){\n       \tthis.props.setUiMetadata(JSON.parse(uiMeta));\n      }else{*/\n      this.props.fetchUiMetadata(modelType, modelVer, callback);\n      //}\n    }\n  }, {\n    key: \"save\",\n    value: function save() {\n      var graph = this.editor.graph;\n      if (graph.isEditing()) {\n        graph.stopEditing();\n      }\n      var modelGraph = graph.getModelGraph();\n      var postData = {\n        graph_json: JSON.stringify(modelGraph)\n      };\n      this.context.setPostData(this.context.model, postData);\n      this.editor.setModified(false);\n    }\n\n    /**\n     * Installs the listeners to update the action states.\n     */\n  }, {\n    key: \"init\",\n    value: function init() {\n      /**\n       * Keypress starts immediate editing on selection cell\n       */\n      var graph = this.editor.graph;\n      _mxEvent[\"default\"].addListener(graph.container, 'keydown', _mxGraphUtils[\"default\"].bind(this, function (evt) {\n        // Tab selects next cell\n        if (evt.which == 9 && graph.isEnabled()) {\n          if (graph.isEditing()) {\n            graph.stopEditing(false);\n          }\n          graph.selectCell(!_mxEvent[\"default\"].isShiftDown(evt));\n          _mxEvent[\"default\"].consume(evt);\n        }\n      }));\n      _mxEvent[\"default\"].addListener(graph.container, 'keypress', _mxGraphUtils[\"default\"].bind(this, function (evt) {\n        // KNOWN: Focus does not work if label is empty in quirks mode\n        if (this.isImmediateEditingEvent(evt) && !graph.isEditing() && !graph.isSelectionEmpty() && evt.which !== 0 && !_mxEvent[\"default\"].isAltDown(evt) && !_mxEvent[\"default\"].isControlDown(evt) && !_mxEvent[\"default\"].isMetaDown(evt)) {\n          graph.escape();\n          //graph.startEditing();\n\n          // Workaround for FF where char is lost if cursor is placed before char\n          if (_mxClient[\"default\"].IS_FF) {\n            var ce = graph.cellEditor;\n            ce.textarea.innerHTML = String.fromCharCode(evt.which);\n\n            // Moves cursor to end of textarea\n            var range = document.createRange();\n            range.selectNodeContents(ce.textarea);\n            range.collapse(false);\n            var sel = window.getSelection();\n            sel.removeAllRanges();\n            sel.addRange(range);\n          }\n        }\n      }));\n\n      // Updates action states\n      this.addUndoListener();\n      this.addBeforeUnloadListener();\n      graph.getSelectionModel().addListener(_mxEvent[\"default\"].CHANGE, _mxGraphUtils[\"default\"].bind(this, function () {\n        this.updateActionStates();\n      }));\n      graph.getModel().addListener(_mxEvent[\"default\"].CHANGE, _mxGraphUtils[\"default\"].bind(this, function () {\n        this.updateActionStates();\n      }));\n\n      // Changes action states after change of default parent\n      var graphSetDefaultParent = graph.setDefaultParent;\n      var ui = this;\n      this.editor.graph.setDefaultParent = function () {\n        graphSetDefaultParent.apply(this, arguments);\n        ui.updateActionStates();\n      };\n\n      // Hack to make editLink available in vertex handler\n      graph.editLink = ui.actions.get('editLink').funct;\n      this.updateActionStates();\n      this.initClipboard();\n      this.initCanvas();\n      if (this.format != null) {\n        this.format.init();\n      }\n    }\n\n    /**\n     * Returns true if the given event should start editing. This implementation returns true.\n     */\n  }, {\n    key: \"isImmediateEditingEvent\",\n    value: function isImmediateEditingEvent(evt) {\n      return true;\n    }\n\n    /**\n     * Private helper method.\n     */\n  }, {\n    key: \"getCssClassForMarker\",\n    value: function getCssClassForMarker(prefix, shape, marker, fill) {\n      var result = '';\n      if (shape == 'flexArrow') {\n        result = marker != null && marker != _mxConstants[\"default\"].NONE ? 'geSprite geSprite-' + prefix + 'blocktrans' : 'geSprite geSprite-noarrow';\n      } else {\n        if (marker == _mxConstants[\"default\"].ARROW_CLASSIC) {\n          result = fill == '1' ? 'geSprite geSprite-' + prefix + 'classic' : 'geSprite geSprite-' + prefix + 'classictrans';\n        } else if (marker == _mxConstants[\"default\"].ARROW_CLASSIC_THIN) {\n          result = fill == '1' ? 'geSprite geSprite-' + prefix + 'classicthin' : 'geSprite geSprite-' + prefix + 'classicthintrans';\n        } else if (marker == _mxConstants[\"default\"].ARROW_OPEN) {\n          result = 'geSprite geSprite-' + prefix + 'open';\n        } else if (marker == _mxConstants[\"default\"].ARROW_OPEN_THIN) {\n          result = 'geSprite geSprite-' + prefix + 'openthin';\n        } else if (marker == _mxConstants[\"default\"].ARROW_BLOCK) {\n          result = fill == '1' ? 'geSprite geSprite-' + prefix + 'block' : 'geSprite geSprite-' + prefix + 'blocktrans';\n        } else if (marker == _mxConstants[\"default\"].ARROW_BLOCK_THIN) {\n          result = fill == '1' ? 'geSprite geSprite-' + prefix + 'blockthin' : 'geSprite geSprite-' + prefix + 'blockthintrans';\n        } else if (marker == _mxConstants[\"default\"].ARROW_OVAL) {\n          result = fill == '1' ? 'geSprite geSprite-' + prefix + 'oval' : 'geSprite geSprite-' + prefix + 'ovaltrans';\n        } else if (marker == _mxConstants[\"default\"].ARROW_DIAMOND) {\n          result = fill == '1' ? 'geSprite geSprite-' + prefix + 'diamond' : 'geSprite geSprite-' + prefix + 'diamondtrans';\n        } else if (marker == _mxConstants[\"default\"].ARROW_DIAMOND_THIN) {\n          result = fill == '1' ? 'geSprite geSprite-' + prefix + 'thindiamond' : 'geSprite geSprite-' + prefix + 'thindiamondtrans';\n        } else if (marker == 'openAsync') {\n          result = 'geSprite geSprite-' + prefix + 'openasync';\n        } else if (marker == 'dash') {\n          result = 'geSprite geSprite-' + prefix + 'dash';\n        } else if (marker == 'cross') {\n          result = 'geSprite geSprite-' + prefix + 'cross';\n        } else if (marker == 'async') {\n          result = fill == '1' ? 'geSprite geSprite-' + prefix + 'async' : 'geSprite geSprite-' + prefix + 'asynctrans';\n        } else if (marker == 'circle' || marker == 'circlePlus') {\n          result = fill == '1' || marker == 'circle' ? 'geSprite geSprite-' + prefix + 'circle' : 'geSprite geSprite-' + prefix + 'circleplus';\n        } else if (marker == 'ERone') {\n          result = 'geSprite geSprite-' + prefix + 'erone';\n        } else if (marker == 'ERmandOne') {\n          result = 'geSprite geSprite-' + prefix + 'eronetoone';\n        } else if (marker == 'ERmany') {\n          result = 'geSprite geSprite-' + prefix + 'ermany';\n        } else if (marker == 'ERoneToMany') {\n          result = 'geSprite geSprite-' + prefix + 'eronetomany';\n        } else if (marker == 'ERzeroToOne') {\n          result = 'geSprite geSprite-' + prefix + 'eroneopt';\n        } else if (marker == 'ERzeroToMany') {\n          result = 'geSprite geSprite-' + prefix + 'ermanyopt';\n        } else {\n          result = 'geSprite geSprite-noarrow';\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Overridden in Menus.js\n     */\n  }, {\n    key: \"createMenus\",\n    value: function createMenus() {\n      return new _Menus[\"default\"](this);\n    }\n\n    /**\n     * Hook for allowing selection and context menu for certain events.\n     */\n  }, {\n    key: \"updatePasteActionStates\",\n    value: function updatePasteActionStates() {\n      var graph = this.editor.graph;\n      var paste = this.actions.get('paste');\n      var pasteHere = this.actions.get('pasteHere');\n      paste.setEnabled(graph.isEnabled() && !graph.isCellLocked(graph.getDefaultParent()));\n      pasteHere.setEnabled(paste.isEnabled());\n    }\n\n    /**\n     * Hook for allowing selection and context menu for certain events.\n     */\n  }, {\n    key: \"initClipboard\",\n    value: function initClipboard() {\n      var ui = this;\n      var mxClipboardCut = _mxClipboard[\"default\"].cut;\n      _mxClipboard[\"default\"].cut = function (graph) {\n        if (graph.cellEditor.isContentEditing()) {\n          document.execCommand('cut', false, null);\n        } else {\n          mxClipboardCut.apply(this, arguments);\n        }\n        ui.updatePasteActionStates();\n      };\n      var context = ui.context;\n      var dispatch = context.dispatch;\n      var pageId = context.model.pageId;\n      var mxClipboardCopy = _mxClipboard[\"default\"].copy;\n      ui.clipboardCopy = function (graph) {\n        var cells = graph.getSelectionCells();\n        if (!cells || cells.length == 0) {\n          console && console.log && console.log(\"No cells, copy failed!\");\n          return;\n        }\n        if (!graph.isCellEditable(cells[0])) {\n          return;\n        }\n        var bpmnRoot = graph.getModel().getBPMNRoot();\n        if (cells.length == 1 && _mxGraphUtils[\"default\"].isBoundaryEvent(cells[0].type)) {\n          var action = {\n            p: [{\n              \"duration\": 3000,\n              \"type\": 2,\n              \"content\": (0, _intlApi.getLangMsg)({\n                key: \"WFEditorUi.copyLeafNodeTip\"\n              })\n            }],\n            a: _server.SHOW_NOTIFICATION_MESSAGE\n          };\n          (0, _action.doPostActions)(pageId, [action], dispatch);\n          return;\n        }\n        var copyOriginPageId = function copyOriginPageId(cell, originPageId) {\n          cell.setOriginPageId(originPageId);\n          if (cell.children) {\n            cell.children.forEach(function (child, index) {\n              copyOriginPageId(child, originPageId);\n            });\n          }\n        };\n        cells.forEach(function (cell, index) {\n          copyOriginPageId(cell, pageId);\n        });\n        if (graph.cellEditor.isContentEditing()) {\n          document.execCommand('copy', false, null);\n        } else {\n          mxClipboardCopy.apply(this, [graph, cells]);\n        }\n        ui.updatePasteActionStates();\n      };\n      var mxClipboardPaste = _mxClipboard[\"default\"].paste;\n      var formId = ui.props.config.formId;\n      var invokeAction = context.invokeAction;\n      var model = context.model;\n      ui.clipboardPaste = function (graph, paste) {\n        if (paste === true) {\n          var result = null;\n          if (graph.cellEditor.isContentEditing()) {\n            document.execCommand('paste', false, null);\n          } else {\n            result = mxClipboardPaste.apply(this, arguments);\n          }\n          ui.updatePasteActionStates();\n          return result;\n        } else {\n          var cells = graph.getImportableCells(_mxClipboard[\"default\"].getCells());\n          if (cells && cells.length) {\n            var cell = graph.getModel().getBPMNRoot().getChildAt(0);\n            if (cell && !graph.isCellEditable(cell)) {\n              return;\n            }\n            var jsons = ui.getCellsJson(cells, false);\n            var params = [formId, {\n              cells: JSON.stringify(jsons)\n            }];\n            invokeAction(model, _mxGraphConstant.EVENT.BEFORE_PASTE_CELLS, params);\n          }\n        }\n      };\n\n      // Overrides cell editor to update paste action state\n      var cellEditorStartEditing = this.editor.graph.cellEditor.startEditing;\n      this.editor.graph.cellEditor.startEditing = function () {\n        cellEditorStartEditing.apply(this, arguments);\n        ui.updatePasteActionStates();\n      };\n      var cellEditorStopEditing = this.editor.graph.cellEditor.stopEditing;\n      this.editor.graph.cellEditor.stopEditing = function (cell, trigger) {\n        cellEditorStopEditing.apply(this, arguments);\n        ui.updatePasteActionStates();\n      };\n      this.updatePasteActionStates();\n    }\n\n    /**\n     * Initializes the infinite canvas.\n     */\n  }, {\n    key: \"initCanvas\",\n    value: function initCanvas() {\n      var graph = this.editor.graph;\n\n      // Initial page layout view, scrollBuffer and timer-based scrolling\n      var graph = this.editor.graph;\n      graph.timerAutoScroll = true;\n\n      /**\n       * Specifies the size of the size for \"tiles\" to be used for a graph with\n       * scrollbars but no visible background page. A good value is large\n       * enough to reduce the number of repaints that is caused for auto-\n       * translation, which depends on this value, and small enough to give\n       * a small empty buffer around the graph. Default is 400x400.\n       */\n      graph.scrollTileSize = new _mxRectangle[\"default\"](0, 0, 400, 400);\n\n      /**\n       * Returns the padding for pages in page view with scrollbars.\n       */\n      graph.getPagePadding = function () {\n        return new _mxPoint[\"default\"](Math.max(0, Math.round((graph.container.offsetWidth - 34) / graph.view.scale)), Math.max(0, Math.round((graph.container.offsetHeight - 34) / graph.view.scale)));\n      };\n\n      /**\n       * Returns the size of the page format scaled with the page size.\n       */\n      graph.getPageSize = function () {\n        return this.pageVisible ? new _mxRectangle[\"default\"](0, 0, this.pageFormat.width * this.pageScale, this.pageFormat.height * this.pageScale) : this.scrollTileSize;\n      };\n\n      /**\n       * Returns a rectangle describing the position and count of the\n       * background pages, where x and y are the position of the top,\n       * left page and width and height are the vertical and horizontal\n       * page count.\n       */\n      graph.getPageLayout = function () {\n        var size = this.pageVisible ? this.getPageSize() : this.scrollTileSize;\n        var bounds = this.getGraphBounds();\n        if (bounds.width === 0 || bounds.height === 0) {\n          return new _mxRectangle[\"default\"](0, 0, 1, 1);\n        } else {\n          // Computes untransformed graph bounds\n          var x = Math.ceil(bounds.x / this.view.scale - this.view.translate.x);\n          var y = Math.ceil(bounds.y / this.view.scale - this.view.translate.y);\n          var w = Math.floor(bounds.width / this.view.scale);\n          var h = Math.floor(bounds.height / this.view.scale);\n          var x0 = Math.floor(x / size.width);\n          var y0 = Math.floor(y / size.height);\n          var w0 = Math.ceil((x + w) / size.width) - x0;\n          var h0 = Math.ceil((y + h) / size.height) - y0;\n          return new _mxRectangle[\"default\"](x0, y0, w0, h0);\n        }\n      };\n\n      // Fits the number of background pages to the graph\n      graph.view.getBackgroundPageBounds = function () {\n        var layout = this.graph.getPageLayout();\n        var page = this.graph.getPageSize();\n        return new _mxRectangle[\"default\"](this.scale * (this.translate.x + layout.x * page.width), this.scale * (this.translate.y + layout.y * page.height), this.scale * layout.width * page.width, this.scale * layout.height * page.height);\n      };\n      graph.getPreferredPageSize = function (bounds, width, height) {\n        var pages = this.getPageLayout();\n        var size = this.getPageSize();\n        return new _mxRectangle[\"default\"](0, 0, pages.width * size.width, pages.height * size.height);\n      };\n\n      // Scales pages/graph to fit available size\n      var resize = null;\n      if (this.editor.chromeless) {\n        resize = _mxGraphUtils[\"default\"].bind(this, function (autoscale) {\n          if (graph.container != null) {\n            var b = graph.pageVisible ? graph.view.getBackgroundPageBounds() : graph.getGraphBounds();\n            var tr = graph.view.translate;\n            var s = graph.view.scale;\n\n            // Normalizes the bounds\n            b = _mxRectangle[\"default\"].fromRectangle(b);\n            b.x = b.x / s - tr.x;\n            b.y = b.y / s - tr.y;\n            b.width /= s;\n            b.height /= s;\n            var st = graph.container.scrollTop;\n            var sl = graph.container.scrollLeft;\n            var sb = _mxClient[\"default\"].IS_QUIRKS || document.documentMode >= 8 ? 20 : 14;\n            if (document.documentMode == 8 || document.documentMode == 9) {\n              sb += 3;\n            }\n            var cw = graph.container.offsetWidth - sb;\n            var ch = graph.container.offsetHeight - sb;\n            var ns = autoscale ? Math.max(0.3, Math.min(1, cw / b.width)) : s;\n            var dx = Math.max((cw - ns * b.width) / 2, 0) / ns;\n            var dy = Math.max((ch - ns * b.height) / 4, 0) / ns;\n            graph.view.scaleAndTranslate(ns, dx - b.x, dy - b.y);\n            graph.container.scrollTop = st * ns / s;\n            graph.container.scrollLeft = sl * ns / s;\n          }\n        });\n\n        // Hack to make function available to subclassers\n        this.chromelessResize = resize;\n\n        // Removable resize listener\n        var autoscaleResize = _mxGraphUtils[\"default\"].bind(this, function () {\n          resize(false);\n        });\n        _mxEvent[\"default\"].addListener(window, 'resize', autoscaleResize);\n        this.destroyFunctions.push(function () {\n          _mxEvent[\"default\"].removeListener(window, 'resize', autoscaleResize);\n        });\n        this.editor.addListener('resetGraphView', _mxGraphUtils[\"default\"].bind(this, function () {\n          resize(true);\n        }));\n        this.actions.get('zoomIn').funct = function (evt) {\n          graph.zoomIn();\n          resize(false);\n        };\n        this.actions.get('zoomOut').funct = function (evt) {\n          graph.zoomOut();\n          resize(false);\n        };\n\n        // Creates toolbar for viewer - do not use CSS here\n        // as this may be used in a viewer that has no CSS\n        this.chromelessToolbar = document.createElement('div');\n        this.chromelessToolbar.style.position = 'fixed';\n        this.chromelessToolbar.style.overflow = 'hidden';\n        this.chromelessToolbar.style.boxSizing = 'border-box';\n        this.chromelessToolbar.style.whiteSpace = 'nowrap';\n        this.chromelessToolbar.style.backgroundColor = '#000000';\n        this.chromelessToolbar.style.padding = '10px 10px 8px 10px';\n        this.chromelessToolbar.style.left = '50%';\n        _mxUtils[\"default\"].setPrefixedStyle(this.chromelessToolbar.style, 'borderRadius', '20px');\n        _mxUtils[\"default\"].setPrefixedStyle(this.chromelessToolbar.style, 'transition', 'opacity 600ms ease-in-out');\n        var updateChromelessToolbarPosition = _mxGraphUtils[\"default\"].bind(this, function () {\n          var css = _mxUtils[\"default\"].getCurrentStyle(graph.container);\n          this.chromelessToolbar.style.bottom = (css != null ? parseInt(css['margin-bottom'] || 0) : 0) + '20px';\n        });\n        this.editor.addListener('resetGraphView', updateChromelessToolbarPosition);\n        updateChromelessToolbarPosition();\n        var btnCount = 0;\n        var addButton = _mxGraphUtils[\"default\"].bind(this, function (fn, imgSrc, tip) {\n          btnCount++;\n          var a = document.createElement('span');\n          a.style.paddingLeft = '8px';\n          a.style.paddingRight = '8px';\n          a.style.cursor = 'pointer';\n          _mxEvent[\"default\"].addListener(a, 'click', fn);\n          if (tip != null) {\n            a.setAttribute('title', tip);\n          }\n          var img = document.createElement('img');\n          img.setAttribute('border', '0');\n          img.setAttribute('src', imgSrc);\n          a.appendChild(img);\n          this.chromelessToolbar.appendChild(a);\n          return a;\n        });\n        addButton(_mxGraphUtils[\"default\"].bind(this, function (evt) {\n          this.actions.get('zoomOut').funct();\n          _mxEvent[\"default\"].consume(evt);\n        }), _Editor[\"default\"].zoomOutLargeImage, (_mxResources[\"default\"].get('zoomOut') || 'Zoom Out') + ' (Alt+Mousewheel)');\n        addButton(_mxGraphUtils[\"default\"].bind(this, function (evt) {\n          this.actions.get('zoomIn').funct();\n          _mxEvent[\"default\"].consume(evt);\n        }), _Editor[\"default\"].zoomInLargeImage, (_mxResources[\"default\"].get('zoomIn') || 'Zoom In') + ' (Alt+Mousewheel)');\n        addButton(_mxGraphUtils[\"default\"].bind(this, function (evt) {\n          if (graph.lightbox) {\n            if (graph.view.scale == 1) {\n              this.lightboxFit();\n            } else {\n              graph.zoomTo(1);\n            }\n            resize(false);\n          } else {\n            resize(true);\n          }\n          _mxEvent[\"default\"].consume(evt);\n        }), _Editor[\"default\"].actualSizeLargeImage, _mxResources[\"default\"].get('fit') || 'Fit');\n\n        // Changes toolbar opacity on hover\n        var fadeThread = null;\n        var fadeThread2 = null;\n        var fadeOut = _mxGraphUtils[\"default\"].bind(this, function (delay) {\n          if (fadeThread != null) {\n            window.clearTimeout(fadeThread);\n            fadeThead = null;\n          }\n          if (fadeThread2 != null) {\n            window.clearTimeout(fadeThread2);\n            fadeThead2 = null;\n          }\n          fadeThread = window.setTimeout(_mxGraphUtils[\"default\"].bind(this, function () {\n            _mxUtils[\"default\"].setOpacity(this.chromelessToolbar, 0);\n            fadeThread = null;\n            fadeThread2 = window.setTimeout(_mxGraphUtils[\"default\"].bind(this, function () {\n              this.chromelessToolbar.style.display = 'none';\n              fadeThread2 = null;\n            }), 600);\n          }), delay || 200);\n        });\n        var fadeIn = _mxGraphUtils[\"default\"].bind(this, function (opacity) {\n          if (fadeThread != null) {\n            window.clearTimeout(fadeThread);\n            fadeThead = null;\n          }\n          if (fadeThread2 != null) {\n            window.clearTimeout(fadeThread2);\n            fadeThead2 = null;\n          }\n          this.chromelessToolbar.style.display = '';\n          _mxUtils[\"default\"].setOpacity(this.chromelessToolbar, opacity || 30);\n        });\n        if (urlParams['layers'] == '1') {\n          this.layersDialog = null;\n          var layersButton = addButton(_mxGraphUtils[\"default\"].bind(this, function (evt) {\n            if (this.layersDialog != null) {\n              this.layersDialog.parentNode.removeChild(this.layersDialog);\n              this.layersDialog = null;\n            } else {\n              this.layersDialog = graph.createLayersDialog();\n              _mxEvent[\"default\"].addListener(this.layersDialog, 'mouseleave', _mxGraphUtils[\"default\"].bind(this, function () {\n                this.layersDialog.parentNode.removeChild(this.layersDialog);\n                this.layersDialog = null;\n              }));\n              var r = layersButton.getBoundingClientRect();\n              _mxUtils[\"default\"].setPrefixedStyle(this.layersDialog.style, 'borderRadius', '5px');\n              this.layersDialog.style.position = 'fixed';\n              this.layersDialog.style.backgroundColor = '#000000';\n              this.layersDialog.style.width = '160px';\n              this.layersDialog.style.padding = '4px 2px 4px 2px';\n              this.layersDialog.style.color = '#ffffff';\n              _mxUtils[\"default\"].setOpacity(this.layersDialog, 70);\n              this.layersDialog.style.left = r.left + 'px';\n              this.layersDialog.style.bottom = parseInt(this.chromelessToolbar.style.bottom) + this.chromelessToolbar.offsetHeight + 4 + 'px';\n\n              // Puts the dialog on top of the container z-index\n              var style = _mxUtils[\"default\"].getCurrentStyle(this.editor.graph.container);\n              this.layersDialog.style.zIndex = style.zIndex;\n              document.body.appendChild(this.layersDialog);\n            }\n            _mxEvent[\"default\"].consume(evt);\n          }), _Editor[\"default\"].layersLargeImage, _mxResources[\"default\"].get('layers') || 'Layers');\n\n          // Shows/hides layers button depending on content\n          var model = graph.getModel();\n          model.addListener(_mxEvent[\"default\"].CHANGE, function () {\n            layersButton.style.display = model.getChildCount(model.root) > 1 ? '' : 'none';\n          });\n        }\n        if (_mxGraphConstant.EDITORUI.editButtonLink != null) {\n          addButton(_mxGraphUtils[\"default\"].bind(this, function (evt) {\n            if (_mxGraphConstant.EDITORUI.editButtonLink == '_blank') {\n              this.editor.editAsNew(this.getEditBlankXml(), null, true);\n            } else {\n              window.open(_mxGraphConstant.EDITORUI.editButtonLink, 'editWindow');\n            }\n            _mxEvent[\"default\"].consume(evt);\n          }), _Editor[\"default\"].editLargeImage, _mxResources[\"default\"].get('openInNewWindow') || 'Open in New Window');\n        }\n        if (graph.lightbox && this.container != document.body) {\n          addButton(_mxGraphUtils[\"default\"].bind(this, function (evt) {\n            if (urlParams['close'] == '1') {\n              window.close();\n            } else {\n              this.destroy();\n              _mxEvent[\"default\"].consume(evt);\n            }\n          }), _Editor[\"default\"].closeLargeImage, (_mxResources[\"default\"].get('close') || 'Close') + ' (Escape)');\n        }\n\n        // Initial state invisible\n        this.chromelessToolbar.style.display = 'none';\n        graph.container.appendChild(this.chromelessToolbar);\n        this.chromelessToolbar.style.marginLeft = -(btnCount * 24 + 10) + 'px';\n\n        // Installs handling of hightligh and handling links to relative links and anchors\n        this.addChromelessClickHandler();\n        _mxEvent[\"default\"].addListener(graph.container, _mxClient[\"default\"].IS_POINTER ? 'pointermove' : 'mousemove', _mxGraphUtils[\"default\"].bind(this, function (evt) {\n          if (!_mxEvent[\"default\"].isTouchEvent(evt)) {\n            if (!_mxEvent[\"default\"].isShiftDown(evt)) {\n              fadeIn(30);\n            }\n            fadeOut();\n          }\n        }));\n        _mxEvent[\"default\"].addListener(this.chromelessToolbar, _mxClient[\"default\"].IS_POINTER ? 'pointermove' : 'mousemove', function (evt) {\n          _mxEvent[\"default\"].consume(evt);\n        });\n        _mxEvent[\"default\"].addListener(this.chromelessToolbar, 'mouseenter', _mxGraphUtils[\"default\"].bind(this, function (evt) {\n          if (!_mxEvent[\"default\"].isShiftDown(evt)) {\n            fadeIn(100);\n          } else {\n            fadeOut();\n          }\n        }));\n        _mxEvent[\"default\"].addListener(this.chromelessToolbar, 'mousemove', _mxGraphUtils[\"default\"].bind(this, function (evt) {\n          if (!_mxEvent[\"default\"].isShiftDown(evt)) {\n            fadeIn(100);\n          } else {\n            fadeOut();\n          }\n          _mxEvent[\"default\"].consume(evt);\n        }));\n        _mxEvent[\"default\"].addListener(this.chromelessToolbar, 'mouseleave', _mxGraphUtils[\"default\"].bind(this, function (evt) {\n          if (!_mxEvent[\"default\"].isTouchEvent(evt)) {\n            fadeIn(30);\n          }\n        }));\n\n        // Shows/hides toolbar for touch devices\n        var tol = graph.getTolerance();\n        var ui = this;\n        graph.addMouseListener({\n          startX: 0,\n          startY: 0,\n          scrollLeft: 0,\n          scrollTop: 0,\n          mouseDown: function mouseDown(sender, me) {\n            this.startX = me.getGraphX();\n            this.startY = me.getGraphY();\n            this.scrollLeft = graph.container.scrollLeft;\n            this.scrollTop = graph.container.scrollTop;\n          },\n          mouseMove: function mouseMove(sender, me) {},\n          mouseUp: function mouseUp(sender, me) {\n            if (_mxEvent[\"default\"].isTouchEvent(me.getEvent())) {\n              if (Math.abs(this.scrollLeft - graph.container.scrollLeft) < tol && Math.abs(this.scrollTop - graph.container.scrollTop) < tol && Math.abs(this.startX - me.getGraphX()) < tol && Math.abs(this.startY - me.getGraphY()) < tol) {\n                if (parseFloat(ui.chromelessToolbar.style.opacity || 0) > 0) {\n                  fadeOut();\n                } else {\n                  fadeIn(30);\n                }\n              }\n            }\n          }\n        });\n      } else if (this.editor.extendCanvas) {\n        /**\n         * Guesses autoTranslate to avoid another repaint (see below).\n         * Works if only the scale of the graph changes or if pages\n         * are visible and the visible pages do not change.\n         */\n        //查看流程图有审批记录时子流程展开位置会偏移\n        /*var graphViewValidate = graph.view.validate;\n        graph.view.validate = function()\n        {\n            if (this.graph.container != null && mxUtils.hasScrollbars(this.graph.container))\n            {\n                var pad = this.graph.getPagePadding();\n                var size = this.graph.getPageSize();\n                 // Updating scrollbars here causes flickering in quirks and is not needed\n                // if zoom method is always used to set the current scale on the graph.\n                var tx = this.translate.x;\n                var ty = this.translate.y;\n                this.translate.x = pad.x - (this.x0 || 0) * size.width;\n                this.translate.y = pad.y - (this.y0 || 0) * size.height;\n            }\n             graphViewValidate.apply(this, arguments);\n        };*/\n\n        var graphSizeDidChange = graph.sizeDidChange;\n        graph.sizeDidChange = function (validate, editorUi) {\n          var container = this.container;\n          if (container && !(container.offsetWidth === 0 && container.offsetHeight === 0) && _mxUtils[\"default\"].hasScrollbars(this.container)) {\n            var pages = this.getPageLayout();\n            var pad = this.getPagePadding();\n            var size = this.getPageSize();\n\n            // Updates the minimum graph size\n            var minw = Math.ceil(2 * pad.x + pages.width * size.width);\n            var minh = Math.ceil(2 * pad.y + pages.height * size.height);\n            var min = graph.minimumGraphSize;\n\n            // LATER: Fix flicker of scrollbar size in IE quirks mode\n            // after delayed call in window.resize event handler\n            if (min == null || min.width != minw || min.height != minh) {\n              graph.minimumGraphSize = new _mxRectangle[\"default\"](0, 0, minw, minh);\n            }\n\n            // Updates auto-translate to include padding and graph size\n            var dx = pad.x - pages.x * size.width;\n            var dy = pad.y - pages.y * size.height;\n            if (!this.autoTranslate && (this.view.translate.x != dx || this.view.translate.y != dy)) {\n              this.autoTranslate = true;\n              this.view.x0 = pages.x;\n              this.view.y0 = pages.y;\n\n              // NOTE: THIS INVOKES THIS METHOD AGAIN. UNFORTUNATELY THERE IS NO WAY AROUND THIS SINCE THE\n              // BOUNDS ARE KNOWN AFTER THE VALIDATION AND SETTING THE TRANSLATE TRIGGERS A REVALIDATION.\n              // SHOULD MOVE TRANSLATE/SCALE TO VIEW.\n              var tx = graph.view.translate.x;\n              var ty = graph.view.translate.y;\n              graph.view.setTranslate(dx, dy, validate);\n\n              // LATER: Fix rounding errors for small zoom\n              //graph.container.scrollLeft += Math.round((dx - tx) * graph.view.scale);\n              //graph.container.scrollTop += Math.round((dy - ty) * graph.view.scale);\n\n              //查看流程图当前节点\n              var currentCell = null;\n              var currentCellId = null;\n              if (editorUi && editorUi.state.initialData && (currentCellId = editorUi.state.initialData.currentCellId)) {\n                currentCell = currentCellId && this.getModel().getCell(currentCellId);\n              }\n              var bounds = currentCell && currentCell.vertex ? this.getCellBounds(currentCell) : this.getGraphBounds();\n              container.scrollLeft = bounds.x + bounds.width / 2 - container.clientWidth / 2;\n              container.scrollTop = bounds.y + bounds.height / 2 - container.clientHeight / 2;\n              this.autoTranslate = false;\n              return;\n            } else {\n              graphSizeDidChange.apply(this, arguments);\n            }\n          }\n        };\n      }\n\n      // Accumulates the zoom factor while the rendering is taking place\n      // so that not the complete sequence of zoom steps must be painted\n      graph.updateZoomTimeout = null;\n      graph.cumulativeZoomFactor = 1;\n      var cursorPosition = null;\n      graph.lazyZoom = function (zoomIn) {\n        if (this.updateZoomTimeout != null) {\n          window.clearTimeout(this.updateZoomTimeout);\n        }\n\n        // Switches to 1% zoom steps below 15%\n        // Lower bound depdends on rounding below\n        if (zoomIn) {\n          if (this.view.scale * this.cumulativeZoomFactor < 0.15) {\n            this.cumulativeZoomFactor = (this.view.scale + 0.01) / this.view.scale;\n          } else {\n            // Uses to 5% zoom steps for better grid rendering in webkit\n            // and to avoid rounding errors for zoom steps\n            this.cumulativeZoomFactor *= this.zoomFactor;\n            this.cumulativeZoomFactor = Math.round(this.view.scale * this.cumulativeZoomFactor * 20) / 20 / this.view.scale;\n          }\n        } else {\n          if (this.view.scale * this.cumulativeZoomFactor <= 0.15) {\n            this.cumulativeZoomFactor = (this.view.scale - 0.01) / this.view.scale;\n          } else {\n            // Uses to 5% zoom steps for better grid rendering in webkit\n            // and to avoid rounding errors for zoom steps\n            this.cumulativeZoomFactor /= this.zoomFactor;\n            this.cumulativeZoomFactor = Math.round(this.view.scale * this.cumulativeZoomFactor * 20) / 20 / this.view.scale;\n          }\n        }\n        this.cumulativeZoomFactor = Math.max(0.01, Math.min(this.view.scale * this.cumulativeZoomFactor, 160) / this.view.scale);\n        this.updateZoomTimeout = window.setTimeout(_mxGraphUtils[\"default\"].bind(this, function () {\n          this.zoom(this.cumulativeZoomFactor);\n          if (resize != null) {\n            resize(false);\n          }\n\n          // Zooms to mouse position if scrollbars enabled\n          if (cursorPosition != null && _mxUtils[\"default\"].hasScrollbars(graph.container)) {\n            var offset = _mxUtils[\"default\"].getOffset(graph.container);\n            var dx = graph.container.offsetWidth / 2 - cursorPosition.x + offset.x;\n            var dy = graph.container.offsetHeight / 2 - cursorPosition.y + offset.y;\n            graph.container.scrollLeft -= dx * (this.cumulativeZoomFactor - 1);\n            graph.container.scrollTop -= dy * (this.cumulativeZoomFactor - 1);\n          }\n          this.cumulativeZoomFactor = 1;\n          this.updateZoomTimeout = null;\n        }), 20);\n      };\n      _mxEvent[\"default\"].addMouseWheelListener(_mxGraphUtils[\"default\"].bind(this, function (evt, up) {\n        // Ctrl+wheel (or pinch on touchpad) is a native browser zoom event is OS X\n        // LATER: Add support for zoom via pinch on trackpad for Chrome in OS X\n        if ((_mxEvent[\"default\"].isAltDown(evt) || _mxEvent[\"default\"].isControlDown(evt) && !_mxClient[\"default\"].IS_MAC || graph.panningHandler.isActive()) && (this.dialogs == null || this.dialogs.length === 0)) {\n          var source = _mxEvent[\"default\"].getSource(evt);\n          while (source != null) {\n            if (source == graph.container) {\n              cursorPosition = new _mxPoint[\"default\"](_mxEvent[\"default\"].getClientX(evt), _mxEvent[\"default\"].getClientY(evt));\n              graph.lazyZoom(up);\n              _mxEvent[\"default\"].consume(evt);\n              return;\n            }\n            source = source.parentNode;\n          }\n        }\n      }));\n    }\n\n    /**\n     *\n     */\n  }, {\n    key: \"addChromelessClickHandler\",\n    value: function addChromelessClickHandler() {\n      var hl = urlParams['highlight'];\n\n      // Adds leading # for highlight color code\n      if (hl != null && hl.length > 0) {\n        hl = '#' + hl;\n      }\n      this.editor.graph.addClickHandler(hl);\n    }\n\n    /**\n     *\n     */\n  }, {\n    key: \"toggleFormatPanel\",\n    value: function toggleFormatPanel(forceHide) {\n      this.formatWidth = forceHide || _mxGraphConstant.EDITORUI.formatWidth > 0 ? 0 : 240;\n      this.formatContainer.style.display = forceHide || this.formatWidth > 0 ? '' : 'none';\n      this.refresh();\n      this.format.refresh();\n      this.fireEvent(new _mxEventObject[\"default\"]('formatWidthChanged'));\n    }\n\n    /**\n     * Adds support for placeholders in labels.\n     */\n  }, {\n    key: \"lightboxFit\",\n    value: function lightboxFit() {\n      // LATER: Use initial graph bounds to avoid rounding errors\n      this.editor.graph.maxFitScale = 2;\n      this.editor.graph.fit(20);\n      this.editor.graph.maxFitScale = null;\n    }\n\n    /**\n     * Hook for allowing selection and context menu for certain events.\n     */\n  }, {\n    key: \"isSelectionAllowed\",\n    value: function isSelectionAllowed(evt) {\n      return _mxEvent[\"default\"].getSource(evt).nodeName == 'SELECT' || _mxEvent[\"default\"].getSource(evt).nodeName == 'INPUT' && _mxUtils[\"default\"].isAncestorNode(this.formatContainer, _mxEvent[\"default\"].getSource(evt));\n    }\n\n    /**\n     * Installs dialog if browser window is closed without saving\n     * This must be disabled during save and image export.\n     */\n  }, {\n    key: \"addBeforeUnloadListener\",\n    value: function addBeforeUnloadListener() {\n      // Installs dialog if browser window is closed without saving\n      // This must be disabled during save and image export\n      /*window.onbeforeunload = mxGraphUtils.bind(this, function()\n      {\n          return this.onBeforeUnload();\n      });*/\n    }\n\n    /**\n     * Sets the onbeforeunload for the application\n     */\n  }, {\n    key: \"onBeforeUnload\",\n    value: function onBeforeUnload() {\n      if (this.editor.modified) {\n        return _mxResources[\"default\"].get('allChangesLost');\n      }\n    }\n\n    /**\n     * Sets the current menu and element.\n     */\n  }, {\n    key: \"setCurrentMenu\",\n    value: function setCurrentMenu(menu, elt) {\n      this.currentMenuElt = elt;\n      this.currentMenu = menu;\n    }\n\n    /**\n     * Resets the current menu and element.\n     */\n  }, {\n    key: \"resetCurrentMenu\",\n    value: function resetCurrentMenu() {\n      this.currentMenuElt = null;\n      this.currentMenu = null;\n    }\n\n    /**\n     * Hides and destroys the current menu.\n     */\n  }, {\n    key: \"hideCurrentMenu\",\n    value: function hideCurrentMenu(menu, elt) {\n      if (this.currentMenu != null) {\n        this.currentMenu.hideMenu();\n        this.resetCurrentMenu();\n      }\n    }\n\n    /**\n     * Updates the document title.\n     */\n  }, {\n    key: \"updateDocumentTitle\",\n    value: function updateDocumentTitle() {\n      var title = this.editor.getOrCreateFilename();\n      if (this.editor.appName != null) {\n        title += ' - ' + this.editor.appName;\n      }\n      document.title = title;\n    }\n\n    /**\n     * Updates the document title.\n     */\n  }, {\n    key: \"createHoverIcons\",\n    value: function createHoverIcons() {\n      return new _HoverIcons[\"default\"](this.editor.graph);\n    }\n\n    /**\n     * Returns the URL for a copy of this editor with no state.\n     */\n  }, {\n    key: \"redo\",\n    value: function redo() {\n      try {\n        var graph = this.editor.graph;\n        if (graph.isEditing()) {\n          document.execCommand('redo', false, null);\n        } else {\n          this.editor.undoManager.redo();\n        }\n      } catch (e) {\n        // ignore all errors\n      }\n    }\n\n    /**\n     * Returns the URL for a copy of this editor with no state.\n     */\n  }, {\n    key: \"undo\",\n    value: function undo() {\n      try {\n        var graph = this.editor.graph;\n        if (graph.isEditing()) {\n          // Stops editing and executes undo on graph if native undo\n          // does not affect current editing value\n          var value = graph.cellEditor.textarea.innerHTML;\n          document.execCommand('undo', false, null);\n          if (value == graph.cellEditor.textarea.innerHTML) {\n            graph.stopEditing(true);\n            this.editor.undoManager.undo();\n          }\n        } else {\n          this.editor.undoManager.undo();\n        }\n      } catch (e) {\n        // ignore all errors\n      }\n    }\n\n    /**\n     * Returns the URL for a copy of this editor with no state.\n     */\n  }, {\n    key: \"canRedo\",\n    value: function canRedo() {\n      return this.editor.graph.isEditing() || this.editor.undoManager.canRedo();\n    }\n\n    /**\n     * Returns the URL for a copy of this editor with no state.\n     */\n  }, {\n    key: \"canUndo\",\n    value: function canUndo() {\n      return this.editor.graph.isEditing() || this.editor.undoManager.canUndo();\n    }\n\n    /**\n     *\n     */\n  }, {\n    key: \"getEditBlankXml\",\n    value: function getEditBlankXml() {\n      return _mxUtils[\"default\"].getXml(this.getGraphXml());\n    }\n\n    /**\n     * Returns the URL for a copy of this editor with no state.\n     */\n  }, {\n    key: \"getUrl\",\n    value: function getUrl(pathname) {\n      var href = pathname != null ? pathname : window.location.pathname;\n      var parms = href.indexOf('?') > 0 ? 1 : 0;\n\n      // Removes template URL parameter for new blank diagram\n      for (var key in urlParams) {\n        if (parms === 0) {\n          href += '?';\n        } else {\n          href += '&';\n        }\n        href += key + '=' + urlParams[key];\n        parms++;\n      }\n      return href;\n    }\n\n    /**\n     * Specifies if the graph has scrollbars.\n     */\n  }, {\n    key: \"setScrollbars\",\n    value: function setScrollbars(value) {\n      var graph = this.editor.graph;\n      var prev = graph.container.style.overflow;\n      graph.scrollbars = value;\n      this.editor.updateGraphComponents();\n      if (prev != graph.container.style.overflow) {\n        if (graph.container.style.overflow == 'hidden') {\n          var t = graph.view.translate;\n          graph.view.setTranslate(t.x - graph.container.scrollLeft / graph.view.scale, t.y - graph.container.scrollTop / graph.view.scale);\n          graph.container.scrollLeft = 0;\n          graph.container.scrollTop = 0;\n          graph.minimumGraphSize = null;\n          graph.sizeDidChange();\n        } else {\n          var dx = graph.view.translate.x;\n          var dy = graph.view.translate.y;\n          graph.view.translate.x = 0;\n          graph.view.translate.y = 0;\n          graph.sizeDidChange();\n          graph.container.scrollLeft -= Math.round(dx * graph.view.scale);\n          graph.container.scrollTop -= Math.round(dy * graph.view.scale);\n        }\n      }\n      this.fireEvent(new _mxEventObject[\"default\"]('scrollbarsChanged'));\n    }\n\n    /**\n     * Returns true if the graph has scrollbars.\n     */\n  }, {\n    key: \"hasScrollbars\",\n    value: function hasScrollbars() {\n      return this.editor.graph.scrollbars;\n    }\n\n    /**\n     * Resets the state of the scrollbars.\n     */\n  }, {\n    key: \"resetScrollbars\",\n    value: function resetScrollbars() {\n      var graph = this.editor.graph;\n      if (!this.editor.extendCanvas) {\n        graph.container.scrollTop = 0;\n        graph.container.scrollLeft = 0;\n        if (!_mxUtils[\"default\"].hasScrollbars(graph.container)) {\n          graph.view.setTranslate(0, 0);\n        }\n      } else if (!this.editor.chromeless) {\n        if (_mxUtils[\"default\"].hasScrollbars(graph.container)) {\n          if (graph.pageVisible) {\n            var pad = graph.getPagePadding();\n            graph.container.scrollTop = Math.floor(pad.y - this.editor.initialTopSpacing);\n            graph.container.scrollLeft = Math.floor(Math.min(pad.x, (graph.container.scrollWidth - graph.container.clientWidth) / 2));\n          } else {\n            var bounds = graph.getGraphBounds();\n            var width = Math.max(bounds.width, graph.scrollTileSize.width * graph.view.scale);\n            var height = Math.max(bounds.height, graph.scrollTileSize.height * graph.view.scale);\n            graph.container.scrollTop = Math.floor(Math.max(0, bounds.y - Math.max(20, (graph.container.clientHeight - height) / 4)));\n            graph.container.scrollLeft = Math.floor(Math.max(0, bounds.x - Math.max(0, (graph.container.clientWidth - width) / 2)));\n          }\n        } else {\n          // This code is not actively used since the default for scrollbars is always true\n          if (graph.pageVisible) {\n            var b = graph.view.getBackgroundPageBounds();\n            graph.view.setTranslate(Math.floor(Math.max(0, (graph.container.clientWidth - b.width) / 2) - b.x), Math.floor(Math.max(0, (graph.container.clientHeight - b.height) / 2) - b.y));\n          } else {\n            var bounds = graph.getGraphBounds();\n            graph.view.setTranslate(Math.floor(Math.max(0, Math.max(0, (graph.container.clientWidth - bounds.width) / 2) - bounds.x)), Math.floor(Math.max(0, Math.max(20, (graph.container.clientHeight - bounds.height) / 4)) - bounds.y));\n          }\n        }\n      }\n    }\n\n    /**\n     * Loads the stylesheet for this graph.\n     */\n  }, {\n    key: \"setBackgroundColor\",\n    value: function setBackgroundColor(value) {\n      this.editor.graph.background = value;\n      this.editor.graph.view.validateBackground();\n      this.fireEvent(new _mxEventObject[\"default\"]('backgroundColorChanged'));\n    }\n\n    /**\n     * Loads the stylesheet for this graph.\n     */\n  }, {\n    key: \"setFoldingEnabled\",\n    value: function setFoldingEnabled(value) {\n      this.editor.graph.foldingEnabled = value;\n      this.editor.graph.view.revalidate();\n      this.fireEvent(new _mxEventObject[\"default\"]('foldingEnabledChanged'));\n    }\n\n    /**\n     * Loads the stylesheet for this graph.\n     */\n  }, {\n    key: \"setPageFormat\",\n    value: function setPageFormat(value) {\n      this.editor.graph.pageFormat = value;\n      if (!this.editor.graph.pageVisible) {\n        this.actions.get('pageView').funct();\n      } else {\n        this.editor.graph.view.validateBackground();\n        this.editor.graph.sizeDidChange();\n      }\n      this.fireEvent(new _mxEventObject[\"default\"]('pageFormatChanged'));\n    }\n\n    /**\n     * Loads the stylesheet for this graph.\n     */\n  }, {\n    key: \"setPageScale\",\n    value: function setPageScale(value) {\n      this.editor.graph.pageScale = value;\n      if (!this.editor.graph.pageVisible) {\n        this.actions.get('pageView').funct();\n      } else {\n        this.editor.graph.view.validateBackground();\n        this.editor.graph.sizeDidChange();\n      }\n      this.fireEvent(new _mxEventObject[\"default\"]('pageScaleChanged'));\n    }\n\n    /**\n     * Loads the stylesheet for this graph.\n     */\n  }, {\n    key: \"setGridColor\",\n    value: function setGridColor(value) {\n      this.editor.graph.view.gridColor = value;\n      this.editor.graph.view.validateBackground();\n      this.fireEvent(new _mxEventObject[\"default\"]('gridColorChanged'));\n    }\n\n    /**\n     * Updates the states of the given undo/redo items.\n     */\n  }, {\n    key: \"addUndoListener\",\n    value: function addUndoListener() {\n      var undo = this.actions.get('undo');\n      var redo = this.actions.get('redo');\n      var undoMgr = this.editor.undoManager;\n      var undoListener = _mxGraphUtils[\"default\"].bind(this, function () {\n        undo.setEnabled(this.canUndo());\n        redo.setEnabled(this.canRedo());\n      });\n      undoMgr.addListener(_mxEvent[\"default\"].ADD, undoListener);\n      undoMgr.addListener(_mxEvent[\"default\"].UNDO, undoListener);\n      undoMgr.addListener(_mxEvent[\"default\"].REDO, undoListener);\n      undoMgr.addListener(_mxEvent[\"default\"].CLEAR, undoListener);\n\n      // Overrides cell editor to update action states\n      var cellEditorStartEditing = this.editor.graph.cellEditor.startEditing;\n      this.editor.graph.cellEditor.startEditing = function () {\n        cellEditorStartEditing.apply(this, arguments);\n        undoListener();\n      };\n      var cellEditorStopEditing = this.editor.graph.cellEditor.stopEditing;\n      this.editor.graph.cellEditor.stopEditing = function (cell, trigger) {\n        cellEditorStopEditing.apply(this, arguments);\n        undoListener();\n      };\n\n      // Updates the button states once\n      undoListener();\n    }\n\n    /**\n    * Updates the states of the given toolbar items based on the selection.\n    */\n  }, {\n    key: \"updateActionStates\",\n    value: function updateActionStates() {\n      var graph = this.editor.graph;\n      var selected = !graph.isSelectionEmpty();\n      var vertexSelected = false;\n      var edgeSelected = false;\n      var cells = graph.getSelectionCells();\n      if (cells != null) {\n        for (var i = 0; i < cells.length; i++) {\n          var cell = cells[i];\n          if (graph.getModel().isEdge(cell)) {\n            edgeSelected = true;\n          }\n          if (graph.getModel().isVertex(cell)) {\n            vertexSelected = true;\n          }\n          if (edgeSelected && vertexSelected) {\n            break;\n          }\n        }\n      }\n\n      // Updates action states\n      var actions = ['cut', 'copy', 'bold', 'italic', 'underline', 'delete', 'duplicate', 'editStyle', 'editTooltip', 'editLink', 'backgroundColor', 'borderColor', 'toFront', 'toBack', 'lockUnlock', 'solid', 'dashed', 'dotted', 'fillColor', 'gradientColor', 'shadow', 'fontColor', 'formattedText', 'rounded', 'toggleRounded', 'sharp', 'strokeColor'];\n      for (var i = 0; i < actions.length; i++) {\n        this.actions.get(actions[i]).setEnabled(selected);\n      }\n      this.actions.get('setAsDefaultStyle').setEnabled(graph.getSelectionCount() == 1);\n      this.actions.get('turn').setEnabled(!graph.isSelectionEmpty());\n      this.actions.get('curved').setEnabled(edgeSelected);\n      this.actions.get('clearWaypoints').setEnabled(edgeSelected);\n      this.actions.get('rotation').setEnabled(vertexSelected);\n      this.actions.get('wordWrap').setEnabled(vertexSelected);\n      this.actions.get('autosize').setEnabled(vertexSelected);\n      this.actions.get('collapsible').setEnabled(vertexSelected);\n      var oneVertexSelected = vertexSelected && graph.getSelectionCount() == 1;\n      this.actions.get('group').setEnabled(graph.getSelectionCount() > 1 || oneVertexSelected && !graph.isContainer(graph.getSelectionCell()));\n      this.actions.get('ungroup').setEnabled(graph.getSelectionCount() == 1 && (graph.getModel().getChildCount(graph.getSelectionCell()) > 0 || oneVertexSelected && graph.isContainer(graph.getSelectionCell())));\n      this.actions.get('removeFromGroup').setEnabled(oneVertexSelected && graph.getModel().isVertex(graph.getModel().getParent(graph.getSelectionCell())));\n\n      // Updates menu states\n      var state = graph.view.getState(graph.getSelectionCell());\n      this.menus.get('navigation').setEnabled(selected || graph.view.currentRoot != null);\n      this.actions.get('collapsible').setEnabled(vertexSelected && graph.getSelectionCount() == 1 && (graph.isContainer(graph.getSelectionCell()) || graph.model.getChildCount(graph.getSelectionCell()) > 0));\n      this.actions.get('home').setEnabled(graph.view.currentRoot != null);\n      this.actions.get('exitGroup').setEnabled(graph.view.currentRoot != null);\n      this.actions.get('enterGroup').setEnabled(graph.getSelectionCount() == 1 && graph.isValidRoot(graph.getSelectionCell()));\n      var foldable = graph.getSelectionCount() == 1 && graph.isCellFoldable(graph.getSelectionCell());\n      this.actions.get('expand').setEnabled(foldable);\n      this.actions.get('collapse').setEnabled(foldable);\n      this.actions.get('editLink').setEnabled(graph.getSelectionCount() == 1);\n      this.actions.get('openLink').setEnabled(graph.getSelectionCount() == 1 && graph.getLinkForCell(graph.getSelectionCell()) != null);\n      this.actions.get('guides').setEnabled(graph.isEnabled());\n      this.actions.get('grid').setEnabled(!this.editor.chromeless);\n      var unlocked = graph.isEnabled() && !graph.isCellLocked(graph.getDefaultParent());\n      this.menus.get('layout').setEnabled(unlocked);\n      this.menus.get('insert').setEnabled(unlocked);\n      this.menus.get('direction').setEnabled(unlocked && vertexSelected);\n      this.menus.get('align').setEnabled(unlocked && vertexSelected && graph.getSelectionCount() > 1);\n      this.menus.get('distribute').setEnabled(unlocked && vertexSelected && graph.getSelectionCount() > 1);\n      this.actions.get('selectVertices').setEnabled(unlocked);\n      this.actions.get('selectEdges').setEnabled(unlocked);\n      this.actions.get('selectAll').setEnabled(unlocked);\n      this.actions.get('selectNone').setEnabled(unlocked);\n      this.updatePasteActionStates();\n    }\n\n    /**\n     * Refreshes the viewport.\n     */\n  }, {\n    key: \"refresh\",\n    value: function refresh(sizeDidChange, validate) {\n      sizeDidChange = sizeDidChange != null ? sizeDidChange : true;\n      var w = this.container.clientWidth;\n      var h = this.container.clientHeight;\n\n      // Workaround for bug on iOS see\n      // http://stackoverflow.com/questions/19012135/ios-7-ipad-safari-landscape-innerheight-outerheight-layout-issue\n      // FIXME: Fix if footer visible\n      //var off = 0;\n\n      if (_mxClient[\"default\"].IS_IOS && !window.navigator.standalone) {\n        if (window.innerHeight != document.documentElement.clientHeight) {\n          off = document.documentElement.clientHeight - window.innerHeight;\n          window.scrollTo(0, 0);\n        }\n      }\n      var tmp = 0;\n      if (tmp > 0 && !_mxClient[\"default\"].IS_QUIRKS) {\n        tmp += 1;\n      }\n\n      //var fw = this.rightContainer.offsetWidth || 0;\n      /*var effHsplitPosition = EDITORUI.hsplitPosition,\n          topPosition = 0;\n      if(this.props.editable === false){\n          effHsplitPosition = 0;\n      }\n       this.diagramContainer.style.left = (this.hsplit.parentNode != null) ? (effHsplitPosition + EDITORUI.splitSize) + 'px' : '0px';*/\n\n      this.diagramContainer.style.left = 0;\n      this.diagramContainer.style.top = 0;\n      //this.hsplit.style.left = effHsplitPosition + 'px';\n\n      this.diagramContainer.style.right = 0; //parseInt(this.centerContainer.style.marginLeft) + 'px';\n      //var th = 0;\n      this.diagramContainer.style.bottom = 0; //(off + th) + 'px';\n\n      if (sizeDidChange) {\n        this.editor.graph.sizeDidChange(validate, this);\n      }\n    }\n\n    /**\n        * 隐藏节点审批信息\n        * TODO: 临时增加，等ApprovalHistoryRecord拆为下一代控件后删除\n        */\n  }, {\n    key: \"resetApprovalRecords\",\n    value: function resetApprovalRecords() {\n      this.props.cleanActivatedCell();\n      var activatedCellCls = _Diagram2[\"default\"].activatedCell;\n      var actCell = this.diagramContainer.querySelector(\"svg #drawPane .\".concat(activatedCellCls));\n      _mxGraphUtils[\"default\"].removeClass(actCell, activatedCellCls);\n    }\n\n    /**\n     * Creates the actual toolbar for the toolbar container.\n     */\n  }, {\n    key: \"createDiv\",\n    value: function createDiv(classname) {\n      var elt = document.createElement('div');\n      elt.className = classname;\n      return elt;\n    }\n\n    /**\n     * Updates the states of the given undo/redo items.\n     */\n  }, {\n    key: \"addSplitHandler\",\n    value: function addSplitHandler(elt, horizontal, dx, onChange) {}\n\n    /**\n     * Displays a print dialog.\n     */\n  }, {\n    key: \"showDialog\",\n    value: function showDialog(elt, w, h, modal, closable, onClose) {\n      this.editor.graph.tooltipHandler.hideTooltip();\n      if (this.dialogs == null) {\n        this.dialogs = [];\n      }\n      this.dialog = new _Dialog[\"default\"](this, elt, w, h, modal, closable, onClose);\n      this.dialogs.push(this.dialog);\n    }\n\n    /**\n     * Displays a print dialog.\n     */\n  }, {\n    key: \"hideDialog\",\n    value: function hideDialog(cancel) {\n      if (this.dialogs != null && this.dialogs.length > 0) {\n        var dlg = this.dialogs.pop();\n        dlg.close(cancel);\n        this.dialog = this.dialogs.length > 0 ? this.dialogs[this.dialogs.length - 1] : null;\n        if (this.dialog == null && this.editor.graph.container.style.visibility != 'hidden') {\n          this.editor.graph.container.focus();\n        }\n        this.editor.fireEvent(new _mxEventObject[\"default\"]('hideDialog'));\n      }\n    }\n\n    /**\n     * Display a color dialog.\n     */\n  }, {\n    key: \"pickColor\",\n    value: function pickColor(color, apply) {\n      var graph = this.editor.graph;\n      var selState = graph.cellEditor.saveSelection();\n      var dlg = new _ColorDialog[\"default\"](this, color || 'none', function (color) {\n        graph.cellEditor.restoreSelection(selState);\n        apply(color);\n      }, function () {\n        graph.cellEditor.restoreSelection(selState);\n      });\n      this.showDialog(dlg.container, 220, 430, true, false);\n      dlg.init();\n    }\n\n    /**\n     * Adds the label menu items to the given menu and parent.\n     */\n  }, {\n    key: \"openFile\",\n    value: function openFile() {\n      // Closes dialog after open\n      window.openFile = new _OpenFile[\"default\"](_mxGraphUtils[\"default\"].bind(this, function (cancel) {\n        this.hideDialog(cancel);\n      }));\n\n      // Removes openFile if dialog is closed\n      this.showDialog(new _OpenDialog[\"default\"](this).container, _Editor[\"default\"].useLocalStorage ? 640 : 320, _Editor[\"default\"].useLocalStorage ? 480 : 220, true, true, function () {\n        window.openFile = null;\n      });\n    }\n\n    /**\n     * Extracs the graph model from the given HTML data from a data transfer event.\n     */\n  }, {\n    key: \"extractGraphModelFromHtml\",\n    value: function extractGraphModelFromHtml(data) {\n      var result = null;\n      try {\n        var idx = data.indexOf('&lt;mxGraphModel ');\n        if (idx >= 0) {\n          var idx2 = data.lastIndexOf('&lt;/mxGraphModel&gt;');\n          if (idx2 > idx) {\n            result = data.substring(idx, idx2 + 21).replace(/&gt;/g, '>').replace(/&lt;/g, '<').replace(/\\n/g, '');\n          }\n        }\n      } catch (e) {\n        // ignore\n      }\n      return result;\n    }\n\n    /**\n     * Returns true if the given string contains a compatible graph model.\n     */\n  }, {\n    key: \"isCompatibleString\",\n    value: function isCompatibleString(data) {\n      try {\n        var doc = _mxUtils[\"default\"].parseXml(data);\n        var node = this.editor.extractGraphModel(doc.documentElement);\n        return node != null && node.getElementsByTagName('parsererror').length === 0;\n      } catch (e) {\n        // ignore\n      }\n      return false;\n    }\n\n    /**\n     * Opens the given files in the editor.\n     */\n  }, {\n    key: \"extractGraphModelFromEvent\",\n    value: function extractGraphModelFromEvent(evt) {\n      var result = null;\n      var data = null;\n      if (evt != null) {\n        var provider = evt.dataTransfer != null ? evt.dataTransfer : evt.clipboardData;\n        if (provider != null) {\n          if (document.documentMode == 10 || document.documentMode == 11) {\n            data = provider.getData('Text');\n          } else {\n            data = _mxUtils[\"default\"].indexOf(provider.types, 'text/html') >= 0 ? provider.getData('text/html') : null;\n            if (_mxUtils[\"default\"].indexOf(provider.types,  true && (data == null || data.length === 0))) {\n              data = provider.getData('text/plain');\n            }\n          }\n          if (data != null) {\n            data = this.editor.graph.zapGremlins(_mxUtils[\"default\"].trim(data));\n\n            // Tries parsing as HTML document with embedded XML\n            var xml = this.extractGraphModelFromHtml(data);\n            if (xml != null) {\n              data = xml;\n            }\n          }\n        }\n      }\n      if (data != null && this.isCompatibleString(data)) {\n        result = data;\n      }\n      return result;\n    }\n\n    /**\n     * Adds the label menu items to the given menu and parent.\n     */\n  }, {\n    key: \"saveFile\",\n    value: function saveFile(forceDialog) {\n      if (!forceDialog && this.editor.filename != null) {\n        this.save(this.editor.getOrCreateFilename());\n      } else {\n        var dlg = new _FilenameDialog[\"default\"](this, this.editor.getOrCreateFilename(), _mxResources[\"default\"].get('save'), _mxGraphUtils[\"default\"].bind(this, function (name) {\n          this.save(name);\n        }), null, _mxGraphUtils[\"default\"].bind(this, function (name) {\n          if (name != null && name.length > 0) {\n            return true;\n          }\n          _mxUtils[\"default\"].confirm(_mxResources[\"default\"].get('invalidName'));\n          return false;\n        }));\n        this.showDialog(dlg.container, 300, 100, true, true);\n        dlg.init();\n      }\n    }\n\n    /**\n     * Executes the given layout.\n     */\n  }, {\n    key: \"executeLayout\",\n    value: function executeLayout(exec, animate, post) {\n      var graph = this.editor.graph;\n      if (graph.isEnabled()) {\n        graph.getModel().beginUpdate();\n        try {\n          exec();\n        } catch (e) {\n          throw e;\n        } finally {\n          // Animates the changes in the graph model except\n          // for Camino, where animation is too slow\n          if (_mxGraphConstant.EDITORUI.allowAnimation && animate && navigator.userAgent.indexOf('Camino') < 0) {\n            // New API for animating graph layout results asynchronously\n            var morph = new _mxMorphing[\"default\"](graph);\n            morph.addListener(_mxEvent[\"default\"].DONE, _mxGraphUtils[\"default\"].bind(this, function () {\n              graph.getModel().endUpdate();\n              if (post != null) {\n                post();\n              }\n            }));\n            morph.startAnimation();\n          } else {\n            graph.getModel().endUpdate();\n          }\n        }\n      }\n    }\n\n    /**\n     * Hides the current menu.\n     */\n  }, {\n    key: \"showImageDialog\",\n    value: function showImageDialog(title, value, fn, ignoreExisting) {\n      var cellEditor = this.editor.graph.cellEditor;\n      var selState = cellEditor.saveSelection();\n      var newValue = _mxUtils[\"default\"].prompt(title, value);\n      cellEditor.restoreSelection(selState);\n      if (newValue != null && newValue.length > 0) {\n        var img = new Image();\n        img.onload = function () {\n          fn(newValue, img.width, img.height);\n        };\n        img.onerror = function () {\n          fn(null);\n          _mxUtils[\"default\"].alert(_mxResources[\"default\"].get('fileNotFound'));\n        };\n        img.src = newValue;\n      } else {\n        fn(null);\n      }\n    }\n\n    /**\n     * Hides the current menu.\n     */\n  }, {\n    key: \"showLinkDialog\",\n    value: function showLinkDialog(value, btnLabel, fn) {\n      var dlg = new _LinkDialog[\"default\"](this, value, btnLabel, fn);\n      this.showDialog(dlg.container, 420, 90, true, true);\n      dlg.init();\n    }\n\n    /**\n     * Hides the current menu.\n     */\n  }, {\n    key: \"showBackgroundImageDialog\",\n    value: function showBackgroundImageDialog(apply) {\n      apply = apply != null ? apply : _mxGraphUtils[\"default\"].bind(this, function (image) {\n        this.setBackgroundImage(image);\n      });\n      var newValue = _mxUtils[\"default\"].prompt(_mxResources[\"default\"].get('backgroundImage'), '');\n      if (newValue != null && newValue.length > 0) {\n        var img = new Image();\n        img.onload = function () {\n          apply(new _mxImage[\"default\"](newValue, img.width, img.height));\n        };\n        img.onerror = function () {\n          apply(null);\n          _mxUtils[\"default\"].alert(_mxResources[\"default\"].get('fileNotFound'));\n        };\n        img.src = newValue;\n      } else {\n        apply(null);\n      }\n    }\n\n    /**\n     * Loads the stylesheet for this graph.\n     */\n  }, {\n    key: \"setBackgroundImage\",\n    value: function setBackgroundImage(image) {\n      this.editor.graph.setBackgroundImage(image);\n      this.editor.graph.view.validateBackgroundImage();\n      this.fireEvent(new _mxEventObject[\"default\"]('backgroundImageChanged'));\n    }\n\n    /**\n     * Creates the keyboard event handler for the current graph and history.\n     */\n  }, {\n    key: \"confirm\",\n    value: function confirm(msg, okFn, cancelFn) {\n      if (_mxUtils[\"default\"].confirm(msg)) {\n        if (okFn != null) {\n          okFn();\n        }\n      } else if (cancelFn != null) {\n        cancelFn();\n      }\n    }\n\n    /**\n     * Creates the keyboard event handler for the current graph and history.\n     */\n  }, {\n    key: \"createOutline\",\n    value: function createOutline(wnd) {\n      var outline = new _mxOutline[\"default\"](this.editor.graph);\n      outline.border = 20;\n      _mxEvent[\"default\"].addListener(window, 'resize', function () {\n        outline.update();\n      });\n      this.addListener('pageFormatChanged', function () {\n        outline.update();\n      });\n      return outline;\n    }\n\n    /**\n     * Creates the keyboard event handler for the current graph and history.\n     */\n  }, {\n    key: \"createKeyHandler\",\n    value: function createKeyHandler(editor) {\n      var editorUi = this;\n      var graph = this.editor.graph;\n      var keyHandler = new _mxKeyHandler[\"default\"](graph, graph.container);\n      var isEventIgnored = keyHandler.isEventIgnored;\n      keyHandler.isEventIgnored = function (evt) {\n        // Handles undo/redo/ctrl+./, via action and allows ctrl+b/u/i only if editing value is HTML (except for FF and Safari)\n        return (!this.isControlDown(evt) || _mxEvent[\"default\"].isShiftDown(evt) || evt.keyCode != 90 && evt.keyCode != 89 && evt.keyCode != 188 && evt.keyCode != 190) && (evt.keyCode != 66 && evt.keyCode != 73 && evt.keyCode != 85 || !this.isControlDown(evt) || this.graph.cellEditor.isContentEditing() && !_mxClient[\"default\"].IS_FF && !_mxClient[\"default\"].IS_SF) && isEventIgnored.apply(this, arguments);\n      };\n\n      // Ignores graph enabled state but not chromeless state\n      keyHandler.isEnabledForEvent = function (evt) {\n        return !_mxEvent[\"default\"].isConsumed(evt) && this.isGraphEvent(evt) && this.isEnabled();\n      };\n\n      // Routes command-key to control-key on Mac\n      keyHandler.isControlDown = function (evt) {\n        return _mxEvent[\"default\"].isControlDown(evt) || _mxClient[\"default\"].IS_MAC && evt.metaKey;\n      };\n\n      // Overridden to handle special alt+shift+cursor keyboard shortcuts\n      var directions = {\n        37: _mxConstants[\"default\"].DIRECTION_WEST,\n        38: _mxConstants[\"default\"].DIRECTION_NORTH,\n        39: _mxConstants[\"default\"].DIRECTION_EAST,\n        40: _mxConstants[\"default\"].DIRECTION_SOUTH\n      };\n      var keyHandlerGetFunction = _mxKeyHandler[\"default\"].prototype.getFunction;\n      keyHandler.getFunction = function (evt) {\n        if (directions[evt.keyCode] != null) {\n          var cell = graph.getSelectionCell();\n          if (graph.model.isVertex(cell)) {\n            if (_mxEvent[\"default\"].isShiftDown(evt) && _mxEvent[\"default\"].isAltDown(evt)) {\n              return function () {\n                var cells = graph.connectVertex(cell, directions[evt.keyCode], graph.defaultEdgeLength, evt, true);\n                if (cells != null && cells.length > 0) {\n                  if (cells.length == 1 && graph.model.isEdge(cells[0])) {\n                    graph.setSelectionCell(graph.model.getTerminal(cells[0], false));\n                  } else {\n                    graph.setSelectionCell(cells[cells.length - 1]);\n                  }\n                  if (editorUi.hoverIcons != null) {\n                    editorUi.hoverIcons.update(graph.view.getState(graph.getSelectionCell()));\n                  }\n                }\n              };\n            } else {\n              // Avoids consuming event if no vertex is selected by returning null below\n              // Cursor keys move and resize (ctrl) cells\n              if (this.isControlDown(evt)) {\n                return function () {\n                  nudge(evt.keyCode, _mxEvent[\"default\"].isShiftDown(evt) ? graph.gridSize : null, true);\n                };\n              } else {\n                return function () {\n                  nudge(evt.keyCode, _mxEvent[\"default\"].isShiftDown(evt) ? graph.gridSize : null);\n                };\n              }\n            }\n          }\n        }\n        return keyHandlerGetFunction.apply(this, arguments);\n      };\n      var queue = [];\n      var thread = null;\n\n      // Helper function to move cells with the cursor keys\n      function nudge(keyCode, stepSize, resize) {\n        queue.push(function () {\n          if (!graph.isSelectionEmpty() && graph.isEnabled()) {\n            stepSize = stepSize != null ? stepSize : 1;\n            if (resize) {\n              // Resizes all selected vertices\n              graph.getModel().beginUpdate();\n              try {\n                var cells = graph.getSelectionCells();\n                for (var i = 0; i < cells.length; i++) {\n                  if (graph.getModel().isVertex(cells[i]) && graph.isCellResizable(cells[i])) {\n                    var geo = graph.getCellGeometry(cells[i]);\n                    if (geo != null) {\n                      geo = geo.clone();\n                      if (keyCode == 37) {\n                        geo.width = Math.max(0, geo.width - stepSize);\n                      } else if (keyCode == 38) {\n                        geo.height = Math.max(0, geo.height - stepSize);\n                      } else if (keyCode == 39) {\n                        geo.width += stepSize;\n                      } else if (keyCode == 40) {\n                        geo.height += stepSize;\n                      }\n                      graph.getModel().setGeometry(cells[i], geo);\n                    }\n                  }\n                }\n              } finally {\n                graph.getModel().endUpdate();\n              }\n            } else {\n              // Moves vertices up/down in a stack layout\n              var cell = graph.getSelectionCell();\n              var parent = graph.model.getParent(cell);\n              var layout = null;\n              if (graph.getSelectionCount() == 1 && graph.model.isVertex(cell) && graph.layoutManager != null && !graph.isCellLocked(cell)) {\n                layout = graph.layoutManager.getLayout(parent);\n              }\n              if (layout != null && layout.constructor == mxStackLayout) {\n                var index = parent.getIndex(cell);\n                if (keyCode == 37 || keyCode == 38) {\n                  graph.model.add(parent, cell, Math.max(0, index - 1));\n                } else if (keyCode == 39 || keyCode == 40) {\n                  graph.model.add(parent, cell, Math.min(graph.model.getChildCount(parent), index + 1));\n                }\n              } else {\n                var dx = 0;\n                var dy = 0;\n                if (keyCode == 37) {\n                  dx = -stepSize;\n                } else if (keyCode == 38) {\n                  dy = -stepSize;\n                } else if (keyCode == 39) {\n                  dx = stepSize;\n                } else if (keyCode == 40) {\n                  dy = stepSize;\n                }\n                graph.moveCells(graph.getMovableCells(graph.getSelectionCells()), dx, dy);\n              }\n            }\n          }\n        });\n        if (thread != null) {\n          window.clearTimeout(thread);\n        }\n        thread = window.setTimeout(function () {\n          if (queue.length > 0) {\n            graph.getModel().beginUpdate();\n            try {\n              for (var i = 0; i < queue.length; i++) {\n                queue[i]();\n              }\n              queue = [];\n            } finally {\n              graph.getModel().endUpdate();\n            }\n            graph.scrollCellToVisible(graph.getSelectionCell());\n          }\n        }, 200);\n      }\n      ;\n\n      // Binds keystrokes to actions\n      keyHandler.bindAction = _mxGraphUtils[\"default\"].bind(this, function (code, control, key, shift) {\n        var action = this.actions.get(key);\n        var loading = this.loading;\n        var graph = this.editor.graph;\n        if (action != null) {\n          var f = function f() {\n            //属性配置初始化完成后才允许删除\n            if (graph.initPropertyCfg) {\n              console && console.log && console.log('Node properties are being initialized. Please try again later...');\n              return;\n            }\n            var waiting = loading && loading.style.display === 'flex';\n            if (!waiting && action.isEnabled()) {\n              action.funct();\n            }\n          };\n          if (control) {\n            if (shift) {\n              keyHandler.bindControlShiftKey(code, f);\n            } else {\n              keyHandler.bindControlKey(code, f);\n            }\n          } else {\n            if (shift) {\n              keyHandler.bindShiftKey(code, f);\n            } else {\n              keyHandler.bindKey(code, f);\n            }\n          }\n        }\n      });\n      var ui = this;\n      var keyHandlerEscape = keyHandler.escape;\n      keyHandler.escape = function (evt) {\n        keyHandlerEscape.apply(this, arguments);\n      };\n\n      // Ignores enter keystroke. Remove this line if you want the\n      // enter keystroke to stop editing. N, W, T are reserved.\n      keyHandler.enter = function () {};\n\n      /*\n      keyHandler.bindControlShiftKey(36, function() { graph.exitGroup(); }); // Ctrl+Shift+Home\n      keyHandler.bindControlShiftKey(35, function() { graph.enterGroup(); }); // Ctrl+Shift+End\n      keyHandler.bindKey(36, function() { graph.home(); }); // Home\n      keyHandler.bindKey(35, function() { graph.refresh(); }); // End\n      keyHandler.bindAction(107, true, 'zoomIn'); // Ctrl+Plus\n      keyHandler.bindAction(109, true, 'zoomOut'); // Ctrl+Minus\n      keyHandler.bindAction(80, true, 'print'); // Ctrl+P\n      keyHandler.bindAction(79, true, 'outline', true); // Ctrl+Shift+O\n      keyHandler.bindAction(112, false, 'about'); // F1\n      */\n\n      if (!this.editor.chromeless) {\n        /*\n        keyHandler.bindControlKey(36, function() { if (graph.isEnabled()) { graph.foldCells(true); }}); // Ctrl+Home\n        keyHandler.bindControlKey(35, function() { if (graph.isEnabled()) { graph.foldCells(false); }}); // Ctrl+End\n        keyHandler.bindControlKey(13, function() { if (graph.isEnabled()) { graph.setSelectionCells(graph.duplicateCells(graph.getSelectionCells(), false)); }}); // Ctrl+Enter\n        keyHandler.bindShiftKey(9, function() { if (graph.isEnabled()) { graph.selectPreviousCell(); }}); // Shift+Tab\n        keyHandler.bindControlKey(9, function() { if (graph.isEnabled()) { graph.selectParentCell(); }}); // Ctrl+Tab\n        keyHandler.bindControlShiftKey(9, function() { if (graph.isEnabled()) { graph.selectChildCell(); }}); // Ctrl+Shift+Tab\n        */\n        keyHandler.bindAction(8, false, 'delete'); // Backspace\n        keyHandler.bindAction(8, true, 'deleteAll'); // Backspace\n        keyHandler.bindAction(46, false, 'delete'); // Delete\n        keyHandler.bindAction(46, true, 'deleteAll'); // Ctrl+Delete\n        /*\n        keyHandler.bindAction(72, true, 'resetView'); // Ctrl+H\n        keyHandler.bindAction(72, true, 'fitWindow', true); // Ctrl+Shift+H\n        keyHandler.bindAction(74, true, 'fitPage'); // Ctrl+J\n        keyHandler.bindAction(74, true, 'fitTwoPages', true); // Ctrl+Shift+J\n        keyHandler.bindAction(48, true, 'customZoom'); // Ctrl+0\n        keyHandler.bindAction(82, true, 'turn'); // Ctrl+R\n        keyHandler.bindAction(82, true, 'clearDefaultStyle', true); // Ctrl+Shift+R\n        keyHandler.bindAction(83, true, 'save'); // Ctrl+S\n        keyHandler.bindAction(83, true, 'saveAs', true); // Ctrl+Shift+S\n        */\n        keyHandler.bindAction(65, true, 'selectAll'); // Ctrl+A\n        keyHandler.bindAction(65, true, 'selectNone', true); // Ctrl+A\n        keyHandler.bindAction(73, true, 'selectVertices', true); // Ctrl+Shift+I\n        keyHandler.bindAction(69, true, 'selectEdges', true); // Ctrl+Shift+E\n\n        /*keyHandler.bindAction(69, true, 'editStyle'); // Ctrl+E\n        keyHandler.bindAction(66, true, 'bold'); // Ctrl+B\n        keyHandler.bindAction(66, true, 'toBack', true); // Ctrl+Shift+B\n        keyHandler.bindAction(70, true, 'toFront', true); // Ctrl+Shift+F\n        keyHandler.bindAction(68, true, 'duplicate'); // Ctrl+D\n        keyHandler.bindAction(68, true, 'setAsDefaultStyle', true); // Ctrl+Shift+D\n        */\n        //keyHandler.bindAction(90, true, 'undo'); // Ctrl+Z\n        keyHandler.bindAction(67, true, 'copy'); // Ctrl+C\n        keyHandler.bindAction(86, true, 'paste'); // Ctrl+V\n        /*\n        keyHandler.bindAction(89, true, 'autosize', true); // Ctrl+Shift+Y\n        keyHandler.bindAction(88, true, 'cut'); // Ctrl+X\n        keyHandler.bindAction(81, true, 'connectionArrows'); // Ctrl+Q\n        keyHandler.bindAction(81, true, 'connectionPoints', true); // Ctrl+Shift+Q\n        keyHandler.bindAction(71, true, 'group'); // Ctrl+G\n        keyHandler.bindAction(77, true, 'editData'); // Ctrl+M\n        */\n        keyHandler.bindAction(71, true, 'grid', true); // Ctrl+Shift+G\n        /*\n        keyHandler.bindAction(73, true, 'italic'); // Ctrl+I\n        keyHandler.bindAction(76, true, 'lockUnlock'); // Ctrl+L\n        keyHandler.bindAction(76, true, 'layers', true); // Ctrl+Shift+L\n        keyHandler.bindAction(80, true, 'formatPanel', true); // Ctrl+Shift+P\n        keyHandler.bindAction(85, true, 'underline'); // Ctrl+U\n        keyHandler.bindAction(85, true, 'ungroup', true); // Ctrl+Shift+U\n        keyHandler.bindAction(190, true, 'superscript'); // Ctrl+.\n        keyHandler.bindAction(188, true, 'subscript'); // Ctrl+,\n        keyHandler.bindKey(13, function() { if (graph.isEnabled()) { graph.startEditingAtCell(); }}); // Enter\n        keyHandler.bindKey(113, function() { if (graph.isEnabled()) { graph.startEditingAtCell(); }}); // F2\n        */\n      }\n\n      /*if (!mxClient.IS_WIN)\n      {\n          keyHandler.bindAction(90, true, 'redo', true); // Ctrl+Shift+Z\n      }\n      else\n      {\n          keyHandler.bindAction(89, true, 'redo'); // Ctrl+Y\n      }*/\n\n      return keyHandler;\n    }\n\n    //创建选中的阴影效果\n  }, {\n    key: \"createBoxShadowFilter\",\n    value: function createBoxShadowFilter() {\n      var filter = document.createElementNS(_mxConstants[\"default\"].NS_SVG, 'filter');\n      var blur = document.createElementNS(_mxConstants[\"default\"].NS_SVG, 'feGaussianBlur');\n      var offset = document.createElementNS(_mxConstants[\"default\"].NS_SVG, 'feOffset');\n      var flood = document.createElementNS(_mxConstants[\"default\"].NS_SVG, 'feFlood');\n      var composite = document.createElementNS(_mxConstants[\"default\"].NS_SVG, 'feComposite');\n      var merge = document.createElementNS(_mxConstants[\"default\"].NS_SVG, 'feMerge');\n      var mergeNode = document.createElementNS(_mxConstants[\"default\"].NS_SVG, 'feMergeNode');\n      filter.setAttribute('id', 'box-shadow');\n      blur.setAttribute('stdDeviation', '10');\n      blur.setAttribute('in', 'SourceAlpha');\n      offset.setAttribute('dx', '1');\n      offset.setAttribute('dy', '1');\n      offset.setAttribute('result', 'offsetblur');\n      flood.setAttribute('flood-color', 'rgba(82,149,241,0.50)');\n      composite.setAttribute('in2', 'offsetblur');\n      composite.setAttribute('operator', 'in');\n      filter.appendChild(blur);\n      filter.appendChild(offset);\n      filter.appendChild(flood);\n      filter.appendChild(composite);\n      merge.appendChild(document.createElementNS(_mxConstants[\"default\"].NS_SVG, 'feMergeNode'));\n      mergeNode.setAttribute('in', 'SourceGraphic');\n      merge.appendChild(mergeNode);\n      filter.appendChild(merge);\n      return filter;\n    }\n\n    /**\n     * Creates the keyboard event handler for the current graph and history.\n     */\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      if (this.editor != null) {\n        this.editor.destroy();\n        this.editor = null;\n      }\n      if (this.toolbar != null) {\n        this.toolbar.destroy();\n        this.toolbar = null;\n      }\n      if (this.sidebar != null) {\n        this.sidebar.destroy();\n        this.sidebar = null;\n      }\n      if (this.keyHandler != null) {\n        this.keyHandler.destroy();\n        this.keyHandler = null;\n      }\n      if (this.keydownHandler != null) {\n        _mxEvent[\"default\"].removeListener(document, 'keydown', this.keydownHandler);\n        this.keydownHandler = null;\n      }\n      if (this.keyupHandler != null) {\n        _mxEvent[\"default\"].removeListener(document, 'keyup', this.keyupHandler);\n        this.keyupHandler = null;\n      }\n      if (this.resizeHandler != null) {\n        _mxEvent[\"default\"].removeListener(window, 'resize', this.resizeHandler);\n        this.resizeHandler = null;\n      }\n      if (this.gestureHandler != null) {\n        _mxEvent[\"default\"].removeGestureListeners(document, this.gestureHandler);\n        this.gestureHandler = null;\n      }\n      if (this.orientationChangeHandler != null) {\n        _mxEvent[\"default\"].removeListener(window, 'orientationchange', this.orientationChangeHandler);\n        this.orientationChangeHandler = null;\n      }\n      if (this.scrollHandler != null) {\n        _mxEvent[\"default\"].removeListener(window, 'scroll', this.scrollHandler);\n        this.scrollHandler = null;\n      }\n      if (this.destroyFunctions != null) {\n        for (var i = 0; i < this.destroyFunctions.length; i++) {\n          this.destroyFunctions[i]();\n        }\n        this.destroyFunctions = null;\n      }\n\n      /*var c = [this.sidebarContainer,\n               this.formatContainer, this.diagramContainer,\n               this.chromelessToolbar, this.hsplit,\n               this.layersDialog];*/\n\n      var c = [this.diagramContainer, this.chromelessToolbar, this.layersDialog];\n      for (var i = 0; i < c.length; i++) {\n        if (c[i] != null && c[i].parentNode != null) {\n          c[i].parentNode.removeChild(c[i]);\n        }\n      }\n    }\n  }, {\n    key: \"update\",\n    value: function update(obj, eventObject) {\n      var cell = null;\n      var graph = this.editor.graph;\n      var properties = eventObject.properties;\n      var selected = properties.added;\n      if (properties.isProcess) {\n        //图形加载完成后默认选中流程\n        cell = graph.getModel().getBPMNRoot();\n      } else if (selected && selected.length) {\n        cell = selected[0];\n      } else if (properties.removed && properties.removed.length) {\n        //删除节点后默认选中流程\n        cell = graph.getModel().getBPMNRoot();\n      }\n      if (cell) {\n        var model = graph.getJSONModel();\n        var ctrl = {\n          id: cell.getId(),\n          group: cell.getGroup(),\n          ctrlType: cell.getType(),\n          collapsed: cell.isCollapsed()\n        };\n        var params = [this.props.config.formId, cell.getType(), cell.getId(), {\n          template: cell.template\n        }];\n        var shrinkDiv = this.refs.diagram.refs.shrink;\n        if (shrinkDiv.style.display === 'none') {\n          //如果是纯绘图状态，即没有右侧属性配置时，不显示阻塞层\n          this.showLoading(true);\n        }\n        this.context.invokeAction(this.context.model, 'change', params);\n        //TODO DELETE --\n        //this.props.setSelectControl(ctrl);\n      }\n    }\n  }, {\n    key: \"removeCellsListener\",\n    value: function removeCellsListener(obj, eventObject) {\n      var cells = eventObject.getProperty('cells');\n      var jsons = this.getCellsJson(cells, false);\n      var params = [this.props.config.formId, {\n        cells: JSON.stringify(jsons)\n      }];\n      this.context.invokeAction(this.context.model, _mxGraphConstant.EVENT.REMOVE_CELLS, params);\n    }\n  }, {\n    key: \"afterDeleteCellsListener\",\n    value: function afterDeleteCellsListener(obj, eventObject) {\n      var cells = eventObject.getProperty('cells');\n      var selectedCells = eventObject.getProperty('selectedCells');\n      var cellsJson = this.getCellsJson(cells, false);\n      var selectedCellsJson = this.getCellsJson(selectedCells, false);\n      var params = [this.props.config.formId, {\n        cells: JSON.stringify(cellsJson),\n        selectedCells: JSON.stringify(selectedCellsJson)\n      }];\n      this.context.invokeAction(this.context.model, _mxGraphConstant.EVENT.AFTER_DELETE_CELLS, params);\n    }\n  }, {\n    key: \"pasteCellsListener\",\n    value: function pasteCellsListener(obj, eventObject) {\n      var cells = eventObject.getProperty('cells');\n      var jsons = this.getCellsJson(cells, true);\n      var params = [this.props.config.formId, {\n        cells: JSON.stringify(jsons)\n      }];\n      this.context.invokeAction(this.context.model, _mxGraphConstant.EVENT.AFTER_PASTE_CELLS, params);\n    }\n  }, {\n    key: \"moveCellsListener\",\n    value: function moveCellsListener(obj, eventObject) {\n      var data = eventObject.getProperty('parentChanged');\n      var target = eventObject.getProperty('target');\n      var keys = null;\n      if (data && (keys = Object.keys(data)) && keys.length) {\n        var params = [this.props.config.formId, {\n          parentId: target && target.id,\n          changed: data\n        }];\n        this.context.invokeAction(this.context.model, _mxGraphConstant.EVENT.PARENT_CHANGED, params);\n      }\n    }\n  }, {\n    key: \"getCellsJson\",\n    value: function getCellsJson(cells, includeProperties) {\n      var jsons = [];\n      cells.forEach(function (val, index) {\n        jsons.push(val.toBpmnJSON(includeProperties));\n      });\n      return jsons;\n    }\n  }, {\n    key: \"insertCellsListener\",\n    value: function insertCellsListener(eventObject) {\n      var cells = eventObject.getProperty('cells');\n      var cell = cells[0];\n      var params = null;\n      if (cell.isEdge()) {\n        //如果添加的是线，还需要传递新增的节点\n        var target = cell.target;\n        target.setProperty('base', 'name', target.value);\n        params = [this.props.config.formId, {\n          sourceId: cell.source.getId(),\n          edge: cell.toBpmnJSONString(true),\n          target: target.toBpmnJSONString(true),\n          parentId: cell.parent && cell.parent.getId()\n        }];\n      } else {\n        //节点\n        params = [this.props.config.formId, {\n          cell: cell.toBpmnJSONString(true)\n        }];\n      }\n      this.context.invokeAction(this.context.model, _mxGraphConstant.EVENT.CELLSINSERTED, params);\n    }\n  }, {\n    key: \"connectListener\",\n    value: function connectListener(eventObject) {\n      //connect_cell事件中是edge\n      var edge = eventObject.getProperty('cell') || eventObject.getProperty('edge');\n      var source = edge.source;\n      var target = edge.target;\n      var params = [this.props.config.formId, {\n        edge: edge.toBpmnJSONString(true),\n        sourceId: source && source.getId(),\n        targetId: target && target.getId(),\n        parentId: edge.parent && edge.parent.getId()\n      }];\n      this.context.invokeAction(this.context.model, _mxEvent[\"default\"].CONNECT, params);\n    }\n  }, {\n    key: \"splitEdgeListener\",\n    value: function splitEdgeListener(obj, eventObject) {\n      var edge = eventObject.getProperty('edge');\n      var newEdge = eventObject.getProperty('newEdge');\n      var params = [this.props.config.formId, {\n        edge: edge.toBpmnJSONString(true),\n        newEdge: newEdge.toBpmnJSONString(true)\n      }];\n      this.context.invokeAction(this.context.model, _mxEvent[\"default\"].SPLIT_EDGE, params);\n    }\n  }, {\n    key: \"showLoading\",\n    value: function showLoading(visible) {\n      var _this3 = this;\n      clearTimeout(this.loadingTimer);\n      this.loadingTimer = setTimeout(function () {\n        _this3.loading.style.display = visible ? 'flex' : 'none';\n      }, _mxGraphConstant.debounceTime);\n      //标识初始化配置为true，在初始化完成时设置为false\n      this.editor.graph.initPropertyCfg = visible;\n    }\n  }, {\n    key: \"addCellsFromSidebar\",\n    value: function addCellsFromSidebar(baseType, type, template, style, value, containable) {\n      var graph = this.editor.graph,\n        translate = graph.view.translate,\n        bounds = graph.getGraphBounds(),\n        select = null,\n        target = null,\n        x = bounds.x - translate.x,\n        y = bounds.y - translate.y;\n      var cellShape = \"ierp.\".concat(baseType, \".\").concat(type);\n      var stencil = _mxStencilRegistry[\"default\"].getStencil(\"\".concat(cellShape, \"_USE\"));\n      if (!stencil) {\n        stencil = _mxStencilRegistry[\"default\"].getStencil(cellShape);\n        style = \"shape=\".concat(stencil.shape, \";\").concat(style);\n      } else {\n        style = \"shape=\".concat(cellShape, \";\").concat(style);\n      }\n      if (containable) {\n        style = style.replace(cellShape, 'swimlane');\n        style += \";strokeColor=#BBBBBB;autosize=1;foldable=1;startSize=24;\";\n      }\n      var isBoundary = _mxGraphUtils[\"default\"].isBoundaryEvent(type);\n      if (isBoundary) {\n        style += \"resizable=0;\";\n      }\n\n      //新添的节点再往左偏一点，否则可能会出现重合\n      x -= stencil.w0 + 10;\n      //TODO: DELETE group\n      var cell = new _mxCell[\"default\"](value, new _mxGeometry[\"default\"](0, 0, stencil.w0, stencil.h0), style, type, null, baseType, containable, template);\n      var cells = [cell];\n      if (containable) {\n        cell.setCollapsed(true);\n        cell.geometry.alternateBounds = new _mxRectangle[\"default\"](0, 0, _mxConstants[\"default\"].DEFAULT_SWIMLANE_WIDTH, _mxConstants[\"default\"].DEFAULT_SWIMLANE_HEIGHT);\n      }\n      var imp = true;\n      var parent = graph.getSelectionCell();\n      if (isBoundary) {\n        //边界节点\n        var geo = cell.geometry;\n        geo.y = 0.5;\n        geo.width = stencil.inwidth || stencil.w0;\n        geo.height = stencil.inheight || stencil.h0;\n        geo.offset = new _mxPoint[\"default\"](0 - geo.width / 2, 0 - geo.height / 2);\n        geo.relative = true;\n        //设置attachedToRefId属性的值为parentId\n        cell.setProperty('base', 'attachedToRefId', parent.getId());\n        imp = false;\n      }\n      cell.vertex = true;\n      cells = graph.getImportableCells(cells);\n      graph.stopEditing();\n      graph.model.beginUpdate();\n      try {\n        if (imp) {\n          select = graph.importCells(cells, x, y, target);\n        } else {\n          select = cells;\n          graph.addCell(cell, parent);\n        }\n        graph.fireEvent(new _mxEventObject[\"default\"]('cellsInserted', 'cells', select));\n      } finally {\n        graph.model.endUpdate();\n      }\n      if (select != null && select.length > 0) {\n        graph.scrollCellToVisible(select[0]);\n        graph.setSelectionCells(select);\n      }\n    }\n  }, {\n    key: \"exportImage\",\n    value: function exportImage(fileName) {\n      var graph = this.editor.graph;\n      var bounds = graph.getGraphBounds();\n      var width = bounds.width;\n      var height = bounds.height;\n      var svg = graph.getSvg('#FFF');\n      var margins = 30;\n      var width = svg.getAttribute('width');\n      var height = svg.getAttribute('height');\n      if (width) {\n        width = parseInt(width.replace('px', '')) + margins;\n        svg.setAttribute('width', \"\".concat(width, \"px\"));\n      }\n      if (height) {\n        height = parseInt(height.replace('px', '')) + margins;\n        svg.setAttribute('height', \"\".concat(height, \"px\"));\n      }\n      var translate = margins / 2 + 0.5;\n      var group = svg.querySelector('g.root');\n      group.setAttribute(\"transform\", \"translate(\".concat(translate, \", \").concat(translate, \")\"));\n      var data = new XMLSerializer().serializeToString(svg);\n      var decoded = unescape(encodeURIComponent(data));\n      var base64 = btoa(decoded);\n      var img = new Image();\n      img.src = \"data:image/svg+xml;base64,\" + base64;\n      img.onload = function () {\n        var canvas = document.createElement('canvas');\n        canvas.setAttribute('width', width);\n        canvas.setAttribute('height', height);\n        var ctx = canvas.getContext('2d');\n        ctx.fillStyle = '#FFF';\n        ctx.drawImage(img, 0, 0, width, height);\n        var a = null;\n        try {\n          var uri = canvas.toDataURL('image/png').replace('image/png', 'octet/stream');\n          a = document.createElement('a');\n          a.style = 'display: none';\n          a.href = uri;\n          a.download = fileName + '.png';\n          document.body.appendChild(a);\n          a.click();\n        } finally {\n          window.URL.revokeObjectURL(uri);\n          document.body.removeChild(a);\n        }\n      };\n    }\n  }]);\n  return EditorUi;\n}(_GraphComponent2[\"default\"]);\nEditorUi.contextTypes = {\n  dispatch: _propTypes[\"default\"].func,\n  model: _propTypes[\"default\"].object,\n  modelType: _propTypes[\"default\"].string,\n  modelVer: _propTypes[\"default\"].string,\n  setPostData: _propTypes[\"default\"].func,\n  invokeAction: _propTypes[\"default\"].func\n};\nEditorUi.childContextTypes = {\n  notifyMsg: _propTypes[\"default\"].func\n};\nvar mapStateToProps = function mapStateToProps(state) {\n  return {\n    uiMetadata: state.metadata.get('domainModel'),\n    modelConfig: state.metadata.get('modelConfig'),\n    ui: state.ui\n  };\n};\nvar _default = exports[\"default\"] = (0, _reactRedux.connect)(mapStateToProps, actionCreators)(EditorUi);\n\n//# sourceURL=webpack://bos-platform/./src/workflow/components/EditorUi.js?");

/***/ }),

/***/ "./src/workflow/components/FloatLayer.js":
/*!***********************************************!*\
  !*** ./src/workflow/components/FloatLayer.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\n__webpack_require__(/*! core-js/modules/es.symbol.js */ \"../../node_modules/core-js/modules/es.symbol.js\");\n__webpack_require__(/*! core-js/modules/es.symbol.description.js */ \"../../node_modules/core-js/modules/es.symbol.description.js\");\n__webpack_require__(/*! core-js/modules/es.symbol.iterator.js */ \"../../node_modules/core-js/modules/es.symbol.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.symbol.to-primitive.js */ \"../../node_modules/core-js/modules/es.symbol.to-primitive.js\");\n__webpack_require__(/*! core-js/modules/es.array.iterator.js */ \"../../node_modules/core-js/modules/es.array.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.date.to-primitive.js */ \"../../node_modules/core-js/modules/es.date.to-primitive.js\");\n__webpack_require__(/*! core-js/modules/es.number.constructor.js */ \"../../node_modules/core-js/modules/es.number.constructor.js\");\n__webpack_require__(/*! core-js/modules/es.object.create.js */ \"../../node_modules/core-js/modules/es.object.create.js\");\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\n__webpack_require__(/*! core-js/modules/es.object.get-own-property-descriptor.js */ \"../../node_modules/core-js/modules/es.object.get-own-property-descriptor.js\");\n__webpack_require__(/*! core-js/modules/es.object.get-prototype-of.js */ \"../../node_modules/core-js/modules/es.object.get-prototype-of.js\");\n__webpack_require__(/*! core-js/modules/es.object.to-string.js */ \"../../node_modules/core-js/modules/es.object.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.reflect.construct.js */ \"../../node_modules/core-js/modules/es.reflect.construct.js\");\n__webpack_require__(/*! core-js/modules/es.string.iterator.js */ \"../../node_modules/core-js/modules/es.string.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.weak-map.js */ \"../../node_modules/core-js/modules/es.weak-map.js\");\n__webpack_require__(/*! core-js/modules/web.dom-collections.iterator.js */ \"../../node_modules/core-js/modules/web.dom-collections.iterator.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.function.bind.js */ \"../../node_modules/core-js/modules/es.function.bind.js\");\n__webpack_require__(/*! core-js/modules/es.object.set-prototype-of.js */ \"../../node_modules/core-js/modules/es.object.set-prototype-of.js\");\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"webpack/sharing/consume/default/react/react?dca2\"));\nvar _propTypes = _interopRequireDefault(__webpack_require__(/*! prop-types */ \"../../node_modules/prop-types/index.js\"));\nvar _FloatLayer2 = _interopRequireDefault(__webpack_require__(/*! ../css/FloatLayer.less */ \"./src/workflow/css/FloatLayer.less\"));\nvar _reactTooltip = _interopRequireDefault(__webpack_require__(/*! react-tooltip */ \"../../node_modules/react-tooltip/dist/index.es.js\"));\nvar _immutable = __webpack_require__(/*! immutable */ \"webpack/sharing/consume/default/immutable/immutable?f2ca\");\nvar _tooltipaction = __webpack_require__(/*! ../../action/tooltipaction */ \"./src/action/tooltipaction.js\");\nvar _Tooltip = _interopRequireDefault(__webpack_require__(/*! ../../component/common/Tooltip */ \"./src/component/common/Tooltip.jsx\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction _getRequireWildcardCache(e) { if (\"function\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return { \"default\": e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\"default\" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n[\"default\"] = e, t && t.set(e, n), n; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nvar FloatLayer = /*#__PURE__*/function (_Component) {\n  _inherits(FloatLayer, _Component);\n  function FloatLayer(props) {\n    var _this;\n    _classCallCheck(this, FloatLayer);\n    _this = _callSuper(this, FloatLayer, [props]);\n    _this.state = {\n      show: false\n    };\n    return _this;\n  }\n  _createClass(FloatLayer, [{\n    key: \"componentWillReceiveProps\",\n    value: function componentWillReceiveProps(nextProps) {\n      this.setState({\n        show: !!nextProps.showFloatLayer\n      });\n    }\n  }, {\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(nextProps, nextState) {\n      if (!(0, _immutable.is)(this.state.show, nextState.show) && nextProps.initialData && nextProps.initialData.floatLayerCellIds && nextProps.updateFloatLayer && nextProps.updateFloatLayer.get(\"id\")) {\n        var cell = nextProps.updateFloatLayer;\n        var cellId = cell.get(\"id\");\n        var floatLayerCellIds = nextProps.initialData.floatLayerCellIds;\n        for (var i = 0; i <= floatLayerCellIds.length; i++) {\n          if (floatLayerCellIds[i] == cellId) {\n            return true;\n          }\n        }\n        return false;\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n      var display = 'flex';\n      var cell = this.props.updateFloatLayer;\n      var top;\n      var left;\n      if (cell && cell.size) {\n        top = cell.get(\"top\");\n        left = cell.get(\"left\");\n      } else {\n        top = this.refs.floatlayer ? this.refs.floatlayer.style.top : \"0px\";\n        left = this.refs.floatlayer ? this.refs.floatlayer.style.left : \"0px\";\n      }\n      var tips = (0, _immutable.fromJS)({\n        'type': 'bill',\n        'place': 'right',\n        'link': false,\n        'billno': '***',\n        'showIcon': true,\n        'iconClassName': '***'\n      });\n      return /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        ref: \"floatlayer\",\n        className: _FloatLayer2[\"default\"]['floatlayer'],\n        style: {\n          display: display,\n          top: top,\n          left: left\n        }\n      }, /*#__PURE__*/_react[\"default\"].createElement(_Tooltip[\"default\"], {\n        ref: \"floatlayertip\",\n        tips: tips,\n        showFormByTips: function showFormByTips(formId, targetCtrlKey) {\n          return dispatch((0, _tooltipaction.showFormByTips)(_this2.context.model.pageId, _this2.context.model.key, formId, targetCtrlKey, 'click'));\n        }\n      }));\n    }\n  }, {\n    key: \"componentWillUpdate\",\n    value: function componentWillUpdate(nextProps, nextState) {\n      if (nextState && nextState.show && nextProps.initialData && nextProps.initialData.floatLayerCellIds && nextProps.updateFloatLayer && nextProps.updateFloatLayer.get(\"id\")) {\n        var cell = nextProps.updateFloatLayer;\n        var cellId = cell.get(\"id\");\n        var floatLayerCellIds = nextProps.initialData.floatLayerCellIds;\n        for (var i = 0; i <= floatLayerCellIds.length; i++) {\n          if (floatLayerCellIds[i] == cellId) {\n            var _cell = nextProps.updateFloatLayer;\n            var params = JSON.stringify({\n              cellId: _cell.get('id'),\n              procInstId: _cell.get('procInstId'),\n              billId: _cell.get('billId'),\n              pageId: _cell.get('pageId'),\n              type: \"floatLayer\",\n              uuid: this.refs.floatlayertip.uuid,\n              top: _cell.get(\"top\"),\n              left: _cell.get(\"left\")\n            });\n            this.context.dispatch((0, _tooltipaction.showFormByTips)(this.context.model.pageId, this.context.model.key, params, this.refs.floatlayertip.uuid, 'hover'));\n          }\n        }\n      } else {\n        _reactTooltip[\"default\"].hide(document.querySelector(\"[data-for=\\\"\".concat(\"+this.refs.floatlayertip.uuid+\", \"\\\"]\")));\n      }\n    }\n  }]);\n  return FloatLayer;\n}(_react.Component);\nFloatLayer.contextTypes = {\n  dispatch: _propTypes[\"default\"].func,\n  invokeAction: _propTypes[\"default\"].func,\n  model: _propTypes[\"default\"].object\n};\nvar _default = exports[\"default\"] = FloatLayer;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/components/FloatLayer.js?");

/***/ }),

/***/ "./src/workflow/components/FloatToolbar.js":
/*!*************************************************!*\
  !*** ./src/workflow/components/FloatToolbar.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\n__webpack_require__(/*! core-js/modules/es.symbol.js */ \"../../node_modules/core-js/modules/es.symbol.js\");\n__webpack_require__(/*! core-js/modules/es.symbol.description.js */ \"../../node_modules/core-js/modules/es.symbol.description.js\");\n__webpack_require__(/*! core-js/modules/es.symbol.iterator.js */ \"../../node_modules/core-js/modules/es.symbol.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.symbol.to-primitive.js */ \"../../node_modules/core-js/modules/es.symbol.to-primitive.js\");\n__webpack_require__(/*! core-js/modules/es.array.iterator.js */ \"../../node_modules/core-js/modules/es.array.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.date.to-primitive.js */ \"../../node_modules/core-js/modules/es.date.to-primitive.js\");\n__webpack_require__(/*! core-js/modules/es.number.constructor.js */ \"../../node_modules/core-js/modules/es.number.constructor.js\");\n__webpack_require__(/*! core-js/modules/es.object.create.js */ \"../../node_modules/core-js/modules/es.object.create.js\");\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\n__webpack_require__(/*! core-js/modules/es.object.get-own-property-descriptor.js */ \"../../node_modules/core-js/modules/es.object.get-own-property-descriptor.js\");\n__webpack_require__(/*! core-js/modules/es.object.get-prototype-of.js */ \"../../node_modules/core-js/modules/es.object.get-prototype-of.js\");\n__webpack_require__(/*! core-js/modules/es.object.to-string.js */ \"../../node_modules/core-js/modules/es.object.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.reflect.construct.js */ \"../../node_modules/core-js/modules/es.reflect.construct.js\");\n__webpack_require__(/*! core-js/modules/es.string.iterator.js */ \"../../node_modules/core-js/modules/es.string.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.weak-map.js */ \"../../node_modules/core-js/modules/es.weak-map.js\");\n__webpack_require__(/*! core-js/modules/web.dom-collections.iterator.js */ \"../../node_modules/core-js/modules/web.dom-collections.iterator.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.function.bind.js */ \"../../node_modules/core-js/modules/es.function.bind.js\");\n__webpack_require__(/*! core-js/modules/es.object.set-prototype-of.js */ \"../../node_modules/core-js/modules/es.object.set-prototype-of.js\");\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"webpack/sharing/consume/default/react/react?dca2\"));\nvar _propTypes = _interopRequireDefault(__webpack_require__(/*! prop-types */ \"../../node_modules/prop-types/index.js\"));\nvar _FloatToolbar2 = _interopRequireDefault(__webpack_require__(/*! ../css/FloatToolbar.less */ \"./src/workflow/css/FloatToolbar.less\"));\nvar _mxEvent = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxEvent.js */ \"./src/workflow/mxClient/mxEvent.js\"));\nvar _classnames = _interopRequireDefault(__webpack_require__(/*! classnames */ \"../../node_modules/classnames/index.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxGraphUtils */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _intlApi = __webpack_require__(/*! ../../i18n/intlApi */ \"./src/i18n/intlApi.js\");\nvar _mxGraphConstant = __webpack_require__(/*! ../constants/mxGraphConstant */ \"./src/workflow/constants/mxGraphConstant.js\");\nvar _kdesign = __webpack_require__(/*! @kdcloudjs/kdesign */ \"webpack/sharing/consume/default/@kdcloudjs/kdesign/@kdcloudjs/kdesign\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction _getRequireWildcardCache(e) { if (\"function\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return { \"default\": e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\"default\" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n[\"default\"] = e, t && t.set(e, n), n; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nvar FloatToolbar = /*#__PURE__*/function (_Component) {\n  _inherits(FloatToolbar, _Component);\n  function FloatToolbar(props) {\n    var _this;\n    _classCallCheck(this, FloatToolbar);\n    _this = _callSuper(this, FloatToolbar, [props]);\n    _this.state = {\n      zoomInActive: false,\n      zoomOutActive: false,\n      downloadActive: false,\n      scale: 1,\n      percentage: '100%'\n    };\n    return _this;\n  }\n  _createClass(FloatToolbar, [{\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n      var isBillRelationGraph = this.props.isBillRelationGraph;\n      var isMobile = this.props.config.formId == \"wf_viewflowchartmobile\";\n      var downloadCls = !isMobile && !isBillRelationGraph ? _FloatToolbar2[\"default\"].visible : _FloatToolbar2[\"default\"].notvisible;\n      var downloadTipCls = !isMobile && this.state.downloadActive ? _FloatToolbar2[\"default\"].visible : _FloatToolbar2[\"default\"].notvisible;\n      var floatButtonsDiv = null;\n      if (this.props.config.formId == 'bpm_billrelation_graph' && isBillRelationGraph) {\n        var params = this.props.config.clientParams || {};\n        var isServerRender = params.serverRender;\n        floatButtonsDiv = /*#__PURE__*/_react[\"default\"].createElement(FloatButtons, {\n          graph: this.props.graph,\n          showLoading: this.props.showLoading,\n          isServerRender: isServerRender,\n          switchLayout: this.props.switchLayout\n        });\n      }\n      return /*#__PURE__*/_react[\"default\"].createElement(_react[\"default\"].Fragment, null, floatButtonsDiv, /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: (0, _classnames[\"default\"])(_FloatToolbar2[\"default\"].floatToolbar)\n      }, /*#__PURE__*/_react[\"default\"].createElement(_kdesign.Tooltip, {\n        tip: (0, _intlApi.getLangMsg)({\n          key: \"FloatToolbar.downloadFlowChart\"\n        }),\n        placement: \"topRight\"\n      }, /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: (0, _classnames[\"default\"])(_FloatToolbar2[\"default\"].item, _FloatToolbar2[\"default\"]['download'], downloadCls),\n        onClick: function onClick(e) {\n          _this2.downloadClickHandler(e);\n        },\n        onMouseOver: function onMouseOver(e) {\n          _this2.downloadMouseOverHandler(e);\n        },\n        onMouseOut: function onMouseOut(e) {\n          _this2.downloadMouseOutHandler(e);\n        }\n      }, /*#__PURE__*/_react[\"default\"].createElement(\"img\", {\n        className: _FloatToolbar2[\"default\"].icon,\n        src: this.state.downloadActive ? _mxGraphConstant.ICON_DOWNLOAD_HOVER : _mxGraphConstant.ICON_DOWNLOAD\n      }))), /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: (0, _classnames[\"default\"])(_FloatToolbar2[\"default\"].item, _FloatToolbar2[\"default\"]['zoom-in']),\n        onClick: function onClick(e) {\n          _this2.zoomInClickHandler(e, true);\n        },\n        onMouseOver: function onMouseOver(e) {\n          _this2.mouseOverHandler(e, true);\n        },\n        onMouseOut: function onMouseOut(e) {\n          _this2.mouseOutHandler(e, true);\n        }\n      }, /*#__PURE__*/_react[\"default\"].createElement(\"img\", {\n        className: _FloatToolbar2[\"default\"].icon,\n        src: this.state.zoomInActive ? _mxGraphConstant.ICON_ZOOMIN_HOVER : _mxGraphConstant.ICON_ZOOMIN\n      })), /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: (0, _classnames[\"default\"])(_FloatToolbar2[\"default\"].item, _FloatToolbar2[\"default\"]['zoom-out']),\n        onClick: function onClick(e) {\n          _this2.zoomOutClickHandler(e, false);\n        },\n        onMouseOver: function onMouseOver(e) {\n          _this2.mouseOverHandler(e, false);\n        },\n        onMouseOut: function onMouseOut(e) {\n          _this2.mouseOutHandler(e, false);\n        }\n      }, /*#__PURE__*/_react[\"default\"].createElement(\"img\", {\n        className: _FloatToolbar2[\"default\"].icon,\n        src: this.state.zoomOutActive ? _mxGraphConstant.ICON_ZOOMOUT_HOVER : _mxGraphConstant.ICON_ZOOMOUT\n      }))));\n    }\n  }, {\n    key: \"downloadClickHandler\",\n    value: function downloadClickHandler(evt) {\n      var model = this.context.model;\n      var config = model.getFormConfig();\n      this.context.invokeAction(model, 'handleEvent', [config.formId, 'downloadFlowChart', {}]);\n    }\n  }, {\n    key: \"downloadMouseOverHandler\",\n    value: function downloadMouseOverHandler(evt) {\n      this.setState({\n        downloadActive: true\n      });\n    }\n  }, {\n    key: \"downloadMouseOutHandler\",\n    value: function downloadMouseOutHandler(evt) {\n      this.setState({\n        downloadActive: false\n      });\n    }\n  }, {\n    key: \"zoomInClickHandler\",\n    value: function zoomInClickHandler(evt, zoomIn) {\n      if (this.isScaleOutOfRange(zoomIn)) {\n        return;\n      }\n      var action = this.props.actions.get(\"zoomIn\");\n      action && action.funct(evt);\n      _mxEvent[\"default\"].consume(evt);\n      this.updatePercentage();\n      this.props.clicked && this.props.clicked();\n    }\n  }, {\n    key: \"zoomOutClickHandler\",\n    value: function zoomOutClickHandler(evt, zoomIn) {\n      if (this.isScaleOutOfRange(zoomIn)) {\n        return;\n      }\n      var action = this.props.actions.get(\"zoomOut\");\n      action && action.funct(evt);\n      _mxEvent[\"default\"].consume(evt);\n      this.updatePercentage();\n      this.props.clicked && this.props.clicked();\n    }\n  }, {\n    key: \"updatePercentage\",\n    value: function updatePercentage() {\n      var graphView = this.props.graph.view;\n      var scale = graphView.getScale();\n      this.setState({\n        scale: scale,\n        percentage: _mxGraphUtils[\"default\"].getScalePercentage(scale)\n      });\n    }\n  }, {\n    key: \"mouseOverHandler\",\n    value: function mouseOverHandler(evt, zoomIn) {\n      if (this.isScaleOutOfRange(zoomIn)) {\n        return;\n      }\n      this.hoverZoomButton(zoomIn, true);\n    }\n  }, {\n    key: \"mouseOutHandler\",\n    value: function mouseOutHandler(evt, zoomIn) {\n      this.hoverZoomButton(zoomIn, false);\n    }\n  }, {\n    key: \"hoverZoomButton\",\n    value: function hoverZoomButton(zoomIn, active) {\n      if (zoomIn) {\n        this.setState({\n          zoomInActive: active\n        });\n      } else {\n        this.setState({\n          zoomOutActive: active\n        });\n      }\n    }\n  }, {\n    key: \"isScaleOutOfRange\",\n    value: function isScaleOutOfRange(zoomIn) {\n      var scale = this.state.scale || 0;\n      if (zoomIn) {\n        return scale >= _mxGraphConstant.zoom_max;\n      } else {\n        return scale <= _mxGraphConstant.zoom_min;\n      }\n    }\n  }]);\n  return FloatToolbar;\n}(_react.Component);\nFloatToolbar.contextTypes = {\n  invokeAction: _propTypes[\"default\"].func,\n  model: _propTypes[\"default\"].object\n};\nvar FloatButtons = /*#__PURE__*/function (_Component2) {\n  _inherits(FloatButtons, _Component2);\n  function FloatButtons(props) {\n    var _this3;\n    _classCallCheck(this, FloatButtons);\n    _this3 = _callSuper(this, FloatButtons, [props]);\n    _this3.state = {\n      horizontal: true,\n      horizontalCls: '',\n      verticalCls: _FloatToolbar2[\"default\"].clickable\n    };\n    return _this3;\n  }\n  _createClass(FloatButtons, [{\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(nextProps, nextState) {\n      var state = this.state;\n      return state.horizontal != nextState.horizontal || state.horizontalCls != nextState.horizontalCls || state.verticalCls != nextState.verticalCls;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this4 = this;\n      var horizontalDisplay = /*#__PURE__*/_react[\"default\"].createElement(\"svg\", {\n        width: \"56px\",\n        height: \"28px\",\n        viewBox: \"0 0 56 28\",\n        version: \"1.1\",\n        xmlns: \"http://www.w3.org/2000/svg\"\n      }, /*#__PURE__*/_react[\"default\"].createElement(\"g\", {\n        stroke: \"none\",\n        \"stroke-width\": \"1\",\n        fill: \"none\",\n        \"fill-rule\": \"evenodd\"\n      }, /*#__PURE__*/_react[\"default\"].createElement(\"g\", null, /*#__PURE__*/_react[\"default\"].createElement(\"rect\", {\n        stroke: \"#5582F3\",\n        fill: \"#FFFFFF\",\n        x: \"0.5\",\n        y: \"0.5\",\n        width: \"55\",\n        height: \"27\",\n        rx: \"2\"\n      }), /*#__PURE__*/_react[\"default\"].createElement(\"path\", {\n        d: \"M2,0 L28,0 L28,0 L28,28 L2,28 C0.8954305,28 1.87533573e-15,27.1045695 0,26 L0,2 C-3.57315355e-16,0.8954305 0.8954305,-1.91384796e-17 2,0 Z\",\n        fill: \"#5582F3\",\n        \"fill-rule\": \"nonzero\"\n      })), /*#__PURE__*/_react[\"default\"].createElement(\"path\", {\n        d: \"M21,7 L21,12 L16,12 L16,10 L14.5,10 L14.5,18 L16,18 L16,16 L21,16 L21,21 L16,21 L16,19 L13.5,19 L13.5,14.5 L12,14.5 L12,16.5 L7,16.5 L7,11.5 L12,11.5 L12,13.5 L13.5,13.5 L13.5,9 L16,9 L16,7 L21,7 Z\",\n        fill: \"#FFFFFF\"\n      }), /*#__PURE__*/_react[\"default\"].createElement(\"path\", {\n        d: \"M37,13.5 L41.5,13.5 L41.5,12 L39.5,12 L39.5,7 L44.5,7 L44.5,12 L42.5,12 L42.5,13.5 L47,13.5 L47,16 L49,16 L49,21 L44,21 L44,16 L46,16 L46,14.5 L38,14.5 L38,16 L40,16 L40,21 L35,21 L35,16 L37,16 L37,13.5 Z\",\n        fill: \"#5582F3\",\n        \"fill-rule\": \"nonzero\"\n      })));\n      var verticalDisplay = /*#__PURE__*/_react[\"default\"].createElement(\"svg\", {\n        width: \"56px\",\n        height: \"28px\",\n        viewBox: \"0 0 56 28\",\n        version: \"1.1\",\n        xmlns: \"http://www.w3.org/2000/svg\"\n      }, /*#__PURE__*/_react[\"default\"].createElement(\"g\", {\n        stroke: \"none\",\n        \"stroke-width\": \"1\",\n        fill: \"none\",\n        \"fill-rule\": \"evenodd\"\n      }, /*#__PURE__*/_react[\"default\"].createElement(\"g\", null, /*#__PURE__*/_react[\"default\"].createElement(\"rect\", {\n        stroke: \"#5582F3\",\n        fill: \"#FFFFFF\",\n        x: \"0.5\",\n        y: \"0.5\",\n        width: \"55\",\n        height: \"27\",\n        rx: \"2\"\n      }), /*#__PURE__*/_react[\"default\"].createElement(\"path\", {\n        d: \"M30,0 L56,0 L56,0 L56,28 L30,28 C28.8954305,28 28,27.1045695 28,26 L28,2 C28,0.8954305 28.8954305,-1.91384796e-17 30,0 Z\",\n        fill: \"#5582F3\",\n        \"fill-rule\": \"nonzero\",\n        transform: \"translate(42.000000, 14.000000) scale(-1, 1) translate(-42.000000, -14.000000) \"\n      })), /*#__PURE__*/_react[\"default\"].createElement(\"path\", {\n        d: \"M37,13.5 L41.5,13.5 L41.5,12 L39.5,12 L39.5,7 L44.5,7 L44.5,12 L42.5,12 L42.5,13.5 L47,13.5 L47,16 L49,16 L49,21 L44,21 L44,16 L46,16 L46,14.5 L38,14.5 L38,16 L40,16 L40,21 L35,21 L35,16 L37,16 L37,13.5 Z\",\n        fill: \"#FFFFFF\",\n        \"fill-rule\": \"nonzero\"\n      }), /*#__PURE__*/_react[\"default\"].createElement(\"path\", {\n        d: \"M21,7 L21,12 L16,12 L16,10 L14.5,10 L14.5,18 L16,18 L16,16 L21,16 L21,21 L16,21 L16,19 L13.5,19 L13.5,14.5 L12,14.5 L12,16.5 L7,16.5 L7,11.5 L12,11.5 L12,13.5 L13.5,13.5 L13.5,9 L16,9 L16,7 L21,7 Z\",\n        fill: \"#5582F3\"\n      })));\n      return /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _FloatToolbar2[\"default\"].floatButtons\n      }, this.state.horizontal ? horizontalDisplay : verticalDisplay, /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: (0, _classnames[\"default\"])(_FloatToolbar2[\"default\"].button, this.state.horizontalCls),\n        onClick: function onClick(e) {\n          _this4.floatButtonClicked(e);\n        }\n      }), /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: (0, _classnames[\"default\"])(_FloatToolbar2[\"default\"].button, _FloatToolbar2[\"default\"].right, this.state.verticalCls),\n        onClick: function onClick(e) {\n          _this4.floatButtonClicked(e);\n        }\n      }));\n    }\n  }, {\n    key: \"floatButtonClicked\",\n    value: function floatButtonClicked(evt) {\n      var icon = evt.currentTarget;\n      if (!_mxGraphUtils[\"default\"].hasClass(icon, _FloatToolbar2[\"default\"].clickable)) {\n        return;\n      }\n      var horizontal = this.state.horizontal;\n      var horizontalCls = '';\n      var verticalCls = '';\n      if (horizontal) {\n        horizontal = false;\n        verticalCls = '';\n        horizontalCls = _FloatToolbar2[\"default\"].clickable;\n      } else {\n        horizontal = true;\n        horizontalCls = '';\n        verticalCls = _FloatToolbar2[\"default\"].clickable;\n      }\n      if (this.props.isServerRender) {\n        this.props.showLoading(true);\n        this.props.graph.invokeCustomEvent('switchLayout', {\n          horizontal: horizontal\n        });\n      } else {\n        this.props.switchLayout(horizontal);\n      }\n      this.setState({\n        horizontal: horizontal,\n        horizontalCls: horizontalCls,\n        verticalCls: verticalCls\n      });\n    }\n  }]);\n  return FloatButtons;\n}(_react.Component);\nvar _default = exports[\"default\"] = FloatToolbar;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/components/FloatToolbar.js?");

/***/ }),

/***/ "./src/workflow/components/GraphComponent.js":
/*!***************************************************!*\
  !*** ./src/workflow/components/GraphComponent.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\n__webpack_require__(/*! core-js/modules/es.symbol.js */ \"../../node_modules/core-js/modules/es.symbol.js\");\n__webpack_require__(/*! core-js/modules/es.symbol.description.js */ \"../../node_modules/core-js/modules/es.symbol.description.js\");\n__webpack_require__(/*! core-js/modules/es.symbol.iterator.js */ \"../../node_modules/core-js/modules/es.symbol.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.symbol.to-primitive.js */ \"../../node_modules/core-js/modules/es.symbol.to-primitive.js\");\n__webpack_require__(/*! core-js/modules/es.array.iterator.js */ \"../../node_modules/core-js/modules/es.array.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.date.to-primitive.js */ \"../../node_modules/core-js/modules/es.date.to-primitive.js\");\n__webpack_require__(/*! core-js/modules/es.number.constructor.js */ \"../../node_modules/core-js/modules/es.number.constructor.js\");\n__webpack_require__(/*! core-js/modules/es.object.create.js */ \"../../node_modules/core-js/modules/es.object.create.js\");\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\n__webpack_require__(/*! core-js/modules/es.object.get-own-property-descriptor.js */ \"../../node_modules/core-js/modules/es.object.get-own-property-descriptor.js\");\n__webpack_require__(/*! core-js/modules/es.object.get-prototype-of.js */ \"../../node_modules/core-js/modules/es.object.get-prototype-of.js\");\n__webpack_require__(/*! core-js/modules/es.object.to-string.js */ \"../../node_modules/core-js/modules/es.object.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.reflect.construct.js */ \"../../node_modules/core-js/modules/es.reflect.construct.js\");\n__webpack_require__(/*! core-js/modules/es.string.iterator.js */ \"../../node_modules/core-js/modules/es.string.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.weak-map.js */ \"../../node_modules/core-js/modules/es.weak-map.js\");\n__webpack_require__(/*! core-js/modules/web.dom-collections.iterator.js */ \"../../node_modules/core-js/modules/web.dom-collections.iterator.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.function.bind.js */ \"../../node_modules/core-js/modules/es.function.bind.js\");\n__webpack_require__(/*! core-js/modules/es.object.set-prototype-of.js */ \"../../node_modules/core-js/modules/es.object.set-prototype-of.js\");\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"webpack/sharing/consume/default/react/react?dca2\"));\nvar _mxEventSource = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxEventSource.js */ \"./src/workflow/mxClient/mxEventSource.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction _getRequireWildcardCache(e) { if (\"function\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return { \"default\": e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\"default\" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n[\"default\"] = e, t && t.set(e, n), n; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nvar GraphComponent = /*#__PURE__*/function (_Component) {\n  _inherits(GraphComponent, _Component);\n  function GraphComponent(props) {\n    var _this;\n    _classCallCheck(this, GraphComponent);\n    _this = _callSuper(this, GraphComponent, [props]);\n    _this.eventListeners = null;\n    _this.eventsEnabled = true;\n    _this.eventSource = null;\n    return _this;\n  }\n  _createClass(GraphComponent, [{\n    key: \"isEventsEnabled\",\n    value: function isEventsEnabled() {\n      return this.eventsEnabled;\n    }\n  }, {\n    key: \"setEventsEnabled\",\n    value: function setEventsEnabled(value) {\n      this.eventsEnabled = value;\n    }\n  }, {\n    key: \"getEventSource\",\n    value: function getEventSource() {\n      return this.eventSource;\n    }\n  }, {\n    key: \"setEventSource\",\n    value: function setEventSource(value) {\n      this.eventSource = value;\n    }\n  }, {\n    key: \"addListener\",\n    value: function addListener(name, funct) {\n      _mxEventSource[\"default\"].prototype.addListener.call(this, name, funct);\n    }\n  }, {\n    key: \"removeListener\",\n    value: function removeListener(funct) {\n      _mxEventSource[\"default\"].prototype.removeListener.call(this, funct);\n    }\n  }, {\n    key: \"fireEvent\",\n    value: function fireEvent(evt, sender) {\n      _mxEventSource[\"default\"].prototype.fireEvent.call(this, evt, sender);\n    }\n  }]);\n  return GraphComponent;\n}(_react.Component);\nvar _default = exports[\"default\"] = GraphComponent;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/components/GraphComponent.js?");

/***/ }),

/***/ "./src/workflow/components/KDWorkflow.js":
/*!***********************************************!*\
  !*** ./src/workflow/components/KDWorkflow.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\n__webpack_require__(/*! core-js/modules/es.symbol.js */ \"../../node_modules/core-js/modules/es.symbol.js\");\n__webpack_require__(/*! core-js/modules/es.symbol.description.js */ \"../../node_modules/core-js/modules/es.symbol.description.js\");\n__webpack_require__(/*! core-js/modules/es.symbol.iterator.js */ \"../../node_modules/core-js/modules/es.symbol.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.symbol.to-primitive.js */ \"../../node_modules/core-js/modules/es.symbol.to-primitive.js\");\n__webpack_require__(/*! core-js/modules/es.array.iterator.js */ \"../../node_modules/core-js/modules/es.array.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.date.to-primitive.js */ \"../../node_modules/core-js/modules/es.date.to-primitive.js\");\n__webpack_require__(/*! core-js/modules/es.number.constructor.js */ \"../../node_modules/core-js/modules/es.number.constructor.js\");\n__webpack_require__(/*! core-js/modules/es.object.create.js */ \"../../node_modules/core-js/modules/es.object.create.js\");\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\n__webpack_require__(/*! core-js/modules/es.object.get-own-property-descriptor.js */ \"../../node_modules/core-js/modules/es.object.get-own-property-descriptor.js\");\n__webpack_require__(/*! core-js/modules/es.object.get-prototype-of.js */ \"../../node_modules/core-js/modules/es.object.get-prototype-of.js\");\n__webpack_require__(/*! core-js/modules/es.object.to-string.js */ \"../../node_modules/core-js/modules/es.object.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.reflect.construct.js */ \"../../node_modules/core-js/modules/es.reflect.construct.js\");\n__webpack_require__(/*! core-js/modules/es.string.iterator.js */ \"../../node_modules/core-js/modules/es.string.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.weak-map.js */ \"../../node_modules/core-js/modules/es.weak-map.js\");\n__webpack_require__(/*! core-js/modules/web.dom-collections.iterator.js */ \"../../node_modules/core-js/modules/web.dom-collections.iterator.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.function.bind.js */ \"../../node_modules/core-js/modules/es.function.bind.js\");\n__webpack_require__(/*! core-js/modules/es.object.set-prototype-of.js */ \"../../node_modules/core-js/modules/es.object.set-prototype-of.js\");\n__webpack_require__(/*! core-js/modules/web.timers.js */ \"../../node_modules/core-js/modules/web.timers.js\");\nvar _init = _interopRequireDefault(__webpack_require__(/*! ../init.js */ \"./src/workflow/init.js\"));\nvar _sanitizerMin = _interopRequireDefault(__webpack_require__(/*! ../vendor/sanitizer.min.js */ \"./src/workflow/vendor/sanitizer.min.js\"));\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"webpack/sharing/consume/default/react/react?dca2\"));\nvar _propTypes = _interopRequireDefault(__webpack_require__(/*! prop-types */ \"../../node_modules/prop-types/index.js\"));\nvar _EditorUi = _interopRequireDefault(__webpack_require__(/*! ./EditorUi */ \"./src/workflow/components/EditorUi.js\"));\nvar _redux = __webpack_require__(/*! redux */ \"../../node_modules/redux/es/index.js\");\nvar _reactRedux = __webpack_require__(/*! react-redux */ \"../../node_modules/react-redux/es/index.js\");\nvar _reducers = _interopRequireDefault(__webpack_require__(/*! ../reducers */ \"./src/workflow/reducers/index.js\"));\nvar _workflowAction = __webpack_require__(/*! ../actions/workflowAction */ \"./src/workflow/actions/workflowAction.js\");\nvar _reduxThunk = _interopRequireDefault(__webpack_require__(/*! redux-thunk */ \"../../node_modules/redux-thunk/es/index.js\"));\nvar _serverproperties = __webpack_require__(/*! ../../constant/serverproperties */ \"./src/constant/serverproperties.js\");\nvar _appModelFunction = __webpack_require__(/*! ../../model/appModelFunction */ \"./src/model/appModelFunction.js\");\nvar _memoryCacher = __webpack_require__(/*! ../../model/memoryCacher */ \"./src/model/memoryCacher.js\");\nfunction _getRequireWildcardCache(e) { if (\"function\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return { \"default\": e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\"default\" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n[\"default\"] = e, t && t.set(e, n), n; }\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nvar exceptionHandler = function exceptionHandler(store) {\n  return function (next) {\n    return function (action) {\n      try {\n        return next(action);\n      } catch (e) {\n        //TODO:\n        console.warn('There is something wrong with dispatch action: ', action);\n        throw e;\n      }\n    };\n  };\n};\nvar createStoreWithMiddleware = (0, _redux.applyMiddleware)(_reduxThunk[\"default\"], exceptionHandler)(_redux.createStore);\nvar KDWorkflow = /*#__PURE__*/function (_Component) {\n  _inherits(KDWorkflow, _Component);\n  function KDWorkflow(props) {\n    _classCallCheck(this, KDWorkflow);\n    return _callSuper(this, KDWorkflow, [props]);\n  }\n  _createClass(KDWorkflow, [{\n    key: \"getChildContext\",\n    value: function getChildContext() {\n      var _this = this;\n      return {\n        dispatch: this.props.dispatch,\n        model: this.props.model,\n        invokeAction: function invokeAction() {\n          return _this.props.dispatch(_workflowAction.property_editor_click.apply(void 0, arguments));\n        },\n        modelType: this.modelType,\n        modelVer: this.modelver || '1.0',\n        setPostData: function setPostData() {\n          return _this.props.dispatch(_workflowAction.setPostData.apply(void 0, arguments));\n        }\n      };\n    }\n  }, {\n    key: \"componentWillMount\",\n    value: function componentWillMount() {\n      this.modelType = 'WorkflowModel'; //this.props.model.appmodel.getFormConfig(this.props.model.pageId).clientParams.modeltype;\n      this.modelver = null; //this.props.model.appmodel.getFormConfig(this.props.model.pageId).clientParams.modelver;\n      this.store = createStoreWithMiddleware(_reducers[\"default\"]);\n      //TODO: delete \n      window.wfStore = this.store;\n      var _this$props$model = this.props.model,\n        pageId = _this$props$model.pageId,\n        key = _this$props$model.key;\n      setTimeout(function () {\n        return (0, _memoryCacher.setControlMount)(pageId, key, true);\n      }, 0);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var modelState = this.props.model.state;\n      var pageId = this.props.model.pageId;\n      var open_args = (0, _appModelFunction.getDataProperty)(pageId, 'workflowdesigner', ['open_args', this.props.model.key])(modelState);\n      var subProcData = (0, _appModelFunction.getDataProperty)(pageId, 'workflowdesigner', 'subprocess')(modelState);\n      var approvalRecords = (0, _appModelFunction.getDataProperty)(pageId, 'workflowdesigner', 'approvalRecords')(modelState);\n      var coordinateRecords = (0, _appModelFunction.getDataProperty)(pageId, 'workflowdesigner', 'showCoordinateInfo')(modelState);\n      var billSummaryInfo = (0, _appModelFunction.getDataProperty)(pageId, 'workflowdesigner', 'showBillSummaryInfo')(modelState);\n      var config = (0, _appModelFunction.getFormConfig)(this.props.model.pageId)(modelState);\n      var initialData = null;\n      var editable = this.props.model.meta.get(_serverproperties.EDITABLE);\n      var showDetails = this.props.model.meta.get('showNodeDetails');\n      if (open_args) {\n        initialData = open_args[2];\n        if (initialData.updateProcInstId) {\n          config.clientParams.procInstId = initialData.procInstId;\n        }\n      }\n      return /*#__PURE__*/_react[\"default\"].createElement(_reactRedux.Provider, {\n        store: this.store\n      }, /*#__PURE__*/_react[\"default\"].createElement(_EditorUi[\"default\"], {\n        initialData: initialData,\n        showNodeDetails: showDetails,\n        editable: editable,\n        config: config,\n        subProcData: subProcData,\n        approvalRecords: approvalRecords,\n        coordinateRecords: coordinateRecords,\n        billSummaryInfo: billSummaryInfo\n      }));\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      var _this$props$model2 = this.props.model,\n        pageId = _this$props$model2.pageId,\n        key = _this$props$model2.key;\n      (0, _memoryCacher.setControlMount)(pageId, key, false);\n    }\n  }]);\n  return KDWorkflow;\n}(_react.Component);\nKDWorkflow.childContextTypes = {\n  dispatch: _propTypes[\"default\"].func,\n  model: _propTypes[\"default\"].object,\n  invokeAction: _propTypes[\"default\"].func,\n  modelType: _propTypes[\"default\"].string,\n  modelVer: _propTypes[\"default\"].string,\n  setPostData: _propTypes[\"default\"].func\n};\nvar _default = exports[\"default\"] = KDWorkflow;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/components/KDWorkflow.js?");

/***/ }),

/***/ "./src/workflow/components/KDYzjChat.js":
/*!**********************************************!*\
  !*** ./src/workflow/components/KDYzjChat.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\n__webpack_require__(/*! core-js/modules/es.symbol.js */ \"../../node_modules/core-js/modules/es.symbol.js\");\n__webpack_require__(/*! core-js/modules/es.symbol.description.js */ \"../../node_modules/core-js/modules/es.symbol.description.js\");\n__webpack_require__(/*! core-js/modules/es.symbol.iterator.js */ \"../../node_modules/core-js/modules/es.symbol.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.symbol.to-primitive.js */ \"../../node_modules/core-js/modules/es.symbol.to-primitive.js\");\n__webpack_require__(/*! core-js/modules/es.array.iterator.js */ \"../../node_modules/core-js/modules/es.array.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.date.to-primitive.js */ \"../../node_modules/core-js/modules/es.date.to-primitive.js\");\n__webpack_require__(/*! core-js/modules/es.number.constructor.js */ \"../../node_modules/core-js/modules/es.number.constructor.js\");\n__webpack_require__(/*! core-js/modules/es.object.create.js */ \"../../node_modules/core-js/modules/es.object.create.js\");\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\n__webpack_require__(/*! core-js/modules/es.object.get-own-property-descriptor.js */ \"../../node_modules/core-js/modules/es.object.get-own-property-descriptor.js\");\n__webpack_require__(/*! core-js/modules/es.object.get-prototype-of.js */ \"../../node_modules/core-js/modules/es.object.get-prototype-of.js\");\n__webpack_require__(/*! core-js/modules/es.object.to-string.js */ \"../../node_modules/core-js/modules/es.object.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.reflect.construct.js */ \"../../node_modules/core-js/modules/es.reflect.construct.js\");\n__webpack_require__(/*! core-js/modules/es.string.iterator.js */ \"../../node_modules/core-js/modules/es.string.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.weak-map.js */ \"../../node_modules/core-js/modules/es.weak-map.js\");\n__webpack_require__(/*! core-js/modules/web.dom-collections.iterator.js */ \"../../node_modules/core-js/modules/web.dom-collections.iterator.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.function.bind.js */ \"../../node_modules/core-js/modules/es.function.bind.js\");\n__webpack_require__(/*! core-js/modules/es.object.set-prototype-of.js */ \"../../node_modules/core-js/modules/es.object.set-prototype-of.js\");\n__webpack_require__(/*! core-js/modules/web.timers.js */ \"../../node_modules/core-js/modules/web.timers.js\");\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"webpack/sharing/consume/default/react/react?dca2\"));\nvar _propTypes = _interopRequireDefault(__webpack_require__(/*! prop-types */ \"../../node_modules/prop-types/index.js\"));\nvar _appModelFunction = __webpack_require__(/*! ../../model/appModelFunction */ \"./src/model/appModelFunction.js\");\nvar _ApprovalRecord = _interopRequireDefault(__webpack_require__(/*! ../css/ApprovalRecord.less */ \"./src/workflow/css/ApprovalRecord.less\"));\nvar _immutable = __webpack_require__(/*! immutable */ \"webpack/sharing/consume/default/immutable/immutable?f2ca\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction _getRequireWildcardCache(e) { if (\"function\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return { \"default\": e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\"default\" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n[\"default\"] = e, t && t.set(e, n), n; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction listenTray() {\n  var yzjChatWindow = $(\"#im-chat-container\");\n  var cls = _ApprovalRecord[\"default\"].chatPosition;\n  if (yzjChatWindow.length > 0 && yzjChatWindow.hasClass(cls)) {\n    yzjChatWindow.removeClass(cls);\n  }\n}\nvar YzjChat = exports[\"default\"] = /*#__PURE__*/function (_Component) {\n  _inherits(YzjChat, _Component);\n  function YzjChat(props) {\n    _classCallCheck(this, YzjChat);\n    return _callSuper(this, YzjChat, [props]);\n  }\n  _createClass(YzjChat, [{\n    key: \"_openChatWindow\",\n    value: function _openChatWindow(groupId) {\n      var tray = $(\".im-tray\");\n      var cls = _ApprovalRecord[\"default\"].chatPosition;\n      tray.unbind(\"click\", listenTray);\n      window.pcyzjShare.openChat({\n        groupId: groupId\n      });\n      $(\"#im-session-left\").toggleClass('im-listAppear');\n      if (tray.length > 0) {\n        $(\"#im-chat-container\").addClass(cls);\n        tray.bind(\"click\", listenTray);\n      }\n    }\n  }, {\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(nextProps, nextState) {\n      var model = this.props.model || {};\n      var m = model.state;\n      var nextModel = nextProps.model || {};\n      var nextM = nextModel.state;\n      return !(0, _immutable.is)((0, _appModelFunction.getDevportalParams)(model.pageId, \"yzjParam\")(m), (0, _appModelFunction.getDevportalParams)(nextModel.pageId, \"yzjParam\")(nextM));\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var model = this.props.model || {};\n      var m = model.state;\n      var that = this;\n      var yzjParam = (0, _appModelFunction.getDevportalParams)(model.pageId, \"yzjParam\")(m);\n      if (yzjParam && yzjParam.groupId) {\n        if ($(\"#\" + yzjParam.groupId).length > 0) {\n          that._openChatWindow(yzjParam.groupId);\n        } else {\n          setTimeout(function () {\n            that._openChatWindow(yzjParam.groupId);\n          }, 5000);\n        }\n      }\n      return null;\n    }\n  }]);\n  return YzjChat;\n}(_react.Component);\n\n//# sourceURL=webpack://bos-platform/./src/workflow/components/KDYzjChat.js?");

/***/ }),

/***/ "./src/workflow/constants/actionNames.js":
/*!***********************************************!*\
  !*** ./src/workflow/constants/actionNames.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.update_ui_metadata = exports.show_floatlayer = exports.set_update_control = exports.set_ui_metadata = exports.set_select_control = exports.hide_floatlayer = exports.clean_activated = exports.activate_cell = void 0;\nvar set_ui_metadata = exports.set_ui_metadata = 'set_ui_metadata';\nvar update_ui_metadata = exports.update_ui_metadata = 'update_ui_metadata';\nvar set_select_control = exports.set_select_control = 'set_select_control';\nvar set_update_control = exports.set_update_control = 'set_update_control';\nvar activate_cell = exports.activate_cell = 'activate_cell';\nvar clean_activated = exports.clean_activated = 'clean_activated';\nvar show_floatlayer = exports.show_floatlayer = 'show_floatlayer';\nvar hide_floatlayer = exports.hide_floatlayer = 'hide_floatlayer';\n\n//# sourceURL=webpack://bos-platform/./src/workflow/constants/actionNames.js?");

/***/ }),

/***/ "./src/workflow/constants/index.js":
/*!*****************************************!*\
  !*** ./src/workflow/constants/index.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.STORE_KEY_PREFIX = exports.PROCESS_DIAGRAM_TYPE = exports.PROCESS_DIAGRAM_GROUP = exports.EXTENDED_CONTROL = void 0;\nvar STORE_KEY_PREFIX = exports.STORE_KEY_PREFIX = 'workflowdesigner';\n//以下两行对应后台模型配置文件中--流程属性\nvar PROCESS_DIAGRAM_GROUP = exports.PROCESS_DIAGRAM_GROUP = 'ProcessControl';\nvar PROCESS_DIAGRAM_TYPE = exports.PROCESS_DIAGRAM_TYPE = 'Diagram';\n//后端配置文件中扩展组ID\nvar EXTENDED_CONTROL = exports.EXTENDED_CONTROL = 'ExtendControl';\n\n//# sourceURL=webpack://bos-platform/./src/workflow/constants/index.js?");

/***/ }),

/***/ "./src/workflow/constants/mxGraphConstant.js":
/*!***************************************************!*\
  !*** ./src/workflow/constants/mxGraphConstant.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.zoom_min = exports.zoom_max = exports.debounceTime = exports.compactUi = exports.SIDEBAR = exports.MENU = exports.INITCLASS = exports.ICON_ZOOMOUT_HOVER = exports.ICON_ZOOMOUT = exports.ICON_ZOOMIN_HOVER = exports.ICON_ZOOMIN = exports.ICON_RETRACT_HOVER = exports.ICON_RETRACT = exports.ICON_DOWNLOAD_HOVER = exports.ICON_DOWNLOAD = exports.ICON_COMMENT_HOVER = exports.ICON_COMMENT = exports.EVENT = exports.EDITORUI = exports.EDITOR = exports.CURRENT_SUBPROCESS_KEY = exports.CURRENT_SUBPROCESS_ID = exports.CONFIG_PANEL_ID = void 0;\nvar _mxClient = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxClient.js */ \"./src/workflow/mxClient/mxClient.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nvar compactUi = exports.compactUi = true;\nvar debounceTime = exports.debounceTime = 1000;\nvar zoom_min = exports.zoom_min = 0.5;\nvar zoom_max = exports.zoom_max = 2;\nvar MENU = exports.MENU = {\n  defaultFont: 'Helvetica',\n  defaultFontSize: '12',\n  defaultMenuItems: ['file', 'edit', 'view', 'arrange', 'extras', 'help'],\n  defaultFonts: ['Helvetica', 'Verdana', 'Times New Roman', 'Garamond', 'Comic Sans MS', 'Courier New', 'Georgia', 'Lucida Console', 'Tahoma']\n};\nvar SIDEBAR = exports.SIDEBAR = {\n  collapsedImage: !_mxClient[\"default\"].IS_SVG ? IMAGE_PATH + '/collapsed.gif' : 'data:image/gif,base64,R0lGODlhDQANAIABAJmZmf///yH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS4wLWMwNjAgNjEuMTM0Nzc3LCAyMDEwLzAyLzEyLTE3OjMyOjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozNUQyRTJFNjZGNUYxMUU1QjZEOThCNDYxMDQ2MzNCQiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozNUQyRTJFNzZGNUYxMUU1QjZEOThCNDYxMDQ2MzNCQiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjFERjc3MEUxNkY1RjExRTVCNkQ5OEI0NjEwNDYzM0JCIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjFERjc3MEUyNkY1RjExRTVCNkQ5OEI0NjEwNDYzM0JCIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkEAQAAAQAsAAAAAA0ADQAAAhSMj6lrwAjcC1GyahV+dcZJgeIIFgA7',\n  expandedImage: !_mxClient[\"default\"].IS_SVG ? IMAGE_PATH + '/expanded.gif' : 'data:image/gif,base64,R0lGODlhDQANAIABAJmZmf///yH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS4wLWMwNjAgNjEuMTM0Nzc3LCAyMDEwLzAyLzEyLTE3OjMyOjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDoxREY3NzBERjZGNUYxMUU1QjZEOThCNDYxMDQ2MzNCQiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDoxREY3NzBFMDZGNUYxMUU1QjZEOThCNDYxMDQ2MzNCQiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjFERjc3MERENkY1RjExRTVCNkQ5OEI0NjEwNDYzM0JCIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjFERjc3MERFNkY1RjExRTVCNkQ5OEI0NjEwNDYzM0JCIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkEAQAAAQAsAAAAAA0ADQAAAhGMj6nL3QAjVHIu6azbvPtWAAA7',\n  tooltipImage: !_mxClient[\"default\"].IS_SVG ? IMAGE_PATH + '/tooltip.png' : 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAbCAMAAAB7jU7LAAAACVBMVEX///+ZmZn///9Y2COLAAAAA3RSTlP//wDXyg1BAAAAOElEQVR42mXQMQ4AMAgDsWv//+iutcJmIQSk+9dJpVKpVCqVSqVSqZTdncWzF8/NeP7FkxWenPEDOnUBiL3jWx0AAAAASUVORK5CYII=',\n  searchImage: !_mxClient[\"default\"].IS_SVG ? IMAGE_PATH + '/search.png' : 'data:image/png,base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAYAAABWdVznAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAEaSURBVHjabNGxS5VxFIfxz71XaWuQUJCG/gCHhgTD9VpEETg4aMOlQRp0EoezObgcd220KQiXmpretTAHQRBdojlQEJyukPdt+b1ywfvAGc7wnHP4nlZd1yKijQW8xzNc4Su+ZOYfQ3T6/f4YNvEJYzjELXp4VVXVz263+7cR2niBxAFeZ2YPi3iHR/gYERPDwhpOsd6sz8x/mfkNG3iOlWFhFj8y89J9KvzGXER0GuEaD42mgwHqUtoljbcRsTBCeINpfM/MgZLKPpaxFxGbOCqDXmILN7hoJrTKH+axhxmcYRxP0MIDnOBDZv5q1XUNIuJxifJp+UNV7t7BFM6xeic0RMQ4Bpl5W/ol7GISx/eEUUTECrbx+f8A8xhiZht9zsgAAAAASUVORK5CYII=',\n  enableTooltips: true,\n  tooltipBorder: 16,\n  tooltipDelay: 300,\n  dropTargetDelay: 200,\n  gearImage: '/clipart/Gear_128x128.png',\n  thumbWidth: 54,\n  thumbHeight: 54,\n  thumbPadding: document.documentMode >= 5 ? 0 : 1,\n  thumbBorder: 2,\n  sidebarTitleSize: 9,\n  sidebarTitles: false,\n  tooltipTitles: true,\n  maxTooltipWidth: 400,\n  maxTooltipHeight: 400,\n  addStencilsToIndex: true,\n  defaultImageWidth: 80,\n  defaultImageHeight: 80\n};\nvar EDITOR = exports.EDITOR = {\n  originalNoForeignObject: _mxClient[\"default\"].NO_FO\n};\nvar EDITORUI = exports.EDITORUI = {\n  splitSize: _mxClient[\"default\"].IS_TOUCH || _mxClient[\"default\"].IS_POINTER ? 14 : 8,\n  menubarHeight: 30,\n  formatEnabled: true,\n  formatWidth: 240,\n  toolbarHeight: 34,\n  footerHeight: 28,\n  editButtonLink: null,\n  hsplitPosition: screen.width <= 500 ? 116 : 204,\n  allowAnimation: true\n};\nvar EVENT = exports.EVENT = {\n  CHANGE: 'change',\n  CELLSINSERTED: 'cellsInserted',\n  PARENT_CHANGED: 'parentChanged',\n  REMOVE_CELLS: 'removeCells',\n  AFTER_DELETE_CELLS: 'afterDeleteCells',\n  FOLD_CELLS: 'foldCells',\n  AFTER_FOLD_CELLS: 'afterFoldCells',\n  BEFORE_PASTE_CELLS: 'beforePasteCells',\n  AFTER_PASTE_CELLS: 'afterPasteCells'\n};\nvar INITCLASS = exports.INITCLASS = 'initClass';\nvar CURRENT_SUBPROCESS_ID = exports.CURRENT_SUBPROCESS_ID = 'currentSubProcessId';\nvar CURRENT_SUBPROCESS_KEY = exports.CURRENT_SUBPROCESS_KEY = 'currentSubProcessKey';\n\n//节点属性配置页面容器ID\nvar CONFIG_PANEL_ID = exports.CONFIG_PANEL_ID = 'rightpanel';\nvar ICON_RETRACT = exports.ICON_RETRACT = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTNweCIgaGVpZ2h0PSIxNHB4IiB2aWV3Qm94PSIwIDAgMTMgMTQiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8ZyBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4KICAgICAgICA8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTMzMS4wMDAwMDAsIC0xOTAuMDAwMDAwKSIgZmlsbD0iIzdGOTNCQyI+CiAgICAgICAgICAgIDxwYXRoIGQ9Ik0xMzMxLjUsMTkxLjUgTDEzMzIuNSwxOTEuNSBMMTMzMi41LDE5Mi41IEwxMzMxLjUsMTkyLjUgTDEzMzEuNSwxOTEuNSBaIE0xMzMwLjUsMTkwLjUgTDEzMzEuNSwxOTAuNSBMMTMzMS41LDE5MS41IEwxMzMwLjUsMTkxLjUgTDEzMzAuNSwxOTAuNSBaIE0xMzM1LjUsMTk1LjUgTDEzMzYuNSwxOTUuNSBMMTMzNi41LDE5Ni41IEwxMzM1LjUsMTk2LjUgTDEzMzUuNSwxOTUuNSBaIE0xMzMzLjUsMTkzLjUgTDEzMzQuNSwxOTMuNSBMMTMzNC41LDE5NC41IEwxMzMzLjUsMTk0LjUgTDEzMzMuNSwxOTMuNSBaIE0xMzMyLjUsMTkyLjUgTDEzMzMuNSwxOTIuNSBMMTMzMy41LDE5My41IEwxMzMyLjUsMTkzLjUgTDEzMzIuNSwxOTIuNSBaIE0xMzM2LjUsMTk2LjUgTDEzMzcuNSwxOTYuNSBMMTMzNy41LDE5Ny41IEwxMzM2LjUsMTk3LjUgTDEzMzYuNSwxOTYuNSBaIE0xMzM0LjUsMTk0LjUgTDEzMzUuNSwxOTQuNSBMMTMzNS41LDE5NS41IEwxMzM0LjUsMTk1LjUgTDEzMzQuNSwxOTQuNSBaIE0xMzQ0LjUsMTkwLjUgTDEzNDQuNSwxOTEuNSBMMTM0My41LDE5MS41IEwxMzQzLjUsMTkwLjUgTDEzNDQuNSwxOTAuNSBaIE0xMzQwLjUsMTk0LjUgTDEzNDAuNSwxOTUuNSBMMTMzOS41LDE5NS41IEwxMzM5LjUsMTk0LjUgTDEzNDAuNSwxOTQuNSBaIE0xMzQyLjUsMTkyLjUgTDEzNDIuNSwxOTMuNSBMMTM0MS41LDE5My41IEwxMzQxLjUsMTkyLjUgTDEzNDIuNSwxOTIuNSBaIE0xMzM4LjUsMTk2LjUgTDEzMzguNSwxOTcuNSBMMTMzNy41LDE5Ny41IEwxMzM3LjUsMTk2LjUgTDEzMzguNSwxOTYuNSBaIE0xMzQzLjUsMTkxLjUgTDEzNDMuNSwxOTIuNSBMMTM0Mi41LDE5Mi41IEwxMzQyLjUsMTkxLjUgTDEzNDMuNSwxOTEuNSBaIE0xMzM5LjUsMTk1LjUgTDEzMzkuNSwxOTYuNSBMMTMzOC41LDE5Ni41IEwxMzM4LjUsMTk1LjUgTDEzMzkuNSwxOTUuNSBaIE0xMzQxLjUsMTkzLjUgTDEzNDEuNSwxOTQuNSBMMTM0MC41LDE5NC41IEwxMzQwLjUsMTkzLjUgTDEzNDEuNSwxOTMuNSBaIE0xMzMxLjUsMTk3LjUgTDEzMzIuNSwxOTcuNSBMMTMzMi41LDE5OC41IEwxMzMxLjUsMTk4LjUgTDEzMzEuNSwxOTcuNSBaIE0xMzMwLjUsMTk2LjUgTDEzMzEuNSwxOTYuNSBMMTMzMS41LDE5Ny41IEwxMzMwLjUsMTk3LjUgTDEzMzAuNSwxOTYuNSBaIE0xMzM1LjUsMjAxLjUgTDEzMzYuNSwyMDEuNSBMMTMzNi41LDIwMi41IEwxMzM1LjUsMjAyLjUgTDEzMzUuNSwyMDEuNSBaIE0xMzMzLjUsMTk5LjUgTDEzMzQuNSwxOTkuNSBMMTMzNC41LDIwMC41IEwxMzMzLjUsMjAwLjUgTDEzMzMuNSwxOTkuNSBaIE0xMzMyLjUsMTk4LjUgTDEzMzMuNSwxOTguNSBMMTMzMy41LDE5OS41IEwxMzMyLjUsMTk5LjUgTDEzMzIuNSwxOTguNSBaIE0xMzM2LjUsMjAyLjUgTDEzMzcuNSwyMDIuNSBMMTMzNy41LDIwMy41IEwxMzM2LjUsMjAzLjUgTDEzMzYuNSwyMDIuNSBaIE0xMzM0LjUsMjAwLjUgTDEzMzUuNSwyMDAuNSBMMTMzNS41LDIwMS41IEwxMzM0LjUsMjAxLjUgTDEzMzQuNSwyMDAuNSBaIE0xMzQ0LjUsMTk2LjUgTDEzNDQuNSwxOTcuNSBMMTM0My41LDE5Ny41IEwxMzQzLjUsMTk2LjUgTDEzNDQuNSwxOTYuNSBaIE0xMzQwLjUsMjAwLjUgTDEzNDAuNSwyMDEuNSBMMTMzOS41LDIwMS41IEwxMzM5LjUsMjAwLjUgTDEzNDAuNSwyMDAuNSBaIE0xMzQyLjUsMTk4LjUgTDEzNDIuNSwxOTkuNSBMMTM0MS41LDE5OS41IEwxMzQxLjUsMTk4LjUgTDEzNDIuNSwxOTguNSBaIE0xMzM4LjUsMjAyLjUgTDEzMzguNSwyMDMuNSBMMTMzNy41LDIwMy41IEwxMzM3LjUsMjAyLjUgTDEzMzguNSwyMDIuNSBaIE0xMzQzLjUsMTk3LjUgTDEzNDMuNSwxOTguNSBMMTM0Mi41LDE5OC41IEwxMzQyLjUsMTk3LjUgTDEzNDMuNSwxOTcuNSBaIE0xMzM5LjUsMjAxLjUgTDEzMzkuNSwyMDIuNSBMMTMzOC41LDIwMi41IEwxMzM4LjUsMjAxLjUgTDEzMzkuNSwyMDEuNSBaIE0xMzQxLjUsMTk5LjUgTDEzNDEuNSwyMDAuNSBMMTM0MC41LDIwMC41IEwxMzQwLjUsMTk5LjUgTDEzNDEuNSwxOTkuNSBaIiBpZD0iQ29tYmluZWQtU2hhcGUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEzMzcuNTAwMDAwLCAxOTcuMDAwMDAwKSByb3RhdGUoLTkwLjAwMDAwMCkgdHJhbnNsYXRlKC0xMzM3LjUwMDAwMCwgLTE5Ny4wMDAwMDApICI+PC9wYXRoPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+';\nvar ICON_RETRACT_HOVER = exports.ICON_RETRACT_HOVER = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTNweCIgaGVpZ2h0PSIxNHB4IiB2aWV3Qm94PSIwIDAgMTMgMTQiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8ZyBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4KICAgICAgICA8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTMzMS4wMDAwMDAsIC0xOTAuMDAwMDAwKSIgZmlsbD0iI0ZDODU1NSI+CiAgICAgICAgICAgIDxwYXRoIGQ9Ik0xMzMxLjUsMTkxLjUgTDEzMzIuNSwxOTEuNSBMMTMzMi41LDE5Mi41IEwxMzMxLjUsMTkyLjUgTDEzMzEuNSwxOTEuNSBaIE0xMzMwLjUsMTkwLjUgTDEzMzEuNSwxOTAuNSBMMTMzMS41LDE5MS41IEwxMzMwLjUsMTkxLjUgTDEzMzAuNSwxOTAuNSBaIE0xMzM1LjUsMTk1LjUgTDEzMzYuNSwxOTUuNSBMMTMzNi41LDE5Ni41IEwxMzM1LjUsMTk2LjUgTDEzMzUuNSwxOTUuNSBaIE0xMzMzLjUsMTkzLjUgTDEzMzQuNSwxOTMuNSBMMTMzNC41LDE5NC41IEwxMzMzLjUsMTk0LjUgTDEzMzMuNSwxOTMuNSBaIE0xMzMyLjUsMTkyLjUgTDEzMzMuNSwxOTIuNSBMMTMzMy41LDE5My41IEwxMzMyLjUsMTkzLjUgTDEzMzIuNSwxOTIuNSBaIE0xMzM2LjUsMTk2LjUgTDEzMzcuNSwxOTYuNSBMMTMzNy41LDE5Ny41IEwxMzM2LjUsMTk3LjUgTDEzMzYuNSwxOTYuNSBaIE0xMzM0LjUsMTk0LjUgTDEzMzUuNSwxOTQuNSBMMTMzNS41LDE5NS41IEwxMzM0LjUsMTk1LjUgTDEzMzQuNSwxOTQuNSBaIE0xMzQ0LjUsMTkwLjUgTDEzNDQuNSwxOTEuNSBMMTM0My41LDE5MS41IEwxMzQzLjUsMTkwLjUgTDEzNDQuNSwxOTAuNSBaIE0xMzQwLjUsMTk0LjUgTDEzNDAuNSwxOTUuNSBMMTMzOS41LDE5NS41IEwxMzM5LjUsMTk0LjUgTDEzNDAuNSwxOTQuNSBaIE0xMzQyLjUsMTkyLjUgTDEzNDIuNSwxOTMuNSBMMTM0MS41LDE5My41IEwxMzQxLjUsMTkyLjUgTDEzNDIuNSwxOTIuNSBaIE0xMzM4LjUsMTk2LjUgTDEzMzguNSwxOTcuNSBMMTMzNy41LDE5Ny41IEwxMzM3LjUsMTk2LjUgTDEzMzguNSwxOTYuNSBaIE0xMzQzLjUsMTkxLjUgTDEzNDMuNSwxOTIuNSBMMTM0Mi41LDE5Mi41IEwxMzQyLjUsMTkxLjUgTDEzNDMuNSwxOTEuNSBaIE0xMzM5LjUsMTk1LjUgTDEzMzkuNSwxOTYuNSBMMTMzOC41LDE5Ni41IEwxMzM4LjUsMTk1LjUgTDEzMzkuNSwxOTUuNSBaIE0xMzQxLjUsMTkzLjUgTDEzNDEuNSwxOTQuNSBMMTM0MC41LDE5NC41IEwxMzQwLjUsMTkzLjUgTDEzNDEuNSwxOTMuNSBaIE0xMzMxLjUsMTk3LjUgTDEzMzIuNSwxOTcuNSBMMTMzMi41LDE5OC41IEwxMzMxLjUsMTk4LjUgTDEzMzEuNSwxOTcuNSBaIE0xMzMwLjUsMTk2LjUgTDEzMzEuNSwxOTYuNSBMMTMzMS41LDE5Ny41IEwxMzMwLjUsMTk3LjUgTDEzMzAuNSwxOTYuNSBaIE0xMzM1LjUsMjAxLjUgTDEzMzYuNSwyMDEuNSBMMTMzNi41LDIwMi41IEwxMzM1LjUsMjAyLjUgTDEzMzUuNSwyMDEuNSBaIE0xMzMzLjUsMTk5LjUgTDEzMzQuNSwxOTkuNSBMMTMzNC41LDIwMC41IEwxMzMzLjUsMjAwLjUgTDEzMzMuNSwxOTkuNSBaIE0xMzMyLjUsMTk4LjUgTDEzMzMuNSwxOTguNSBMMTMzMy41LDE5OS41IEwxMzMyLjUsMTk5LjUgTDEzMzIuNSwxOTguNSBaIE0xMzM2LjUsMjAyLjUgTDEzMzcuNSwyMDIuNSBMMTMzNy41LDIwMy41IEwxMzM2LjUsMjAzLjUgTDEzMzYuNSwyMDIuNSBaIE0xMzM0LjUsMjAwLjUgTDEzMzUuNSwyMDAuNSBMMTMzNS41LDIwMS41IEwxMzM0LjUsMjAxLjUgTDEzMzQuNSwyMDAuNSBaIE0xMzQ0LjUsMTk2LjUgTDEzNDQuNSwxOTcuNSBMMTM0My41LDE5Ny41IEwxMzQzLjUsMTk2LjUgTDEzNDQuNSwxOTYuNSBaIE0xMzQwLjUsMjAwLjUgTDEzNDAuNSwyMDEuNSBMMTMzOS41LDIwMS41IEwxMzM5LjUsMjAwLjUgTDEzNDAuNSwyMDAuNSBaIE0xMzQyLjUsMTk4LjUgTDEzNDIuNSwxOTkuNSBMMTM0MS41LDE5OS41IEwxMzQxLjUsMTk4LjUgTDEzNDIuNSwxOTguNSBaIE0xMzM4LjUsMjAyLjUgTDEzMzguNSwyMDMuNSBMMTMzNy41LDIwMy41IEwxMzM3LjUsMjAyLjUgTDEzMzguNSwyMDIuNSBaIE0xMzQzLjUsMTk3LjUgTDEzNDMuNSwxOTguNSBMMTM0Mi41LDE5OC41IEwxMzQyLjUsMTk3LjUgTDEzNDMuNSwxOTcuNSBaIE0xMzM5LjUsMjAxLjUgTDEzMzkuNSwyMDIuNSBMMTMzOC41LDIwMi41IEwxMzM4LjUsMjAxLjUgTDEzMzkuNSwyMDEuNSBaIE0xMzQxLjUsMTk5LjUgTDEzNDEuNSwyMDAuNSBMMTM0MC41LDIwMC41IEwxMzQwLjUsMTk5LjUgTDEzNDEuNSwxOTkuNSBaIiBpZD0iQ29tYmluZWQtU2hhcGUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEzMzcuNTAwMDAwLCAxOTcuMDAwMDAwKSByb3RhdGUoLTkwLjAwMDAwMCkgdHJhbnNsYXRlKC0xMzM3LjUwMDAwMCwgLTE5Ny4wMDAwMDApICI+PC9wYXRoPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+';\nvar ICON_COMMENT = exports.ICON_COMMENT = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMThweCIgaGVpZ2h0PSIxOHB4IiB2aWV3Qm94PSIwIDAgMTggMTgiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8ZyBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4KCQk8cGF0aCBkPSJNOS4zMTQyODU3NiwxNS45MjMxNDI4IEM4Ljc1MjQyODYsMTUuOTIzMTQyOCA3LjU0MDg1NzE4LDE1LjgyODQyODYgNy4wMDc3MTQzNCwxNS43NDA1NzE0IEwzLjE0Mjg1NzE5LDE4IEwzLjE0Mjg1NzE5LDE0LjA3Mzg1NzIgQzEuMzUxMDAwMDQsMTIuNTM0IDAuNDAwMDAwMDMxLDEwLjM5NDU3MTQgMC40MDAwMDAwMzEsNy44NzUgQzAuNDAwMDAwMDMxLDMuNTI1ODU3MTQgNC4zODQwMDAwNCwwIDkuMzE0Mjg1NzYsMCBDMTMuNDEyNzE0MywwIDE3LjU0Mjg1NzIsMy41MjU4NTcxNCAxNy41NDI4NTcyLDcuODc1IEMxNy41NDI4NTcyLDEyLjIyNDU3MTQgMTQuMjM3NzE0MywxNS45MjMxNDI4IDkuMzE0Mjg1NzYsMTUuOTIzMTQyOCBMOS4zMTQyODU3NiwxNS45MjMxNDI4IFoiIGlkPSJTaGFwZSIgZmlsbD0iI0E3QjVEMyIgZmlsbC1ydWxlPSJub256ZXJvIj48L3BhdGg+CiAgICAgICAgPHBhdGggZD0iTTQuNzQ2ODg4MjQsOS4zMDQ1MTA1MiBMNC43NDY4ODgyNCw5LjMwNDUxMDUyIEM1LjUxMDAzNzY4LDEwLjcwMzQ4OTQgNi45OTQxNzY4NCwxMS42NTI2MzE2IDguNywxMS42NTI2MzE2IEMxMC40NjI1MTQ1LDExLjY1MjYzMTYgMTEuOTg4MzY1MywxMC42MzkzNTM0IDEyLjcyNjc5Miw5LjE2MzU1NzI2IiBpZD0iT3ZhbC01IiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMS41IiBzdHJva2UtbGluZWNhcD0icm91bmQiPjwvcGF0aD4KICAgIDwvZz4KPC9zdmc+';\nvar ICON_COMMENT_HOVER = exports.ICON_COMMENT_HOVER = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMThweCIgaGVpZ2h0PSIxOHB4IiB2aWV3Qm94PSIwIDAgMTggMTgiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8ZyBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4KCQk8cGF0aCBkPSJNOS4zMTQyODU3NiwxNS45MjMxNDI4IEM4Ljc1MjQyODYsMTUuOTIzMTQyOCA3LjU0MDg1NzE4LDE1LjgyODQyODYgNy4wMDc3MTQzNCwxNS43NDA1NzE0IEwzLjE0Mjg1NzE5LDE4IEwzLjE0Mjg1NzE5LDE0LjA3Mzg1NzIgQzEuMzUxMDAwMDQsMTIuNTM0IDAuNDAwMDAwMDMxLDEwLjM5NDU3MTQgMC40MDAwMDAwMzEsNy44NzUgQzAuNDAwMDAwMDMxLDMuNTI1ODU3MTQgNC4zODQwMDAwNCwwIDkuMzE0Mjg1NzYsMCBDMTMuNDEyNzE0MywwIDE3LjU0Mjg1NzIsMy41MjU4NTcxNCAxNy41NDI4NTcyLDcuODc1IEMxNy41NDI4NTcyLDEyLjIyNDU3MTQgMTQuMjM3NzE0MywxNS45MjMxNDI4IDkuMzE0Mjg1NzYsMTUuOTIzMTQyOCBMOS4zMTQyODU3NiwxNS45MjMxNDI4IFoiIGlkPSJTaGFwZSIgZmlsbD0iI0ZDODU1NSIgZmlsbC1ydWxlPSJub256ZXJvIj48L3BhdGg+CiAgICAgICAgPHBhdGggZD0iTTQuNzQ2ODg4MjQsOS4zMDQ1MTA1MiBMNC43NDY4ODgyNCw5LjMwNDUxMDUyIEM1LjUxMDAzNzY4LDEwLjcwMzQ4OTQgNi45OTQxNzY4NCwxMS42NTI2MzE2IDguNywxMS42NTI2MzE2IEMxMC40NjI1MTQ1LDExLjY1MjYzMTYgMTEuOTg4MzY1MywxMC42MzkzNTM0IDEyLjcyNjc5Miw5LjE2MzU1NzI2IiBpZD0iT3ZhbC01IiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMS41IiBzdHJva2UtbGluZWNhcD0icm91bmQiPjwvcGF0aD4KICAgIDwvZz4KPC9zdmc+';\nvar ICON_ZOOMIN = exports.ICON_ZOOMIN = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjBweCIgaGVpZ2h0PSIyMHB4IiB2aWV3Qm94PSIwIDAgMjAgMjAiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CgkJCTxnIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPgoJCQkJPHBvbHlnb24gcG9pbnRzPSIwIDAgMjAgMCAyMCAyMCAwIDIwIi8+CgkJCQk8cG9seWdvbiBmaWxsPSIjNjY2NjY2IiBmaWxsLXJ1bGU9Im5vbnplcm8iIHBvaW50cz0iOS4xNjY2NjY2NyA5LjE2NjY2NjY3IDkuMTY2NjY2NjcgNC4xNjY2NjY2NyAxMC44MzMzMzMzIDQuMTY2NjY2NjcgMTAuODMzMzMzMyA5LjE2NjY2NjY3IDE1LjgzMzMzMzMgOS4xNjY2NjY2NyAxNS44MzMzMzMzIDEwLjgzMzMzMzMgMTAuODMzMzMzMyAxMC44MzMzMzMzIDEwLjgzMzMzMzMgMTUuODMzMzMzMyA5LjE2NjY2NjY3IDE1LjgzMzMzMzMgOS4xNjY2NjY2NyAxMC44MzMzMzMzIDQuMTY2NjY2NjcgMTAuODMzMzMzMyA0LjE2NjY2NjY3IDkuMTY2NjY2NjciLz4KCQkJPC9nPgoJCTwvc3ZnPg==';\nvar ICON_ZOOMOUT = exports.ICON_ZOOMOUT = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjBweCIgaGVpZ2h0PSIyMHB4IiB2aWV3Qm94PSIwIDAgMjAgMjAiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CgkJCTxnIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPgoJCQkJPHBvbHlnb24gcG9pbnRzPSIwIDAgMjAgMCAyMCAyMCAwIDIwIi8+CgkJCQk8cG9seWdvbiBmaWxsPSIjNjY2NjY2IiBmaWxsLXJ1bGU9Im5vbnplcm8iIHBvaW50cz0iNC4xNjY2NjY2NyA5LjE2NjY2NjY3IDE1LjgzMzMzMzMgOS4xNjY2NjY2NyAxNS44MzMzMzMzIDEwLjgzMzMzMzMgNC4xNjY2NjY2NyAxMC44MzMzMzMzIi8+CgkJCTwvZz4KCQk8L3N2Zz4=';\nvar ICON_DOWNLOAD = exports.ICON_DOWNLOAD = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjBweCIgaGVpZ2h0PSIyMHB4IiB2aWV3Qm94PSIwIDAgMjAgMjAiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CgkJCTxnIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPgoJCQkJPGc+CgkJCQkJPHBhdGggZD0iTTEwLjc1LDguNSBMMTQuNSw4LjUgTDEwLDEzIEw1LjUsOC41IEw5LjI1LDguNSBMOS4yNSwzLjI1IEwxMC43NSwzLjI1IEwxMC43NSw4LjUgWiBNNCwxNS4yNSBMMTYsMTUuMjUgTDE2LDEwIEwxNy41LDEwIEwxNy41LDE2IEMxNy41LDE2LjQxNDIxMzYgMTcuMTY0MjEzNiwxNi43NSAxNi43NSwxNi43NSBMMy4yNSwxNi43NSBDMi44MzU3ODY0NCwxNi43NSAyLjUsMTYuNDE0MjEzNiAyLjUsMTYgTDIuNSwxMCBMNCwxMCBMNCwxNS4yNSBaIiBmaWxsPSIjNjY2NjY2IiBmaWxsLXJ1bGU9Im5vbnplcm8iLz4KCQkJCQk8cG9seWdvbiBwb2ludHM9IjAgMCAyMCAwIDIwIDIwIDAgMjAiLz4KCQkJCTwvZz4KCQkJPC9nPgoJCTwvc3ZnPg==';\nvar ICON_ZOOMIN_HOVER = exports.ICON_ZOOMIN_HOVER = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjBweCIgaGVpZ2h0PSIyMHB4IiB2aWV3Qm94PSIwIDAgMjAgMjAiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CgkJCTxnIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPgoJCQkJPHBvbHlnb24gcG9pbnRzPSIwIDAgMjAgMCAyMCAyMCAwIDIwIi8+CgkJCQk8cG9seWdvbiBmaWxsPSIjMzc2MUNBIiBmaWxsLXJ1bGU9Im5vbnplcm8iIHBvaW50cz0iOS4xNjY2NjY2NyA5LjE2NjY2NjY3IDkuMTY2NjY2NjcgNC4xNjY2NjY2NyAxMC44MzMzMzMzIDQuMTY2NjY2NjcgMTAuODMzMzMzMyA5LjE2NjY2NjY3IDE1LjgzMzMzMzMgOS4xNjY2NjY2NyAxNS44MzMzMzMzIDEwLjgzMzMzMzMgMTAuODMzMzMzMyAxMC44MzMzMzMzIDEwLjgzMzMzMzMgMTUuODMzMzMzMyA5LjE2NjY2NjY3IDE1LjgzMzMzMzMgOS4xNjY2NjY2NyAxMC44MzMzMzMzIDQuMTY2NjY2NjcgMTAuODMzMzMzMyA0LjE2NjY2NjY3IDkuMTY2NjY2NjciLz4KCQkJPC9nPgoJCTwvc3ZnPg==';\nvar ICON_ZOOMOUT_HOVER = exports.ICON_ZOOMOUT_HOVER = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjBweCIgaGVpZ2h0PSIyMHB4IiB2aWV3Qm94PSIwIDAgMjAgMjAiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CgkJCTxnIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPgoJCQkJPHBvbHlnb24gcG9pbnRzPSIwIDAgMjAgMCAyMCAyMCAwIDIwIi8+CgkJCQk8cG9seWdvbiBmaWxsPSIjMzc2MUNBIiBmaWxsLXJ1bGU9Im5vbnplcm8iIHBvaW50cz0iNC4xNjY2NjY2NyA5LjE2NjY2NjY3IDE1LjgzMzMzMzMgOS4xNjY2NjY2NyAxNS44MzMzMzMzIDEwLjgzMzMzMzMgNC4xNjY2NjY2NyAxMC44MzMzMzMzIi8+CgkJCTwvZz4KCQk8L3N2Zz4=';\nvar ICON_DOWNLOAD_HOVER = exports.ICON_DOWNLOAD_HOVER = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjBweCIgaGVpZ2h0PSIyMHB4IiB2aWV3Qm94PSIwIDAgMjAgMjAiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CgkJCTxnIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPgoJCQkJPGc+CgkJCQkJPHBhdGggZD0iTTEwLjc1LDguNSBMMTQuNSw4LjUgTDEwLDEzIEw1LjUsOC41IEw5LjI1LDguNSBMOS4yNSwzLjI1IEwxMC43NSwzLjI1IEwxMC43NSw4LjUgWiBNNCwxNS4yNSBMMTYsMTUuMjUgTDE2LDEwIEwxNy41LDEwIEwxNy41LDE2IEMxNy41LDE2LjQxNDIxMzYgMTcuMTY0MjEzNiwxNi43NSAxNi43NSwxNi43NSBMMy4yNSwxNi43NSBDMi44MzU3ODY0NCwxNi43NSAyLjUsMTYuNDE0MjEzNiAyLjUsMTYgTDIuNSwxMCBMNCwxMCBMNCwxNS4yNSBaIiBmaWxsPSIjMzc2MUNBIiBmaWxsLXJ1bGU9Im5vbnplcm8iLz4KCQkJCQk8cG9seWdvbiBwb2ludHM9IjAgMCAyMCAwIDIwIDIwIDAgMjAiLz4KCQkJCTwvZz4KCQkJPC9nPgoJCTwvc3ZnPg==';\n\n//# sourceURL=webpack://bos-platform/./src/workflow/constants/mxGraphConstant.js?");

/***/ }),

/***/ "./src/workflow/init.js":
/*!******************************!*\
  !*** ./src/workflow/init.js ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.index-of.js */ \"../../node_modules/core-js/modules/es.array.index-of.js\");\n__webpack_require__(/*! core-js/modules/es.array.last-index-of.js */ \"../../node_modules/core-js/modules/es.array.last-index-of.js\");\n// Parses URL parameters. Supported parameters are:\n// - lang=xy: Specifies the language of the user interface.\n// - touch=1: Enables a touch-style user interface.\n// - storage=local: Enables HTML5 local storage.\n// - chrome=0: Chromeless mode.\nvar urlParams = function (url) {\n  var result = new Object();\n  var idx = url.lastIndexOf('?');\n  if (idx > 0) {\n    var params = url.substring(idx + 1).split('&');\n    for (var i = 0; i < params.length; i++) {\n      idx = params[i].indexOf('=');\n      if (idx > 0) {\n        result[params[i].substring(0, idx)] = params[i].substring(idx + 1);\n      }\n    }\n  }\n  return result;\n}(window.location.href);\n\n// Default resources are included in grapheditor resources\n//window.mxLoadResources = false;\n//window.mxLoadStylesheets = false;\n\n// urlParams is null when used for embedding\nwindow.urlParams = window.urlParams || {};\n\n// Public global variables\nwindow.MAX_REQUEST_SIZE = window.MAX_REQUEST_SIZE || 10485760;\nwindow.MAX_AREA = window.MAX_AREA || 10000 * 10000;\n\n// URLs for save and export\nwindow.EXPORT_URL = window.EXPORT_URL || '/export';\nwindow.SAVE_URL = window.SAVE_URL || '/save';\nwindow.OPEN_URL = window.OPEN_URL || '/open';\nwindow.RESOURCES_PATH = window.RESOURCES_PATH || 'resources';\nwindow.RESOURCE_BASE = window.RESOURCE_BASE || window.RESOURCES_PATH + '/grapheditor';\nwindow.STENCIL_PATH = window.STENCIL_PATH || 'workflow/stencils';\nwindow.IMAGE_PATH = window.IMAGE_PATH || 'images';\nwindow.STYLE_PATH = window.STYLE_PATH || 'styles';\nwindow.CSS_PATH = window.CSS_PATH || 'styles';\nwindow.OPEN_FORM = window.OPEN_FORM || 'open.html';\n\n// Sets the base path, the UI language via URL param and configures the\n// supported languages to avoid 404s. The loading of all core language\n// resources is disabled as all required resources are in grapheditor.\n// properties. Note that in this example the loading of two resource\n// files (the special bundle and the default bundle) is disabled to\n// save a GET request. This requires that all resources be present in\n// each properties file since only one file is loaded.\nwindow.mxBasePath = window.mxBasePath || './workflow';\nwindow.mxLanguage = window.mxLanguage || urlParams['lang'];\nwindow.mxLanguages = window.mxLanguages || ['de'];\nwindow.compactUi = true; //给作为全局变量的文件使用，例如：LayersWindow.js\nvar _default = exports[\"default\"] = {};\n\n//# sourceURL=webpack://bos-platform/./src/workflow/init.js?");

/***/ }),

/***/ "./src/workflow/mxClient/WeightedCellSorter.js":
/*!*****************************************************!*\
  !*** ./src/workflow/mxClient/WeightedCellSorter.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nfunction WeightedCellSorter(cell, weightedValue) {\n  this.cell = cell;\n  this.weightedValue = weightedValue;\n}\n;\n\n/**\r\n * Variable: weightedValue\r\n *\r\n * The weighted value of the cell stored.\r\n */\nWeightedCellSorter.prototype.weightedValue = 0;\n\n/**\r\n * Variable: nudge\r\n *\r\n * Whether or not to flip equal weight values.\r\n */\nWeightedCellSorter.prototype.nudge = false;\n\n/**\r\n * Variable: visited\r\n *\r\n * Whether or not this cell has been visited in the current assignment.\r\n */\nWeightedCellSorter.prototype.visited = false;\n\n/**\r\n * Variable: rankIndex\r\n *\r\n * The index this cell is in the model rank.\r\n */\nWeightedCellSorter.prototype.rankIndex = null;\n\n/**\r\n * Variable: cell\r\n *\r\n * The cell whose median value is being calculated.\r\n */\nWeightedCellSorter.prototype.cell = null;\n\n/**\r\n * Function: compare\r\n *\r\n * Compares two WeightedCellSorters.\r\n */\nWeightedCellSorter.prototype.compare = function (a, b) {\n  if (a != null && b != null) {\n    if (b.weightedValue > a.weightedValue) {\n      return -1;\n    } else if (b.weightedValue < a.weightedValue) {\n      return 1;\n    } else {\n      if (b.nudge) {\n        return -1;\n      } else {\n        return 1;\n      }\n    }\n  } else {\n    return 0;\n  }\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxSwimlaneOrdering\r\n *\r\n * An implementation of the first stage of the Sugiyama layout. Straightforward\r\n * longest path calculation of layer assignment\r\n *\r\n * Constructor: mxSwimlaneOrdering\r\n *\r\n * Creates a cycle remover for the given internal model.\r\n */\nvar _default = exports[\"default\"] = WeightedCellSorter;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/WeightedCellSorter.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxAbstractCanvas2D.js":
/*!*****************************************************!*\
  !*** ./src/workflow/mxClient/mxAbstractCanvas2D.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.parse-float.js */ \"../../node_modules/core-js/modules/es.parse-float.js\");\n__webpack_require__(/*! core-js/modules/es.regexp.exec.js */ \"../../node_modules/core-js/modules/es.regexp.exec.js\");\n__webpack_require__(/*! core-js/modules/es.string.replace.js */ \"../../node_modules/core-js/modules/es.string.replace.js\");\nvar _mxPoint = _interopRequireDefault(__webpack_require__(/*! ./mxPoint.js */ \"./src/workflow/mxClient/mxPoint.js\"));\nvar _mxUrlConverter = _interopRequireDefault(__webpack_require__(/*! ./mxUrlConverter.js */ \"./src/workflow/mxClient/mxUrlConverter.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ./mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxAbstractCanvas2D() {\n  /**\r\n   * Variable: converter\r\n   *\r\n   * Holds the <mxUrlConverter> to convert image URLs.\r\n   */\n  this.converter = this.createUrlConverter();\n  this.reset();\n}\n;\n\n/**\r\n * Variable: state\r\n *\r\n * Holds the current state.\r\n */\nmxAbstractCanvas2D.prototype.state = null;\n\n/**\r\n * Variable: states\r\n *\r\n * Stack of states.\r\n */\nmxAbstractCanvas2D.prototype.states = null;\n\n/**\r\n * Variable: path\r\n *\r\n * Holds the current path as an array.\r\n */\nmxAbstractCanvas2D.prototype.path = null;\n\n/**\r\n * Variable: rotateHtml\r\n *\r\n * Switch for rotation of HTML. Default is false.\r\n */\nmxAbstractCanvas2D.prototype.rotateHtml = true;\n\n/**\r\n * Variable: lastX\r\n *\r\n * Holds the last x coordinate.\r\n */\nmxAbstractCanvas2D.prototype.lastX = 0;\n\n/**\r\n * Variable: lastY\r\n *\r\n * Holds the last y coordinate.\r\n */\nmxAbstractCanvas2D.prototype.lastY = 0;\n\n/**\r\n * Variable: moveOp\r\n *\r\n * Contains the string used for moving in paths. Default is 'M'.\r\n */\nmxAbstractCanvas2D.prototype.moveOp = 'M';\n\n/**\r\n * Variable: lineOp\r\n *\r\n * Contains the string used for moving in paths. Default is 'L'.\r\n */\nmxAbstractCanvas2D.prototype.lineOp = 'L';\n\n/**\r\n * Variable: quadOp\r\n *\r\n * Contains the string used for quadratic paths. Default is 'Q'.\r\n */\nmxAbstractCanvas2D.prototype.quadOp = 'Q';\n\n/**\r\n * Variable: curveOp\r\n *\r\n * Contains the string used for bezier curves. Default is 'C'.\r\n */\nmxAbstractCanvas2D.prototype.curveOp = 'C';\n\n/**\r\n * Variable: closeOp\r\n *\r\n * Holds the operator for closing curves. Default is 'Z'.\r\n */\nmxAbstractCanvas2D.prototype.closeOp = 'Z';\n\n/**\r\n * Variable: pointerEvents\r\n *\r\n * Boolean value that specifies if events should be handled. Default is false.\r\n */\nmxAbstractCanvas2D.prototype.pointerEvents = false;\n\n/**\r\n * Function: createUrlConverter\r\n *\r\n * Create a new <mxUrlConverter> and returns it.\r\n */\nmxAbstractCanvas2D.prototype.createUrlConverter = function () {\n  return new _mxUrlConverter[\"default\"]();\n};\n\n/**\r\n * Function: reset\r\n *\r\n * Resets the state of this canvas.\r\n */\nmxAbstractCanvas2D.prototype.reset = function () {\n  this.state = this.createState();\n  this.states = [];\n};\n\n/**\r\n * Function: createState\r\n *\r\n * Creates the state of the this canvas.\r\n */\nmxAbstractCanvas2D.prototype.createState = function () {\n  return {\n    dx: 0,\n    dy: 0,\n    scale: 1,\n    alpha: 1,\n    fillAlpha: 1,\n    strokeAlpha: 1,\n    fillColor: null,\n    gradientFillAlpha: 1,\n    gradientColor: null,\n    gradientAlpha: 1,\n    gradientDirection: null,\n    strokeColor: null,\n    strokeWidth: 1,\n    dashed: false,\n    dashPattern: '3 3',\n    lineCap: 'flat',\n    lineJoin: 'miter',\n    miterLimit: 10,\n    fontColor: '#000000',\n    fontBackgroundColor: null,\n    ellipsisBackgroundColor: null,\n    fontBorderColor: null,\n    fontSize: _mxConstants[\"default\"].DEFAULT_FONTSIZE,\n    fontFamily: _mxConstants[\"default\"].DEFAULT_FONTFAMILY,\n    fontStyle: 0,\n    shadow: false,\n    shadowColor: _mxConstants[\"default\"].SHADOWCOLOR,\n    shadowAlpha: _mxConstants[\"default\"].SHADOW_OPACITY,\n    shadowDx: _mxConstants[\"default\"].SHADOW_OFFSET_X,\n    shadowDy: _mxConstants[\"default\"].SHADOW_OFFSET_Y,\n    rotation: 0,\n    rotationCx: 0,\n    rotationCy: 0\n  };\n};\n\n/**\r\n * Function: format\r\n *\r\n * Rounds all numbers to integers.\r\n */\nmxAbstractCanvas2D.prototype.format = function (value) {\n  return Math.round(parseFloat(value));\n};\n\n/**\r\n * Function: addOp\r\n *\r\n * Adds the given operation to the path.\r\n */\nmxAbstractCanvas2D.prototype.addOp = function () {\n  if (this.path != null) {\n    this.path.push(arguments[0]);\n    if (arguments.length > 2) {\n      var s = this.state;\n      for (var i = 2; i < arguments.length; i += 2) {\n        this.lastX = arguments[i - 1];\n        this.lastY = arguments[i];\n        this.path.push(this.format((this.lastX + s.dx) * s.scale));\n        this.path.push(this.format((this.lastY + s.dy) * s.scale));\n      }\n    }\n  }\n};\n\n/**\r\n * Function: rotatePoint\r\n *\r\n * Rotates the given point and returns the result as an <mxPoint>.\r\n */\nmxAbstractCanvas2D.prototype.rotatePoint = function (x, y, theta, cx, cy) {\n  var rad = theta * (Math.PI / 180);\n  return _mxGraphUtils[\"default\"].getRotatedPoint(new _mxPoint[\"default\"](x, y), Math.cos(rad), Math.sin(rad), new _mxPoint[\"default\"](cx, cy), _mxPoint[\"default\"]);\n};\n\n/**\r\n * Function: save\r\n *\r\n * Saves the current state.\r\n */\nmxAbstractCanvas2D.prototype.save = function () {\n  this.states.push(this.state);\n  this.state = _mxGraphUtils[\"default\"].clone(this.state);\n};\n\n/**\r\n * Function: restore\r\n *\r\n * Restores the current state.\r\n */\nmxAbstractCanvas2D.prototype.restore = function () {\n  if (this.states.length > 0) {\n    this.state = this.states.pop();\n  }\n};\n\n/**\r\n * Function: setLink\r\n *\r\n * Sets the current link. Hook for subclassers.\r\n */\nmxAbstractCanvas2D.prototype.setLink = function (link) {\n  // nop\n};\n\n/**\r\n * Function: scale\r\n *\r\n * Scales the current state.\r\n */\nmxAbstractCanvas2D.prototype.scale = function (value, isPureSvg) {\n  this.state.scale *= value;\n  this.state.strokeWidth *= value;\n  //TODO: Canvas2D对扩展方式图形的处理\n  if (isPureSvg === true) {\n    var transform = this.root.getAttribute('transform');\n    this.root.setAttribute(\"transform\", transform.replace(/scale\\(\\d+[\\.\\d+]?\\)/, '') + ' scale(' + this.state.scale + ')');\n  }\n};\n\n/**\r\n * Function: translate\r\n *\r\n * Translates the current state.\r\n */\nmxAbstractCanvas2D.prototype.translate = function (dx, dy) {\n  this.state.dx += dx;\n  this.state.dy += dy;\n};\n\n/**\r\n * Function: rotate\r\n *\r\n * Rotates the current state.\r\n */\nmxAbstractCanvas2D.prototype.rotate = function (theta, flipH, flipV, cx, cy) {\n  // nop\n};\n\n/**\r\n * Function: setAlpha\r\n *\r\n * Sets the current alpha.\r\n */\nmxAbstractCanvas2D.prototype.setAlpha = function (value) {\n  this.state.alpha = value;\n};\n\n/**\r\n * Function: setFillAlpha\r\n *\r\n * Sets the current solid fill alpha.\r\n */\nmxAbstractCanvas2D.prototype.setFillAlpha = function (value) {\n  this.state.fillAlpha = value;\n};\n\n/**\r\n * Function: setStrokeAlpha\r\n *\r\n * Sets the current stroke alpha.\r\n */\nmxAbstractCanvas2D.prototype.setStrokeAlpha = function (value) {\n  this.state.strokeAlpha = value;\n};\n\n/**\r\n * Function: setFillColor\r\n *\r\n * Sets the current fill color.\r\n */\nmxAbstractCanvas2D.prototype.setFillColor = function (value) {\n  if (value == _mxConstants[\"default\"].NONE) {\n    value = null;\n  }\n  this.state.fillColor = value;\n  this.state.gradientColor = null;\n};\n\n/**\r\n * Function: setGradient\r\n *\r\n * Sets the current gradient.\r\n */\nmxAbstractCanvas2D.prototype.setGradient = function (color1, color2, x, y, w, h, direction, alpha1, alpha2) {\n  var s = this.state;\n  s.fillColor = color1;\n  s.gradientFillAlpha = alpha1 != null ? alpha1 : 1;\n  s.gradientColor = color2;\n  s.gradientAlpha = alpha2 != null ? alpha2 : 1;\n  s.gradientDirection = direction;\n};\n\n/**\r\n * Function: setStrokeColor\r\n *\r\n * Sets the current stroke color.\r\n */\nmxAbstractCanvas2D.prototype.setStrokeColor = function (value) {\n  if (value == _mxConstants[\"default\"].NONE) {\n    value = null;\n  }\n  this.state.strokeColor = value;\n};\n\n/**\r\n * Function: setStrokeWidth\r\n *\r\n * Sets the current stroke width.\r\n */\nmxAbstractCanvas2D.prototype.setStrokeWidth = function (value) {\n  this.state.strokeWidth = value;\n};\n\n/**\r\n * Function: setDashed\r\n *\r\n * Enables or disables dashed lines.\r\n */\nmxAbstractCanvas2D.prototype.setDashed = function (value) {\n  this.state.dashed = value;\n};\n\n/**\r\n * Function: setDashPattern\r\n *\r\n * Sets the current dash pattern.\r\n */\nmxAbstractCanvas2D.prototype.setDashPattern = function (value) {\n  this.state.dashPattern = value;\n};\n\n/**\r\n * Function: setLineCap\r\n *\r\n * Sets the current line cap.\r\n */\nmxAbstractCanvas2D.prototype.setLineCap = function (value) {\n  this.state.lineCap = value;\n};\n\n/**\r\n * Function: setLineJoin\r\n *\r\n * Sets the current line join.\r\n */\nmxAbstractCanvas2D.prototype.setLineJoin = function (value) {\n  this.state.lineJoin = value;\n};\n\n/**\r\n * Function: setMiterLimit\r\n *\r\n * Sets the current miter limit.\r\n */\nmxAbstractCanvas2D.prototype.setMiterLimit = function (value) {\n  this.state.miterLimit = value;\n};\n\n/**\r\n * Function: setFontColor\r\n *\r\n * Sets the current font color.\r\n */\nmxAbstractCanvas2D.prototype.setFontColor = function (value) {\n  if (value == _mxConstants[\"default\"].NONE) {\n    value = null;\n  }\n  this.state.fontColor = value;\n};\n\n/**\r\n * Function: setFontColor\r\n *\r\n * Sets the current font color.\r\n */\nmxAbstractCanvas2D.prototype.setFontBackgroundColor = function (value) {\n  if (value == _mxConstants[\"default\"].NONE) {\n    value = null;\n  }\n  this.state.fontBackgroundColor = value;\n};\nmxAbstractCanvas2D.prototype.setEllipsisBackgroundColor = function (value) {\n  if (value == _mxConstants[\"default\"].NONE) {\n    value = null;\n  }\n  this.state.ellipsisBackgroundColor = value;\n};\n\n/**\r\n * Function: setFontColor\r\n *\r\n * Sets the current font color.\r\n */\nmxAbstractCanvas2D.prototype.setFontBorderColor = function (value) {\n  if (value == _mxConstants[\"default\"].NONE) {\n    value = null;\n  }\n  this.state.fontBorderColor = value;\n};\n\n/**\r\n * Function: setFontSize\r\n *\r\n * Sets the current font size.\r\n */\nmxAbstractCanvas2D.prototype.setFontSize = function (value) {\n  this.state.fontSize = parseFloat(value);\n};\n\n/**\r\n * Function: setFontFamily\r\n *\r\n * Sets the current font family.\r\n */\nmxAbstractCanvas2D.prototype.setFontFamily = function (value) {\n  this.state.fontFamily = value;\n};\n\n/**\r\n * Function: setFontStyle\r\n *\r\n * Sets the current font style.\r\n */\nmxAbstractCanvas2D.prototype.setFontStyle = function (value) {\n  if (value == null) {\n    value = 0;\n  }\n  this.state.fontStyle = value;\n};\n\n/**\r\n * Function: setShadow\r\n *\r\n * Enables or disables and configures the current shadow.\r\n */\nmxAbstractCanvas2D.prototype.setShadow = function (enabled) {\n  this.state.shadow = enabled;\n};\n\n/**\r\n * Function: setShadowColor\r\n *\r\n * Enables or disables and configures the current shadow.\r\n */\nmxAbstractCanvas2D.prototype.setShadowColor = function (value) {\n  if (value == _mxConstants[\"default\"].NONE) {\n    value = null;\n  }\n  this.state.shadowColor = value;\n};\n\n/**\r\n * Function: setShadowAlpha\r\n *\r\n * Enables or disables and configures the current shadow.\r\n */\nmxAbstractCanvas2D.prototype.setShadowAlpha = function (value) {\n  this.state.shadowAlpha = value;\n};\n\n/**\r\n * Function: setShadowOffset\r\n *\r\n * Enables or disables and configures the current shadow.\r\n */\nmxAbstractCanvas2D.prototype.setShadowOffset = function (dx, dy) {\n  this.state.shadowDx = dx;\n  this.state.shadowDy = dy;\n};\n\n/**\r\n * Function: begin\r\n *\r\n * Starts a new path.\r\n */\nmxAbstractCanvas2D.prototype.begin = function () {\n  this.lastX = 0;\n  this.lastY = 0;\n  this.path = [];\n};\n\n/**\r\n * Function: moveTo\r\n *\r\n *  Moves the current path the given coordinates.\r\n */\nmxAbstractCanvas2D.prototype.moveTo = function (x, y) {\n  this.addOp(this.moveOp, x, y);\n};\n\n/**\r\n * Function: lineTo\r\n *\r\n * Draws a line to the given coordinates. Uses moveTo with the op argument.\r\n */\nmxAbstractCanvas2D.prototype.lineTo = function (x, y) {\n  this.addOp(this.lineOp, x, y);\n};\n\n/**\r\n * Function: quadTo\r\n *\r\n * Adds a quadratic curve to the current path.\r\n */\nmxAbstractCanvas2D.prototype.quadTo = function (x1, y1, x2, y2) {\n  this.addOp(this.quadOp, x1, y1, x2, y2);\n};\n\n/**\r\n * Function: curveTo\r\n *\r\n * Adds a bezier curve to the current path.\r\n */\nmxAbstractCanvas2D.prototype.curveTo = function (x1, y1, x2, y2, x3, y3) {\n  this.addOp(this.curveOp, x1, y1, x2, y2, x3, y3);\n};\n\n/**\r\n * Function: arcTo\r\n *\r\n * Adds the given arc to the current path. This is a synthetic operation that\r\n * is broken down into curves.\r\n */\nmxAbstractCanvas2D.prototype.arcTo = function (rx, ry, angle, largeArcFlag, sweepFlag, x, y) {\n  var curves = _mxGraphUtils[\"default\"].arcToCurves(this.lastX, this.lastY, rx, ry, angle, largeArcFlag, sweepFlag, x, y);\n  if (curves != null) {\n    for (var i = 0; i < curves.length; i += 6) {\n      this.curveTo(curves[i], curves[i + 1], curves[i + 2], curves[i + 3], curves[i + 4], curves[i + 5]);\n    }\n  }\n};\n\n/**\r\n * Function: close\r\n *\r\n * Closes the current path.\r\n */\nmxAbstractCanvas2D.prototype.close = function (x1, y1, x2, y2, x3, y3) {\n  this.addOp(this.closeOp);\n};\n\n/**\r\n * Function: end\r\n *\r\n * Empty implementation for backwards compatibility. This will be removed.\r\n */\nmxAbstractCanvas2D.prototype.end = function () {};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxXmlCanvas2D\r\n *\r\n * Base class for all canvases. The following methods make up the public\r\n * interface of the canvas 2D for all painting in mxGraph:\r\n *\r\n * - <save>, <restore>\r\n * - <scale>, <translate>, <rotate>\r\n * - <setAlpha>, <setFillAlpha>, <setStrokeAlpha>, <setFillColor>, <setGradient>,\r\n *   <setStrokeColor>, <setStrokeWidth>, <setDashed>, <setDashPattern>, <setLineCap>,\r\n *   <setLineJoin>, <setMiterLimit>\r\n * - <setFontColor>, <setFontBackgroundColor>, <setFontBorderColor>, <setFontSize>,\r\n *   <setFontFamily>, <setFontStyle>\r\n * - <setShadow>, <setShadowColor>, <setShadowAlpha>, <setShadowOffset>\r\n * - <rect>, <roundrect>, <ellipse>, <image>, <text>\r\n * - <begin>, <moveTo>, <lineTo>, <quadTo>, <curveTo>\r\n * - <stroke>, <fill>, <fillAndStroke>\r\n *\r\n * <mxAbstractCanvas2D.arcTo> is an additional method for drawing paths. This is\r\n * a synthetic method, meaning that it is turned into a sequence of curves by\r\n * default. Subclassers may add native support for arcs.\r\n *\r\n * Constructor: mxXmlCanvas2D\r\n *\r\n * Constructs a new abstract canvas.\r\n */\nvar _default = exports[\"default\"] = mxAbstractCanvas2D;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxAbstractCanvas2D.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxActor.js":
/*!******************************************!*\
  !*** ./src/workflow/mxClient/mxActor.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.fill.js */ \"../../node_modules/core-js/modules/es.array.fill.js\");\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxShape = _interopRequireDefault(__webpack_require__(/*! ./mxShape.js */ \"./src/workflow/mxClient/mxShape.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxActor(bounds, fill, stroke, strokewidth) {\n  _mxShape[\"default\"].call(this);\n  this.bounds = bounds;\n  this.fill = fill;\n  this.stroke = stroke;\n  this.strokewidth = strokewidth != null ? strokewidth : 1;\n}\n;\n\n/**\r\n * Extends mxShape.\r\n */\n_mxGraphUtils[\"default\"].extend(mxActor, _mxShape[\"default\"]);\n\n/**\r\n * Function: paintVertexShape\r\n *\r\n * Redirects to redrawPath for subclasses to work.\r\n */\nmxActor.prototype.paintVertexShape = function (c, x, y, w, h) {\n  c.translate(x, y);\n  c.begin();\n  this.redrawPath(c, x, y, w, h);\n  c.fillAndStroke();\n};\n\n/**\r\n * Function: redrawPath\r\n *\r\n * Draws the path for this shape.\r\n */\nmxActor.prototype.redrawPath = function (c, x, y, w, h) {\n  var width = w / 3;\n  c.moveTo(0, h);\n  c.curveTo(0, 3 * h / 5, 0, 2 * h / 5, w / 2, 2 * h / 5);\n  c.curveTo(w / 2 - width, 2 * h / 5, w / 2 - width, 0, w / 2, 0);\n  c.curveTo(w / 2 + width, 0, w / 2 + width, 2 * h / 5, w / 2, 2 * h / 5);\n  c.curveTo(w, 2 * h / 5, w, 3 * h / 5, w, h);\n  c.close();\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxCloud\r\n *\r\n * Extends <mxActor> to implement a cloud shape.\r\n *\r\n * This shape is registered under <mxConstants.SHAPE_CLOUD> in\r\n * <mxCellRenderer>.\r\n *\r\n * Constructor: mxCloud\r\n *\r\n * Constructs a new cloud shape.\r\n *\r\n * Parameters:\r\n *\r\n * bounds - <mxRectangle> that defines the bounds. This is stored in\r\n * <mxShape.bounds>.\r\n * fill - String that defines the fill color. This is stored in <fill>.\r\n * stroke - String that defines the stroke color. This is stored in <stroke>.\r\n * strokewidth - Optional integer that defines the stroke width. Default is\r\n * 1. This is stored in <strokewidth>.\r\n */\nvar _default = exports[\"default\"] = mxActor;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxActor.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxAnimation.js":
/*!**********************************************!*\
  !*** ./src/workflow/mxClient/mxAnimation.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.function.bind.js */ \"../../node_modules/core-js/modules/es.function.bind.js\");\n__webpack_require__(/*! core-js/modules/web.timers.js */ \"../../node_modules/core-js/modules/web.timers.js\");\nvar _mxEventObject = _interopRequireDefault(__webpack_require__(/*! ./mxEventObject.js */ \"./src/workflow/mxClient/mxEventObject.js\"));\nvar _mxEvent = _interopRequireDefault(__webpack_require__(/*! ./mxEvent.js */ \"./src/workflow/mxClient/mxEvent.js\"));\nvar _mxEventSource = _interopRequireDefault(__webpack_require__(/*! ./mxEventSource.js */ \"./src/workflow/mxClient/mxEventSource.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxAnimation(delay) {\n  this.delay = delay != null ? delay : 20;\n}\n;\n\n/**\r\n * Extends mxEventSource.\r\n */\nmxAnimation.prototype = new _mxEventSource[\"default\"]();\nmxAnimation.prototype.constructor = mxAnimation;\n\n/**\r\n * Variable: delay\r\n *\r\n * Specifies the delay between the animation steps. Defaul is 30ms.\r\n */\nmxAnimation.prototype.delay = null;\n\n/**\r\n * Variable: thread\r\n *\r\n * Reference to the thread while the animation is running.\r\n */\nmxAnimation.prototype.thread = null;\n\n/**\r\n * Function: isRunning\r\n *\r\n * Returns true if the animation is running.\r\n */\nmxAnimation.prototype.isRunning = function () {\n  return this.thread != null;\n};\n\n/**\r\n * Function: startAnimation\r\n *\r\n * Starts the animation by repeatedly invoking updateAnimation.\r\n */\nmxAnimation.prototype.startAnimation = function () {\n  if (this.thread == null) {\n    this.thread = window.setInterval(_mxGraphUtils[\"default\"].bind(this, this.updateAnimation), this.delay);\n  }\n};\n\n/**\r\n * Function: updateAnimation\r\n *\r\n * Hook for subclassers to implement the animation. Invoke stopAnimation\r\n * when finished, startAnimation to resume. This is called whenever the\r\n * timer fires and fires an mxEvent.EXECUTE event with no properties.\r\n */\nmxAnimation.prototype.updateAnimation = function () {\n  this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].EXECUTE));\n};\n\n/**\r\n * Function: stopAnimation\r\n *\r\n * Stops the animation by deleting the timer and fires an <mxEvent.DONE>.\r\n */\nmxAnimation.prototype.stopAnimation = function () {\n  if (this.thread != null) {\n    window.clearInterval(this.thread);\n    this.thread = null;\n    this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].DONE));\n  }\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n *\r\n * Class: mxMorphing\r\n *\r\n * Implements animation for morphing cells. Here is an example of\r\n * using this class for animating the result of a layout algorithm:\r\n *\r\n * (code)\r\n * graph.getModel().beginUpdate();\r\n * try\r\n * {\r\n *   var circleLayout = new mxCircleLayout(graph);\r\n *   circleLayout.execute(graph.getDefaultParent());\r\n * }\r\n * finally\r\n * {\r\n *   var morph = new mxMorphing(graph);\r\n *   morph.addListener(mxEvent.DONE, function()\r\n *   {\r\n *     graph.getModel().endUpdate();\r\n *   });\r\n *\r\n *   morph.startAnimation();\r\n * }\r\n * (end)\r\n *\r\n * Constructor: mxMorphing\r\n *\r\n * Constructs an animation.\r\n *\r\n * Parameters:\r\n *\r\n * graph - Reference to the enclosing <mxGraph>.\r\n * steps - Optional number of steps in the morphing animation. Default is 6.\r\n * ease - Optional easing constant for the animation. Default is 1.5.\r\n * delay - Optional delay between the animation steps. Passed to <mxAnimation>.\r\n */\nvar _default = exports[\"default\"] = mxAnimation;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxAnimation.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxArrow.js":
/*!******************************************!*\
  !*** ./src/workflow/mxClient/mxArrow.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.fill.js */ \"../../node_modules/core-js/modules/es.array.fill.js\");\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxShape = _interopRequireDefault(__webpack_require__(/*! ./mxShape.js */ \"./src/workflow/mxClient/mxShape.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ./mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxArrow(points, fill, stroke, strokewidth, arrowWidth, spacing, endSize) {\n  _mxShape[\"default\"].call(this);\n  this.points = points;\n  this.fill = fill;\n  this.stroke = stroke;\n  this.strokewidth = strokewidth != null ? strokewidth : 1;\n  this.arrowWidth = arrowWidth != null ? arrowWidth : _mxConstants[\"default\"].ARROW_WIDTH;\n  this.spacing = spacing != null ? spacing : _mxConstants[\"default\"].ARROW_SPACING;\n  this.endSize = endSize != null ? endSize : _mxConstants[\"default\"].ARROW_SIZE;\n}\n;\n\n/**\r\n * Extends mxShape.\r\n */\n_mxGraphUtils[\"default\"].extend(mxArrow, _mxShape[\"default\"]);\n\n/**\r\n * Function: augmentBoundingBox\r\n *\r\n * Augments the bounding box with the edge width and markers.\r\n */\nmxArrow.prototype.augmentBoundingBox = function (bbox) {\n  _mxShape[\"default\"].prototype.augmentBoundingBox.apply(this, arguments);\n  var w = Math.max(this.arrowWidth, this.endSize);\n  bbox.grow((w / 2 + this.strokewidth) * this.scale);\n};\n\n/**\r\n * Function: paintEdgeShape\r\n *\r\n * Paints the line shape.\r\n */\nmxArrow.prototype.paintEdgeShape = function (c, pts) {\n  // Geometry of arrow\n  var spacing = _mxConstants[\"default\"].ARROW_SPACING;\n  var width = _mxConstants[\"default\"].ARROW_WIDTH;\n  var arrow = _mxConstants[\"default\"].ARROW_SIZE;\n\n  // Base vector (between end points)\n  var p0 = pts[0];\n  var pe = pts[pts.length - 1];\n  var dx = pe.x - p0.x;\n  var dy = pe.y - p0.y;\n  var dist = Math.sqrt(dx * dx + dy * dy);\n  var length = dist - 2 * spacing - arrow;\n\n  // Computes the norm and the inverse norm\n  var nx = dx / dist;\n  var ny = dy / dist;\n  var basex = length * nx;\n  var basey = length * ny;\n  var floorx = width * ny / 3;\n  var floory = -width * nx / 3;\n\n  // Computes points\n  var p0x = p0.x - floorx / 2 + spacing * nx;\n  var p0y = p0.y - floory / 2 + spacing * ny;\n  var p1x = p0x + floorx;\n  var p1y = p0y + floory;\n  var p2x = p1x + basex;\n  var p2y = p1y + basey;\n  var p3x = p2x + floorx;\n  var p3y = p2y + floory;\n  // p4 not necessary\n  var p5x = p3x - 3 * floorx;\n  var p5y = p3y - 3 * floory;\n  c.begin();\n  c.moveTo(p0x, p0y);\n  c.lineTo(p1x, p1y);\n  c.lineTo(p2x, p2y);\n  c.lineTo(p3x, p3y);\n  c.lineTo(pe.x - spacing * nx, pe.y - spacing * ny);\n  c.lineTo(p5x, p5y);\n  c.lineTo(p5x + floorx, p5y + floory);\n  c.close();\n  c.fillAndStroke();\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxArrowConnector\r\n *\r\n * Extends <mxShape> to implement an new rounded arrow shape with support for\r\n * waypoints and double arrows. (The shape is used to represent edges, not\r\n * vertices.) This shape is registered under <mxConstants.SHAPE_ARROW_CONNECTOR>\r\n * in <mxCellRenderer>.\r\n *\r\n * Constructor: mxArrowConnector\r\n *\r\n * Constructs a new arrow shape.\r\n *\r\n * Parameters:\r\n *\r\n * points - Array of <mxPoints> that define the points. This is stored in\r\n * <mxShape.points>.\r\n * fill - String that defines the fill color. This is stored in <fill>.\r\n * stroke - String that defines the stroke color. This is stored in <stroke>.\r\n * strokewidth - Optional integer that defines the stroke width. Default is\r\n * 1. This is stored in <strokewidth>.\r\n * arrowWidth - Optional integer that defines the arrow width. Default is\r\n * <mxConstants.ARROW_WIDTH>. This is stored in <arrowWidth>.\r\n * spacing - Optional integer that defines the spacing between the arrow shape\r\n * and its endpoints. Default is <mxConstants.ARROW_SPACING>. This is stored in\r\n * <spacing>.\r\n * endSize - Optional integer that defines the size of the arrowhead. Default\r\n * is <mxConstants.ARROW_SIZE>. This is stored in <endSize>.\r\n */\nvar _default = exports[\"default\"] = mxArrow;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxArrow.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxArrowConnector.js":
/*!***************************************************!*\
  !*** ./src/workflow/mxClient/mxArrowConnector.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.fill.js */ \"../../node_modules/core-js/modules/es.array.fill.js\");\n__webpack_require__(/*! core-js/modules/es.array.splice.js */ \"../../node_modules/core-js/modules/es.array.splice.js\");\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxShape = _interopRequireDefault(__webpack_require__(/*! ./mxShape.js */ \"./src/workflow/mxClient/mxShape.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ./mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nvar _mxUtils = _interopRequireDefault(__webpack_require__(/*! ./mxUtils.js */ \"./src/workflow/mxClient/mxUtils.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxArrowConnector(points, fill, stroke, strokewidth, arrowWidth, spacing, endSize) {\n  _mxShape[\"default\"].call(this);\n  this.points = points;\n  this.fill = fill;\n  this.stroke = stroke;\n  this.strokewidth = strokewidth != null ? strokewidth : 1;\n  this.arrowWidth = arrowWidth != null ? arrowWidth : _mxConstants[\"default\"].ARROW_WIDTH;\n  this.arrowSpacing = spacing != null ? spacing : _mxConstants[\"default\"].ARROW_SPACING;\n  this.startSize = _mxConstants[\"default\"].ARROW_SIZE / 5;\n  this.endSize = _mxConstants[\"default\"].ARROW_SIZE / 5;\n}\n;\n\n/**\r\n * Extends mxShape.\r\n */\n_mxGraphUtils[\"default\"].extend(mxArrowConnector, _mxShape[\"default\"]);\n\n/**\r\n * Variable: useSvgBoundingBox\r\n *\r\n * Allows to use the SVG bounding box in SVG. Default is false for performance\r\n * reasons.\r\n */\nmxArrowConnector.prototype.useSvgBoundingBox = true;\n\n/**\r\n * Variable: resetStyles\r\n *\r\n * Overrides mxShape to reset spacing.\r\n */\nmxArrowConnector.prototype.resetStyles = function () {\n  _mxShape[\"default\"].prototype.resetStyles.apply(this, arguments);\n  this.arrowSpacing = _mxConstants[\"default\"].ARROW_SPACING;\n};\n\n/**\r\n * Overrides apply to get smooth transition from default start- and endsize.\r\n */\nmxArrowConnector.prototype.apply = function (state) {\n  _mxShape[\"default\"].prototype.apply.apply(this, arguments);\n  if (this.style != null) {\n    this.startSize = _mxGraphUtils[\"default\"].getNumber(this.style, _mxConstants[\"default\"].STYLE_STARTSIZE, _mxConstants[\"default\"].ARROW_SIZE / 5) * 3;\n    this.endSize = _mxGraphUtils[\"default\"].getNumber(this.style, _mxConstants[\"default\"].STYLE_ENDSIZE, _mxConstants[\"default\"].ARROW_SIZE / 5) * 3;\n  }\n};\n\n/**\r\n * Function: augmentBoundingBox\r\n *\r\n * Augments the bounding box with the edge width and markers.\r\n */\nmxArrowConnector.prototype.augmentBoundingBox = function (bbox) {\n  _mxShape[\"default\"].prototype.augmentBoundingBox.apply(this, arguments);\n  var w = this.getEdgeWidth();\n  if (this.isMarkerStart()) {\n    w = Math.max(w, this.getStartArrowWidth());\n  }\n  if (this.isMarkerEnd()) {\n    w = Math.max(w, this.getEndArrowWidth());\n  }\n  bbox.grow((w / 2 + this.strokewidth) * this.scale);\n};\n\n/**\r\n * Function: paintEdgeShape\r\n *\r\n * Paints the line shape.\r\n */\nmxArrowConnector.prototype.paintEdgeShape = function (c, pts) {\n  // Geometry of arrow\n  var strokeWidth = this.strokewidth;\n  if (this.outline) {\n    strokeWidth = Math.max(1, _mxGraphUtils[\"default\"].getNumber(this.style, _mxConstants[\"default\"].STYLE_STROKEWIDTH, this.strokewidth));\n  }\n  var startWidth = this.getStartArrowWidth() + strokeWidth;\n  var endWidth = this.getEndArrowWidth() + strokeWidth;\n  var edgeWidth = this.outline ? this.getEdgeWidth() + strokeWidth : this.getEdgeWidth();\n  var openEnded = this.isOpenEnded();\n  var markerStart = this.isMarkerStart();\n  var markerEnd = this.isMarkerEnd();\n  var spacing = openEnded ? 0 : this.arrowSpacing + strokeWidth / 2;\n  var startSize = this.startSize + strokeWidth;\n  var endSize = this.endSize + strokeWidth;\n  var isRounded = this.isArrowRounded();\n\n  // Base vector (between first points)\n  var pe = pts[pts.length - 1];\n\n  // Finds first non-overlapping point\n  var i0 = 1;\n  while (i0 < pts.length - 1 && pts[i0].x == pts[0].x && pts[i0].y == pts[0].y) {\n    i0++;\n  }\n  var dx = pts[i0].x - pts[0].x;\n  var dy = pts[i0].y - pts[0].y;\n  var dist = Math.sqrt(dx * dx + dy * dy);\n  if (dist == 0) {\n    return;\n  }\n\n  // Computes the norm and the inverse norm\n  var nx = dx / dist;\n  var nx2,\n    nx1 = nx;\n  var ny = dy / dist;\n  var ny2,\n    ny1 = ny;\n  var orthx = edgeWidth * ny;\n  var orthy = -edgeWidth * nx;\n\n  // Stores the inbound function calls in reverse order in fns\n  var fns = [];\n  if (isRounded) {\n    c.setLineJoin('round');\n  } else if (pts.length > 2) {\n    // Only mitre if there are waypoints\n    c.setMiterLimit(1.42);\n  }\n  c.begin();\n  var startNx = nx;\n  var startNy = ny;\n  if (markerStart && !openEnded) {\n    this.paintMarker(c, pts[0].x, pts[0].y, nx, ny, startSize, startWidth, edgeWidth, spacing, true);\n  } else {\n    var outStartX = pts[0].x + orthx / 2 + spacing * nx;\n    var outStartY = pts[0].y + orthy / 2 + spacing * ny;\n    var inEndX = pts[0].x - orthx / 2 + spacing * nx;\n    var inEndY = pts[0].y - orthy / 2 + spacing * ny;\n    if (openEnded) {\n      c.moveTo(outStartX, outStartY);\n      fns.push(function () {\n        c.lineTo(inEndX, inEndY);\n      });\n    } else {\n      c.moveTo(inEndX, inEndY);\n      c.lineTo(outStartX, outStartY);\n    }\n  }\n  var dx1 = 0;\n  var dy1 = 0;\n  var dist1 = 0;\n  for (var i = 0; i < pts.length - 2; i++) {\n    // Work out in which direction the line is bending\n    var pos = _mxUtils[\"default\"].relativeCcw(pts[i].x, pts[i].y, pts[i + 1].x, pts[i + 1].y, pts[i + 2].x, pts[i + 2].y);\n    dx1 = pts[i + 2].x - pts[i + 1].x;\n    dy1 = pts[i + 2].y - pts[i + 1].y;\n    dist1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);\n    if (dist1 != 0) {\n      nx1 = dx1 / dist1;\n      ny1 = dy1 / dist1;\n      var tmp1 = nx * nx1 + ny * ny1;\n      tmp = Math.max(Math.sqrt((tmp1 + 1) / 2), 0.04);\n\n      // Work out the normal orthogonal to the line through the control point and the edge sides intersection\n      nx2 = nx + nx1;\n      ny2 = ny + ny1;\n      var dist2 = Math.sqrt(nx2 * nx2 + ny2 * ny2);\n      if (dist2 != 0) {\n        nx2 = nx2 / dist2;\n        ny2 = ny2 / dist2;\n\n        // Higher strokewidths require a larger minimum bend, 0.35 covers all but the most extreme cases\n        var strokeWidthFactor = Math.max(tmp, Math.min(this.strokewidth / 200 + 0.04, 0.35));\n        var angleFactor = pos != 0 && isRounded ? Math.max(0.1, strokeWidthFactor) : Math.max(tmp, 0.06);\n        var outX = pts[i + 1].x + ny2 * edgeWidth / 2 / angleFactor;\n        var outY = pts[i + 1].y - nx2 * edgeWidth / 2 / angleFactor;\n        var inX = pts[i + 1].x - ny2 * edgeWidth / 2 / angleFactor;\n        var inY = pts[i + 1].y + nx2 * edgeWidth / 2 / angleFactor;\n        if (pos == 0 || !isRounded) {\n          // If the two segments are aligned, or if we're not drawing curved sections between segments\n          // just draw straight to the intersection point\n          c.lineTo(outX, outY);\n          (function (x, y) {\n            fns.push(function () {\n              c.lineTo(x, y);\n            });\n          })(inX, inY);\n        } else if (pos == -1) {\n          var c1x = inX + ny * edgeWidth;\n          var c1y = inY - nx * edgeWidth;\n          var c2x = inX + ny1 * edgeWidth;\n          var c2y = inY - nx1 * edgeWidth;\n          c.lineTo(c1x, c1y);\n          c.quadTo(outX, outY, c2x, c2y);\n          (function (x, y) {\n            fns.push(function () {\n              c.lineTo(x, y);\n            });\n          })(inX, inY);\n        } else {\n          c.lineTo(outX, outY);\n          (function (x, y) {\n            var c1x = outX - ny * edgeWidth;\n            var c1y = outY + nx * edgeWidth;\n            var c2x = outX - ny1 * edgeWidth;\n            var c2y = outY + nx1 * edgeWidth;\n            fns.push(function () {\n              c.quadTo(x, y, c1x, c1y);\n            });\n            fns.push(function () {\n              c.lineTo(c2x, c2y);\n            });\n          })(inX, inY);\n        }\n        nx = nx1;\n        ny = ny1;\n      }\n    }\n  }\n  orthx = edgeWidth * ny1;\n  orthy = -edgeWidth * nx1;\n  if (markerEnd && !openEnded) {\n    this.paintMarker(c, pe.x, pe.y, -nx, -ny, endSize, endWidth, edgeWidth, spacing, false);\n  } else {\n    c.lineTo(pe.x - spacing * nx1 + orthx / 2, pe.y - spacing * ny1 + orthy / 2);\n    var inStartX = pe.x - spacing * nx1 - orthx / 2;\n    var inStartY = pe.y - spacing * ny1 - orthy / 2;\n    if (!openEnded) {\n      c.lineTo(inStartX, inStartY);\n    } else {\n      c.moveTo(inStartX, inStartY);\n      fns.splice(0, 0, function () {\n        c.moveTo(inStartX, inStartY);\n      });\n    }\n  }\n  for (var i = fns.length - 1; i >= 0; i--) {\n    fns[i]();\n  }\n  if (openEnded) {\n    c.end();\n    c.stroke();\n  } else {\n    c.close();\n    c.fillAndStroke();\n  }\n\n  // Workaround for shadow on top of base arrow\n  c.setShadow(false);\n\n  // Need to redraw the markers without the low miter limit\n  c.setMiterLimit(4);\n  if (isRounded) {\n    c.setLineJoin('flat');\n  }\n  if (pts.length > 2) {\n    // Only to repaint markers if no waypoints\n    // Need to redraw the markers without the low miter limit\n    c.setMiterLimit(4);\n    if (markerStart && !openEnded) {\n      c.begin();\n      this.paintMarker(c, pts[0].x, pts[0].y, startNx, startNy, startSize, startWidth, edgeWidth, spacing, true);\n      c.stroke();\n      c.end();\n    }\n    if (markerEnd && !openEnded) {\n      c.begin();\n      this.paintMarker(c, pe.x, pe.y, -nx, -ny, endSize, endWidth, edgeWidth, spacing, true);\n      c.stroke();\n      c.end();\n    }\n  }\n};\n\n/**\r\n * Function: paintEdgeShape\r\n *\r\n * Paints the line shape.\r\n */\nmxArrowConnector.prototype.paintMarker = function (c, ptX, ptY, nx, ny, size, arrowWidth, edgeWidth, spacing, initialMove) {\n  var widthArrowRatio = edgeWidth / arrowWidth;\n  var orthx = edgeWidth * ny / 2;\n  var orthy = -edgeWidth * nx / 2;\n  var spaceX = (spacing + size) * nx;\n  var spaceY = (spacing + size) * ny;\n  if (initialMove) {\n    c.moveTo(ptX - orthx + spaceX, ptY - orthy + spaceY);\n  } else {\n    c.lineTo(ptX - orthx + spaceX, ptY - orthy + spaceY);\n  }\n  c.lineTo(ptX - orthx / widthArrowRatio + spaceX, ptY - orthy / widthArrowRatio + spaceY);\n  c.lineTo(ptX + spacing * nx, ptY + spacing * ny);\n  c.lineTo(ptX + orthx / widthArrowRatio + spaceX, ptY + orthy / widthArrowRatio + spaceY);\n  c.lineTo(ptX + orthx + spaceX, ptY + orthy + spaceY);\n};\n\n/**\r\n * Function: isArrowRounded\r\n *\r\n * Returns wether the arrow is rounded\r\n */\nmxArrowConnector.prototype.isArrowRounded = function () {\n  return this.isRounded;\n};\n\n/**\r\n * Function: getStartArrowWidth\r\n *\r\n * Returns the width of the start arrow\r\n */\nmxArrowConnector.prototype.getStartArrowWidth = function () {\n  return _mxConstants[\"default\"].ARROW_WIDTH;\n};\n\n/**\r\n * Function: getEndArrowWidth\r\n *\r\n * Returns the width of the end arrow\r\n */\nmxArrowConnector.prototype.getEndArrowWidth = function () {\n  return _mxConstants[\"default\"].ARROW_WIDTH;\n};\n\n/**\r\n * Function: getEdgeWidth\r\n *\r\n * Returns the width of the body of the edge\r\n */\nmxArrowConnector.prototype.getEdgeWidth = function () {\n  return _mxConstants[\"default\"].ARROW_WIDTH / 3;\n};\n\n/**\r\n * Function: isOpenEnded\r\n *\r\n * Returns whether the ends of the shape are drawn\r\n */\nmxArrowConnector.prototype.isOpenEnded = function () {\n  return false;\n};\n\n/**\r\n * Function: isMarkerStart\r\n *\r\n * Returns whether the start marker is drawn\r\n */\nmxArrowConnector.prototype.isMarkerStart = function () {\n  return _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_STARTARROW, _mxConstants[\"default\"].NONE) != _mxConstants[\"default\"].NONE;\n};\n\n/**\r\n * Function: isMarkerEnd\r\n *\r\n * Returns whether the end marker is drawn\r\n */\nmxArrowConnector.prototype.isMarkerEnd = function () {\n  return _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_ENDARROW, _mxConstants[\"default\"].NONE) != _mxConstants[\"default\"].NONE;\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxText\r\n *\r\n * Extends <mxShape> to implement a text shape. To change vertical text from\r\n * bottom to top to top to bottom, the following code can be used:\r\n *\r\n * (code)\r\n * mxText.prototype.verticalTextRotation = 90;\r\n * (end)\r\n *\r\n * Constructor: mxText\r\n *\r\n * Constructs a new text shape.\r\n *\r\n * Parameters:\r\n *\r\n * value - String that represents the text to be displayed. This is stored in\r\n * <value>.\r\n * bounds - <mxRectangle> that defines the bounds. This is stored in\r\n * <mxShape.bounds>.\r\n * align - Specifies the horizontal alignment. Default is ''. This is stored in\r\n * <align>.\r\n * valign - Specifies the vertical alignment. Default is ''. This is stored in\r\n * <valign>.\r\n * color - String that specifies the text color. Default is 'black'. This is\r\n * stored in <color>.\r\n * family - String that specifies the font family. Default is\r\n * <mxConstants.DEFAULT_FONTFAMILY>. This is stored in <family>.\r\n * size - Integer that specifies the font size. Default is\r\n * <mxConstants.DEFAULT_FONTSIZE>. This is stored in <size>.\r\n * fontStyle - Specifies the font style. Default is 0. This is stored in\r\n * <fontStyle>.\r\n * spacing - Integer that specifies the global spacing. Default is 2. This is\r\n * stored in <spacing>.\r\n * spacingTop - Integer that specifies the top spacing. Default is 0. The\r\n * sum of the spacing and this is stored in <spacingTop>.\r\n * spacingRight - Integer that specifies the right spacing. Default is 0. The\r\n * sum of the spacing and this is stored in <spacingRight>.\r\n * spacingBottom - Integer that specifies the bottom spacing. Default is 0.The\r\n * sum of the spacing and this is stored in <spacingBottom>.\r\n * spacingLeft - Integer that specifies the left spacing. Default is 0. The\r\n * sum of the spacing and this is stored in <spacingLeft>.\r\n * horizontal - Boolean that specifies if the label is horizontal. Default is\r\n * true. This is stored in <horizontal>.\r\n * background - String that specifies the background color. Default is null.\r\n * This is stored in <background>.\r\n * border - String that specifies the label border color. Default is null.\r\n * This is stored in <border>.\r\n * wrap - Specifies if word-wrapping should be enabled. Default is false.\r\n * This is stored in <wrap>.\r\n * clipped - Specifies if the label should be clipped. Default is false.\r\n * This is stored in <clipped>.\r\n * overflow - Value of the overflow style. Default is 'visible'.\r\n */\nvar _default = exports[\"default\"] = mxArrowConnector;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxArrowConnector.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxCell.js":
/*!*****************************************!*\
  !*** ./src/workflow/mxClient/mxCell.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.concat.js */ \"../../node_modules/core-js/modules/es.array.concat.js\");\n__webpack_require__(/*! core-js/modules/es.array.for-each.js */ \"../../node_modules/core-js/modules/es.array.for-each.js\");\n__webpack_require__(/*! core-js/modules/es.array.index-of.js */ \"../../node_modules/core-js/modules/es.array.index-of.js\");\n__webpack_require__(/*! core-js/modules/es.array.join.js */ \"../../node_modules/core-js/modules/es.array.join.js\");\n__webpack_require__(/*! core-js/modules/es.array.map.js */ \"../../node_modules/core-js/modules/es.array.map.js\");\n__webpack_require__(/*! core-js/modules/es.array.splice.js */ \"../../node_modules/core-js/modules/es.array.splice.js\");\n__webpack_require__(/*! core-js/modules/es.object.keys.js */ \"../../node_modules/core-js/modules/es.object.keys.js\");\n__webpack_require__(/*! core-js/modules/es.object.to-string.js */ \"../../node_modules/core-js/modules/es.object.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.regexp.exec.js */ \"../../node_modules/core-js/modules/es.regexp.exec.js\");\n__webpack_require__(/*! core-js/modules/es.string.replace.js */ \"../../node_modules/core-js/modules/es.string.replace.js\");\n__webpack_require__(/*! core-js/modules/web.dom-collections.for-each.js */ \"../../node_modules/core-js/modules/web.dom-collections.for-each.js\");\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ./mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nvar _mxStencilRegistry = _interopRequireDefault(__webpack_require__(/*! ./mxStencilRegistry */ \"./src/workflow/mxClient/mxStencilRegistry.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxCell(value, geometry, style, type, group, baseType, containable, template) {\n  this.value = value;\n  this.setGeometry(geometry);\n  this.setStyle(style);\n  this.setType(type);\n  this.setTemplate(template);\n  this.setGroup(group);\n  baseType && this.setBaseType(baseType);\n  containable && this.setContainable(containable);\n  this.properties = {};\n  //同时设置name属性的值\n  value && this.setProperty('base', 'name', value);\n  template && this.setProperty('base', 'template', template);\n  if (this.onInit != null) {\n    this.onInit();\n  }\n}\n;\n\n/**\r\n * Variable: id\r\n *\r\n * Holds the Id. Default is null.\r\n */\nmxCell.prototype.id = null;\n\n/**\r\n * Variable: value\r\n *\r\n * Holds the user object. Default is null.\r\n */\nmxCell.prototype.value = null;\n\n/**\r\n * Variable: geometry\r\n *\r\n * Holds the <mxGeometry>. Default is null.\r\n */\nmxCell.prototype.geometry = null;\n\n/**\r\n * Variable: style\r\n *\r\n * Holds the style as a string of the form [(stylename|key=value);]. Default is\r\n * null.\r\n */\nmxCell.prototype.style = null;\n\n/**\r\n * Variable: vertex\r\n *\r\n * Specifies whether the cell is a vertex. Default is false.\r\n */\nmxCell.prototype.vertex = false;\n\n/**\r\n * Variable: edge\r\n *\r\n * Specifies whether the cell is an edge. Default is false.\r\n */\nmxCell.prototype.edge = false;\n\n/**\r\n * Variable: connectable\r\n *\r\n * Specifies whether the cell is connectable. Default is true.\r\n */\nmxCell.prototype.connectable = true;\n\n/**\r\n * Variable: visible\r\n *\r\n * Specifies whether the cell is visible. Default is true.\r\n */\nmxCell.prototype.visible = true;\n\n/**\r\n * Variable: collapsed\r\n *\r\n * Specifies whether the cell is collapsed. Default is false.\r\n */\nmxCell.prototype.collapsed = false;\n\n/**\r\n * Variable: parent\r\n *\r\n * Reference to the parent cell.\r\n */\nmxCell.prototype.parent = null;\n\n/**\r\n * Variable: source\r\n *\r\n * Reference to the source terminal.\r\n */\nmxCell.prototype.source = null;\n\n/**\r\n * Variable: target\r\n *\r\n * Reference to the target terminal.\r\n */\nmxCell.prototype.target = null;\n\n/**\r\n * Variable: children\r\n *\r\n * Holds the child cells.\r\n */\nmxCell.prototype.children = null;\n\n/**\r\n * Variable: edges\r\n *\r\n * Holds the edges.\r\n */\nmxCell.prototype.edges = null;\n\n/**\r\n * Variable: mxTransient\r\n *\r\n * List of members that should not be cloned inside <clone>. This field is\r\n * passed to <mxUtils.clone> and is not made persistent in <mxCellCodec>.\r\n * This is not a convention for all classes, it is only used in this class\r\n * to mark transient fields since transient modifiers are not supported by\r\n * the language.\r\n */\nmxCell.prototype.mxTransient = ['id', 'value', 'parent', 'source', 'target', 'children', 'edges'];\n/**\r\n* 默认cell为非容器类型的，对应配置文件中的isContainer，如果是true则按swimlane渲染\r\n*/\nmxCell.prototype.containable = false;\n\n/**\r\n* 对应配置文件中的baseType，表明cell所属的模型(Model)[WorkflowModel(bpmn) or XxxModel]\r\n*/\nmxCell.prototype.baseType = 'bpmn';\n\n/**\r\n * Function: getId\r\n *\r\n * Returns the Id of the cell as a string.\r\n */\nmxCell.prototype.getId = function () {\n  return this.id;\n};\n\n/**\r\n * Function: setId\r\n *\r\n * Sets the Id of the cell to the given string.\r\n */\nmxCell.prototype.setId = function (id, model) {\n  var uuid = null;\n  if (model) {\n    //不能用id，id会导致properties错乱(mxCell)\n    var processNumber = model.getBPMNRoot().getProperty(_mxConstants[\"default\"].PROCESS_ID);\n    uuid = processNumber ? \"\".concat(processNumber, \"_\").concat(id) : id;\n    this.setProperty('base', _mxConstants[\"default\"].STENCIL_NUMBER, id);\n  } else {\n    //如果是从xml解析(decode)，就不需要设置number了\n    uuid = id;\n  }\n  this.id = uuid;\n  this.setProperty('base', _mxConstants[\"default\"].STENCIL_ITEMID, uuid);\n};\n\n/**\r\n * Function: getValue\r\n *\r\n * Returns the user object of the cell. The user\r\n * object is stored in <value>.\r\n */\nmxCell.prototype.getValue = function () {\n  return this.value;\n};\n\n/**\r\n * Function: setValue\r\n *\r\n * Sets the user object of the cell. The user object\r\n * is stored in <value>.\r\n */\nmxCell.prototype.setValue = function (value) {\n  this.value = value;\n};\n\n/**\r\n * Function: valueChanged\r\n *\r\n * Changes the user object after an in-place edit\r\n * and returns the previous value. This implementation\r\n * replaces the user object with the given value and\r\n * returns the old user object.\r\n */\nmxCell.prototype.valueChanged = function (newValue) {\n  var previous = this.getValue();\n  this.setValue(newValue);\n  return previous;\n};\nmxCell.prototype.propertyChanged = function (group, property, newValue, reducer) {\n  var previous = this.getProperty(group, property);\n  this.setProperty(group, property, newValue, reducer);\n  return previous;\n};\n\n/**\r\n * Function: getGeometry\r\n *\r\n * Returns the <mxGeometry> that describes the <geometry>.\r\n */\nmxCell.prototype.getGeometry = function () {\n  return this.geometry;\n};\n\n/**\r\n * Function: setGeometry\r\n *\r\n * Sets the <mxGeometry> to be used as the <geometry>.\r\n */\nmxCell.prototype.setGeometry = function (geometry) {\n  this.geometry = geometry;\n};\n\n/**\r\n * Function: getStyle\r\n *\r\n * Returns a string that describes the <style>.\r\n */\nmxCell.prototype.getStyle = function () {\n  return this.style;\n};\n\n/**\r\n * Function: setStyle\r\n *\r\n * Sets the string to be used as the <style>.\r\n */\nmxCell.prototype.setStyle = function (style) {\n  this.style = style;\n};\n\n/**\r\n * Function: isVertex\r\n *\r\n * Returns true if the cell is a vertex.\r\n */\nmxCell.prototype.isVertex = function () {\n  return this.vertex != 0;\n};\n\n/**\r\n * Function: setVertex\r\n *\r\n * Specifies if the cell is a vertex. This should only be assigned at\r\n * construction of the cell and not be changed during its lifecycle.\r\n *\r\n * Parameters:\r\n *\r\n * vertex - Boolean that specifies if the cell is a vertex.\r\n */\nmxCell.prototype.setVertex = function (vertex) {\n  this.vertex = vertex;\n};\n\n/**\r\n * Function: isEdge\r\n *\r\n * Returns true if the cell is an edge.\r\n */\nmxCell.prototype.isEdge = function () {\n  return this.edge != 0;\n};\n\n/**\r\n * Function: setEdge\r\n *\r\n * Specifies if the cell is an edge. This should only be assigned at\r\n * construction of the cell and not be changed during its lifecycle.\r\n *\r\n * Parameters:\r\n *\r\n * edge - Boolean that specifies if the cell is an edge.\r\n */\nmxCell.prototype.setEdge = function (edge) {\n  this.edge = edge;\n};\n\n/**\r\n * Function: isConnectable\r\n *\r\n * Returns true if the cell is connectable.\r\n */\nmxCell.prototype.isConnectable = function () {\n  return this.connectable != 0;\n};\n\n/**\r\n * Function: setConnectable\r\n *\r\n * Sets the connectable state.\r\n *\r\n * Parameters:\r\n *\r\n * connectable - Boolean that specifies the new connectable state.\r\n */\nmxCell.prototype.setConnectable = function (connectable) {\n  this.connectable = connectable;\n};\n\n/**\r\n * Function: isVisible\r\n *\r\n * Returns true if the cell is visibile.\r\n */\nmxCell.prototype.isVisible = function () {\n  return this.visible != 0;\n};\n\n/**\r\n * Function: setVisible\r\n *\r\n * Specifies if the cell is visible.\r\n *\r\n * Parameters:\r\n *\r\n * visible - Boolean that specifies the new visible state.\r\n */\nmxCell.prototype.setVisible = function (visible) {\n  this.visible = visible;\n};\n\n/**\r\n * Function: isCollapsed\r\n *\r\n * Returns true if the cell is collapsed.\r\n */\nmxCell.prototype.isCollapsed = function () {\n  return this.collapsed != 0;\n};\n\n/**\r\n * Function: setCollapsed\r\n *\r\n * Sets the collapsed state.\r\n *\r\n * Parameters:\r\n *\r\n * collapsed - Boolean that specifies the new collapsed state.\r\n */\nmxCell.prototype.setCollapsed = function (collapsed) {\n  this.collapsed = collapsed;\n};\n\n/**\r\n * Function: getParent\r\n *\r\n * Returns the cell's parent.\r\n */\nmxCell.prototype.getParent = function () {\n  return this.parent;\n};\n\n/**\r\n * Function: setParent\r\n *\r\n * Sets the parent cell.\r\n *\r\n * Parameters:\r\n *\r\n * parent - <mxCell> that represents the new parent.\r\n */\nmxCell.prototype.setParent = function (parent) {\n  this.parent = parent;\n};\n\n/**\r\n * Function: getTerminal\r\n *\r\n * Returns the source or target terminal.\r\n *\r\n * Parameters:\r\n *\r\n * source - Boolean that specifies if the source terminal should be\r\n * returned.\r\n */\nmxCell.prototype.getTerminal = function (source) {\n  return source ? this.source : this.target;\n};\n\n/**\r\n * Function: setTerminal\r\n *\r\n * Sets the source or target terminal and returns the new terminal.\r\n *\r\n * Parameters:\r\n *\r\n * terminal - <mxCell> that represents the new source or target terminal.\r\n * isSource - Boolean that specifies if the source or target terminal\r\n * should be set.\r\n */\nmxCell.prototype.setTerminal = function (terminal, isSource) {\n  if (isSource) {\n    this.source = terminal;\n  } else {\n    this.target = terminal;\n  }\n  return terminal;\n};\n\n/**\r\n * Function: getChildCount\r\n *\r\n * Returns the number of child cells.\r\n */\nmxCell.prototype.getChildCount = function () {\n  return this.children == null ? 0 : this.children.length;\n};\n\n/**\r\n * Function: getIndex\r\n *\r\n * Returns the index of the specified child in the child array.\r\n *\r\n * Parameters:\r\n *\r\n * child - Child whose index should be returned.\r\n */\nmxCell.prototype.getIndex = function (child) {\n  return _mxGraphUtils[\"default\"].indexOf(this.children, child);\n};\n\n/**\r\n * Function: getChildAt\r\n *\r\n * Returns the child at the specified index.\r\n *\r\n * Parameters:\r\n *\r\n * index - Integer that specifies the child to be returned.\r\n */\nmxCell.prototype.getChildAt = function (index) {\n  return this.children == null ? null : this.children[index];\n};\n\n/**\r\n * Function: insert\r\n *\r\n * Inserts the specified child into the child array at the specified index\r\n * and updates the parent reference of the child. If not childIndex is\r\n * specified then the child is appended to the child array. Returns the\r\n * inserted child.\r\n *\r\n * Parameters:\r\n *\r\n * child - <mxCell> to be inserted or appended to the child array.\r\n * index - Optional integer that specifies the index at which the child\r\n * should be inserted into the child array.\r\n */\nmxCell.prototype.insert = function (child, index) {\n  if (child != null) {\n    if (index == null) {\n      index = this.getChildCount();\n      if (child.getParent() == this) {\n        index--;\n      }\n    }\n    child.removeFromParent();\n    child.setParent(this);\n    if (this.children == null) {\n      this.children = [];\n      this.children.push(child);\n    } else {\n      this.children.splice(index, 0, child);\n    }\n  }\n  return child;\n};\n\n/**\r\n * Function: remove\r\n *\r\n * Removes the child at the specified index from the child array and\r\n * returns the child that was removed. Will remove the parent reference of\r\n * the child.\r\n *\r\n * Parameters:\r\n *\r\n * index - Integer that specifies the index of the child to be\r\n * removed.\r\n */\nmxCell.prototype.remove = function (index) {\n  var child = null;\n  if (this.children != null && index >= 0) {\n    child = this.getChildAt(index);\n    if (child != null) {\n      this.children.splice(index, 1);\n      child.setParent(null);\n    }\n  }\n  return child;\n};\n\n/**\r\n * Function: removeFromParent\r\n *\r\n * Removes the cell from its parent.\r\n */\nmxCell.prototype.removeFromParent = function () {\n  if (this.parent != null) {\n    var index = this.parent.getIndex(this);\n    this.parent.remove(index);\n  }\n};\n\n/**\r\n * Function: getEdgeCount\r\n *\r\n * Returns the number of edges in the edge array.\r\n */\nmxCell.prototype.getEdgeCount = function () {\n  return this.edges == null ? 0 : this.edges.length;\n};\n\n/**\r\n * Function: getEdgeIndex\r\n *\r\n * Returns the index of the specified edge in <edges>.\r\n *\r\n * Parameters:\r\n *\r\n * edge - <mxCell> whose index in <edges> should be returned.\r\n */\nmxCell.prototype.getEdgeIndex = function (edge) {\n  return _mxGraphUtils[\"default\"].indexOf(this.edges, edge);\n};\n\n/**\r\n * Function: getEdgeAt\r\n *\r\n * Returns the edge at the specified index in <edges>.\r\n *\r\n * Parameters:\r\n *\r\n * index - Integer that specifies the index of the edge to be returned.\r\n */\nmxCell.prototype.getEdgeAt = function (index) {\n  return this.edges == null ? null : this.edges[index];\n};\n\n/**\r\n * Function: insertEdge\r\n *\r\n * Inserts the specified edge into the edge array and returns the edge.\r\n * Will update the respective terminal reference of the edge.\r\n *\r\n * Parameters:\r\n *\r\n * edge - <mxCell> to be inserted into the edge array.\r\n * isOutgoing - Boolean that specifies if the edge is outgoing.\r\n */\nmxCell.prototype.insertEdge = function (edge, isOutgoing) {\n  if (edge != null) {\n    edge.removeFromTerminal(isOutgoing);\n    edge.setTerminal(this, isOutgoing);\n    if (this.edges == null || edge.getTerminal(!isOutgoing) != this || _mxGraphUtils[\"default\"].indexOf(this.edges, edge) < 0) {\n      if (this.edges == null) {\n        this.edges = [];\n      }\n      this.edges.push(edge);\n    }\n  }\n  return edge;\n};\n\n/**\r\n * Function: removeEdge\r\n *\r\n * Removes the specified edge from the edge array and returns the edge.\r\n * Will remove the respective terminal reference from the edge.\r\n *\r\n * Parameters:\r\n *\r\n * edge - <mxCell> to be removed from the edge array.\r\n * isOutgoing - Boolean that specifies if the edge is outgoing.\r\n */\nmxCell.prototype.removeEdge = function (edge, isOutgoing) {\n  if (edge != null) {\n    if (edge.getTerminal(!isOutgoing) != this && this.edges != null) {\n      var index = this.getEdgeIndex(edge);\n      if (index >= 0) {\n        this.edges.splice(index, 1);\n      }\n    }\n    edge.setTerminal(null, isOutgoing);\n  }\n  return edge;\n};\n\n/**\r\n * Function: removeFromTerminal\r\n *\r\n * Removes the edge from its source or target terminal.\r\n *\r\n * Parameters:\r\n *\r\n * isSource - Boolean that specifies if the edge should be removed from its\r\n * source or target terminal.\r\n */\nmxCell.prototype.removeFromTerminal = function (isSource) {\n  var terminal = this.getTerminal(isSource);\n  if (terminal != null) {\n    terminal.removeEdge(this, isSource);\n  }\n};\n\n/**\r\n * Function: getAttribute\r\n *\r\n * Returns the specified attribute from the user object if it is an XML\r\n * node.\r\n *\r\n * Parameters:\r\n *\r\n * name - Name of the attribute whose value should be returned.\r\n * defaultValue - Optional default value to use if the attribute has no\r\n * value.\r\n */\nmxCell.prototype.getAttribute = function (name, defaultValue) {\n  var userObject = this.getValue();\n  var val = userObject != null && userObject.nodeType == _mxConstants[\"default\"].NODETYPE_ELEMENT ? userObject.getAttribute(name) : null;\n  return val || defaultValue;\n};\n\n/**\r\n * Function: setAttribute\r\n *\r\n * Sets the specified attribute on the user object if it is an XML node.\r\n *\r\n * Parameters:\r\n *\r\n * name - Name of the attribute whose value should be set.\r\n * value - New value of the attribute.\r\n */\nmxCell.prototype.setAttribute = function (name, value) {\n  var userObject = this.getValue();\n  if (userObject != null && userObject.nodeType == _mxConstants[\"default\"].NODETYPE_ELEMENT) {\n    userObject.setAttribute(name, value);\n  }\n};\n\n/**\r\n * Function: clone\r\n *\r\n * Returns a clone of the cell. Uses <cloneValue> to clone\r\n * the user object. All fields in <mxTransient> are ignored\r\n * during the cloning.\r\n */\nmxCell.prototype.clone = function () {\n  var clone = _mxGraphUtils[\"default\"].clone(this, this.mxTransient);\n  //copy: ori -clone-> clipboard; paste: clipboard -clone-> cell\n  clone.setOriginId(this.getId() || this.getOriginId());\n  clone.setValue(this.cloneValue());\n  return clone;\n};\n\n/**\r\n * Function: cloneValue\r\n *\r\n * Returns a clone of the cell's user object.\r\n */\nmxCell.prototype.cloneValue = function () {\n  var value = this.getValue();\n  if (value != null) {\n    if (typeof value.clone == 'function') {\n      value = value.clone();\n    } else if (!isNaN(value.nodeType)) {\n      value = value.cloneNode(true);\n    }\n  }\n  return value;\n};\n\n/**\r\n* 设置mxCell的类型，对应模型中的id\r\n*/\nmxCell.prototype.setType = function (type) {\n  this.type = type;\n};\n/**\r\n* 获取mxCell的类型\r\n*/\nmxCell.prototype.getType = function () {\n  return this.type;\n};\nmxCell.prototype.setTemplate = function (template) {\n  this.template = template;\n};\nmxCell.prototype.getTemplate = function () {\n  return this.template;\n};\n/**\r\n* 设置mxCell对应模型元素中的Category.id（group）\r\n*/\nmxCell.prototype.setGroup = function (group) {\n  this.group = group;\n};\n/**\r\n* 获取mxCell对应模型元素中的Category.id（group）\r\n*/\nmxCell.prototype.getGroup = function () {\n  return this.group;\n};\n/**\r\n* 节点复制源ID\r\n*/\nmxCell.prototype.setOriginId = function (originId) {\n  this.originId = originId;\n};\nmxCell.prototype.getOriginId = function () {\n  return this.originId;\n};\n/**\r\n* 节点所属PageID\r\n*/\nmxCell.prototype.setOriginPageId = function (originPageId) {\n  this.originPageId = originPageId;\n};\nmxCell.prototype.getOriginPageId = function () {\n  return this.originPageId;\n};\n\n/**\r\n* baseType对应配置文件中的BaseType，表明cell属于哪个模型下（工作流模型 or 扩展模型）\r\n*/\nmxCell.prototype.getBaseType = function () {\n  return this.baseType;\n};\nmxCell.prototype.setBaseType = function (baseType) {\n  this.baseType = baseType;\n};\n/**\r\n* isContainer对应配置文件中的isContainer，表示cell是否是swimlane类型\r\n*/\nmxCell.prototype.isContainable = function () {\n  return this.containable;\n};\nmxCell.prototype.setContainable = function (containable) {\n  this.containable = containable;\n};\nmxCell.prototype.getIdPrefix = function () {\n  if (_mxGraphUtils[\"default\"].isBoundaryEvent(this.getType())) {\n    //TODO: 做业务流时统一优化，暂时对边界节点特殊处理，边界节点生成ID时统一使用BoundaryEvent\n    return 'BoundaryEvent';\n  } else if (_mxGraphUtils[\"default\"].isGateway(this.getType())) {\n    return 'Gateway';\n  }\n  return this.getType();\n};\n\n/**\r\n* 返回mxCell对应的shape全称\r\n*/\nmxCell.prototype.getShape = function (use) {\n  var shape = \"ierp.\".concat(this.getBaseType(), \".\").concat(this.getType());\n  return use !== true ? shape : shape + '_USE';\n};\n/**\r\n* 设置工作流模型属性值\r\n* 分组保存数据是为了方便后端解析\r\n*/\nmxCell.prototype.setProperty = function (groupName, propName, value, reducer) {\n  //base 暂时不分组，便于后台bpmnModel转换\n  if (groupName === 'base') {\n    this.properties[propName] = value;\n  } else {\n    var group = this.properties[groupName] || {};\n    group[propName] = value;\n    this.properties[groupName] = group;\n  }\n  if (typeof reducer === 'function') {\n    reducer({\n      id: this.getId(),\n      propName: propName,\n      value: value\n    });\n  }\n};\n/**\r\n* 获取工作流模型属性值\r\n*/\nmxCell.prototype.getProperty = function (groupName, propName) {\n  //base 暂时不分组，便于后台bpmnModel转换\n  if (!groupName) {\n    return null;\n  }\n  if (propName === undefined) {\n    var props = groupName.split(\".\");\n    if (props.length > 1) {\n      return this.getProperty(props[0], props[1]);\n    }\n    return this.properties[groupName];\n  }\n  if (groupName === 'base') {\n    return this.properties[propName];\n  }\n  var value = this.properties[groupName];\n  return value ? value[propName] : null;\n};\n/**\r\n* 更新界面显示\r\n*/\nmxCell.prototype.updateView = function (graph, propName, value) {\n  //TODO 抽取到常量中\n  var viewProps = ['strokeWidth', 'fillColor', 'strokeColor'];\n  var model = graph.getModel();\n  if (viewProps.indexOf(propName) > -1) {\n    var tmp = null,\n      find = false,\n      newStyle = null,\n      style = this.getStyle(),\n      i = viewProps.length,\n      styles = style.split(';');\n    while (i--) {\n      if ((tmp = styles[i]).indexOf(propName) > -1) {\n        find = true;\n        tmp.replace(/(\\w+=).+/, '$1' + value);\n        break;\n      }\n    }\n    newStyle = styles.join(';');\n    !find && (newStyle += ';' + propName + '=' + value);\n    model.setStyle(this, newStyle);\n  }\n};\n/**\r\n* 从style中获得某一具体的样式\r\n*/\nmxCell.prototype.getStyleItem = function (key) {\n  var styles = (this.getStyle() || \"\").split(\";\");\n  var i = styles.length,\n    val = null;\n  while (i--) {\n    val = styles[i];\n    if (val.indexOf(key + \"=\") > -1) {\n      return val.replace(key + \"=\", \"\");\n    }\n  }\n};\nmxCell.prototype.getCellGraph = function () {\n  var json = {};\n  var getChildrenGraph = function getChildrenGraph(children, cell) {\n    //如果是子流程，JSON中不添加children\n    if (cell.isContainable() === true) {\n      return [];\n    }\n    return children && children.map(function (cell, index) {\n      if (cell.edge) {\n        //边\n        return getEdgeGraph(cell);\n      } else if (cell.vertex) {\n        //图形？\n        return getVertexGraph(cell);\n      }\n      return [];\n    }) || [];\n  };\n  var getEdgeGraph = function getEdgeGraph(cell) {\n    var geometry = cell.getGeometry();\n    var dockers = geometry.points && geometry.points.map(function (point, index) {\n      return {\n        x: point.x,\n        y: point.y\n      };\n    }) || [];\n    var ret = {\n      resourceId: cell.getId(),\n      //TODO id?\n      //中间节点\n      dockers: dockers,\n      style: cell.getStyle()\n    };\n    if (geometry.sourcePoint || geometry.targetPoint) {\n      ret.bounds = {\n        upperLeft: geometry.sourcePoint,\n        lowerRight: geometry.targetPoint\n      };\n    }\n    if (cell.children && cell.children.length) {\n      ret.childShapes = getChildrenGraph(cell.children, cell);\n    }\n    return ret;\n  };\n  var getVertexGraph = function getVertexGraph(cell) {\n    var geometry = cell.getGeometry();\n    var width = geometry.width;\n    var height = geometry.height;\n    if (cell.isContainable() === true) {\n      //容器类的节点（子流程）在保存时要保留原宽高 \n      var stencil = _mxStencilRegistry[\"default\"].getStencil(cell.getShape(true));\n      width = stencil.w0;\n      height = stencil.h0;\n    }\n    var ret = {\n      resourceId: cell.getId(),\n      bounds: {\n        upperLeft: {\n          //左上节点坐标\n          x: geometry.x,\n          y: geometry.y\n        },\n        lowerRight: {\n          //右下节点坐标\n          x: geometry.x + width,\n          y: geometry.y + height\n        },\n        relative: geometry.relative,\n        offset: geometry.offset\n      },\n      style: cell.getStyle()\n    };\n    if (cell.children && cell.children.length) {\n      ret.childShapes = getChildrenGraph(cell.children, cell);\n    }\n    return ret;\n  };\n  if (this.edge) {\n    //边\n    json = getEdgeGraph(this);\n  } else if (this.vertex) {\n    //图形？\n    json = getVertexGraph(this);\n  } else if (this.id === 'node_1') {\n    //root TODO \n    json = getChildrenGraph(this.children, this);\n  }\n  return json;\n};\n\n/**\r\n* 将mxCell转换为activity explorer前端模型\r\n*/\nmxCell.prototype.toBpmnJSON = function (includeProperties) {\n  var json = {},\n    children = this.children;\n  var getChildrenJSON = function getChildrenJSON(children, cell, includeProperties) {\n    //如果是子流程，JSON中不添加children\n    if (cell.isContainable() === true) {\n      return [];\n    }\n    return children && children.map(function (cell, index) {\n      if (cell.edge) {\n        //边\n        return getEdgeJSON(cell, includeProperties);\n      } else if (cell.vertex) {\n        //图形？\n        return getVertexJSON(cell, includeProperties);\n      }\n      return [];\n    }) || [];\n  };\n  var getEdgeJSON = function getEdgeJSON(cell, includeProperties) {\n    var geometry = cell.getGeometry();\n    var dockers = geometry.points && geometry.points.map(function (point, index) {\n      return {\n        x: point.x,\n        y: point.y\n      };\n    }) || [];\n    var targetId = cell.target && cell.target.getId();\n    var ret = {\n      resourceId: cell.getId(),\n      //TODO id?\n      originId: cell.getOriginId(),\n      originPageId: cell.getOriginPageId(),\n      stencil: {\n        id: \"SequenceFlow\"\n      },\n      //TODO 类型区分\n      outgoing: [{\n        resourceId: targetId\n      }],\n      target: {\n        resourceId: targetId\n      },\n      bounds: {},\n      //中间节点\n      dockers: dockers,\n      childShapes: getChildrenJSON(cell.children, cell, includeProperties),\n      style: cell.getStyle()\n    };\n    if (includeProperties) {\n      ret.properties = cell.getProperties();\n    }\n    return ret;\n  };\n  var getVertexJSON = function getVertexJSON(cell, includeProperties) {\n    var geometry = cell.getGeometry();\n    var edges = cell.edges;\n    var outgoing = [];\n    edges && edges.forEach(function (edge, index) {\n      if (edge.source && edge.source.getId() === cell.getId()) {\n        outgoing.push({\n          resourceId: edge.getId()\n        });\n      }\n    });\n    var width = geometry.width;\n    var height = geometry.height;\n    if (cell.isContainable() === true) {\n      //容器类的节点（子流程）在保存时要保留原宽高 \n      var stencil = _mxStencilRegistry[\"default\"].getStencil(cell.getShape(true));\n      width = stencil.w0;\n      height = stencil.h0;\n    }\n    var ret = {\n      resourceId: cell.getId(),\n      originId: cell.getOriginId(),\n      originPageId: cell.getOriginPageId(),\n      stencil: {\n        id: cell.getType()\n      },\n      //TODO 类型区分\n      outgoing: outgoing,\n      //cell.target.getId() //TODO: target为空\n      bounds: {\n        upperLeft: {\n          //左上节点坐标\n          x: geometry.x,\n          y: geometry.y\n        },\n        lowerRight: {\n          //右下节点坐标\n          x: geometry.x + width,\n          y: geometry.y + height\n        },\n        relative: geometry.relative,\n        offset: geometry.offset\n      },\n      \"dockers\": [],\n      childShapes: getChildrenJSON(cell.children, cell, includeProperties),\n      style: cell.getStyle()\n    };\n    if (includeProperties) {\n      ret.properties = cell.getProperties();\n    }\n    return ret;\n  };\n  if (this.edge) {\n    //边\n    json = getEdgeJSON(this, includeProperties);\n  } else if (this.vertex) {\n    //图形？\n    json = getVertexJSON(this, includeProperties);\n  } else if (this.id === 'node_1') {\n    //root TODO \n    json = getChildrenJSON(this.children, this, includeProperties);\n  }\n  return json;\n};\nmxCell.prototype.toBpmnJSONString = function (includeProperties) {\n  var cellJson = this.toBpmnJSON(includeProperties);\n  return JSON.stringify(cellJson);\n};\nmxCell.prototype.getProperties = function () {\n  var _this = this;\n  var props = this.properties || {};\n  //处理属性中的${node.xxx}\n  return JSON.parse(JSON.stringify(props).replace(/\\$\\{node\\.(\\w+)\\.?(\\w+)?\\}/g, function (str, groupName, propName) {\n    return _this.getProperty(groupName, propName);\n  }));\n};\nmxCell.prototype.setProperties = function (properties) {\n  this.properties = properties;\n};\n\n//防止打包的时候functionName被简化\nmxCell.getName = function () {\n  return 'mxCell';\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxGeometry\r\n *\r\n * Extends <mxRectangle> to represent the geometry of a cell.\r\n *\r\n * For vertices, the geometry consists of the x- and y-location, and the width\r\n * and height. For edges, the geometry consists of the optional terminal- and\r\n * control points. The terminal points are only required if an edge is\r\n * unconnected, and are stored in the sourcePoint> and <targetPoint>\r\n * variables, respectively.\r\n *\r\n * Example:\r\n *\r\n * If an edge is unconnected, that is, it has no source or target terminal,\r\n * then a geometry with terminal points for a new edge can be defined as\r\n * follows.\r\n *\r\n * (code)\r\n * geometry.setTerminalPoint(new mxPoint(x1, y1), true);\r\n * geometry.points = [new mxPoint(x2, y2)];\r\n * geometry.setTerminalPoint(new mxPoint(x3, y3), false);\r\n * (end)\r\n *\r\n * Control points are used regardless of the connected state of an edge and may\r\n * be ignored or interpreted differently depending on the edge's <mxEdgeStyle>.\r\n *\r\n * To disable automatic reset of control points after a cell has been moved or\r\n * resized, the the <mxGraph.resizeEdgesOnMove> and\r\n * <mxGraph.resetEdgesOnResize> may be used.\r\n *\r\n * Edge Labels:\r\n *\r\n * Using the x- and y-coordinates of a cell's geometry, it is possible to\r\n * position the label on edges on a specific location on the actual edge shape\r\n * as it appears on the screen. The x-coordinate of an edge's geometry is used\r\n * to describe the distance from the center of the edge from -1 to 1 with 0\r\n * being the center of the edge and the default value. The y-coordinate of an\r\n * edge's geometry is used to describe the absolute, orthogonal distance in\r\n * pixels from that point. In addition, the <mxGeometry.offset> is used as an\r\n * absolute offset vector from the resulting point.\r\n *\r\n * This coordinate system is applied if <relative> is true, otherwise the\r\n * offset defines the absolute vector from the edge's center point to the\r\n * label and the values for <x> and <y> are ignored.\r\n *\r\n * The width and height parameter for edge geometries can be used to set the\r\n * label width and height (eg. for word wrapping).\r\n *\r\n * Ports:\r\n *\r\n * The term \"port\" refers to a relatively positioned, connectable child cell,\r\n * which is used to specify the connection between the parent and another cell\r\n * in the graph. Ports are typically modeled as vertices with relative\r\n * geometries.\r\n *\r\n * Offsets:\r\n *\r\n * The <offset> field is interpreted in 3 different ways, depending on the cell\r\n * and the geometry. For edges, the offset defines the absolute offset for the\r\n * edge label. For relative geometries, the offset defines the absolute offset\r\n * for the origin (top, left corner) of the vertex, otherwise the offset\r\n * defines the absolute offset for the label inside the vertex or group.\r\n *\r\n * Constructor: mxGeometry\r\n *\r\n * Constructs a new object to describe the size and location of a vertex or\r\n * the control points of an edge.\r\n */\nvar _default = exports[\"default\"] = mxCell;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxCell.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxCellAttributeChange.js":
/*!********************************************************!*\
  !*** ./src/workflow/mxClient/mxCellAttributeChange.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nfunction mxCellAttributeChange(cell, attribute, value) {\n  this.cell = cell;\n  this.attribute = attribute;\n  this.value = value;\n  this.previous = value;\n}\n;\n\n/**\r\n * Function: execute\r\n *\r\n * Changes the attribute of the cell's user object by\r\n * using <mxCell.setAttribute>.\r\n */\nmxCellAttributeChange.prototype.execute = function () {\n  var tmp = this.cell.getAttribute(this.attribute);\n  if (this.previous == null) {\n    this.cell.value.removeAttribute(this.attribute);\n  } else {\n    this.cell.setAttribute(this.attribute, this.previous);\n  }\n  this.previous = tmp;\n};\nmxCellAttributeChange.getName = function () {\n  return 'mxCellAttributeChange';\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxCell\r\n *\r\n * Cells are the elements of the graph model. They represent the state\r\n * of the groups, vertices and edges in a graph.\r\n *\r\n * Custom attributes:\r\n *\r\n * For custom attributes we recommend using an XML node as the value of a cell.\r\n * The following code can be used to create a cell with an XML node as the\r\n * value:\r\n *\r\n * (code)\r\n * var doc = mxUtils.createXmlDocument();\r\n * var node = doc.createElement('MyNode')\r\n * node.setAttribute('label', 'MyLabel');\r\n * node.setAttribute('attribute1', 'value1');\r\n * graph.insertVertex(graph.getDefaultParent(), null, node, 40, 40, 80, 30);\r\n * (end)\r\n *\r\n * For the label to work, <mxGraph.convertValueToString> and\r\n * <mxGraph.cellLabelChanged> should be overridden as follows:\r\n *\r\n * (code)\r\n * graph.convertValueToString = function(cell)\r\n * {\r\n *   if (mxGraphUtils.isNode(cell.value))\r\n *   {\r\n *     return cell.getAttribute('label', '')\r\n *   }\r\n * };\r\n *\r\n * var cellLabelChanged = graph.cellLabelChanged;\r\n * graph.cellLabelChanged = function(cell, newValue, autoSize)\r\n * {\r\n *   if (mxGraphUtils.isNode(cell.value))\r\n *   {\r\n *     // Clones the value for correct undo/redo\r\n *     var elt = cell.value.cloneNode(true);\r\n *     elt.setAttribute('label', newValue);\r\n *     newValue = elt;\r\n *   }\r\n *\r\n *   cellLabelChanged.apply(this, arguments);\r\n * };\r\n * (end)\r\n *\r\n * Callback: onInit\r\n *\r\n * Called from within the constructor.\r\n *\r\n * Constructor: mxCell\r\n *\r\n * Constructs a new cell to be used in a graph model.\r\n * This method invokes <onInit> upon completion.\r\n *\r\n * Parameters:\r\n *\r\n * value - Optional object that represents the cell value.\r\n * geometry - Optional <mxGeometry> that specifies the geometry.\r\n * style - Optional formatted string that defines the style.\r\n */\nvar _default = exports[\"default\"] = mxCellAttributeChange;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxCellAttributeChange.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxCellEditor.js":
/*!***********************************************!*\
  !*** ./src/workflow/mxClient/mxCellEditor.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.function.bind.js */ \"../../node_modules/core-js/modules/es.function.bind.js\");\n__webpack_require__(/*! core-js/modules/es.parse-float.js */ \"../../node_modules/core-js/modules/es.parse-float.js\");\n__webpack_require__(/*! core-js/modules/es.parse-int.js */ \"../../node_modules/core-js/modules/es.parse-int.js\");\n__webpack_require__(/*! core-js/modules/es.regexp.exec.js */ \"../../node_modules/core-js/modules/es.regexp.exec.js\");\n__webpack_require__(/*! core-js/modules/es.string.replace.js */ \"../../node_modules/core-js/modules/es.string.replace.js\");\n__webpack_require__(/*! core-js/modules/web.timers.js */ \"../../node_modules/core-js/modules/web.timers.js\");\nvar _mxClient = _interopRequireDefault(__webpack_require__(/*! ./mxClient.js */ \"./src/workflow/mxClient/mxClient.js\"));\nvar _mxEvent = _interopRequireDefault(__webpack_require__(/*! ./mxEvent.js */ \"./src/workflow/mxClient/mxEvent.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxRectangle = _interopRequireDefault(__webpack_require__(/*! ./mxRectangle.js */ \"./src/workflow/mxClient/mxRectangle.js\"));\nvar _mxText = _interopRequireDefault(__webpack_require__(/*! ./mxText.js */ \"./src/workflow/mxClient/mxText.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ./mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nvar _mxUtils = _interopRequireDefault(__webpack_require__(/*! ./mxUtils.js */ \"./src/workflow/mxClient/mxUtils.js\"));\nvar _mxPoint = _interopRequireDefault(__webpack_require__(/*! ./mxPoint */ \"./src/workflow/mxClient/mxPoint.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxCellEditor(graph) {\n  this.graph = graph;\n\n  // Stops editing after zoom changes\n  this.zoomHandler = _mxGraphUtils[\"default\"].bind(this, function () {\n    if (this.graph.isEditing()) {\n      this.resize();\n    }\n  });\n  this.graph.view.addListener(_mxEvent[\"default\"].SCALE, this.zoomHandler);\n  this.graph.view.addListener(_mxEvent[\"default\"].SCALE_AND_TRANSLATE, this.zoomHandler);\n}\n;\n\n/**\r\n * Variable: graph\r\n *\r\n * Reference to the enclosing <mxGraph>.\r\n */\nmxCellEditor.prototype.graph = null;\n\n/**\r\n * Variable: textarea\r\n *\r\n * Holds the DIV that is used for text editing. Note that this may be null before the first\r\n * edit. Instantiated in <init>.\r\n */\nmxCellEditor.prototype.textarea = null;\n\n/**\r\n * Variable: editingCell\r\n *\r\n * Reference to the <mxCell> that is currently being edited.\r\n */\nmxCellEditor.prototype.editingCell = null;\n\n/**\r\n * Variable: trigger\r\n *\r\n * Reference to the event that was used to start editing.\r\n */\nmxCellEditor.prototype.trigger = null;\n\n/**\r\n * Variable: modified\r\n *\r\n * Specifies if the label has been modified.\r\n */\nmxCellEditor.prototype.modified = false;\n\n/**\r\n * Variable: autoSize\r\n *\r\n * Specifies if the textarea should be resized while the text is being edited.\r\n * Default is true.\r\n */\nmxCellEditor.prototype.autoSize = true;\n\n/**\r\n * Variable: selectText\r\n *\r\n * Specifies if the text should be selected when editing starts. Default is\r\n * true.\r\n */\nmxCellEditor.prototype.selectText = true;\n\n/**\r\n * Variable: emptyLabelText\r\n *\r\n * Text to be displayed for empty labels. Default is '' or '<br>' in Firefox as\r\n * a workaround for the missing cursor bug for empty content editable. This can\r\n * be set to eg. \"[Type Here]\" to easier visualize editing of empty labels. The\r\n * value is only displayed before the first keystroke and is never used as the\r\n * actual editing value.\r\n */\nmxCellEditor.prototype.emptyLabelText = _mxClient[\"default\"].IS_FF ? '<br>' : '';\n\n/**\r\n * Variable: escapeCancelsEditing\r\n *\r\n * If true, pressing the escape key will stop editing and not accept the new\r\n * value. Change this to false to accept the new value on escape, and cancel\r\n * editing on Shift+Escape instead. Default is true.\r\n */\nmxCellEditor.prototype.escapeCancelsEditing = true;\n\n/**\r\n * Variable: textNode\r\n *\r\n * Reference to the label DOM node that has been hidden.\r\n */\nmxCellEditor.prototype.textNode = '';\n\n/**\r\n * Variable: zIndex\r\n *\r\n * Specifies the zIndex for the textarea. Default is 5.\r\n */\nmxCellEditor.prototype.zIndex = 5;\n\n/**\r\n * Variable: minResize\r\n *\r\n * Defines the minimum width and height to be used in <resize>. Default is 0x20px.\r\n */\nmxCellEditor.prototype.minResize = new _mxRectangle[\"default\"](0, 20);\n\n/**\r\n * Variable: wordWrapPadding\r\n *\r\n * Correction factor for word wrapping width. Default is 2 in quirks, 0 in IE\r\n * 11 and 1 in all other browsers and modes.\r\n */\nmxCellEditor.prototype.wordWrapPadding = _mxClient[\"default\"].IS_QUIRKS ? 2 : !_mxClient[\"default\"].IS_IE11 ? 1 : 0;\n\n/**\r\n * Variable: blurEnabled\r\n *\r\n * If <focusLost> should be called if <textarea> loses the focus. Default is false.\r\n */\nmxCellEditor.prototype.blurEnabled = false;\n\n/**\r\n * Variable: initialValue\r\n *\r\n * Holds the initial editing value to check if the current value was modified.\r\n */\nmxCellEditor.prototype.initialValue = null;\n\n/**\r\n * Function: init\r\n *\r\n * Creates the <textarea> and installs the event listeners. The key handler\r\n * updates the <modified> state.\r\n */\nmxCellEditor.prototype.init = function () {\n  this.textarea = document.createElement('div');\n  //this.textarea.className = 'mxCellEditor mxPlainTextEditor';\n  this.textarea.style.background = \" url('../images/transparent_common.gif')\";\n  this.textarea.style.borderColor = \"transparent\";\n  this.textarea.style.borderStyle = \"solid\";\n  this.textarea.style.position = \"absolute\";\n  this.textarea.style.overflow = \"visible\";\n  this.textarea.style.wordWrap = \"normal\";\n  this.textarea.style.borderWidth = \"0\";\n  this.textarea.style.minWidth = \"1px\";\n  this.textarea.style.resize = \"none\";\n  this.textarea.style.padding = \"0px\";\n  this.textarea.style.margin = \"0px\";\n  this.textarea.contentEditable = true;\n  this.installListeners(this.textarea);\n};\n\n/**\r\n * Function: applyValue\r\n *\r\n * Called in <stopEditing> if cancel is false to invoke <mxGraph.labelChanged>.\r\n */\nmxCellEditor.prototype.applyValue = function (state, value) {\n  this.graph.labelChanged(state.cell, value, this.trigger);\n};\n\n/**\r\n * Function: getInitialValue\r\n *\r\n * Gets the initial editing value for the given cell.\r\n */\nmxCellEditor.prototype.getInitialValue = function (state, trigger) {\n  var result = _mxGraphUtils[\"default\"].htmlEntities(this.graph.getEditingValue(state.cell, trigger), false);\n\n  // Workaround for trailing line breaks being ignored in the editor\n  if (!_mxClient[\"default\"].IS_QUIRKS && document.documentMode != 8 && document.documentMode != 9 && document.documentMode != 10) {\n    result = _mxGraphUtils[\"default\"].replaceTrailingNewlines(result, '<div><br></div>');\n  }\n  return result.replace(/\\n/g, '<br>');\n};\n\n/**\r\n * Function: getCurrentValue\r\n *\r\n * Returns the current editing value.\r\n */\nmxCellEditor.prototype.getCurrentValue = function (state) {\n  var result = _mxUtils[\"default\"].extractTextWithWhitespace(this.textarea.childNodes);\n\n  // Strips trailing line break\n  if (result.length > 0 && result.charAt(result.length - 1) == '\\n') {\n    result = result.substring(0, result.length - 1);\n  }\n  return result;\n};\n\n/**\r\n * Function: installListeners\r\n *\r\n * Installs listeners for focus, change and standard key event handling.\r\n */\nmxCellEditor.prototype.installListeners = function (elt) {\n  // Applies value if focus is lost\n  _mxEvent[\"default\"].addListener(elt, 'blur', _mxGraphUtils[\"default\"].bind(this, function (evt) {\n    if (this.blurEnabled) {\n      this.focusLost(evt);\n    }\n  }));\n\n  // Updates modified state and handles placeholder text\n  _mxEvent[\"default\"].addListener(elt, 'keydown', _mxGraphUtils[\"default\"].bind(this, function (evt) {\n    if (!_mxEvent[\"default\"].isConsumed(evt)) {\n      if (this.isStopEditingEvent(evt)) {\n        this.graph.stopEditing(false);\n        _mxEvent[\"default\"].consume(evt);\n      } else if (evt.keyCode == 27 /* Escape */) {\n        this.graph.stopEditing(this.escapeCancelsEditing || _mxEvent[\"default\"].isShiftDown(evt));\n        _mxEvent[\"default\"].consume(evt);\n      }\n    }\n  }));\n\n  // Adds handling of deleted cells while editing\n  this.changeHandler = _mxGraphUtils[\"default\"].bind(this, function (sender) {\n    if (this.editingCell != null && this.graph.getView().getState(this.editingCell) == null) {\n      this.stopEditing(true);\n    }\n  });\n  this.graph.getModel().addListener(_mxEvent[\"default\"].CHANGE, this.changeHandler);\n\n  // Keypress only fires if printable key was pressed and handles removing the empty placeholder\n  var keypressHandler = _mxGraphUtils[\"default\"].bind(this, function (evt) {\n    if (this.editingCell != null) {\n      // Clears the initial empty label on the first keystroke\n      // and workaround for FF which fires keypress for delete and backspace\n      if (this.clearOnChange && elt.innerHTML == this.getEmptyLabelText() && (!_mxClient[\"default\"].IS_FF || evt.keyCode != 8 /* Backspace */ && evt.keyCode != 46 /* Delete */)) {\n        this.clearOnChange = false;\n        elt.innerHTML = '';\n      }\n    }\n  });\n  _mxEvent[\"default\"].addListener(elt, 'keypress', keypressHandler);\n  _mxEvent[\"default\"].addListener(elt, 'paste', keypressHandler);\n\n  // Handler for updating the empty label text value after a change\n  var keyupHandler = _mxGraphUtils[\"default\"].bind(this, function (evt) {\n    if (this.editingCell != null) {\n      // Uses an optional text value for sempty labels which is cleared\n      // when the first keystroke appears. This makes it easier to see\n      // that a label is being edited even if the label is empty.\n      // In Safari and FF, an empty text is represented by <BR> which isn't enough to force a valid size\n      if (this.textarea.innerHTML.length == 0 || this.textarea.innerHTML == '<br>') {\n        this.textarea.innerHTML = this.getEmptyLabelText();\n        this.clearOnChange = this.textarea.innerHTML.length > 0;\n      } else {\n        this.clearOnChange = false;\n      }\n    }\n  });\n  _mxEvent[\"default\"].addListener(elt, !_mxClient[\"default\"].IS_IE11 && !_mxClient[\"default\"].IS_IE ? 'input' : 'keyup', keyupHandler);\n  _mxEvent[\"default\"].addListener(elt, 'cut', keyupHandler);\n  _mxEvent[\"default\"].addListener(elt, 'paste', keyupHandler);\n\n  // Adds automatic resizing of the textbox while typing using input, keyup and/or DOM change events\n  var evtName = !_mxClient[\"default\"].IS_IE11 && !_mxClient[\"default\"].IS_IE ? 'input' : 'keydown';\n  var resizeHandler = _mxGraphUtils[\"default\"].bind(this, function (evt) {\n    if (this.editingCell != null && this.autoSize && !_mxEvent[\"default\"].isConsumed(evt)) {\n      // Asynchronous is needed for keydown and shows better results for input events overall\n      // (ie non-blocking and cases where the offsetWidth/-Height was wrong at this time)\n      if (this.resizeThread != null) {\n        window.clearTimeout(this.resizeThread);\n      }\n      this.resizeThread = window.setTimeout(_mxGraphUtils[\"default\"].bind(this, function () {\n        this.resizeThread = null;\n        this.resize();\n      }), 0);\n    }\n  });\n  _mxEvent[\"default\"].addListener(elt, evtName, resizeHandler);\n  if (document.documentMode >= 9) {\n    _mxEvent[\"default\"].addListener(elt, 'DOMNodeRemoved', resizeHandler);\n    _mxEvent[\"default\"].addListener(elt, 'DOMNodeInserted', resizeHandler);\n  } else {\n    _mxEvent[\"default\"].addListener(elt, 'cut', resizeHandler);\n    _mxEvent[\"default\"].addListener(elt, 'paste', resizeHandler);\n  }\n};\n\n/**\r\n * Function: isStopEditingEvent\r\n *\r\n * Returns true if the given keydown event should stop cell editing. This\r\n * returns true if F2 is pressed of if <mxGraph.enterStopsCellEditing> is true\r\n * and enter is pressed without control or shift.\r\n */\nmxCellEditor.prototype.isStopEditingEvent = function (evt) {\n  return evt.keyCode == 113 /* F2 */ || this.graph.isEnterStopsCellEditing() && evt.keyCode == 13 /* Enter */ && !_mxEvent[\"default\"].isControlDown(evt) && !_mxEvent[\"default\"].isShiftDown(evt);\n};\n\n/**\r\n * Function: isEventSource\r\n *\r\n * Returns true if this editor is the source for the given native event.\r\n */\nmxCellEditor.prototype.isEventSource = function (evt) {\n  return _mxEvent[\"default\"].getSource(evt) == this.textarea;\n};\n\n/**\r\n * Function: resize\r\n *\r\n * Returns <modified>.\r\n */\nmxCellEditor.prototype.resize = function () {\n  var state = this.graph.getView().getState(this.editingCell);\n  if (state == null) {\n    this.stopEditing(true);\n  } else {\n    var isEdge = this.graph.getModel().isEdge(state.cell);\n    var scale = this.graph.getView().scale;\n    var m = null;\n    if (!this.autoSize || state.style[_mxConstants[\"default\"].STYLE_OVERFLOW] == 'fill') {\n      // Specifies the bounds of the editor box\n      this.bounds = this.getEditorBounds(state);\n      this.textarea.style.width = Math.round(this.bounds.width / scale) + 'px';\n      this.textarea.style.height = Math.round(this.bounds.height / scale) + 'px';\n\n      // FIXME: Offset when scaled\n      if (document.documentMode == 8 || _mxClient[\"default\"].IS_QUIRKS) {\n        this.textarea.style.left = Math.round(this.bounds.x) + 'px';\n        this.textarea.style.top = Math.round(this.bounds.y) + 'px';\n      } else {\n        this.textarea.style.left = Math.max(0, Math.round(this.bounds.x + 1)) + 'px';\n        this.textarea.style.top = Math.max(0, Math.round(this.bounds.y + 1)) + 'px';\n      }\n\n      // Installs native word wrapping and avoids word wrap for empty label placeholder\n      if (this.graph.isWrapping(state.cell) && (this.bounds.width >= 2 || this.bounds.height >= 2) && this.textarea.innerHTML != this.getEmptyLabelText()) {\n        this.textarea.style.wordWrap = _mxConstants[\"default\"].WORD_WRAP;\n        this.textarea.style.whiteSpace = 'normal';\n        if (state.style[_mxConstants[\"default\"].STYLE_OVERFLOW] != 'fill') {\n          this.textarea.style.width = Math.round(this.bounds.width / scale) + this.wordWrapPadding + 'px';\n        }\n      } else {\n        this.textarea.style.whiteSpace = 'nowrap';\n        if (state.style[_mxConstants[\"default\"].STYLE_OVERFLOW] != 'fill') {\n          this.textarea.style.width = '';\n        }\n      }\n    } else {\n      var lw = _mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_LABEL_WIDTH, null);\n      m = state.text != null ? state.text.margin : null;\n      if (m == null) {\n        m = _mxGraphUtils[\"default\"].getAlignmentAsPoint(_mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_ALIGN, _mxConstants[\"default\"].ALIGN_CENTER), _mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_VERTICAL_ALIGN, _mxConstants[\"default\"].ALIGN_MIDDLE), _mxPoint[\"default\"]);\n      }\n      if (isEdge) {\n        this.bounds = new _mxRectangle[\"default\"](state.absoluteOffset.x, state.absoluteOffset.y, 0, 0);\n        if (lw != null) {\n          var tmp = (parseFloat(lw) + 2) * scale;\n          this.bounds.width = tmp;\n          this.bounds.x += m.x * tmp;\n        }\n      } else {\n        var bds = _mxRectangle[\"default\"].fromRectangle(state);\n        var hpos = _mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_LABEL_POSITION, _mxConstants[\"default\"].ALIGN_CENTER);\n        var vpos = _mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_VERTICAL_LABEL_POSITION, _mxConstants[\"default\"].ALIGN_MIDDLE);\n        bds = state.shape != null && hpos == _mxConstants[\"default\"].ALIGN_CENTER && vpos == _mxConstants[\"default\"].ALIGN_MIDDLE ? state.shape.getLabelBounds(bds) : bds;\n        if (lw != null) {\n          bds.width = parseFloat(lw) * scale;\n        }\n        if (!state.view.graph.cellRenderer.legacySpacing || state.style[_mxConstants[\"default\"].STYLE_OVERFLOW] != 'width') {\n          var spacing = parseInt(state.style[_mxConstants[\"default\"].STYLE_SPACING] || 2) * scale;\n          var spacingTop = (parseInt(state.style[_mxConstants[\"default\"].STYLE_SPACING_TOP] || 0) + _mxText[\"default\"].prototype.baseSpacingTop) * scale + spacing;\n          var spacingRight = (parseInt(state.style[_mxConstants[\"default\"].STYLE_SPACING_RIGHT] || 0) + _mxText[\"default\"].prototype.baseSpacingRight) * scale + spacing;\n          var spacingBottom = (parseInt(state.style[_mxConstants[\"default\"].STYLE_SPACING_BOTTOM] || 0) + _mxText[\"default\"].prototype.baseSpacingBottom) * scale + spacing;\n          var spacingLeft = (parseInt(state.style[_mxConstants[\"default\"].STYLE_SPACING_LEFT] || 0) + _mxText[\"default\"].prototype.baseSpacingLeft) * scale + spacing;\n          var hpos = _mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_LABEL_POSITION, _mxConstants[\"default\"].ALIGN_CENTER);\n          var vpos = _mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_VERTICAL_LABEL_POSITION, _mxConstants[\"default\"].ALIGN_MIDDLE);\n          bds = new _mxRectangle[\"default\"](bds.x + spacingLeft, bds.y + spacingTop, bds.width - (hpos == _mxConstants[\"default\"].ALIGN_CENTER && lw == null ? spacingLeft + spacingRight : 0), bds.height - (vpos == _mxConstants[\"default\"].ALIGN_MIDDLE ? spacingTop + spacingBottom : 0));\n        }\n        this.bounds = new _mxRectangle[\"default\"](bds.x + state.absoluteOffset.x, bds.y + state.absoluteOffset.y, bds.width, bds.height);\n      }\n\n      // Needed for word wrap inside text blocks with oversize lines to match the final result where\n      // the width of the longest line is used as the reference for text alignment in the cell\n      // TODO: Fix word wrapping preview for edge labels in helloworld.html\n      if (this.graph.isWrapping(state.cell) && (this.bounds.width >= 2 || this.bounds.height >= 2) && this.textarea.innerHTML != this.getEmptyLabelText()) {\n        this.textarea.style.wordWrap = _mxConstants[\"default\"].WORD_WRAP;\n        this.textarea.style.whiteSpace = 'normal';\n\n        // Forces automatic reflow if text is removed from an oversize label and normal word wrap\n        var tmp = Math.round(this.bounds.width / scale) + this.wordWrapPadding;\n        this.textarea.style.width = tmp + 'px';\n        if (this.textarea.scrollWidth > tmp) {\n          this.textarea.style.width = this.textarea.scrollWidth + 'px';\n        }\n      } else {\n        // KNOWN: Trailing cursor in IE9 quirks mode is not visible\n        this.textarea.style.whiteSpace = 'nowrap';\n        this.textarea.style.width = '';\n      }\n\n      // LATER: Keep in visible area, add fine tuning for pixel precision\n      // Workaround for wrong measuring in IE8 standards\n      if (document.documentMode == 8) {\n        this.textarea.style.zoom = '1';\n        this.textarea.style.height = 'auto';\n      }\n      var ow = this.textarea.scrollWidth;\n      var oh = this.textarea.scrollHeight;\n\n      // TODO: Update CSS width and height if smaller than minResize or remove minResize\n      //if (this.minResize != null)\n      //{\n      //\tow = Math.max(ow, this.minResize.width);\n      //\toh = Math.max(oh, this.minResize.height);\n      //}\n\n      // LATER: Keep in visible area, add fine tuning for pixel precision\n      if (document.documentMode == 8) {\n        // LATER: Scaled wrapping and position is wrong in IE8\n        this.textarea.style.left = Math.max(0, Math.ceil((this.bounds.x - m.x * (this.bounds.width - (ow + 1) * scale) + ow * (scale - 1) * 0 + (m.x + 0.5) * 2) / scale)) + 'px';\n        this.textarea.style.top = Math.max(0, Math.ceil((this.bounds.y - m.y * (this.bounds.height - (oh + 0.5) * scale) + oh * (scale - 1) * 0 + Math.abs(m.y + 0.5) * 1) / scale)) + 'px';\n        // Workaround for wrong event handling width and height\n        this.textarea.style.width = Math.round(ow * scale) + 'px';\n        this.textarea.style.height = Math.round(oh * scale) + 'px';\n      } else if (_mxClient[\"default\"].IS_QUIRKS) {\n        this.textarea.style.left = Math.max(0, Math.ceil(this.bounds.x - m.x * (this.bounds.width - (ow + 1) * scale) + ow * (scale - 1) * 0 + (m.x + 0.5) * 2)) + 'px';\n        this.textarea.style.top = Math.max(0, Math.ceil(this.bounds.y - m.y * (this.bounds.height - (oh + 0.5) * scale) + oh * (scale - 1) * 0 + Math.abs(m.y + 0.5) * 1)) + 'px';\n      } else {\n        this.textarea.style.left = Math.max(0, Math.round(this.bounds.x - m.x * (this.bounds.width - 2)) + 1) + 'px';\n        this.textarea.style.top = Math.max(0, Math.round(this.bounds.y - m.y * (this.bounds.height - 4) + (m.y == -1 ? 3 : 0)) + 1) + 'px';\n      }\n    }\n    if (_mxClient[\"default\"].IS_VML) {\n      this.textarea.style.zoom = scale;\n    } else {\n      _mxGraphUtils[\"default\"].setPrefixedStyle(this.textarea.style, 'transformOrigin', '0px 0px');\n      _mxGraphUtils[\"default\"].setPrefixedStyle(this.textarea.style, 'transform', 'scale(' + scale + ',' + scale + ')' + (m == null ? '' : ' translate(' + m.x * 100 + '%,' + m.y * 100 + '%)'));\n    }\n  }\n};\n\n/**\r\n * Function: focusLost\r\n *\r\n * Called if the textarea has lost focus.\r\n */\nmxCellEditor.prototype.focusLost = function () {\n  this.stopEditing(!this.graph.isInvokesStopCellEditing());\n};\n\n/**\r\n * Function: getBackgroundColor\r\n *\r\n * Returns the background color for the in-place editor. This implementation\r\n * always returns null.\r\n */\nmxCellEditor.prototype.getBackgroundColor = function (state) {\n  return null;\n};\n\n/**\r\n * Function: startEditing\r\n *\r\n * Starts the editor for the given cell.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> to start editing.\r\n * trigger - Optional mouse event that triggered the editor.\r\n */\nmxCellEditor.prototype.startEditing = function (cell, trigger) {\n  // Lazy instantiates textarea to save memory in IE\n  if (this.textarea == null) {\n    this.init();\n  }\n  if (this.graph.tooltipHandler != null) {\n    this.graph.tooltipHandler.hideTooltip();\n  }\n  this.stopEditing(true);\n  var state = this.graph.getView().getState(cell);\n  if (state != null) {\n    // Configures the style of the in-place editor\n    var scale = this.graph.getView().scale;\n    var size = _mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_FONTSIZE, _mxConstants[\"default\"].DEFAULT_FONTSIZE);\n    var family = _mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_FONTFAMILY, _mxConstants[\"default\"].DEFAULT_FONTFAMILY);\n    var color = _mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_FONTCOLOR, 'black');\n    var align = _mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_ALIGN, _mxConstants[\"default\"].ALIGN_LEFT);\n    var bold = (_mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_FONTSTYLE, 0) & _mxConstants[\"default\"].FONT_BOLD) == _mxConstants[\"default\"].FONT_BOLD;\n    var italic = (_mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_FONTSTYLE, 0) & _mxConstants[\"default\"].FONT_ITALIC) == _mxConstants[\"default\"].FONT_ITALIC;\n    var uline = (_mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_FONTSTYLE, 0) & _mxConstants[\"default\"].FONT_UNDERLINE) == _mxConstants[\"default\"].FONT_UNDERLINE;\n    this.textarea.style.lineHeight = _mxConstants[\"default\"].ABSOLUTE_LINE_HEIGHT ? Math.round(size * _mxConstants[\"default\"].LINE_HEIGHT) + 'px' : _mxConstants[\"default\"].LINE_HEIGHT;\n    this.textarea.style.backgroundColor = this.getBackgroundColor(state);\n    this.textarea.style.textDecoration = uline ? 'underline' : '';\n    this.textarea.style.fontWeight = bold ? 'bold' : 'normal';\n    this.textarea.style.fontStyle = italic ? 'italic' : '';\n    this.textarea.style.fontSize = Math.round(size) + 'px';\n    this.textarea.style.zIndex = this.zIndex;\n    this.textarea.style.fontFamily = family;\n    this.textarea.style.textAlign = align;\n    this.textarea.style.outline = 'none';\n    this.textarea.style.color = color;\n    var dir = this.textDirection = _mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_TEXT_DIRECTION, _mxConstants[\"default\"].DEFAULT_TEXT_DIRECTION);\n    if (dir == _mxConstants[\"default\"].TEXT_DIRECTION_AUTO) {\n      if (state != null && state.text != null && state.text.dialect != _mxConstants[\"default\"].DIALECT_STRICTHTML && !_mxGraphUtils[\"default\"].isNode(state.text.value)) {\n        dir = state.text.getAutoDirection();\n      }\n    }\n    if (dir == _mxConstants[\"default\"].TEXT_DIRECTION_LTR || dir == _mxConstants[\"default\"].TEXT_DIRECTION_RTL) {\n      this.textarea.setAttribute('dir', dir);\n    } else {\n      this.textarea.removeAttribute('dir');\n    }\n\n    // Sets the initial editing value\n    this.textarea.innerHTML = this.getInitialValue(state, trigger) || '';\n    this.initialValue = this.textarea.innerHTML;\n\n    // Uses an optional text value for empty labels which is cleared\n    // when the first keystroke appears. This makes it easier to see\n    // that a label is being edited even if the label is empty.\n    if (this.textarea.innerHTML.length == 0 || this.textarea.innerHTML == '<br>') {\n      this.textarea.innerHTML = this.getEmptyLabelText();\n      this.clearOnChange = true;\n    } else {\n      this.clearOnChange = this.textarea.innerHTML == this.getEmptyLabelText();\n    }\n    this.graph.container.appendChild(this.textarea);\n\n    // Update this after firing all potential events that could update the cleanOnChange flag\n    this.editingCell = cell;\n    this.trigger = trigger;\n    this.textNode = null;\n    if (state.text != null && this.isHideLabel(state)) {\n      this.textNode = state.text.node;\n      this.textNode.style.visibility = 'hidden';\n    }\n\n    // Workaround for initial offsetHeight not ready for heading in markup\n    if (this.autoSize && (this.graph.model.isEdge(state.cell) || state.style[_mxConstants[\"default\"].STYLE_OVERFLOW] != 'fill')) {\n      window.setTimeout(_mxGraphUtils[\"default\"].bind(this, function () {\n        this.resize();\n      }), 0);\n    }\n    this.resize();\n    if (this.textarea != null) {\n      // Workaround for NS_ERROR_FAILURE in FF\n      try {\n        // Prefers blinking cursor over no selected text if empty\n        this.textarea.focus();\n        if (this.isSelectText() && this.textarea.innerHTML.length > 0 && (this.textarea.innerHTML != this.getEmptyLabelText() || !this.clearOnChange)) {\n          document.execCommand('selectAll', false, null);\n        }\n      } catch (e) {\n        // ignore\n      }\n    }\n  }\n};\n\n/**\r\n * Function: isSelectText\r\n *\r\n * Returns <selectText>.\r\n */\nmxCellEditor.prototype.isSelectText = function () {\n  return this.selectText;\n};\n\n/**\r\n * Function: stopEditing\r\n *\r\n * Stops the editor and applies the value if cancel is false.\r\n */\nmxCellEditor.prototype.stopEditing = function (cancel) {\n  cancel = cancel || false;\n  if (this.editingCell != null) {\n    if (this.textNode != null) {\n      this.textNode.style.visibility = 'visible';\n      this.textNode = null;\n    }\n    var state = !cancel ? this.graph.view.getState(this.editingCell) : null;\n    var initial = this.initialValue;\n    this.initialValue = null;\n    this.editingCell = null;\n    this.trigger = null;\n    this.bounds = null;\n    this.textarea.blur();\n    if (this.textarea.parentNode != null) {\n      this.textarea.parentNode.removeChild(this.textarea);\n    }\n    if (this.clearOnChange && this.textarea.innerHTML == this.getEmptyLabelText()) {\n      this.textarea.innerHTML = '';\n      this.clearOnChange = false;\n    }\n    if (state != null && this.textarea.innerHTML != initial) {\n      var value = this.getCurrentValue(state);\n      if (value != null) {\n        this.applyValue(state, value);\n      }\n    }\n  }\n};\n\n/**\r\n * Function: isHideLabel\r\n *\r\n * Returns true if the label should be hidden while the cell is being\r\n * edited.\r\n */\nmxCellEditor.prototype.isHideLabel = function (state) {\n  return true;\n};\n\n/**\r\n * Function: getMinimumSize\r\n *\r\n * Returns the minimum width and height for editing the given state.\r\n */\nmxCellEditor.prototype.getMinimumSize = function (state) {\n  var scale = this.graph.getView().scale;\n  return new _mxRectangle[\"default\"](0, 0, state.text == null ? 30 : state.text.size * scale + 20, this.textarea.style.textAlign == 'left' ? 120 : 40);\n};\n\n/**\r\n * Function: getEditorBounds\r\n *\r\n * Returns the <mxRectangle> that defines the bounds of the editor.\r\n */\nmxCellEditor.prototype.getEditorBounds = function (state) {\n  var isEdge = this.graph.getModel().isEdge(state.cell);\n  var scale = this.graph.getView().scale;\n  var minSize = this.getMinimumSize(state);\n  var minWidth = minSize.width;\n  var minHeight = minSize.height;\n  var result = null;\n  if (!isEdge && state.view.graph.cellRenderer.legacySpacing && state.style[_mxConstants[\"default\"].STYLE_OVERFLOW] == 'fill') {\n    result = state.shape.getLabelBounds(_mxRectangle[\"default\"].fromRectangle(state));\n  } else {\n    var spacing = parseInt(state.style[_mxConstants[\"default\"].STYLE_SPACING] || 0) * scale;\n    var spacingTop = (parseInt(state.style[_mxConstants[\"default\"].STYLE_SPACING_TOP] || 0) + _mxText[\"default\"].prototype.baseSpacingTop) * scale + spacing;\n    var spacingRight = (parseInt(state.style[_mxConstants[\"default\"].STYLE_SPACING_RIGHT] || 0) + _mxText[\"default\"].prototype.baseSpacingRight) * scale + spacing;\n    var spacingBottom = (parseInt(state.style[_mxConstants[\"default\"].STYLE_SPACING_BOTTOM] || 0) + _mxText[\"default\"].prototype.baseSpacingBottom) * scale + spacing;\n    var spacingLeft = (parseInt(state.style[_mxConstants[\"default\"].STYLE_SPACING_LEFT] || 0) + _mxText[\"default\"].prototype.baseSpacingLeft) * scale + spacing;\n    result = new _mxRectangle[\"default\"](state.x, state.y, Math.max(minWidth, state.width - spacingLeft - spacingRight), Math.max(minHeight, state.height - spacingTop - spacingBottom));\n    var hpos = _mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_LABEL_POSITION, _mxConstants[\"default\"].ALIGN_CENTER);\n    var vpos = _mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_VERTICAL_LABEL_POSITION, _mxConstants[\"default\"].ALIGN_MIDDLE);\n    result = state.shape != null && hpos == _mxConstants[\"default\"].ALIGN_CENTER && vpos == _mxConstants[\"default\"].ALIGN_MIDDLE ? state.shape.getLabelBounds(result) : result;\n    if (isEdge) {\n      result.x = state.absoluteOffset.x;\n      result.y = state.absoluteOffset.y;\n      if (state.text != null && state.text.boundingBox != null) {\n        // Workaround for label containing just spaces in which case\n        // the bounding box location contains negative numbers\n        if (state.text.boundingBox.x > 0) {\n          result.x = state.text.boundingBox.x;\n        }\n        if (state.text.boundingBox.y > 0) {\n          result.y = state.text.boundingBox.y;\n        }\n      }\n    } else if (state.text != null && state.text.boundingBox != null) {\n      result.x = Math.min(result.x, state.text.boundingBox.x);\n      result.y = Math.min(result.y, state.text.boundingBox.y);\n    }\n    result.x += spacingLeft;\n    result.y += spacingTop;\n    if (state.text != null && state.text.boundingBox != null) {\n      if (!isEdge) {\n        result.width = Math.max(result.width, state.text.boundingBox.width);\n        result.height = Math.max(result.height, state.text.boundingBox.height);\n      } else {\n        result.width = Math.max(minWidth, state.text.boundingBox.width);\n        result.height = Math.max(minHeight, state.text.boundingBox.height);\n      }\n    }\n\n    // Applies the horizontal and vertical label positions\n    if (this.graph.getModel().isVertex(state.cell)) {\n      var horizontal = _mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_LABEL_POSITION, _mxConstants[\"default\"].ALIGN_CENTER);\n      if (horizontal == _mxConstants[\"default\"].ALIGN_LEFT) {\n        result.x -= state.width;\n      } else if (horizontal == _mxConstants[\"default\"].ALIGN_RIGHT) {\n        result.x += state.width;\n      }\n      var vertical = _mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_VERTICAL_LABEL_POSITION, _mxConstants[\"default\"].ALIGN_MIDDLE);\n      if (vertical == _mxConstants[\"default\"].ALIGN_TOP) {\n        result.y -= state.height;\n      } else if (vertical == _mxConstants[\"default\"].ALIGN_BOTTOM) {\n        result.y += state.height;\n      }\n    }\n  }\n  return new _mxRectangle[\"default\"](Math.round(result.x), Math.round(result.y), Math.round(result.width), Math.round(result.height));\n};\n\n/**\r\n * Function: getEmptyLabelText\r\n *\r\n * Returns the initial label value to be used of the label of the given\r\n * cell is empty. This label is displayed and cleared on the first keystroke.\r\n * This implementation returns <emptyLabelText>.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> for which a text for an empty editing box should be\r\n * returned.\r\n */\nmxCellEditor.prototype.getEmptyLabelText = function (cell) {\n  return this.emptyLabelText;\n};\n\n/**\r\n * Function: getEditingCell\r\n *\r\n * Returns the cell that is currently being edited or null if no cell is\r\n * being edited.\r\n */\nmxCellEditor.prototype.getEditingCell = function () {\n  return this.editingCell;\n};\n\n/**\r\n * Function: destroy\r\n *\r\n * Destroys the editor and removes all associated resources.\r\n */\nmxCellEditor.prototype.destroy = function () {\n  if (this.textarea != null) {\n    _mxEvent[\"default\"].release(this.textarea);\n    if (this.textarea.parentNode != null) {\n      this.textarea.parentNode.removeChild(this.textarea);\n    }\n    this.textarea = null;\n    if (this.changeHandler != null) {\n      this.graph.getModel().removeListener(this.changeHandler);\n      this.changeHandler = null;\n    }\n    if (this.zoomHandler) {\n      this.graph.view.removeListener(this.zoomHandler);\n      this.zoomHandler = null;\n    }\n  }\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxCellRenderer\r\n *\r\n * Renders cells into a document object model. The <defaultShapes> is a global\r\n * map of shapename, constructor pairs that is used in all instances. You can\r\n * get a list of all available shape names using the following code.\r\n *\r\n * In general the cell renderer is in charge of creating, redrawing and\r\n * destroying the shape and label associated with a cell state, as well as\r\n * some other graphical objects, namely controls and overlays. The shape\r\n * hieararchy in the display (ie. the hierarchy in which the DOM nodes\r\n * appear in the document) does not reflect the cell hierarchy. The shapes\r\n * are a (flat) sequence of shapes and labels inside the draw pane of the\r\n * graph view, with some exceptions, namely the HTML labels being placed\r\n * directly inside the graph container for certain browsers.\r\n *\r\n * (code)\r\n * mxLog.show();\r\n * for (var i in mxCellRenderer.prototype.defaultShapes)\r\n * {\r\n *   mxLog.debug(i);\r\n * }\r\n * (end)\r\n *\r\n * Constructor: mxCellRenderer\r\n *\r\n * Constructs a new cell renderer with the following built-in shapes:\r\n * arrow, rectangle, ellipse, rhombus, image, line, label, cylinder,\r\n * swimlane, connector, actor and cloud.\r\n */\nvar _default = exports[\"default\"] = mxCellEditor;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxCellEditor.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxCellHighlight.js":
/*!**************************************************!*\
  !*** ./src/workflow/mxClient/mxCellHighlight.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.function.bind.js */ \"../../node_modules/core-js/modules/es.function.bind.js\");\n__webpack_require__(/*! core-js/modules/es.number.constructor.js */ \"../../node_modules/core-js/modules/es.number.constructor.js\");\nvar _mxClient = _interopRequireDefault(__webpack_require__(/*! ./mxClient.js */ \"./src/workflow/mxClient/mxClient.js\"));\nvar _mxEventUtils = _interopRequireDefault(__webpack_require__(/*! ./mxEventUtils.js */ \"./src/workflow/mxClient/mxEventUtils.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxRectangle = _interopRequireDefault(__webpack_require__(/*! ./mxRectangle.js */ \"./src/workflow/mxClient/mxRectangle.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ./mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nvar _mxMouseEvent = _interopRequireDefault(__webpack_require__(/*! ./mxMouseEvent.js */ \"./src/workflow/mxClient/mxMouseEvent.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxCellHighlight(graph, highlightColor, strokeWidth, dashed) {\n  if (graph != null) {\n    this.graph = graph;\n    this.highlightColor = highlightColor != null ? highlightColor : _mxConstants[\"default\"].DEFAULT_VALID_COLOR;\n    this.strokeWidth = strokeWidth != null ? strokeWidth : _mxConstants[\"default\"].HIGHLIGHT_STROKEWIDTH;\n    this.dashed = dashed != null ? dashed : false;\n    this.opacity = _mxConstants[\"default\"].HIGHLIGHT_OPACITY;\n\n    // Updates the marker if the graph changes\n    this.repaintHandler = _mxGraphUtils[\"default\"].bind(this, function () {\n      // Updates reference to state\n      if (this.state != null) {\n        var tmp = this.graph.view.getState(this.state.cell);\n        if (tmp == null) {\n          this.hide();\n        } else {\n          this.state = tmp;\n          this.repaint();\n        }\n      }\n    });\n    this.graph.getView().addListener(_mxEventUtils[\"default\"].SCALE, this.repaintHandler);\n    this.graph.getView().addListener(_mxEventUtils[\"default\"].TRANSLATE, this.repaintHandler);\n    this.graph.getView().addListener(_mxEventUtils[\"default\"].SCALE_AND_TRANSLATE, this.repaintHandler);\n    this.graph.getModel().addListener(_mxEventUtils[\"default\"].CHANGE, this.repaintHandler);\n\n    // Hides the marker if the current root changes\n    this.resetHandler = _mxGraphUtils[\"default\"].bind(this, function () {\n      this.hide();\n    });\n    this.graph.getView().addListener(_mxEventUtils[\"default\"].DOWN, this.resetHandler);\n    this.graph.getView().addListener(_mxEventUtils[\"default\"].UP, this.resetHandler);\n  }\n}\n;\n\n/**\r\n * Variable: keepOnTop\r\n *\r\n * Specifies if the highlights should appear on top of everything\r\n * else in the overlay pane. Default is false.\r\n */\nmxCellHighlight.prototype.keepOnTop = false;\n\n/**\r\n * Variable: graph\r\n *\r\n * Reference to the enclosing <mxGraph>.\r\n */\nmxCellHighlight.prototype.graph = true;\n\n/**\r\n * Variable: state\r\n *\r\n * Reference to the <mxCellState>.\r\n */\nmxCellHighlight.prototype.state = null;\n\n/**\r\n * Variable: spacing\r\n *\r\n * Specifies the spacing between the highlight for vertices and the vertex.\r\n * Default is 2.\r\n */\nmxCellHighlight.prototype.spacing = 2;\n\n/**\r\n * Variable: resetHandler\r\n *\r\n * Holds the handler that automatically invokes reset if the highlight\r\n * should be hidden.\r\n */\nmxCellHighlight.prototype.resetHandler = null;\n\n/**\r\n * Function: setHighlightColor\r\n *\r\n * Sets the color of the rectangle used to highlight drop targets.\r\n *\r\n * Parameters:\r\n *\r\n * color - String that represents the new highlight color.\r\n */\nmxCellHighlight.prototype.setHighlightColor = function (color) {\n  this.highlightColor = color;\n  if (this.shape != null) {\n    this.shape.stroke = color;\n  }\n};\n\n/**\r\n * Function: drawHighlight\r\n *\r\n * Creates and returns the highlight shape for the given state.\r\n */\nmxCellHighlight.prototype.drawHighlight = function () {\n  this.shape = this.createShape();\n  this.repaint();\n  if (!this.keepOnTop && this.shape.node.parentNode.firstChild != this.shape.node) {\n    this.shape.node.parentNode.insertBefore(this.shape.node, this.shape.node.parentNode.firstChild);\n  }\n};\n\n/**\r\n * Function: createShape\r\n *\r\n * Creates and returns the highlight shape for the given state.\r\n */\nmxCellHighlight.prototype.createShape = function () {\n  var shape = this.graph.cellRenderer.createShape(this.state);\n  shape.svgStrokeTolerance = this.graph.tolerance;\n  shape.scale = this.state.view.scale;\n  shape.outline = true;\n  shape.points = this.state.absolutePoints;\n  shape.apply(this.state);\n  shape.strokewidth = this.strokeWidth / this.state.view.scale / this.state.view.scale;\n  shape.arrowStrokewidth = this.strokeWidth;\n  shape.stroke = this.highlightColor;\n  shape.opacity = this.opacity;\n  shape.isDashed = this.dashed;\n  shape.isShadow = false;\n  shape.dialect = this.graph.dialect != _mxConstants[\"default\"].DIALECT_SVG ? _mxConstants[\"default\"].DIALECT_VML : _mxConstants[\"default\"].DIALECT_SVG;\n  shape.init(this.graph.getView().getOverlayPane());\n  _mxEventUtils[\"default\"].redirectMouseEvents(shape.node, this.graph, this.state, null, null, null, null, _mxMouseEvent[\"default\"]);\n  if (this.graph.dialect != _mxConstants[\"default\"].DIALECT_SVG) {\n    shape.pointerEvents = false;\n  } else {\n    shape.svgPointerEvents = 'stroke';\n  }\n  return shape;\n};\n\n/**\r\n * Function: repaint\r\n *\r\n * Updates the highlight after a change of the model or view.\r\n */\nmxCellHighlight.prototype.repaint = function () {\n  if (this.state != null && this.shape != null) {\n    if (this.graph.model.isEdge(this.state.cell)) {\n      this.shape.points = this.state.absolutePoints;\n    } else {\n      this.shape.bounds = new _mxRectangle[\"default\"](this.state.x - this.spacing, this.state.y - this.spacing, this.state.width + 2 * this.spacing, this.state.height + 2 * this.spacing);\n      this.shape.rotation = Number(this.state.style[_mxConstants[\"default\"].STYLE_ROTATION] || '0');\n    }\n\n    // Uses cursor from shape in highlight\n    if (this.state.shape != null) {\n      this.shape.setCursor(this.state.shape.getCursor());\n    }\n\n    // Workaround for event transparency in VML with transparent color\n    // is to use a non-transparent color with near zero opacity\n    if (_mxClient[\"default\"].IS_QUIRKS || document.documentMode == 8) {\n      if (this.shape.stroke == 'transparent') {\n        // KNOWN: Quirks mode does not seem to catch events if\n        // we do not force an update of the DOM via a change such\n        // as mxLog.debug. Since IE6 is EOL we do not add a fix.\n        this.shape.stroke = 'white';\n        this.shape.opacity = 1;\n      } else {\n        this.shape.opacity = this.opacity;\n      }\n    }\n\n    //this.shape.redraw();\n  }\n};\n\n/**\r\n * Function: hide\r\n *\r\n * Resets the state of the cell marker.\r\n */\nmxCellHighlight.prototype.hide = function () {\n  this.highlight(null);\n};\n\n/**\r\n * Function: mark\r\n *\r\n * Marks the <markedState> and fires a <mark> event.\r\n */\nmxCellHighlight.prototype.highlight = function (state) {\n  if (this.state != state) {\n    if (this.shape != null) {\n      this.shape.destroy();\n      this.shape = null;\n    }\n    this.state = state;\n    if (this.state != null) {\n      this.drawHighlight();\n    }\n  }\n};\n\n/**\r\n * Function: isHighlightAt\r\n *\r\n * Returns true if this highlight is at the given position.\r\n */\nmxCellHighlight.prototype.isHighlightAt = function (x, y) {\n  var hit = false;\n\n  // Quirks mode is currently not supported as it used a different coordinate system\n  if (this.shape != null && document.elementFromPoint != null && !_mxClient[\"default\"].IS_QUIRKS) {\n    var elt = document.elementFromPoint(x, y);\n    while (elt != null) {\n      if (elt == this.shape.node) {\n        hit = true;\n        break;\n      }\n      elt = elt.parentNode;\n    }\n  }\n  return hit;\n};\n\n/**\r\n * Function: destroy\r\n *\r\n * Destroys the handler and all its resources and DOM nodes.\r\n */\nmxCellHighlight.prototype.destroy = function () {\n  this.graph.getView().removeListener(this.resetHandler);\n  this.graph.getView().removeListener(this.repaintHandler);\n  this.graph.getModel().removeListener(this.repaintHandler);\n  if (this.shape != null) {\n    this.shape.destroy();\n    this.shape = null;\n  }\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxDefaultKeyHandler\r\n *\r\n * Binds keycodes to actionnames in an editor. This aggregates an internal\r\n * <handler> and extends the implementation of <mxKeyHandler.escape> to not\r\n * only cancel the editing, but also hide the properties dialog and fire an\r\n * <mxEditor.escape> event via <editor>. An instance of this class is created\r\n * by <mxEditor> and stored in <mxEditor.keyHandler>.\r\n *\r\n * Example:\r\n *\r\n * Bind the delete key to the delete action in an existing editor.\r\n *\r\n * (code)\r\n * var keyHandler = new mxDefaultKeyHandler(editor);\r\n * keyHandler.bindAction(46, 'delete');\r\n * (end)\r\n *\r\n * Codec:\r\n *\r\n * This class uses the <mxDefaultKeyHandlerCodec> to read configuration\r\n * data into an existing instance. See <mxDefaultKeyHandlerCodec> for a\r\n * description of the configuration format.\r\n *\r\n * Keycodes:\r\n *\r\n * See <mxKeyHandler>.\r\n *\r\n * An <mxEventUtils.ESCAPE> event is fired via the editor if the escape key is\r\n * pressed.\r\n *\r\n * Constructor: mxDefaultKeyHandler\r\n *\r\n * Constructs a new default key handler for the <mxEditor.graph> in the\r\n * given <mxEditor>. (The editor may be null if a prototypical instance for\r\n * a <mxDefaultKeyHandlerCodec> is created.)\r\n *\r\n * Parameters:\r\n *\r\n * editor - Reference to the enclosing <mxEditor>.\r\n */\nvar _default = exports[\"default\"] = mxCellHighlight;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxCellHighlight.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxCellMarker.js":
/*!***********************************************!*\
  !*** ./src/workflow/mxClient/mxCellMarker.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _mxEventObject = _interopRequireDefault(__webpack_require__(/*! ./mxEventObject.js */ \"./src/workflow/mxClient/mxEventObject.js\"));\nvar _mxEvent = _interopRequireDefault(__webpack_require__(/*! ./mxEvent.js */ \"./src/workflow/mxClient/mxEvent.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxEventSource = _interopRequireDefault(__webpack_require__(/*! ./mxEventSource.js */ \"./src/workflow/mxClient/mxEventSource.js\"));\nvar _mxCellHighlight = _interopRequireDefault(__webpack_require__(/*! ./mxCellHighlight.js */ \"./src/workflow/mxClient/mxCellHighlight.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ./mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nvar _mxUtils = _interopRequireDefault(__webpack_require__(/*! ./mxUtils.js */ \"./src/workflow/mxClient/mxUtils.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxCellMarker(graph, validColor, invalidColor, hotspot) {\n  _mxEventSource[\"default\"].call(this);\n  if (graph != null) {\n    this.graph = graph;\n    this.validColor = validColor != null ? validColor : _mxConstants[\"default\"].DEFAULT_VALID_COLOR;\n    this.invalidColor = validColor != null ? invalidColor : _mxConstants[\"default\"].DEFAULT_INVALID_COLOR;\n    this.hotspot = hotspot != null ? hotspot : _mxConstants[\"default\"].DEFAULT_HOTSPOT;\n    this.highlight = new _mxCellHighlight[\"default\"](graph);\n  }\n}\n;\n\n/**\r\n * Extends mxEventSource.\r\n */\n_mxGraphUtils[\"default\"].extend(mxCellMarker, _mxEventSource[\"default\"]);\n\n/**\r\n * Variable: graph\r\n *\r\n * Reference to the enclosing <mxGraph>.\r\n */\nmxCellMarker.prototype.graph = null;\n\n/**\r\n * Variable: enabled\r\n *\r\n * Specifies if the marker is enabled. Default is true.\r\n */\nmxCellMarker.prototype.enabled = true;\n\n/**\r\n * Variable: hotspot\r\n *\r\n * Specifies the portion of the width and height that should trigger\r\n * a highlight. The area around the center of the cell to be marked is used\r\n * as the hotspot. Possible values are between 0 and 1. Default is\r\n * mxConstants.DEFAULT_HOTSPOT.\r\n */\nmxCellMarker.prototype.hotspot = _mxConstants[\"default\"].DEFAULT_HOTSPOT;\n\n/**\r\n * Variable: hotspotEnabled\r\n *\r\n * Specifies if the hotspot is enabled. Default is false.\r\n */\nmxCellMarker.prototype.hotspotEnabled = false;\n\n/**\r\n * Variable: validColor\r\n *\r\n * Holds the valid marker color.\r\n */\nmxCellMarker.prototype.validColor = null;\n\n/**\r\n * Variable: invalidColor\r\n *\r\n * Holds the invalid marker color.\r\n */\nmxCellMarker.prototype.invalidColor = null;\n\n/**\r\n * Variable: currentColor\r\n *\r\n * Holds the current marker color.\r\n */\nmxCellMarker.prototype.currentColor = null;\n\n/**\r\n * Variable: validState\r\n *\r\n * Holds the marked <mxCellState> if it is valid.\r\n */\nmxCellMarker.prototype.validState = null;\n\n/**\r\n * Variable: markedState\r\n *\r\n * Holds the marked <mxCellState>.\r\n */\nmxCellMarker.prototype.markedState = null;\n\n/**\r\n * Function: setEnabled\r\n *\r\n * Enables or disables event handling. This implementation\r\n * updates <enabled>.\r\n *\r\n * Parameters:\r\n *\r\n * enabled - Boolean that specifies the new enabled state.\r\n */\nmxCellMarker.prototype.setEnabled = function (enabled) {\n  this.enabled = enabled;\n};\n\n/**\r\n * Function: isEnabled\r\n *\r\n * Returns true if events are handled. This implementation\r\n * returns <enabled>.\r\n */\nmxCellMarker.prototype.isEnabled = function () {\n  return this.enabled;\n};\n\n/**\r\n * Function: setHotspot\r\n *\r\n * Sets the <hotspot>.\r\n */\nmxCellMarker.prototype.setHotspot = function (hotspot) {\n  this.hotspot = hotspot;\n};\n\n/**\r\n * Function: getHotspot\r\n *\r\n * Returns the <hotspot>.\r\n */\nmxCellMarker.prototype.getHotspot = function () {\n  return this.hotspot;\n};\n\n/**\r\n * Function: setHotspotEnabled\r\n *\r\n * Specifies whether the hotspot should be used in <intersects>.\r\n */\nmxCellMarker.prototype.setHotspotEnabled = function (enabled) {\n  this.hotspotEnabled = enabled;\n};\n\n/**\r\n * Function: isHotspotEnabled\r\n *\r\n * Returns true if hotspot is used in <intersects>.\r\n */\nmxCellMarker.prototype.isHotspotEnabled = function () {\n  return this.hotspotEnabled;\n};\n\n/**\r\n * Function: hasValidState\r\n *\r\n * Returns true if <validState> is not null.\r\n */\nmxCellMarker.prototype.hasValidState = function () {\n  return this.validState != null;\n};\n\n/**\r\n * Function: getValidState\r\n *\r\n * Returns the <validState>.\r\n */\nmxCellMarker.prototype.getValidState = function () {\n  return this.validState;\n};\n\n/**\r\n * Function: getMarkedState\r\n *\r\n * Returns the <markedState>.\r\n */\nmxCellMarker.prototype.getMarkedState = function () {\n  return this.markedState;\n};\n\n/**\r\n * Function: reset\r\n *\r\n * Resets the state of the cell marker.\r\n */\nmxCellMarker.prototype.reset = function () {\n  this.validState = null;\n  if (this.markedState != null) {\n    this.markedState = null;\n    this.unmark();\n  }\n};\n\n/**\r\n * Function: process\r\n *\r\n * Processes the given event and cell and marks the state returned by\r\n * <getState> with the color returned by <getMarkerColor>. If the\r\n * markerColor is not null, then the state is stored in <markedState>. If\r\n * <isValidState> returns true, then the state is stored in <validState>\r\n * regardless of the marker color. The state is returned regardless of the\r\n * marker color and valid state.\r\n */\nmxCellMarker.prototype.process = function (me) {\n  var state = null;\n  if (this.isEnabled()) {\n    state = this.getState(me);\n    this.setCurrentState(state, me);\n  }\n  return state;\n};\n\n/**\r\n * Function: setCurrentState\r\n *\r\n * Sets and marks the current valid state.\r\n */\nmxCellMarker.prototype.setCurrentState = function (state, me, color) {\n  var isValid = state != null ? this.isValidState(state) : false;\n  color = color != null ? color : this.getMarkerColor(me.getEvent(), state, isValid);\n  if (isValid) {\n    this.validState = state;\n  } else {\n    this.validState = null;\n  }\n  if (state != this.markedState || color != this.currentColor) {\n    this.currentColor = color;\n    if (state != null && this.currentColor != null) {\n      this.markedState = state;\n      this.mark();\n    } else if (this.markedState != null) {\n      this.markedState = null;\n      this.unmark();\n    }\n  }\n};\n\n/**\r\n * Function: markCell\r\n *\r\n * Marks the given cell using the given color, or <validColor> if no color is specified.\r\n */\nmxCellMarker.prototype.markCell = function (cell, color) {\n  var state = this.graph.getView().getState(cell);\n  if (state != null) {\n    this.currentColor = color != null ? color : this.validColor;\n    this.markedState = state;\n    this.mark();\n  }\n};\n\n/**\r\n * Function: mark\r\n *\r\n * Marks the <markedState> and fires a <mark> event.\r\n */\nmxCellMarker.prototype.mark = function () {\n  this.highlight.setHighlightColor(this.currentColor);\n  this.highlight.highlight(this.markedState);\n  this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].MARK, 'state', this.markedState));\n};\n\n/**\r\n * Function: unmark\r\n *\r\n * Hides the marker and fires a <mark> event.\r\n */\nmxCellMarker.prototype.unmark = function () {\n  this.mark();\n};\n\n/**\r\n * Function: isValidState\r\n *\r\n * Returns true if the given <mxCellState> is a valid state. If this\r\n * returns true, then the state is stored in <validState>. The return value\r\n * of this method is used as the argument for <getMarkerColor>.\r\n */\nmxCellMarker.prototype.isValidState = function (state) {\n  return true;\n};\n\n/**\r\n * Function: getMarkerColor\r\n *\r\n * Returns the valid- or invalidColor depending on the value of isValid.\r\n * The given <mxCellState> is ignored by this implementation.\r\n */\nmxCellMarker.prototype.getMarkerColor = function (evt, state, isValid) {\n  return isValid ? this.validColor : this.invalidColor;\n};\n\n/**\r\n * Function: getState\r\n *\r\n * Uses <getCell>, <getStateToMark> and <intersects> to return the\r\n * <mxCellState> for the given <mxMouseEvent>.\r\n */\nmxCellMarker.prototype.getState = function (me) {\n  var view = this.graph.getView();\n  var cell = this.getCell(me);\n  var state = this.getStateToMark(view.getState(cell));\n  return state != null && this.intersects(state, me) ? state : null;\n};\n\n/**\r\n * Function: getCell\r\n *\r\n * Returns the <mxCell> for the given event and cell. This returns the\r\n * given cell.\r\n */\nmxCellMarker.prototype.getCell = function (me) {\n  return me.getCell();\n};\n\n/**\r\n * Function: getStateToMark\r\n *\r\n * Returns the <mxCellState> to be marked for the given <mxCellState> under\r\n * the mouse. This returns the given state.\r\n */\nmxCellMarker.prototype.getStateToMark = function (state) {\n  return state;\n};\n\n/**\r\n * Function: intersects\r\n *\r\n * Returns true if the given coordinate pair intersects the given state.\r\n * This returns true if the <hotspot> is 0 or the coordinates are inside\r\n * the hotspot for the given cell state.\r\n */\nmxCellMarker.prototype.intersects = function (state, me) {\n  if (this.hotspotEnabled) {\n    return _mxUtils[\"default\"].intersectsHotspot(state, me.getGraphX(), me.getGraphY(), this.hotspot, _mxConstants[\"default\"].MIN_HOTSPOT_SIZE, _mxConstants[\"default\"].MAX_HOTSPOT_SIZE);\n  }\n  return true;\n};\n\n/**\r\n * Function: destroy\r\n *\r\n * Destroys the handler and all its resources and DOM nodes.\r\n */\nmxCellMarker.prototype.destroy = function () {\n  this.graph.getView().removeListener(this.resetHandler);\n  this.graph.getModel().removeListener(this.resetHandler);\n  this.highlight.destroy();\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxSelectionCellsHandler\r\n *\r\n * An event handler that manages cell handlers and invokes their mouse event\r\n * processing functions.\r\n *\r\n * Group: Events\r\n *\r\n * Event: mxEvent.ADD\r\n *\r\n * Fires if a cell has been added to the selection. The <code>state</code>\r\n * property contains the <mxCellState> that has been added.\r\n *\r\n * Event: mxEvent.REMOVE\r\n *\r\n * Fires if a cell has been remove from the selection. The <code>state</code>\r\n * property contains the <mxCellState> that has been removed.\r\n *\r\n * Parameters:\r\n *\r\n * graph - Reference to the enclosing <mxGraph>.\r\n */\nvar _default = exports[\"default\"] = mxCellMarker;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxCellMarker.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxCellOverlay.js":
/*!************************************************!*\
  !*** ./src/workflow/mxClient/mxCellOverlay.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.date.to-string.js */ \"../../node_modules/core-js/modules/es.date.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.object.to-string.js */ \"../../node_modules/core-js/modules/es.object.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.regexp.to-string.js */ \"../../node_modules/core-js/modules/es.regexp.to-string.js\");\nvar _mxPoint = _interopRequireDefault(__webpack_require__(/*! ./mxPoint.js */ \"./src/workflow/mxClient/mxPoint.js\"));\nvar _mxEventSource = _interopRequireDefault(__webpack_require__(/*! ./mxEventSource.js */ \"./src/workflow/mxClient/mxEventSource.js\"));\nvar _mxRectangle = _interopRequireDefault(__webpack_require__(/*! ./mxRectangle.js */ \"./src/workflow/mxClient/mxRectangle.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ./mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxCellOverlay(image, tooltip, align, verticalAlign, offset, cursor) {\n  this.image = image;\n  this.tooltip = tooltip;\n  this.align = align != null ? align : this.align;\n  this.verticalAlign = verticalAlign != null ? verticalAlign : this.verticalAlign;\n  this.offset = offset != null ? offset : new _mxPoint[\"default\"]();\n  this.cursor = cursor != null ? cursor : 'help';\n}\n;\n\n/**\r\n * Extends mxEventSource.\r\n */\nmxCellOverlay.prototype = new _mxEventSource[\"default\"]();\nmxCellOverlay.prototype.constructor = mxCellOverlay;\n\n/**\r\n * Variable: image\r\n *\r\n * Holds the <mxImage> to be used as the icon.\r\n */\nmxCellOverlay.prototype.image = null;\n\n/**\r\n * Variable: tooltip\r\n *\r\n * Holds the optional string to be used as the tooltip.\r\n */\nmxCellOverlay.prototype.tooltip = null;\n\n/**\r\n * Variable: align\r\n *\r\n * Holds the horizontal alignment for the overlay. Default is\r\n * <mxConstants.ALIGN_RIGHT>. For edges, the overlay always appears in the\r\n * center of the edge.\r\n */\nmxCellOverlay.prototype.align = _mxConstants[\"default\"].ALIGN_RIGHT;\n\n/**\r\n * Variable: verticalAlign\r\n *\r\n * Holds the vertical alignment for the overlay. Default is\r\n * <mxConstants.ALIGN_BOTTOM>. For edges, the overlay always appears in the\r\n * center of the edge.\r\n */\nmxCellOverlay.prototype.verticalAlign = _mxConstants[\"default\"].ALIGN_BOTTOM;\n\n/**\r\n * Variable: offset\r\n *\r\n * Holds the offset as an <mxPoint>. The offset will be scaled according to the\r\n * current scale.\r\n */\nmxCellOverlay.prototype.offset = null;\n\n/**\r\n * Variable: cursor\r\n *\r\n * Holds the cursor for the overlay. Default is 'help'.\r\n */\nmxCellOverlay.prototype.cursor = null;\n\n/**\r\n * Variable: defaultOverlap\r\n *\r\n * Defines the overlapping for the overlay, that is, the proportional distance\r\n * from the origin to the point defined by the alignment. Default is 0.5.\r\n */\nmxCellOverlay.prototype.defaultOverlap = 0.5;\n\n/**\r\n * Function: getBounds\r\n *\r\n * Returns the bounds of the overlay for the given <mxCellState> as an\r\n * <mxRectangle>. This should be overridden when using multiple overlays\r\n * per cell so that the overlays do not overlap.\r\n *\r\n * The following example will place the overlay along an edge (where\r\n * x=[-1..1] from the start to the end of the edge and y is the\r\n * orthogonal offset in px).\r\n *\r\n * (code)\r\n * overlay.getBounds = function(state)\r\n * {\r\n *   var bounds = mxCellOverlay.prototype.getBounds.apply(this, arguments);\r\n *\r\n *   if (state.view.graph.getModel().isEdge(state.cell))\r\n *   {\r\n *     var pt = state.view.getPoint(state, {x: 0, y: 0, relative: true});\r\n *\r\n *     bounds.x = pt.x - bounds.width / 2;\r\n *     bounds.y = pt.y - bounds.height / 2;\r\n *   }\r\n *\r\n *   return bounds;\r\n * };\r\n * (end)\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> that represents the current state of the\r\n * associated cell.\r\n */\nmxCellOverlay.prototype.getBounds = function (state) {\n  var isEdge = state.view.graph.getModel().isEdge(state.cell);\n  var s = state.view.scale;\n  var pt = null;\n  var w = this.image.width;\n  var h = this.image.height;\n  if (isEdge) {\n    var pts = state.absolutePoints;\n    if (pts.length % 2 == 1) {\n      pt = pts[Math.floor(pts.length / 2)];\n    } else {\n      var idx = pts.length / 2;\n      var p0 = pts[idx - 1];\n      var p1 = pts[idx];\n      pt = new _mxPoint[\"default\"](p0.x + (p1.x - p0.x) / 2, p0.y + (p1.y - p0.y) / 2);\n    }\n  } else {\n    pt = new _mxPoint[\"default\"]();\n    if (this.align == _mxConstants[\"default\"].ALIGN_LEFT) {\n      pt.x = state.x;\n    } else if (this.align == _mxConstants[\"default\"].ALIGN_CENTER) {\n      pt.x = state.x + state.width / 2;\n    } else {\n      pt.x = state.x + state.width;\n    }\n    if (this.verticalAlign == _mxConstants[\"default\"].ALIGN_TOP) {\n      pt.y = state.y;\n    } else if (this.verticalAlign == _mxConstants[\"default\"].ALIGN_MIDDLE) {\n      pt.y = state.y + state.height / 2;\n    } else {\n      pt.y = state.y + state.height;\n    }\n  }\n  return new _mxRectangle[\"default\"](Math.round(pt.x - (w * this.defaultOverlap - this.offset.x) * s), Math.round(pt.y - (h * this.defaultOverlap - this.offset.y) * s), w * s, h * s);\n};\n\n/**\r\n * Function: toString\r\n *\r\n * Returns the textual representation of the overlay to be used as the\r\n * tooltip. This implementation returns <tooltip>.\r\n */\nmxCellOverlay.prototype.toString = function () {\n  return this.tooltip;\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxOutline\r\n *\r\n * Implements an outline (aka overview) for a graph. Set <updateOnPan> to true\r\n * to enable updates while the source graph is panning.\r\n *\r\n * Example:\r\n *\r\n * (code)\r\n * var outline = new mxOutline(graph, div);\r\n * (end)\r\n *\r\n * If an outline is used in an <mxWindow> in IE8 standards mode, the following\r\n * code makes sure that the shadow filter is not inherited and that any\r\n * transparent elements in the graph do not show the page background, but the\r\n * background of the graph container.\r\n *\r\n * (code)\r\n * if (document.documentMode == 8)\r\n * {\r\n *   container.style.filter = 'progid:DXImageTransform.Microsoft.alpha(opacity=100)';\r\n * }\r\n * (end)\r\n *\r\n * To move the graph to the top, left corner the following code can be used.\r\n *\r\n * (code)\r\n * var scale = graph.view.scale;\r\n * var bounds = graph.getGraphBounds();\r\n * graph.view.setTranslate(-bounds.x / scale, -bounds.y / scale);\r\n * (end)\r\n *\r\n * To toggle the suspended mode, the following can be used.\r\n *\r\n * (code)\r\n * outline.suspended = !outln.suspended;\r\n * if (!outline.suspended)\r\n * {\r\n *   outline.update(true);\r\n * }\r\n * (end)\r\n *\r\n * Constructor: mxOutline\r\n *\r\n * Constructs a new outline for the specified graph inside the given\r\n * container.\r\n *\r\n * Parameters:\r\n *\r\n * source - <mxGraph> to create the outline for.\r\n * container - DOM node that will contain the outline.\r\n */\nvar _default = exports[\"default\"] = mxCellOverlay;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxCellOverlay.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxCellPath.js":
/*!*********************************************!*\
  !*** ./src/workflow/mxClient/mxCellPath.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.last-index-of.js */ \"../../node_modules/core-js/modules/es.array.last-index-of.js\");\n__webpack_require__(/*! core-js/modules/es.parse-int.js */ \"../../node_modules/core-js/modules/es.parse-int.js\");\n__webpack_require__(/*! core-js/modules/es.regexp.exec.js */ \"../../node_modules/core-js/modules/es.regexp.exec.js\");\n__webpack_require__(/*! core-js/modules/es.string.split.js */ \"../../node_modules/core-js/modules/es.string.split.js\");\nvar mxCellPath = {\n  /**\r\n   * Class: mxCellPath\r\n   *\r\n   * Implements a mechanism for temporary cell Ids.\r\n   *\r\n   * Variable: PATH_SEPARATOR\r\n   *\r\n   * Defines the separator between the path components. Default is \".\".\r\n   */\n  PATH_SEPARATOR: '.',\n  /**\r\n   * Function: create\r\n   *\r\n   * Creates the cell path for the given cell. The cell path is a\r\n   * concatenation of the indices of all ancestors on the (finite) path to\r\n   * the root, eg. \"0.0.0.1\".\r\n   *\r\n   * Parameters:\r\n   *\r\n   * cell - Cell whose path should be returned.\r\n   */\n  create: function create(cell) {\n    var result = '';\n    if (cell != null) {\n      var parent = cell.getParent();\n      while (parent != null) {\n        var index = parent.getIndex(cell);\n        result = index + mxCellPath.PATH_SEPARATOR + result;\n        cell = parent;\n        parent = cell.getParent();\n      }\n    }\n\n    // Removes trailing separator\n    var n = result.length;\n    if (n > 1) {\n      result = result.substring(0, n - 1);\n    }\n    return result;\n  },\n  /**\r\n   * Function: getParentPath\r\n   *\r\n   * Returns the path for the parent of the cell represented by the given\r\n   * path. Returns null if the given path has no parent.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * path - Path whose parent path should be returned.\r\n   */\n  getParentPath: function getParentPath(path) {\n    if (path != null) {\n      var index = path.lastIndexOf(mxCellPath.PATH_SEPARATOR);\n      if (index >= 0) {\n        return path.substring(0, index);\n      } else if (path.length > 0) {\n        return '';\n      }\n    }\n    return null;\n  },\n  /**\r\n   * Function: resolve\r\n   *\r\n   * Returns the cell for the specified cell path using the given root as the\r\n   * root of the path.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * root - Root cell of the path to be resolved.\r\n   * path - String that defines the path.\r\n   */\n  resolve: function resolve(root, path) {\n    var parent = root;\n    if (path != null) {\n      var tokens = path.split(mxCellPath.PATH_SEPARATOR);\n      for (var i = 0; i < tokens.length; i++) {\n        parent = parent.getChildAt(parseInt(tokens[i]));\n      }\n    }\n    return parent;\n  },\n  /**\r\n   * Function: compare\r\n   *\r\n   * Compares the given cell paths and returns -1 if p1 is smaller, 0 if\r\n   * p1 is equal and 1 if p1 is greater than p2.\r\n   */\n  compare: function compare(p1, p2) {\n    var min = Math.min(p1.length, p2.length);\n    var comp = 0;\n    for (var i = 0; i < min; i++) {\n      if (p1[i] != p2[i]) {\n        if (p1[i].length == 0 || p2[i].length == 0) {\n          comp = p1[i] == p2[i] ? 0 : p1[i] > p2[i] ? 1 : -1;\n        } else {\n          var t1 = parseInt(p1[i]);\n          var t2 = parseInt(p2[i]);\n          comp = t1 == t2 ? 0 : t1 > t2 ? 1 : -1;\n        }\n        break;\n      }\n    }\n\n    // Compares path length if both paths are equal to this point\n    if (comp == 0) {\n      var t1 = p1.length;\n      var t2 = p2.length;\n      if (t1 != t2) {\n        comp = t1 > t2 ? 1 : -1;\n      }\n    }\n    return comp;\n  }\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\nvar _default = exports[\"default\"] = mxCellPath;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxCellPath.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxCellRenderer.js":
/*!*************************************************!*\
  !*** ./src/workflow/mxClient/mxCellRenderer.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.index-of.js */ \"../../node_modules/core-js/modules/es.array.index-of.js\");\n__webpack_require__(/*! core-js/modules/es.array.slice.js */ \"../../node_modules/core-js/modules/es.array.slice.js\");\n__webpack_require__(/*! core-js/modules/es.function.bind.js */ \"../../node_modules/core-js/modules/es.function.bind.js\");\n__webpack_require__(/*! core-js/modules/es.parse-float.js */ \"../../node_modules/core-js/modules/es.parse-float.js\");\nvar _mxEventObject = _interopRequireDefault(__webpack_require__(/*! ./mxEventObject.js */ \"./src/workflow/mxClient/mxEventObject.js\"));\nvar _mxEvent = _interopRequireDefault(__webpack_require__(/*! ./mxEvent.js */ \"./src/workflow/mxClient/mxEvent.js\"));\nvar _mxMouseEvent = _interopRequireDefault(__webpack_require__(/*! ./mxMouseEvent.js */ \"./src/workflow/mxClient/mxMouseEvent.js\"));\nvar _mxDictionary = _interopRequireDefault(__webpack_require__(/*! ./mxDictionary.js */ \"./src/workflow/mxClient/mxDictionary.js\"));\nvar _mxRectangle = _interopRequireDefault(__webpack_require__(/*! ./mxRectangle.js */ \"./src/workflow/mxClient/mxRectangle.js\"));\nvar _mxClient = _interopRequireDefault(__webpack_require__(/*! ./mxClient.js */ \"./src/workflow/mxClient/mxClient.js\"));\nvar _mxImageShape = _interopRequireDefault(__webpack_require__(/*! ./mxImageShape.js */ \"./src/workflow/mxClient/mxImageShape.js\"));\nvar _mxPoint = _interopRequireDefault(__webpack_require__(/*! ./mxPoint.js */ \"./src/workflow/mxClient/mxPoint.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxShape = _interopRequireDefault(__webpack_require__(/*! ./mxShape.js */ \"./src/workflow/mxClient/mxShape.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ./mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nvar _mxUtils = _interopRequireDefault(__webpack_require__(/*! ./mxUtils.js */ \"./src/workflow/mxClient/mxUtils.js\"));\nvar _mxArrowConnector = _interopRequireDefault(__webpack_require__(/*! ./mxArrowConnector.js */ \"./src/workflow/mxClient/mxArrowConnector.js\"));\nvar _mxCylinder = _interopRequireDefault(__webpack_require__(/*! ./mxCylinder.js */ \"./src/workflow/mxClient/mxCylinder.js\"));\nvar _mxArrow = _interopRequireDefault(__webpack_require__(/*! ./mxArrow.js */ \"./src/workflow/mxClient/mxArrow.js\"));\nvar _mxTriangle = _interopRequireDefault(__webpack_require__(/*! ./mxTriangle.js */ \"./src/workflow/mxClient/mxTriangle.js\"));\nvar _mxHexagon = _interopRequireDefault(__webpack_require__(/*! ./mxHexagon.js */ \"./src/workflow/mxClient/mxHexagon.js\"));\nvar _mxEllipse = _interopRequireDefault(__webpack_require__(/*! ./mxEllipse.js */ \"./src/workflow/mxClient/mxEllipse.js\"));\nvar _mxConnector = _interopRequireDefault(__webpack_require__(/*! ./mxConnector.js */ \"./src/workflow/mxClient/mxConnector.js\"));\nvar _mxRectangleShape = _interopRequireDefault(__webpack_require__(/*! ./mxRectangleShape.js */ \"./src/workflow/mxClient/mxRectangleShape.js\"));\nvar _mxCloud = _interopRequireDefault(__webpack_require__(/*! ./mxCloud.js */ \"./src/workflow/mxClient/mxCloud.js\"));\nvar _mxDoubleEllipse = _interopRequireDefault(__webpack_require__(/*! ./mxDoubleEllipse.js */ \"./src/workflow/mxClient/mxDoubleEllipse.js\"));\nvar _mxLabel = _interopRequireDefault(__webpack_require__(/*! ./mxLabel.js */ \"./src/workflow/mxClient/mxLabel.js\"));\nvar _mxLine = _interopRequireDefault(__webpack_require__(/*! ./mxLine.js */ \"./src/workflow/mxClient/mxLine.js\"));\nvar _mxActor = _interopRequireDefault(__webpack_require__(/*! ./mxActor.js */ \"./src/workflow/mxClient/mxActor.js\"));\nvar _mxSwimlane = _interopRequireDefault(__webpack_require__(/*! ./mxSwimlane.js */ \"./src/workflow/mxClient/mxSwimlane.js\"));\nvar _mxRhombus = _interopRequireDefault(__webpack_require__(/*! ./mxRhombus.js */ \"./src/workflow/mxClient/mxRhombus.js\"));\nvar _mxText = _interopRequireDefault(__webpack_require__(/*! ./mxText.js */ \"./src/workflow/mxClient/mxText.js\"));\nvar _mxStencilRegistry = _interopRequireDefault(__webpack_require__(/*! ./mxStencilRegistry.js */ \"./src/workflow/mxClient/mxStencilRegistry.js\"));\nvar _BillCard = _interopRequireDefault(__webpack_require__(/*! ../mxGraph/BillCard.js */ \"./src/workflow/mxGraph/BillCard.js\"));\nvar _StackedCard = _interopRequireDefault(__webpack_require__(/*! ../mxGraph/StackedCard.js */ \"./src/workflow/mxGraph/StackedCard.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxCellRenderer() {}\n;\n\n/**\r\n * Variable: defaultEdgeShape\r\n *\r\n * Defines the default shape for edges. Default is <mxConnector>.\r\n */\nmxCellRenderer.prototype.defaultEdgeShape = _mxConnector[\"default\"];\n\n/**\r\n * Variable: defaultVertexShape\r\n *\r\n * Defines the default shape for vertices. Default is <mxRectangleShape>.\r\n */\nmxCellRenderer.prototype.defaultVertexShape = _mxRectangleShape[\"default\"];\n\n/**\r\n * Variable: defaultTextShape\r\n *\r\n * Defines the default shape for labels. Default is <mxText>.\r\n */\nmxCellRenderer.prototype.defaultTextShape = _mxText[\"default\"];\n\n/**\r\n * Variable: legacyControlPosition\r\n *\r\n * Specifies if the folding icon should ignore the horizontal\r\n * orientation of a swimlane. Default is true.\r\n */\nmxCellRenderer.prototype.legacyControlPosition = true;\n\n/**\r\n * Variable: legacySpacing\r\n *\r\n * Specifies if spacing and label position should be ignored if overflow is\r\n * fill or width. Default is true for backwards compatiblity.\r\n */\nmxCellRenderer.prototype.legacySpacing = true;\n\n/**\r\n * Variable: defaultShapes\r\n *\r\n * Static array that contains the globally registered shapes which are\r\n * known to all instances of this class. For adding new shapes you should\r\n * use the static <mxCellRenderer.registerShape> function.\r\n */\nmxCellRenderer.prototype.defaultShapes = new Object();\n\n/**\r\n * Variable: antiAlias\r\n *\r\n * Anti-aliasing option for new shapes. Default is true.\r\n */\nmxCellRenderer.prototype.antiAlias = true;\n\n/**\r\n * Variable: forceControlClickHandler\r\n *\r\n * Specifies if the enabled state of the graph should be ignored in the control\r\n * click handler (to allow folding in disabled graphs). Default is false.\r\n */\nmxCellRenderer.prototype.forceControlClickHandler = false;\n\n/**\r\n * Function: registerShape\r\n *\r\n * Registers the given constructor under the specified key in this instance\r\n * of the renderer.\r\n *\r\n * Example:\r\n *\r\n * (code)\r\n * mxCellRenderer.registerShape(mxConstants.SHAPE_RECTANGLE, mxRectangleShape);\r\n * (end)\r\n *\r\n * Parameters:\r\n *\r\n * key - String representing the shape name.\r\n * shape - Constructor of the <mxShape> subclass.\r\n */\nmxCellRenderer.registerShape = function (key, shape) {\n  mxCellRenderer.prototype.defaultShapes[key] = shape;\n};\n\n// Adds default shapes into the default shapes array\nmxCellRenderer.registerShape(_mxConstants[\"default\"].SHAPE_RECTANGLE, _mxRectangleShape[\"default\"]);\nmxCellRenderer.registerShape(_mxConstants[\"default\"].SHAPE_ELLIPSE, _mxEllipse[\"default\"]);\nmxCellRenderer.registerShape(_mxConstants[\"default\"].SHAPE_RHOMBUS, _mxRhombus[\"default\"]);\nmxCellRenderer.registerShape(_mxConstants[\"default\"].SHAPE_CYLINDER, _mxCylinder[\"default\"]);\nmxCellRenderer.registerShape(_mxConstants[\"default\"].SHAPE_CONNECTOR, _mxConnector[\"default\"]);\nmxCellRenderer.registerShape(_mxConstants[\"default\"].SHAPE_ACTOR, _mxActor[\"default\"]);\nmxCellRenderer.registerShape(_mxConstants[\"default\"].SHAPE_TRIANGLE, _mxTriangle[\"default\"]);\nmxCellRenderer.registerShape(_mxConstants[\"default\"].SHAPE_HEXAGON, _mxHexagon[\"default\"]);\nmxCellRenderer.registerShape(_mxConstants[\"default\"].SHAPE_CLOUD, _mxCloud[\"default\"]);\nmxCellRenderer.registerShape(_mxConstants[\"default\"].SHAPE_LINE, _mxLine[\"default\"]);\nmxCellRenderer.registerShape(_mxConstants[\"default\"].SHAPE_ARROW, _mxArrow[\"default\"]);\nmxCellRenderer.registerShape(_mxConstants[\"default\"].SHAPE_ARROW_CONNECTOR, _mxArrowConnector[\"default\"]);\nmxCellRenderer.registerShape(_mxConstants[\"default\"].SHAPE_DOUBLE_ELLIPSE, _mxDoubleEllipse[\"default\"]);\nmxCellRenderer.registerShape(_mxConstants[\"default\"].SHAPE_SWIMLANE, _mxSwimlane[\"default\"]);\nmxCellRenderer.registerShape(_mxConstants[\"default\"].SHAPE_IMAGE, _mxImageShape[\"default\"]);\nmxCellRenderer.registerShape(_mxConstants[\"default\"].SHAPE_LABEL, _mxLabel[\"default\"]);\nmxCellRenderer.registerShape('billCard', _BillCard[\"default\"]);\nmxCellRenderer.registerShape('stackedCard', _StackedCard[\"default\"]);\n\n/**\r\n * Function: initializeShape\r\n *\r\n * Initializes the shape in the given state by calling its init method with\r\n * the correct container after configuring it using <configureShape>.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> for which the shape should be initialized.\r\n */\nmxCellRenderer.prototype.initializeShape = function (state) {\n  state.shape.dialect = state.view.graph.dialect;\n  this.configureShape(state);\n  state.shape.init(state.view.getDrawPane());\n};\n\n/**\r\n * Function: createShape\r\n *\r\n * Creates and returns the shape for the given cell state.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> for which the shape should be created.\r\n */\nmxCellRenderer.prototype.createShape = function (state) {\n  var shape = null;\n  var container = state.view.graph.container;\n  var used = container.id === \"diagram\" ? true : false;\n  if (state.style != null) {\n    // Checks if there is a stencil for the name and creates\n    // a shape instance for the stencil if one exists\n    var key = state.style[_mxConstants[\"default\"].STYLE_SHAPE];\n    // TODO: 取stencil方式重构\n    var stencil = _mxStencilRegistry[\"default\"].getStencil(used === true && key.indexOf('_') < 0 ? key + '_USE' : key);\n\n    //没有配置其他状态节点图标的情况使用_USE\n    if (stencil == null && used == true && key.indexOf('_') > -1) {\n      stencil = _mxStencilRegistry[\"default\"].getStencil(key + '_USE');\n    }\n    if (stencil != null) {\n      shape = new _mxShape[\"default\"](stencil);\n    } else {\n      var ctor = this.getShapeConstructor(state);\n      shape = new ctor();\n    }\n  }\n  return shape;\n};\n\n/**\r\n * Function: createIndicatorShape\r\n *\r\n * Creates the indicator shape for the given cell state.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> for which the indicator shape should be created.\r\n */\nmxCellRenderer.prototype.createIndicatorShape = function (state) {\n  state.shape.indicatorShape = this.getShape(state.view.graph.getIndicatorShape(state));\n};\n\n/**\r\n * Function: getShape\r\n *\r\n * Returns the shape for the given name from <defaultShapes>.\r\n */\nmxCellRenderer.prototype.getShape = function (name) {\n  return name != null ? mxCellRenderer.prototype.defaultShapes[name] : null;\n};\n\n/**\r\n * Function: getShapeConstructor\r\n *\r\n * Returns the constructor to be used for creating the shape.\r\n */\nmxCellRenderer.prototype.getShapeConstructor = function (state) {\n  var ctor = this.getShape(state.style[_mxConstants[\"default\"].STYLE_SHAPE]);\n  if (ctor == null) {\n    ctor = state.view.graph.getModel().isEdge(state.cell) ? this.defaultEdgeShape : this.defaultVertexShape;\n  }\n  return ctor;\n};\n\n/**\r\n * Function: configureShape\r\n *\r\n * Configures the shape for the given cell state.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> for which the shape should be configured.\r\n */\nmxCellRenderer.prototype.configureShape = function (state) {\n  state.shape.apply(state);\n  state.shape.image = state.view.graph.getImage(state);\n  state.shape.indicatorColor = state.view.graph.getIndicatorColor(state);\n  state.shape.indicatorStrokeColor = state.style[_mxConstants[\"default\"].STYLE_INDICATOR_STROKECOLOR];\n  state.shape.indicatorGradientColor = state.view.graph.getIndicatorGradientColor(state);\n  state.shape.indicatorDirection = state.style[_mxConstants[\"default\"].STYLE_INDICATOR_DIRECTION];\n  state.shape.indicatorImage = state.view.graph.getIndicatorImage(state);\n  this.postConfigureShape(state);\n};\n\n/**\r\n * Function: postConfigureShape\r\n *\r\n * Replaces any reserved words used for attributes, eg. inherit,\r\n * indicated or swimlane for colors in the shape for the given state.\r\n * This implementation resolves these keywords on the fill, stroke\r\n * and gradient color keys.\r\n */\nmxCellRenderer.prototype.postConfigureShape = function (state) {\n  if (state.shape != null) {\n    this.resolveColor(state, 'indicatorColor', _mxConstants[\"default\"].STYLE_FILLCOLOR);\n    this.resolveColor(state, 'indicatorGradientColor', _mxConstants[\"default\"].STYLE_GRADIENTCOLOR);\n    this.resolveColor(state, 'fill', _mxConstants[\"default\"].STYLE_FILLCOLOR);\n    this.resolveColor(state, 'stroke', _mxConstants[\"default\"].STYLE_STROKECOLOR);\n    this.resolveColor(state, 'gradient', _mxConstants[\"default\"].STYLE_GRADIENTCOLOR);\n  }\n};\n\n/**\r\n * Function: resolveColor\r\n *\r\n * Resolves special keywords 'inherit', 'indicated' and 'swimlane' and sets\r\n * the respective color on the shape.\r\n */\nmxCellRenderer.prototype.resolveColor = function (state, field, key) {\n  var value = state.shape[field];\n  var graph = state.view.graph;\n  var referenced = null;\n  if (value == 'inherit') {\n    referenced = graph.model.getParent(state.cell);\n  } else if (value == 'swimlane') {\n    if (graph.model.getTerminal(state.cell, false) != null) {\n      referenced = graph.model.getTerminal(state.cell, false);\n    } else {\n      referenced = state.cell;\n    }\n    referenced = graph.getSwimlane(referenced);\n    key = graph.swimlaneIndicatorColorAttribute;\n  } else if (value == 'indicated') {\n    state.shape[field] = state.shape.indicatorColor;\n  }\n  if (referenced != null) {\n    var rstate = graph.getView().getState(referenced);\n    state.shape[field] = null;\n    if (rstate != null) {\n      if (rstate.shape != null && field != 'indicatorColor') {\n        state.shape[field] = rstate.shape[field];\n      } else {\n        state.shape[field] = rstate.style[key];\n      }\n    }\n  }\n};\n\n/**\r\n * Function: getLabelValue\r\n *\r\n * Returns the value to be used for the label.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> for which the label should be created.\r\n */\nmxCellRenderer.prototype.getLabelValue = function (state) {\n  return state.view.graph.getLabel(state.cell);\n};\n\n/**\r\n * Function: createLabel\r\n *\r\n * Creates the label for the given cell state.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> for which the label should be created.\r\n */\nmxCellRenderer.prototype.createLabel = function (state, value) {\n  var graph = state.view.graph;\n  var isEdge = graph.getModel().isEdge(state.cell);\n  if (state.style[_mxConstants[\"default\"].STYLE_FONTSIZE] > 0 || state.style[_mxConstants[\"default\"].STYLE_FONTSIZE] == null) {\n    // Avoids using DOM node for empty labels\n    var isForceHtml = graph.isHtmlLabel(state.cell) || value != null && _mxGraphUtils[\"default\"].isNode(value);\n    state.text = new this.defaultTextShape(value, new _mxRectangle[\"default\"](), state.style[_mxConstants[\"default\"].STYLE_ALIGN] || _mxConstants[\"default\"].ALIGN_CENTER, graph.getVerticalAlign(state), state.style[_mxConstants[\"default\"].STYLE_FONTCOLOR], state.style[_mxConstants[\"default\"].STYLE_FONTFAMILY], state.style[_mxConstants[\"default\"].STYLE_FONTSIZE], state.style[_mxConstants[\"default\"].STYLE_FONTSTYLE], state.style[_mxConstants[\"default\"].STYLE_SPACING], state.style[_mxConstants[\"default\"].STYLE_SPACING_TOP], state.style[_mxConstants[\"default\"].STYLE_SPACING_RIGHT], state.style[_mxConstants[\"default\"].STYLE_SPACING_BOTTOM], state.style[_mxConstants[\"default\"].STYLE_SPACING_LEFT], state.style[_mxConstants[\"default\"].STYLE_HORIZONTAL], state.style[_mxConstants[\"default\"].STYLE_LABEL_BACKGROUNDCOLOR], state.style[_mxConstants[\"default\"].STYLE_LABEL_BORDERCOLOR], graph.isWrapping(state.cell) && graph.isHtmlLabel(state.cell), graph.isLabelClipped(state.cell), state.style[_mxConstants[\"default\"].STYLE_OVERFLOW], state.style[_mxConstants[\"default\"].STYLE_LABEL_PADDING], _mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_TEXT_DIRECTION, _mxConstants[\"default\"].DEFAULT_TEXT_DIRECTION), state.style[_mxConstants[\"default\"].STYLE_LABEL_ELLIPSISGROUNDCOLOR] || '#FFFFFF');\n    state.text.opacity = _mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_TEXT_OPACITY, 100);\n    state.text.dialect = isForceHtml ? _mxConstants[\"default\"].DIALECT_STRICTHTML : state.view.graph.dialect;\n    state.text.style = state.style;\n    state.text.state = state;\n    this.initializeLabel(state, state.text);\n\n    // Workaround for touch devices routing all events for a mouse gesture\n    // (down, move, up) via the initial DOM node. IE additionally redirects\n    // the event via the initial DOM node but the event source is the node\n    // under the mouse, so we need to check if this is the case and force\n    // getCellAt for the subsequent mouseMoves and the final mouseUp.\n    var forceGetCell = false;\n    var getState = function getState(evt) {\n      var result = state;\n      if (_mxClient[\"default\"].IS_TOUCH || forceGetCell) {\n        var x = _mxEvent[\"default\"].getClientX(evt);\n        var y = _mxEvent[\"default\"].getClientY(evt);\n\n        // Dispatches the drop event to the graph which\n        // consumes and executes the source function\n        var pt = _mxUtils[\"default\"].convertPoint(graph.container, x, y);\n        result = graph.view.getState(graph.getCellAt(pt.x, pt.y));\n      }\n      return result;\n    };\n\n    // TODO: Add handling for special touch device gestures\n    _mxEvent[\"default\"].addGestureListeners(state.text.node, _mxGraphUtils[\"default\"].bind(this, function (evt) {\n      if (this.isLabelEvent(state, evt)) {\n        graph.fireMouseEvent(_mxEvent[\"default\"].MOUSE_DOWN, new _mxMouseEvent[\"default\"](evt, state));\n        forceGetCell = graph.dialect != _mxConstants[\"default\"].DIALECT_SVG && _mxEvent[\"default\"].getSource(evt).nodeName == 'IMG';\n      }\n    }), _mxGraphUtils[\"default\"].bind(this, function (evt) {\n      if (this.isLabelEvent(state, evt)) {\n        graph.fireMouseEvent(_mxEvent[\"default\"].MOUSE_MOVE, new _mxMouseEvent[\"default\"](evt, getState(evt)));\n      }\n    }), _mxGraphUtils[\"default\"].bind(this, function (evt) {\n      if (this.isLabelEvent(state, evt)) {\n        graph.fireMouseEvent(_mxEvent[\"default\"].MOUSE_UP, new _mxMouseEvent[\"default\"](evt, getState(evt)));\n        forceGetCell = false;\n      }\n    }));\n\n    // Uses double click timeout in mxGraph for quirks mode\n    if (graph.nativeDblClickEnabled) {\n      _mxEvent[\"default\"].addListener(state.text.node, 'dblclick', _mxGraphUtils[\"default\"].bind(this, function (evt) {\n        if (this.isLabelEvent(state, evt)) {\n          graph.dblClick(evt, state.cell);\n          _mxEvent[\"default\"].consume(evt);\n        }\n      }));\n    }\n  }\n};\n\n/**\r\n * Function: initializeLabel\r\n *\r\n * Initiailzes the label with a suitable container.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> whose label should be initialized.\r\n */\nmxCellRenderer.prototype.initializeLabel = function (state, shape) {\n  if (_mxClient[\"default\"].IS_SVG && _mxClient[\"default\"].NO_FO && shape.dialect != _mxConstants[\"default\"].DIALECT_SVG) {\n    shape.init(state.view.graph.container);\n  } else {\n    shape.init(state.view.getDrawPane());\n  }\n};\n\n/**\r\n * Function: createCellOverlays\r\n *\r\n * Creates the actual shape for showing the overlay for the given cell state.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> for which the overlay should be created.\r\n */\nmxCellRenderer.prototype.createCellOverlays = function (state) {\n  var graph = state.view.graph;\n  var overlays = graph.getCellOverlays(state.cell);\n  var dict = null;\n  if (overlays != null) {\n    dict = new _mxDictionary[\"default\"]();\n    for (var i = 0; i < overlays.length; i++) {\n      var shape = state.overlays != null ? state.overlays.remove(overlays[i]) : null;\n      if (shape == null) {\n        var tmp = new _mxImageShape[\"default\"](new _mxRectangle[\"default\"](), overlays[i].image.src);\n        tmp.dialect = state.view.graph.dialect;\n        tmp.preserveImageAspect = false;\n        tmp.overlay = overlays[i];\n        this.initializeOverlay(state, tmp);\n        this.installCellOverlayListeners(state, overlays[i], tmp);\n        if (overlays[i].cursor != null) {\n          tmp.node.style.cursor = overlays[i].cursor;\n        }\n        dict.put(overlays[i], tmp);\n      } else {\n        dict.put(overlays[i], shape);\n      }\n    }\n  }\n\n  // Removes unused\n  if (state.overlays != null) {\n    state.overlays.visit(function (id, shape) {\n      shape.destroy();\n    });\n  }\n  state.overlays = dict;\n};\n\n/**\r\n * Function: initializeOverlay\r\n *\r\n * Initializes the given overlay.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> for which the overlay should be created.\r\n * overlay - <mxImageShape> that represents the overlay.\r\n */\nmxCellRenderer.prototype.initializeOverlay = function (state, overlay) {\n  overlay.init(state.view.getOverlayPane());\n};\n\n/**\r\n * Function: installOverlayListeners\r\n *\r\n * Installs the listeners for the given <mxCellState>, <mxCellOverlay> and\r\n * <mxShape> that represents the overlay.\r\n */\nmxCellRenderer.prototype.installCellOverlayListeners = function (state, overlay, shape) {\n  var graph = state.view.graph;\n  _mxEvent[\"default\"].addListener(shape.node, 'click', function (evt) {\n    if (graph.isEditing()) {\n      graph.stopEditing(!graph.isInvokesStopCellEditing());\n    }\n    overlay.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].CLICK, 'event', evt, 'cell', state.cell));\n  });\n  _mxEvent[\"default\"].addGestureListeners(shape.node, function (evt) {\n    _mxEvent[\"default\"].consume(evt);\n  }, function (evt) {\n    graph.fireMouseEvent(_mxEvent[\"default\"].MOUSE_MOVE, new _mxMouseEvent[\"default\"](evt, state));\n  });\n  if (_mxClient[\"default\"].IS_TOUCH) {\n    _mxEvent[\"default\"].addListener(shape.node, 'touchend', function (evt) {\n      overlay.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].CLICK, 'event', evt, 'cell', state.cell));\n    });\n  }\n};\n\n/**\r\n * Function: createControl\r\n *\r\n * Creates the control for the given cell state.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> for which the control should be created.\r\n */\nmxCellRenderer.prototype.createControl = function (state) {\n  var graph = state.view.graph;\n  var image = graph.getFoldingImage(state);\n  if (graph.foldingEnabled && image != null) {\n    if (state.control == null) {\n      var b = new _mxRectangle[\"default\"](0, 0, image.width, image.height);\n      state.control = new _mxImageShape[\"default\"](b, image.src);\n      state.control.preserveImageAspect = false;\n      state.control.dialect = graph.dialect;\n      this.initControl(state, state.control, true, this.createControlClickHandler(state));\n    }\n  } else if (state.control != null) {\n    state.control.destroy();\n    state.control = null;\n  }\n};\n\n/**\r\n * Function: createControlClickHandler\r\n *\r\n * Hook for creating the click handler for the folding icon.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> whose control click handler should be returned.\r\n */\nmxCellRenderer.prototype.createControlClickHandler = function (state) {\n  var graph = state.view.graph;\n  return _mxGraphUtils[\"default\"].bind(this, function (evt) {\n    if (this.forceControlClickHandler || graph.isEnabled()) {\n      var collapse = !graph.isCellCollapsed(state.cell);\n      graph.foldCells(collapse, false, [state.cell], null, evt);\n      _mxEvent[\"default\"].consume(evt);\n    }\n  });\n};\n\n/**\r\n * Function: initControl\r\n *\r\n * Initializes the given control and returns the corresponding DOM node.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> for which the control should be initialized.\r\n * control - <mxShape> to be initialized.\r\n * handleEvents - Boolean indicating if mousedown and mousemove should fire events via the graph.\r\n * clickHandler - Optional function to implement clicks on the control.\r\n */\nmxCellRenderer.prototype.initControl = function (state, control, handleEvents, clickHandler) {\n  var graph = state.view.graph;\n\n  // In the special case where the label is in HTML and the display is SVG the image\n  // should go into the graph container directly in order to be clickable. Otherwise\n  // it is obscured by the HTML label that overlaps the cell.\n  var isForceHtml = graph.isHtmlLabel(state.cell) && _mxClient[\"default\"].NO_FO && graph.dialect == _mxConstants[\"default\"].DIALECT_SVG;\n  if (isForceHtml) {\n    control.dialect = _mxConstants[\"default\"].DIALECT_PREFERHTML;\n    control.init(graph.container);\n    control.node.style.zIndex = 1;\n  } else {\n    control.init(state.view.getOverlayPane());\n  }\n  var node = control.innerNode || control.node;\n\n  // Workaround for missing click event on iOS is to check tolerance below\n  if (clickHandler != null && !_mxClient[\"default\"].IS_IOS) {\n    if (this.forceControlClickHandler || graph.isEnabled()) {\n      node.style.cursor = 'pointer';\n    }\n    _mxEvent[\"default\"].addListener(node, 'click', clickHandler);\n  }\n  if (handleEvents) {\n    var first = null;\n    _mxEvent[\"default\"].addGestureListeners(node, function (evt) {\n      first = new _mxPoint[\"default\"](_mxEvent[\"default\"].getClientX(evt), _mxEvent[\"default\"].getClientY(evt));\n      graph.fireMouseEvent(_mxEvent[\"default\"].MOUSE_DOWN, new _mxMouseEvent[\"default\"](evt, state));\n      _mxEvent[\"default\"].consume(evt);\n    }, function (evt) {\n      graph.fireMouseEvent(_mxEvent[\"default\"].MOUSE_MOVE, new _mxMouseEvent[\"default\"](evt, state));\n    }, function (evt) {\n      graph.fireMouseEvent(_mxEvent[\"default\"].MOUSE_UP, new _mxMouseEvent[\"default\"](evt, state));\n      _mxEvent[\"default\"].consume(evt);\n    });\n\n    // Uses capture phase for event interception to stop bubble phase\n    if (clickHandler != null && _mxClient[\"default\"].IS_IOS) {\n      node.addEventListener('touchend', function (evt) {\n        if (first != null) {\n          var tol = graph.tolerance;\n          if (Math.abs(first.x - _mxEvent[\"default\"].getClientX(evt)) < tol && Math.abs(first.y - _mxEvent[\"default\"].getClientY(evt)) < tol) {\n            clickHandler.call(clickHandler, evt);\n            _mxEvent[\"default\"].consume(evt);\n          }\n        }\n      }, true);\n    }\n  }\n  return node;\n};\n\n/**\r\n * Function: isShapeEvent\r\n *\r\n * Returns true if the event is for the shape of the given state. This\r\n * implementation always returns true.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> whose shape fired the event.\r\n * evt - Mouse event which was fired.\r\n */\nmxCellRenderer.prototype.isShapeEvent = function (state, evt) {\n  return true;\n};\n\n/**\r\n * Function: isLabelEvent\r\n *\r\n * Returns true if the event is for the label of the given state. This\r\n * implementation always returns true.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> whose label fired the event.\r\n * evt - Mouse event which was fired.\r\n */\nmxCellRenderer.prototype.isLabelEvent = function (state, evt) {\n  return true;\n};\n\n/**\r\n * Function: installListeners\r\n *\r\n * Installs the event listeners for the given cell state.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> for which the event listeners should be isntalled.\r\n */\nmxCellRenderer.prototype.installListeners = function (state) {\n  var graph = state.view.graph;\n\n  // Workaround for touch devices routing all events for a mouse\n  // gesture (down, move, up) via the initial DOM node. Same for\n  // HTML images in all IE versions (VML images are working).\n  var getState = function getState(evt) {\n    var result = state;\n    if (graph.dialect != _mxConstants[\"default\"].DIALECT_SVG && _mxEvent[\"default\"].getSource(evt).nodeName == 'IMG' || _mxClient[\"default\"].IS_TOUCH) {\n      var x = _mxEvent[\"default\"].getClientX(evt);\n      var y = _mxEvent[\"default\"].getClientY(evt);\n\n      // Dispatches the drop event to the graph which\n      // consumes and executes the source function\n      var pt = _mxUtils[\"default\"].convertPoint(graph.container, x, y);\n      result = graph.view.getState(graph.getCellAt(pt.x, pt.y));\n    }\n    return result;\n  };\n  _mxEvent[\"default\"].addGestureListeners(state.shape.node, _mxGraphUtils[\"default\"].bind(this, function (evt) {\n    if (this.isShapeEvent(state, evt)) {\n      graph.fireMouseEvent(_mxEvent[\"default\"].MOUSE_DOWN, new _mxMouseEvent[\"default\"](evt, state));\n    }\n  }), _mxGraphUtils[\"default\"].bind(this, function (evt) {\n    if (this.isShapeEvent(state, evt)) {\n      graph.fireMouseEvent(_mxEvent[\"default\"].MOUSE_MOVE, new _mxMouseEvent[\"default\"](evt, getState(evt)));\n    }\n  }), _mxGraphUtils[\"default\"].bind(this, function (evt) {\n    if (this.isShapeEvent(state, evt)) {\n      graph.fireMouseEvent(_mxEvent[\"default\"].MOUSE_UP, new _mxMouseEvent[\"default\"](evt, getState(evt)));\n    }\n  }));\n\n  // Uses double click timeout in mxGraph for quirks mode\n  if (graph.nativeDblClickEnabled) {\n    _mxEvent[\"default\"].addListener(state.shape.node, 'dblclick', _mxGraphUtils[\"default\"].bind(this, function (evt) {\n      if (this.isShapeEvent(state, evt)) {\n        graph.dblClick(evt, state.cell);\n        _mxEvent[\"default\"].consume(evt);\n      }\n    }));\n  }\n};\n\n/**\r\n * Function: redrawLabel\r\n *\r\n * Redraws the label for the given cell state.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> whose label should be redrawn.\r\n */\nmxCellRenderer.prototype.redrawLabel = function (state, forced) {\n  var value = this.getLabelValue(state);\n  if (state.text == null && value != null && (_mxGraphUtils[\"default\"].isNode(value) || value.length > 0)) {\n    this.createLabel(state, value);\n  } else if (state.text != null && (value == null || value.length == 0)) {\n    state.text.destroy();\n    state.text = null;\n  }\n  if (state.text != null) {\n    var graph = state.view.graph;\n\n    // Forced is true if the style has changed, so to get the updated\n    // result in getLabelBounds we apply the new style to the shape\n    if (forced) {\n      // Checks if a full repaint is needed\n      if (state.text.lastValue != null && this.isTextShapeInvalid(state, state.text)) {\n        // Forces a full repaint\n        state.text.lastValue = null;\n      }\n      state.text.resetStyles();\n      state.text.apply(state);\n\n      // Special case opacity which is taken from textOpacity style for text\n      state.text.opacity = _mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_TEXT_OPACITY, 100);\n    }\n    var bounds = this.getLabelBounds(state);\n    var wrapping = graph.isWrapping(state.cell);\n    var clipping = graph.isLabelClipped(state.cell);\n    var isForceHtml = state.view.graph.isHtmlLabel(state.cell) || value != null && _mxGraphUtils[\"default\"].isNode(value);\n    var dialect = isForceHtml ? _mxConstants[\"default\"].DIALECT_STRICTHTML : state.view.graph.dialect;\n\n    // Text is a special case where change of dialect is possible at runtime\n    var overflow = state.style[_mxConstants[\"default\"].STYLE_OVERFLOW] || 'visible';\n    if (forced || state.text.value != value || state.text.isWrapping != wrapping || state.text.overflow != overflow || state.text.isClipping != clipping || state.text.scale != this.getTextScale(state) || state.text.dialect != dialect || !state.text.bounds.equals(bounds)) {\n      state.text.dialect = dialect;\n      state.text.value = value;\n      state.text.bounds = bounds;\n      state.text.scale = this.getTextScale(state);\n      state.text.wrap = wrapping;\n      state.text.clipped = clipping;\n      state.text.overflow = overflow;\n\n      // Preserves visible state\n      var vis = state.text.node.style.visibility;\n      this.redrawLabelShape(state.text);\n      //TODO 处理方式优化，使用事件？\n      var shape = state.shape;\n      shape.afterRedrawLabel && shape.afterRedrawLabel(state.text.node.firstElementChild);\n      state.text.node.style.visibility = vis;\n    }\n  }\n};\n\n/**\r\n * Function: isTextShapeInvalid\r\n *\r\n * Returns true if the style for the text shape has changed.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> whose label should be checked.\r\n * shape - <mxText> shape to be checked.\r\n */\nmxCellRenderer.prototype.isTextShapeInvalid = function (state, shape) {\n  function check(property, stylename, defaultValue) {\n    return shape[property] != (state.style[stylename] || defaultValue);\n  }\n  ;\n  return check('fontStyle', _mxConstants[\"default\"].STYLE_FONTSTYLE, _mxConstants[\"default\"].DEFAULT_FONTSTYLE) || check('family', _mxConstants[\"default\"].STYLE_FONTFAMILY, _mxConstants[\"default\"].DEFAULT_FONTFAMILY) || check('size', _mxConstants[\"default\"].STYLE_FONTSIZE, _mxConstants[\"default\"].DEFAULT_FONTSIZE) || check('color', _mxConstants[\"default\"].STYLE_FONTCOLOR, 'black') || check('align', _mxConstants[\"default\"].STYLE_ALIGN, '') || check('valign', _mxConstants[\"default\"].STYLE_VERTICAL_ALIGN, '') || check('spacing', _mxConstants[\"default\"].STYLE_SPACING, 2) || check('spacingTop', _mxConstants[\"default\"].STYLE_SPACING_TOP, 2) || check('spacingRight', _mxConstants[\"default\"].STYLE_SPACING_RIGHT, 2) || check('spacingBottom', _mxConstants[\"default\"].STYLE_SPACING_BOTTOM, 2) || check('spacingLeft', _mxConstants[\"default\"].STYLE_SPACING_LEFT, 2) || check('horizontal', _mxConstants[\"default\"].STYLE_HORIZONTAL, true) || check('background', _mxConstants[\"default\"].STYLE_LABEL_BACKGROUNDCOLOR) || check('border', _mxConstants[\"default\"].STYLE_LABEL_BORDERCOLOR) || check('opacity', _mxConstants[\"default\"].STYLE_TEXT_OPACITY, 100) || check('textDirection', _mxConstants[\"default\"].STYLE_TEXT_DIRECTION, _mxConstants[\"default\"].DEFAULT_TEXT_DIRECTION);\n};\n\n/**\r\n * Function: redrawLabelShape\r\n *\r\n * Called to invoked redraw on the given text shape.\r\n *\r\n * Parameters:\r\n *\r\n * shape - <mxText> shape to be redrawn.\r\n */\nmxCellRenderer.prototype.redrawLabelShape = function (shape) {\n  shape.redraw();\n};\n\n/**\r\n * Function: getTextScale\r\n *\r\n * Returns the scaling used for the label of the given state\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> whose label scale should be returned.\r\n */\nmxCellRenderer.prototype.getTextScale = function (state) {\n  return state.view.scale;\n};\n\n/**\r\n * Function: getLabelBounds\r\n *\r\n * Returns the bounds to be used to draw the label of the given state.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> whose label bounds should be returned.\r\n */\nmxCellRenderer.prototype.getLabelBounds = function (state) {\n  var graph = state.view.graph;\n  var scale = state.view.scale;\n  var isEdge = graph.getModel().isEdge(state.cell);\n  var bounds = new _mxRectangle[\"default\"](state.absoluteOffset.x, state.absoluteOffset.y);\n  if (isEdge) {\n    var spacing = state.text.getSpacing();\n    bounds.x += spacing.x * scale;\n    bounds.y += spacing.y * scale;\n    var geo = graph.getCellGeometry(state.cell);\n    if (geo != null) {\n      bounds.width = Math.max(0, geo.width * scale);\n      bounds.height = Math.max(0, geo.height * scale);\n    }\n  } else {\n    // Inverts label position\n    if (state.text.isPaintBoundsInverted()) {\n      var tmp = bounds.x;\n      bounds.x = bounds.y;\n      bounds.y = tmp;\n    }\n    bounds.x += state.x;\n    bounds.y += state.y;\n\n    // Minimum of 1 fixes alignment bug in HTML labels\n    bounds.width = Math.max(1, state.width);\n    bounds.height = Math.max(1, state.height);\n    var sc = _mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_STROKECOLOR, _mxConstants[\"default\"].NONE);\n    if (sc != _mxConstants[\"default\"].NONE && sc != '') {\n      var s = parseFloat(_mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_STROKEWIDTH, 1)) * scale;\n      var dx = 1 + Math.floor((s - 1) / 2);\n      var dh = Math.floor(s + 1);\n      bounds.x += dx;\n      bounds.y += dx;\n      bounds.width -= dh;\n      bounds.height -= dh;\n    }\n  }\n  if (state.text.isPaintBoundsInverted()) {\n    // Rotates around center of state\n    var t = (state.width - state.height) / 2;\n    bounds.x += t;\n    bounds.y -= t;\n    var tmp = bounds.width;\n    bounds.width = bounds.height;\n    bounds.height = tmp;\n  }\n\n  // Shape can modify its label bounds\n  if (state.shape != null) {\n    var hpos = _mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_LABEL_POSITION, _mxConstants[\"default\"].ALIGN_CENTER);\n    var vpos = _mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_VERTICAL_LABEL_POSITION, _mxConstants[\"default\"].ALIGN_MIDDLE);\n    if (hpos == _mxConstants[\"default\"].ALIGN_CENTER && vpos == _mxConstants[\"default\"].ALIGN_MIDDLE) {\n      bounds = state.shape.getLabelBounds(bounds);\n    }\n  }\n\n  // Label width style overrides actual label width\n  var lw = _mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_LABEL_WIDTH, null);\n  if (lw != null) {\n    bounds.width = parseFloat(lw) * scale;\n  }\n  if (!isEdge) {\n    this.rotateLabelBounds(state, bounds);\n  }\n  return bounds;\n};\n\n/**\r\n * Function: rotateLabelBounds\r\n *\r\n * Adds the shape rotation to the given label bounds and\r\n * applies the alignment and offsets.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> whose label bounds should be rotated.\r\n * bounds - <mxRectangle> the rectangle to be rotated.\r\n */\nmxCellRenderer.prototype.rotateLabelBounds = function (state, bounds) {\n  bounds.y -= state.text.margin.y * bounds.height;\n  bounds.x -= state.text.margin.x * bounds.width;\n  if (!this.legacySpacing || state.style[_mxConstants[\"default\"].STYLE_OVERFLOW] != 'fill' && state.style[_mxConstants[\"default\"].STYLE_OVERFLOW] != 'width') {\n    var s = state.view.scale;\n    var spacing = state.text.getSpacing();\n    bounds.x += spacing.x * s;\n    bounds.y += spacing.y * s;\n    var hpos = _mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_LABEL_POSITION, _mxConstants[\"default\"].ALIGN_CENTER);\n    var vpos = _mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_VERTICAL_LABEL_POSITION, _mxConstants[\"default\"].ALIGN_MIDDLE);\n    var lw = _mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_LABEL_WIDTH, null);\n    bounds.width = Math.max(0, bounds.width - (hpos == _mxConstants[\"default\"].ALIGN_CENTER && lw == null ? state.text.spacingLeft * s + state.text.spacingRight * s : 0));\n    bounds.height = Math.max(0, bounds.height - (vpos == _mxConstants[\"default\"].ALIGN_MIDDLE ? state.text.spacingTop * s + state.text.spacingBottom * s : 0));\n  }\n  var theta = state.text.getTextRotation();\n\n  // Only needed if rotated around another center\n  if (theta != 0 && state != null && state.view.graph.model.isVertex(state.cell)) {\n    var cx = state.getCenterX();\n    var cy = state.getCenterY();\n    if (bounds.x != cx || bounds.y != cy) {\n      var rad = theta * (Math.PI / 180);\n      var pt = _mxUtils[\"default\"].getRotatedPoint(new _mxPoint[\"default\"](bounds.x, bounds.y), Math.cos(rad), Math.sin(rad), new _mxPoint[\"default\"](cx, cy));\n      bounds.x = pt.x;\n      bounds.y = pt.y;\n    }\n  }\n};\n\n/**\r\n * Function: redrawCellOverlays\r\n *\r\n * Redraws the overlays for the given cell state.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> whose overlays should be redrawn.\r\n */\nmxCellRenderer.prototype.redrawCellOverlays = function (state, forced) {\n  this.createCellOverlays(state);\n  if (state.overlays != null) {\n    var rot = _mxGraphUtils[\"default\"].mod(_mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_ROTATION, 0), 90);\n    var rad = _mxUtils[\"default\"].toRadians(rot);\n    var cos = Math.cos(rad);\n    var sin = Math.sin(rad);\n    state.overlays.visit(function (id, shape) {\n      var bounds = shape.overlay.getBounds(state);\n      if (!state.view.graph.getModel().isEdge(state.cell)) {\n        if (state.shape != null && rot != 0) {\n          var cx = bounds.getCenterX();\n          var cy = bounds.getCenterY();\n          var point = _mxUtils[\"default\"].getRotatedPoint(new _mxPoint[\"default\"](cx, cy), cos, sin, new _mxPoint[\"default\"](state.getCenterX(), state.getCenterY()));\n          cx = point.x;\n          cy = point.y;\n          bounds.x = Math.round(cx - bounds.width / 2);\n          bounds.y = Math.round(cy - bounds.height / 2);\n        }\n      }\n      if (forced || shape.bounds == null || shape.scale != state.view.scale || !shape.bounds.equals(bounds)) {\n        shape.bounds = bounds;\n        shape.scale = state.view.scale;\n        shape.redraw();\n      }\n    });\n  }\n};\n\n/**\r\n * Function: redrawControl\r\n *\r\n * Redraws the control for the given cell state.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> whose control should be redrawn.\r\n */\nmxCellRenderer.prototype.redrawControl = function (state, forced) {\n  var image = state.view.graph.getFoldingImage(state);\n  if (state.control != null && image != null) {\n    var bounds = this.getControlBounds(state, image.width, image.height);\n    var r = this.legacyControlPosition ? _mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_ROTATION, 0) : state.shape.getTextRotation();\n    var s = state.view.scale;\n    if (forced || state.control.scale != s || !state.control.bounds.equals(bounds) || state.control.rotation != r) {\n      state.control.rotation = r;\n      state.control.bounds = bounds;\n      state.control.scale = s;\n      state.control.redraw();\n    }\n  }\n};\n\n/**\r\n * Function: getControlBounds\r\n *\r\n * Returns the bounds to be used to draw the control (folding icon) of the\r\n * given state.\r\n */\nmxCellRenderer.prototype.getControlBounds = function (state, w, h) {\n  if (state.control != null) {\n    var s = state.view.scale;\n    var cx = state.getCenterX();\n    var cy = state.getCenterY();\n    if (!state.view.graph.getModel().isEdge(state.cell)) {\n      var rgtSpacing = state.style.startSize * 0.05 || 2;\n      //图标改到右侧\n      cx = state.x + state.width - w * s - rgtSpacing; //state.x + w * s;\n      cy = state.y + state.style.startSize / 2; //state.y + h * s;\n\n      if (state.shape != null) {\n        // TODO: Factor out common code\n        var rot = state.shape.getShapeRotation();\n        if (this.legacyControlPosition) {\n          rot = _mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_ROTATION, 0);\n        } else {\n          if (state.shape.isPaintBoundsInverted()) {\n            var t = (state.width - state.height) / 2;\n            cx += t;\n            cy -= t;\n          }\n        }\n        if (rot != 0) {\n          var rad = _mxUtils[\"default\"].toRadians(rot);\n          var cos = Math.cos(rad);\n          var sin = Math.sin(rad);\n          var point = _mxUtils[\"default\"].getRotatedPoint(new _mxPoint[\"default\"](cx, cy), cos, sin, new _mxPoint[\"default\"](state.getCenterX(), state.getCenterY()));\n          cx = point.x;\n          cy = point.y;\n        }\n      }\n    }\n    state.view.graph.getModel().isEdge(state.cell);\n    return new _mxRectangle[\"default\"](Math.round(cx - w / 2 * s), Math.round(cy - h / 2 * s), Math.round(w * s), Math.round(h * s));\n  }\n  return null;\n};\n\n/**\r\n * Function: insertStateAfter\r\n *\r\n * Inserts the given array of <mxShapes> after the given nodes in the DOM.\r\n *\r\n * Parameters:\r\n *\r\n * shapes - Array of <mxShapes> to be inserted.\r\n * node - Node in <drawPane> after which the shapes should be inserted.\r\n * htmlNode - Node in the graph container after which the shapes should be inserted that\r\n * will not go into the <drawPane> (eg. HTML labels without foreignObjects).\r\n */\nmxCellRenderer.prototype.insertStateAfter = function (state, node, htmlNode) {\n  var shapes = this.getShapesForState(state);\n  for (var i = 0; i < shapes.length; i++) {\n    if (shapes[i] != null && shapes[i].node != null) {\n      var html = shapes[i].node.parentNode != state.view.getDrawPane() && shapes[i].node.parentNode != state.view.getOverlayPane();\n      var temp = html ? htmlNode : node;\n      if (temp != null && temp.nextSibling != shapes[i].node) {\n        if (temp.nextSibling == null) {\n          temp.parentNode.appendChild(shapes[i].node);\n        } else {\n          temp.parentNode.insertBefore(shapes[i].node, temp.nextSibling);\n        }\n      } else if (temp == null) {\n        // Special case: First HTML node should be first sibling after canvas\n        if (shapes[i].node.parentNode == state.view.graph.container) {\n          var canvas = state.view.canvas;\n          while (canvas != null && canvas.parentNode != state.view.graph.container) {\n            canvas = canvas.parentNode;\n          }\n          if (canvas != null && canvas.nextSibling != null) {\n            if (canvas.nextSibling != shapes[i].node) {\n              shapes[i].node.parentNode.insertBefore(shapes[i].node, canvas.nextSibling);\n            }\n          } else {\n            shapes[i].node.parentNode.appendChild(shapes[i].node);\n          }\n        } else if (shapes[i].node.parentNode.firstChild != null && shapes[i].node.parentNode.firstChild != shapes[i].node) {\n          // Inserts the node as the first child of the parent to implement the order\n          shapes[i].node.parentNode.insertBefore(shapes[i].node, shapes[i].node.parentNode.firstChild);\n        }\n      }\n      if (html) {\n        htmlNode = shapes[i].node;\n      } else {\n        node = shapes[i].node;\n      }\n    }\n  }\n  return [node, htmlNode];\n};\n\n/**\r\n * Function: getShapesForState\r\n *\r\n * Returns the <mxShapes> for the given cell state in the order in which they should\r\n * appear in the DOM.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> whose shapes should be returned.\r\n */\nmxCellRenderer.prototype.getShapesForState = function (state) {\n  return [state.shape, state.text, state.control];\n};\n\n/**\r\n * Function: redraw\r\n *\r\n * Updates the bounds or points and scale of the shapes for the given cell\r\n * state. This is called in mxGraphView.validatePoints as the last step of\r\n * updating all cells.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> for which the shapes should be updated.\r\n * force - Optional boolean that specifies if the cell should be reconfiured\r\n * and redrawn without any additional checks.\r\n * rendering - Optional boolean that specifies if the cell should actually\r\n * be drawn into the DOM. If this is false then redraw and/or reconfigure\r\n * will not be called on the shape.\r\n */\nmxCellRenderer.prototype.redraw = function (state, force, rendering) {\n  var shapeChanged = this.redrawShape(state, force, rendering);\n  if (state.shape != null && (rendering == null || rendering)) {\n    this.redrawLabel(state, shapeChanged);\n    this.redrawCellOverlays(state, shapeChanged);\n    this.redrawControl(state, shapeChanged);\n  }\n};\n\n/**\r\n * Function: redrawShape\r\n *\r\n * Redraws the shape for the given cell state.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> whose label should be redrawn.\r\n */\nmxCellRenderer.prototype.redrawShape = function (state, force, rendering) {\n  var model = state.view.graph.model;\n  var shapeChanged = false;\n\n  // Forces creation of new shape if shape style has changed\n  if (state.shape != null && state.shape.style != null && state.style != null && state.shape.style[_mxConstants[\"default\"].STYLE_SHAPE] != state.style[_mxConstants[\"default\"].STYLE_SHAPE]) {\n    state.shape.destroy();\n    state.shape = null;\n  }\n  var container = state.view.graph.container;\n  if (state.shape == null && container != null && state.cell != state.view.currentRoot && (model.isVertex(state.cell) || model.isEdge(state.cell))) {\n    state.shape = this.createShape(state);\n    if (state.shape != null) {\n      state.shape.antiAlias = this.antiAlias;\n      this.createIndicatorShape(state);\n      this.initializeShape(state);\n      this.createCellOverlays(state);\n      this.installListeners(state);\n\n      // Forces a refresh of the handler of one exists\n      state.view.graph.selectionCellsHandler.updateHandler(state);\n    }\n  } else if (state.shape != null && !_mxUtils[\"default\"].equalEntries(state.shape.style, state.style)) {\n    state.shape.resetStyles();\n    this.configureShape(state);\n    // LATER: Ignore update for realtime to fix reset of current gesture\n    state.view.graph.selectionCellsHandler.updateHandler(state);\n    force = true;\n  }\n  if (state.shape != null) {\n    // Handles changes of the collapse icon\n    this.createControl(state);\n\n    // Redraws the cell if required, ignores changes to bounds if points are\n    // defined as the bounds are updated for the given points inside the shape\n    if (force || state.shape.bounds == null || state.shape.scale != state.view.scale || state.absolutePoints == null && !state.shape.bounds.equals(state) || state.absolutePoints != null && !_mxUtils[\"default\"].equalPoints(state.shape.points, state.absolutePoints)) {\n      if (state.absolutePoints != null) {\n        state.shape.points = state.absolutePoints.slice();\n        state.shape.bounds = null;\n      } else {\n        state.shape.points = null;\n        state.shape.bounds = new _mxRectangle[\"default\"](state.x, state.y, state.width, state.height);\n      }\n      state.shape.scale = state.view.scale;\n      if (rendering == null || rendering) {\n        state.shape.redraw();\n      } else {\n        state.shape.updateBoundingBox();\n      }\n      shapeChanged = true;\n    }\n  }\n  return shapeChanged;\n};\n\n/**\r\n * Function: destroy\r\n *\r\n * Destroys the shapes associated with the given cell state.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> for which the shapes should be destroyed.\r\n */\nmxCellRenderer.prototype.destroy = function (state) {\n  if (state.shape != null) {\n    if (state.text != null) {\n      state.text.destroy();\n      state.text = null;\n    }\n    if (state.overlays != null) {\n      state.overlays.visit(function (id, shape) {\n        shape.destroy();\n      });\n      state.overlays = null;\n    }\n    if (state.control != null) {\n      state.control.destroy();\n      state.control = null;\n    }\n    state.shape.destroy();\n    state.shape = null;\n  }\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\nvar _default = exports[\"default\"] = mxCellRenderer;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxCellRenderer.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxCellState.js":
/*!**********************************************!*\
  !*** ./src/workflow/mxClient/mxCellState.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _mxPoint = _interopRequireDefault(__webpack_require__(/*! ./mxPoint.js */ \"./src/workflow/mxClient/mxPoint.js\"));\nvar _mxRectangle = _interopRequireDefault(__webpack_require__(/*! ./mxRectangle.js */ \"./src/workflow/mxClient/mxRectangle.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxCellState(view, cell, style) {\n  this.view = view;\n  this.cell = cell;\n  this.style = style;\n  this.origin = new _mxPoint[\"default\"]();\n  this.absoluteOffset = new _mxPoint[\"default\"]();\n}\n;\n\n/**\r\n * Extends mxRectangle.\r\n */\nmxCellState.prototype = new _mxRectangle[\"default\"]();\nmxCellState.prototype.constructor = mxCellState;\n\n/**\r\n * Variable: view\r\n *\r\n * Reference to the enclosing <mxGraphView>.\r\n */\nmxCellState.prototype.view = null;\n\n/**\r\n * Variable: cell\r\n *\r\n * Reference to the <mxCell> that is represented by this state.\r\n */\nmxCellState.prototype.cell = null;\n\n/**\r\n * Variable: style\r\n *\r\n * Contains an array of key, value pairs that represent the style of the\r\n * cell.\r\n */\nmxCellState.prototype.style = null;\n\n/**\r\n * Variable: invalid\r\n *\r\n * Specifies if the state is invalid. Default is true.\r\n */\nmxCellState.prototype.invalid = true;\n\n/**\r\n * Variable: origin\r\n *\r\n * <mxPoint> that holds the origin for all child cells. Default is a new\r\n * empty <mxPoint>.\r\n */\nmxCellState.prototype.origin = null;\n\n/**\r\n * Variable: absolutePoints\r\n *\r\n * Holds an array of <mxPoints> that represent the absolute points of an\r\n * edge.\r\n */\nmxCellState.prototype.absolutePoints = null;\n\n/**\r\n * Variable: absoluteOffset\r\n *\r\n * <mxPoint> that holds the absolute offset. For edges, this is the\r\n * absolute coordinates of the label position. For vertices, this is the\r\n * offset of the label relative to the top, left corner of the vertex.\r\n */\nmxCellState.prototype.absoluteOffset = null;\n\n/**\r\n * Variable: visibleSourceState\r\n *\r\n * Caches the visible source terminal state.\r\n */\nmxCellState.prototype.visibleSourceState = null;\n\n/**\r\n * Variable: visibleTargetState\r\n *\r\n * Caches the visible target terminal state.\r\n */\nmxCellState.prototype.visibleTargetState = null;\n\n/**\r\n * Variable: terminalDistance\r\n *\r\n * Caches the distance between the end points for an edge.\r\n */\nmxCellState.prototype.terminalDistance = 0;\n\n/**\r\n * Variable: length\r\n *\r\n * Caches the length of an edge.\r\n */\nmxCellState.prototype.length = 0;\n\n/**\r\n * Variable: segments\r\n *\r\n * Array of numbers that represent the cached length of each segment of the\r\n * edge.\r\n */\nmxCellState.prototype.segments = null;\n\n/**\r\n * Variable: shape\r\n *\r\n * Holds the <mxShape> that represents the cell graphically.\r\n */\nmxCellState.prototype.shape = null;\n\n/**\r\n * Variable: text\r\n *\r\n * Holds the <mxText> that represents the label of the cell. Thi smay be\r\n * null if the cell has no label.\r\n */\nmxCellState.prototype.text = null;\n\n/**\r\n * Variable: unscaledWidth\r\n *\r\n * Holds the unscaled width of the state.\r\n */\nmxCellState.prototype.unscaledWidth = null;\n\n/**\r\n * Function: getPerimeterBounds\r\n *\r\n * Returns the <mxRectangle> that should be used as the perimeter of the\r\n * cell.\r\n *\r\n * Parameters:\r\n *\r\n * border - Optional border to be added around the perimeter bounds.\r\n * bounds - Optional <mxRectangle> to be used as the initial bounds.\r\n */\nmxCellState.prototype.getPerimeterBounds = function (border, bounds) {\n  border = border || 0;\n  bounds = bounds != null ? bounds : new _mxRectangle[\"default\"](this.x, this.y, this.width, this.height);\n  if (this.shape != null && this.shape.stencil != null && this.shape.stencil.aspect == 'fixed') {\n    var aspect = this.shape.stencil.computeAspect(this.style, bounds.x, bounds.y, bounds.width, bounds.height);\n    bounds.x = aspect.x;\n    bounds.y = aspect.y;\n    bounds.width = this.shape.stencil.w0 * aspect.width;\n    bounds.height = this.shape.stencil.h0 * aspect.height;\n  }\n  if (border != 0) {\n    bounds.grow(border);\n  }\n  return bounds;\n};\n\n/**\r\n * Function: setAbsoluteTerminalPoint\r\n *\r\n * Sets the first or last point in <absolutePoints> depending on isSource.\r\n *\r\n * Parameters:\r\n *\r\n * point - <mxPoint> that represents the terminal point.\r\n * isSource - Boolean that specifies if the first or last point should\r\n * be assigned.\r\n */\nmxCellState.prototype.setAbsoluteTerminalPoint = function (point, isSource) {\n  if (isSource) {\n    if (this.absolutePoints == null) {\n      this.absolutePoints = [];\n    }\n    if (this.absolutePoints.length == 0) {\n      this.absolutePoints.push(point);\n    } else {\n      this.absolutePoints[0] = point;\n    }\n  } else {\n    if (this.absolutePoints == null) {\n      this.absolutePoints = [];\n      this.absolutePoints.push(null);\n      this.absolutePoints.push(point);\n    } else if (this.absolutePoints.length == 1) {\n      this.absolutePoints.push(point);\n    } else {\n      this.absolutePoints[this.absolutePoints.length - 1] = point;\n    }\n  }\n};\n\n/**\r\n * Function: setCursor\r\n *\r\n * Sets the given cursor on the shape and text shape.\r\n */\nmxCellState.prototype.setCursor = function (cursor) {\n  if (this.shape != null) {\n    this.shape.setCursor(cursor);\n  }\n  if (this.text != null) {\n    this.text.setCursor(cursor);\n  }\n};\n\n/**\r\n * Function: getVisibleTerminal\r\n *\r\n * Returns the visible source or target terminal cell.\r\n *\r\n * Parameters:\r\n *\r\n * source - Boolean that specifies if the source or target cell should be\r\n * returned.\r\n */\nmxCellState.prototype.getVisibleTerminal = function (source) {\n  var tmp = this.getVisibleTerminalState(source);\n  return tmp != null ? tmp.cell : null;\n};\n\n/**\r\n * Function: getVisibleTerminalState\r\n *\r\n * Returns the visible source or target terminal state.\r\n *\r\n * Parameters:\r\n *\r\n * source - Boolean that specifies if the source or target state should be\r\n * returned.\r\n */\nmxCellState.prototype.getVisibleTerminalState = function (source) {\n  return source ? this.visibleSourceState : this.visibleTargetState;\n};\n\n/**\r\n * Function: setVisibleTerminalState\r\n *\r\n * Sets the visible source or target terminal state.\r\n *\r\n * Parameters:\r\n *\r\n * terminalState - <mxCellState> that represents the terminal.\r\n * source - Boolean that specifies if the source or target state should be set.\r\n */\nmxCellState.prototype.setVisibleTerminalState = function (terminalState, source) {\n  if (source) {\n    this.visibleSourceState = terminalState;\n  } else {\n    this.visibleTargetState = terminalState;\n  }\n};\n\n/**\r\n * Function: getCellBounds\r\n *\r\n * Returns the unscaled, untranslated bounds.\r\n */\nmxCellState.prototype.getCellBounds = function () {\n  return this.cellBounds;\n};\n\n/**\r\n * Function: getPaintBounds\r\n *\r\n * Returns the unscaled, untranslated paint bounds. This is the same as\r\n * <getCellBounds> but with a 90 degree rotation if the shape's\r\n * isPaintBoundsInverted returns true.\r\n */\nmxCellState.prototype.getPaintBounds = function () {\n  return this.paintBounds;\n};\n\n/**\r\n * Function: updateCachedBounds\r\n *\r\n * Updates the cellBounds and paintBounds.\r\n */\nmxCellState.prototype.updateCachedBounds = function () {\n  var tr = this.view.translate;\n  var s = this.view.scale;\n  this.cellBounds = new _mxRectangle[\"default\"](this.x / s - tr.x, this.y / s - tr.y, this.width / s, this.height / s);\n  this.paintBounds = _mxRectangle[\"default\"].fromRectangle(this.cellBounds);\n  if (this.shape != null && this.shape.isPaintBoundsInverted()) {\n    this.paintBounds.rotate90();\n  }\n};\n\n/**\r\n * Destructor: setState\r\n *\r\n * Copies all fields from the given state to this state.\r\n */\nmxCellState.prototype.setState = function (state) {\n  this.view = state.view;\n  this.cell = state.cell;\n  this.style = state.style;\n  this.absolutePoints = state.absolutePoints;\n  this.origin = state.origin;\n  this.absoluteOffset = state.absoluteOffset;\n  this.boundingBox = state.boundingBox;\n  this.terminalDistance = state.terminalDistance;\n  this.segments = state.segments;\n  this.length = state.length;\n  this.x = state.x;\n  this.y = state.y;\n  this.width = state.width;\n  this.height = state.height;\n  this.unscaledWidth = state.unscaledWidth;\n};\n\n/**\r\n * Function: clone\r\n *\r\n * Returns a clone of this <mxPoint>.\r\n */\nmxCellState.prototype.clone = function () {\n  var clone = new mxCellState(this.view, this.cell, this.style);\n\n  // Clones the absolute points\n  if (this.absolutePoints != null) {\n    clone.absolutePoints = [];\n    for (var i = 0; i < this.absolutePoints.length; i++) {\n      clone.absolutePoints[i] = this.absolutePoints[i].clone();\n    }\n  }\n  if (this.origin != null) {\n    clone.origin = this.origin.clone();\n  }\n  if (this.absoluteOffset != null) {\n    clone.absoluteOffset = this.absoluteOffset.clone();\n  }\n  if (this.boundingBox != null) {\n    clone.boundingBox = this.boundingBox.clone();\n  }\n  clone.terminalDistance = this.terminalDistance;\n  clone.segments = this.segments;\n  clone.length = this.length;\n  clone.x = this.x;\n  clone.y = this.y;\n  clone.width = this.width;\n  clone.height = this.height;\n  clone.unscaledWidth = this.unscaledWidth;\n  return clone;\n};\n\n/**\r\n * Destructor: destroy\r\n *\r\n * Destroys the state and all associated resources.\r\n */\nmxCellState.prototype.destroy = function () {\n  this.view.graph.cellRenderer.destroy(this);\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxGraphSelectionModel\r\n *\r\n * Implements the selection model for a graph. Here is a listener that handles\r\n * all removed selection cells.\r\n *\r\n * (code)\r\n * graph.getSelectionModel().addListener(mxEvent.CHANGE, function(sender, evt)\r\n * {\r\n *   var cells = evt.getProperty('added');\r\n *\r\n *   for (var i = 0; i < cells.length; i++)\r\n *   {\r\n *     // Handle cells[i]...\r\n *   }\r\n * });\r\n * (end)\r\n *\r\n * Event: mxEvent.UNDO\r\n *\r\n * Fires after the selection was changed in <changeSelection>. The\r\n * <code>edit</code> property contains the <mxUndoableEdit> which contains the\r\n * <mxSelectionChange>.\r\n *\r\n * Event: mxEvent.CHANGE\r\n *\r\n * Fires after the selection changes by executing an <mxSelectionChange>. The\r\n * <code>added</code> and <code>removed</code> properties contain arrays of\r\n * cells that have been added to or removed from the selection, respectively.\r\n * The names are inverted due to historic reasons. This cannot be changed.\r\n *\r\n * Constructor: mxGraphSelectionModel\r\n *\r\n * Constructs a new graph selection model for the given <mxGraph>.\r\n *\r\n * Parameters:\r\n *\r\n * graph - Reference to the enclosing <mxGraph>.\r\n */\nvar _default = exports[\"default\"] = mxCellState;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxCellState.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxCellStatePreview.js":
/*!*****************************************************!*\
  !*** ./src/workflow/mxClient/mxCellStatePreview.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.function.bind.js */ \"../../node_modules/core-js/modules/es.function.bind.js\");\nvar _mxPoint = _interopRequireDefault(__webpack_require__(/*! ./mxPoint.js */ \"./src/workflow/mxClient/mxPoint.js\"));\nvar _mxDictionary = _interopRequireDefault(__webpack_require__(/*! ./mxDictionary.js */ \"./src/workflow/mxClient/mxDictionary.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxCellStatePreview(graph) {\n  this.deltas = new _mxDictionary[\"default\"]();\n  this.graph = graph;\n}\n;\n\n/**\r\n * Variable: graph\r\n *\r\n * Reference to the enclosing <mxGraph>.\r\n */\nmxCellStatePreview.prototype.graph = null;\n\n/**\r\n * Variable: deltas\r\n *\r\n * Reference to the enclosing <mxGraph>.\r\n */\nmxCellStatePreview.prototype.deltas = null;\n\n/**\r\n * Variable: count\r\n *\r\n * Contains the number of entries in the map.\r\n */\nmxCellStatePreview.prototype.count = 0;\n\n/**\r\n * Function: isEmpty\r\n *\r\n * Returns true if this contains no entries.\r\n */\nmxCellStatePreview.prototype.isEmpty = function () {\n  return this.count == 0;\n};\n\n/**\r\n * Function: moveState\r\n */\nmxCellStatePreview.prototype.moveState = function (state, dx, dy, add, includeEdges) {\n  add = add != null ? add : true;\n  includeEdges = includeEdges != null ? includeEdges : true;\n  var delta = this.deltas.get(state.cell);\n  if (delta == null) {\n    // Note: Deltas stores the point and the state since the key is a string.\n    delta = {\n      point: new _mxPoint[\"default\"](dx, dy),\n      state: state\n    };\n    this.deltas.put(state.cell, delta);\n    this.count++;\n  } else if (add) {\n    delta.point.x += dx;\n    delta.point.y += dy;\n  } else {\n    delta.point.x = dx;\n    delta.point.y = dy;\n  }\n  if (includeEdges) {\n    this.addEdges(state);\n  }\n  return delta.point;\n};\n\n/**\r\n * Function: show\r\n */\nmxCellStatePreview.prototype.show = function (visitor) {\n  this.deltas.visit(_mxGraphUtils[\"default\"].bind(this, function (key, delta) {\n    this.translateState(delta.state, delta.point.x, delta.point.y);\n  }));\n  this.deltas.visit(_mxGraphUtils[\"default\"].bind(this, function (key, delta) {\n    this.revalidateState(delta.state, delta.point.x, delta.point.y, visitor);\n  }));\n};\n\n/**\r\n * Function: translateState\r\n */\nmxCellStatePreview.prototype.translateState = function (state, dx, dy) {\n  if (state != null) {\n    var model = this.graph.getModel();\n    if (model.isVertex(state.cell)) {\n      state.view.updateCellState(state);\n      var geo = model.getGeometry(state.cell);\n\n      // Moves selection cells and non-relative vertices in\n      // the first phase so that edge terminal points will\n      // be updated in the second phase\n      if ((dx != 0 || dy != 0) && geo != null && (!geo.relative || this.deltas.get(state.cell) != null)) {\n        state.x += dx;\n        state.y += dy;\n      }\n    }\n    var childCount = model.getChildCount(state.cell);\n    for (var i = 0; i < childCount; i++) {\n      this.translateState(state.view.getState(model.getChildAt(state.cell, i)), dx, dy);\n    }\n  }\n};\n\n/**\r\n * Function: revalidateState\r\n */\nmxCellStatePreview.prototype.revalidateState = function (state, dx, dy, visitor) {\n  if (state != null) {\n    var model = this.graph.getModel();\n\n    // Updates the edge terminal points and restores the\n    // (relative) positions of any (relative) children\n    if (model.isEdge(state.cell)) {\n      state.view.updateCellState(state);\n    }\n    var geo = this.graph.getCellGeometry(state.cell);\n    var pState = state.view.getState(model.getParent(state.cell));\n\n    // Moves selection vertices which are relative\n    if ((dx != 0 || dy != 0) && geo != null && geo.relative && model.isVertex(state.cell) && (pState == null || model.isVertex(pState.cell) || this.deltas.get(state.cell) != null)) {\n      state.x += dx;\n      state.y += dy;\n    }\n    this.graph.cellRenderer.redraw(state);\n\n    // Invokes the visitor on the given state\n    if (visitor != null) {\n      visitor(state);\n    }\n    var childCount = model.getChildCount(state.cell);\n    for (var i = 0; i < childCount; i++) {\n      this.revalidateState(this.graph.view.getState(model.getChildAt(state.cell, i)), dx, dy, visitor);\n    }\n  }\n};\n\n/**\r\n * Function: addEdges\r\n */\nmxCellStatePreview.prototype.addEdges = function (state) {\n  var model = this.graph.getModel();\n  var edgeCount = model.getEdgeCount(state.cell);\n  for (var i = 0; i < edgeCount; i++) {\n    var s = state.view.getState(model.getEdgeAt(state.cell, i));\n    if (s != null) {\n      this.moveState(s, 0, 0);\n    }\n  }\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxConnectionConstraint\r\n *\r\n * Defines an object that contains the constraints about how to connect one\r\n * side of an edge to its terminal.\r\n *\r\n * Constructor: mxConnectionConstraint\r\n *\r\n * Constructs a new connection constraint for the given point and boolean\r\n * arguments.\r\n *\r\n * Parameters:\r\n *\r\n * point - Optional <mxPoint> that specifies the fixed location of the point\r\n * in relative coordinates. Default is null.\r\n * perimeter - Optional boolean that specifies if the fixed point should be\r\n * projected onto the perimeter of the terminal. Default is true.\r\n */\nvar _default = exports[\"default\"] = mxCellStatePreview;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxCellStatePreview.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxChildChange.js":
/*!************************************************!*\
  !*** ./src/workflow/mxClient/mxChildChange.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nfunction mxChildChange(model, parent, child, index) {\n  this.model = model;\n  this.parent = parent;\n  this.previous = parent;\n  this.child = child;\n  this.index = index;\n  this.previousIndex = index;\n}\n;\n\n/**\r\n * Function: execute\r\n *\r\n * Changes the parent of <child> using\r\n * <mxGraphModel.parentForCellChanged> and\r\n * removes or restores the cell's\r\n * connections.\r\n */\nmxChildChange.prototype.execute = function () {\n  var tmp = this.model.getParent(this.child);\n  var tmp2 = tmp != null ? tmp.getIndex(this.child) : 0;\n  if (this.previous == null) {\n    this.connect(this.child, false);\n  }\n  tmp = this.model.parentForCellChanged(this.child, this.previous, this.previousIndex);\n  if (this.previous != null) {\n    this.connect(this.child, true);\n  }\n  this.parent = this.previous;\n  this.previous = tmp;\n  this.index = this.previousIndex;\n  this.previousIndex = tmp2;\n};\n\n/**\r\n * Function: disconnect\r\n *\r\n * Disconnects the given cell recursively from its\r\n * terminals and stores the previous terminal in the\r\n * cell's terminals.\r\n */\nmxChildChange.prototype.connect = function (cell, isConnect) {\n  isConnect = isConnect != null ? isConnect : true;\n  var source = cell.getTerminal(true);\n  var target = cell.getTerminal(false);\n  if (source != null) {\n    if (isConnect) {\n      this.model.terminalForCellChanged(cell, source, true);\n    } else {\n      this.model.terminalForCellChanged(cell, null, true);\n    }\n  }\n  if (target != null) {\n    if (isConnect) {\n      this.model.terminalForCellChanged(cell, target, false);\n    } else {\n      this.model.terminalForCellChanged(cell, null, false);\n    }\n  }\n  cell.setTerminal(source, true);\n  cell.setTerminal(target, false);\n  var childCount = this.model.getChildCount(cell);\n  for (var i = 0; i < childCount; i++) {\n    this.connect(this.model.getChildAt(cell, i), isConnect);\n  }\n};\nmxChildChange.getName = function () {\n  return 'mxChildChange';\n};\n/**\r\n * Class: mxTerminalChange\r\n *\r\n * Action to change a terminal in a model.\r\n *\r\n * Constructor: mxTerminalChange\r\n *\r\n * Constructs a change of a terminal in the\r\n * specified model.\r\n */\nvar _default = exports[\"default\"] = mxChildChange;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxChildChange.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxCircleLayout.js":
/*!*************************************************!*\
  !*** ./src/workflow/mxClient/mxCircleLayout.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _mxGraphLayout = _interopRequireDefault(__webpack_require__(/*! ./mxGraphLayout.js */ \"./src/workflow/mxClient/mxGraphLayout.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxCircleLayout(graph, radius) {\n  _mxGraphLayout[\"default\"].call(this, graph);\n  this.radius = radius != null ? radius : 100;\n}\n;\n\n/**\r\n * Extends mxGraphLayout.\r\n */\nmxCircleLayout.prototype = new _mxGraphLayout[\"default\"]();\nmxCircleLayout.prototype.constructor = mxCircleLayout;\n\n/**\r\n * Variable: radius\r\n *\r\n * Integer specifying the size of the radius. Default is 100.\r\n */\nmxCircleLayout.prototype.radius = null;\n\n/**\r\n * Variable: moveCircle\r\n *\r\n * Boolean specifying if the circle should be moved to the top,\r\n * left corner specified by <x0> and <y0>. Default is false.\r\n */\nmxCircleLayout.prototype.moveCircle = false;\n\n/**\r\n * Variable: x0\r\n *\r\n * Integer specifying the left coordinate of the circle.\r\n * Default is 0.\r\n */\nmxCircleLayout.prototype.x0 = 0;\n\n/**\r\n * Variable: y0\r\n *\r\n * Integer specifying the top coordinate of the circle.\r\n * Default is 0.\r\n */\nmxCircleLayout.prototype.y0 = 0;\n\n/**\r\n * Variable: resetEdges\r\n *\r\n * Specifies if all edge points of traversed edges should be removed.\r\n * Default is true.\r\n */\nmxCircleLayout.prototype.resetEdges = true;\n\n/**\r\n * Variable: disableEdgeStyle\r\n *\r\n * Specifies if the STYLE_NOEDGESTYLE flag should be set on edges that are\r\n * modified by the result. Default is true.\r\n */\nmxCircleLayout.prototype.disableEdgeStyle = true;\n\n/**\r\n * Function: execute\r\n *\r\n * Implements <mxGraphLayout.execute>.\r\n */\nmxCircleLayout.prototype.execute = function (parent) {\n  var model = this.graph.getModel();\n\n  // Moves the vertices to build a circle. Makes sure the\n  // radius is large enough for the vertices to not\n  // overlap\n  model.beginUpdate();\n  try {\n    // Gets all vertices inside the parent and finds\n    // the maximum dimension of the largest vertex\n    var max = 0;\n    var top = null;\n    var left = null;\n    var vertices = [];\n    var childCount = model.getChildCount(parent);\n    for (var i = 0; i < childCount; i++) {\n      var cell = model.getChildAt(parent, i);\n      if (!this.isVertexIgnored(cell)) {\n        vertices.push(cell);\n        var bounds = this.getVertexBounds(cell);\n        if (top == null) {\n          top = bounds.y;\n        } else {\n          top = Math.min(top, bounds.y);\n        }\n        if (left == null) {\n          left = bounds.x;\n        } else {\n          left = Math.min(left, bounds.x);\n        }\n        max = Math.max(max, Math.max(bounds.width, bounds.height));\n      } else if (!this.isEdgeIgnored(cell)) {\n        // Resets the points on the traversed edge\n        if (this.resetEdges) {\n          this.graph.resetEdge(cell);\n        }\n        if (this.disableEdgeStyle) {\n          this.setEdgeStyleEnabled(cell, false);\n        }\n      }\n    }\n    var r = this.getRadius(vertices.length, max);\n\n    // Moves the circle to the specified origin\n    if (this.moveCircle) {\n      left = this.x0;\n      top = this.y0;\n    }\n    this.circle(vertices, r, left, top);\n  } finally {\n    model.endUpdate();\n  }\n};\n\n/**\r\n * Function: getRadius\r\n *\r\n * Returns the radius to be used for the given vertex count. Max is the maximum\r\n * width or height of all vertices in the layout.\r\n */\nmxCircleLayout.prototype.getRadius = function (count, max) {\n  return Math.max(count * max / Math.PI, this.radius);\n};\n\n/**\r\n * Function: circle\r\n *\r\n * Executes the circular layout for the specified array\r\n * of vertices and the given radius. This is called from\r\n * <execute>.\r\n */\nmxCircleLayout.prototype.circle = function (vertices, r, left, top) {\n  var vertexCount = vertices.length;\n  var phi = 2 * Math.PI / vertexCount;\n  for (var i = 0; i < vertexCount; i++) {\n    if (this.isVertexMovable(vertices[i])) {\n      this.setVertexLocation(vertices[i], left + r + r * Math.sin(i * phi), top + r + r * Math.cos(i * phi));\n    }\n  }\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxParallelEdgeLayout\r\n *\r\n * Extends <mxGraphLayout> for arranging parallel edges. This layout works\r\n * on edges for all pairs of vertices where there is more than one edge\r\n * connecting the latter.\r\n *\r\n * Example:\r\n *\r\n * (code)\r\n * var layout = new mxParallelEdgeLayout(graph);\r\n * layout.execute(graph.getDefaultParent());\r\n * (end)\r\n *\r\n * To run the layout for the parallel edges of a changed edge only, the\r\n * following code can be used.\r\n *\r\n * (code)\r\n * var layout = new mxParallelEdgeLayout(graph);\r\n *\r\n * graph.addListener(mxEvent.CELL_CONNECTED, function(sender, evt)\r\n * {\r\n *   var model = graph.getModel();\r\n *   var edge = evt.getProperty('edge');\r\n *   var src = model.getTerminal(edge, true);\r\n *   var trg = model.getTerminal(edge, false);\r\n *\r\n *   layout.isEdgeIgnored = function(edge2)\r\n *   {\r\n *     var src2 = model.getTerminal(edge2, true);\r\n *     var trg2 = model.getTerminal(edge2, false);\r\n *\r\n *     return !(model.isEdge(edge2) && ((src == src2 && trg == trg2) || (src == trg2 && trg == src2)));\r\n *   };\r\n *\r\n *   layout.execute(graph.getDefaultParent());\r\n * });\r\n * (end)\r\n *\r\n * Constructor: mxCompactTreeLayout\r\n *\r\n * Constructs a new fast organic layout for the specified graph.\r\n */\nvar _default = exports[\"default\"] = mxCircleLayout;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxCircleLayout.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxClient.js":
/*!*******************************************!*\
  !*** ./src/workflow/mxClient/mxClient.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.index-of.js */ \"../../node_modules/core-js/modules/es.array.index-of.js\");\n__webpack_require__(/*! core-js/modules/es.regexp.exec.js */ \"../../node_modules/core-js/modules/es.regexp.exec.js\");\n__webpack_require__(/*! core-js/modules/es.string.match.js */ \"../../node_modules/core-js/modules/es.string.match.js\");\nvar mxClient = {\n  /**\r\n   * Class: mxClient\r\n   *\r\n   * Bootstrapping mechanism for the mxGraph thin client. The production version\r\n   * of this file contains all code required to run the mxGraph thin client, as\r\n   * well as global constants to identify the browser and operating system in\r\n   * use. You may have to load chrome://global/content/contentAreaUtils.js in\r\n   * your page to disable certain security restrictions in Mozilla.\r\n   *\r\n   * Variable: VERSION\r\n   *\r\n   * Contains the current version of the mxGraph library. The strings that\r\n   * communicate versions of mxGraph use the following format.\r\n   *\r\n   * versionMajor.versionMinor.buildNumber.revisionNumber\r\n   *\r\n   * Current version is 3.6.0.0.\r\n   */\n  VERSION: '3.6.0.0',\n  /**\r\n   * Variable: IS_IE\r\n   *\r\n   * True if the current browser is Internet Explorer 10 or below. Use <mxClient.IS_IE11>\r\n   * to detect IE 11.\r\n   */\n  IS_IE: navigator.userAgent.indexOf('MSIE') >= 0,\n  /**\r\n   * Variable: IS_IE6\r\n   *\r\n   * True if the current browser is Internet Explorer 6.x.\r\n   */\n  IS_IE6: navigator.userAgent.indexOf('MSIE 6') >= 0,\n  /**\r\n   * Variable: IS_IE11\r\n   *\r\n   * True if the current browser is Internet Explorer 11.x.\r\n   */\n  IS_IE11: !!navigator.userAgent.match(/Trident\\/7\\./),\n  /**\r\n   * Variable: IS_EDGE\r\n   *\r\n   * True if the current browser is Microsoft Edge.\r\n   */\n  IS_EDGE: !!navigator.userAgent.match(/Edge\\//),\n  /**\r\n   * Variable: IS_QUIRKS\r\n   *\r\n   * True if the current browser is Internet Explorer and it is in quirks mode.\r\n   */\n  IS_QUIRKS: navigator.userAgent.indexOf('MSIE') >= 0 && (document.documentMode == null || document.documentMode == 5),\n  /**\r\n   * Variable: IS_EM\r\n   *\r\n   * True if the browser is IE11 in enterprise mode (IE8 standards mode).\r\n   */\n  IS_EM: 'spellcheck' in document.createElement('textarea') && document.documentMode == 8,\n  /**\r\n   * Variable: VML_PREFIX\r\n   *\r\n   * Prefix for VML namespace in node names. Default is 'v'.\r\n   */\n  VML_PREFIX: 'v',\n  /**\r\n   * Variable: OFFICE_PREFIX\r\n   *\r\n   * Prefix for VML office namespace in node names. Default is 'o'.\r\n   */\n  OFFICE_PREFIX: 'o',\n  /**\r\n   * Variable: IS_NS\r\n   *\r\n   * True if the current browser is Netscape (including Firefox).\r\n   */\n  IS_NS: navigator.userAgent.indexOf('Mozilla/') >= 0 && navigator.userAgent.indexOf('MSIE') < 0 && navigator.userAgent.indexOf('Edge/') < 0,\n  /**\r\n   * Variable: IS_OP\r\n   *\r\n   * True if the current browser is Opera.\r\n   */\n  IS_OP: navigator.userAgent.indexOf('Opera/') >= 0 || navigator.userAgent.indexOf('OPR/') >= 0,\n  /**\r\n   * Variable: IS_OT\r\n   *\r\n   * True if -o-transform is available as a CSS style, ie for Opera browsers\r\n   * based on a Presto engine with version 2.5 or later.\r\n   */\n  IS_OT: navigator.userAgent.indexOf('Presto/') >= 0 && navigator.userAgent.indexOf('Presto/2.4.') < 0 && navigator.userAgent.indexOf('Presto/2.3.') < 0 && navigator.userAgent.indexOf('Presto/2.2.') < 0 && navigator.userAgent.indexOf('Presto/2.1.') < 0 && navigator.userAgent.indexOf('Presto/2.0.') < 0 && navigator.userAgent.indexOf('Presto/1.') < 0,\n  /**\r\n   * Variable: IS_SF\r\n   *\r\n   * True if the current browser is Safari.\r\n   */\n  IS_SF: navigator.userAgent.indexOf('AppleWebKit/') >= 0 && navigator.userAgent.indexOf('Chrome/') < 0 && navigator.userAgent.indexOf('Edge/') < 0,\n  /**\r\n   * Variable: IS_IOS\r\n   *\r\n   * Returns true if the user agent is an iPad, iPhone or iPod.\r\n   */\n  IS_IOS: navigator.userAgent.match(/(iPad|iPhone|iPod)/g) ? true : false,\n  /**\r\n   * Variable: IS_GC\r\n   *\r\n   * True if the current browser is Google Chrome.\r\n   */\n  IS_GC: navigator.userAgent.indexOf('Chrome/') >= 0 && navigator.userAgent.indexOf('Edge/') < 0,\n  /**\r\n   * Variable: IS_CHROMEAPP\r\n   *\r\n   * True if the this is running inside a Chrome App.\r\n   */\n  IS_CHROMEAPP: window.chrome != null && chrome.app != null && chrome.app.runtime != null,\n  /**\r\n   * Variable: IS_FF\r\n   *\r\n   * True if the current browser is Firefox.\r\n   */\n  IS_FF: navigator.userAgent.indexOf('Firefox/') >= 0,\n  /**\r\n   * Variable: IS_MT\r\n   *\r\n   * True if -moz-transform is available as a CSS style. This is the case\r\n   * for all Firefox-based browsers newer than or equal 3, such as Camino,\r\n   * Iceweasel, Seamonkey and Iceape.\r\n   */\n  IS_MT: navigator.userAgent.indexOf('Firefox/') >= 0 && navigator.userAgent.indexOf('Firefox/1.') < 0 && navigator.userAgent.indexOf('Firefox/2.') < 0 || navigator.userAgent.indexOf('Iceweasel/') >= 0 && navigator.userAgent.indexOf('Iceweasel/1.') < 0 && navigator.userAgent.indexOf('Iceweasel/2.') < 0 || navigator.userAgent.indexOf('SeaMonkey/') >= 0 && navigator.userAgent.indexOf('SeaMonkey/1.') < 0 || navigator.userAgent.indexOf('Iceape/') >= 0 && navigator.userAgent.indexOf('Iceape/1.') < 0,\n  /**\r\n   * Variable: IS_SVG\r\n   *\r\n   * True if the browser supports SVG.\r\n   */\n  IS_SVG: navigator.userAgent.indexOf('Firefox/') >= 0 ||\n  // FF and Camino\n  navigator.userAgent.indexOf('Iceweasel/') >= 0 ||\n  // Firefox on Debian\n  navigator.userAgent.indexOf('Seamonkey/') >= 0 ||\n  // Firefox-based\n  navigator.userAgent.indexOf('Iceape/') >= 0 ||\n  // Seamonkey on Debian\n  navigator.userAgent.indexOf('Galeon/') >= 0 ||\n  // Gnome Browser (old)\n  navigator.userAgent.indexOf('Epiphany/') >= 0 ||\n  // Gnome Browser (new)\n  navigator.userAgent.indexOf('AppleWebKit/') >= 0 ||\n  // Safari/Google Chrome\n  navigator.userAgent.indexOf('Gecko/') >= 0 ||\n  // Netscape/Gecko\n  navigator.userAgent.indexOf('Opera/') >= 0 ||\n  // Opera\n  document.documentMode != null && document.documentMode >= 9,\n  // IE9+\n\n  /**\r\n   * Variable: NO_FO\r\n   *\r\n   * True if foreignObject support is not available. This is the case for\r\n   * Opera, older SVG-based browsers and all versions of IE.\r\n   */\n  NO_FO: !document.createElementNS || document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject') != '[object SVGForeignObjectElement]' || navigator.userAgent.indexOf('Opera/') >= 0,\n  /**\r\n   * Variable: IS_VML\r\n   *\r\n   * True if the browser supports VML.\r\n   */\n  IS_VML: navigator.appName.toUpperCase() == 'MICROSOFT INTERNET EXPLORER',\n  /**\r\n   * Variable: IS_WIN\r\n   *\r\n   * True if the client is a Windows.\r\n   */\n  IS_WIN: navigator.appVersion.indexOf('Win') > 0,\n  /**\r\n   * Variable: IS_MAC\r\n   *\r\n   * True if the client is a Mac.\r\n   */\n  IS_MAC: navigator.appVersion.indexOf('Mac') > 0,\n  /**\r\n   * Variable: IS_TOUCH\r\n   *\r\n   * True if this device supports touchstart/-move/-end events (Apple iOS,\r\n   * Android, Chromebook and Chrome Browser on touch-enabled devices).\r\n   */\n  IS_TOUCH: 'ontouchstart' in document.documentElement,\n  /**\r\n   * Variable: IS_POINTER\r\n   *\r\n   * True if this device supports Microsoft pointer events.\r\n   */\n  IS_POINTER: window.PointerEvent != null,\n  /**\r\n   * Variable: IS_LOCAL\r\n   *\r\n   * True if the documents location does not start with http:// or https://.\r\n   */\n  IS_LOCAL: document.location.href.indexOf('http://') < 0 && document.location.href.indexOf('https://') < 0,\n  /**\r\n   * Function: isBrowserSupported\r\n   *\r\n   * Returns true if the current browser is supported, that is, if\r\n   * <mxClient.IS_VML> or <mxClient.IS_SVG> is true.\r\n   *\r\n   * Example:\r\n   *\r\n   * (code)\r\n   * if (!mxClient.isBrowserSupported())\r\n   * {\r\n   *   mxUtils.error('Browser is not supported!', 200, false);\r\n   * }\r\n   * (end)\r\n   */\n  isBrowserSupported: function isBrowserSupported() {\n    return mxClient.IS_VML || mxClient.IS_SVG;\n  },\n  /**\r\n   * Function: link\r\n   *\r\n   * Adds a link node to the head of the document. Use this\r\n   * to add a stylesheet to the page as follows:\r\n   *\r\n   * (code)\r\n   * mxClient.link('stylesheet', filename);\r\n   * (end)\r\n   *\r\n   * where filename is the (relative) URL of the stylesheet. The charset\r\n   * is hardcoded to ISO-8859-1 and the type is text/css.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * rel - String that represents the rel attribute of the link node.\r\n   * href - String that represents the href attribute of the link node.\r\n   * doc - Optional parent document of the link node.\r\n   */\n  link: function link(rel, href, doc) {\n    doc = doc || document;\n\n    // Workaround for Operation Aborted in IE6 if base tag is used in head\n    if (mxClient.IS_IE6) {\n      doc.write('<link rel=\"' + rel + '\" href=\"' + href + '\" charset=\"ISO-8859-1\" type=\"text/css\"/>');\n    } else {\n      var link = doc.createElement('link');\n      link.setAttribute('rel', rel);\n      link.setAttribute('href', href);\n      link.setAttribute('charset', 'ISO-8859-1');\n      link.setAttribute('type', 'text/css');\n      var head = doc.getElementsByTagName('head')[0];\n      head.appendChild(link);\n    }\n  },\n  /**\r\n   * Function: include\r\n   *\r\n   * Dynamically adds a script node to the document header.\r\n   *\r\n   * In production environments, the includes are resolved in the mxClient.js\r\n   * file to reduce the number of requests required for client startup. This\r\n   * function should only be used in development environments, but not in\r\n   * production systems.\r\n   */\n  include: function include(src) {\n    document.write('<script src=\"' + src + '\"></script>');\n  }\n};\n\n/**\r\n * Variable: mxLoadResources\r\n *\r\n * Optional global config variable to toggle loading of the two resource files\r\n * in <mxGraph> and <mxEditor>. Default is true. NOTE: This is a global variable,\r\n * not a variable of mxClient.\r\n *\r\n * (code)\r\n * <script type=\"text/javascript\">\r\n * \t\tvar mxLoadResources = false;\r\n * </script>\r\n * <script type=\"text/javascript\" src=\"/path/to/core/directory/js/mxClient.js\"></script>\r\n * (end)\r\n */\n/*if (typeof(window.mxLoadResources) == 'undefined')\r\n{\r\n\twindow.mxLoadResources = true;\r\n}*/\n\n/**\r\n * Variable: mxResourceExtension\r\n *\r\n * Optional global config variable to specify the extension of resource files.\r\n * Default is true. NOTE: This is a global variable, not a variable of mxClient.\r\n *\r\n * (code)\r\n * <script type=\"text/javascript\">\r\n * \t\tvar mxResourceExtension = '.txt';\r\n * </script>\r\n * <script type=\"text/javascript\" src=\"/path/to/core/directory/js/mxClient.js\"></script>\r\n * (end)\r\n */\nif (typeof window.mxResourceExtension == 'undefined') {\n  window.mxResourceExtension = '.txt';\n}\n\n/**\r\n * Variable: mxLoadStylesheets\r\n *\r\n * Optional global config variable to toggle loading of the CSS files when\r\n * the library is initialized. Default is true. NOTE: This is a global variable,\r\n * not a variable of mxClient.\r\n *\r\n * (code)\r\n * <script type=\"text/javascript\">\r\n * \t\tvar mxLoadStylesheets = false;\r\n * </script>\r\n * <script type=\"text/javascript\" src=\"/path/to/core/directory/js/mxClient.js\"></script>\r\n * (end)\r\n */\n/*if (typeof(window.mxLoadStylesheets) == 'undefined')\r\n{\r\n\twindow.mxLoadStylesheets = true;\r\n}*/\n\n/**\r\n * Variable: basePath\r\n *\r\n * Basepath for all URLs in the core without trailing slash. Default is '.'.\r\n * Set mxBasePath prior to loading the mxClient library as follows to override\r\n * this setting:\r\n *\r\n * (code)\r\n * <script type=\"text/javascript\">\r\n * \t\tmxBasePath = '/path/to/core/directory';\r\n * </script>\r\n * <script type=\"text/javascript\" src=\"/path/to/core/directory/js/mxClient.js\"></script>\r\n * (end)\r\n *\r\n * When using a relative path, the path is relative to the URL of the page that\r\n * contains the assignment. Trailing slashes are automatically removed.\r\n */\nvar mxBasePath = window.mxBasePath;\nif (typeof mxBasePath != 'undefined' && mxBasePath.length > 0) {\n  // Adds a trailing slash if required\n  if (mxBasePath.substring(mxBasePath.length - 1) == '/') {\n    mxBasePath = mxBasePath.substring(0, mxBasePath.length - 1);\n  }\n  mxClient.basePath = mxBasePath;\n} else {\n  mxClient.basePath = '.';\n}\n\n/**\r\n * Variable: imageBasePath\r\n *\r\n * Basepath for all images URLs in the core without trailing slash. Default is\r\n * <mxClient.basePath> + '/images'. Set mxImageBasePath prior to loading the\r\n * mxClient library as follows to override this setting:\r\n *\r\n * (code)\r\n * <script type=\"text/javascript\">\r\n * \t\tmxImageBasePath = '/path/to/image/directory';\r\n * </script>\r\n * <script type=\"text/javascript\" src=\"/path/to/core/directory/js/mxClient.js\"></script>\r\n * (end)\r\n *\r\n * When using a relative path, the path is relative to the URL of the page that\r\n * contains the assignment. Trailing slashes are automatically removed.\r\n */\nvar mxImageBasePath = window.mxImageBasePath;\nif (typeof mxImageBasePath != 'undefined' && mxImageBasePath.length > 0) {\n  // Adds a trailing slash if required\n  if (mxImageBasePath.substring(mxImageBasePath.length - 1) == '/') {\n    mxImageBasePath = mxImageBasePath.substring(0, mxImageBasePath.length - 1);\n  }\n  mxClient.imageBasePath = mxImageBasePath;\n} else {\n  mxClient.imageBasePath = mxClient.basePath + '/images';\n}\n\n/**\r\n * Variable: language\r\n *\r\n * Defines the language of the client, eg. en for english, de for german etc.\r\n * The special value 'none' will disable all built-in internationalization and\r\n * resource loading. See <mxResources.getSpecialBundle> for handling identifiers\r\n * with and without a dash.\r\n *\r\n * Set mxLanguage prior to loading the mxClient library as follows to override\r\n * this setting:\r\n *\r\n * (code)\r\n * <script type=\"text/javascript\">\r\n * \t\tmxLanguage = 'en';\r\n * </script>\r\n * <script type=\"text/javascript\" src=\"js/mxClient.js\"></script>\r\n * (end)\r\n *\r\n * If internationalization is disabled, then the following variables should be\r\n * overridden to reflect the current language of the system. These variables are\r\n * cleared when i18n is disabled.\r\n * <mxEditor.askZoomResource>, <mxEditor.lastSavedResource>,\r\n * <mxEditor.currentFileResource>, <mxEditor.propertiesResource>,\r\n * <mxEditor.tasksResource>, <mxEditor.helpResource>, <mxEditor.outlineResource>,\r\n * <mxElbowEdgeHandler.doubleClickOrientationResource>, <mxUtils.errorResource>,\r\n * <mxUtils.closeResource>, <mxGraphSelectionModel.doneResource>,\r\n * <mxGraphSelectionModel.updatingSelectionResource>, <mxGraphView.doneResource>,\r\n * <mxGraphView.updatingDocumentResource>, <mxCellRenderer.collapseExpandResource>,\r\n * <mxGraph.containsValidationErrorsResource> and\r\n * <mxGraph.alreadyConnectedResource>.\r\n */\nvar mxLanguage = window.mxLanguage;\nif (typeof mxLanguage != 'undefined' && mxLanguage != null) {\n  mxClient.language = mxLanguage;\n} else {\n  mxClient.language = mxClient.IS_IE ? navigator.userLanguage : navigator.language;\n}\n\n/**\r\n * Variable: defaultLanguage\r\n *\r\n * Defines the default language which is used in the common resource files. Any\r\n * resources for this language will only load the common resource file, but not\r\n * the language-specific resource file. Default is 'en'.\r\n *\r\n * Set mxDefaultLanguage prior to loading the mxClient library as follows to override\r\n * this setting:\r\n *\r\n * (code)\r\n * <script type=\"text/javascript\">\r\n * \t\tmxDefaultLanguage = 'de';\r\n * </script>\r\n * <script type=\"text/javascript\" src=\"js/mxClient.js\"></script>\r\n * (end)\r\n */\nvar mxDefaultLanguage = window.mxDefaultLanguage;\nif (typeof mxDefaultLanguage != 'undefined' && mxDefaultLanguage != null) {\n  mxClient.defaultLanguage = mxDefaultLanguage;\n} else {\n  mxClient.defaultLanguage = 'en';\n}\n\n// Adds all required stylesheets and namespaces\n/*if (window.mxLoadStylesheets)\r\n{\r\n\tmxClient.link('stylesheet', mxClient.basePath + '/styles/common.css');\r\n}*/\n\n/**\r\n * Variable: languages\r\n *\r\n * Defines the optional array of all supported language extensions. The default\r\n * language does not have to be part of this list. See\r\n * <mxResources.isLanguageSupported>.\r\n *\r\n * (code)\r\n * <script type=\"text/javascript\">\r\n * \t\tmxLanguages = ['de', 'it', 'fr'];\r\n * </script>\r\n * <script type=\"text/javascript\" src=\"js/mxClient.js\"></script>\r\n * (end)\r\n *\r\n * This is used to avoid unnecessary requests to language files, ie. if a 404\r\n * will be returned.\r\n */\nvar mxLanguages = window.mxLanguages;\nif (typeof mxLanguages != 'undefined' && mxLanguages != null) {\n  mxClient.languages = mxLanguages;\n}\n\n// Adds required namespaces, stylesheets and memory handling for older IE browsers\nif (mxClient.IS_VML) {\n  if (mxClient.IS_SVG) {\n    mxClient.IS_VML = false;\n  } else {\n    // Enables support for IE8 standards mode. Note that this requires all attributes for VML\n    // elements to be set using direct notation, ie. node.attr = value. The use of setAttribute\n    // is not possible.\n    if (document.documentMode == 8) {\n      document.namespaces.add(mxClient.VML_PREFIX, 'urn:schemas-microsoft-com:vml', '#default#VML');\n      document.namespaces.add(mxClient.OFFICE_PREFIX, 'urn:schemas-microsoft-com:office:office', '#default#VML');\n    } else {\n      document.namespaces.add(mxClient.VML_PREFIX, 'urn:schemas-microsoft-com:vml');\n      document.namespaces.add(mxClient.OFFICE_PREFIX, 'urn:schemas-microsoft-com:office:office');\n    }\n\n    // Workaround for limited number of stylesheets in IE (does not work in standards mode)\n    if (mxClient.IS_QUIRKS && document.styleSheets.length >= 30) {\n      (function () {\n        var node = document.createElement('style');\n        node.type = 'text/css';\n        node.styleSheet.cssText = mxClient.VML_PREFIX + '\\\\:*{behavior:url(#default#VML)}' + mxClient.OFFICE_PREFIX + '\\\\:*{behavior:url(#default#VML)}';\n        document.getElementsByTagName('head')[0].appendChild(node);\n      })();\n    } else {\n      document.createStyleSheet().cssText = mxClient.VML_PREFIX + '\\\\:*{behavior:url(#default#VML)}' + mxClient.OFFICE_PREFIX + '\\\\:*{behavior:url(#default#VML)}';\n    }\n\n    /*if (window.mxLoadStylesheets)\r\n    {\r\n    \tmxClient.link('stylesheet', mxClient.basePath + '/css/explorer.css');\r\n    }*/\n\n    // Cleans up resources when the application terminates\n    window.attachEvent('onunload', mxClient.dispose);\n  }\n}\n\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\nvar _default = exports[\"default\"] = mxClient;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxClient.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxClipboard.js":
/*!**********************************************!*\
  !*** ./src/workflow/mxClient/mxClipboard.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _mxEventObject = _interopRequireDefault(__webpack_require__(/*! ./mxEventObject.js */ \"./src/workflow/mxClient/mxEventObject.js\"));\nvar _mxEvent = _interopRequireDefault(__webpack_require__(/*! ./mxEvent.js */ \"./src/workflow/mxClient/mxEvent.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nvar mxClipboard = {\n  /**\r\n   * Class: mxClipboard\r\n   *\r\n   * Singleton that implements a clipboard for graph cells.\r\n   *\r\n   * Example:\r\n   *\r\n   * (code)\r\n   * mxClipboard.copy(graph);\r\n   * mxClipboard.paste(graph2);\r\n   * (end)\r\n   *\r\n   * This copies the selection cells from the graph to the clipboard and\r\n   * pastes them into graph2.\r\n   *\r\n   * For fine-grained control of the clipboard data the <mxGraph.canExportCell>\r\n   * and <mxGraph.canImportCell> functions can be overridden.\r\n   *\r\n   * To restore previous parents for pasted cells, the implementation for\r\n   * <copy> and <paste> can be changed as follows.\r\n   *\r\n   * (code)\r\n   * mxClipboard.copy = function(graph, cells)\r\n   * {\r\n   *   cells = cells || graph.getSelectionCells();\r\n   *   var result = graph.getExportableCells(cells);\r\n   *\r\n   *   mxClipboard.parents = new Object();\r\n   *\r\n   *   for (var i = 0; i < result.length; i++)\r\n   *   {\r\n   *     mxClipboard.parents[i] = graph.model.getParent(cells[i]);\r\n   *   }\r\n   *\r\n   *   mxClipboard.insertCount = 1;\r\n   *   mxClipboard.setCells(graph.cloneCells(result));\r\n   *\r\n   *   return result;\r\n   * };\r\n   *\r\n   * mxClipboard.paste = function(graph)\r\n   * {\r\n   *   if (!mxClipboard.isEmpty())\r\n   *   {\r\n   *     var cells = graph.getImportableCells(mxClipboard.getCells());\r\n   *     var delta = mxClipboard.insertCount * mxClipboard.STEPSIZE;\r\n   *     var parent = graph.getDefaultParent();\r\n   *\r\n   *     graph.model.beginUpdate();\r\n   *     try\r\n   *     {\r\n   *       for (var i = 0; i < cells.length; i++)\r\n   *       {\r\n   *         var tmp = (mxClipboard.parents != null && graph.model.contains(mxClipboard.parents[i])) ?\r\n   *              mxClipboard.parents[i] : parent;\r\n   *         cells[i] = graph.importCells([cells[i]], delta, delta, tmp)[0];\r\n   *       }\r\n   *     }\r\n   *     finally\r\n   *     {\r\n   *       graph.model.endUpdate();\r\n   *     }\r\n   *\r\n   *     // Increments the counter and selects the inserted cells\r\n   *     mxClipboard.insertCount++;\r\n   *     graph.setSelectionCells(cells);\r\n   *   }\r\n   * };\r\n   * (end)\r\n   *\r\n   * Variable: STEPSIZE\r\n   *\r\n   * Defines the step size to offset the cells after each paste operation.\r\n   * Default is 10.\r\n   */\n  STEPSIZE: 10,\n  /**\r\n   * Variable: insertCount\r\n   *\r\n   * Counts the number of times the clipboard data has been inserted.\r\n   */\n  insertCount: 1,\n  /**\r\n   * Variable: cells\r\n   *\r\n   * Holds the array of <mxCells> currently in the clipboard.\r\n   */\n  cells: null,\n  /**\r\n   * Function: setCells\r\n   *\r\n   * Sets the cells in the clipboard. Fires a <mxEvent.CHANGE> event.\r\n   */\n  setCells: function setCells(cells) {\n    mxClipboard.cells = cells;\n  },\n  /**\r\n   * Function: getCells\r\n   *\r\n   * Returns  the cells in the clipboard.\r\n   */\n  getCells: function getCells() {\n    return mxClipboard.cells;\n  },\n  /**\r\n   * Function: isEmpty\r\n   *\r\n   * Returns true if the clipboard currently has not data stored.\r\n   */\n  isEmpty: function isEmpty() {\n    return mxClipboard.getCells() == null;\n  },\n  /**\r\n   * Function: cut\r\n   *\r\n   * Cuts the given array of <mxCells> from the specified graph.\r\n   * If cells is null then the selection cells of the graph will\r\n   * be used. Returns the cells that have been cut from the graph.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * graph - <mxGraph> that contains the cells to be cut.\r\n   * cells - Optional array of <mxCells> to be cut.\r\n   */\n  cut: function cut(graph, cells) {\n    cells = mxClipboard.copy(graph, cells);\n    mxClipboard.insertCount = 0;\n    mxClipboard.removeCells(graph, cells);\n    return cells;\n  },\n  /**\r\n   * Function: removeCells\r\n   *\r\n   * Hook to remove the given cells from the given graph after\r\n   * a cut operation.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * graph - <mxGraph> that contains the cells to be cut.\r\n   * cells - Array of <mxCells> to be cut.\r\n   */\n  removeCells: function removeCells(graph, cells) {\n    graph.removeCells(cells);\n  },\n  /**\r\n   * Function: copy\r\n   *\r\n   * Copies the given array of <mxCells> from the specified\r\n   * graph to <cells>. Returns the original array of cells that has\r\n   * been cloned. Descendants of cells in the array are ignored.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * graph - <mxGraph> that contains the cells to be copied.\r\n   * cells - Optional array of <mxCells> to be copied.\r\n   */\n  copy: function copy(graph, cells) {\n    cells = cells || graph.getSelectionCells();\n    var result = graph.getExportableCells(graph.model.getTopmostCells(cells));\n    mxClipboard.insertCount = 1;\n    mxClipboard.setCells(graph.cloneCells(result));\n    return result;\n  },\n  /**\r\n   * Function: paste\r\n   *\r\n   * Pastes the <cells> into the specified graph restoring\r\n   * the relation to <parents>, if possible. If the parents\r\n   * are no longer in the graph or invisible then the\r\n   * cells are added to the graph's default or into the\r\n   * swimlane under the cell's new location if one exists.\r\n   * The cells are added to the graph using <mxGraph.importCells>\r\n   * and returned.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * graph - <mxGraph> to paste the <cells> into.\r\n   */\n  paste: function paste(graph) {\n    var cells = null;\n    var getTranslateValue = function getTranslateValue(cells) {\n      var ret = {};\n      var children = graph.getModel().getBPMNRoot().children;\n      var regionBounds = graph.getBoundingBoxFromGeometry(cells, true);\n      if (!children || !children.length) {\n        return {\n          x: 0 - regionBounds.x,\n          y: 0 - regionBounds.y\n        };\n      }\n      var graphBounds = graph.getBoundingBoxFromGeometry(children, true);\n      var graphCenter = {\n        x: graphBounds.x + graphBounds.width / 2,\n        y: graphBounds.y + graphBounds.height / 2\n      };\n      ret = {\n        x: 0 - regionBounds.x + graphCenter.x - regionBounds.width / 2,\n        y: 0 - regionBounds.y + graphCenter.y - regionBounds.height / 2\n      };\n      return ret;\n    };\n    if (!mxClipboard.isEmpty()) {\n      cells = graph.getImportableCells(mxClipboard.getCells());\n      var delta = mxClipboard.insertCount * mxClipboard.STEPSIZE;\n      var deltaX = delta;\n      var deltaY = delta;\n      if (cells.length && graph.pageId != cells[0].getOriginPageId()) {\n        //跨设计器复制，复制后的内容居中\n        var trans = getTranslateValue(cells);\n        if (trans.x && trans.y) {\n          deltaX += trans.x;\n          deltaY += trans.y;\n        }\n      }\n      var parent = graph.getDefaultParent();\n      cells = graph.importCells(cells, deltaX, deltaY, parent);\n      graph.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].PASTE_CELLS, 'cells', cells));\n\n      // Increments the counter and selects the inserted cells\n      mxClipboard.insertCount++;\n      graph.setSelectionCells(cells);\n    }\n    return cells;\n  }\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxWindow\r\n *\r\n * Basic window inside a document.\r\n *\r\n * Examples:\r\n *\r\n * Creating a simple window.\r\n *\r\n * (code)\r\n * var tb = document.createElement('div');\r\n * var wnd = new mxWindow('Title', tb, 100, 100, 200, 200, true, true);\r\n * wnd.setVisible(true);\r\n * (end)\r\n *\r\n * Creating a window that contains an iframe.\r\n *\r\n * (code)\r\n * var frame = document.createElement('iframe');\r\n * frame.setAttribute('width', '192px');\r\n * frame.setAttribute('height', '172px');\r\n * frame.setAttribute('src', 'http://www.example.com/');\r\n * frame.style.backgroundColor = 'white';\r\n *\r\n * var w = document.body.clientWidth;\r\n * var h = (document.body.clientHeight || document.documentElement.clientHeight);\r\n * var wnd = new mxWindow('Title', frame, (w-200)/2, (h-200)/3, 200, 200);\r\n * wnd.setVisible(true);\r\n * (end)\r\n *\r\n * To limit the movement of a window, eg. to keep it from being moved beyond\r\n * the top, left corner the following method can be overridden (recommended):\r\n *\r\n * (code)\r\n * wnd.setLocation = function(x, y)\r\n * {\r\n *   x = Math.max(0, x);\r\n *   y = Math.max(0, y);\r\n *   mxWindow.prototype.setLocation.apply(this, arguments);\r\n * };\r\n * (end)\r\n *\r\n * Or the following event handler can be used:\r\n *\r\n * (code)\r\n * wnd.addListener(mxEvent.MOVE, function(e)\r\n * {\r\n *   wnd.setLocation(Math.max(0, wnd.getX()), Math.max(0, wnd.getY()));\r\n * });\r\n * (end)\r\n *\r\n * To keep a window inside the current window:\r\n *\r\n * (code)\r\n * mxEvent.addListener(window, 'resize', mxGraphUtils.bind(this, function()\r\n * {\r\n *   var iw = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;\r\n *   var ih = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;\r\n *\r\n *   var x = this.window.getX();\r\n *   var y = this.window.getY();\r\n *\r\n *   if (x + this.window.table.clientWidth > iw)\r\n *   {\r\n *     x = Math.max(0, iw - this.window.table.clientWidth);\r\n *   }\r\n *\r\n *   if (y + this.window.table.clientHeight > ih)\r\n *   {\r\n *     y = Math.max(0, ih - this.window.table.clientHeight);\r\n *   }\r\n *\r\n *   if (this.window.getX() != x || this.window.getY() != y)\r\n *   {\r\n *     this.window.setLocation(x, y);\r\n *   }\r\n * }));\r\n * (end)\r\n *\r\n * Event: mxEvent.MOVE_START\r\n *\r\n * Fires before the window is moved. The <code>event</code> property contains\r\n * the corresponding mouse event.\r\n *\r\n * Event: mxEvent.MOVE\r\n *\r\n * Fires while the window is being moved. The <code>event</code> property\r\n * contains the corresponding mouse event.\r\n *\r\n * Event: mxEvent.MOVE_END\r\n *\r\n * Fires after the window is moved. The <code>event</code> property contains\r\n * the corresponding mouse event.\r\n *\r\n * Event: mxEvent.RESIZE_START\r\n *\r\n * Fires before the window is resized. The <code>event</code> property contains\r\n * the corresponding mouse event.\r\n *\r\n * Event: mxEvent.RESIZE\r\n *\r\n * Fires while the window is being resized. The <code>event</code> property\r\n * contains the corresponding mouse event.\r\n *\r\n * Event: mxEvent.RESIZE_END\r\n *\r\n * Fires after the window is resized. The <code>event</code> property contains\r\n * the corresponding mouse event.\r\n *\r\n * Event: mxEvent.MAXIMIZE\r\n *\r\n * Fires after the window is maximized. The <code>event</code> property\r\n * contains the corresponding mouse event.\r\n *\r\n * Event: mxEvent.MINIMIZE\r\n *\r\n * Fires after the window is minimized. The <code>event</code> property\r\n * contains the corresponding mouse event.\r\n *\r\n * Event: mxEvent.NORMALIZE\r\n *\r\n * Fires after the window is normalized, that is, it returned from\r\n * maximized or minimized state. The <code>event</code> property contains the\r\n * corresponding mouse event.\r\n *\r\n * Event: mxEvent.ACTIVATE\r\n *\r\n * Fires after a window is activated. The <code>previousWindow</code> property\r\n * contains the previous window. The event sender is the active window.\r\n *\r\n * Event: mxEvent.SHOW\r\n *\r\n * Fires after the window is shown. This event has no properties.\r\n *\r\n * Event: mxEvent.HIDE\r\n *\r\n * Fires after the window is hidden. This event has no properties.\r\n *\r\n * Event: mxEvent.CLOSE\r\n *\r\n * Fires before the window is closed. The <code>event</code> property contains\r\n * the corresponding mouse event.\r\n *\r\n * Event: mxEvent.DESTROY\r\n *\r\n * Fires before the window is destroyed. This event has no properties.\r\n *\r\n * Constructor: mxWindow\r\n *\r\n * Constructs a new window with the given dimension and title to display\r\n * the specified content. The window elements use the given style as a\r\n * prefix for the classnames of the respective window elements, namely,\r\n * the window title and window pane. The respective postfixes are appended\r\n * to the given stylename as follows:\r\n *\r\n *   style - Base style for the window.\r\n *   style+Title - Style for the window title.\r\n *   style+Pane - Style for the window pane.\r\n *\r\n * The default value for style is mxWindow, resulting in the following\r\n * classnames for the window elements: mxWindow, mxWindowTitle and\r\n * mxWindowPane.\r\n *\r\n * If replaceNode is given then the window replaces the given DOM node in\r\n * the document.\r\n *\r\n * Parameters:\r\n *\r\n * title - String that represents the title of the new window.\r\n * content - DOM node that is used as the window content.\r\n * x - X-coordinate of the window location.\r\n * y - Y-coordinate of the window location.\r\n * width - Width of the window.\r\n * height - Optional height of the window. Default is to match the height\r\n * of the content at the specified width.\r\n * minimizable - Optional boolean indicating if the window is minimizable.\r\n * Default is true.\r\n * movable - Optional boolean indicating if the window is movable. Default\r\n * is true.\r\n * replaceNode - Optional DOM node that the window should replace.\r\n * style - Optional base classname for the window elements. Default is\r\n * mxWindow.\r\n */\nvar _default = exports[\"default\"] = mxClipboard;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxClipboard.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxCloud.js":
/*!******************************************!*\
  !*** ./src/workflow/mxClient/mxCloud.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.fill.js */ \"../../node_modules/core-js/modules/es.array.fill.js\");\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxActor = _interopRequireDefault(__webpack_require__(/*! ./mxActor.js */ \"./src/workflow/mxClient/mxActor.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxCloud(bounds, fill, stroke, strokewidth) {\n  _mxActor[\"default\"].call(this);\n  this.bounds = bounds;\n  this.fill = fill;\n  this.stroke = stroke;\n  this.strokewidth = strokewidth != null ? strokewidth : 1;\n}\n;\n\n/**\r\n * Extends mxActor.\r\n */\n_mxGraphUtils[\"default\"].extend(mxCloud, _mxActor[\"default\"]);\n\n/**\r\n * Function: redrawPath\r\n *\r\n * Draws the path for this shape.\r\n */\nmxCloud.prototype.redrawPath = function (c, x, y, w, h) {\n  c.moveTo(0.25 * w, 0.25 * h);\n  c.curveTo(0.05 * w, 0.25 * h, 0, 0.5 * h, 0.16 * w, 0.55 * h);\n  c.curveTo(0, 0.66 * h, 0.18 * w, 0.9 * h, 0.31 * w, 0.8 * h);\n  c.curveTo(0.4 * w, h, 0.7 * w, h, 0.8 * w, 0.8 * h);\n  c.curveTo(w, 0.8 * h, w, 0.6 * h, 0.875 * w, 0.5 * h);\n  c.curveTo(w, 0.3 * h, 0.8 * w, 0.1 * h, 0.625 * w, 0.2 * h);\n  c.curveTo(0.5 * w, 0.05 * h, 0.3 * w, 0.05 * h, 0.25 * w, 0.25 * h);\n  c.close();\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxRectangleShape\r\n *\r\n * Extends <mxShape> to implement a rectangle shape.\r\n * This shape is registered under <mxConstants.SHAPE_RECTANGLE>\r\n * in <mxCellRenderer>.\r\n *\r\n * Constructor: mxRectangleShape\r\n *\r\n * Constructs a new rectangle shape.\r\n *\r\n * Parameters:\r\n *\r\n * bounds - <mxRectangle> that defines the bounds. This is stored in\r\n * <mxShape.bounds>.\r\n * fill - String that defines the fill color. This is stored in <fill>.\r\n * stroke - String that defines the stroke color. This is stored in <stroke>.\r\n * strokewidth - Optional integer that defines the stroke width. Default is\r\n * 1. This is stored in <strokewidth>.\r\n */\nvar _default = exports[\"default\"] = mxCloud;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxCloud.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxCodec.js":
/*!******************************************!*\
  !*** ./src/workflow/mxClient/mxCodec.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxCodecRegistry = _interopRequireDefault(__webpack_require__(/*! ./mxCodecRegistry.js */ \"./src/workflow/mxClient/mxCodecRegistry.js\"));\nvar _mxCellPath = _interopRequireDefault(__webpack_require__(/*! ./mxCellPath.js */ \"./src/workflow/mxClient/mxCellPath.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ./mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nvar _mxCell = _interopRequireDefault(__webpack_require__(/*! ./mxCell.js */ \"./src/workflow/mxClient/mxCell.js\"));\nvar _mxLog = _interopRequireDefault(__webpack_require__(/*! ./mxLog.js */ \"./src/workflow/mxClient/mxLog.js\"));\nvar _mxCodecRegistryHelper = __webpack_require__(/*! ../mxClient/mxCodecRegistryHelper */ \"./src/workflow/mxClient/mxCodecRegistryHelper.js\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxCodec\r\n *\r\n * XML codec for JavaScript object graphs. See <mxObjectCodec> for a\r\n * description of the general encoding/decoding scheme. This class uses the\r\n * codecs registered in <mxCodecRegistry> for encoding/decoding each object.\r\n *\r\n * References:\r\n *\r\n * In order to resolve references, especially forward references, the mxCodec\r\n * constructor must be given the document that contains the referenced\r\n * elements.\r\n *\r\n * Examples:\r\n *\r\n * The following code is used to encode a graph model.\r\n *\r\n * (code)\r\n * var encoder = new mxCodec();\r\n * var result = encoder.encode(graph.getModel());\r\n * var xml = mxUtils.getXml(result);\r\n * (end)\r\n *\r\n * Example:\r\n *\r\n * Using the code below, an XML document is decoded into an existing model. The\r\n * document may be obtained using one of the functions in mxUtils for loading\r\n * an XML file, eg. <mxRequestUtils.get>, or using <mxUtils.parseXml> for parsing an\r\n * XML string.\r\n *\r\n * (code)\r\n * var doc = mxUtils.parseXml(xmlString);\r\n * var codec = new mxCodec(doc);\r\n * codec.decode(doc.documentElement, graph.getModel());\r\n * (end)\r\n *\r\n * Example:\r\n *\r\n * This example demonstrates parsing a list of isolated cells into an existing\r\n * graph model. Note that the cells do not have a parent reference so they can\r\n * be added anywhere in the cell hierarchy after parsing.\r\n *\r\n * (code)\r\n * var xml = '<root><mxCell id=\"2\" value=\"Hello,\" vertex=\"1\"><mxGeometry x=\"20\" y=\"20\" width=\"80\" height=\"30\" as=\"geometry\"/></mxCell><mxCell id=\"3\" value=\"World!\" vertex=\"1\"><mxGeometry x=\"200\" y=\"150\" width=\"80\" height=\"30\" as=\"geometry\"/></mxCell><mxCell id=\"4\" value=\"\" edge=\"1\" source=\"2\" target=\"3\"><mxGeometry relative=\"1\" as=\"geometry\"/></mxCell></root>';\r\n * var doc = mxUtils.parseXml(xml);\r\n * var codec = new mxCodec(doc);\r\n * var elt = doc.documentElement.firstChild;\r\n * var cells = [];\r\n *\r\n * while (elt != null)\r\n * {\r\n *   cells.push(codec.decode(elt));\r\n *   elt = elt.nextSibling;\r\n * }\r\n *\r\n * graph.addCells(cells);\r\n * (end)\r\n *\r\n * Example:\r\n *\r\n * Using the following code, the selection cells of a graph are encoded and the\r\n * output is displayed in a dialog box.\r\n *\r\n * (code)\r\n * var enc = new mxCodec();\r\n * var cells = graph.getSelectionCells();\r\n * mxUtils.alert(mxUtils.getPrettyXml(enc.encode(cells)));\r\n * (end)\r\n *\r\n * Newlines in the XML can be converted to <br>, in which case a '<br>' argument\r\n * must be passed to <mxUtils.getXml> as the second argument.\r\n *\r\n * Debugging:\r\n *\r\n * For debugging I/O you can use the following code to get the sequence of\r\n * encoded objects:\r\n *\r\n * (code)\r\n * var oldEncode = mxCodec.prototype.encode;\r\n * mxCodec.prototype.encode = function(obj)\r\n * {\r\n *   mxLog.show();\r\n *   mxLog.debug('mxCodec.encode: obj='+mxGraphUtils.getFunctionName(obj.constructor));\r\n *\r\n *   return oldEncode.apply(this, arguments);\r\n * };\r\n * (end)\r\n *\r\n * Note that the I/O system adds object codecs for new object automatically. For\r\n * decoding those objects, the constructor should be written as follows:\r\n *\r\n * (code)\r\n\r\n * var MyObj = function(name)\r\n * {\r\n *   // ...\r\n * };\r\n * (end)\r\n *\r\n * Constructor: mxCodec\r\n *\r\n * Constructs an XML encoder/decoder for the specified\r\n * owner document.\r\n *\r\n * Parameters:\r\n *\r\n * document - Optional XML document that contains the data.\r\n * If no document is specified then a new document is created\r\n * using <mxUtils.createXmlDocument>.\r\n */\n\nfunction mxCodec(document) {\n  this.document = document || _mxGraphUtils[\"default\"].createXmlDocument();\n  this.objects = [];\n}\n;\n\n/**\r\n * Variable: document\r\n *\r\n * The owner document of the codec.\r\n */\nmxCodec.prototype.document = null;\n\n/**\r\n * Variable: objects\r\n *\r\n * Maps from IDs to objects.\r\n */\nmxCodec.prototype.objects = null;\n\n/**\r\n * Variable: elements\r\n *\r\n * Lookup table for resolving IDs to elements.\r\n */\nmxCodec.prototype.elements = null;\n\n/**\r\n * Variable: encodeDefaults\r\n *\r\n * Specifies if default values should be encoded. Default is false.\r\n */\nmxCodec.prototype.encodeDefaults = false;\n\n/**\r\n * Function: putObject\r\n *\r\n * Assoiates the given object with the given ID and returns the given object.\r\n *\r\n * Parameters\r\n *\r\n * id - ID for the object to be associated with.\r\n * obj - Object to be associated with the ID.\r\n */\nmxCodec.prototype.putObject = function (id, obj) {\n  this.objects[id] = obj;\n  return obj;\n};\n\n/**\r\n * Function: getObject\r\n *\r\n * Returns the decoded object for the element with the specified ID in\r\n * <document>. If the object is not known then <lookup> is used to find an\r\n * object. If no object is found, then the element with the respective ID\r\n * from the document is parsed using <decode>.\r\n */\nmxCodec.prototype.getObject = function (id) {\n  var obj = null;\n  if (id != null) {\n    obj = this.objects[id];\n    if (obj == null) {\n      obj = this.lookup(id);\n      if (obj == null) {\n        var node = this.getElementById(id);\n        if (node != null) {\n          obj = this.decode(node);\n        }\n      }\n    }\n  }\n  return obj;\n};\n\n/**\r\n * Function: lookup\r\n *\r\n * Hook for subclassers to implement a custom lookup mechanism for cell IDs.\r\n * This implementation always returns null.\r\n *\r\n * Example:\r\n *\r\n * (code)\r\n * var codec = new mxCodec();\r\n * codec.lookup = function(id)\r\n * {\r\n *   return model.getCell(id);\r\n * };\r\n * (end)\r\n *\r\n * Parameters:\r\n *\r\n * id - ID of the object to be returned.\r\n */\nmxCodec.prototype.lookup = function (id) {\n  return null;\n};\n\n/**\r\n * Function: getElementById\r\n *\r\n * Returns the element with the given ID from <document>.\r\n *\r\n * Parameters:\r\n *\r\n * id - String that contains the ID.\r\n */\nmxCodec.prototype.getElementById = function (id) {\n  if (this.elements == null) {\n    this.elements = new Object();\n    this.addElement(this.document.documentElement);\n  }\n  return this.elements[id];\n};\n\n/**\r\n * Function: addElement\r\n *\r\n * Adds the given element to <elements> if it has an ID.\r\n */\nmxCodec.prototype.addElement = function (node) {\n  if (node.nodeType == _mxConstants[\"default\"].NODETYPE_ELEMENT) {\n    var id = node.getAttribute('id');\n    if (id != null && this.elements[id] == null) {\n      this.elements[id] = node;\n    }\n  }\n  node = node.firstChild;\n  while (node != null) {\n    this.addElement(node);\n    node = node.nextSibling;\n  }\n};\n\n/**\r\n * Function: getId\r\n *\r\n * Returns the ID of the specified object. This implementation\r\n * calls <reference> first and if that returns null handles\r\n * the object as an <mxCell> by returning their IDs using\r\n * <mxCell.getId>. If no ID exists for the given cell, then\r\n * an on-the-fly ID is generated using <mxCellPath.create>.\r\n *\r\n * Parameters:\r\n *\r\n * obj - Object to return the ID for.\r\n */\nmxCodec.prototype.getId = function (obj) {\n  var id = null;\n  if (obj != null) {\n    id = this.reference(obj);\n    if (id == null && obj instanceof _mxCell[\"default\"]) {\n      id = obj.getId();\n      if (id == null) {\n        // Uses an on-the-fly Id\n        id = _mxCellPath[\"default\"].create(obj);\n        if (id.length == 0) {\n          id = 'root';\n        }\n      }\n    }\n  }\n  return id;\n};\n\n/**\r\n * Function: reference\r\n *\r\n * Hook for subclassers to implement a custom method\r\n * for retrieving IDs from objects. This implementation\r\n * always returns null.\r\n *\r\n * Example:\r\n *\r\n * (code)\r\n * var codec = new mxCodec();\r\n * codec.reference = function(obj)\r\n * {\r\n *   return obj.getCustomId();\r\n * };\r\n * (end)\r\n *\r\n * Parameters:\r\n *\r\n * obj - Object whose ID should be returned.\r\n */\nmxCodec.prototype.reference = function (obj) {\n  return null;\n};\n\n/**\r\n * Function: encode\r\n *\r\n * Encodes the specified object and returns the resulting\r\n * XML node.\r\n *\r\n * Parameters:\r\n *\r\n * obj - Object to be encoded.\r\n */\nmxCodec.prototype.encode = function (obj) {\n  var node = null;\n  if (obj != null && obj.constructor != null) {\n    var enc = _mxCodecRegistry[\"default\"].getCodec(obj.constructor);\n    if (enc != null) {\n      node = enc.encode(this, obj);\n    } else {\n      if (_mxGraphUtils[\"default\"].isNode(obj)) {\n        node = _mxGraphUtils[\"default\"].importNode(this.document, obj, true);\n      } else {\n        _mxLog[\"default\"].warn('mxCodec.encode: No codec for ' + _mxGraphUtils[\"default\"].getFunctionName(obj.constructor));\n      }\n    }\n  }\n  return node;\n};\n\n/**\r\n * Function: decode\r\n *\r\n * Decodes the given XML node. The optional \"into\"\r\n * argument specifies an existing object to be\r\n * used. If no object is given, then a new instance\r\n * is created using the constructor from the codec.\r\n *\r\n * The function returns the passed in object or\r\n * the new instance if no object was given.\r\n *\r\n * Parameters:\r\n *\r\n * node - XML node to be decoded.\r\n * into - Optional object to be decodec into.\r\n */\nmxCodec.prototype.decode = function (node, into) {\n  var obj = null;\n  if (node != null && node.nodeType == _mxConstants[\"default\"].NODETYPE_ELEMENT) {\n    var ctor = null;\n    var nodeName = node.nodeName;\n    try {\n      ctor = _mxCodecRegistryHelper.nodeCodecsMap[nodeName] || window[nodeName];\n    } catch (err) {\n      // ignore\n    }\n    var dec = _mxCodecRegistry[\"default\"].getCodec(ctor);\n    if (dec != null) {\n      obj = dec.decode(this, node, into);\n    } else {\n      obj = node.cloneNode(true);\n      obj.removeAttribute('as');\n    }\n  }\n  return obj;\n};\n\n/**\r\n * Function: encodeCell\r\n *\r\n * Encoding of cell hierarchies is built-into the core, but\r\n * is a higher-level function that needs to be explicitely\r\n * used by the respective object encoders (eg. <mxModelCodec>,\r\n * <mxChildChangeCodec> and <mxRootChangeCodec>). This\r\n * implementation writes the given cell and its children as a\r\n * (flat) sequence into the given node. The children are not\r\n * encoded if the optional includeChildren is false. The\r\n * function is in charge of adding the result into the\r\n * given node and has no return value.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> to be encoded.\r\n * node - Parent XML node to add the encoded cell into.\r\n * includeChildren - Optional boolean indicating if the\r\n * function should include all descendents. Default is true.\r\n */\nmxCodec.prototype.encodeCell = function (cell, node, includeChildren) {\n  node.appendChild(this.encode(cell));\n  if (cell.isContainable() !== true && (includeChildren == null || includeChildren)) {\n    var childCount = cell.getChildCount();\n    for (var i = 0; i < childCount; i++) {\n      this.encodeCell(cell.getChildAt(i), node);\n    }\n  }\n};\n\n/**\r\n * Function: isCellCodec\r\n *\r\n * Returns true if the given codec is a cell codec. This uses\r\n * <mxCellCodec.isCellCodec> to check if the codec is of the\r\n * given type.\r\n */\nmxCodec.prototype.isCellCodec = function (codec) {\n  if (codec != null && typeof codec.isCellCodec == 'function') {\n    return codec.isCellCodec();\n  }\n  return false;\n};\n\n/**\r\n * Function: decodeCell\r\n *\r\n * Decodes cells that have been encoded using inversion, ie.\r\n * where the user object is the enclosing node in the XML,\r\n * and restores the group and graph structure in the cells.\r\n * Returns a new <mxCell> instance that represents the\r\n * given node.\r\n *\r\n * Parameters:\r\n *\r\n * node - XML node that contains the cell data.\r\n * restoreStructures - Optional boolean indicating whether\r\n * the graph structure should be restored by calling insert\r\n * and insertEdge on the parent and terminals, respectively.\r\n * Default is true.\r\n */\nmxCodec.prototype.decodeCell = function (node, restoreStructures) {\n  restoreStructures = restoreStructures != null ? restoreStructures : true;\n  var cell = null;\n  if (node != null && node.nodeType == _mxConstants[\"default\"].NODETYPE_ELEMENT) {\n    // Tries to find a codec for the given node name. If that does\n    // not return a codec then the node is the user object (an XML node\n    // that contains the mxCell, aka inversion).\n    var decoder = _mxCodecRegistry[\"default\"].getCodec(node.nodeName);\n\n    // Tries to find the codec for the cell inside the user object.\n    // This assumes all node names inside the user object are either\n    // not registered or they correspond to a class for cells.\n    if (!this.isCellCodec(decoder)) {\n      var child = node.firstChild;\n      while (child != null && !this.isCellCodec(decoder)) {\n        decoder = _mxCodecRegistry[\"default\"].getCodec(child.nodeName);\n        child = child.nextSibling;\n      }\n    }\n    if (!this.isCellCodec(decoder)) {\n      decoder = _mxCodecRegistry[\"default\"].getCodec(_mxCell[\"default\"]);\n    }\n    cell = decoder.decode(this, node);\n    if (restoreStructures) {\n      this.insertIntoGraph(cell);\n    }\n  }\n  return cell;\n};\n\n/**\r\n * Function: insertIntoGraph\r\n *\r\n * Inserts the given cell into its parent and terminal cells.\r\n */\nmxCodec.prototype.insertIntoGraph = function (cell) {\n  var parent = cell.parent;\n  var source = cell.getTerminal(true);\n  var target = cell.getTerminal(false);\n\n  // Fixes possible inconsistencies during insert into graph\n  cell.setTerminal(null, false);\n  cell.setTerminal(null, true);\n  cell.parent = null;\n  if (parent != null) {\n    parent.insert(cell);\n  }\n  if (source != null) {\n    source.insertEdge(cell, true);\n  }\n  if (target != null) {\n    target.insertEdge(cell, false);\n  }\n};\n\n/**\r\n * Function: setAttribute\r\n *\r\n * Sets the attribute on the specified node to value. This is a\r\n * helper method that makes sure the attribute and value arguments\r\n * are not null.\r\n *\r\n * Parameters:\r\n *\r\n * node - XML node to set the attribute for.\r\n * attributes - Attributename to be set.\r\n * value - New value of the attribute.\r\n */\nmxCodec.prototype.setAttribute = function (node, attribute, value) {\n  if (attribute != null && value != null) {\n    node.setAttribute(attribute, value);\n  }\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxObjectCodec\r\n *\r\n * Generic codec for JavaScript objects that implements a mapping between\r\n * JavaScript objects and XML nodes that maps each field or element to an\r\n * attribute or child node, and vice versa.\r\n *\r\n * Atomic Values:\r\n *\r\n * Consider the following example.\r\n *\r\n * (code)\r\n * var obj = new Object();\r\n * obj.foo = \"Foo\";\r\n * obj.bar = \"Bar\";\r\n * (end)\r\n *\r\n * This object is encoded into an XML node using the following.\r\n *\r\n * (code)\r\n * var enc = new mxCodec();\r\n * var node = enc.encode(obj);\r\n * (end)\r\n *\r\n * The output of the encoding may be viewed using <mxLog> as follows.\r\n *\r\n * (code)\r\n * mxLog.show();\r\n * mxLog.debug(mxGraphUtils.getPrettyXml(node));\r\n * (end)\r\n *\r\n * Finally, the result of the encoding looks as follows.\r\n *\r\n * (code)\r\n * <Object foo=\"Foo\" bar=\"Bar\"/>\r\n * (end)\r\n *\r\n * In the above output, the foo and bar fields have been mapped to attributes\r\n * with the same names, and the name of the constructor was used for the\r\n * nodename.\r\n *\r\n * Booleans:\r\n *\r\n * Since booleans are numbers in JavaScript, all boolean values are encoded\r\n * into 1 for true and 0 for false. The decoder also accepts the string true\r\n * and false for boolean values.\r\n *\r\n * Objects:\r\n *\r\n * The above scheme is applied to all atomic fields, that is, to all non-object\r\n * fields of an object. For object fields, a child node is created with a\r\n * special attribute that contains the fieldname. This special attribute is\r\n * called \"as\" and hence, as is a reserved word that should not be used for a\r\n * fieldname.\r\n *\r\n * Consider the following example where foo is an object and bar is an atomic\r\n * property of foo.\r\n *\r\n * (code)\r\n * var obj = {foo: {bar: \"Bar\"}};\r\n * (end)\r\n *\r\n * This will be mapped to the following XML structure by mxObjectCodec.\r\n *\r\n * (code)\r\n * <Object>\r\n *   <Object bar=\"Bar\" as=\"foo\"/>\r\n * </Object>\r\n * (end)\r\n *\r\n * In the above output, the inner Object node contains the as-attribute that\r\n * specifies the fieldname in the enclosing object. That is, the field foo was\r\n * mapped to a child node with an as-attribute that has the value foo.\r\n *\r\n * Arrays:\r\n *\r\n * Arrays are special objects that are either associative, in which case each\r\n * key, value pair is treated like a field where the key is the fieldname, or\r\n * they are a sequence of atomic values and objects, which is mapped to a\r\n * sequence of child nodes. For object elements, the above scheme is applied\r\n * without the use of the special as-attribute for creating each child. For\r\n * atomic elements, a special add-node is created with the value stored in the\r\n * value-attribute.\r\n *\r\n * For example, the following array contains one atomic value and one object\r\n * with a field called bar. Furthermore it contains two associative entries\r\n * called bar with an atomic value, and foo with an object value.\r\n *\r\n * (code)\r\n * var obj = [\"Bar\", {bar: \"Bar\"}];\r\n * obj[\"bar\"] = \"Bar\";\r\n * obj[\"foo\"] = {bar: \"Bar\"};\r\n * (end)\r\n *\r\n * This array is represented by the following XML nodes.\r\n *\r\n * (code)\r\n * <Array bar=\"Bar\">\r\n *   <add value=\"Bar\"/>\r\n *   <Object bar=\"Bar\"/>\r\n *   <Object bar=\"Bar\" as=\"foo\"/>\r\n * </Array>\r\n * (end)\r\n *\r\n * The Array node name is the name of the constructor. The additional\r\n * as-attribute in the last child contains the key of the associative entry,\r\n * whereas the second last child is part of the array sequence and does not\r\n * have an as-attribute.\r\n *\r\n * References:\r\n *\r\n * Objects may be represented as child nodes or attributes with ID values,\r\n * which are used to lookup the object in a table within <mxCodec>. The\r\n * <isReference> function is in charge of deciding if a specific field should\r\n * be encoded as a reference or not. Its default implementation returns true if\r\n * the fieldname is in <idrefs>, an array of strings that is used to configure\r\n * the <mxObjectCodec>.\r\n *\r\n * Using this approach, the mapping does not guarantee that the referenced\r\n * object itself exists in the document. The fields that are encoded as\r\n * references must be carefully chosen to make sure all referenced objects\r\n * exist in the document, or may be resolved by some other means if necessary.\r\n *\r\n * For example, in the case of the graph model all cells are stored in a tree\r\n * whose root is referenced by the model's root field. A tree is a structure\r\n * that is well suited for an XML representation, however, the additional edges\r\n * in the graph model have a reference to a source and target cell, which are\r\n * also contained in the tree. To handle this case, the source and target cell\r\n * of an edge are treated as references, whereas the children are treated as\r\n * objects. Since all cells are contained in the tree and no edge references a\r\n * source or target outside the tree, this setup makes sure all referenced\r\n * objects are contained in the document.\r\n *\r\n * In the case of a tree structure we must further avoid infinite recursion by\r\n * ignoring the parent reference of each child. This is done by returning true\r\n * in <isExcluded>, whose default implementation uses the array of excluded\r\n * fieldnames passed to the mxObjectCodec constructor.\r\n *\r\n * References are only used for cells in mxGraph. For defining other\r\n * referencable object types, the codec must be able to work out the ID of an\r\n * object. This is done by implementing <mxCodec.reference>. For decoding a\r\n * reference, the XML node with the respective id-attribute is fetched from the\r\n * document, decoded, and stored in a lookup table for later reference. For\r\n * looking up external objects, <mxCodec.lookup> may be implemented.\r\n *\r\n * Expressions:\r\n *\r\n * For decoding JavaScript expressions, the add-node may be used with a text\r\n * content that contains the JavaScript expression. For example, the following\r\n * creates a field called foo in the enclosing object and assigns it the value\r\n * of <mxConstants.ALIGN_LEFT>.\r\n *\r\n * (code)\r\n * <Object>\r\n *   <add as=\"foo\">mxConstants.ALIGN_LEFT</add>\r\n * </Object>\r\n * (end)\r\n *\r\n * The resulting object has a field called foo with the value \"left\". Its XML\r\n * representation looks as follows.\r\n *\r\n * (code)\r\n * <Object foo=\"left\"/>\r\n * (end)\r\n *\r\n * This means the expression is evaluated at decoding time and the result of\r\n * the evaluation is stored in the respective field. Valid expressions are all\r\n * JavaScript expressions, including function definitions, which are mapped to\r\n * functions on the resulting object.\r\n *\r\n * Expressions are only evaluated if <allowEval> is true.\r\n *\r\n * Constructor: mxObjectCodec\r\n *\r\n * Constructs a new codec for the specified template object.\r\n * The variables in the optional exclude array are ignored by\r\n * the codec. Variables in the optional idrefs array are\r\n * turned into references in the XML. The optional mapping\r\n * may be used to map from variable names to XML attributes.\r\n * The argument is created as follows:\r\n *\r\n * (code)\r\n * var mapping = new Object();\r\n * mapping['variableName'] = 'attribute-name';\r\n * (end)\r\n *\r\n * Parameters:\r\n *\r\n * template - Prototypical instance of the object to be\r\n * encoded/decoded.\r\n * exclude - Optional array of fieldnames to be ignored.\r\n * idrefs - Optional array of fieldnames to be converted to/from\r\n * references.\r\n * mapping - Optional mapping from field- to attributenames.\r\n */\nvar _default = exports[\"default\"] = mxCodec;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxCodec.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxCodecRegistry.js":
/*!**************************************************!*\
  !*** ./src/workflow/mxClient/mxCodecRegistry.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.index-of.js */ \"../../node_modules/core-js/modules/es.array.index-of.js\");\nvar _mxCell = _interopRequireDefault(__webpack_require__(/*! ./mxCell.js */ \"./src/workflow/mxClient/mxCell.js\"));\nvar _mxChildChange = _interopRequireDefault(__webpack_require__(/*! ./mxChildChange.js */ \"./src/workflow/mxClient/mxChildChange.js\"));\nvar _mxRootChange = _interopRequireDefault(__webpack_require__(/*! ./mxRootChange.js */ \"./src/workflow/mxClient/mxRootChange.js\"));\nvar _mxGraphModel = _interopRequireDefault(__webpack_require__(/*! ./mxGraphModel.js */ \"./src/workflow/mxClient/mxGraphModel.js\"));\nvar _mxTerminalChange = _interopRequireDefault(__webpack_require__(/*! ./mxTerminalChange.js */ \"./src/workflow/mxClient/mxTerminalChange.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ./mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nvar _mxObjectCodec = _interopRequireDefault(__webpack_require__(/*! ./mxObjectCodec.js */ \"./src/workflow/mxClient/mxObjectCodec.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nvar mxCodecRegistry = {\n  /**\r\n   * Class: mxCodecRegistry\r\n   *\r\n   * Singleton class that acts as a global registry for codecs.\r\n   *\r\n   * Adding an <mxCodec>:\r\n   *\r\n   * 1. Define a default codec with a new instance of the\r\n   * object to be handled.\r\n   *\r\n   * (code)\r\n   * var codec = new mxObjectCodec(new mxGraphModel());\r\n   * (end)\r\n   *\r\n   * 2. Define the functions required for encoding and decoding\r\n   * objects.\r\n   *\r\n   * (code)\r\n   * codec.encode = function(enc, obj) { ... }\r\n   * codec.decode = function(dec, node, into) { ... }\r\n   * (end)\r\n   *\r\n   * 3. Register the codec in the <mxCodecRegistry>.\r\n   *\r\n   * (code)\r\n   * mxCodecRegistry.register(codec);\r\n   * (end)\r\n   *\r\n   * <mxObjectCodec.decode> may be used to either create a new\r\n   * instance of an object or to configure an existing instance,\r\n   * in which case the into argument points to the existing\r\n   * object. In this case, we say the codec \"configures\" the\r\n   * object.\r\n   *\r\n   * Variable: codecs\r\n   *\r\n   * Maps from constructor names to codecs.\r\n   */\n  codecs: [],\n  /**\r\n   * Variable: aliases\r\n   *\r\n   * Maps from classnames to codecnames.\r\n   */\n  aliases: [],\n  /**\r\n   * Function: register\r\n   *\r\n   * Registers a new codec and associates the name of the template\r\n   * constructor in the codec with the codec object.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * codec - <mxObjectCodec> to be registered.\r\n   */\n  register: function register(codec) {\n    if (codec != null) {\n      var name = codec.getName();\n      mxCodecRegistry.codecs[name] = codec;\n      var classname = _mxGraphUtils[\"default\"].getFunctionName(codec.template.constructor);\n      if (classname != name) {\n        mxCodecRegistry.addAlias(classname, name);\n      }\n    }\n    return codec;\n  },\n  /**\r\n   * Function: addAlias\r\n   *\r\n   * Adds an alias for mapping a classname to a codecname.\r\n   */\n  addAlias: function addAlias(classname, codecname) {\n    mxCodecRegistry.aliases[classname] = codecname;\n  },\n  /**\r\n   * Function: getCodec\r\n   *\r\n   * Returns a codec that handles objects that are constructed\r\n   * using the given constructor.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * ctor - JavaScript constructor function.\r\n   */\n  getCodec: function getCodec(ctor) {\n    var codec = null;\n    if (ctor != null) {\n      var name = _mxGraphUtils[\"default\"].getFunctionName(ctor);\n      var tmp = mxCodecRegistry.aliases[name];\n      if (tmp != null) {\n        name = tmp;\n      }\n      codec = mxCodecRegistry.codecs[name];\n\n      // Registers a new default codec for the given constructor\n      // if no codec has been previously defined.\n      if (codec == null) {\n        try {\n          codec = new _mxObjectCodec[\"default\"](new ctor());\n          mxCodecRegistry.register(codec);\n        } catch (e) {\n          // ignore\n        }\n      }\n    }\n    return codec;\n  }\n};\n\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\nmxCodecRegistry.register(function () {\n  /**\r\n   * Class: mxCellCodec\r\n   *\r\n   * Codec for <mxCell>s. This class is created and registered\r\n   * dynamically at load time and used implicitely via <mxCodec>\r\n   * and the <mxCodecRegistry>.\r\n   *\r\n   * Transient Fields:\r\n   *\r\n   * - children\r\n   * - edges\r\n   * - overlays\r\n   * - mxTransient\r\n   *\r\n   * Reference Fields:\r\n   *\r\n   * - parent\r\n   * - source\r\n   * - target\r\n   *\r\n   * Transient fields can be added using the following code:\r\n   *\r\n   * mxCodecRegistry.getCodec(mxCell).exclude.push('name_of_field');\r\n   *\r\n   * To subclass <mxCell>, replace the template and add an alias as\r\n   * follows.\r\n   *\r\n   * (code)\r\n   * function CustomCell(value, geometry, style)\r\n   * {\r\n   *   mxCell.apply(this, arguments);\r\n   * }\r\n   *\r\n   * mxGraphUtils.extend(CustomCell, mxCell);\r\n   *\r\n   * mxCodecRegistry.getCodec(mxCell).template = new CustomCell();\r\n   * mxCodecRegistry.addAlias('CustomCell', 'mxCell');\r\n   * (end)\r\n   */\n  var codec = new _mxObjectCodec[\"default\"](new _mxCell[\"default\"](), ['children', 'edges', 'overlays', 'mxTransient'], ['parent', 'source', 'target']);\n\n  /**\r\n   * Function: isCellCodec\r\n   *\r\n   * Returns true since this is a cell codec.\r\n   */\n  codec.isCellCodec = function () {\n    return true;\n  };\n\n  /**\r\n   * Overidden to disable conversion of value to number.\r\n   */\n  codec.isNumericAttribute = function (dec, attr, obj) {\n    return attr.nodeName !== 'value' && _mxObjectCodec[\"default\"].prototype.isNumericAttribute.apply(this, arguments);\n  };\n\n  /**\r\n   * Function: isExcluded\r\n   *\r\n   * Excludes user objects that are XML nodes.\r\n   */\n  codec.isExcluded = function (obj, attr, value, isWrite) {\n    return _mxObjectCodec[\"default\"].prototype.isExcluded.apply(this, arguments) || isWrite && attr == 'value' && value.nodeType == _mxConstants[\"default\"].NODETYPE_ELEMENT;\n  };\n\n  /**\r\n   * Function: afterEncode\r\n   *\r\n   * Encodes an <mxCell> and wraps the XML up inside the\r\n   * XML of the user object (inversion).\r\n   */\n  codec.afterEncode = function (enc, obj, node) {\n    if (obj.value != null && obj.value.nodeType == _mxConstants[\"default\"].NODETYPE_ELEMENT) {\n      // Wraps the graphical annotation up in the user object (inversion)\n      // by putting the result of the default encoding into a clone of the\n      // user object (node type 1) and returning this cloned user object.\n      var tmp = node;\n      node = _mxGraphUtils[\"default\"].importNode(enc.document, obj.value, true);\n      node.appendChild(tmp);\n\n      // Moves the id attribute to the outermost XML node, namely the\n      // node which denotes the object boundaries in the file.\n      var id = tmp.getAttribute('id');\n      node.setAttribute('id', id);\n      tmp.removeAttribute('id');\n    }\n    return node;\n  };\n\n  /**\r\n   * Function: beforeDecode\r\n   *\r\n   * Decodes an <mxCell> and uses the enclosing XML node as\r\n   * the user object for the cell (inversion).\r\n   */\n  codec.beforeDecode = function (dec, node, obj) {\n    var inner = node.cloneNode(true);\n    var classname = this.getName();\n    if (node.nodeName != classname) {\n      // Passes the inner graphical annotation node to the\n      // object codec for further processing of the cell.\n      var tmp = node.getElementsByTagName(classname)[0];\n      if (tmp != null && tmp.parentNode == node) {\n        _mxGraphUtils[\"default\"].removeWhitespace(tmp, true);\n        _mxGraphUtils[\"default\"].removeWhitespace(tmp, false);\n        tmp.parentNode.removeChild(tmp);\n        inner = tmp;\n      } else {\n        inner = null;\n      }\n\n      // Creates the user object out of the XML node\n      obj.value = node.cloneNode(true);\n      /*var id = obj.value.getAttribute('id');\r\n      \t\tif (id != null)\r\n      {\r\n      \tobj.setId(id);\r\n      \tobj.value.removeAttribute('id');\r\n      }*/\n    } else {\n      // Uses ID from XML file as ID for cell in model\n      obj.setId(node.getAttribute('id'));\n    }\n\n    // Preprocesses and removes all Id-references in order to use the\n    // correct encoder (this) for the known references to cells (all).\n    if (inner != null) {\n      for (var i = 0; i < this.idrefs.length; i++) {\n        var attr = this.idrefs[i];\n        var ref = inner.getAttribute(attr);\n        if (ref != null) {\n          inner.removeAttribute(attr);\n          var object = dec.objects[ref] || dec.lookup(ref);\n          if (object == null) {\n            // Needs to decode forward reference\n            var element = dec.getElementById(ref);\n            if (element != null) {\n              var decoder = mxCodecRegistry.codecs[element.nodeName] || this;\n              object = decoder.decode(dec, element);\n            }\n          }\n          obj[attr] = object;\n        }\n      }\n    }\n    return inner;\n  };\n\n  // Returns the codec into the registry\n  return codec;\n}());\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\nmxCodecRegistry.register(function () {\n  /**\r\n   * Class: mxModelCodec\r\n   *\r\n   * Codec for <mxGraphModel>s. This class is created and registered\r\n   * dynamically at load time and used implicitely via <mxCodec>\r\n   * and the <mxCodecRegistry>.\r\n   */\n  var codec = new _mxObjectCodec[\"default\"](new _mxGraphModel[\"default\"]());\n\n  /**\r\n   * Function: encodeObject\r\n   *\r\n   * Encodes the given <mxGraphModel> by writing a (flat) XML sequence of\r\n   * cell nodes as produced by the <mxCellCodec>. The sequence is\r\n   * wrapped-up in a node with the name root.\r\n   */\n  codec.encodeObject = function (enc, obj, node) {\n    var rootNode = enc.document.createElement('root');\n    enc.encodeCell(obj.getRoot(), rootNode);\n    node.appendChild(rootNode);\n  };\n\n  /**\r\n   * Function: decodeChild\r\n   *\r\n   * Overrides decode child to handle special child nodes.\r\n   */\n  codec.decodeChild = function (dec, child, obj) {\n    if (child.nodeName == 'root') {\n      this.decodeRoot(dec, child, obj);\n    } else {\n      _mxObjectCodec[\"default\"].prototype.decodeChild.apply(this, arguments);\n    }\n  };\n\n  /**\r\n   * Function: decodeRoot\r\n   *\r\n   * Reads the cells into the graph model. All cells\r\n   * are children of the root element in the node.\r\n   */\n  codec.decodeRoot = function (dec, root, model) {\n    var rootCell = null;\n    var tmp = root.firstChild;\n    while (tmp != null) {\n      var cell = dec.decodeCell(tmp);\n      if (cell != null && cell.getParent() == null) {\n        rootCell = cell;\n      }\n      tmp = tmp.nextSibling;\n    }\n\n    // Sets the root on the model if one has been decoded\n    if (rootCell != null) {\n      model.setRoot(rootCell);\n    }\n  };\n\n  // Returns the codec into the registry\n  return codec;\n}());\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\nmxCodecRegistry.register(function () {\n  /**\r\n   * Class: mxRootChangeCodec\r\n   *\r\n   * Codec for <mxRootChange>s. This class is created and registered\r\n   * dynamically at load time and used implicitely via <mxCodec> and\r\n   * the <mxCodecRegistry>.\r\n   *\r\n   * Transient Fields:\r\n   *\r\n   * - model\r\n   * - previous\r\n   * - root\r\n   */\n  var codec = new _mxObjectCodec[\"default\"](new _mxRootChange[\"default\"](), ['model', 'previous', 'root']);\n\n  /**\r\n   * Function: onEncode\r\n   *\r\n   * Encodes the child recursively.\r\n   */\n  codec.afterEncode = function (enc, obj, node) {\n    enc.encodeCell(obj.root, node);\n    return node;\n  };\n\n  /**\r\n   * Function: beforeDecode\r\n   *\r\n   * Decodes the optional children as cells\r\n   * using the respective decoder.\r\n   */\n  codec.beforeDecode = function (dec, node, obj) {\n    if (node.firstChild != null && node.firstChild.nodeType == _mxConstants[\"default\"].NODETYPE_ELEMENT) {\n      // Makes sure the original node isn't modified\n      node = node.cloneNode(true);\n      var tmp = node.firstChild;\n      obj.root = dec.decodeCell(tmp, false);\n      var tmp2 = tmp.nextSibling;\n      tmp.parentNode.removeChild(tmp);\n      tmp = tmp2;\n      while (tmp != null) {\n        tmp2 = tmp.nextSibling;\n        dec.decodeCell(tmp);\n        tmp.parentNode.removeChild(tmp);\n        tmp = tmp2;\n      }\n    }\n    return node;\n  };\n\n  /**\r\n   * Function: afterDecode\r\n   *\r\n   * Restores the state by assigning the previous value.\r\n   */\n  codec.afterDecode = function (dec, node, obj) {\n    obj.previous = obj.root;\n    return obj;\n  };\n\n  // Returns the codec into the registry\n  return codec;\n}());\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\nmxCodecRegistry.register(function () {\n  /**\r\n   * Class: mxChildChangeCodec\r\n   *\r\n   * Codec for <mxChildChange>s. This class is created and registered\r\n   * dynamically at load time and used implicitely via <mxCodec> and\r\n   * the <mxCodecRegistry>.\r\n   *\r\n   * Transient Fields:\r\n   *\r\n   * - model\r\n   * - previous\r\n   * - previousIndex\r\n   * - child\r\n   *\r\n   * Reference Fields:\r\n   *\r\n   * - parent\r\n   */\n  var codec = new _mxObjectCodec[\"default\"](new _mxChildChange[\"default\"](), ['model', 'child', 'previousIndex'], ['parent', 'previous']);\n\n  /**\r\n   * Function: isReference\r\n   *\r\n   * Returns true for the child attribute if the child\r\n   * cell had a previous parent or if we're reading the\r\n   * child as an attribute rather than a child node, in\r\n   * which case it's always a reference.\r\n   */\n  codec.isReference = function (obj, attr, value, isWrite) {\n    if (attr == 'child' && (obj.previous != null || !isWrite)) {\n      return true;\n    }\n    return _mxGraphUtils[\"default\"].indexOf(this.idrefs, attr) >= 0;\n  };\n\n  /**\r\n   * Function: afterEncode\r\n   *\r\n   * Encodes the child recusively and adds the result\r\n   * to the given node.\r\n   */\n  codec.afterEncode = function (enc, obj, node) {\n    if (this.isReference(obj, 'child', obj.child, true)) {\n      // Encodes as reference (id)\n      node.setAttribute('child', enc.getId(obj.child));\n    } else {\n      // At this point, the encoder is no longer able to know which cells\n      // are new, so we have to encode the complete cell hierarchy and\n      // ignore the ones that are already there at decoding time. Note:\n      // This can only be resolved by moving the notify event into the\n      // execute of the edit.\n      enc.encodeCell(obj.child, node);\n    }\n    return node;\n  };\n\n  /**\r\n   * Function: beforeDecode\r\n   *\r\n   * Decodes the any child nodes as using the respective\r\n   * codec from the registry.\r\n   */\n  codec.beforeDecode = function (dec, node, obj) {\n    if (node.firstChild != null && node.firstChild.nodeType == _mxConstants[\"default\"].NODETYPE_ELEMENT) {\n      // Makes sure the original node isn't modified\n      node = node.cloneNode(true);\n      var tmp = node.firstChild;\n      obj.child = dec.decodeCell(tmp, false);\n      var tmp2 = tmp.nextSibling;\n      tmp.parentNode.removeChild(tmp);\n      tmp = tmp2;\n      while (tmp != null) {\n        tmp2 = tmp.nextSibling;\n        if (tmp.nodeType == _mxConstants[\"default\"].NODETYPE_ELEMENT) {\n          // Ignores all existing cells because those do not need to\n          // be re-inserted into the model. Since the encoded version\n          // of these cells contains the new parent, this would leave\n          // to an inconsistent state on the model (ie. a parent\n          // change without a call to parentForCellChanged).\n          var id = tmp.getAttribute('id');\n          if (dec.lookup(id) == null) {\n            dec.decodeCell(tmp);\n          }\n        }\n        tmp.parentNode.removeChild(tmp);\n        tmp = tmp2;\n      }\n    } else {\n      var childRef = node.getAttribute('child');\n      obj.child = dec.getObject(childRef);\n    }\n    return node;\n  };\n\n  /**\r\n   * Function: afterDecode\r\n   *\r\n   * Restores object state in the child change.\r\n   */\n  codec.afterDecode = function (dec, node, obj) {\n    // Cells are encoded here after a complete transaction so the previous\n    // parent must be restored on the cell for the case where the cell was\n    // added. This is needed for the local model to identify the cell as a\n    // new cell and register the ID.\n    obj.child.parent = obj.previous;\n    obj.previous = obj.parent;\n    obj.previousIndex = obj.index;\n    return obj;\n  };\n\n  // Returns the codec into the registry\n  return codec;\n}());\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\nmxCodecRegistry.register(function () {\n  /**\r\n   * Class: mxTerminalChangeCodec\r\n   *\r\n   * Codec for <mxTerminalChange>s. This class is created and registered\r\n   * dynamically at load time and used implicitely via <mxCodec> and\r\n   * the <mxCodecRegistry>.\r\n   *\r\n   * Transient Fields:\r\n   *\r\n   * - model\r\n   * - previous\r\n   *\r\n   * Reference Fields:\r\n   *\r\n   * - cell\r\n   * - terminal\r\n   */\n  var codec = new _mxObjectCodec[\"default\"](new _mxTerminalChange[\"default\"](), ['model', 'previous'], ['cell', 'terminal']);\n\n  /**\r\n   * Function: afterDecode\r\n   *\r\n   * Restores the state by assigning the previous value.\r\n   */\n  codec.afterDecode = function (dec, node, obj) {\n    obj.previous = obj.terminal;\n    return obj;\n  };\n\n  // Returns the codec into the registry\n  return codec;\n}());\n\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxCodec\r\n *\r\n * XML codec for JavaScript object graphs. See <mxObjectCodec> for a\r\n * description of the general encoding/decoding scheme. This class uses the\r\n * codecs registered in <mxCodecRegistry> for encoding/decoding each object.\r\n *\r\n * References:\r\n *\r\n * In order to resolve references, especially forward references, the mxCodec\r\n * constructor must be given the document that contains the referenced\r\n * elements.\r\n *\r\n * Examples:\r\n *\r\n * The following code is used to encode a graph model.\r\n *\r\n * (code)\r\n * var encoder = new mxCodec();\r\n * var result = encoder.encode(graph.getModel());\r\n * var xml = mxUtils.getXml(result);\r\n * (end)\r\n *\r\n * Example:\r\n *\r\n * Using the code below, an XML document is decoded into an existing model. The\r\n * document may be obtained using one of the functions in mxUtils for loading\r\n * an XML file, eg. <mxRequestUtils.get>, or using <mxUtils.parseXml> for parsing an\r\n * XML string.\r\n *\r\n * (code)\r\n * var doc = mxUtils.parseXml(xmlString);\r\n * var codec = new mxCodec(doc);\r\n * codec.decode(doc.documentElement, graph.getModel());\r\n * (end)\r\n *\r\n * Example:\r\n *\r\n * This example demonstrates parsing a list of isolated cells into an existing\r\n * graph model. Note that the cells do not have a parent reference so they can\r\n * be added anywhere in the cell hierarchy after parsing.\r\n *\r\n * (code)\r\n * var xml = '<root><mxCell id=\"2\" value=\"Hello,\" vertex=\"1\"><mxGeometry x=\"20\" y=\"20\" width=\"80\" height=\"30\" as=\"geometry\"/></mxCell><mxCell id=\"3\" value=\"World!\" vertex=\"1\"><mxGeometry x=\"200\" y=\"150\" width=\"80\" height=\"30\" as=\"geometry\"/></mxCell><mxCell id=\"4\" value=\"\" edge=\"1\" source=\"2\" target=\"3\"><mxGeometry relative=\"1\" as=\"geometry\"/></mxCell></root>';\r\n * var doc = mxUtils.parseXml(xml);\r\n * var codec = new mxCodec(doc);\r\n * var elt = doc.documentElement.firstChild;\r\n * var cells = [];\r\n *\r\n * while (elt != null)\r\n * {\r\n *   cells.push(codec.decode(elt));\r\n *   elt = elt.nextSibling;\r\n * }\r\n *\r\n * graph.addCells(cells);\r\n * (end)\r\n *\r\n * Example:\r\n *\r\n * Using the following code, the selection cells of a graph are encoded and the\r\n * output is displayed in a dialog box.\r\n *\r\n * (code)\r\n * var enc = new mxCodec();\r\n * var cells = graph.getSelectionCells();\r\n * mxUtils.alert(mxUtils.getPrettyXml(enc.encode(cells)));\r\n * (end)\r\n *\r\n * Newlines in the XML can be converted to <br>, in which case a '<br>' argument\r\n * must be passed to <mxUtils.getXml> as the second argument.\r\n *\r\n * Debugging:\r\n *\r\n * For debugging I/O you can use the following code to get the sequence of\r\n * encoded objects:\r\n *\r\n * (code)\r\n * var oldEncode = mxCodec.prototype.encode;\r\n * mxCodec.prototype.encode = function(obj)\r\n * {\r\n *   mxLog.show();\r\n *   mxLog.debug('mxCodec.encode: obj='+mxGraphUtils.getFunctionName(obj.constructor));\r\n *\r\n *   return oldEncode.apply(this, arguments);\r\n * };\r\n * (end)\r\n *\r\n * Note that the I/O system adds object codecs for new object automatically. For\r\n * decoding those objects, the constructor should be written as follows:\r\n *\r\n * (code)\r\nimport mxGraphUtils from './mxGraphUtils.js';\r\n\r\n * var MyObj = function(name)\r\n * {\r\n *   // ...\r\n * };\r\n * (end)\r\n *\r\n * Constructor: mxCodec\r\n *\r\n * Constructs an XML encoder/decoder for the specified\r\n * owner document.\r\n *\r\n * Parameters:\r\n *\r\n * document - Optional XML document that contains the data.\r\n * If no document is specified then a new document is created\r\n * using <mxUtils.createXmlDocument>.\r\n */\nvar _default = exports[\"default\"] = mxCodecRegistry;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxCodecRegistry.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxCodecRegistryHelper.js":
/*!********************************************************!*\
  !*** ./src/workflow/mxClient/mxCodecRegistryHelper.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.nodeCodecsMap = exports[\"default\"] = void 0;\nvar _mxCell = _interopRequireDefault(__webpack_require__(/*! ./mxCell */ \"./src/workflow/mxClient/mxCell.js\"));\nvar _mxGraphModel = _interopRequireDefault(__webpack_require__(/*! ./mxGraphModel */ \"./src/workflow/mxClient/mxGraphModel.js\"));\nvar _mxRootChange = _interopRequireDefault(__webpack_require__(/*! ./mxRootChange */ \"./src/workflow/mxClient/mxRootChange.js\"));\nvar _mxChildChange = _interopRequireDefault(__webpack_require__(/*! ./mxChildChange */ \"./src/workflow/mxClient/mxChildChange.js\"));\nvar _mxTerminalChange = _interopRequireDefault(__webpack_require__(/*! ./mxTerminalChange */ \"./src/workflow/mxClient/mxTerminalChange.js\"));\nvar _mxValueChange = _interopRequireDefault(__webpack_require__(/*! ./mxValueChange */ \"./src/workflow/mxClient/mxValueChange.js\"));\nvar _mxStyleChange = _interopRequireDefault(__webpack_require__(/*! ./mxStyleChange */ \"./src/workflow/mxClient/mxStyleChange.js\"));\nvar _mxGeometryChange = _interopRequireDefault(__webpack_require__(/*! ./mxGeometryChange */ \"./src/workflow/mxClient/mxGeometryChange.js\"));\nvar _mxCollapseChange = _interopRequireDefault(__webpack_require__(/*! ./mxCollapseChange */ \"./src/workflow/mxClient/mxCollapseChange.js\"));\nvar _mxVisibleChange = _interopRequireDefault(__webpack_require__(/*! ./mxVisibleChange */ \"./src/workflow/mxClient/mxVisibleChange.js\"));\nvar _mxCellAttributeChange = _interopRequireDefault(__webpack_require__(/*! ./mxCellAttributeChange */ \"./src/workflow/mxClient/mxCellAttributeChange.js\"));\nvar _mxGraph = _interopRequireDefault(__webpack_require__(/*! ./mxGraph */ \"./src/workflow/mxClient/mxGraph.js\"));\nvar _mxGraphView = _interopRequireDefault(__webpack_require__(/*! ./mxGraphView */ \"./src/workflow/mxClient/mxGraphView.js\"));\nvar _mxStylesheet = _interopRequireDefault(__webpack_require__(/*! ./mxStylesheet */ \"./src/workflow/mxClient/mxStylesheet.js\"));\nvar _mxDefaultKeyHandler = _interopRequireDefault(__webpack_require__(/*! ./mxDefaultKeyHandler */ \"./src/workflow/mxClient/mxDefaultKeyHandler.js\"));\nvar _mxDefaultToolbar = _interopRequireDefault(__webpack_require__(/*! ./mxDefaultToolbar */ \"./src/workflow/mxClient/mxDefaultToolbar.js\"));\nvar _mxDefaultPopupMenu = _interopRequireDefault(__webpack_require__(/*! ./mxDefaultPopupMenu */ \"./src/workflow/mxClient/mxDefaultPopupMenu.js\"));\nvar _mxEditor = _interopRequireDefault(__webpack_require__(/*! ./mxEditor */ \"./src/workflow/mxClient/mxEditor.js\"));\nvar _mxGeometry = _interopRequireDefault(__webpack_require__(/*! ./mxGeometry */ \"./src/workflow/mxClient/mxGeometry.js\"));\nvar _mxPoint = _interopRequireDefault(__webpack_require__(/*! ./mxPoint */ \"./src/workflow/mxClient/mxPoint.js\"));\nvar _mxRectangle = _interopRequireDefault(__webpack_require__(/*! ./mxRectangle */ \"./src/workflow/mxClient/mxRectangle.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nvar mxCodecRegistryHelper = {\n  /*\r\n  * TODO: 优化\r\n  * node节点名与codec的映射\r\n  * 由于把mxGraph拆成独立的模块打包之后mxXxx不在是全局变量且函数名被简化，因此暂时先添加这种映射\r\n  */\n  nodeCodecsMap: {\n    'mxCell': _mxCell[\"default\"],\n    'mxGraphModel': _mxGraphModel[\"default\"],\n    'mxRootChange': _mxRootChange[\"default\"],\n    'mxChildChange': _mxChildChange[\"default\"],\n    'mxTerminalChange': _mxTerminalChange[\"default\"],\n    'mxValueChange': _mxValueChange[\"default\"],\n    'mxStyleChange': _mxStyleChange[\"default\"],\n    'mxGeometryChange': _mxGeometryChange[\"default\"],\n    'mxCollapseChange': _mxCollapseChange[\"default\"],\n    'mxVisibleChange': _mxVisibleChange[\"default\"],\n    'mxCellAttributeChange': _mxCellAttributeChange[\"default\"],\n    'mxGraph': _mxGraph[\"default\"],\n    'mxGraphView': _mxGraphView[\"default\"],\n    'mxStylesheet': _mxStylesheet[\"default\"],\n    'mxDefaultKeyHandler': _mxDefaultKeyHandler[\"default\"],\n    'mxDefaultToolbar': _mxDefaultToolbar[\"default\"],\n    'mxDefaultPopupMenu': _mxDefaultPopupMenu[\"default\"],\n    'mxEditor': _mxEditor[\"default\"],\n    'mxGeometry': _mxGeometry[\"default\"],\n    'mxPoint': _mxPoint[\"default\"],\n    'mxRectangle': _mxRectangle[\"default\"]\n  }\n};\nvar nodeCodecsMap = exports.nodeCodecsMap = mxCodecRegistryHelper.nodeCodecsMap;\nvar _default = exports[\"default\"] = mxCodecRegistryHelper;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxCodecRegistryHelper.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxCollapseChange.js":
/*!***************************************************!*\
  !*** ./src/workflow/mxClient/mxCollapseChange.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nfunction mxCollapseChange(model, cell, collapsed) {\n  this.model = model;\n  this.cell = cell;\n  this.collapsed = collapsed;\n  this.previous = collapsed;\n}\n;\n\n/**\r\n * Function: execute\r\n *\r\n * Changes the collapsed state of <cell> to <previous> using\r\n * <mxGraphModel.collapsedStateForCellChanged>.\r\n */\nmxCollapseChange.prototype.execute = function () {\n  this.collapsed = this.previous;\n  this.previous = this.model.collapsedStateForCellChanged(this.cell, this.previous);\n};\nmxCollapseChange.getName = function () {\n  return 'mxCollapseChange';\n};\n/**\r\n * Class: mxVisibleChange\r\n *\r\n * Action to change a cell's visible state in a model.\r\n *\r\n * Constructor: mxVisibleChange\r\n *\r\n * Constructs a change of a visible state in the\r\n * specified model.\r\n */\nvar _default = exports[\"default\"] = mxCollapseChange;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxCollapseChange.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxCompactTreeLayout.js":
/*!******************************************************!*\
  !*** ./src/workflow/mxClient/mxCompactTreeLayout.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.join.js */ \"../../node_modules/core-js/modules/es.array.join.js\");\n__webpack_require__(/*! core-js/modules/es.array.sort.js */ \"../../node_modules/core-js/modules/es.array.sort.js\");\n__webpack_require__(/*! core-js/modules/es.regexp.exec.js */ \"../../node_modules/core-js/modules/es.regexp.exec.js\");\n__webpack_require__(/*! core-js/modules/es.string.split.js */ \"../../node_modules/core-js/modules/es.string.split.js\");\nvar _mxGraphLayout = _interopRequireDefault(__webpack_require__(/*! ./mxGraphLayout.js */ \"./src/workflow/mxClient/mxGraphLayout.js\"));\nvar _mxPoint = _interopRequireDefault(__webpack_require__(/*! ./mxPoint.js */ \"./src/workflow/mxClient/mxPoint.js\"));\nvar _mxDictionary = _interopRequireDefault(__webpack_require__(/*! ./mxDictionary.js */ \"./src/workflow/mxClient/mxDictionary.js\"));\nvar _WeightedCellSorter = _interopRequireDefault(__webpack_require__(/*! ./WeightedCellSorter.js */ \"./src/workflow/mxClient/WeightedCellSorter.js\"));\nvar _mxRectangle = _interopRequireDefault(__webpack_require__(/*! ./mxRectangle.js */ \"./src/workflow/mxClient/mxRectangle.js\"));\nvar _mxCellPath = _interopRequireDefault(__webpack_require__(/*! ./mxCellPath.js */ \"./src/workflow/mxClient/mxCellPath.js\"));\nvar _mxUtils = _interopRequireDefault(__webpack_require__(/*! ./mxUtils.js */ \"./src/workflow/mxClient/mxUtils.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxCompactTreeLayout(graph, horizontal, invert) {\n  _mxGraphLayout[\"default\"].call(this, graph);\n  this.horizontal = horizontal != null ? horizontal : true;\n  this.invert = invert != null ? invert : false;\n}\n;\n\n/**\r\n * Extends mxGraphLayout.\r\n */\nmxCompactTreeLayout.prototype = new _mxGraphLayout[\"default\"]();\nmxCompactTreeLayout.prototype.constructor = mxCompactTreeLayout;\n\n/**\r\n * Variable: horizontal\r\n *\r\n * Specifies the orientation of the layout. Default is true.\r\n */\nmxCompactTreeLayout.prototype.horizontal = null;\n\n/**\r\n * Variable: invert\r\n *\r\n * Specifies if edge directions should be inverted. Default is false.\r\n */\nmxCompactTreeLayout.prototype.invert = null;\n\n/**\r\n * Variable: resizeParent\r\n *\r\n * If the parents should be resized to match the width/height of the\r\n * children. Default is true.\r\n */\nmxCompactTreeLayout.prototype.resizeParent = true;\n\n/**\r\n * Variable: maintainParentLocation\r\n *\r\n * Specifies if the parent location should be maintained, so that the\r\n * top, left corner stays the same before and after execution of\r\n * the layout. Default is false for backwards compatibility.\r\n */\nmxCompactTreeLayout.prototype.maintainParentLocation = false;\n\n/**\r\n * Variable: groupPadding\r\n *\r\n * Padding added to resized parents. Default is 10.\r\n */\nmxCompactTreeLayout.prototype.groupPadding = 10;\n\n/**\r\n * Variable: groupPaddingTop\r\n *\r\n * Top padding added to resized parents. Default is 0.\r\n */\nmxCompactTreeLayout.prototype.groupPaddingTop = 0;\n\n/**\r\n * Variable: groupPaddingRight\r\n *\r\n * Right padding added to resized parents. Default is 0.\r\n */\nmxCompactTreeLayout.prototype.groupPaddingRight = 0;\n\n/**\r\n * Variable: groupPaddingBottom\r\n *\r\n * Bottom padding added to resized parents. Default is 0.\r\n */\nmxCompactTreeLayout.prototype.groupPaddingBottom = 0;\n\n/**\r\n * Variable: groupPaddingLeft\r\n *\r\n * Left padding added to resized parents. Default is 0.\r\n */\nmxCompactTreeLayout.prototype.groupPaddingLeft = 0;\n\n/**\r\n * Variable: parentsChanged\r\n *\r\n * A set of the parents that need updating based on children\r\n * process as part of the layout.\r\n */\nmxCompactTreeLayout.prototype.parentsChanged = null;\n\n/**\r\n * Variable: moveTree\r\n *\r\n * Specifies if the tree should be moved to the top, left corner\r\n * if it is inside a top-level layer. Default is false.\r\n */\nmxCompactTreeLayout.prototype.moveTree = false;\n\n/**\r\n * Variable: visited\r\n *\r\n * Specifies if the tree should be moved to the top, left corner\r\n * if it is inside a top-level layer. Default is false.\r\n */\nmxCompactTreeLayout.prototype.visited = null;\n\n/**\r\n * Variable: levelDistance\r\n *\r\n * Holds the levelDistance. Default is 10.\r\n */\nmxCompactTreeLayout.prototype.levelDistance = 10;\n\n/**\r\n * Variable: nodeDistance\r\n *\r\n * Holds the nodeDistance. Default is 20.\r\n */\nmxCompactTreeLayout.prototype.nodeDistance = 20;\n\n/**\r\n * Variable: resetEdges\r\n *\r\n * Specifies if all edge points of traversed edges should be removed.\r\n * Default is true.\r\n */\nmxCompactTreeLayout.prototype.resetEdges = true;\n\n/**\r\n * Variable: prefHozEdgeSep\r\n *\r\n * The preferred horizontal distance between edges exiting a vertex.\r\n */\nmxCompactTreeLayout.prototype.prefHozEdgeSep = 5;\n\n/**\r\n * Variable: prefVertEdgeOff\r\n *\r\n * The preferred vertical offset between edges exiting a vertex.\r\n */\nmxCompactTreeLayout.prototype.prefVertEdgeOff = 4;\n\n/**\r\n * Variable: minEdgeJetty\r\n *\r\n * The minimum distance for an edge jetty from a vertex.\r\n */\nmxCompactTreeLayout.prototype.minEdgeJetty = 8;\n\n/**\r\n * Variable: channelBuffer\r\n *\r\n * The size of the vertical buffer in the center of inter-rank channels\r\n * where edge control points should not be placed.\r\n */\nmxCompactTreeLayout.prototype.channelBuffer = 4;\n\n/**\r\n * Variable: edgeRouting\r\n *\r\n * Whether or not to apply the internal tree edge routing.\r\n */\nmxCompactTreeLayout.prototype.edgeRouting = true;\n\n/**\r\n * Variable: sortEdges\r\n *\r\n * Specifies if edges should be sorted according to the order of their\r\n * opposite terminal cell in the model.\r\n */\nmxCompactTreeLayout.prototype.sortEdges = false;\n\n/**\r\n * Variable: alignRanks\r\n *\r\n * Whether or not the tops of cells in each rank should be aligned\r\n * across the rank\r\n */\nmxCompactTreeLayout.prototype.alignRanks = false;\n\n/**\r\n * Variable: maxRankHeight\r\n *\r\n * An array of the maximum height of cells (relative to the layout direction)\r\n * per rank\r\n */\nmxCompactTreeLayout.prototype.maxRankHeight = null;\n\n/**\r\n * Variable: root\r\n *\r\n * The cell to use as the root of the tree\r\n */\nmxCompactTreeLayout.prototype.root = null;\n\n/**\r\n * Variable: node\r\n *\r\n * The internal node representation of the root cell. Do not set directly\r\n * , this value is only exposed to assist with post-processing functionality\r\n */\nmxCompactTreeLayout.prototype.node = null;\n\n/**\r\n * Function: isVertexIgnored\r\n *\r\n * Returns a boolean indicating if the given <mxCell> should be ignored as a\r\n * vertex. This returns true if the cell has no connections.\r\n *\r\n * Parameters:\r\n *\r\n * vertex - <mxCell> whose ignored state should be returned.\r\n */\nmxCompactTreeLayout.prototype.isVertexIgnored = function (vertex) {\n  return _mxGraphLayout[\"default\"].prototype.isVertexIgnored.apply(this, arguments) || this.graph.getConnections(vertex).length == 0;\n};\n\n/**\r\n * Function: isHorizontal\r\n *\r\n * Returns <horizontal>.\r\n */\nmxCompactTreeLayout.prototype.isHorizontal = function () {\n  return this.horizontal;\n};\n\n/**\r\n * Function: execute\r\n *\r\n * Implements <mxGraphLayout.execute>.\r\n *\r\n * If the parent has any connected edges, then it is used as the root of\r\n * the tree. Else, <mxGraph.findTreeRoots> will be used to find a suitable\r\n * root node within the set of children of the given parent.\r\n *\r\n * Parameters:\r\n *\r\n * parent - <mxCell> whose children should be laid out.\r\n * root - Optional <mxCell> that will be used as the root of the tree.\r\n * Overrides <root> if specified.\r\n */\nmxCompactTreeLayout.prototype.execute = function (parent, root) {\n  this.parent = parent;\n  var model = this.graph.getModel();\n  if (root == null) {\n    // Takes the parent as the root if it has outgoing edges\n    if (this.graph.getEdges(parent, model.getParent(parent), this.invert, !this.invert, false).length > 0) {\n      this.root = parent;\n    }\n\n    // Tries to find a suitable root in the parent's\n    // children\n    else {\n      var roots = this.graph.findTreeRoots(parent, true, this.invert);\n      if (roots.length > 0) {\n        for (var i = 0; i < roots.length; i++) {\n          if (!this.isVertexIgnored(roots[i]) && this.graph.getEdges(roots[i], null, this.invert, !this.invert, false).length > 0) {\n            this.root = roots[i];\n            break;\n          }\n        }\n      }\n    }\n  } else {\n    this.root = root;\n  }\n  if (this.root != null) {\n    if (this.resizeParent) {\n      this.parentsChanged = new Object();\n    } else {\n      this.parentsChanged = null;\n    }\n\n    //  Maintaining parent location\n    this.parentX = null;\n    this.parentY = null;\n    if (parent != this.root && model.isVertex(parent) != null && this.maintainParentLocation) {\n      var geo = this.graph.getCellGeometry(parent);\n      if (geo != null) {\n        this.parentX = geo.x;\n        this.parentY = geo.y;\n      }\n    }\n    model.beginUpdate();\n    try {\n      this.visited = new Object();\n      this.node = this.dfs(this.root, parent);\n      if (this.alignRanks) {\n        this.maxRankHeight = [];\n        this.findRankHeights(this.node, 0);\n        this.setCellHeights(this.node, 0);\n      }\n      if (this.node != null) {\n        this.layout(this.node);\n        var x0 = this.graph.gridSize;\n        var y0 = x0;\n        if (!this.moveTree) {\n          var g = this.getVertexBounds(this.root);\n          if (g != null) {\n            x0 = g.x;\n            y0 = g.y;\n          }\n        }\n        var bounds = null;\n        if (this.isHorizontal()) {\n          bounds = this.horizontalLayout(this.node, x0, y0);\n        } else {\n          bounds = this.verticalLayout(this.node, null, x0, y0);\n        }\n        if (bounds != null) {\n          var dx = 0;\n          var dy = 0;\n          if (bounds.x < 0) {\n            dx = Math.abs(x0 - bounds.x);\n          }\n          if (bounds.y < 0) {\n            dy = Math.abs(y0 - bounds.y);\n          }\n          if (dx != 0 || dy != 0) {\n            this.moveNode(this.node, dx, dy);\n          }\n          if (this.resizeParent) {\n            this.adjustParents();\n          }\n          if (this.edgeRouting) {\n            // Iterate through all edges setting their positions\n            this.localEdgeProcessing(this.node);\n          }\n        }\n\n        // Maintaining parent location\n        if (this.parentX != null && this.parentY != null) {\n          var geo = this.graph.getCellGeometry(parent);\n          if (geo != null) {\n            geo = geo.clone();\n            geo.x = this.parentX;\n            geo.y = this.parentY;\n            model.setGeometry(parent, geo);\n          }\n        }\n      }\n    } finally {\n      model.endUpdate();\n    }\n  }\n};\n\n/**\r\n * Function: moveNode\r\n *\r\n * Moves the specified node and all of its children by the given amount.\r\n */\nmxCompactTreeLayout.prototype.moveNode = function (node, dx, dy) {\n  node.x += dx;\n  node.y += dy;\n  this.apply(node);\n  var child = node.child;\n  while (child != null) {\n    this.moveNode(child, dx, dy);\n    child = child.next;\n  }\n};\n\n/**\r\n * Function: sortOutgoingEdges\r\n *\r\n * Called if <sortEdges> is true to sort the array of outgoing edges in place.\r\n */\nmxCompactTreeLayout.prototype.sortOutgoingEdges = function (source, edges) {\n  var lookup = new _mxDictionary[\"default\"]();\n  edges.sort(function (e1, e2) {\n    var end1 = e1.getTerminal(e1.getTerminal(false) == source);\n    var p1 = lookup.get(end1);\n    if (p1 == null) {\n      p1 = _mxCellPath[\"default\"].create(end1).split(_mxCellPath[\"default\"].PATH_SEPARATOR);\n      lookup.put(end1, p1);\n    }\n    var end2 = e2.getTerminal(e2.getTerminal(false) == source);\n    var p2 = lookup.get(end2);\n    if (p2 == null) {\n      p2 = _mxCellPath[\"default\"].create(end2).split(_mxCellPath[\"default\"].PATH_SEPARATOR);\n      lookup.put(end2, p2);\n    }\n    return _mxCellPath[\"default\"].compare(p1, p2);\n  });\n};\n\n/**\r\n * Function: findRankHeights\r\n *\r\n * Stores the maximum height (relative to the layout\r\n * direction) of cells in each rank\r\n */\nmxCompactTreeLayout.prototype.findRankHeights = function (node, rank) {\n  if (this.maxRankHeight[rank] == null || this.maxRankHeight[rank] < node.height) {\n    this.maxRankHeight[rank] = node.height;\n  }\n  var child = node.child;\n  while (child != null) {\n    this.findRankHeights(child, rank + 1);\n    child = child.next;\n  }\n};\n\n/**\r\n * Function: setCellHeights\r\n *\r\n * Set the cells heights (relative to the layout\r\n * direction) when the tops of each rank are to be aligned\r\n */\nmxCompactTreeLayout.prototype.setCellHeights = function (node, rank) {\n  if (this.maxRankHeight[rank] != null && this.maxRankHeight[rank] > node.height) {\n    node.height = this.maxRankHeight[rank];\n  }\n  var child = node.child;\n  while (child != null) {\n    this.setCellHeights(child, rank + 1);\n    child = child.next;\n  }\n};\n\n/**\r\n * Function: dfs\r\n *\r\n * Does a depth first search starting at the specified cell.\r\n * Makes sure the specified parent is never left by the\r\n * algorithm.\r\n */\nmxCompactTreeLayout.prototype.dfs = function (cell, parent) {\n  var id = _mxCellPath[\"default\"].create(cell);\n  var node = null;\n  if (cell != null && this.visited[id] == null && !this.isVertexIgnored(cell)) {\n    this.visited[id] = cell;\n    node = this.createNode(cell);\n    var model = this.graph.getModel();\n    var prev = null;\n    var out = this.graph.getEdges(cell, parent, this.invert, !this.invert, false, true);\n    var view = this.graph.getView();\n    if (this.sortEdges) {\n      this.sortOutgoingEdges(cell, out);\n    }\n    for (var i = 0; i < out.length; i++) {\n      var edge = out[i];\n      if (!this.isEdgeIgnored(edge)) {\n        // Resets the points on the traversed edge\n        if (this.resetEdges) {\n          this.setEdgePoints(edge, null);\n        }\n        if (this.edgeRouting) {\n          this.setEdgeStyleEnabled(edge, false);\n          this.setEdgePoints(edge, null);\n        }\n\n        // Checks if terminal in same swimlane\n        var state = view.getState(edge);\n        var target = state != null ? state.getVisibleTerminal(this.invert) : view.getVisibleTerminal(edge, this.invert);\n        var tmp = this.dfs(target, parent);\n        if (tmp != null && model.getGeometry(target) != null) {\n          if (prev == null) {\n            node.child = tmp;\n          } else {\n            prev.next = tmp;\n          }\n          prev = tmp;\n        }\n      }\n    }\n  }\n  return node;\n};\n\n/**\r\n * Function: layout\r\n *\r\n * Starts the actual compact tree layout algorithm\r\n * at the given node.\r\n */\nmxCompactTreeLayout.prototype.layout = function (node) {\n  if (node != null) {\n    var child = node.child;\n    while (child != null) {\n      this.layout(child);\n      child = child.next;\n    }\n    if (node.child != null) {\n      this.attachParent(node, this.join(node));\n    } else {\n      this.layoutLeaf(node);\n    }\n  }\n};\n\n/**\r\n * Function: horizontalLayout\r\n */\nmxCompactTreeLayout.prototype.horizontalLayout = function (node, x0, y0, bounds) {\n  node.x += x0 + node.offsetX;\n  node.y += y0 + node.offsetY;\n  bounds = this.apply(node, bounds);\n  var child = node.child;\n  if (child != null) {\n    bounds = this.horizontalLayout(child, node.x, node.y, bounds);\n    var siblingOffset = node.y + child.offsetY;\n    var s = child.next;\n    while (s != null) {\n      bounds = this.horizontalLayout(s, node.x + child.offsetX, siblingOffset, bounds);\n      siblingOffset += s.offsetY;\n      s = s.next;\n    }\n  }\n  return bounds;\n};\n\n/**\r\n * Function: verticalLayout\r\n */\nmxCompactTreeLayout.prototype.verticalLayout = function (node, parent, x0, y0, bounds) {\n  node.x += x0 + node.offsetY;\n  node.y += y0 + node.offsetX;\n  bounds = this.apply(node, bounds);\n  var child = node.child;\n  if (child != null) {\n    bounds = this.verticalLayout(child, node, node.x, node.y, bounds);\n    var siblingOffset = node.x + child.offsetY;\n    var s = child.next;\n    while (s != null) {\n      bounds = this.verticalLayout(s, node, siblingOffset, node.y + child.offsetX, bounds);\n      siblingOffset += s.offsetY;\n      s = s.next;\n    }\n  }\n  return bounds;\n};\n\n/**\r\n * Function: attachParent\r\n */\nmxCompactTreeLayout.prototype.attachParent = function (node, height) {\n  var x = this.nodeDistance + this.levelDistance;\n  var y2 = (height - node.width) / 2 - this.nodeDistance;\n  var y1 = y2 + node.width + 2 * this.nodeDistance - height;\n  node.child.offsetX = x + node.height;\n  node.child.offsetY = y1;\n  node.contour.upperHead = this.createLine(node.height, 0, this.createLine(x, y1, node.contour.upperHead));\n  node.contour.lowerHead = this.createLine(node.height, 0, this.createLine(x, y2, node.contour.lowerHead));\n};\n\n/**\r\n * Function: layoutLeaf\r\n */\nmxCompactTreeLayout.prototype.layoutLeaf = function (node) {\n  var dist = 2 * this.nodeDistance;\n  node.contour.upperTail = this.createLine(node.height + dist, 0);\n  node.contour.upperHead = node.contour.upperTail;\n  node.contour.lowerTail = this.createLine(0, -node.width - dist);\n  node.contour.lowerHead = this.createLine(node.height + dist, 0, node.contour.lowerTail);\n};\n\n/**\r\n * Function: join\r\n */\nmxCompactTreeLayout.prototype.join = function (node) {\n  var dist = 2 * this.nodeDistance;\n  var child = node.child;\n  node.contour = child.contour;\n  var h = child.width + dist;\n  var sum = h;\n  child = child.next;\n  while (child != null) {\n    var d = this.merge(node.contour, child.contour);\n    child.offsetY = d + h;\n    child.offsetX = 0;\n    h = child.width + dist;\n    sum += d + h;\n    child = child.next;\n  }\n  return sum;\n};\n\n/**\r\n * Function: merge\r\n */\nmxCompactTreeLayout.prototype.merge = function (p1, p2) {\n  var x = 0;\n  var y = 0;\n  var total = 0;\n  var upper = p1.lowerHead;\n  var lower = p2.upperHead;\n  while (lower != null && upper != null) {\n    var d = this.offset(x, y, lower.dx, lower.dy, upper.dx, upper.dy);\n    y += d;\n    total += d;\n    if (x + lower.dx <= upper.dx) {\n      x += lower.dx;\n      y += lower.dy;\n      lower = lower.next;\n    } else {\n      x -= upper.dx;\n      y -= upper.dy;\n      upper = upper.next;\n    }\n  }\n  if (lower != null) {\n    var b = this.bridge(p1.upperTail, 0, 0, lower, x, y);\n    p1.upperTail = b.next != null ? p2.upperTail : b;\n    p1.lowerTail = p2.lowerTail;\n  } else {\n    var b = this.bridge(p2.lowerTail, x, y, upper, 0, 0);\n    if (b.next == null) {\n      p1.lowerTail = b;\n    }\n  }\n  p1.lowerHead = p2.lowerHead;\n  return total;\n};\n\n/**\r\n * Function: offset\r\n */\nmxCompactTreeLayout.prototype.offset = function (p1, p2, a1, a2, b1, b2) {\n  var d = 0;\n  if (b1 <= p1 || p1 + a1 <= 0) {\n    return 0;\n  }\n  var t = b1 * a2 - a1 * b2;\n  if (t > 0) {\n    if (p1 < 0) {\n      var s = p1 * a2;\n      d = s / a1 - p2;\n    } else if (p1 > 0) {\n      var s = p1 * b2;\n      d = s / b1 - p2;\n    } else {\n      d = -p2;\n    }\n  } else if (b1 < p1 + a1) {\n    var s = (b1 - p1) * a2;\n    d = b2 - (p2 + s / a1);\n  } else if (b1 > p1 + a1) {\n    var s = (a1 + p1) * b2;\n    d = s / b1 - (p2 + a2);\n  } else {\n    d = b2 - (p2 + a2);\n  }\n  if (d > 0) {\n    return d;\n  } else {\n    return 0;\n  }\n};\n\n/**\r\n * Function: bridge\r\n */\nmxCompactTreeLayout.prototype.bridge = function (line1, x1, y1, line2, x2, y2) {\n  var dx = x2 + line2.dx - x1;\n  var dy = 0;\n  var s = 0;\n  if (line2.dx == 0) {\n    dy = line2.dy;\n  } else {\n    s = dx * line2.dy;\n    dy = s / line2.dx;\n  }\n  var r = this.createLine(dx, dy, line2.next);\n  line1.next = this.createLine(0, y2 + line2.dy - dy - y1, r);\n  return r;\n};\n\n/**\r\n * Function: createNode\r\n */\nmxCompactTreeLayout.prototype.createNode = function (cell) {\n  var node = new Object();\n  node.cell = cell;\n  node.x = 0;\n  node.y = 0;\n  node.width = 0;\n  node.height = 0;\n  var geo = this.getVertexBounds(cell);\n  if (geo != null) {\n    if (this.isHorizontal()) {\n      node.width = geo.height;\n      node.height = geo.width;\n    } else {\n      node.width = geo.width;\n      node.height = geo.height;\n    }\n  }\n  node.offsetX = 0;\n  node.offsetY = 0;\n  node.contour = new Object();\n  return node;\n};\n\n/**\r\n * Function: apply\r\n */\nmxCompactTreeLayout.prototype.apply = function (node, bounds) {\n  var model = this.graph.getModel();\n  var cell = node.cell;\n  var g = model.getGeometry(cell);\n  if (cell != null && g != null) {\n    if (this.isVertexMovable(cell)) {\n      g = this.setVertexLocation(cell, node.x, node.y);\n      if (this.resizeParent) {\n        var parent = model.getParent(cell);\n        var id = _mxCellPath[\"default\"].create(parent);\n\n        // Implements set semantic\n        if (this.parentsChanged[id] == null) {\n          this.parentsChanged[id] = parent;\n        }\n      }\n    }\n    if (bounds == null) {\n      bounds = new _mxRectangle[\"default\"](g.x, g.y, g.width, g.height);\n    } else {\n      bounds = new _mxRectangle[\"default\"](Math.min(bounds.x, g.x), Math.min(bounds.y, g.y), Math.max(bounds.x + bounds.width, g.x + g.width), Math.max(bounds.y + bounds.height, g.y + g.height));\n    }\n  }\n  return bounds;\n};\n\n/**\r\n * Function: createLine\r\n */\nmxCompactTreeLayout.prototype.createLine = function (dx, dy, next) {\n  var line = new Object();\n  line.dx = dx;\n  line.dy = dy;\n  line.next = next;\n  return line;\n};\n\n/**\r\n * Function: adjustParents\r\n *\r\n * Adjust parent cells whose child geometries have changed. The default\r\n * implementation adjusts the group to just fit around the children with\r\n * a padding.\r\n */\nmxCompactTreeLayout.prototype.adjustParents = function () {\n  var tmp = [];\n  for (var id in this.parentsChanged) {\n    tmp.push(this.parentsChanged[id]);\n  }\n  this.arrangeGroups(_mxUtils[\"default\"].sortCells(tmp, true), this.groupPadding, this.groupPaddingTop, this.groupPaddingRight, this.groupPaddingBottom, this.groupPaddingLeft);\n};\n\n/**\r\n * Function: localEdgeProcessing\r\n *\r\n * Moves the specified node and all of its children by the given amount.\r\n */\nmxCompactTreeLayout.prototype.localEdgeProcessing = function (node) {\n  this.processNodeOutgoing(node);\n  var child = node.child;\n  while (child != null) {\n    this.localEdgeProcessing(child);\n    child = child.next;\n  }\n};\n\n/**\r\n * Function: localEdgeProcessing\r\n *\r\n * Separates the x position of edges as they connect to vertices\r\n */\nmxCompactTreeLayout.prototype.processNodeOutgoing = function (node) {\n  var child = node.child;\n  var parentCell = node.cell;\n  var childCount = 0;\n  var sortedCells = [];\n  while (child != null) {\n    childCount++;\n    var sortingCriterion = child.x;\n    if (this.horizontal) {\n      sortingCriterion = child.y;\n    }\n    sortedCells.push(new _WeightedCellSorter[\"default\"](child, sortingCriterion));\n    child = child.next;\n  }\n  sortedCells.sort(_WeightedCellSorter[\"default\"].prototype.compare);\n  var availableWidth = node.width;\n  var requiredWidth = (childCount + 1) * this.prefHozEdgeSep;\n\n  // Add a buffer on the edges of the vertex if the edge count allows\n  if (availableWidth > requiredWidth + 2 * this.prefHozEdgeSep) {\n    availableWidth -= 2 * this.prefHozEdgeSep;\n  }\n  var edgeSpacing = availableWidth / childCount;\n  var currentXOffset = edgeSpacing / 2.0;\n  if (availableWidth > requiredWidth + 2 * this.prefHozEdgeSep) {\n    currentXOffset += this.prefHozEdgeSep;\n  }\n  var currentYOffset = this.minEdgeJetty - this.prefVertEdgeOff;\n  var maxYOffset = 0;\n  var parentBounds = this.getVertexBounds(parentCell);\n  child = node.child;\n  for (var j = 0; j < sortedCells.length; j++) {\n    var childCell = sortedCells[j].cell.cell;\n    var childBounds = this.getVertexBounds(childCell);\n    var edges = this.graph.getEdgesBetween(parentCell, childCell, false);\n    var newPoints = [];\n    var x = 0;\n    var y = 0;\n    for (var i = 0; i < edges.length; i++) {\n      if (this.horizontal) {\n        // Use opposite co-ords, calculation was done for\n        //\n        x = parentBounds.x + parentBounds.width;\n        y = parentBounds.y + currentXOffset;\n        newPoints.push(new _mxPoint[\"default\"](x, y));\n        x = parentBounds.x + parentBounds.width + currentYOffset;\n        newPoints.push(new _mxPoint[\"default\"](x, y));\n        y = childBounds.y + childBounds.height / 2.0;\n        newPoints.push(new _mxPoint[\"default\"](x, y));\n        this.setEdgePoints(edges[i], newPoints);\n      } else {\n        x = parentBounds.x + currentXOffset;\n        y = parentBounds.y + parentBounds.height;\n        newPoints.push(new _mxPoint[\"default\"](x, y));\n        y = parentBounds.y + parentBounds.height + currentYOffset;\n        newPoints.push(new _mxPoint[\"default\"](x, y));\n        x = childBounds.x + childBounds.width / 2.0;\n        newPoints.push(new _mxPoint[\"default\"](x, y));\n        this.setEdgePoints(edges[i], newPoints);\n      }\n    }\n    if (j < childCount / 2) {\n      currentYOffset += this.prefVertEdgeOff;\n    } else if (j > childCount / 2) {\n      currentYOffset -= this.prefVertEdgeOff;\n    }\n    // Ignore the case if equals, this means the second of 2\n    // jettys with the same y (even number of edges)\n\n    //\t\t\t\t\t\t\t\tpos[k * 2] = currentX;\n    currentXOffset += edgeSpacing;\n    //\t\t\t\t\t\t\t\tpos[k * 2 + 1] = currentYOffset;\n\n    maxYOffset = Math.max(maxYOffset, currentYOffset);\n  }\n};\n\n/**\r\n * Class: WeightedCellSorter\r\n *\r\n * A utility class used to track cells whilst sorting occurs on the weighted\r\n * sum of their connected edges. Does not violate (x.compareTo(y)==0) ==\r\n * (x.equals(y))\r\n *\r\n * Constructor: WeightedCellSorter\r\n *\r\n * Constructs a new weighted cell sorted for the given cell and weight.\r\n */\nvar _default = exports[\"default\"] = mxCompactTreeLayout;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxCompactTreeLayout.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxConnectionConstraint.js":
/*!*********************************************************!*\
  !*** ./src/workflow/mxClient/mxConnectionConstraint.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nfunction mxConnectionConstraint(point, perimeter) {\n  this.point = point;\n  this.perimeter = perimeter != null ? perimeter : true;\n}\n;\n\n/**\r\n * Variable: point\r\n *\r\n * <mxPoint> that specifies the fixed location of the connection point.\r\n */\nmxConnectionConstraint.prototype.point = null;\n\n/**\r\n * Variable: perimeter\r\n *\r\n * Boolean that specifies if the point should be projected onto the perimeter\r\n * of the terminal.\r\n */\nmxConnectionConstraint.prototype.perimeter = null;\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxGraphHandler\r\n *\r\n * Graph event handler that handles selection. Individual cells are handled\r\n * separately using <mxVertexHandler> or one of the edge handlers. These\r\n * handlers are created using <mxGraph.createHandler> in\r\n * <mxGraphSelectionModel.cellAdded>.\r\n *\r\n * To avoid the container to scroll a moved cell into view, set\r\n * <scrollAfterMove> to false.\r\n *\r\n * Constructor: mxGraphHandler\r\n *\r\n * Constructs an event handler that creates handles for the\r\n * selection cells.\r\n *\r\n * Parameters:\r\n *\r\n * graph - Reference to the enclosing <mxGraph>.\r\n */\nvar _default = exports[\"default\"] = mxConnectionConstraint;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxConnectionConstraint.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxConnectionHandler.js":
/*!******************************************************!*\
  !*** ./src/workflow/mxClient/mxConnectionHandler.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.concat.js */ \"../../node_modules/core-js/modules/es.array.concat.js\");\n__webpack_require__(/*! core-js/modules/es.function.bind.js */ \"../../node_modules/core-js/modules/es.function.bind.js\");\nvar _mxCell = _interopRequireDefault(__webpack_require__(/*! ./mxCell.js */ \"./src/workflow/mxClient/mxCell.js\"));\nvar _mxPolyline = _interopRequireDefault(__webpack_require__(/*! ./mxPolyline.js */ \"./src/workflow/mxClient/mxPolyline.js\"));\nvar _mxEventObject = _interopRequireDefault(__webpack_require__(/*! ./mxEventObject.js */ \"./src/workflow/mxClient/mxEventObject.js\"));\nvar _mxEvent = _interopRequireDefault(__webpack_require__(/*! ./mxEvent.js */ \"./src/workflow/mxClient/mxEvent.js\"));\nvar _mxMouseEvent = _interopRequireDefault(__webpack_require__(/*! ./mxMouseEvent.js */ \"./src/workflow/mxClient/mxMouseEvent.js\"));\nvar _mxRectangle = _interopRequireDefault(__webpack_require__(/*! ./mxRectangle.js */ \"./src/workflow/mxClient/mxRectangle.js\"));\nvar _mxGeometry = _interopRequireDefault(__webpack_require__(/*! ./mxGeometry.js */ \"./src/workflow/mxClient/mxGeometry.js\"));\nvar _mxClient = _interopRequireDefault(__webpack_require__(/*! ./mxClient.js */ \"./src/workflow/mxClient/mxClient.js\"));\nvar _mxImageShape = _interopRequireDefault(__webpack_require__(/*! ./mxImageShape.js */ \"./src/workflow/mxClient/mxImageShape.js\"));\nvar _mxPoint = _interopRequireDefault(__webpack_require__(/*! ./mxPoint.js */ \"./src/workflow/mxClient/mxPoint.js\"));\nvar _mxConstraintHandler = _interopRequireDefault(__webpack_require__(/*! ./mxConstraintHandler.js */ \"./src/workflow/mxClient/mxConstraintHandler.js\"));\nvar _mxEventSource = _interopRequireDefault(__webpack_require__(/*! ./mxEventSource.js */ \"./src/workflow/mxClient/mxEventSource.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxCellMarker = _interopRequireDefault(__webpack_require__(/*! ./mxCellMarker.js */ \"./src/workflow/mxClient/mxCellMarker.js\"));\nvar _mxLog = _interopRequireDefault(__webpack_require__(/*! ./mxLog.js */ \"./src/workflow/mxClient/mxLog.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ./mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nvar _mxUtils = _interopRequireDefault(__webpack_require__(/*! ./mxUtils.js */ \"./src/workflow/mxClient/mxUtils.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxConnectionHandler(graph, factoryMethod) {\n  _mxEventSource[\"default\"].call(this);\n  if (graph != null) {\n    this.graph = graph;\n    this.factoryMethod = factoryMethod;\n    this.init();\n\n    // Handles escape keystrokes\n    this.escapeHandler = _mxGraphUtils[\"default\"].bind(this, function (sender, evt) {\n      this.reset();\n    });\n    this.graph.addListener(_mxEvent[\"default\"].ESCAPE, this.escapeHandler);\n  }\n}\n;\n\n/**\r\n * Extends mxEventSource.\r\n */\n_mxGraphUtils[\"default\"].extend(mxConnectionHandler, _mxEventSource[\"default\"]);\n\n/**\r\n * Variable: graph\r\n *\r\n * Reference to the enclosing <mxGraph>.\r\n */\nmxConnectionHandler.prototype.graph = null;\n\n/**\r\n * Variable: factoryMethod\r\n *\r\n * Function that is used for creating new edges. The function takes the\r\n * source and target <mxCell> as the first and second argument and returns\r\n * a new <mxCell> that represents the edge. This is used in <createEdge>.\r\n */\nmxConnectionHandler.prototype.factoryMethod = true;\n\n/**\r\n * Variable: moveIconFront\r\n *\r\n * Specifies if icons should be displayed inside the graph container instead\r\n * of the overlay pane. This is used for HTML labels on vertices which hide\r\n * the connect icon. This has precendence over <moveIconBack> when set\r\n * to true. Default is false.\r\n */\nmxConnectionHandler.prototype.moveIconFront = false;\n\n/**\r\n * Variable: moveIconBack\r\n *\r\n * Specifies if icons should be moved to the back of the overlay pane. This can\r\n * be set to true if the icons of the connection handler conflict with other\r\n * handles, such as the vertex label move handle. Default is false.\r\n */\nmxConnectionHandler.prototype.moveIconBack = false;\n\n/**\r\n * Variable: connectImage\r\n *\r\n * <mxImage> that is used to trigger the creation of a new connection. This\r\n * is used in <createIcons>. Default is null.\r\n */\nmxConnectionHandler.prototype.connectImage = null;\n\n/**\r\n * Variable: targetConnectImage\r\n *\r\n * Specifies if the connect icon should be centered on the target state\r\n * while connections are being previewed. Default is false.\r\n */\nmxConnectionHandler.prototype.targetConnectImage = false;\n\n/**\r\n * Variable: enabled\r\n *\r\n * Specifies if events are handled. Default is true.\r\n */\nmxConnectionHandler.prototype.enabled = true;\n\n/**\r\n * Variable: select\r\n *\r\n * Specifies if new edges should be selected. Default is true.\r\n */\nmxConnectionHandler.prototype.select = true;\n\n/**\r\n * Variable: createTarget\r\n *\r\n * Specifies if <createTargetVertex> should be called if no target was under the\r\n * mouse for the new connection. Setting this to true means the connection\r\n * will be drawn as valid if no target is under the mouse, and\r\n * <createTargetVertex> will be called before the connection is created between\r\n * the source cell and the newly created vertex in <createTargetVertex>, which\r\n * can be overridden to create a new target. Default is false.\r\n */\nmxConnectionHandler.prototype.createTarget = false;\n\n/**\r\n * Variable: marker\r\n *\r\n * Holds the <mxTerminalMarker> used for finding source and target cells.\r\n */\nmxConnectionHandler.prototype.marker = null;\n\n/**\r\n * Variable: constraintHandler\r\n *\r\n * Holds the <mxConstraintHandler> used for drawing and highlighting\r\n * constraints.\r\n */\nmxConnectionHandler.prototype.constraintHandler = null;\n\n/**\r\n * Variable: error\r\n *\r\n * Holds the current validation error while connections are being created.\r\n */\nmxConnectionHandler.prototype.error = null;\n\n/**\r\n * Variable: waypointsEnabled\r\n *\r\n * Specifies if single clicks should add waypoints on the new edge. Default is\r\n * false.\r\n */\nmxConnectionHandler.prototype.waypointsEnabled = false;\n\n/**\r\n * Variable: ignoreMouseDown\r\n *\r\n * Specifies if the connection handler should ignore the state of the mouse\r\n * button when highlighting the source. Default is false, that is, the\r\n * handler only highlights the source if no button is being pressed.\r\n */\nmxConnectionHandler.prototype.ignoreMouseDown = false;\n\n/**\r\n * Variable: first\r\n *\r\n * Holds the <mxPoint> where the mouseDown took place while the handler is\r\n * active.\r\n */\nmxConnectionHandler.prototype.first = null;\n\n/**\r\n * Variable: connectIconOffset\r\n *\r\n * Holds the offset for connect icons during connection preview.\r\n * Default is mxPoint(0, <mxConstants.TOOLTIP_VERTICAL_OFFSET>).\r\n * Note that placing the icon under the mouse pointer with an\r\n * offset of (0,0) will affect hit detection.\r\n */\nmxConnectionHandler.prototype.connectIconOffset = new _mxPoint[\"default\"](0, _mxConstants[\"default\"].TOOLTIP_VERTICAL_OFFSET);\n\n/**\r\n * Variable: edgeState\r\n *\r\n * Optional <mxCellState> that represents the preview edge while the\r\n * handler is active. This is created in <createEdgeState>.\r\n */\nmxConnectionHandler.prototype.edgeState = null;\n\n/**\r\n * Variable: changeHandler\r\n *\r\n * Holds the change event listener for later removal.\r\n */\nmxConnectionHandler.prototype.changeHandler = null;\n\n/**\r\n * Variable: drillHandler\r\n *\r\n * Holds the drill event listener for later removal.\r\n */\nmxConnectionHandler.prototype.drillHandler = null;\n\n/**\r\n * Variable: mouseDownCounter\r\n *\r\n * Counts the number of mouseDown events since the start. The initial mouse\r\n * down event counts as 1.\r\n */\nmxConnectionHandler.prototype.mouseDownCounter = 0;\n\n/**\r\n * Variable: movePreviewAway\r\n *\r\n * Switch to enable moving the preview away from the mousepointer. This is required in browsers\r\n * where the preview cannot be made transparent to events and if the built-in hit detection on\r\n * the HTML elements in the page should be used. Default is the value of <mxClient.IS_VML>.\r\n */\nmxConnectionHandler.prototype.movePreviewAway = _mxClient[\"default\"].IS_VML;\n\n/**\r\n * Variable: outlineConnect\r\n *\r\n * Specifies if connections to the outline of a highlighted target should be\r\n * enabled. This will allow to place the connection point along the outline of\r\n * the highlighted target. Default is false.\r\n */\nmxConnectionHandler.prototype.outlineConnect = false;\n\n/**\r\n * Variable: livePreview\r\n *\r\n * Specifies if the actual shape of the edge state should be used for the preview.\r\n * Default is false. (Ignored if no edge state is created in <createEdgeState>.)\r\n */\nmxConnectionHandler.prototype.livePreview = false;\n\n/**\r\n * Variable: cursor\r\n *\r\n * Specifies the cursor to be used while the handler is active. Default is null.\r\n */\nmxConnectionHandler.prototype.cursor = null;\n\n/**\r\n * Variable: insertBeforeSource\r\n *\r\n * Specifies if new edges should be inserted before the source vertex in the\r\n * cell hierarchy. Default is false for backwards compatibility.\r\n */\nmxConnectionHandler.prototype.insertBeforeSource = false;\n\n/**\r\n * Function: isEnabled\r\n *\r\n * Returns true if events are handled. This implementation\r\n * returns <enabled>.\r\n */\nmxConnectionHandler.prototype.isEnabled = function () {\n  return this.enabled;\n};\n\n/**\r\n * Function: setEnabled\r\n *\r\n * Enables or disables event handling. This implementation\r\n * updates <enabled>.\r\n *\r\n * Parameters:\r\n *\r\n * enabled - Boolean that specifies the new enabled state.\r\n */\nmxConnectionHandler.prototype.setEnabled = function (enabled) {\n  this.enabled = enabled;\n};\n\n/**\r\n * Function: isInsertBefore\r\n *\r\n * Returns <insertBeforeSource> for non-loops and false for loops.\r\n *\r\n * Parameters:\r\n *\r\n * edge - <mxCell> that represents the edge to be inserted.\r\n * source - <mxCell> that represents the source terminal.\r\n * target - <mxCell> that represents the target terminal.\r\n * evt - Mousedown event of the connect gesture.\r\n * dropTarget - <mxCell> that represents the cell under the mouse when it was\r\n * released.\r\n */\nmxConnectionHandler.prototype.isInsertBefore = function (edge, source, target, evt, dropTarget) {\n  return this.insertBeforeSource && source != target;\n};\n\n/**\r\n * Function: isCreateTarget\r\n *\r\n * Returns <createTarget>.\r\n *\r\n * Parameters:\r\n *\r\n * evt - Current active native pointer event.\r\n */\nmxConnectionHandler.prototype.isCreateTarget = function (evt) {\n  return this.createTarget;\n};\n\n/**\r\n * Function: setCreateTarget\r\n *\r\n * Sets <createTarget>.\r\n */\nmxConnectionHandler.prototype.setCreateTarget = function (value) {\n  this.createTarget = value;\n};\n\n/**\r\n * Function: createShape\r\n *\r\n * Creates the preview shape for new connections.\r\n */\nmxConnectionHandler.prototype.createShape = function () {\n  // Creates the edge preview\n  var shape = this.livePreview && this.edgeState != null ? this.graph.cellRenderer.createShape(this.edgeState) : new _mxPolyline[\"default\"]([], _mxConstants[\"default\"].INVALID_COLOR);\n  shape.dialect = this.graph.dialect != _mxConstants[\"default\"].DIALECT_SVG ? _mxConstants[\"default\"].DIALECT_VML : _mxConstants[\"default\"].DIALECT_SVG;\n  shape.scale = this.graph.view.scale;\n  shape.pointerEvents = false;\n  shape.isDashed = true;\n  shape.init(this.graph.getView().getOverlayPane());\n  _mxEvent[\"default\"].redirectMouseEvents(shape.node, this.graph, null);\n  return shape;\n};\n\n/**\r\n * Function: init\r\n *\r\n * Initializes the shapes required for this connection handler. This should\r\n * be invoked if <mxGraph.container> is assigned after the connection\r\n * handler has been created.\r\n */\nmxConnectionHandler.prototype.init = function () {\n  this.graph.addMouseListener(this);\n  this.marker = this.createMarker();\n  this.constraintHandler = new _mxConstraintHandler[\"default\"](this.graph);\n\n  // Redraws the icons if the graph changes\n  this.changeHandler = _mxGraphUtils[\"default\"].bind(this, function (sender) {\n    if (this.iconState != null) {\n      this.iconState = this.graph.getView().getState(this.iconState.cell);\n    }\n    if (this.iconState != null) {\n      this.redrawIcons(this.icons, this.iconState);\n      this.constraintHandler.reset();\n    } else if (this.previous != null && this.graph.view.getState(this.previous.cell) == null) {\n      this.reset();\n    }\n  });\n  this.graph.getModel().addListener(_mxEvent[\"default\"].CHANGE, this.changeHandler);\n  this.graph.getView().addListener(_mxEvent[\"default\"].SCALE, this.changeHandler);\n  this.graph.getView().addListener(_mxEvent[\"default\"].TRANSLATE, this.changeHandler);\n  this.graph.getView().addListener(_mxEvent[\"default\"].SCALE_AND_TRANSLATE, this.changeHandler);\n\n  // Removes the icon if we step into/up or start editing\n  this.drillHandler = _mxGraphUtils[\"default\"].bind(this, function (sender) {\n    this.reset();\n  });\n  this.graph.addListener(_mxEvent[\"default\"].START_EDITING, this.drillHandler);\n  this.graph.getView().addListener(_mxEvent[\"default\"].DOWN, this.drillHandler);\n  this.graph.getView().addListener(_mxEvent[\"default\"].UP, this.drillHandler);\n};\n\n/**\r\n * Function: isConnectableCell\r\n *\r\n * Returns true if the given cell is connectable. This is a hook to\r\n * disable floating connections. This implementation returns true.\r\n */\nmxConnectionHandler.prototype.isConnectableCell = function (cell) {\n  return true;\n};\n\n/**\r\n * Function: createMarker\r\n *\r\n * Creates and returns the <mxCellMarker> used in <marker>.\r\n */\nmxConnectionHandler.prototype.createMarker = function () {\n  var marker = new _mxCellMarker[\"default\"](this.graph);\n  marker.hotspotEnabled = true;\n\n  // Overrides to return cell at location only if valid (so that\n  // there is no highlight for invalid cells)\n  marker.getCell = _mxGraphUtils[\"default\"].bind(this, function (me) {\n    var cell = _mxCellMarker[\"default\"].prototype.getCell.apply(marker, arguments);\n    this.error = null;\n\n    // Checks for cell at preview point (with grid)\n    if (cell == null && this.currentPoint != null) {\n      cell = this.graph.getCellAt(this.currentPoint.x, this.currentPoint.y);\n    }\n\n    // Uses connectable parent vertex if one exists\n    if (cell != null && !this.graph.isCellConnectable(cell)) {\n      var parent = this.graph.getModel().getParent(cell);\n      if (this.graph.getModel().isVertex(parent) && this.graph.isCellConnectable(parent)) {\n        cell = parent;\n      }\n    }\n    if (this.graph.isSwimlane(cell) && this.currentPoint != null && this.graph.hitsSwimlaneContent(cell, this.currentPoint.x, this.currentPoint.y) || !this.isConnectableCell(cell)) {\n      cell = null;\n    }\n    if (cell != null) {\n      if (this.isConnecting()) {\n        if (this.previous != null) {\n          this.error = this.validateConnection(this.previous.cell, cell);\n          if (this.error != null && this.error.length == 0) {\n            cell = null;\n\n            // Enables create target inside groups\n            if (this.isCreateTarget(me.getEvent())) {\n              this.error = null;\n            }\n          }\n        }\n      } else if (!this.isValidSource(cell, me)) {\n        cell = null;\n      }\n    } else if (this.isConnecting() && !this.isCreateTarget(me.getEvent()) && !this.graph.allowDanglingEdges) {\n      this.error = '';\n    }\n    return cell;\n  });\n\n  // Sets the highlight color according to validateConnection\n  marker.isValidState = _mxGraphUtils[\"default\"].bind(this, function (state) {\n    if (this.isConnecting()) {\n      return this.error == null;\n    } else {\n      return _mxCellMarker[\"default\"].prototype.isValidState.apply(marker, arguments);\n    }\n  });\n\n  // Overrides to use marker color only in highlight mode or for\n  // target selection\n  marker.getMarkerColor = _mxGraphUtils[\"default\"].bind(this, function (evt, state, isValid) {\n    return this.connectImage == null || this.isConnecting() ? _mxCellMarker[\"default\"].prototype.getMarkerColor.apply(marker, arguments) : null;\n  });\n\n  // Overrides to use hotspot only for source selection otherwise\n  // intersects always returns true when over a cell\n  marker.intersects = _mxGraphUtils[\"default\"].bind(this, function (state, evt) {\n    if (this.connectImage != null || this.isConnecting()) {\n      return true;\n    }\n    return _mxCellMarker[\"default\"].prototype.intersects.apply(marker, arguments);\n  });\n  return marker;\n};\n\n/**\r\n * Function: start\r\n *\r\n * Starts a new connection for the given state and coordinates.\r\n */\nmxConnectionHandler.prototype.start = function (state, x, y, edgeState) {\n  this.previous = state;\n  this.first = new _mxPoint[\"default\"](x, y);\n  this.edgeState = edgeState != null ? edgeState : this.createEdgeState(null);\n\n  // Marks the source state\n  this.marker.currentColor = this.marker.validColor;\n  this.marker.markedState = state;\n  this.marker.mark();\n  this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].START, 'state', this.previous));\n};\n\n/**\r\n * Function: isConnecting\r\n *\r\n * Returns true if the source terminal has been clicked and a new\r\n * connection is currently being previewed.\r\n */\nmxConnectionHandler.prototype.isConnecting = function () {\n  return this.first != null && this.shape != null;\n};\n\n/**\r\n * Function: isValidSource\r\n *\r\n * Returns <mxGraph.isValidSource> for the given source terminal.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> that represents the source terminal.\r\n * me - <mxMouseEvent> that is associated with this call.\r\n */\nmxConnectionHandler.prototype.isValidSource = function (cell, me) {\n  return this.graph.isValidSource(cell);\n};\n\n/**\r\n * Function: isValidTarget\r\n *\r\n * Returns true. The call to <mxGraph.isValidTarget> is implicit by calling\r\n * <mxGraph.getEdgeValidationError> in <validateConnection>. This is an\r\n * additional hook for disabling certain targets in this specific handler.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> that represents the target terminal.\r\n */\nmxConnectionHandler.prototype.isValidTarget = function (cell) {\n  return true;\n};\n\n/**\r\n * Function: validateConnection\r\n *\r\n * Returns the error message or an empty string if the connection for the\r\n * given source target pair is not valid. Otherwise it returns null. This\r\n * implementation uses <mxGraph.getEdgeValidationError>.\r\n *\r\n * Parameters:\r\n *\r\n * source - <mxCell> that represents the source terminal.\r\n * target - <mxCell> that represents the target terminal.\r\n */\nmxConnectionHandler.prototype.validateConnection = function (source, target) {\n  if (!this.isValidTarget(target)) {\n    return '';\n  }\n  return this.graph.getEdgeValidationError(null, source, target);\n};\n\n/**\r\n * Function: getConnectImage\r\n *\r\n * Hook to return the <mxImage> used for the connection icon of the given\r\n * <mxCellState>. This implementation returns <connectImage>.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> whose connect image should be returned.\r\n */\nmxConnectionHandler.prototype.getConnectImage = function (state) {\n  return this.connectImage;\n};\n\n/**\r\n * Function: isMoveIconToFrontForState\r\n *\r\n * Returns true if the state has a HTML label in the graph's container, otherwise\r\n * it returns <moveIconFront>.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> whose connect icons should be returned.\r\n */\nmxConnectionHandler.prototype.isMoveIconToFrontForState = function (state) {\n  if (state.text != null && state.text.node.parentNode == this.graph.container) {\n    return true;\n  }\n  return this.moveIconFront;\n};\n\n/**\r\n * Function: createIcons\r\n *\r\n * Creates the array <mxImageShapes> that represent the connect icons for\r\n * the given <mxCellState>.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> whose connect icons should be returned.\r\n */\nmxConnectionHandler.prototype.createIcons = function (state) {\n  var image = this.getConnectImage(state);\n  if (image != null && state != null) {\n    this.iconState = state;\n    var icons = [];\n\n    // Cannot use HTML for the connect icons because the icon receives all\n    // mouse move events in IE, must use VML and SVG instead even if the\n    // connect-icon appears behind the selection border and the selection\n    // border consumes the events before the icon gets a chance\n    var bounds = new _mxRectangle[\"default\"](0, 0, image.width, image.height);\n    var icon = new _mxImageShape[\"default\"](bounds, image.src, null, null, 0);\n    icon.preserveImageAspect = false;\n    if (this.isMoveIconToFrontForState(state)) {\n      icon.dialect = _mxConstants[\"default\"].DIALECT_STRICTHTML;\n      icon.init(this.graph.container);\n    } else {\n      icon.dialect = this.graph.dialect == _mxConstants[\"default\"].DIALECT_SVG ? _mxConstants[\"default\"].DIALECT_SVG : _mxConstants[\"default\"].DIALECT_VML;\n      icon.init(this.graph.getView().getOverlayPane());\n\n      // Move the icon back in the overlay pane\n      if (this.moveIconBack && icon.node.previousSibling != null) {\n        icon.node.parentNode.insertBefore(icon.node, icon.node.parentNode.firstChild);\n      }\n    }\n    icon.node.style.cursor = _mxConstants[\"default\"].CURSOR_CONNECT;\n\n    // Events transparency\n    var getState = _mxGraphUtils[\"default\"].bind(this, function () {\n      return this.currentState != null ? this.currentState : state;\n    });\n\n    // Updates the local icon before firing the mouse down event.\n    var mouseDown = _mxGraphUtils[\"default\"].bind(this, function (evt) {\n      if (!_mxEvent[\"default\"].isConsumed(evt)) {\n        this.icon = icon;\n        this.graph.fireMouseEvent(_mxEvent[\"default\"].MOUSE_DOWN, new _mxMouseEvent[\"default\"](evt, getState()));\n      }\n    });\n    _mxEvent[\"default\"].redirectMouseEvents(icon.node, this.graph, getState, mouseDown);\n    icons.push(icon);\n    this.redrawIcons(icons, this.iconState);\n    return icons;\n  }\n  return null;\n};\n\n/**\r\n * Function: redrawIcons\r\n *\r\n * Redraws the given array of <mxImageShapes>.\r\n *\r\n * Parameters:\r\n *\r\n * icons - Optional array of <mxImageShapes> to be redrawn.\r\n */\nmxConnectionHandler.prototype.redrawIcons = function (icons, state) {\n  if (icons != null && icons[0] != null && state != null) {\n    var pos = this.getIconPosition(icons[0], state);\n    icons[0].bounds.x = pos.x;\n    icons[0].bounds.y = pos.y;\n    icons[0].redraw();\n  }\n};\n\n/**\r\n * Function: redrawIcons\r\n *\r\n * Redraws the given array of <mxImageShapes>.\r\n *\r\n * Parameters:\r\n *\r\n * icons - Optional array of <mxImageShapes> to be redrawn.\r\n */\nmxConnectionHandler.prototype.getIconPosition = function (icon, state) {\n  var scale = this.graph.getView().scale;\n  var cx = state.getCenterX();\n  var cy = state.getCenterY();\n  if (this.graph.isSwimlane(state.cell)) {\n    var size = this.graph.getStartSize(state.cell);\n    cx = size.width != 0 ? state.x + size.width * scale / 2 : cx;\n    cy = size.height != 0 ? state.y + size.height * scale / 2 : cy;\n    var alpha = _mxUtils[\"default\"].toRadians(_mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_ROTATION) || 0);\n    if (alpha != 0) {\n      var cos = Math.cos(alpha);\n      var sin = Math.sin(alpha);\n      var ct = new _mxPoint[\"default\"](state.getCenterX(), state.getCenterY());\n      var pt = _mxUtils[\"default\"].getRotatedPoint(new _mxPoint[\"default\"](cx, cy), cos, sin, ct);\n      cx = pt.x;\n      cy = pt.y;\n    }\n  }\n  return new _mxPoint[\"default\"](cx - icon.bounds.width / 2, cy - icon.bounds.height / 2);\n};\n\n/**\r\n * Function: destroyIcons\r\n *\r\n * Destroys the connect icons and resets the respective state.\r\n */\nmxConnectionHandler.prototype.destroyIcons = function () {\n  if (this.icons != null) {\n    for (var i = 0; i < this.icons.length; i++) {\n      this.icons[i].destroy();\n    }\n    this.icons = null;\n    this.icon = null;\n    this.selectedIcon = null;\n    this.iconState = null;\n  }\n};\n\n/**\r\n * Function: isStartEvent\r\n *\r\n * Returns true if the given mouse down event should start this handler. The\r\n * This implementation returns true if the event does not force marquee\r\n * selection, and the currentConstraint and currentFocus of the\r\n * <constraintHandler> are not null, or <previous> and <error> are not null and\r\n * <icons> is null or <icons> and <icon> are not null.\r\n */\nmxConnectionHandler.prototype.isStartEvent = function (me) {\n  return this.constraintHandler.currentFocus != null && this.constraintHandler.currentConstraint != null || this.previous != null && this.error == null && (this.icons == null || this.icons != null && this.icon != null);\n};\n\n/**\r\n * Function: mouseDown\r\n *\r\n * Handles the event by initiating a new connection.\r\n */\nmxConnectionHandler.prototype.mouseDown = function (sender, me) {\n  this.mouseDownCounter++;\n  if (this.isEnabled() && this.graph.isEnabled() && !me.isConsumed() && !this.isConnecting() && this.isStartEvent(me)) {\n    if (this.constraintHandler.currentConstraint != null && this.constraintHandler.currentFocus != null && this.constraintHandler.currentPoint != null) {\n      this.sourceConstraint = this.constraintHandler.currentConstraint;\n      this.previous = this.constraintHandler.currentFocus;\n      this.first = this.constraintHandler.currentPoint.clone();\n    } else {\n      // Stores the location of the initial mousedown\n      this.first = new _mxPoint[\"default\"](me.getGraphX(), me.getGraphY());\n    }\n    this.edgeState = this.createEdgeState(me);\n    this.mouseDownCounter = 1;\n    if (this.waypointsEnabled && this.shape == null) {\n      this.waypoints = null;\n      this.shape = this.createShape();\n      if (this.edgeState != null) {\n        this.shape.apply(this.edgeState);\n      }\n    }\n\n    // Stores the starting point in the geometry of the preview\n    if (this.previous == null && this.edgeState != null) {\n      var pt = this.graph.getPointForEvent(me.getEvent());\n      this.edgeState.cell.geometry.setTerminalPoint(pt, true);\n    }\n    this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].START, 'state', this.previous));\n    me.consume();\n  }\n  this.selectedIcon = this.icon;\n  this.icon = null;\n};\n\n/**\r\n * Function: isImmediateConnectSource\r\n *\r\n * Returns true if a tap on the given source state should immediately start\r\n * connecting. This implementation returns true if the state is not movable\r\n * in the graph.\r\n */\nmxConnectionHandler.prototype.isImmediateConnectSource = function (state) {\n  return !this.graph.isCellMovable(state.cell);\n};\n\n/**\r\n * Function: createEdgeState\r\n *\r\n * Hook to return an <mxCellState> which may be used during the preview.\r\n * This implementation returns null.\r\n *\r\n * Use the following code to create a preview for an existing edge style:\r\n *\r\n * (code)\r\n * graph.connectionHandler.createEdgeState = function(me)\r\n * {\r\n *   var edge = graph.createEdge(null, null, null, null, null, 'edgeStyle=elbowEdgeStyle');\r\n *\r\n *   return new mxCellState(this.graph.view, edge, this.graph.getCellStyle(edge));\r\n * };\r\n * (end)\r\n */\nmxConnectionHandler.prototype.createEdgeState = function (me) {\n  return null;\n};\n\n/**\r\n * Function: isOutlineConnectEvent\r\n *\r\n * Returns true if <outlineConnect> is true and the source of the event is the outline shape\r\n * or shift is pressed.\r\n */\nmxConnectionHandler.prototype.isOutlineConnectEvent = function (me) {\n  var offset = _mxUtils[\"default\"].getOffset(this.graph.container);\n  var evt = me.getEvent();\n  var clientX = _mxEvent[\"default\"].getClientX(evt);\n  var clientY = _mxEvent[\"default\"].getClientY(evt);\n  var doc = document.documentElement;\n  var left = (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);\n  var top = (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);\n  var gridX = this.currentPoint.x - this.graph.container.scrollLeft + offset.x - left;\n  var gridY = this.currentPoint.y - this.graph.container.scrollTop + offset.y - top;\n  return this.outlineConnect && !_mxEvent[\"default\"].isShiftDown(me.getEvent()) && (me.isSource(this.marker.highlight.shape) || _mxEvent[\"default\"].isAltDown(me.getEvent()) && me.getState() != null || this.marker.highlight.isHighlightAt(clientX, clientY) || (gridX != clientX || gridY != clientY) && me.getState() == null && this.marker.highlight.isHighlightAt(gridX, gridY));\n};\n\n/**\r\n * Function: updateCurrentState\r\n *\r\n * Updates the current state for a given mouse move event by using\r\n * the <marker>.\r\n */\nmxConnectionHandler.prototype.updateCurrentState = function (me, point) {\n  this.constraintHandler.update(me, this.first == null, false, this.first == null || me.isSource(this.marker.highlight.shape) ? null : point);\n  if (this.constraintHandler.currentFocus != null && this.constraintHandler.currentConstraint != null) {\n    // Handles special case where grid is large and connection point is at actual point in which\n    // case the outline is not followed as long as we're < gridSize / 2 away from that point\n    if (this.marker.highlight != null && this.marker.highlight.state != null && this.marker.highlight.state.cell == this.constraintHandler.currentFocus.cell) {\n      // Direct repaint needed if cell already highlighted\n      if (this.marker.highlight.shape.stroke != 'transparent') {\n        this.marker.highlight.shape.stroke = 'transparent';\n        this.marker.highlight.repaint();\n      }\n    } else {\n      this.marker.markCell(this.constraintHandler.currentFocus.cell, 'transparent');\n    }\n\n    // Updates validation state\n    if (this.previous != null) {\n      this.error = this.validateConnection(this.previous.cell, this.constraintHandler.currentFocus.cell);\n      if (this.error == null) {\n        this.currentState = this.constraintHandler.currentFocus;\n      } else {\n        this.constraintHandler.reset();\n      }\n    }\n  } else {\n    if (this.graph.isIgnoreTerminalEvent(me.getEvent())) {\n      this.marker.reset();\n      this.currentState = null;\n    } else {\n      this.marker.process(me);\n      this.currentState = this.marker.getValidState();\n    }\n    var outline = this.isOutlineConnectEvent(me);\n    if (this.currentState != null && outline) {\n      // Handles special case where mouse is on outline away from actual end point\n      // in which case the grid is ignored and mouse point is used instead\n      if (me.isSource(this.marker.highlight.shape)) {\n        point = new _mxPoint[\"default\"](me.getGraphX(), me.getGraphY());\n      }\n      var constraint = this.graph.getOutlineConstraint(point, this.currentState, me);\n      this.constraintHandler.setFocus(me, this.currentState, false);\n      this.constraintHandler.currentConstraint = constraint;\n      this.constraintHandler.currentPoint = point;\n    }\n    if (this.outlineConnect) {\n      if (this.marker.highlight != null && this.marker.highlight.shape != null) {\n        var s = this.graph.view.scale;\n        if (this.constraintHandler.currentConstraint != null && this.constraintHandler.currentFocus != null) {\n          this.marker.highlight.shape.stroke = _mxConstants[\"default\"].OUTLINE_HIGHLIGHT_COLOR;\n          this.marker.highlight.shape.strokewidth = _mxConstants[\"default\"].OUTLINE_HIGHLIGHT_STROKEWIDTH / s / s;\n          this.marker.highlight.repaint();\n        } else if (this.marker.hasValidState()) {\n          // Handles special case where actual end point of edge and current mouse point\n          // are not equal (due to grid snapping) and there is no hit on shape or highlight\n          if (this.marker.getValidState() != me.getState()) {\n            this.marker.highlight.shape.stroke = 'transparent';\n            this.currentState = null;\n          } else {\n            this.marker.highlight.shape.stroke = _mxConstants[\"default\"].DEFAULT_VALID_COLOR;\n          }\n          this.marker.highlight.shape.strokewidth = _mxConstants[\"default\"].HIGHLIGHT_STROKEWIDTH / s / s;\n          this.marker.highlight.repaint();\n        }\n      }\n    }\n  }\n};\n\n/**\r\n * Function: convertWaypoint\r\n *\r\n * Converts the given point from screen coordinates to model coordinates.\r\n */\nmxConnectionHandler.prototype.convertWaypoint = function (point) {\n  var scale = this.graph.getView().getScale();\n  var tr = this.graph.getView().getTranslate();\n  point.x = point.x / scale - tr.x;\n  point.y = point.y / scale - tr.y;\n};\n\n/**\r\n * Function: snapToPreview\r\n *\r\n * Called to snap the given point to the current preview. This snaps to the\r\n * first point of the preview if alt is not pressed.\r\n */\nmxConnectionHandler.prototype.snapToPreview = function (me, point) {\n  if (!_mxEvent[\"default\"].isAltDown(me.getEvent()) && this.previous != null) {\n    var tol = this.graph.gridSize * this.graph.view.scale / 2;\n    var tmp = this.sourceConstraint != null ? this.first : new _mxPoint[\"default\"](this.previous.getCenterX(), this.previous.getCenterY());\n    if (Math.abs(tmp.x - me.getGraphX()) < tol) {\n      point.x = tmp.x;\n    }\n    if (Math.abs(tmp.y - me.getGraphY()) < tol) {\n      point.y = tmp.y;\n    }\n  }\n};\n\n/**\r\n * Function: mouseMove\r\n *\r\n * Handles the event by updating the preview edge or by highlighting\r\n * a possible source or target terminal.\r\n */\nmxConnectionHandler.prototype.mouseMove = function (sender, me) {\n  if (!me.isConsumed() && (this.ignoreMouseDown || this.first != null || !this.graph.isMouseDown)) {\n    // Handles special case when handler is disabled during highlight\n    if (!this.isEnabled() && this.currentState != null) {\n      this.destroyIcons();\n      this.currentState = null;\n    }\n    var view = this.graph.getView();\n    var scale = view.scale;\n    var tr = view.translate;\n    var point = new _mxPoint[\"default\"](me.getGraphX(), me.getGraphY());\n    this.error = null;\n    if (this.graph.isGridEnabledEvent(me.getEvent())) {\n      point = new _mxPoint[\"default\"]((this.graph.snap(point.x / scale - tr.x) + tr.x) * scale, (this.graph.snap(point.y / scale - tr.y) + tr.y) * scale);\n    }\n    this.snapToPreview(me, point);\n    this.currentPoint = point;\n    if (this.first != null || this.isEnabled() && this.graph.isEnabled()) {\n      this.updateCurrentState(me, point);\n    }\n    if (this.first != null) {\n      var constraint = null;\n      var current = point;\n\n      // Uses the current point from the constraint handler if available\n      if (this.constraintHandler.currentConstraint != null && this.constraintHandler.currentFocus != null && this.constraintHandler.currentPoint != null) {\n        constraint = this.constraintHandler.currentConstraint;\n        current = this.constraintHandler.currentPoint.clone();\n      } else if (this.previous != null && !this.graph.isIgnoreTerminalEvent(me.getEvent()) && _mxEvent[\"default\"].isShiftDown(me.getEvent())) {\n        if (Math.abs(this.previous.getCenterX() - point.x) < Math.abs(this.previous.getCenterY() - point.y)) {\n          point.x = this.previous.getCenterX();\n        } else {\n          point.y = this.previous.getCenterY();\n        }\n      }\n      var pt2 = this.first;\n\n      // Moves the connect icon with the mouse\n      if (this.selectedIcon != null) {\n        var w = this.selectedIcon.bounds.width;\n        var h = this.selectedIcon.bounds.height;\n        if (this.currentState != null && this.targetConnectImage) {\n          var pos = this.getIconPosition(this.selectedIcon, this.currentState);\n          this.selectedIcon.bounds.x = pos.x;\n          this.selectedIcon.bounds.y = pos.y;\n        } else {\n          var bounds = new _mxRectangle[\"default\"](me.getGraphX() + this.connectIconOffset.x, me.getGraphY() + this.connectIconOffset.y, w, h);\n          this.selectedIcon.bounds = bounds;\n        }\n        this.selectedIcon.redraw();\n      }\n\n      // Uses edge state to compute the terminal points\n      if (this.edgeState != null) {\n        this.updateEdgeState(current, constraint);\n        current = this.edgeState.absolutePoints[this.edgeState.absolutePoints.length - 1];\n        pt2 = this.edgeState.absolutePoints[0];\n      } else {\n        if (this.currentState != null) {\n          if (this.constraintHandler.currentConstraint == null) {\n            var tmp = this.getTargetPerimeterPoint(this.currentState, me);\n            if (tmp != null) {\n              current = tmp;\n            }\n          }\n        }\n\n        // Computes the source perimeter point\n        if (this.sourceConstraint == null && this.previous != null) {\n          var next = this.waypoints != null && this.waypoints.length > 0 ? this.waypoints[0] : current;\n          var tmp = this.getSourcePerimeterPoint(this.previous, next, me);\n          if (tmp != null) {\n            pt2 = tmp;\n          }\n        }\n      }\n\n      // Makes sure the cell under the mousepointer can be detected\n      // by moving the preview shape away from the mouse. This\n      // makes sure the preview shape does not prevent the detection\n      // of the cell under the mousepointer even for slow gestures.\n      if (this.currentState == null && this.movePreviewAway) {\n        var tmp = pt2;\n        if (this.edgeState != null && this.edgeState.absolutePoints.length >= 2) {\n          var tmp2 = this.edgeState.absolutePoints[this.edgeState.absolutePoints.length - 2];\n          if (tmp2 != null) {\n            tmp = tmp2;\n          }\n        }\n        var dx = current.x - tmp.x;\n        var dy = current.y - tmp.y;\n        var len = Math.sqrt(dx * dx + dy * dy);\n        if (len == 0) {\n          return;\n        }\n\n        // Stores old point to reuse when creating edge\n        this.originalPoint = current.clone();\n        current.x -= dx * 4 / len;\n        current.y -= dy * 4 / len;\n      } else {\n        this.originalPoint = null;\n      }\n\n      // Creates the preview shape (lazy)\n      if (this.shape == null) {\n        var dx = Math.abs(point.x - this.first.x);\n        var dy = Math.abs(point.y - this.first.y);\n        if (dx > this.graph.tolerance || dy > this.graph.tolerance) {\n          this.shape = this.createShape();\n          if (this.edgeState != null) {\n            this.shape.apply(this.edgeState);\n          }\n\n          // Revalidates current connection\n          this.updateCurrentState(me, point);\n        }\n      }\n\n      // Updates the points in the preview edge\n      if (this.shape != null) {\n        if (this.edgeState != null) {\n          this.shape.points = this.edgeState.absolutePoints;\n        } else {\n          var pts = [pt2];\n          if (this.waypoints != null) {\n            pts = pts.concat(this.waypoints);\n          }\n          pts.push(current);\n          this.shape.points = pts;\n        }\n        this.drawPreview();\n      }\n\n      // Makes sure endpoint of edge is visible during connect\n      if (this.cursor != null) {\n        this.graph.container.style.cursor = this.cursor;\n      }\n      _mxEvent[\"default\"].consume(me.getEvent());\n      me.consume();\n    } else if (!this.isEnabled() || !this.graph.isEnabled()) {\n      this.constraintHandler.reset();\n    } else if (this.previous != this.currentState && this.edgeState == null) {\n      this.destroyIcons();\n\n      // Sets the cursor on the current shape\n      if (this.currentState != null && this.error == null && this.constraintHandler.currentConstraint == null) {\n        this.icons = this.createIcons(this.currentState);\n        if (this.icons == null) {\n          this.currentState.setCursor(_mxConstants[\"default\"].CURSOR_CONNECT);\n          me.consume();\n        }\n      }\n      this.previous = this.currentState;\n    } else if (this.previous == this.currentState && this.currentState != null && this.icons == null && !this.graph.isMouseDown) {\n      // Makes sure that no cursors are changed\n      me.consume();\n    }\n    if (!this.graph.isMouseDown && this.currentState != null && this.icons != null) {\n      var hitsIcon = false;\n      var target = me.getSource();\n      for (var i = 0; i < this.icons.length && !hitsIcon; i++) {\n        hitsIcon = target == this.icons[i].node || target.parentNode == this.icons[i].node;\n      }\n      if (!hitsIcon) {\n        this.updateIcons(this.currentState, this.icons, me);\n      }\n    }\n  } else {\n    this.constraintHandler.reset();\n  }\n};\n\n/**\r\n * Function: updateEdgeState\r\n *\r\n * Updates <edgeState>.\r\n */\nmxConnectionHandler.prototype.updateEdgeState = function (current, constraint) {\n  // TODO: Use generic method for writing constraint to style\n  if (this.sourceConstraint != null && this.sourceConstraint.point != null) {\n    this.edgeState.style[_mxConstants[\"default\"].STYLE_EXIT_X] = this.sourceConstraint.point.x;\n    this.edgeState.style[_mxConstants[\"default\"].STYLE_EXIT_Y] = this.sourceConstraint.point.y;\n  }\n  if (constraint != null && constraint.point != null) {\n    this.edgeState.style[_mxConstants[\"default\"].STYLE_ENTRY_X] = constraint.point.x;\n    this.edgeState.style[_mxConstants[\"default\"].STYLE_ENTRY_Y] = constraint.point.y;\n  } else {\n    delete this.edgeState.style[_mxConstants[\"default\"].STYLE_ENTRY_X];\n    delete this.edgeState.style[_mxConstants[\"default\"].STYLE_ENTRY_Y];\n  }\n  this.edgeState.absolutePoints = [null, this.currentState != null ? null : current];\n  this.graph.view.updateFixedTerminalPoint(this.edgeState, this.previous, true, this.sourceConstraint);\n  if (this.currentState != null) {\n    if (constraint == null) {\n      constraint = this.graph.getConnectionConstraint(this.edgeState, this.previous, false);\n    }\n    this.edgeState.setAbsoluteTerminalPoint(null, false);\n    this.graph.view.updateFixedTerminalPoint(this.edgeState, this.currentState, false, constraint);\n  }\n\n  // Scales and translates the waypoints to the model\n  var realPoints = null;\n  if (this.waypoints != null) {\n    realPoints = [];\n    for (var i = 0; i < this.waypoints.length; i++) {\n      var pt = this.waypoints[i].clone();\n      this.convertWaypoint(pt);\n      realPoints[i] = pt;\n    }\n  }\n  this.graph.view.updatePoints(this.edgeState, realPoints, this.previous, this.currentState);\n  this.graph.view.updateFloatingTerminalPoints(this.edgeState, this.previous, this.currentState);\n};\n\n/**\r\n * Function: getTargetPerimeterPoint\r\n *\r\n * Returns the perimeter point for the given target state.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> that represents the target cell state.\r\n * me - <mxMouseEvent> that represents the mouse move.\r\n */\nmxConnectionHandler.prototype.getTargetPerimeterPoint = function (state, me) {\n  var result = null;\n  var view = state.view;\n  var targetPerimeter = view.getPerimeterFunction(state);\n  if (targetPerimeter != null) {\n    var next = this.waypoints != null && this.waypoints.length > 0 ? this.waypoints[this.waypoints.length - 1] : new _mxPoint[\"default\"](this.previous.getCenterX(), this.previous.getCenterY());\n    var tmp = targetPerimeter(view.getPerimeterBounds(state), this.edgeState, next, false);\n    if (tmp != null) {\n      result = tmp;\n    }\n  } else {\n    result = new _mxPoint[\"default\"](state.getCenterX(), state.getCenterY());\n  }\n  return result;\n};\n\n/**\r\n * Function: getSourcePerimeterPoint\r\n *\r\n * Hook to update the icon position(s) based on a mouseOver event. This is\r\n * an empty implementation.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> that represents the target cell state.\r\n * next - <mxPoint> that represents the next point along the previewed edge.\r\n * me - <mxMouseEvent> that represents the mouse move.\r\n */\nmxConnectionHandler.prototype.getSourcePerimeterPoint = function (state, next, me) {\n  var result = null;\n  var view = state.view;\n  var sourcePerimeter = view.getPerimeterFunction(state);\n  var c = new _mxPoint[\"default\"](state.getCenterX(), state.getCenterY());\n  if (sourcePerimeter != null) {\n    var theta = _mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_ROTATION, 0);\n    var rad = -theta * (Math.PI / 180);\n    if (theta != 0) {\n      next = _mxUtils[\"default\"].getRotatedPoint(new _mxPoint[\"default\"](next.x, next.y), Math.cos(rad), Math.sin(rad), c);\n    }\n    var tmp = sourcePerimeter(view.getPerimeterBounds(state), state, next, false);\n    if (tmp != null) {\n      if (theta != 0) {\n        tmp = _mxUtils[\"default\"].getRotatedPoint(new _mxPoint[\"default\"](tmp.x, tmp.y), Math.cos(-rad), Math.sin(-rad), c);\n      }\n      result = tmp;\n    }\n  } else {\n    result = c;\n  }\n  return result;\n};\n\n/**\r\n * Function: updateIcons\r\n *\r\n * Hook to update the icon position(s) based on a mouseOver event. This is\r\n * an empty implementation.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> under the mouse.\r\n * icons - Array of currently displayed icons.\r\n * me - <mxMouseEvent> that contains the mouse event.\r\n */\nmxConnectionHandler.prototype.updateIcons = function (state, icons, me) {\n  // empty\n};\n\n/**\r\n * Function: isStopEvent\r\n *\r\n * Returns true if the given mouse up event should stop this handler. The\r\n * connection will be created if <error> is null. Note that this is only\r\n * called if <waypointsEnabled> is true. This implemtation returns true\r\n * if there is a cell state in the given event.\r\n */\nmxConnectionHandler.prototype.isStopEvent = function (me) {\n  return me.getState() != null;\n};\n\n/**\r\n * Function: addWaypoint\r\n *\r\n * Adds the waypoint for the given event to <waypoints>.\r\n */\nmxConnectionHandler.prototype.addWaypointForEvent = function (me) {\n  var point = _mxUtils[\"default\"].convertPoint(this.graph.container, me.getX(), me.getY());\n  var dx = Math.abs(point.x - this.first.x);\n  var dy = Math.abs(point.y - this.first.y);\n  var addPoint = this.waypoints != null || this.mouseDownCounter > 1 && (dx > this.graph.tolerance || dy > this.graph.tolerance);\n  if (addPoint) {\n    if (this.waypoints == null) {\n      this.waypoints = [];\n    }\n    var scale = this.graph.view.scale;\n    var point = new _mxPoint[\"default\"](this.graph.snap(me.getGraphX() / scale) * scale, this.graph.snap(me.getGraphY() / scale) * scale);\n    this.waypoints.push(point);\n  }\n};\n\n/**\r\n * Function: mouseUp\r\n *\r\n * Handles the event by inserting the new connection.\r\n */\nmxConnectionHandler.prototype.mouseUp = function (sender, me) {\n  if (!me.isConsumed() && this.isConnecting()) {\n    if (this.waypointsEnabled && !this.isStopEvent(me)) {\n      this.addWaypointForEvent(me);\n      me.consume();\n      return;\n    }\n\n    // Inserts the edge if no validation error exists\n    if (this.error == null) {\n      var source = this.previous != null ? this.previous.cell : null;\n      var target = null;\n      if (this.constraintHandler.currentConstraint != null && this.constraintHandler.currentFocus != null) {\n        target = this.constraintHandler.currentFocus.cell;\n      }\n      if (target == null && this.currentState != null) {\n        target = this.currentState.cell;\n      }\n      if (source !== target) {\n        //不能有自己连自己的线\n        this.connect(source, target, me.getEvent(), me.getCell());\n      }\n    } else {\n      // Selects the source terminal for self-references\n      if (this.previous != null && this.marker.validState != null && this.previous.cell == this.marker.validState.cell) {\n        this.graph.selectCellForEvent(this.marker.source, evt);\n      }\n\n      // Displays the error message if it is not an empty string,\n      // for empty error messages, the event is silently dropped\n      if (this.error.length > 0) {\n        this.graph.validationAlert(this.error);\n      }\n    }\n\n    // Redraws the connect icons and resets the handler state\n    this.destroyIcons();\n    me.consume();\n  }\n  if (this.first != null) {\n    this.reset();\n  }\n};\n\n/**\r\n * Function: reset\r\n *\r\n * Resets the state of this handler.\r\n */\nmxConnectionHandler.prototype.reset = function () {\n  if (this.shape != null) {\n    this.shape.destroy();\n    this.shape = null;\n  }\n\n  // Resets the cursor on the container\n  if (this.cursor != null && this.graph.container != null) {\n    this.graph.container.style.cursor = '';\n  }\n  this.destroyIcons();\n  this.marker.reset();\n  this.constraintHandler.reset();\n  this.originalPoint = null;\n  this.currentPoint = null;\n  this.edgeState = null;\n  this.previous = null;\n  this.error = null;\n  this.sourceConstraint = null;\n  this.mouseDownCounter = 0;\n  this.first = null;\n  this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].RESET));\n};\n\n/**\r\n * Function: drawPreview\r\n *\r\n * Redraws the preview edge using the color and width returned by\r\n * <getEdgeColor> and <getEdgeWidth>.\r\n */\nmxConnectionHandler.prototype.drawPreview = function () {\n  this.updatePreview(this.error == null);\n  this.shape.redraw();\n};\n\n/**\r\n * Function: getEdgeColor\r\n *\r\n * Returns the color used to draw the preview edge. This returns green if\r\n * there is no edge validation error and red otherwise.\r\n *\r\n * Parameters:\r\n *\r\n * valid - Boolean indicating if the color for a valid edge should be\r\n * returned.\r\n */\nmxConnectionHandler.prototype.updatePreview = function (valid) {\n  this.shape.strokewidth = this.getEdgeWidth(valid);\n  this.shape.stroke = this.getEdgeColor(valid);\n};\n\n/**\r\n * Function: getEdgeColor\r\n *\r\n * Returns the color used to draw the preview edge. This returns green if\r\n * there is no edge validation error and red otherwise.\r\n *\r\n * Parameters:\r\n *\r\n * valid - Boolean indicating if the color for a valid edge should be\r\n * returned.\r\n */\nmxConnectionHandler.prototype.getEdgeColor = function (valid) {\n  return valid ? _mxConstants[\"default\"].VALID_COLOR : _mxConstants[\"default\"].INVALID_COLOR;\n};\n\n/**\r\n * Function: getEdgeWidth\r\n *\r\n * Returns the width used to draw the preview edge. This returns 3 if\r\n * there is no edge validation error and 1 otherwise.\r\n *\r\n * Parameters:\r\n *\r\n * valid - Boolean indicating if the width for a valid edge should be\r\n * returned.\r\n */\nmxConnectionHandler.prototype.getEdgeWidth = function (valid) {\n  return valid ? 3 : 1;\n};\n\n/**\r\n * Function: connect\r\n *\r\n * Connects the given source and target using a new edge. This\r\n * implementation uses <createEdge> to create the edge.\r\n *\r\n * Parameters:\r\n *\r\n * source - <mxCell> that represents the source terminal.\r\n * target - <mxCell> that represents the target terminal.\r\n * evt - Mousedown event of the connect gesture.\r\n * dropTarget - <mxCell> that represents the cell under the mouse when it was\r\n * released.\r\n */\nmxConnectionHandler.prototype.connect = function (source, target, evt, dropTarget) {\n  if (target != null || this.isCreateTarget(evt) || this.graph.allowDanglingEdges) {\n    // Uses the common parent of source and target or\n    // the default parent to insert the edge\n    var model = this.graph.getModel();\n    var terminalInserted = false;\n    var edge = null;\n    model.beginUpdate();\n    try {\n      if (source != null && target == null && !this.graph.isIgnoreTerminalEvent(evt) && this.isCreateTarget(evt)) {\n        target = this.createTargetVertex(evt, source);\n        if (target != null) {\n          dropTarget = this.graph.getDropTarget([target], evt, dropTarget);\n          terminalInserted = true;\n\n          // Disables edges as drop targets if the target cell was created\n          // FIXME: Should not shift if vertex was aligned (same in Java)\n          if (dropTarget == null || !this.graph.getModel().isEdge(dropTarget)) {\n            var pstate = this.graph.getView().getState(dropTarget);\n            if (pstate != null) {\n              var tmp = model.getGeometry(target);\n              tmp.x -= pstate.origin.x;\n              tmp.y -= pstate.origin.y;\n            }\n          } else {\n            dropTarget = this.graph.getDefaultParent();\n          }\n          this.graph.addCell(target, dropTarget);\n        }\n      }\n      var parent = this.graph.getDefaultParent();\n      if (source != null && target != null && model.getParent(source) == model.getParent(target) && model.getParent(model.getParent(source)) != model.getRoot()) {\n        parent = model.getParent(source);\n        if (source.geometry != null && source.geometry.relative && target.geometry != null && target.geometry.relative) {\n          parent = model.getParent(parent);\n        }\n      }\n\n      // Uses the value of the preview edge state for inserting\n      // the new edge into the graph\n      var value = null;\n      var style = null;\n      if (this.edgeState != null) {\n        value = this.edgeState.cell.value;\n        style = this.edgeState.cell.style;\n      }\n      edge = this.insertEdge(parent, null, value, source, target, style);\n      if (edge != null) {\n        // Updates the connection constraints\n        this.graph.setConnectionConstraint(edge, source, true, this.sourceConstraint);\n        this.graph.setConnectionConstraint(edge, target, false, this.constraintHandler.currentConstraint);\n\n        // Uses geometry of the preview edge state\n        if (this.edgeState != null) {\n          model.setGeometry(edge, this.edgeState.cell.geometry);\n        }\n        var parent = model.getParent(source);\n\n        // Inserts edge before source\n        if (this.isInsertBefore(edge, source, target, evt, dropTarget)) {\n          var index = null;\n          var tmp = source;\n          while (tmp.parent != null && tmp.geometry != null && tmp.geometry.relative && tmp.parent != edge.parent) {\n            tmp = this.graph.model.getParent(tmp);\n          }\n          if (tmp != null && tmp.parent != null && tmp.parent == edge.parent) {\n            var index = tmp.parent.getIndex(tmp);\n            tmp.parent.insert(edge, index);\n          }\n        }\n\n        // Makes sure the edge has a non-null, relative geometry\n        var geo = model.getGeometry(edge);\n        if (geo == null) {\n          geo = new _mxGeometry[\"default\"]();\n          geo.relative = true;\n          model.setGeometry(edge, geo);\n        }\n\n        // Uses scaled waypoints in geometry\n        if (this.waypoints != null && this.waypoints.length > 0) {\n          var s = this.graph.view.scale;\n          var tr = this.graph.view.translate;\n          geo.points = [];\n          for (var i = 0; i < this.waypoints.length; i++) {\n            var pt = this.waypoints[i];\n            geo.points.push(new _mxPoint[\"default\"](pt.x / s - tr.x, pt.y / s - tr.y));\n          }\n        }\n        if (target == null) {\n          var t = this.graph.view.translate;\n          var s = this.graph.view.scale;\n          var pt = this.originalPoint != null ? new _mxPoint[\"default\"](this.originalPoint.x / s - t.x, this.originalPoint.y / s - t.y) : new _mxPoint[\"default\"](this.currentPoint.x / s - t.x, this.currentPoint.y / s - t.y);\n          pt.x -= this.graph.panDx / this.graph.view.scale;\n          pt.y -= this.graph.panDy / this.graph.view.scale;\n          geo.setTerminalPoint(pt, false);\n        }\n        this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].CONNECT, 'cell', edge, 'terminal', target, 'event', evt, 'target', dropTarget, 'terminalInserted', terminalInserted));\n      }\n    } catch (e) {\n      _mxLog[\"default\"].show();\n      _mxLog[\"default\"].debug(e.message);\n    } finally {\n      model.endUpdate();\n    }\n    if (this.select) {\n      this.selectCells(edge, terminalInserted ? target : null);\n    }\n  }\n};\n\n/**\r\n * Function: selectCells\r\n *\r\n * Selects the given edge after adding a new connection. The target argument\r\n * contains the target vertex if one has been inserted.\r\n */\nmxConnectionHandler.prototype.selectCells = function (edge, target) {\n  this.graph.setSelectionCell(edge);\n};\n\n/**\r\n * Function: insertEdge\r\n *\r\n * Creates, inserts and returns the new edge for the given parameters. This\r\n * implementation does only use <createEdge> if <factoryMethod> is defined,\r\n * otherwise <mxGraph.insertEdge> will be used.\r\n */\nmxConnectionHandler.prototype.insertEdge = function (parent, id, value, source, target, style) {\n  if (this.factoryMethod == null) {\n    return this.graph.insertEdge(parent, id, value, source, target, style);\n  } else {\n    var edge = this.createEdge(value, source, target, style);\n    edge = this.graph.addEdge(edge, parent, source, target);\n    return edge;\n  }\n};\n\n/**\r\n * Function: createTargetVertex\r\n *\r\n * Hook method for creating new vertices on the fly if no target was\r\n * under the mouse. This is only called if <createTarget> is true and\r\n * returns null.\r\n *\r\n * Parameters:\r\n *\r\n * evt - Mousedown event of the connect gesture.\r\n * source - <mxCell> that represents the source terminal.\r\n */\nmxConnectionHandler.prototype.createTargetVertex = function (evt, source) {\n  // Uses the first non-relative source\n  var geo = this.graph.getCellGeometry(source);\n  while (geo != null && geo.relative) {\n    source = this.graph.getModel().getParent(source);\n    geo = this.graph.getCellGeometry(source);\n  }\n  var clone = this.graph.cloneCells([source])[0];\n  var geo = this.graph.getModel().getGeometry(clone);\n  if (geo != null) {\n    var t = this.graph.view.translate;\n    var s = this.graph.view.scale;\n    var point = new _mxPoint[\"default\"](this.currentPoint.x / s - t.x, this.currentPoint.y / s - t.y);\n    geo.x = Math.round(point.x - geo.width / 2 - this.graph.panDx / s);\n    geo.y = Math.round(point.y - geo.height / 2 - this.graph.panDy / s);\n\n    // Aligns with source if within certain tolerance\n    var tol = this.getAlignmentTolerance();\n    if (tol > 0) {\n      var sourceState = this.graph.view.getState(source);\n      if (sourceState != null) {\n        var x = sourceState.x / s - t.x;\n        var y = sourceState.y / s - t.y;\n        if (Math.abs(x - geo.x) <= tol) {\n          geo.x = Math.round(x);\n        }\n        if (Math.abs(y - geo.y) <= tol) {\n          geo.y = Math.round(y);\n        }\n      }\n    }\n  }\n  return clone;\n};\n\n/**\r\n * Function: getAlignmentTolerance\r\n *\r\n * Returns the tolerance for aligning new targets to sources. This returns the grid size / 2.\r\n */\nmxConnectionHandler.prototype.getAlignmentTolerance = function (evt) {\n  return this.graph.isGridEnabled() ? this.graph.gridSize / 2 : this.graph.tolerance;\n};\n\n/**\r\n * Function: createEdge\r\n *\r\n * Creates and returns a new edge using <factoryMethod> if one exists. If\r\n * no factory method is defined, then a new default edge is returned. The\r\n * source and target arguments are informal, the actual connection is\r\n * setup later by the caller of this function.\r\n *\r\n * Parameters:\r\n *\r\n * value - Value to be used for creating the edge.\r\n * source - <mxCell> that represents the source terminal.\r\n * target - <mxCell> that represents the target terminal.\r\n * style - Optional style from the preview edge.\r\n */\nmxConnectionHandler.prototype.createEdge = function (value, source, target, style) {\n  var edge = null;\n\n  // Creates a new edge using the factoryMethod\n  if (this.factoryMethod != null) {\n    edge = this.factoryMethod(source, target, style);\n  }\n  if (edge == null) {\n    edge = new _mxCell[\"default\"](value || '');\n    edge.setEdge(true);\n    edge.setStyle(style);\n    var geo = new _mxGeometry[\"default\"]();\n    geo.relative = true;\n    edge.setGeometry(geo);\n  }\n  return edge;\n};\n\n/**\r\n * Function: destroy\r\n *\r\n * Destroys the handler and all its resources and DOM nodes. This should be\r\n * called on all instances. It is called automatically for the built-in\r\n * instance created for each <mxGraph>.\r\n */\nmxConnectionHandler.prototype.destroy = function () {\n  this.graph.removeMouseListener(this);\n  if (this.shape != null) {\n    this.shape.destroy();\n    this.shape = null;\n  }\n  if (this.marker != null) {\n    this.marker.destroy();\n    this.marker = null;\n  }\n  if (this.constraintHandler != null) {\n    this.constraintHandler.destroy();\n    this.constraintHandler = null;\n  }\n  if (this.changeHandler != null) {\n    this.graph.getModel().removeListener(this.changeHandler);\n    this.graph.getView().removeListener(this.changeHandler);\n    this.changeHandler = null;\n  }\n  if (this.drillHandler != null) {\n    this.graph.removeListener(this.drillHandler);\n    this.graph.getView().removeListener(this.drillHandler);\n    this.drillHandler = null;\n  }\n  if (this.escapeHandler != null) {\n    this.graph.removeListener(this.escapeHandler);\n    this.escapeHandler = null;\n  }\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxConstraintHandler\r\n *\r\n * Handles constraints on connection targets. This class is in charge of\r\n * showing fixed points when the mouse is over a vertex and handles constraints\r\n * to establish new connections.\r\n *\r\n * Constructor: mxConstraintHandler\r\n *\r\n * Constructs an new constraint handler.\r\n *\r\n * Parameters:\r\n *\r\n * graph - Reference to the enclosing <mxGraph>.\r\n * factoryMethod - Optional function to create the edge. The function takes\r\n * the source and target <mxCell> as the first and second argument and\r\n * returns the <mxCell> that represents the new edge.\r\n */\nvar _default = exports[\"default\"] = mxConnectionHandler;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxConnectionHandler.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxConnector.js":
/*!**********************************************!*\
  !*** ./src/workflow/mxClient/mxConnector.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.join.js */ \"../../node_modules/core-js/modules/es.array.join.js\");\n__webpack_require__(/*! core-js/modules/es.number.to-fixed.js */ \"../../node_modules/core-js/modules/es.number.to-fixed.js\");\n__webpack_require__(/*! core-js/modules/es.parse-int.js */ \"../../node_modules/core-js/modules/es.parse-int.js\");\n__webpack_require__(/*! core-js/modules/es.regexp.exec.js */ \"../../node_modules/core-js/modules/es.regexp.exec.js\");\n__webpack_require__(/*! core-js/modules/es.string.match.js */ \"../../node_modules/core-js/modules/es.string.match.js\");\n__webpack_require__(/*! core-js/modules/es.string.replace.js */ \"../../node_modules/core-js/modules/es.string.replace.js\");\nvar _mxPolyline = _interopRequireDefault(__webpack_require__(/*! ./mxPolyline.js */ \"./src/workflow/mxClient/mxPolyline.js\"));\nvar _mxMarker = _interopRequireDefault(__webpack_require__(/*! ./mxMarker.js */ \"./src/workflow/mxClient/mxMarker.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxShape = _interopRequireDefault(__webpack_require__(/*! ./mxShape.js */ \"./src/workflow/mxClient/mxShape.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ./mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nvar _workflowUtil = __webpack_require__(/*! ../util/workflowUtil */ \"./src/workflow/util/workflowUtil.js\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxConnector(points, stroke, strokewidth) {\n  _mxPolyline[\"default\"].call(this, points, stroke, strokewidth);\n}\n;\n\n/**\r\n * Extends mxPolyline.\r\n */\n_mxGraphUtils[\"default\"].extend(mxConnector, _mxPolyline[\"default\"]);\n\n/**\r\n * Function: updateBoundingBox\r\n *\r\n * Updates the <boundingBox> for this shape using <createBoundingBox> and\r\n * <augmentBoundingBox> and stores the result in <boundingBox>.\r\n */\nmxConnector.prototype.updateBoundingBox = function () {\n  this.useSvgBoundingBox = this.style != null && this.style[_mxConstants[\"default\"].STYLE_CURVED] == 1;\n  _mxShape[\"default\"].prototype.updateBoundingBox.apply(this, arguments);\n};\n\n/**\r\n * Function: paintEdgeShape\r\n *\r\n * Paints the line shape.\r\n */\nmxConnector.prototype.paintEdgeShape = function (c, pts) {\n  // The indirection via functions for markers is needed in\n  // order to apply the offsets before painting the line and\n  // paint the markers after painting the line.\n  var graph = this.state.view.graph;\n  if (!(0, _workflowUtil.isBizFlow)(graph.flowType)) {\n    var source = pts[0];\n    var len = pts.length;\n    var target = pts[len - 1];\n    var radian = Math.atan2(source.y - target.y, target.x - source.x);\n    var angle = radian * 180 / Math.PI;\n    var space = 5; //UE规定箭头两端的空隙为5\n    var cos = Math.abs(space * Math.cos(radian).toFixed(2));\n    var sin = Math.abs(space * Math.sin(radian).toFixed(2));\n    var style = this.style;\n    var type = _mxGraphUtils[\"default\"].getValue(style, _mxConstants[\"default\"].STYLE_ENDARROW);\n    var isStraight = true;\n\n    //跳过的连线是虚线，不需要space\n    if (graph.isMouseDown === false && type !== 'none') {\n      //非mouseDown状态\n      //TODO:1到2与n-1到n的线是直线，但pts.length是3\n      var firstX = source.x;\n      for (var i = 0; i < len; i++) {\n        if (pts[i].x !== firstX) {\n          isStraight = false;\n          break;\n        }\n      }\n      if (!isStraight && len > 2) {\n        //有转折点\n        var entryX = _mxGraphUtils[\"default\"].getValue(style, 'entryX');\n        var entryY = _mxGraphUtils[\"default\"].getValue(style, 'entryY');\n        var exitX = _mxGraphUtils[\"default\"].getValue(style, 'exitX');\n        var exitY = _mxGraphUtils[\"default\"].getValue(style, 'exitY');\n        if (entryX === 0) {\n          target.x -= space;\n        } else if (entryX == 1) {\n          target.x += space;\n        }\n        if (exitX == 0) {\n          source.x -= space;\n        } else if (exitX == 1) {\n          source.x += space;\n        }\n        if (entryY === 0) {\n          target.y -= space;\n        } else if (entryY == 1) {\n          target.y += space;\n        }\n        if (exitY == 0) {\n          source.y -= space;\n        } else if (exitY == 1) {\n          source.y += space;\n        }\n      } else if (angle >= -135 && angle <= -45 || angle > -45 && angle < 45) {\n        //竖向由上到下或横向由左到右\n        source.x += cos;\n        source.y += sin;\n        target.x -= cos;\n        target.y -= sin;\n      } else {\n        //竖向由下到上或横向由右到左\n        source.x -= cos;\n        source.y -= sin;\n        target.x += cos;\n        target.y += sin;\n      }\n    }\n  }\n  var sourceMarker = this.createMarker(c, pts, true);\n  var targetMarker = this.createMarker(c, pts, false);\n  _mxPolyline[\"default\"].prototype.paintEdgeShape.apply(this, arguments);\n\n  // Disables shadows, dashed styles and fixes fill color for markers\n  c.setFillColor(this.stroke);\n  c.setShadow(false);\n  c.setDashed(false);\n  if (sourceMarker != null) {\n    sourceMarker();\n  }\n  if (targetMarker != null) {\n    targetMarker();\n  }\n};\n\n/**\r\n * Function: createMarker\r\n *\r\n * Prepares the marker by adding offsets in pts and returning a function to\r\n * paint the marker.\r\n */\nmxConnector.prototype.createMarker = function (c, pts, source) {\n  var result = null;\n  var n = pts.length;\n  var type = _mxGraphUtils[\"default\"].getValue(this.style, source ? _mxConstants[\"default\"].STYLE_STARTARROW : _mxConstants[\"default\"].STYLE_ENDARROW);\n  var p0 = source ? pts[1] : pts[n - 2];\n  var pe = source ? pts[0] : pts[n - 1];\n  if (type != null && p0 != null && pe != null) {\n    var count = 1;\n\n    // Uses next non-overlapping point\n    while (count < n - 1 && Math.round(p0.x - pe.x) == 0 && Math.round(p0.y - pe.y) == 0) {\n      p0 = source ? pts[1 + count] : pts[n - 2 - count];\n      count++;\n    }\n\n    // Computes the norm and the inverse norm\n    var dx = pe.x - p0.x;\n    var dy = pe.y - p0.y;\n    var dist = Math.max(1, Math.sqrt(dx * dx + dy * dy));\n    var unitX = dx / dist;\n    var unitY = dy / dist;\n    var size = _mxGraphUtils[\"default\"].getNumber(this.style, source ? _mxConstants[\"default\"].STYLE_STARTSIZE : _mxConstants[\"default\"].STYLE_ENDSIZE, _mxConstants[\"default\"].DEFAULT_MARKERSIZE);\n\n    // Allow for stroke width in the end point used and the\n    // orthogonal vectors describing the direction of the marker\n    var filled = this.style[source ? _mxConstants[\"default\"].STYLE_STARTFILL : _mxConstants[\"default\"].STYLE_ENDFILL] != 0;\n    result = _mxMarker[\"default\"].createMarker(c, this, type, pe, unitX, unitY, size, source, this.arrowStrokewidth, filled);\n  }\n  return result;\n};\n\n/**\r\n * Function: augmentBoundingBox\r\n *\r\n * Augments the bounding box with the strokewidth and shadow offsets.\r\n */\nmxConnector.prototype.augmentBoundingBox = function (bbox) {\n  _mxShape[\"default\"].prototype.augmentBoundingBox.apply(this, arguments);\n\n  // Adds marker sizes\n  var size = 0;\n  if (_mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_STARTARROW, _mxConstants[\"default\"].NONE) != _mxConstants[\"default\"].NONE) {\n    size = _mxGraphUtils[\"default\"].getNumber(this.style, _mxConstants[\"default\"].STYLE_STARTSIZE, _mxConstants[\"default\"].DEFAULT_MARKERSIZE) + 1;\n  }\n  if (_mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_ENDARROW, _mxConstants[\"default\"].NONE) != _mxConstants[\"default\"].NONE) {\n    size = Math.max(size, _mxGraphUtils[\"default\"].getNumber(this.style, _mxConstants[\"default\"].STYLE_ENDSIZE, _mxConstants[\"default\"].DEFAULT_MARKERSIZE)) + 1;\n  }\n  bbox.grow(size * this.scale);\n};\n\n/*\r\n * label渲染完成后调用，暂时这样处理，后续优化 TODO\r\n */\nmxConnector.prototype.afterRedrawLabel = function (group) {\n  //IE低版本中参数group就是text\n  var text = group.querySelector('.text') || group,\n    style = text.style,\n    transform = group.getAttribute(\"transform\") || '',\n    tlRegex = /(translate\\()(\\d+(\\.\\d+)?)(,)(\\d+(\\.\\d+)?)(\\))/,\n    translate = transform.match(tlRegex);\n  if (translate) {\n    //由于加了padding和border会导致文字向右偏移，因此需要再向左平移\n    transform = transform.replace(tlRegex, [translate[1], translate[2] - 10, translate[4], translate[5] - 3, translate[7]].join(''));\n    group.setAttribute('transform', transform);\n  }\n  var fo = group.querySelector(\"foreignObject\");\n  if (fo) {\n    var width = fo.getAttribute(\"width\");\n    var height = fo.getAttribute(\"height\");\n    if (width) {\n      fo.setAttribute(\"width\", parseInt(width) + 20);\n    }\n    if (height) {\n      fo.setAttribute(\"height\", parseInt(height) + 6);\n    }\n  }\n  style.borderRadius = '10px';\n  style.padding = '1px 9px';\n  style.border = '1px solid #BBB';\n  style.letterSpacing = '0.27px';\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxSwimlane\r\n *\r\n * Extends <mxShape> to implement a swimlane shape. This shape is registered\r\n * under <mxConstants.SHAPE_SWIMLANE> in <mxCellRenderer>. Use the\r\n * <mxConstants.STYLE_STYLE_STARTSIZE> to define the size of the title\r\n * region, <mxConstants.STYLE_SWIMLANE_FILLCOLOR> for the content area fill,\r\n * <mxConstants.STYLE_SEPARATORCOLOR> to draw an additional vertical separator\r\n * and <mxConstants.STYLE_SWIMLANE_LINE> to hide the line between the title\r\n * region and the content area. The <mxConstants.STYLE_HORIZONTAL> affects\r\n * the orientation of this shape, not only its label.\r\n *\r\n * Constructor: mxSwimlane\r\n *\r\n * Constructs a new swimlane shape.\r\n *\r\n * Parameters:\r\n *\r\n * bounds - <mxRectangle> that defines the bounds. This is stored in\r\n * <mxShape.bounds>.\r\n * fill - String that defines the fill color. This is stored in <fill>.\r\n * stroke - String that defines the stroke color. This is stored in <stroke>.\r\n * strokewidth - Optional integer that defines the stroke width. Default is\r\n * 1. This is stored in <strokewidth>.\r\n */\nvar _default = exports[\"default\"] = mxConnector;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxConnector.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxConstants.js":
/*!**********************************************!*\
  !*** ./src/workflow/mxClient/mxConstants.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _mxClient = _interopRequireDefault(__webpack_require__(/*! ./mxClient.js */ \"./src/workflow/mxClient/mxClient.js\"));\nvar _mxRectangle = _interopRequireDefault(__webpack_require__(/*! ./mxRectangle.js */ \"./src/workflow/mxClient/mxRectangle.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nvar mxConstants = {\n  /**\r\n   * Class: mxConstants\r\n   *\r\n   * Defines various global constants.\r\n   *\r\n   * Variable: DEFAULT_HOTSPOT\r\n   *\r\n   * Defines the portion of the cell which is to be used as a connectable\r\n   * region. Default is 0.3. Possible values are 0 < x <= 1.\r\n   */\n  DEFAULT_HOTSPOT: 0.3,\n  //swimlane padding (height+、width+)\n  DEFAULT_SWIMLANE_PADDING: 10,\n  DEFAULT_SWIMLANE_WIDTH: 200,\n  DEFAULT_SWIMLANE_HEIGHT: 280,\n  /**\r\n   * Variable: MIN_HOTSPOT_SIZE\r\n   *\r\n   * Defines the minimum size in pixels of the portion of the cell which is\r\n   * to be used as a connectable region. Default is 8.\r\n   */\n  MIN_HOTSPOT_SIZE: 8,\n  /**\r\n   * Variable: MAX_HOTSPOT_SIZE\r\n   *\r\n   * Defines the maximum size in pixels of the portion of the cell which is\r\n   * to be used as a connectable region. Use 0 for no maximum. Default is 0.\r\n   */\n  MAX_HOTSPOT_SIZE: 0,\n  /**\r\n   * Variable: RENDERING_HINT_EXACT\r\n   *\r\n   * Defines the exact rendering hint.\r\n   */\n  RENDERING_HINT_EXACT: 'exact',\n  /**\r\n   * Variable: RENDERING_HINT_FASTER\r\n   *\r\n   * Defines the faster rendering hint.\r\n   */\n  RENDERING_HINT_FASTER: 'faster',\n  /**\r\n   * Variable: RENDERING_HINT_FASTEST\r\n   *\r\n   * Defines the fastest rendering hint.\r\n   */\n  RENDERING_HINT_FASTEST: 'fastest',\n  /**\r\n   * Variable: DIALECT_SVG\r\n   *\r\n   * Defines the SVG display dialect name.\r\n   */\n  DIALECT_SVG: 'svg',\n  /**\r\n   * Variable: DIALECT_VML\r\n   *\r\n   * Defines the VML display dialect name.\r\n   */\n  DIALECT_VML: 'vml',\n  /**\r\n   * Variable: DIALECT_MIXEDHTML\r\n   *\r\n   * Defines the mixed HTML display dialect name.\r\n   */\n  DIALECT_MIXEDHTML: 'mixedHtml',\n  /**\r\n   * Variable: DIALECT_PREFERHTML\r\n   *\r\n   * Defines the preferred HTML display dialect name.\r\n   */\n  DIALECT_PREFERHTML: 'preferHtml',\n  /**\r\n   * Variable: DIALECT_STRICTHTML\r\n   *\r\n   * Defines the strict HTML display dialect.\r\n   */\n  DIALECT_STRICTHTML: 'strictHtml',\n  /**\r\n   * Variable: NS_SVG\r\n   *\r\n   * Defines the SVG namespace.\r\n   */\n  NS_SVG: 'http://www.w3.org/2000/svg',\n  /**\r\n   * Variable: NS_XHTML\r\n   *\r\n   * Defines the XHTML namespace.\r\n   */\n  NS_XHTML: 'http://www.w3.org/1999/xhtml',\n  /**\r\n   * Variable: NS_XLINK\r\n   *\r\n   * Defines the XLink namespace.\r\n   */\n  NS_XLINK: 'http://www.w3.org/1999/xlink',\n  /**\r\n   * Variable: SHADOWCOLOR\r\n   *\r\n   * Defines the color to be used to draw shadows in shapes and windows.\r\n   * Default is gray.\r\n   */\n  SHADOWCOLOR: 'gray',\n  /**\r\n   * Variable: VML_SHADOWCOLOR\r\n   *\r\n   * Used for shadow color in filters where transparency is not supported\r\n   * (Microsoft Internet Explorer). Default is gray.\r\n   */\n  VML_SHADOWCOLOR: 'gray',\n  /**\r\n   * Variable: SHADOW_OFFSET_X\r\n   *\r\n   * Specifies the x-offset of the shadow. Default is 2.\r\n   */\n  SHADOW_OFFSET_X: 2,\n  /**\r\n   * Variable: SHADOW_OFFSET_Y\r\n   *\r\n   * Specifies the y-offset of the shadow. Default is 3.\r\n   */\n  SHADOW_OFFSET_Y: 3,\n  /**\r\n   * Variable: SHADOW_OPACITY\r\n   *\r\n   * Defines the opacity for shadows. Default is 1.\r\n   */\n  SHADOW_OPACITY: 1,\n  /**\r\n   * Variable: NODETYPE_ELEMENT\r\n   *\r\n   * DOM node of type ELEMENT.\r\n   */\n  NODETYPE_ELEMENT: 1,\n  /**\r\n   * Variable: NODETYPE_ATTRIBUTE\r\n   *\r\n   * DOM node of type ATTRIBUTE.\r\n   */\n  NODETYPE_ATTRIBUTE: 2,\n  /**\r\n   * Variable: NODETYPE_TEXT\r\n   *\r\n   * DOM node of type TEXT.\r\n   */\n  NODETYPE_TEXT: 3,\n  /**\r\n   * Variable: NODETYPE_CDATA\r\n   *\r\n   * DOM node of type CDATA.\r\n   */\n  NODETYPE_CDATA: 4,\n  /**\r\n   * Variable: NODETYPE_ENTITY_REFERENCE\r\n   *\r\n   * DOM node of type ENTITY_REFERENCE.\r\n   */\n  NODETYPE_ENTITY_REFERENCE: 5,\n  /**\r\n   * Variable: NODETYPE_ENTITY\r\n   *\r\n   * DOM node of type ENTITY.\r\n   */\n  NODETYPE_ENTITY: 6,\n  /**\r\n   * Variable: NODETYPE_PROCESSING_INSTRUCTION\r\n   *\r\n   * DOM node of type PROCESSING_INSTRUCTION.\r\n   */\n  NODETYPE_PROCESSING_INSTRUCTION: 7,\n  /**\r\n   * Variable: NODETYPE_COMMENT\r\n   *\r\n   * DOM node of type COMMENT.\r\n   */\n  NODETYPE_COMMENT: 8,\n  /**\r\n   * Variable: NODETYPE_DOCUMENT\r\n   *\r\n   * DOM node of type DOCUMENT.\r\n   */\n  NODETYPE_DOCUMENT: 9,\n  /**\r\n   * Variable: NODETYPE_DOCUMENTTYPE\r\n   *\r\n   * DOM node of type DOCUMENTTYPE.\r\n   */\n  NODETYPE_DOCUMENTTYPE: 10,\n  /**\r\n   * Variable: NODETYPE_DOCUMENT_FRAGMENT\r\n   *\r\n   * DOM node of type DOCUMENT_FRAGMENT.\r\n   */\n  NODETYPE_DOCUMENT_FRAGMENT: 11,\n  /**\r\n   * Variable: NODETYPE_NOTATION\r\n   *\r\n   * DOM node of type NOTATION.\r\n   */\n  NODETYPE_NOTATION: 12,\n  /**\r\n   * Variable: TOOLTIP_VERTICAL_OFFSET\r\n   *\r\n   * Defines the vertical offset for the tooltip.\r\n   * Default is 16.\r\n   */\n  TOOLTIP_VERTICAL_OFFSET: 16,\n  /**\r\n   * Variable: DEFAULT_VALID_COLOR\r\n   *\r\n   * Specifies the default valid color. Default is #0000FF.\r\n   */\n  DEFAULT_VALID_COLOR: '#00FF00',\n  /**\r\n   * Variable: DEFAULT_INVALID_COLOR\r\n   *\r\n   * Specifies the default invalid color. Default is #FF0000.\r\n   */\n  DEFAULT_INVALID_COLOR: '#FF0000',\n  /**\r\n   * Variable: OUTLINE_HIGHLIGHT_COLOR\r\n   *\r\n   * Specifies the default highlight color for shape outlines.\r\n   * Default is #0000FF. This is used in <mxEdgeHandler>.\r\n   */\n  OUTLINE_HIGHLIGHT_COLOR: '#00FF00',\n  /**\r\n   * Variable: OUTLINE_HIGHLIGHT_COLOR\r\n   *\r\n   * Defines the strokewidth to be used for shape outlines.\r\n   * Default is 5. This is used in <mxEdgeHandler>.\r\n   */\n  OUTLINE_HIGHLIGHT_STROKEWIDTH: 5,\n  /**\r\n   * Variable: HIGHLIGHT_STROKEWIDTH\r\n   *\r\n   * Defines the strokewidth to be used for the highlights.\r\n   * Default is 3.\r\n   */\n  HIGHLIGHT_STROKEWIDTH: 3,\n  /**\r\n   * Variable: CONSTRAINT_HIGHLIGHT_SIZE\r\n   *\r\n   * Size of the constraint highlight (in px). Default is 2.\r\n   */\n  HIGHLIGHT_SIZE: 2,\n  /**\r\n   * Variable: HIGHLIGHT_OPACITY\r\n   *\r\n   * Opacity (in %) used for the highlights (including outline).\r\n   * Default is 100.\r\n   */\n  HIGHLIGHT_OPACITY: 100,\n  /**\r\n   * Variable: CURSOR_MOVABLE_VERTEX\r\n   *\r\n   * Defines the cursor for a movable vertex. Default is 'move'.\r\n   */\n  CURSOR_MOVABLE_VERTEX: 'move',\n  /**\r\n   * Variable: CURSOR_MOVABLE_EDGE\r\n   *\r\n   * Defines the cursor for a movable edge. Default is 'move'.\r\n   */\n  CURSOR_MOVABLE_EDGE: 'move',\n  /**\r\n   * Variable: CURSOR_LABEL_HANDLE\r\n   *\r\n   * Defines the cursor for a movable label. Default is 'default'.\r\n   */\n  CURSOR_LABEL_HANDLE: 'default',\n  /**\r\n   * Variable: CURSOR_TERMINAL_HANDLE\r\n   *\r\n   * Defines the cursor for a terminal handle. Default is 'pointer'.\r\n   */\n  CURSOR_TERMINAL_HANDLE: 'pointer',\n  /**\r\n   * Variable: CURSOR_BEND_HANDLE\r\n   *\r\n   * Defines the cursor for a movable bend. Default is 'crosshair'.\r\n   */\n  CURSOR_BEND_HANDLE: 'crosshair',\n  /**\r\n   * Variable: CURSOR_VIRTUAL_BEND_HANDLE\r\n   *\r\n   * Defines the cursor for a movable bend. Default is 'crosshair'.\r\n   */\n  CURSOR_VIRTUAL_BEND_HANDLE: 'crosshair',\n  /**\r\n   * Variable: CURSOR_CONNECT\r\n   *\r\n   * Defines the cursor for a connectable state. Default is 'pointer'.\r\n   */\n  CURSOR_CONNECT: 'pointer',\n  /**\r\n   * Variable: HIGHLIGHT_COLOR\r\n   *\r\n   * Defines the color to be used for the cell highlighting.\r\n   * Use 'none' for no color. Default is #00FF00.\r\n   */\n  HIGHLIGHT_COLOR: '#00FF00',\n  /**\r\n   * Variable: TARGET_HIGHLIGHT_COLOR\r\n   *\r\n   * Defines the color to be used for highlighting a target cell for a new\r\n   * or changed connection. Note that this may be either a source or\r\n   * target terminal in the graph. Use 'none' for no color.\r\n   * Default is #0000FF.\r\n   */\n  CONNECT_TARGET_COLOR: '#0000FF',\n  /**\r\n   * Variable: INVALID_CONNECT_TARGET_COLOR\r\n   *\r\n   * Defines the color to be used for highlighting a invalid target cells\r\n   * for a new or changed connections. Note that this may be either a source\r\n   * or target terminal in the graph. Use 'none' for no color. Default is\r\n   * #FF0000.\r\n   */\n  INVALID_CONNECT_TARGET_COLOR: '#FF0000',\n  /**\r\n   * Variable: DROP_TARGET_COLOR\r\n   *\r\n   * Defines the color to be used for the highlighting target parent cells\r\n   * (for drag and drop). Use 'none' for no color. Default is #0000FF.\r\n   */\n  DROP_TARGET_COLOR: '#0000FF',\n  /**\r\n   * Variable: VALID_COLOR\r\n   *\r\n   * Defines the color to be used for the coloring valid connection\r\n   * previews. Use 'none' for no color. Default is #FF0000.\r\n   */\n  VALID_COLOR: '#00FF00',\n  /**\r\n   * Variable: INVALID_COLOR\r\n   *\r\n   * Defines the color to be used for the coloring invalid connection\r\n   * previews. Use 'none' for no color. Default is #FF0000.\r\n   */\n  INVALID_COLOR: '#FF0000',\n  /**\r\n   * Variable: EDGE_SELECTION_COLOR\r\n   *\r\n   * Defines the color to be used for the selection border of edges. Use\r\n   * 'none' for no color. Default is #00FF00.\r\n   */\n  EDGE_SELECTION_COLOR: '#00FF00',\n  /**\r\n   * Variable: VERTEX_SELECTION_COLOR\r\n   *\r\n   * Defines the color to be used for the selection border of vertices. Use\r\n   * 'none' for no color. Default is #00FF00.\r\n   */\n  VERTEX_SELECTION_COLOR: '#00FF00',\n  /**\r\n   * Variable: VERTEX_SELECTION_STROKEWIDTH\r\n   *\r\n   * Defines the strokewidth to be used for vertex selections.\r\n   * Default is 1.\r\n   */\n  VERTEX_SELECTION_STROKEWIDTH: 1,\n  /**\r\n   * Variable: EDGE_SELECTION_STROKEWIDTH\r\n   *\r\n   * Defines the strokewidth to be used for edge selections.\r\n   * Default is 1.\r\n   */\n  EDGE_SELECTION_STROKEWIDTH: 1,\n  /**\r\n   * Variable: SELECTION_DASHED\r\n   *\r\n   * Defines the dashed state to be used for the vertex selection\r\n   * border. Default is true.\r\n   */\n  VERTEX_SELECTION_DASHED: true,\n  /**\r\n   * Variable: SELECTION_DASHED\r\n   *\r\n   * Defines the dashed state to be used for the edge selection\r\n   * border. Default is true.\r\n   */\n  EDGE_SELECTION_DASHED: true,\n  BIZFLOW_EDGE_SELECTION_DASHED: false,\n  BIZFLOW_EDGE_SELECTION_COLOR: '#2B87F3',\n  BIZFLOW_EDGE_SELECTION_STROKEWIDTH: 2,\n  /**\r\n   * Variable: GUIDE_COLOR\r\n   *\r\n   * Defines the color to be used for the guidelines in mxGraphHandler.\r\n   * Default is #FF0000.\r\n   */\n  GUIDE_COLOR: '#FF0000',\n  /**\r\n   * Variable: GUIDE_STROKEWIDTH\r\n   *\r\n   * Defines the strokewidth to be used for the guidelines in mxGraphHandler.\r\n   * Default is 1.\r\n   */\n  GUIDE_STROKEWIDTH: 1,\n  /**\r\n   * Variable: OUTLINE_COLOR\r\n   *\r\n   * Defines the color to be used for the outline rectangle\r\n   * border.  Use 'none' for no color. Default is #0099FF.\r\n   */\n  OUTLINE_COLOR: '#0099FF',\n  /**\r\n   * Variable: OUTLINE_STROKEWIDTH\r\n   *\r\n   * Defines the strokewidth to be used for the outline rectangle\r\n   * stroke width. Default is 3.\r\n   */\n  OUTLINE_STROKEWIDTH: _mxClient[\"default\"].IS_IE ? 2 : 3,\n  /**\r\n   * Variable: HANDLE_SIZE\r\n   *\r\n   * Defines the default size for handles. Default is 6.\r\n   */\n  HANDLE_SIZE: 6,\n  /**\r\n   * Variable: LABEL_HANDLE_SIZE\r\n   *\r\n   * Defines the default size for label handles. Default is 4.\r\n   */\n  LABEL_HANDLE_SIZE: 4,\n  /**\r\n   * Variable: HANDLE_FILLCOLOR\r\n   *\r\n   * Defines the color to be used for the handle fill color. Use 'none' for\r\n   * no color. Default is #00FF00 (green).\r\n   */\n  HANDLE_FILLCOLOR: '#00FF00',\n  /**\r\n   * Variable: HANDLE_STROKECOLOR\r\n   *\r\n   * Defines the color to be used for the handle stroke color. Use 'none' for\r\n   * no color. Default is black.\r\n   */\n  HANDLE_STROKECOLOR: 'black',\n  /**\r\n   * Variable: LABEL_HANDLE_FILLCOLOR\r\n   *\r\n   * Defines the color to be used for the label handle fill color. Use 'none'\r\n   * for no color. Default is yellow.\r\n   */\n  LABEL_HANDLE_FILLCOLOR: 'yellow',\n  /**\r\n   * Variable: CONNECT_HANDLE_FILLCOLOR\r\n   *\r\n   * Defines the color to be used for the connect handle fill color. Use\r\n   * 'none' for no color. Default is #0000FF (blue).\r\n   */\n  CONNECT_HANDLE_FILLCOLOR: '#0000FF',\n  /**\r\n   * Variable: LOCKED_HANDLE_FILLCOLOR\r\n   *\r\n   * Defines the color to be used for the locked handle fill color. Use\r\n   * 'none' for no color. Default is #FF0000 (red).\r\n   */\n  LOCKED_HANDLE_FILLCOLOR: '#FF0000',\n  /**\r\n   * Variable: OUTLINE_HANDLE_FILLCOLOR\r\n   *\r\n   * Defines the color to be used for the outline sizer fill color. Use\r\n   * 'none' for no color. Default is #00FFFF.\r\n   */\n  OUTLINE_HANDLE_FILLCOLOR: '#00FFFF',\n  /**\r\n   * Variable: OUTLINE_HANDLE_STROKECOLOR\r\n   *\r\n   * Defines the color to be used for the outline sizer stroke color. Use\r\n   * 'none' for no color. Default is #0033FF.\r\n   */\n  OUTLINE_HANDLE_STROKECOLOR: '#0033FF',\n  /**\r\n   * Variable: DEFAULT_FONTFAMILY\r\n   *\r\n   * Defines the default family for all fonts in points. Default is\r\n   * Arial,Helvetica.\r\n   */\n  DEFAULT_FONTFAMILY: '\"Microsoft YaHei\", 微软雅黑, PingFangSC-Regular, sans-serif, Arial, \"Lucida Grande\", Verdana, 黑体',\n  /**\r\n   * Variable: DEFAULT_FONTSIZE\r\n   *\r\n   * Defines the default size for all fonts in points. Default is 11.\r\n   */\n  DEFAULT_FONTSIZE: 12,\n  /**\r\n   * Variable: DEFAULT_TEXT_DIRECTION\r\n   *\r\n   * Defines the default value for the <STYLE_TEXT_DIRECTION> if no value is\r\n   * defined for it in the style. Default value is an empty string which means\r\n   * the default system setting is used and no direction is set.\r\n   */\n  DEFAULT_TEXT_DIRECTION: '',\n  /**\r\n   * Variable: LINE_HEIGHT\r\n   *\r\n   * Defines the default line height for text labels. Default is 1.2.\r\n   */\n  LINE_HEIGHT: 1.2,\n  /**\r\n   * Variable: WORD_WRAP\r\n   *\r\n   * Defines the CSS value for the word-wrap property. Default is \"normal\".\r\n   * Change this to \"break-word\" to allow long words to be able to be broken\r\n   * and wrap onto the next line.\r\n   */\n  WORD_WRAP: 'normal',\n  /**\r\n   * Variable: ABSOLUTE_LINE_HEIGHT\r\n   *\r\n   * Specifies if absolute line heights should be used (px) in CSS. Default\r\n   * is false. Set this to true for backwards compatibility.\r\n   */\n  ABSOLUTE_LINE_HEIGHT: false,\n  /**\r\n   * Variable: DEFAULT_FONTSTYLE\r\n   *\r\n   * Defines the default style for all fonts. Default is 0. This can be set\r\n   * to any combination of font styles as follows.\r\n   *\r\n   * (code)\r\n   * mxConstants.DEFAULT_FONTSTYLE = mxConstants.FONT_BOLD | mxConstants.FONT_ITALIC;\r\n   * (end)\r\n   */\n  DEFAULT_FONTSTYLE: 0,\n  /**\r\n   * Variable: DEFAULT_STARTSIZE\r\n   *\r\n   * Defines the default start size for swimlanes. Default is 40.\r\n   */\n  DEFAULT_STARTSIZE: 40,\n  /**\r\n   * Variable: DEFAULT_MARKERSIZE\r\n   *\r\n   * Defines the default size for all markers. Default is 6.\r\n   */\n  DEFAULT_MARKERSIZE: 6,\n  /**\r\n   * Variable: DEFAULT_IMAGESIZE\r\n   *\r\n   * Defines the default width and height for images used in the\r\n   * label shape. Default is 24.\r\n   */\n  DEFAULT_IMAGESIZE: 24,\n  /**\r\n   * Variable: ENTITY_SEGMENT\r\n   *\r\n   * Defines the length of the horizontal segment of an Entity Relation.\r\n   * This can be overridden using <mxConstants.STYLE_SEGMENT> style.\r\n   * Default is 30.\r\n   */\n  ENTITY_SEGMENT: 30,\n  /**\r\n   * Variable: RECTANGLE_ROUNDING_FACTOR\r\n   *\r\n   * Defines the rounding factor for rounded rectangles in percent between\r\n   * 0 and 1. Values should be smaller than 0.5. Default is 0.15.\r\n   */\n  RECTANGLE_ROUNDING_FACTOR: 0.15,\n  /**\r\n   * Variable: LINE_ARCSIZE\r\n   *\r\n   * Defines the size of the arcs for rounded edges. Default is 20.\r\n   */\n  LINE_ARCSIZE: 20,\n  /**\r\n   * Variable: ARROW_SPACING\r\n   *\r\n   * Defines the spacing between the arrow shape and its terminals. Default is 0.\r\n   */\n  ARROW_SPACING: 0,\n  /**\r\n   * Variable: ARROW_WIDTH\r\n   *\r\n   * Defines the width of the arrow shape. Default is 30.\r\n   */\n  ARROW_WIDTH: 30,\n  /**\r\n   * Variable: ARROW_SIZE\r\n   *\r\n   * Defines the size of the arrowhead in the arrow shape. Default is 30.\r\n   */\n  ARROW_SIZE: 30,\n  /**\r\n   * Variable: PAGE_FORMAT_A4_PORTRAIT\r\n   *\r\n   * Defines the rectangle for the A4 portrait page format. The dimensions\r\n   * of this page format are 826x1169 pixels.\r\n   */\n  PAGE_FORMAT_A4_PORTRAIT: new _mxRectangle[\"default\"](0, 0, 826, 1169),\n  /**\r\n   * Variable: PAGE_FORMAT_A4_PORTRAIT\r\n   *\r\n   * Defines the rectangle for the A4 portrait page format. The dimensions\r\n   * of this page format are 826x1169 pixels.\r\n   */\n  PAGE_FORMAT_A4_LANDSCAPE: new _mxRectangle[\"default\"](0, 0, 1169, 826),\n  /**\r\n   * Variable: PAGE_FORMAT_LETTER_PORTRAIT\r\n   *\r\n   * Defines the rectangle for the Letter portrait page format. The\r\n   * dimensions of this page format are 850x1100 pixels.\r\n   */\n  PAGE_FORMAT_LETTER_PORTRAIT: new _mxRectangle[\"default\"](0, 0, 850, 1100),\n  /**\r\n   * Variable: PAGE_FORMAT_LETTER_PORTRAIT\r\n   *\r\n   * Defines the rectangle for the Letter portrait page format. The dimensions\r\n   * of this page format are 850x1100 pixels.\r\n   */\n  PAGE_FORMAT_LETTER_LANDSCAPE: new _mxRectangle[\"default\"](0, 0, 1100, 850),\n  /**\r\n   * Variable: NONE\r\n   *\r\n   * Defines the value for none. Default is \"none\".\r\n   */\n  NONE: 'none',\n  /**\r\n   * Variable: STYLE_PERIMETER\r\n   *\r\n   * Defines the key for the perimeter style. This is a function that defines\r\n   * the perimeter around a particular shape. Possible values are the\r\n   * functions defined in <mxPerimeter>. Alternatively, the constants in this\r\n   * class that start with \"PERIMETER_\" may be used to access\r\n   * perimeter styles in <mxStyleRegistry>. Value is \"perimeter\".\r\n   */\n  STYLE_PERIMETER: 'perimeter',\n  /**\r\n   * Variable: STYLE_SOURCE_PORT\r\n   *\r\n   * Defines the ID of the cell that should be used for computing the\r\n   * perimeter point of the source for an edge. This allows for graphically\r\n   * connecting to a cell while keeping the actual terminal of the edge.\r\n   * Value is \"sourcePort\".\r\n   */\n  STYLE_SOURCE_PORT: 'sourcePort',\n  /**\r\n   * Variable: STYLE_TARGET_PORT\r\n   *\r\n   * Defines the ID of the cell that should be used for computing the\r\n   * perimeter point of the target for an edge. This allows for graphically\r\n   * connecting to a cell while keeping the actual terminal of the edge.\r\n   * Value is \"targetPort\".\r\n   */\n  STYLE_TARGET_PORT: 'targetPort',\n  /**\r\n   * Variable: STYLE_PORT_CONSTRAINT\r\n   *\r\n   * Defines the direction(s) that edges are allowed to connect to cells in.\r\n   * Possible values are \"DIRECTION_NORTH, DIRECTION_SOUTH,\r\n   * DIRECTION_EAST\" and \"DIRECTION_WEST\". Value is\r\n   * \"portConstraint\".\r\n   */\n  STYLE_PORT_CONSTRAINT: 'portConstraint',\n  /**\r\n   * Variable: STYLE_PORT_CONSTRAINT_ROTATION\r\n   *\r\n   * Define whether port constraint directions are rotated with vertex\r\n   * rotation. 0 (default) causes port constraints to remain absolute,\r\n   * relative to the graph, 1 causes the constraints to rotate with\r\n   * the vertex. Value is \"portConstraintRotation\".\r\n   */\n  STYLE_PORT_CONSTRAINT_ROTATION: 'portConstraintRotation',\n  /**\r\n   * Variable: STYLE_OPACITY\r\n   *\r\n   * Defines the key for the opacity style. The type of the value is\r\n   * numeric and the possible range is 0-100. Value is \"opacity\".\r\n   */\n  STYLE_OPACITY: 'opacity',\n  /**\r\n   * Variable: STYLE_FILL_OPACITY\r\n   *\r\n   * Defines the key for the fill opacity style. The type of the value is\r\n   * numeric and the possible range is 0-100. Value is \"fillOpacity\".\r\n   */\n  STYLE_FILL_OPACITY: 'fillOpacity',\n  /**\r\n   * Variable: STYLE_STROKE_OPACITY\r\n   *\r\n   * Defines the key for the stroke opacity style. The type of the value is\r\n   * numeric and the possible range is 0-100. Value is \"strokeOpacity\".\r\n   */\n  STYLE_STROKE_OPACITY: 'strokeOpacity',\n  /**\r\n   * Variable: STYLE_TEXT_OPACITY\r\n   *\r\n   * Defines the key for the text opacity style. The type of the value is\r\n   * numeric and the possible range is 0-100. Value is \"textOpacity\".\r\n   */\n  STYLE_TEXT_OPACITY: 'textOpacity',\n  /**\r\n   * Variable: STYLE_TEXT_DIRECTION\r\n   *\r\n   * Defines the key for the text direction style. Possible values are\r\n   * \"TEXT_DIRECTION_DEFAULT, TEXT_DIRECTION_AUTO, TEXT_DIRECTION_LTR\"\r\n   * and \"TEXT_DIRECTION_RTL\". Value is \"textDirection\".\r\n   * The default value for the style is defined in <DEFAULT_TEXT_DIRECTION>.\r\n   * It is used is no value is defined for this key in a given style. This is\r\n   * an experimental style that is currently ignored in the backends.\r\n   */\n  STYLE_TEXT_DIRECTION: 'textDirection',\n  /**\r\n   * Variable: STYLE_OVERFLOW\r\n   *\r\n   * Defines the key for the overflow style. Possible values are 'visible',\r\n   * 'hidden', 'fill' and 'width'. The default value is 'visible'. This value\r\n   * specifies how overlapping vertex labels are handled. A value of\r\n   * 'visible' will show the complete label. A value of 'hidden' will clip\r\n   * the label so that it does not overlap the vertex bounds. A value of\r\n   * 'fill' will use the vertex bounds and a value of 'width' will use the\r\n   * the vertex width for the label. See <mxGraph.isLabelClipped>. Note that\r\n   * the vertical alignment is ignored for overflow fill and for horizontal\r\n   * alignment, left should be used to avoid pixel offsets in Internet Explorer\r\n   * 11 and earlier or if foreignObjects are disabled. Value is \"overflow\".\r\n   */\n  STYLE_OVERFLOW: 'overflow',\n  /**\r\n   * Variable: STYLE_ORTHOGONAL\r\n   *\r\n   * Defines if the connection points on either end of the edge should be\r\n   * computed so that the edge is vertical or horizontal if possible and\r\n   * if the point is not at a fixed location. Default is false. This is\r\n   * used in <mxGraph.isOrthogonal>, which also returns true if the edgeStyle\r\n   * of the edge is an elbow or entity. Value is \"orthogonal\".\r\n   */\n  STYLE_ORTHOGONAL: 'orthogonal',\n  /**\r\n   * Variable: STYLE_EXIT_X\r\n   *\r\n   * Defines the key for the horizontal relative coordinate connection point\r\n   * of an edge with its source terminal. Value is \"exitX\".\r\n   */\n  STYLE_EXIT_X: 'exitX',\n  /**\r\n   * Variable: STYLE_EXIT_Y\r\n   *\r\n   * Defines the key for the vertical relative coordinate connection point\r\n   * of an edge with its source terminal. Value is \"exitY\".\r\n   */\n  STYLE_EXIT_Y: 'exitY',\n  /**\r\n   * Variable: STYLE_EXIT_PERIMETER\r\n   *\r\n   * Defines if the perimeter should be used to find the exact entry point\r\n   * along the perimeter of the source. Possible values are 0 (false) and\r\n   * 1 (true). Default is 1 (true). Value is \"exitPerimeter\".\r\n   */\n  STYLE_EXIT_PERIMETER: 'exitPerimeter',\n  /**\r\n   * Variable: STYLE_ENTRY_X\r\n   *\r\n   * Defines the key for the horizontal relative coordinate connection point\r\n   * of an edge with its target terminal. Value is \"entryX\".\r\n   */\n  STYLE_ENTRY_X: 'entryX',\n  /**\r\n   * Variable: STYLE_ENTRY_Y\r\n   *\r\n   * Defines the key for the vertical relative coordinate connection point\r\n   * of an edge with its target terminal. Value is \"entryY\".\r\n   */\n  STYLE_ENTRY_Y: 'entryY',\n  /**\r\n   * Variable: STYLE_ENTRY_PERIMETER\r\n   *\r\n   * Defines if the perimeter should be used to find the exact entry point\r\n   * along the perimeter of the target. Possible values are 0 (false) and\r\n   * 1 (true). Default is 1 (true). Value is \"entryPerimeter\".\r\n   */\n  STYLE_ENTRY_PERIMETER: 'entryPerimeter',\n  /**\r\n   * Variable: STYLE_WHITE_SPACE\r\n   *\r\n   * Defines the key for the white-space style. Possible values are 'nowrap'\r\n   * and 'wrap'. The default value is 'nowrap'. This value specifies how\r\n   * white-space inside a HTML vertex label should be handled. A value of\r\n   * 'nowrap' means the text will never wrap to the next line until a\r\n   * linefeed is encountered. A value of 'wrap' means text will wrap when\r\n   * necessary. This style is only used for HTML labels.\r\n   * See <mxGraph.isWrapping>. Value is \"whiteSpace\".\r\n   */\n  STYLE_WHITE_SPACE: 'whiteSpace',\n  /**\r\n   * Variable: STYLE_ROTATION\r\n   *\r\n   * Defines the key for the rotation style. The type of the value is\r\n   * numeric and the possible range is 0-360. Value is \"rotation\".\r\n   */\n  STYLE_ROTATION: 'rotation',\n  /**\r\n   * Variable: STYLE_FILLCOLOR\r\n   *\r\n   * Defines the key for the fill color. Possible values are all HTML color\r\n   * names or HEX codes, as well as special keywords such as 'swimlane,\r\n   * 'inherit' or 'indicated' to use the color code of a related cell or the\r\n   * indicator shape. Value is \"fillColor\".\r\n   */\n  STYLE_FILLCOLOR: 'fillColor',\n  /**\r\n   * Variable: STYLE_POINTER_EVENTS\r\n   *\r\n   * Specifies if pointer events should be fired on transparent backgrounds.\r\n   * This style is currently only supported in <mxRectangleShape>. Default\r\n   * is true. Value is \"pointerEvents\". This is typically set to\r\n   * false in groups where the transparent part should allow any underlying\r\n   * cells to be clickable.\r\n   */\n  STYLE_POINTER_EVENTS: 'pointerEvents',\n  /**\r\n   * Variable: STYLE_SWIMLANE_FILLCOLOR\r\n   *\r\n   * Defines the key for the fill color of the swimlane background. Possible\r\n   * values are all HTML color names or HEX codes. Default is no background.\r\n   * Value is \"swimlaneFillColor\".\r\n   */\n  STYLE_SWIMLANE_FILLCOLOR: 'swimlaneFillColor',\n  /**\r\n   * Variable: STYLE_MARGIN\r\n   *\r\n   * Defines the key for the margin between the ellipses in the double ellipse shape.\r\n   * Possible values are all positive numbers. Value is \"margin\".\r\n   */\n  STYLE_MARGIN: 'margin',\n  /**\r\n   * Variable: STYLE_GRADIENTCOLOR\r\n   *\r\n   * Defines the key for the gradient color. Possible values are all HTML color\r\n   * names or HEX codes, as well as special keywords such as 'swimlane,\r\n   * 'inherit' or 'indicated' to use the color code of a related cell or the\r\n   * indicator shape. This is ignored if no fill color is defined. Value is\r\n   * \"gradientColor\".\r\n   */\n  STYLE_GRADIENTCOLOR: 'gradientColor',\n  /**\r\n   * Variable: STYLE_GRADIENT_DIRECTION\r\n   *\r\n   * Defines the key for the gradient direction. Possible values are\r\n   * <DIRECTION_EAST>, <DIRECTION_WEST>, <DIRECTION_NORTH> and\r\n   * <DIRECTION_SOUTH>. Default is <DIRECTION_SOUTH>. Generally, and by\r\n   * default in mxGraph, gradient painting is done from the value of\r\n   * <STYLE_FILLCOLOR> to the value of <STYLE_GRADIENTCOLOR>. Taking the\r\n   * example of <DIRECTION_NORTH>, this means <STYLE_FILLCOLOR> color at the\r\n   * bottom of paint pattern and <STYLE_GRADIENTCOLOR> at top, with a\r\n   * gradient in-between. Value is \"gradientDirection\".\r\n   */\n  STYLE_GRADIENT_DIRECTION: 'gradientDirection',\n  /**\r\n   * Variable: STYLE_STROKECOLOR\r\n   *\r\n   * Defines the key for the strokeColor style. Possible values are all HTML\r\n   * color names or HEX codes, as well as special keywords such as 'swimlane,\r\n   * 'inherit', 'indicated' to use the color code of a related cell or the\r\n   * indicator shape or 'none' for no color. Value is \"strokeColor\".\r\n   */\n  STYLE_STROKECOLOR: 'strokeColor',\n  /**\r\n   * Variable: STYLE_SEPARATORCOLOR\r\n   *\r\n   * Defines the key for the separatorColor style. Possible values are all\r\n   * HTML color names or HEX codes. This style is only used for\r\n   * <SHAPE_SWIMLANE> shapes. Value is \"separatorColor\".\r\n   */\n  STYLE_SEPARATORCOLOR: 'separatorColor',\n  /**\r\n   * Variable: STYLE_STROKEWIDTH\r\n   *\r\n   * Defines the key for the strokeWidth style. The type of the value is\r\n   * numeric and the possible range is any non-negative value larger or equal\r\n   * to 1. The value defines the stroke width in pixels. Note: To hide a\r\n   * stroke use strokeColor none. Value is \"strokeWidth\".\r\n   */\n  STYLE_STROKEWIDTH: 'strokeWidth',\n  /**\r\n   * Variable: STYLE_ALIGN\r\n   *\r\n   * Defines the key for the align style. Possible values are <ALIGN_LEFT>,\r\n   * <ALIGN_CENTER> and <ALIGN_RIGHT>. This value defines how the lines of\r\n   * the label are horizontally aligned. <ALIGN_LEFT> mean label text lines\r\n   * are aligned to left of the label bounds, <ALIGN_RIGHT> to the right of\r\n   * the label bounds and <ALIGN_CENTER> means the center of the text lines\r\n   * are aligned in the center of the label bounds. Note this value doesn't\r\n   * affect the positioning of the overall label bounds relative to the\r\n   * vertex, to move the label bounds horizontally, use\r\n   * <STYLE_LABEL_POSITION>. Value is \"align\".\r\n   */\n  STYLE_ALIGN: 'align',\n  /**\r\n   * Variable: STYLE_VERTICAL_ALIGN\r\n   *\r\n   * Defines the key for the verticalAlign style. Possible values are\r\n   * <ALIGN_TOP>, <ALIGN_MIDDLE> and <ALIGN_BOTTOM>. This value defines how\r\n   * the lines of the label are vertically aligned. <ALIGN_TOP> means the\r\n   * topmost label text line is aligned against the top of the label bounds,\r\n   * <ALIGN_BOTTOM> means the bottom-most label text line is aligned against\r\n   * the bottom of the label bounds and <ALIGN_MIDDLE> means there is equal\r\n   * spacing between the topmost text label line and the top of the label\r\n   * bounds and the bottom-most text label line and the bottom of the label\r\n   * bounds. Note this value doesn't affect the positioning of the overall\r\n   * label bounds relative to the vertex, to move the label bounds\r\n   * vertically, use <STYLE_VERTICAL_LABEL_POSITION>. Value is \"verticalAlign\".\r\n   */\n  STYLE_VERTICAL_ALIGN: 'verticalAlign',\n  /**\r\n   * Variable: STYLE_LABEL_WIDTH\r\n   *\r\n   * Defines the key for the width of the label if the label position is not\r\n   * center. Value is \"labelWidth\".\r\n   */\n  STYLE_LABEL_WIDTH: 'labelWidth',\n  /**\r\n   * Variable: STYLE_LABEL_POSITION\r\n   *\r\n   * Defines the key for the horizontal label position of vertices. Possible\r\n   * values are <ALIGN_LEFT>, <ALIGN_CENTER> and <ALIGN_RIGHT>. Default is\r\n   * <ALIGN_CENTER>. The label align defines the position of the label\r\n   * relative to the cell. <ALIGN_LEFT> means the entire label bounds is\r\n   * placed completely just to the left of the vertex, <ALIGN_RIGHT> means\r\n   * adjust to the right and <ALIGN_CENTER> means the label bounds are\r\n   * vertically aligned with the bounds of the vertex. Note this value\r\n   * doesn't affect the positioning of label within the label bounds, to move\r\n   * the label horizontally within the label bounds, use <STYLE_ALIGN>.\r\n   * Value is \"labelPosition\".\r\n   */\n  STYLE_LABEL_POSITION: 'labelPosition',\n  /**\r\n   * Variable: STYLE_VERTICAL_LABEL_POSITION\r\n   *\r\n   * Defines the key for the vertical label position of vertices. Possible\r\n   * values are <ALIGN_TOP>, <ALIGN_BOTTOM> and <ALIGN_MIDDLE>. Default is\r\n   * <ALIGN_MIDDLE>. The label align defines the position of the label\r\n   * relative to the cell. <ALIGN_TOP> means the entire label bounds is\r\n   * placed completely just on the top of the vertex, <ALIGN_BOTTOM> means\r\n   * adjust on the bottom and <ALIGN_MIDDLE> means the label bounds are\r\n   * horizontally aligned with the bounds of the vertex. Note this value\r\n   * doesn't affect the positioning of label within the label bounds, to move\r\n   * the label vertically within the label bounds, use\r\n   * <STYLE_VERTICAL_ALIGN>. Value is \"verticalLabelPosition\".\r\n   */\n  STYLE_VERTICAL_LABEL_POSITION: 'verticalLabelPosition',\n  /**\r\n   * Variable: STYLE_IMAGE_ASPECT\r\n   *\r\n   * Defines the key for the image aspect style. Possible values are 0 (do\r\n   * not preserve aspect) or 1 (keep aspect). This is only used in\r\n   * <mxImageShape>. Default is 1. Value is \"imageAspect\".\r\n   */\n  STYLE_IMAGE_ASPECT: 'imageAspect',\n  /**\r\n   * Variable: STYLE_IMAGE_ALIGN\r\n   *\r\n   * Defines the key for the align style. Possible values are <ALIGN_LEFT>,\r\n   * <ALIGN_CENTER> and <ALIGN_RIGHT>. The value defines how any image in the\r\n   * vertex label is aligned horizontally within the label bounds of a\r\n   * <SHAPE_LABEL> shape. Value is \"imageAlign\".\r\n   */\n  STYLE_IMAGE_ALIGN: 'imageAlign',\n  /**\r\n   * Variable: STYLE_IMAGE_VERTICAL_ALIGN\r\n   *\r\n   * Defines the key for the verticalAlign style. Possible values are\r\n   * <ALIGN_TOP>, <ALIGN_MIDDLE> and <ALIGN_BOTTOM>. The value defines how\r\n   * any image in the vertex label is aligned vertically within the label\r\n   * bounds of a <SHAPE_LABEL> shape. Value is \"imageVerticalAlign\".\r\n   */\n  STYLE_IMAGE_VERTICAL_ALIGN: 'imageVerticalAlign',\n  /**\r\n   * Variable: STYLE_GLASS\r\n   *\r\n   * Defines the key for the glass style. Possible values are 0 (disabled) and\r\n   * 1(enabled). The default value is 0. This is used in <mxLabel>. Value is\r\n   * \"glass\".\r\n   */\n  STYLE_GLASS: 'glass',\n  /**\r\n   * Variable: STYLE_IMAGE\r\n   *\r\n   * Defines the key for the image style. Possible values are any image URL,\r\n   * the type of the value is String. This is the path to the image that is\r\n   * to be displayed within the label of a vertex. Data URLs should use the\r\n   * following format: data:image/png,xyz where xyz is the base64 encoded\r\n   * data (without the \"base64\"-prefix). Note that Data URLs are only\r\n   * supported in modern browsers. Value is \"image\".\r\n   */\n  STYLE_IMAGE: 'image',\n  /**\r\n   * Variable: STYLE_IMAGE_WIDTH\r\n   *\r\n   * Defines the key for the imageWidth style. The type of this value is\r\n   * int, the value is the image width in pixels and must be greater than 0.\r\n   * Value is \"imageWidth\".\r\n   */\n  STYLE_IMAGE_WIDTH: 'imageWidth',\n  /**\r\n   * Variable: STYLE_IMAGE_HEIGHT\r\n   *\r\n   * Defines the key for the imageHeight style. The type of this value is\r\n   * int, the value is the image height in pixels and must be greater than 0.\r\n   * Value is \"imageHeight\".\r\n   */\n  STYLE_IMAGE_HEIGHT: 'imageHeight',\n  /**\r\n   * Variable: STYLE_IMAGE_BACKGROUND\r\n   *\r\n   * Defines the key for the image background color. This style is only used\r\n   * in <mxImageShape>. Possible values are all HTML color names or HEX\r\n   * codes. Value is \"imageBackground\".\r\n   */\n  STYLE_IMAGE_BACKGROUND: 'imageBackground',\n  /**\r\n   * Variable: STYLE_IMAGE_BORDER\r\n   *\r\n   * Defines the key for the image border color. This style is only used in\r\n   * <mxImageShape>. Possible values are all HTML color names or HEX codes.\r\n   * Value is \"imageBorder\".\r\n   */\n  STYLE_IMAGE_BORDER: 'imageBorder',\n  /**\r\n   * Variable: STYLE_FLIPH\r\n   *\r\n   * Defines the key for the horizontal image flip. This style is only used\r\n   * in <mxImageShape>. Possible values are 0 and 1. Default is 0. Value is\r\n   * \"flipH\".\r\n   */\n  STYLE_FLIPH: 'flipH',\n  /**\r\n   * Variable: STYLE_FLIPV\r\n   *\r\n   * Defines the key for the vertical flip. Possible values are 0 and 1.\r\n   * Default is 0. Value is \"flipV\".\r\n   */\n  STYLE_FLIPV: 'flipV',\n  /**\r\n   * Variable: STYLE_NOLABEL\r\n   *\r\n   * Defines the key for the noLabel style. If this is true then no label is\r\n   * visible for a given cell. Possible values are true or false (1 or 0).\r\n   * Default is false. Value is \"noLabel\".\r\n   */\n  STYLE_NOLABEL: 'noLabel',\n  /**\r\n   * Variable: STYLE_NOEDGESTYLE\r\n   *\r\n   * Defines the key for the noEdgeStyle style. If this is true then no edge\r\n   * style is applied for a given edge. Possible values are true or false\r\n   * (1 or 0). Default is false. Value is \"noEdgeStyle\".\r\n   */\n  STYLE_NOEDGESTYLE: 'noEdgeStyle',\n  /**\r\n   * Variable: STYLE_LABEL_BACKGROUNDCOLOR\r\n   *\r\n   * Defines the key for the label background color. Possible values are all\r\n   * HTML color names or HEX codes. Value is \"labelBackgroundColor\".\r\n   */\n  STYLE_LABEL_BACKGROUNDCOLOR: 'labelBackgroundColor',\n  STYLE_LABEL_ELLIPSISGROUNDCOLOR: 'ellipsisBackgroundColor',\n  /**\r\n   * Variable: STYLE_LABEL_BORDERCOLOR\r\n   *\r\n   * Defines the key for the label border color. Possible values are all\r\n   * HTML color names or HEX codes. Value is \"labelBorderColor\".\r\n   */\n  STYLE_LABEL_BORDERCOLOR: 'labelBorderColor',\n  /**\r\n   * Variable: STYLE_LABEL_PADDING\r\n   *\r\n   * Defines the key for the label padding, ie. the space between the label\r\n   * border and the label. Value is \"labelPadding\".\r\n   */\n  STYLE_LABEL_PADDING: 'labelPadding',\n  /**\r\n   * Variable: STYLE_INDICATOR_SHAPE\r\n   *\r\n   * Defines the key for the indicator shape used within an <mxLabel>.\r\n   * Possible values are all SHAPE_* constants or the names of any new\r\n   * shapes. The indicatorShape has precedence over the indicatorImage.\r\n   * Value is \"indicatorShape\".\r\n   */\n  STYLE_INDICATOR_SHAPE: 'indicatorShape',\n  /**\r\n   * Variable: STYLE_INDICATOR_IMAGE\r\n   *\r\n   * Defines the key for the indicator image used within an <mxLabel>.\r\n   * Possible values are all image URLs. The indicatorShape has\r\n   * precedence over the indicatorImage. Value is \"indicatorImage\".\r\n   */\n  STYLE_INDICATOR_IMAGE: 'indicatorImage',\n  /**\r\n   * Variable: STYLE_INDICATOR_COLOR\r\n   *\r\n   * Defines the key for the indicatorColor style. Possible values are all\r\n   * HTML color names or HEX codes, as well as the special 'swimlane' keyword\r\n   * to refer to the color of the parent swimlane if one exists. Value is\r\n   * \"indicatorColor\".\r\n   */\n  STYLE_INDICATOR_COLOR: 'indicatorColor',\n  /**\r\n   * Variable: STYLE_INDICATOR_STROKECOLOR\r\n   *\r\n   * Defines the key for the indicator stroke color in <mxLabel>.\r\n   * Possible values are all color codes. Value is \"indicatorStrokeColor\".\r\n   */\n  STYLE_INDICATOR_STROKECOLOR: 'indicatorStrokeColor',\n  /**\r\n   * Variable: STYLE_INDICATOR_GRADIENTCOLOR\r\n   *\r\n   * Defines the key for the indicatorGradientColor style. Possible values\r\n   * are all HTML color names or HEX codes. This style is only supported in\r\n   * <SHAPE_LABEL> shapes. Value is \"indicatorGradientColor\".\r\n   */\n  STYLE_INDICATOR_GRADIENTCOLOR: 'indicatorGradientColor',\n  /**\r\n   * Variable: STYLE_INDICATOR_SPACING\r\n   *\r\n   * The defines the key for the spacing between the label and the\r\n   * indicator in <mxLabel>. Possible values are in pixels. Value is\r\n   * \"indicatorSpacing\".\r\n   */\n  STYLE_INDICATOR_SPACING: 'indicatorSpacing',\n  /**\r\n   * Variable: STYLE_INDICATOR_WIDTH\r\n   *\r\n   * Defines the key for the indicator width. Possible values start at 0 (in\r\n   * pixels). Value is \"indicatorWidth\".\r\n   */\n  STYLE_INDICATOR_WIDTH: 'indicatorWidth',\n  /**\r\n   * Variable: STYLE_INDICATOR_HEIGHT\r\n   *\r\n   * Defines the key for the indicator height. Possible values start at 0 (in\r\n   * pixels). Value is \"indicatorHeight\".\r\n   */\n  STYLE_INDICATOR_HEIGHT: 'indicatorHeight',\n  /**\r\n   * Variable: STYLE_INDICATOR_DIRECTION\r\n   *\r\n   * Defines the key for the indicatorDirection style. The direction style is\r\n   * used to specify the direction of certain shapes (eg. <mxTriangle>).\r\n   * Possible values are <DIRECTION_EAST> (default), <DIRECTION_WEST>,\r\n   * <DIRECTION_NORTH> and <DIRECTION_SOUTH>. Value is \"indicatorDirection\".\r\n   */\n  STYLE_INDICATOR_DIRECTION: 'indicatorDirection',\n  /**\r\n   * Variable: STYLE_SHADOW\r\n   *\r\n   * Defines the key for the shadow style. The type of the value is Boolean.\r\n   * Value is \"shadow\".\r\n   */\n  STYLE_SHADOW: 'shadow',\n  /**\r\n   * Variable: STYLE_SEGMENT\r\n   *\r\n   * Defines the key for the segment style. The type of this value is float\r\n   * and the value represents the size of the horizontal segment of the\r\n   * entity relation style. Default is ENTITY_SEGMENT. Value is \"segment\".\r\n   */\n  STYLE_SEGMENT: 'segment',\n  /**\r\n   * Variable: STYLE_ENDARROW\r\n   *\r\n   * Defines the key for the end arrow marker. Possible values are all\r\n   * constants with an ARROW-prefix. This is only used in <mxConnector>.\r\n   * Value is \"endArrow\".\r\n   *\r\n   * Example:\r\n   * (code)\r\n   * style[mxConstants.STYLE_ENDARROW] = mxConstants.ARROW_CLASSIC;\r\n   * (end)\r\n   */\n  STYLE_ENDARROW: 'endArrow',\n  /**\r\n   * Variable: STYLE_STARTARROW\r\n   *\r\n   * Defines the key for the start arrow marker. Possible values are all\r\n   * constants with an ARROW-prefix. This is only used in <mxConnector>.\r\n   * See <STYLE_ENDARROW>. Value is \"startArrow\".\r\n   */\n  STYLE_STARTARROW: 'startArrow',\n  /**\r\n   * Variable: STYLE_ENDSIZE\r\n   *\r\n   * Defines the key for the endSize style. The type of this value is numeric\r\n   * and the value represents the size of the end marker in pixels. Value is\r\n   * \"endSize\".\r\n   */\n  STYLE_ENDSIZE: 'endSize',\n  /**\r\n   * Variable: STYLE_STARTSIZE\r\n   *\r\n   * Defines the key for the startSize style. The type of this value is\r\n   * numeric and the value represents the size of the start marker or the\r\n   * size of the swimlane title region depending on the shape it is used for.\r\n   * Value is \"startSize\".\r\n   */\n  STYLE_STARTSIZE: 'startSize',\n  /**\r\n   * Variable: STYLE_SWIMLANE_LINE\r\n   *\r\n   * Defines the key for the swimlaneLine style. This style specifies whether\r\n   * the line between the title regio of a swimlane should be visible. Use 0\r\n   * for hidden or 1 (default) for visible. Value is \"swimlaneLine\".\r\n   */\n  STYLE_SWIMLANE_LINE: 'swimlaneLine',\n  /**\r\n   * Variable: STYLE_ENDFILL\r\n   *\r\n   * Defines the key for the endFill style. Use 0 for no fill or 1 (default)\r\n   * for fill. (This style is only exported via <mxImageExport>.) Value is\r\n   * \"endFill\".\r\n   */\n  STYLE_ENDFILL: 'endFill',\n  /**\r\n   * Variable: STYLE_STARTFILL\r\n   *\r\n   * Defines the key for the startFill style. Use 0 for no fill or 1 (default)\r\n   * for fill. (This style is only exported via <mxImageExport>.) Value is\r\n   * \"startFill\".\r\n   */\n  STYLE_STARTFILL: 'startFill',\n  /**\r\n   * Variable: STYLE_DASHED\r\n   *\r\n   * Defines the key for the dashed style. Use 0 (default) for non-dashed or 1\r\n   * for dashed. Value is \"dashed\".\r\n   */\n  STYLE_DASHED: 'dashed',\n  /**\r\n   * Defines the key for the dashed pattern style in SVG and image exports.\r\n   * The type of this value is a space separated list of numbers that specify\r\n   * a custom-defined dash pattern. Dash styles are defined in terms of the\r\n   * length of the dash (the drawn part of the stroke) and the length of the\r\n   * space between the dashes. The lengths are relative to the line width: a\r\n   * length of \"1\" is equal to the line width. VML ignores this style and\r\n   * uses dashStyle instead as defined in the VML specification. This style\r\n   * is only used in the <mxConnector> shape. Value is \"dashPattern\".\r\n   */\n  STYLE_DASH_PATTERN: 'dashPattern',\n  /**\r\n   * Variable: STYLE_ROUNDED\r\n   *\r\n   * Defines the key for the rounded style. The type of this value is\r\n   * Boolean. For edges this determines whether or not joins between edges\r\n   * segments are smoothed to a rounded finish. For vertices that have the\r\n   * rectangle shape, this determines whether or not the rectangle is\r\n   * rounded. Use 0 (default) for non-rounded or 1 for rounded. Value is\r\n   * \"rounded\".\r\n   */\n  STYLE_ROUNDED: 'rounded',\n  /**\r\n   * Variable: STYLE_CURVED\r\n   *\r\n   * Defines the key for the curved style. The type of this value is\r\n   * Boolean. It is only applicable for connector shapes. Use 0 (default)\r\n   * for non-curved or 1 for curved. Value is \"curved\".\r\n   */\n  STYLE_CURVED: 'curved',\n  /**\r\n   * Variable: STYLE_ARCSIZE\r\n   *\r\n   * Defines the rounding factor for a rounded rectangle in percent (without\r\n   * the percent sign). Possible values are between 0 and 100. If this value\r\n   * is not specified then RECTANGLE_ROUNDING_FACTOR * 100 is used. For\r\n   * edges, this defines the absolute size of rounded corners in pixels. If\r\n   * this values is not specified then LINE_ARCSIZE is used.\r\n   * (This style is only exported via <mxImageExport>.) Value is \"arcSize\".\r\n   */\n  STYLE_ARCSIZE: 'arcSize',\n  /**\r\n   * Variable: STYLE_SMOOTH\r\n   *\r\n   * An experimental style for edges. This style is currently not available\r\n   * in the backends and is implemented differently for VML and SVG. The use\r\n   * of this style is currently only recommended for VML. Value is \"smooth\".\r\n   */\n  STYLE_SMOOTH: 'smooth',\n  /**\r\n   * Variable: STYLE_SOURCE_PERIMETER_SPACING\r\n   *\r\n   * Defines the key for the source perimeter spacing. The type of this value\r\n   * is numeric. This is the distance between the source connection point of\r\n   * an edge and the perimeter of the source vertex in pixels. This style\r\n   * only applies to edges. Value is \"sourcePerimeterSpacing\".\r\n   */\n  STYLE_SOURCE_PERIMETER_SPACING: 'sourcePerimeterSpacing',\n  /**\r\n   * Variable: STYLE_TARGET_PERIMETER_SPACING\r\n   *\r\n   * Defines the key for the target perimeter spacing. The type of this value\r\n   * is numeric. This is the distance between the target connection point of\r\n   * an edge and the perimeter of the target vertex in pixels. This style\r\n   * only applies to edges. Value is \"targetPerimeterSpacing\".\r\n   */\n  STYLE_TARGET_PERIMETER_SPACING: 'targetPerimeterSpacing',\n  /**\r\n   * Variable: STYLE_PERIMETER_SPACING\r\n   *\r\n   * Defines the key for the perimeter spacing. This is the distance between\r\n   * the connection point and the perimeter in pixels. When used in a vertex\r\n   * style, this applies to all incoming edges to floating ports (edges that\r\n   * terminate on the perimeter of the vertex). When used in an edge style,\r\n   * this spacing applies to the source and target separately, if they\r\n   * terminate in floating ports (on the perimeter of the vertex). Value is\r\n   * \"perimeterSpacing\".\r\n   */\n  STYLE_PERIMETER_SPACING: 'perimeterSpacing',\n  /**\r\n   * Variable: STYLE_SPACING\r\n   *\r\n   * Defines the key for the spacing. The value represents the spacing, in\r\n   * pixels, added to each side of a label in a vertex (style applies to\r\n   * vertices only). Value is \"spacing\".\r\n   */\n  STYLE_SPACING: 'spacing',\n  /**\r\n   * Variable: STYLE_SPACING_TOP\r\n   *\r\n   * Defines the key for the spacingTop style. The value represents the\r\n   * spacing, in pixels, added to the top side of a label in a vertex (style\r\n   * applies to vertices only). Value is \"spacingTop\".\r\n   */\n  STYLE_SPACING_TOP: 'spacingTop',\n  /**\r\n   * Variable: STYLE_SPACING_LEFT\r\n   *\r\n   * Defines the key for the spacingLeft style. The value represents the\r\n   * spacing, in pixels, added to the left side of a label in a vertex (style\r\n   * applies to vertices only). Value is \"spacingLeft\".\r\n   */\n  STYLE_SPACING_LEFT: 'spacingLeft',\n  /**\r\n   * Variable: STYLE_SPACING_BOTTOM\r\n   *\r\n   * Defines the key for the spacingBottom style The value represents the\r\n   * spacing, in pixels, added to the bottom side of a label in a vertex\r\n   * (style applies to vertices only). Value is \"spacingBottom\".\r\n   */\n  STYLE_SPACING_BOTTOM: 'spacingBottom',\n  /**\r\n   * Variable: STYLE_SPACING_RIGHT\r\n   *\r\n   * Defines the key for the spacingRight style The value represents the\r\n   * spacing, in pixels, added to the right side of a label in a vertex (style\r\n   * applies to vertices only). Value is \"spacingRight\".\r\n   */\n  STYLE_SPACING_RIGHT: 'spacingRight',\n  /**\r\n   * Variable: STYLE_HORIZONTAL\r\n   *\r\n   * Defines the key for the horizontal style. Possible values are\r\n   * true or false. This value only applies to vertices. If the <STYLE_SHAPE>\r\n   * is \"SHAPE_SWIMLANE\" a value of false indicates that the\r\n   * swimlane should be drawn vertically, true indicates to draw it\r\n   * horizontally. If the shape style does not indicate that this vertex is a\r\n   * swimlane, this value affects only whether the label is drawn\r\n   * horizontally or vertically. Value is \"horizontal\".\r\n   */\n  STYLE_HORIZONTAL: 'horizontal',\n  /**\r\n   * Variable: STYLE_DIRECTION\r\n   *\r\n   * Defines the key for the direction style. The direction style is used\r\n   * to specify the direction of certain shapes (eg. <mxTriangle>).\r\n   * Possible values are <DIRECTION_EAST> (default), <DIRECTION_WEST>,\r\n   * <DIRECTION_NORTH> and <DIRECTION_SOUTH>. Value is \"direction\".\r\n   */\n  STYLE_DIRECTION: 'direction',\n  /**\r\n   * Variable: STYLE_ELBOW\r\n   *\r\n   * Defines the key for the elbow style. Possible values are\r\n   * <ELBOW_HORIZONTAL> and <ELBOW_VERTICAL>. Default is <ELBOW_HORIZONTAL>.\r\n   * This defines how the three segment orthogonal edge style leaves its\r\n   * terminal vertices. The vertical style leaves the terminal vertices at\r\n   * the top and bottom sides. Value is \"elbow\".\r\n   */\n  STYLE_ELBOW: 'elbow',\n  /**\r\n   * Variable: STYLE_FONTCOLOR\r\n   *\r\n   * Defines the key for the fontColor style. Possible values are all HTML\r\n   * color names or HEX codes. Value is \"fontColor\".\r\n   */\n  STYLE_FONTCOLOR: 'fontColor',\n  /**\r\n   * Variable: STYLE_FONTFAMILY\r\n   *\r\n   * Defines the key for the fontFamily style. Possible values are names such\r\n   * as Arial; Dialog; Verdana; Times New Roman. The value is of type String.\r\n   * Value is fontFamily.\r\n   */\n  STYLE_FONTFAMILY: 'fontFamily',\n  /**\r\n   * Variable: STYLE_FONTSIZE\r\n   *\r\n   * Defines the key for the fontSize style (in points). The type of the value\r\n   * is int. Value is \"fontSize\".\r\n   */\n  STYLE_FONTSIZE: 'fontSize',\n  /**\r\n   * Variable: STYLE_FONTSTYLE\r\n   *\r\n   * Defines the key for the fontStyle style. Values may be any logical AND\r\n   * (sum) of <FONT_BOLD>, <FONT_ITALIC> and <FONT_UNDERLINE>.\r\n   * The type of the value is int. Value is \"fontStyle\".\r\n   */\n  STYLE_FONTSTYLE: 'fontStyle',\n  /**\r\n   * Variable: STYLE_ASPECT\r\n   *\r\n   * Defines the key for the aspect style. Possible values are empty or fixed.\r\n   * If fixed is used then the aspect ratio of the cell will be maintained\r\n   * when resizing. Default is empty. Value is \"aspect\".\r\n   */\n  STYLE_ASPECT: 'aspect',\n  /**\r\n   * Variable: STYLE_AUTOSIZE\r\n   *\r\n   * Defines the key for the autosize style. This specifies if a cell should be\r\n   * resized automatically if the value has changed. Possible values are 0 or 1.\r\n   * Default is 0. See <mxGraph.isAutoSizeCell>. This is normally combined with\r\n   * <STYLE_RESIZABLE> to disable manual sizing. Value is \"autosize\".\r\n   */\n  STYLE_AUTOSIZE: 'autosize',\n  /**\r\n   * Variable: STYLE_FOLDABLE\r\n   *\r\n   * Defines the key for the foldable style. This specifies if a cell is foldable\r\n   * using a folding icon. Possible values are 0 or 1. Default is 1. See\r\n   * <mxGraph.isCellFoldable>. Value is \"foldable\".\r\n   */\n  STYLE_FOLDABLE: 'foldable',\n  /**\r\n   * Variable: STYLE_EDITABLE\r\n   *\r\n   * Defines the key for the editable style. This specifies if the value of\r\n   * a cell can be edited using the in-place editor. Possible values are 0 or\r\n   * 1. Default is 1. See <mxGraph.isCellEditable>. Value is \"editable\".\r\n   */\n  STYLE_EDITABLE: 'editable',\n  /**\r\n   * Variable: STYLE_BENDABLE\r\n   *\r\n   * Defines the key for the bendable style. This specifies if the control\r\n   * points of an edge can be moved. Possible values are 0 or 1. Default is\r\n   * 1. See <mxGraph.isCellBendable>. Value is \"bendable\".\r\n   */\n  STYLE_BENDABLE: 'bendable',\n  /**\r\n   * Variable: STYLE_MOVABLE\r\n   *\r\n   * Defines the key for the movable style. This specifies if a cell can\r\n   * be moved. Possible values are 0 or 1. Default is 1. See\r\n   * <mxGraph.isCellMovable>. Value is \"movable\".\r\n   */\n  STYLE_MOVABLE: 'movable',\n  /**\r\n   * Variable: STYLE_RESIZABLE\r\n   *\r\n   * Defines the key for the resizable style. This specifies if a cell can\r\n   * be resized. Possible values are 0 or 1. Default is 1. See\r\n   * <mxGraph.isCellResizable>. Value is \"resizable\".\r\n   */\n  STYLE_RESIZABLE: 'resizable',\n  /**\r\n   * Variable: STYLE_RESIZE_WIDTH\r\n   *\r\n   * Defines the key for the resizeWidth style. This specifies if a cell's\r\n   * width if resize if the parent is resized. If this is 1 then the width\r\n   * will be resized even if the cell's geometry is relative. If this is 0\r\n   * then the cell's width will not be resized. Default is not defined. Value\r\n   * is \"resizeWidth\".\r\n   */\n  STYLE_RESIZE_WIDTH: 'resizeWidth',\n  /**\r\n   * Variable: STYLE_RESIZE_WIDTH\r\n   *\r\n   * Defines the key for the resizeHeight style. This specifies if a cell's\r\n   * height if resize if the parent is resized. If this is 1 then the height\r\n   * will be resized even if the cell's geometry is relative. If this is 0\r\n   * then the cell's height will not be resized. Default is not defined. Value\r\n   * is \"resizeHeight\".\r\n   */\n  STYLE_RESIZE_HEIGHT: 'resizeHeight',\n  /**\r\n   * Variable: STYLE_ROTATABLE\r\n   *\r\n   * Defines the key for the rotatable style. This specifies if a cell can\r\n   * be rotated. Possible values are 0 or 1. Default is 1. See\r\n   * <mxGraph.isCellRotatable>. Value is \"rotatable\".\r\n   */\n  STYLE_ROTATABLE: 'rotatable',\n  /**\r\n   * Variable: STYLE_CLONEABLE\r\n   *\r\n   * Defines the key for the cloneable style. This specifies if a cell can\r\n   * be cloned. Possible values are 0 or 1. Default is 1. See\r\n   * <mxGraph.isCellCloneable>. Value is \"cloneable\".\r\n   */\n  STYLE_CLONEABLE: 'cloneable',\n  /**\r\n   * Variable: STYLE_DELETABLE\r\n   *\r\n   * Defines the key for the deletable style. This specifies if a cell can be\r\n   * deleted. Possible values are 0 or 1. Default is 1. See\r\n   * <mxGraph.isCellDeletable>. Value is \"deletable\".\r\n   */\n  STYLE_DELETABLE: 'deletable',\n  /**\r\n   * Variable: STYLE_SHAPE\r\n   *\r\n   * Defines the key for the shape. Possible values are all constants with\r\n   * a SHAPE-prefix or any newly defined shape names. Value is \"shape\".\r\n   */\n  STYLE_SHAPE: 'shape',\n  /**\r\n   * Variable: STYLE_EDGE\r\n   *\r\n   * Defines the key for the edge style. Possible values are the functions\r\n   * defined in <mxEdgeStyle>. Value is \"edgeStyle\".\r\n   */\n  STYLE_EDGE: 'edgeStyle',\n  /**\r\n   * Variable: STYLE_JETTY_SIZE\r\n   *\r\n   * Defines the key for the jetty size in <mxEdgeStyle.OrthConnector>.\r\n   * Default is 10. Possible values are all numeric values or \"auto\".\r\n   * Value is \"jettySize\".\r\n   */\n  STYLE_JETTY_SIZE: 'jettySize',\n  /**\r\n   * Variable: STYLE_SOURCE_JETTY_SIZE\r\n   *\r\n   * Defines the key for the jetty size in <mxEdgeStyle.OrthConnector>.\r\n   * Default is 10. Possible values are numeric values or \"auto\". This has\r\n   * precedence over <STYLE_JETTY_SIZE>. Value is \"sourceJettySize\".\r\n   */\n  STYLE_SOURCE_JETTY_SIZE: 'sourceJettySize',\n  /**\r\n   * Variable: targetJettySize\r\n   *\r\n   * Defines the key for the jetty size in <mxEdgeStyle.OrthConnector>.\r\n   * Default is 10. Possible values are numeric values or \"auto\". This has\r\n   * precedence over <STYLE_JETTY_SIZE>. Value is \"targetJettySize\".\r\n   */\n  STYLE_TARGET_JETTY_SIZE: 'targetJettySize',\n  /**\r\n   * Variable: STYLE_LOOP\r\n   *\r\n   * Defines the key for the loop style. Possible values are the functions\r\n   * defined in <mxEdgeStyle>. Value is \"loopStyle\".\r\n   */\n  STYLE_LOOP: 'loopStyle',\n  /**\r\n   * Variable: STYLE_ORTHOGONAL_LOOP\r\n   *\r\n   * Defines the key for the orthogonal loop style. Possible values are 0 and\r\n   * 1. Default is 0. Value is \"orthogonalLoop\". Use this style to specify\r\n   * if loops should be routed using an orthogonal router. Currently, this\r\n   * uses <mxEdgeStyle.OrthConnector> but will be replaced with a dedicated\r\n   * orthogonal loop router in later releases.\r\n   */\n  STYLE_ORTHOGONAL_LOOP: 'orthogonalLoop',\n  /**\r\n   * Variable: STYLE_ROUTING_CENTER_X\r\n   *\r\n   * Defines the key for the horizontal routing center. Possible values are\r\n   * between -0.5 and 0.5. This is the relative offset from the center used\r\n   * for connecting edges. The type of this value is numeric. Value is\r\n   * \"routingCenterX\".\r\n   */\n  STYLE_ROUTING_CENTER_X: 'routingCenterX',\n  /**\r\n   * Variable: STYLE_ROUTING_CENTER_Y\r\n   *\r\n   * Defines the key for the vertical routing center. Possible values are\r\n   * between -0.5 and 0.5. This is the relative offset from the center used\r\n   * for connecting edges. The type of this value is numeric. Value is\r\n   * \"routingCenterY\".\r\n   */\n  STYLE_ROUTING_CENTER_Y: 'routingCenterY',\n  /**\r\n   * Variable: FONT_BOLD\r\n   *\r\n   * Constant for bold fonts. Default is 1.\r\n   */\n  FONT_BOLD: 1,\n  /**\r\n   * Variable: FONT_ITALIC\r\n   *\r\n   * Constant for italic fonts. Default is 2.\r\n   */\n  FONT_ITALIC: 2,\n  /**\r\n   * Variable: FONT_UNDERLINE\r\n   *\r\n   * Constant for underlined fonts. Default is 4.\r\n   */\n  FONT_UNDERLINE: 4,\n  /**\r\n   * Variable: SHAPE_RECTANGLE\r\n   *\r\n   * Name under which <mxRectangleShape> is registered in <mxCellRenderer>.\r\n   * Default is rectangle.\r\n   */\n  SHAPE_RECTANGLE: 'rectangle',\n  /**\r\n   * Variable: SHAPE_ELLIPSE\r\n   *\r\n   * Name under which <mxEllipse> is registered in <mxCellRenderer>.\r\n   * Default is ellipse.\r\n   */\n  SHAPE_ELLIPSE: 'ellipse',\n  /**\r\n   * Variable: SHAPE_DOUBLE_ELLIPSE\r\n   *\r\n   * Name under which <mxDoubleEllipse> is registered in <mxCellRenderer>.\r\n   * Default is doubleEllipse.\r\n   */\n  SHAPE_DOUBLE_ELLIPSE: 'doubleEllipse',\n  /**\r\n   * Variable: SHAPE_RHOMBUS\r\n   *\r\n   * Name under which <mxRhombus> is registered in <mxCellRenderer>.\r\n   * Default is rhombus.\r\n   */\n  SHAPE_RHOMBUS: 'rhombus',\n  /**\r\n   * Variable: SHAPE_LINE\r\n   *\r\n   * Name under which <mxLine> is registered in <mxCellRenderer>.\r\n   * Default is line.\r\n   */\n  SHAPE_LINE: 'line',\n  /**\r\n   * Variable: SHAPE_IMAGE\r\n   *\r\n   * Name under which <mxImageShape> is registered in <mxCellRenderer>.\r\n   * Default is image.\r\n   */\n  SHAPE_IMAGE: 'image',\n  /**\r\n   * Variable: SHAPE_ARROW\r\n   *\r\n   * Name under which <mxArrow> is registered in <mxCellRenderer>.\r\n   * Default is arrow.\r\n   */\n  SHAPE_ARROW: 'arrow',\n  /**\r\n   * Variable: SHAPE_ARROW_CONNECTOR\r\n   *\r\n   * Name under which <mxArrowConnector> is registered in <mxCellRenderer>.\r\n   * Default is arrowConnector.\r\n   */\n  SHAPE_ARROW_CONNECTOR: 'arrowConnector',\n  /**\r\n   * Variable: SHAPE_LABEL\r\n   *\r\n   * Name under which <mxLabel> is registered in <mxCellRenderer>.\r\n   * Default is label.\r\n   */\n  SHAPE_LABEL: 'label',\n  /**\r\n   * Variable: SHAPE_CYLINDER\r\n   *\r\n   * Name under which <mxCylinder> is registered in <mxCellRenderer>.\r\n   * Default is cylinder.\r\n   */\n  SHAPE_CYLINDER: 'cylinder',\n  /**\r\n   * Variable: SHAPE_SWIMLANE\r\n   *\r\n   * Name under which <mxSwimlane> is registered in <mxCellRenderer>.\r\n   * Default is swimlane.\r\n   */\n  SHAPE_SWIMLANE: 'swimlane',\n  /**\r\n   * Variable: SHAPE_CONNECTOR\r\n   *\r\n   * Name under which <mxConnector> is registered in <mxCellRenderer>.\r\n   * Default is connector.\r\n   */\n  SHAPE_CONNECTOR: 'connector',\n  /**\r\n   * Variable: SHAPE_ACTOR\r\n   *\r\n   * Name under which <mxActor> is registered in <mxCellRenderer>.\r\n   * Default is actor.\r\n   */\n  SHAPE_ACTOR: 'actor',\n  /**\r\n   * Variable: SHAPE_CLOUD\r\n   *\r\n   * Name under which <mxCloud> is registered in <mxCellRenderer>.\r\n   * Default is cloud.\r\n   */\n  SHAPE_CLOUD: 'cloud',\n  /**\r\n   * Variable: SHAPE_TRIANGLE\r\n   *\r\n   * Name under which <mxTriangle> is registered in <mxCellRenderer>.\r\n   * Default is triangle.\r\n   */\n  SHAPE_TRIANGLE: 'triangle',\n  /**\r\n   * Variable: SHAPE_HEXAGON\r\n   *\r\n   * Name under which <mxHexagon> is registered in <mxCellRenderer>.\r\n   * Default is hexagon.\r\n   */\n  SHAPE_HEXAGON: 'hexagon',\n  /**\r\n   * 正三角形\r\n   */\n  ARROW_TRIANGLE: 'regularTriangle',\n  /**\r\n   * Variable: ARROW_CLASSIC\r\n   *\r\n   * Constant for classic arrow markers.\r\n   */\n  ARROW_CLASSIC: 'classic',\n  /**\r\n   * Variable: ARROW_CLASSIC_THIN\r\n   *\r\n   * Constant for thin classic arrow markers.\r\n   */\n  ARROW_CLASSIC_THIN: 'classicThin',\n  /**\r\n   * Variable: ARROW_BLOCK\r\n   *\r\n   * Constant for block arrow markers.\r\n   */\n  ARROW_BLOCK: 'block',\n  /**\r\n   * Variable: ARROW_BLOCK_THIN\r\n   *\r\n   * Constant for thin block arrow markers.\r\n   */\n  ARROW_BLOCK_THIN: 'blockThin',\n  /**\r\n   * Variable: ARROW_OPEN\r\n   *\r\n   * Constant for open arrow markers.\r\n   */\n  ARROW_OPEN: 'open',\n  /**\r\n   * Variable: ARROW_OPEN_THIN\r\n   *\r\n   * Constant for thin open arrow markers.\r\n   */\n  ARROW_OPEN_THIN: 'openThin',\n  /**\r\n   * Variable: ARROW_OVAL\r\n   *\r\n   * Constant for oval arrow markers.\r\n   */\n  ARROW_OVAL: 'oval',\n  /**\r\n   * Variable: ARROW_DIAMOND\r\n   *\r\n   * Constant for diamond arrow markers.\r\n   */\n  ARROW_DIAMOND: 'diamond',\n  /**\r\n   * Variable: ARROW_DIAMOND_THIN\r\n   *\r\n   * Constant for thin diamond arrow markers.\r\n   */\n  ARROW_DIAMOND_THIN: 'diamondThin',\n  /**\r\n   * Variable: ALIGN_LEFT\r\n   *\r\n   * Constant for left horizontal alignment. Default is left.\r\n   */\n  ALIGN_LEFT: 'left',\n  /**\r\n   * Variable: ALIGN_CENTER\r\n   *\r\n   * Constant for center horizontal alignment. Default is center.\r\n   */\n  ALIGN_CENTER: 'center',\n  /**\r\n   * Variable: ALIGN_RIGHT\r\n   *\r\n   * Constant for right horizontal alignment. Default is right.\r\n   */\n  ALIGN_RIGHT: 'right',\n  /**\r\n   * Variable: ALIGN_TOP\r\n   *\r\n   * Constant for top vertical alignment. Default is top.\r\n   */\n  ALIGN_TOP: 'top',\n  /**\r\n   * Variable: ALIGN_MIDDLE\r\n   *\r\n   * Constant for middle vertical alignment. Default is middle.\r\n   */\n  ALIGN_MIDDLE: 'middle',\n  /**\r\n   * Variable: ALIGN_BOTTOM\r\n   *\r\n   * Constant for bottom vertical alignment. Default is bottom.\r\n   */\n  ALIGN_BOTTOM: 'bottom',\n  /**\r\n   * Variable: DIRECTION_NORTH\r\n   *\r\n   * Constant for direction north. Default is north.\r\n   */\n  DIRECTION_NORTH: 'north',\n  /**\r\n   * Variable: DIRECTION_SOUTH\r\n   *\r\n   * Constant for direction south. Default is south.\r\n   */\n  DIRECTION_SOUTH: 'south',\n  /**\r\n   * Variable: DIRECTION_EAST\r\n   *\r\n   * Constant for direction east. Default is east.\r\n   */\n  DIRECTION_EAST: 'east',\n  /**\r\n   * Variable: DIRECTION_WEST\r\n   *\r\n   * Constant for direction west. Default is west.\r\n   */\n  DIRECTION_WEST: 'west',\n  /**\r\n   * Variable: TEXT_DIRECTION_DEFAULT\r\n   *\r\n   * Constant for text direction default. Default is an empty string. Use\r\n   * this value to use the default text direction of the operating system.\r\n   */\n  TEXT_DIRECTION_DEFAULT: '',\n  /**\r\n   * Variable: TEXT_DIRECTION_AUTO\r\n   *\r\n   * Constant for text direction automatic. Default is auto. Use this value\r\n   * to find the direction for a given text with <mxText.getAutoDirection>.\r\n   */\n  TEXT_DIRECTION_AUTO: 'auto',\n  /**\r\n   * Variable: TEXT_DIRECTION_LTR\r\n   *\r\n   * Constant for text direction left to right. Default is ltr. Use this\r\n   * value for left to right text direction.\r\n   */\n  TEXT_DIRECTION_LTR: 'ltr',\n  /**\r\n   * Variable: TEXT_DIRECTION_RTL\r\n   *\r\n   * Constant for text direction right to left. Default is rtl. Use this\r\n   * value for right to left text direction.\r\n   */\n  TEXT_DIRECTION_RTL: 'rtl',\n  /**\r\n   * Variable: DIRECTION_MASK_NONE\r\n   *\r\n   * Constant for no direction.\r\n   */\n  DIRECTION_MASK_NONE: 0,\n  /**\r\n   * Variable: DIRECTION_MASK_WEST\r\n   *\r\n   * Bitwise mask for west direction.\r\n   */\n  DIRECTION_MASK_WEST: 1,\n  /**\r\n   * Variable: DIRECTION_MASK_NORTH\r\n   *\r\n   * Bitwise mask for north direction.\r\n   */\n  DIRECTION_MASK_NORTH: 2,\n  /**\r\n   * Variable: DIRECTION_MASK_SOUTH\r\n   *\r\n   * Bitwise mask for south direction.\r\n   */\n  DIRECTION_MASK_SOUTH: 4,\n  /**\r\n   * Variable: DIRECTION_MASK_EAST\r\n   *\r\n   * Bitwise mask for east direction.\r\n   */\n  DIRECTION_MASK_EAST: 8,\n  /**\r\n   * Variable: DIRECTION_MASK_ALL\r\n   *\r\n   * Bitwise mask for all directions.\r\n   */\n  DIRECTION_MASK_ALL: 15,\n  /**\r\n   * Variable: ELBOW_VERTICAL\r\n   *\r\n   * Constant for elbow vertical. Default is horizontal.\r\n   */\n  ELBOW_VERTICAL: 'vertical',\n  /**\r\n   * Variable: ELBOW_HORIZONTAL\r\n   *\r\n   * Constant for elbow horizontal. Default is horizontal.\r\n   */\n  ELBOW_HORIZONTAL: 'horizontal',\n  /**\r\n   * Variable: EDGESTYLE_ELBOW\r\n   *\r\n   * Name of the elbow edge style. Can be used as a string value\r\n   * for the STYLE_EDGE style.\r\n   */\n  EDGESTYLE_ELBOW: 'elbowEdgeStyle',\n  /**\r\n   * Variable: EDGESTYLE_ENTITY_RELATION\r\n   *\r\n   * Name of the entity relation edge style. Can be used as a string value\r\n   * for the STYLE_EDGE style.\r\n   */\n  EDGESTYLE_ENTITY_RELATION: 'entityRelationEdgeStyle',\n  /**\r\n   * Variable: EDGESTYLE_LOOP\r\n   *\r\n   * Name of the loop edge style. Can be used as a string value\r\n   * for the STYLE_EDGE style.\r\n   */\n  EDGESTYLE_LOOP: 'loopEdgeStyle',\n  /**\r\n   * Variable: EDGESTYLE_SIDETOSIDE\r\n   *\r\n   * Name of the side to side edge style. Can be used as a string value\r\n   * for the STYLE_EDGE style.\r\n   */\n  EDGESTYLE_SIDETOSIDE: 'sideToSideEdgeStyle',\n  /**\r\n   * Variable: EDGESTYLE_TOPTOBOTTOM\r\n   *\r\n   * Name of the top to bottom edge style. Can be used as a string value\r\n   * for the STYLE_EDGE style.\r\n   */\n  EDGESTYLE_TOPTOBOTTOM: 'topToBottomEdgeStyle',\n  /**\r\n   * Variable: EDGESTYLE_ORTHOGONAL\r\n   *\r\n   * Name of the generic orthogonal edge style. Can be used as a string value\r\n   * for the STYLE_EDGE style.\r\n   */\n  EDGESTYLE_ORTHOGONAL: 'orthogonalEdgeStyle',\n  /**\r\n   * Variable: EDGESTYLE_SEGMENT\r\n   *\r\n   * Name of the generic segment edge style. Can be used as a string value\r\n   * for the STYLE_EDGE style.\r\n   */\n  EDGESTYLE_SEGMENT: 'segmentEdgeStyle',\n  /**\r\n   * Variable: PERIMETER_ELLIPSE\r\n   *\r\n   * Name of the ellipse perimeter. Can be used as a string value\r\n   * for the STYLE_PERIMETER style.\r\n   */\n  PERIMETER_ELLIPSE: 'ellipsePerimeter',\n  /**\r\n   * Variable: PERIMETER_RECTANGLE\r\n   *\r\n   * Name of the rectangle perimeter. Can be used as a string value\r\n   * for the STYLE_PERIMETER style.\r\n   */\n  PERIMETER_RECTANGLE: 'rectanglePerimeter',\n  /**\r\n   * Variable: PERIMETER_RHOMBUS\r\n   *\r\n   * Name of the rhombus perimeter. Can be used as a string value\r\n   * for the STYLE_PERIMETER style.\r\n   */\n  PERIMETER_RHOMBUS: 'rhombusPerimeter',\n  /**\r\n   * Variable: PERIMETER_HEXAGON\r\n   *\r\n   * Name of the hexagon perimeter. Can be used as a string value\r\n   * for the STYLE_PERIMETER style.\r\n   */\n  PERIMETER_HEXAGON: 'hexagonPerimeter',\n  /**\r\n   * Variable: PERIMETER_TRIANGLE\r\n   *\r\n   * Name of the triangle perimeter. Can be used as a string value\r\n   * for the STYLE_PERIMETER style.\r\n   */\n  PERIMETER_TRIANGLE: 'trianglePerimeter',\n  STENCIL_NUMBER: 'number',\n  STENCIL_ITEMID: 'itemId',\n  PROCESS_ID: 'process_id'\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxEventObject\r\n *\r\n * The mxEventObject is a wrapper for all properties of a single event.\r\n * Additionally, it also offers functions to consume the event and check if it\r\n * was consumed as follows:\r\n *\r\n * (code)\r\n * evt.consume();\r\n * INV: evt.isConsumed() == true\r\n * (end)\r\n *\r\n * Constructor: mxEventObject\r\n *\r\n * Constructs a new event object with the specified name. An optional\r\n * sequence of key, value pairs can be appended to define properties.\r\n *\r\n * Example:\r\n *\r\n * (code)\r\n * new mxEventObject(\"eventName\", key1, val1, .., keyN, valN)\r\n * (end)\r\n */\nvar _default = exports[\"default\"] = mxConstants;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxConstants.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxConstraintHandler.js":
/*!******************************************************!*\
  !*** ./src/workflow/mxClient/mxConstraintHandler.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.function.bind.js */ \"../../node_modules/core-js/modules/es.function.bind.js\");\nvar _mxClient = _interopRequireDefault(__webpack_require__(/*! ./mxClient.js */ \"./src/workflow/mxClient/mxClient.js\"));\nvar _mxImageShape = _interopRequireDefault(__webpack_require__(/*! ./mxImageShape.js */ \"./src/workflow/mxClient/mxImageShape.js\"));\nvar _mxImage = _interopRequireDefault(__webpack_require__(/*! ./mxImage.js */ \"./src/workflow/mxClient/mxImage.js\"));\nvar _mxEvent = _interopRequireDefault(__webpack_require__(/*! ./mxEvent.js */ \"./src/workflow/mxClient/mxEvent.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxRectangle = _interopRequireDefault(__webpack_require__(/*! ./mxRectangle.js */ \"./src/workflow/mxClient/mxRectangle.js\"));\nvar _mxRectangleShape = _interopRequireDefault(__webpack_require__(/*! ./mxRectangleShape.js */ \"./src/workflow/mxClient/mxRectangleShape.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ./mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nvar _mxUtils = _interopRequireDefault(__webpack_require__(/*! ./mxUtils.js */ \"./src/workflow/mxClient/mxUtils.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxConstraintHandler(graph) {\n  this.graph = graph;\n\n  // Adds a graph model listener to update the current focus on changes\n  this.resetHandler = _mxGraphUtils[\"default\"].bind(this, function (sender, evt) {\n    if (this.currentFocus != null && this.graph.view.getState(this.currentFocus.cell) == null) {\n      this.reset();\n    }\n  });\n  this.graph.model.addListener(_mxEvent[\"default\"].CHANGE, this.resetHandler);\n  this.graph.view.addListener(_mxEvent[\"default\"].SCALE, this.resetHandler);\n  this.graph.addListener(_mxEvent[\"default\"].ROOT, this.resetHandler);\n}\n;\n\n/**\r\n * Variable: pointImage\r\n *\r\n * <mxImage> to be used as the image for fixed connection points.\r\n */\nmxConstraintHandler.prototype.pointImage = new _mxImage[\"default\"]('data:image/gif;base64,R0lGODlhBQAFAJECAAAA/////////wAAACH5BAEAAAIALAAAAAAFAAUAAAIIRBSml7yGQAEAOw==', 5, 5);\n\n/**\r\n * Variable: graph\r\n *\r\n * Reference to the enclosing <mxGraph>.\r\n */\nmxConstraintHandler.prototype.graph = null;\n\n/**\r\n * Variable: enabled\r\n *\r\n * Specifies if events are handled. Default is true.\r\n */\nmxConstraintHandler.prototype.enabled = true;\n\n/**\r\n * Variable: highlightColor\r\n *\r\n * Specifies the color for the highlight. Default is <mxConstants.DEFAULT_VALID_COLOR>.\r\n */\nmxConstraintHandler.prototype.highlightColor = _mxConstants[\"default\"].DEFAULT_VALID_COLOR;\n\n/**\r\n * Function: isEnabled\r\n *\r\n * Returns true if events are handled. This implementation\r\n * returns <enabled>.\r\n */\nmxConstraintHandler.prototype.isEnabled = function () {\n  return this.enabled;\n};\n\n/**\r\n * Function: setEnabled\r\n *\r\n * Enables or disables event handling. This implementation\r\n * updates <enabled>.\r\n *\r\n * Parameters:\r\n *\r\n * enabled - Boolean that specifies the new enabled state.\r\n */\nmxConstraintHandler.prototype.setEnabled = function (enabled) {\n  this.enabled = enabled;\n};\n\n/**\r\n * Function: reset\r\n *\r\n * Resets the state of this handler.\r\n */\nmxConstraintHandler.prototype.reset = function () {\n  if (this.focusIcons != null) {\n    for (var i = 0; i < this.focusIcons.length; i++) {\n      this.focusIcons[i].destroy();\n    }\n    this.focusIcons = null;\n  }\n  if (this.focusHighlight != null) {\n    this.focusHighlight.destroy();\n    this.focusHighlight = null;\n  }\n  this.currentConstraint = null;\n  this.currentFocusArea = null;\n  this.currentPoint = null;\n  this.currentFocus = null;\n  this.focusPoints = null;\n};\n\n/**\r\n * Function: getTolerance\r\n *\r\n * Returns the tolerance to be used for intersecting connection points. This\r\n * implementation returns <mxGraph.tolerance>.\r\n *\r\n * Parameters:\r\n *\r\n * me - <mxMouseEvent> whose tolerance should be returned.\r\n */\nmxConstraintHandler.prototype.getTolerance = function (me) {\n  return this.graph.getTolerance();\n};\n\n/**\r\n * Function: getImageForConstraint\r\n *\r\n * Returns the tolerance to be used for intersecting connection points.\r\n */\nmxConstraintHandler.prototype.getImageForConstraint = function (state, constraint, point) {\n  return this.pointImage;\n};\n\n/**\r\n * Function: isEventIgnored\r\n *\r\n * Returns true if the given <mxMouseEvent> should be ignored in <update>. This\r\n * implementation always returns false.\r\n */\nmxConstraintHandler.prototype.isEventIgnored = function (me, source) {\n  return false;\n};\n\n/**\r\n * Function: isStateIgnored\r\n *\r\n * Returns true if the given state should be ignored. This always returns false.\r\n */\nmxConstraintHandler.prototype.isStateIgnored = function (state, source) {\n  return false;\n};\n\n/**\r\n * Function: destroyIcons\r\n *\r\n * Destroys the <focusIcons> if they exist.\r\n */\nmxConstraintHandler.prototype.destroyIcons = function () {\n  if (this.focusIcons != null) {\n    for (var i = 0; i < this.focusIcons.length; i++) {\n      this.focusIcons[i].destroy();\n    }\n    this.focusIcons = null;\n    this.focusPoints = null;\n  }\n};\n\n/**\r\n * Function: destroyFocusHighlight\r\n *\r\n * Destroys the <focusHighlight> if one exists.\r\n */\nmxConstraintHandler.prototype.destroyFocusHighlight = function () {\n  if (this.focusHighlight != null) {\n    this.focusHighlight.destroy();\n    this.focusHighlight = null;\n  }\n};\n\n/**\r\n * Function: isKeepFocusEvent\r\n *\r\n * Returns true if the current focused state should not be changed for the given event.\r\n * This returns true if shift and alt are pressed.\r\n */\nmxConstraintHandler.prototype.isKeepFocusEvent = function (me) {\n  return _mxEvent[\"default\"].isShiftDown(me.getEvent());\n};\n\n/**\r\n * Function: getCellForEvent\r\n *\r\n * Returns the cell for the given event.\r\n */\nmxConstraintHandler.prototype.getCellForEvent = function (me, point) {\n  var cell = me.getCell();\n\n  // Gets cell under actual point if different from event location\n  if (cell == null && point != null && (me.getGraphX() != point.x || me.getGraphY() != point.y)) {\n    cell = this.graph.getCellAt(point.x, point.y);\n  }\n\n  // Uses connectable parent vertex if one exists\n  if (cell != null && !this.graph.isCellConnectable(cell)) {\n    var parent = this.graph.getModel().getParent(cell);\n    if (this.graph.getModel().isVertex(parent) && this.graph.isCellConnectable(parent)) {\n      cell = parent;\n    }\n  }\n  return cell;\n};\n\n/**\r\n * Function: update\r\n *\r\n * Updates the state of this handler based on the given <mxMouseEvent>.\r\n * Source is a boolean indicating if the cell is a source or target.\r\n */\nmxConstraintHandler.prototype.update = function (me, source, existingEdge, point) {\n  if (this.isEnabled() && !this.isEventIgnored(me)) {\n    // Lazy installation of mouseleave handler\n    if (this.mouseleaveHandler == null && this.graph.container != null) {\n      this.mouseleaveHandler = _mxGraphUtils[\"default\"].bind(this, function () {\n        this.reset();\n      });\n      _mxEvent[\"default\"].addListener(this.graph.container, 'mouseleave', this.resetHandler);\n    }\n    var tol = this.getTolerance(me);\n    var x = point != null ? point.x : me.getGraphX();\n    var y = point != null ? point.y : me.getGraphY();\n    var grid = new _mxRectangle[\"default\"](x - tol, y - tol, 2 * tol, 2 * tol);\n    var mouse = new _mxRectangle[\"default\"](me.getGraphX() - tol, me.getGraphY() - tol, 2 * tol, 2 * tol);\n    var state = this.graph.view.getState(this.getCellForEvent(me, point));\n\n    // Keeps focus icons visible while over vertex bounds and no other cell under mouse or shift is pressed\n    if (!this.isKeepFocusEvent(me) && (this.currentFocusArea == null || this.currentFocus == null || state != null || !this.graph.getModel().isVertex(this.currentFocus.cell) || !_mxUtils[\"default\"].intersects(this.currentFocusArea, mouse)) && state != this.currentFocus) {\n      this.currentFocusArea = null;\n      this.currentFocus = null;\n      this.setFocus(me, state, source);\n    }\n    this.currentConstraint = null;\n    this.currentPoint = null;\n    var minDistSq = null;\n    if (this.focusIcons != null && this.constraints != null && (state == null || this.currentFocus == state)) {\n      var cx = mouse.getCenterX();\n      var cy = mouse.getCenterY();\n      for (var i = 0; i < this.focusIcons.length; i++) {\n        var dx = cx - this.focusIcons[i].bounds.getCenterX();\n        var dy = cy - this.focusIcons[i].bounds.getCenterY();\n        var tmp = dx * dx + dy * dy;\n        if ((this.intersects(this.focusIcons[i], mouse, source, existingEdge) || point != null && this.intersects(this.focusIcons[i], grid, source, existingEdge)) && (minDistSq == null || tmp < minDistSq)) {\n          this.currentConstraint = this.constraints[i];\n          this.currentPoint = this.focusPoints[i];\n          minDistSq = tmp;\n          var tmp = this.focusIcons[i].bounds.clone();\n          tmp.grow(_mxConstants[\"default\"].HIGHLIGHT_SIZE);\n          if (_mxClient[\"default\"].IS_IE) {\n            tmp.grow(1);\n            tmp.width -= 1;\n            tmp.height -= 1;\n          }\n          if (this.focusHighlight == null) {\n            var hl = this.createHighlightShape();\n            hl.dialect = this.graph.dialect == _mxConstants[\"default\"].DIALECT_SVG ? _mxConstants[\"default\"].DIALECT_SVG : _mxConstants[\"default\"].DIALECT_VML;\n            hl.pointerEvents = false;\n            hl.init(this.graph.getView().getOverlayPane());\n            this.focusHighlight = hl;\n            var getState = _mxGraphUtils[\"default\"].bind(this, function () {\n              return this.currentFocus != null ? this.currentFocus : state;\n            });\n            _mxEvent[\"default\"].redirectMouseEvents(hl.node, this.graph, getState);\n          }\n          this.focusHighlight.bounds = tmp;\n          this.focusHighlight.redraw();\n        }\n      }\n    }\n    if (this.currentConstraint == null) {\n      this.destroyFocusHighlight();\n    }\n  } else {\n    this.currentConstraint = null;\n    this.currentFocus = null;\n    this.currentPoint = null;\n  }\n};\n\n/**\r\n * Function: setFocus\r\n *\r\n * Transfers the focus to the given state as a source or target terminal. If\r\n * the handler is not enabled then the outline is painted, but the constraints\r\n * are ignored.\r\n */\nmxConstraintHandler.prototype.setFocus = function (me, state, source) {\n  this.constraints = state != null && !this.isStateIgnored(state, source) && this.graph.isCellConnectable(state.cell) ? this.isEnabled() ? this.graph.getAllConnectionConstraints(state, source) || [] : [] : null;\n\n  // Only uses cells which have constraints\n  if (state && this.constraints != null) {\n    this.currentFocus = state;\n    this.currentFocusArea = new _mxRectangle[\"default\"](state.x, state.y, state.width, state.height);\n    if (this.focusIcons != null) {\n      for (var i = 0; i < this.focusIcons.length; i++) {\n        this.focusIcons[i].destroy();\n      }\n      this.focusIcons = null;\n      this.focusPoints = null;\n    }\n    this.focusPoints = [];\n    this.focusIcons = [];\n    for (var i = 0; i < this.constraints.length; i++) {\n      var cp = this.graph.getConnectionPoint(state, this.constraints[i]);\n      var img = this.getImageForConstraint(state, this.constraints[i], cp);\n      var src = img.src;\n      var bounds = new _mxRectangle[\"default\"](Math.round(cp.x - img.width / 2), Math.round(cp.y - img.height / 2), img.width, img.height);\n      var icon = new _mxImageShape[\"default\"](bounds, src);\n      icon.dialect = this.graph.dialect != _mxConstants[\"default\"].DIALECT_SVG ? _mxConstants[\"default\"].DIALECT_MIXEDHTML : _mxConstants[\"default\"].DIALECT_SVG;\n      icon.preserveImageAspect = false;\n      icon.init(this.graph.getView().getDecoratorPane());\n\n      // Fixes lost event tracking for images in quirks / IE8 standards\n      if (_mxClient[\"default\"].IS_QUIRKS || document.documentMode == 8) {\n        _mxEvent[\"default\"].addListener(icon.node, 'dragstart', function (evt) {\n          _mxEvent[\"default\"].consume(evt);\n          return false;\n        });\n      }\n\n      // Move the icon behind all other overlays\n      if (icon.node.previousSibling != null) {\n        icon.node.parentNode.insertBefore(icon.node, icon.node.parentNode.firstChild);\n      }\n      var getState = _mxGraphUtils[\"default\"].bind(this, function () {\n        return this.currentFocus != null ? this.currentFocus : state;\n      });\n      icon.redraw();\n      _mxEvent[\"default\"].redirectMouseEvents(icon.node, this.graph, getState);\n      this.currentFocusArea.add(icon.bounds);\n      this.focusIcons.push(icon);\n      this.focusPoints.push(cp);\n    }\n    this.currentFocusArea.grow(this.getTolerance(me));\n  } else {\n    this.destroyIcons();\n    this.destroyFocusHighlight();\n  }\n};\n\n/**\r\n * Function: createHighlightShape\r\n *\r\n * Create the shape used to paint the highlight.\r\n *\r\n * Returns true if the given icon intersects the given point.\r\n */\nmxConstraintHandler.prototype.createHighlightShape = function () {\n  var hl = new _mxRectangleShape[\"default\"](null, this.highlightColor, this.highlightColor, _mxConstants[\"default\"].HIGHLIGHT_STROKEWIDTH);\n  hl.opacity = _mxConstants[\"default\"].HIGHLIGHT_OPACITY;\n  return hl;\n};\n\n/**\r\n * Function: intersects\r\n *\r\n * Returns true if the given icon intersects the given rectangle.\r\n */\nmxConstraintHandler.prototype.intersects = function (icon, mouse, source, existingEdge) {\n  return _mxUtils[\"default\"].intersects(icon.bounds, mouse);\n};\n\n/**\r\n * Function: destroy\r\n *\r\n * Destroy this handler.\r\n */\nmxConstraintHandler.prototype.destroy = function () {\n  this.reset();\n  if (this.resetHandler != null) {\n    this.graph.model.removeListener(this.resetHandler);\n    this.graph.view.removeListener(this.resetHandler);\n    this.graph.removeListener(this.resetHandler);\n    this.resetHandler = null;\n  }\n  if (this.mouseleaveHandler != null && this.graph.container != null) {\n    _mxEvent[\"default\"].removeListener(this.graph.container, 'mouseleave', this.mouseleaveHandler);\n    this.mouseleaveHandler = null;\n  }\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxRubberband\r\n *\r\n * Event handler that selects rectangular regions. This is not built-into\r\n * <mxGraph>. To enable rubberband selection in a graph, ssssssssuse the following code.\r\n *\r\n * Example:\r\n *\r\n * (code)\r\n * var rubberband = new mxRubberband(graph);\r\n * (end)\r\n *\r\n * Constructor: mxRubberband\r\n *\r\n * Constructs an event handler that selects rectangular regions in the graph\r\n * using rubberband selection.\r\n */\nvar _default = exports[\"default\"] = mxConstraintHandler;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxConstraintHandler.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxCurrentRootChange.js":
/*!******************************************************!*\
  !*** ./src/workflow/mxClient/mxCurrentRootChange.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _mxEventObject = _interopRequireDefault(__webpack_require__(/*! ./mxEventObject.js */ \"./src/workflow/mxClient/mxEventObject.js\"));\nvar _mxEvent = _interopRequireDefault(__webpack_require__(/*! ./mxEvent.js */ \"./src/workflow/mxClient/mxEvent.js\"));\nvar _mxPoint = _interopRequireDefault(__webpack_require__(/*! ./mxPoint.js */ \"./src/workflow/mxClient/mxPoint.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxCurrentRootChange(view, root) {\n  this.view = view;\n  this.root = root;\n  this.previous = root;\n  this.isUp = root == null;\n  if (!this.isUp) {\n    var tmp = this.view.currentRoot;\n    var model = this.view.graph.getModel();\n    while (tmp != null) {\n      if (tmp == root) {\n        this.isUp = true;\n        break;\n      }\n      tmp = model.getParent(tmp);\n    }\n  }\n}\n;\n\n/**\r\n * Function: execute\r\n *\r\n * Changes the current root of the view.\r\n */\nmxCurrentRootChange.prototype.execute = function () {\n  var tmp = this.view.currentRoot;\n  this.view.currentRoot = this.previous;\n  this.previous = tmp;\n  var translate = this.view.graph.getTranslateForRoot(this.view.currentRoot);\n  if (translate != null) {\n    this.view.translate = new _mxPoint[\"default\"](-translate.x, -translate.y);\n  }\n  if (this.isUp) {\n    this.view.clear(this.view.currentRoot, true);\n    this.view.validate();\n  } else {\n    this.view.refresh();\n  }\n  var name = this.isUp ? _mxEvent[\"default\"].UP : _mxEvent[\"default\"].DOWN;\n  this.view.fireEvent(new _mxEventObject[\"default\"](name, 'root', this.view.currentRoot, 'previous', this.previous));\n  this.isUp = !this.isUp;\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxGraph\r\n *\r\n * Extends <mxEventSource> to implement a graph component for\r\n * the browser. This is the main class of the package. To activate\r\n * panning and connections use <setPanning> and <setConnectable>.\r\n * For rubberband selection you must create a new instance of\r\n * <mxRubberband>. The following listeners are added to\r\n * <mouseListeners> by default:\r\n *\r\n * - <tooltipHandler>: <mxTooltipHandler> that displays tooltips\r\n * - <panningHandler>: <mxPanningHandler> for panning and popup menus\r\n * - <connectionHandler>: <mxConnectionHandler> for creating connections\r\n * - <graphHandler>: <mxGraphHandler> for moving and cloning cells\r\n *\r\n * These listeners will be called in the above order if they are enabled.\r\n *\r\n * Background Images:\r\n *\r\n * To display a background image, set the image, image width and\r\n * image height using <setBackgroundImage>. If one of the\r\n * above values has changed then the <view>'s <mxGraphView.validate>\r\n * should be invoked.\r\n *\r\n * Cell Images:\r\n *\r\n * To use images in cells, a shape must be specified in the default\r\n * vertex style (or any named style). Possible shapes are\r\n * <mxConstants.SHAPE_IMAGE> and <mxConstants.SHAPE_LABEL>.\r\n * The code to change the shape used in the default vertex style,\r\n * the following code is used:\r\n *\r\n * (code)\r\n * var style = graph.getStylesheet().getDefaultVertexStyle();\r\n * style[mxConstants.STYLE_SHAPE] = mxConstants.SHAPE_IMAGE;\r\n * (end)\r\n *\r\n * For the default vertex style, the image to be displayed can be\r\n * specified in a cell's style using the <mxConstants.STYLE_IMAGE>\r\n * key and the image URL as a value, for example:\r\n *\r\n * (code)\r\n * image=http://www.example.com/image.gif\r\n * (end)\r\n *\r\n * For a named style, the the stylename must be the first element\r\n * of the cell style:\r\n *\r\n * (code)\r\n * stylename;image=http://www.example.com/image.gif\r\n * (end)\r\n *\r\n * A cell style can have any number of key=value pairs added, divided\r\n * by a semicolon as follows:\r\n *\r\n * (code)\r\n * [stylename;|key=value;]\r\n * (end)\r\n *\r\n * Labels:\r\n *\r\n * The cell labels are defined by <getLabel> which uses <convertValueToString>\r\n * if <labelsVisible> is true. If a label must be rendered as HTML markup, then\r\n * <isHtmlLabel> should return true for the respective cell. If all labels\r\n * contain HTML markup, <htmlLabels> can be set to true. NOTE: Enabling HTML\r\n * labels carries a possible security risk (see the section on security in\r\n * the manual).\r\n *\r\n * If wrapping is needed for a label, then <isHtmlLabel> and <isWrapping> must\r\n * return true for the cell whose label should be wrapped. See <isWrapping> for\r\n * an example.\r\n *\r\n * If clipping is needed to keep the rendering of a HTML label inside the\r\n * bounds of its vertex, then <isClipping> should return true for the\r\n * respective cell.\r\n *\r\n * By default, edge labels are movable and vertex labels are fixed. This can be\r\n * changed by setting <edgeLabelsMovable> and <vertexLabelsMovable>, or by\r\n * overriding <isLabelMovable>.\r\n *\r\n * In-place Editing:\r\n *\r\n * In-place editing is started with a doubleclick or by typing F2.\r\n * Programmatically, <edit> is used to check if the cell is editable\r\n * (<isCellEditable>) and call <startEditingAtCell>, which invokes\r\n * <mxCellEditor.startEditing>. The editor uses the value returned\r\n * by <getEditingValue> as the editing value.\r\n *\r\n * After in-place editing, <labelChanged> is called, which invokes\r\n * <mxGraphModel.setValue>, which in turn calls\r\n * <mxGraphModel.valueForCellChanged> via <mxValueChange>.\r\n *\r\n * The event that triggers in-place editing is passed through to the\r\n * <cellEditor>, which may take special actions depending on the type of the\r\n * event or mouse location, and is also passed to <getEditingValue>. The event\r\n * is then passed back to the event processing functions which can perform\r\n * specific actions based on the trigger event.\r\n *\r\n * Tooltips:\r\n *\r\n * Tooltips are implemented by <getTooltip>, which calls <getTooltipForCell>\r\n * if a cell is under the mousepointer. The default implementation checks if\r\n * the cell has a getTooltip function and calls it if it exists. Hence, in order\r\n * to provide custom tooltips, the cell must provide a getTooltip function, or\r\n * one of the two above functions must be overridden.\r\n *\r\n * Typically, for custom cell tooltips, the latter function is overridden as\r\n * follows:\r\n *\r\n * (code)\r\n * graph.getTooltipForCell = function(cell)\r\n * {\r\n *   var label = this.convertValueToString(cell);\r\n *   return 'Tooltip for '+label;\r\n * }\r\n * (end)\r\n *\r\n * When using a config file, the function is overridden in the mxGraph section\r\n * using the following entry:\r\n *\r\n * (code)\r\n * <add as=\"getTooltipForCell\"><![CDATA[\r\n *   function(cell)\r\n *   {\r\n *     var label = this.convertValueToString(cell);\r\n *     return 'Tooltip for '+label;\r\n *   }\r\n * ]]></add>\r\n * (end)\r\n *\r\n * \"this\" refers to the graph in the implementation, so for example to check if\r\n * a cell is an edge, you use this.getModel().isEdge(cell)\r\n *\r\n * For replacing the default implementation of <getTooltipForCell> (rather than\r\n * replacing the function on a specific instance), the following code should be\r\n * used after loading the JavaScript files, but before creating a new mxGraph\r\n * instance using <mxGraph>:\r\n *\r\n * (code)\r\n * mxGraph.prototype.getTooltipForCell = function(cell)\r\n * {\r\n *   var label = this.convertValueToString(cell);\r\n *   return 'Tooltip for '+label;\r\n * }\r\n * (end)\r\n *\r\n * Shapes & Styles:\r\n *\r\n * The implementation of new shapes is demonstrated in the examples. We'll assume\r\n * that we have implemented a custom shape with the name BoxShape which we want\r\n * to use for drawing vertices. To use this shape, it must first be registered in\r\n * the cell renderer as follows:\r\n *\r\n * (code)\r\n * mxCellRenderer.registerShape('box', BoxShape);\r\n * (end)\r\n *\r\n * The code registers the BoxShape constructor under the name box in the cell\r\n * renderer of the graph. The shape can now be referenced using the shape-key in\r\n * a style definition. (The cell renderer contains a set of additional shapes,\r\n * namely one for each constant with a SHAPE-prefix in <mxConstants>.)\r\n *\r\n * Styles are a collection of key, value pairs and a stylesheet is a collection\r\n * of named styles. The names are referenced by the cellstyle, which is stored\r\n * in <mxCell.style> with the following format: [stylename;|key=value;]. The\r\n * string is resolved to a collection of key, value pairs, where the keys are\r\n * overridden with the values in the string.\r\n *\r\n * When introducing a new shape, the name under which the shape is registered\r\n * must be used in the stylesheet. There are three ways of doing this:\r\n *\r\n *   - By changing the default style, so that all vertices will use the new\r\n * \t\tshape\r\n *   - By defining a new style, so that only vertices with the respective\r\n * \t\tcellstyle will use the new shape\r\n *   - By using shape=box in the cellstyle's optional list of key, value pairs\r\n * \t\tto be overridden\r\n *\r\n * In the first case, the code to fetch and modify the default style for\r\n * vertices is as follows:\r\n *\r\n * (code)\r\n * var style = graph.getStylesheet().getDefaultVertexStyle();\r\n * style[mxConstants.STYLE_SHAPE] = 'box';\r\n * (end)\r\n *\r\n * The code takes the default vertex style, which is used for all vertices that\r\n * do not have a specific cellstyle, and modifies the value for the shape-key\r\n * in-place to use the new BoxShape for drawing vertices. This is done by\r\n * assigning the box value in the second line, which refers to the name of the\r\n * BoxShape in the cell renderer.\r\n *\r\n * In the second case, a collection of key, value pairs is created and then\r\n * added to the stylesheet under a new name. In order to distinguish the\r\n * shapename and the stylename we'll use boxstyle for the stylename:\r\n *\r\n * (code)\r\n * var style = new Object();\r\n * style[mxConstants.STYLE_SHAPE] = 'box';\r\n * style[mxConstants.STYLE_STROKECOLOR] = '#000000';\r\n * style[mxConstants.STYLE_FONTCOLOR] = '#000000';\r\n * graph.getStylesheet().putCellStyle('boxstyle', style);\r\n * (end)\r\n *\r\n * The code adds a new style with the name boxstyle to the stylesheet. To use\r\n * this style with a cell, it must be referenced from the cellstyle as follows:\r\n *\r\n * (code)\r\n * var vertex = graph.insertVertex(parent, null, 'Hello, World!', 20, 20, 80, 20,\r\n * \t\t\t\t'boxstyle');\r\n * (end)\r\n *\r\n * To summarize, each new shape must be registered in the <mxCellRenderer> with\r\n * a unique name. That name is then used as the value of the shape-key in a\r\n * default or custom style. If there are multiple custom shapes, then there\r\n * should be a separate style for each shape.\r\n *\r\n * Inheriting Styles:\r\n *\r\n * For fill-, stroke-, gradient- and indicatorColors special keywords can be\r\n * used. The inherit keyword for one of these colors will inherit the color\r\n * for the same key from the parent cell. The swimlane keyword does the same,\r\n * but inherits from the nearest swimlane in the ancestor hierarchy. Finally,\r\n * the indicated keyword will use the color of the indicator as the color for\r\n * the given key.\r\n *\r\n * Scrollbars:\r\n *\r\n * The <containers> overflow CSS property defines if scrollbars are used to\r\n * display the graph. For values of 'auto' or 'scroll', the scrollbars will\r\n * be shown. Note that the <resizeContainer> flag is normally not used\r\n * together with scrollbars, as it will resize the container to match the\r\n * size of the graph after each change.\r\n *\r\n * Multiplicities and Validation:\r\n *\r\n * To control the possible connections in mxGraph, <getEdgeValidationError> is\r\n * used. The default implementation of the function uses <multiplicities>,\r\n * which is an array of <mxMultiplicity>. Using this class allows to establish\r\n * simple multiplicities, which are enforced by the graph.\r\n *\r\n * The <mxMultiplicity> uses <mxCell.is> to determine for which terminals it\r\n * applies. The default implementation of <mxCell.is> works with DOM nodes (XML\r\n * nodes) and checks if the given type parameter matches the nodeName of the\r\n * node (case insensitive). Optionally, an attributename and value can be\r\n * specified which are also checked.\r\n *\r\n * <getEdgeValidationError> is called whenever the connectivity of an edge\r\n * changes. It returns an empty string or an error message if the edge is\r\n * invalid or null if the edge is valid. If the returned string is not empty\r\n * then it is displayed as an error message.\r\n *\r\n * <mxMultiplicity> allows to specify the multiplicity between a terminal and\r\n * its possible neighbors. For example, if any rectangle may only be connected\r\n * to, say, a maximum of two circles you can add the following rule to\r\n * <multiplicities>:\r\n *\r\n * (code)\r\n * graph.multiplicities.push(new mxMultiplicity(\r\n *   true, 'rectangle', null, null, 0, 2, ['circle'],\r\n *   'Only 2 targets allowed',\r\n *   'Only shape targets allowed'));\r\n * (end)\r\n *\r\n * This will display the first error message whenever a rectangle is connected\r\n * to more than two circles and the second error message if a rectangle is\r\n * connected to anything but a circle.\r\n *\r\n * For certain multiplicities, such as a minimum of 1 connection, which cannot\r\n * be enforced at cell creation time (unless the cell is created together with\r\n * the connection), mxGraph offers <validate> which checks all multiplicities\r\n * for all cells and displays the respective error messages in an overlay icon\r\n * on the cells.\r\n *\r\n * If a cell is collapsed and contains validation errors, a respective warning\r\n * icon is attached to the collapsed cell.\r\n *\r\n * Auto-Layout:\r\n *\r\n * For automatic layout, the <getLayout> hook is provided in <mxLayoutManager>.\r\n * It can be overridden to return a layout algorithm for the children of a\r\n * given cell.\r\n *\r\n * Unconnected edges:\r\n *\r\n * The default values for all switches are designed to meet the requirements of\r\n * general diagram drawing applications. A very typical set of settings to\r\n * avoid edges that are not connected is the following:\r\n *\r\n * (code)\r\n * graph.setAllowDanglingEdges(false);\r\n * graph.setDisconnectOnMove(false);\r\n * (end)\r\n *\r\n * Setting the <cloneInvalidEdges> switch to true is optional. This switch\r\n * controls if edges are inserted after a copy, paste or clone-drag if they are\r\n * invalid. For example, edges are invalid if copied or control-dragged without\r\n * having selected the corresponding terminals and allowDanglingEdges is\r\n * false, in which case the edges will not be cloned if the switch is false.\r\n *\r\n * Output:\r\n *\r\n * To produce an XML representation for a diagram, the following code can be\r\n * used.\r\n *\r\n * (code)\r\n * var enc = new mxCodec(mxUtils.createXmlDocument());\r\n * var node = enc.encode(graph.getModel());\r\n * (end)\r\n *\r\n * This will produce an XML node than can be handled using the DOM API or\r\n * turned into a string representation using the following code:\r\n *\r\n * (code)\r\n * var xml = mxUtils.getXml(node);\r\n * (end)\r\n *\r\n * To obtain a formatted string, mxUtils.getPrettyXml can be used instead.\r\n *\r\n * This string can now be stored in a local persistent storage (for example\r\n * using Google Gears) or it can be passed to a backend using mxUtils.post as\r\n * follows. The url variable is the URL of the Java servlet, PHP page or HTTP\r\n * handler, depending on the server.\r\n *\r\n * (code)\r\n * var xmlString = encodeURIComponent(mxUtils.getXml(node));\r\n * mxUtils.post(url, 'xml='+xmlString, function(req)\r\n * {\r\n *   // Process server response using req of type mxXmlRequest\r\n * });\r\n * (end)\r\n *\r\n * Input:\r\n *\r\n * To load an XML representation of a diagram into an existing graph object\r\n * mxRequestUtils.load can be used as follows. The url variable is the URL of the Java\r\n * servlet, PHP page or HTTP handler that produces the XML string.\r\n *\r\n * (code)\r\n * var xmlDoc = mxRequestUtils.load(url).getXml();\r\n * var node = xmlDoc.documentElement;\r\n * var dec = new mxCodec(node.ownerDocument);\r\n * dec.decode(node, graph.getModel());\r\n * (end)\r\n *\r\n * For creating a page that loads the client and a diagram using a single\r\n * request please refer to the deployment examples in the backends.\r\n *\r\n * Functional dependencies:\r\n *\r\n * (see images/callgraph.png)\r\n *\r\n * Resources:\r\n *\r\n * resources/graph - Language resources for mxGraph\r\n *\r\n * Group: Events\r\n *\r\n * Event: mxEvent.ROOT\r\n *\r\n * Fires if the root in the model has changed. This event has no properties.\r\n *\r\n * Event: mxEvent.ALIGN_CELLS\r\n *\r\n * Fires between begin- and endUpdate in <alignCells>. The <code>cells</code>\r\n * and <code>align</code> properties contain the respective arguments that were\r\n * passed to <alignCells>.\r\n *\r\n * Event: mxEvent.FLIP_EDGE\r\n *\r\n * Fires between begin- and endUpdate in <flipEdge>. The <code>edge</code>\r\n * property contains the edge passed to <flipEdge>.\r\n *\r\n * Event: mxEvent.ORDER_CELLS\r\n *\r\n * Fires between begin- and endUpdate in <orderCells>. The <code>cells</code>\r\n * and <code>back</code> properties contain the respective arguments that were\r\n * passed to <orderCells>.\r\n *\r\n * Event: mxEvent.CELLS_ORDERED\r\n *\r\n * Fires between begin- and endUpdate in <cellsOrdered>. The <code>cells</code>\r\n * and <code>back</code> arguments contain the respective arguments that were\r\n * passed to <cellsOrdered>.\r\n *\r\n * Event: mxEvent.GROUP_CELLS\r\n *\r\n * Fires between begin- and endUpdate in <groupCells>. The <code>group</code>,\r\n * <code>cells</code> and <code>border</code> arguments contain the respective\r\n * arguments that were passed to <groupCells>.\r\n *\r\n * Event: mxEvent.UNGROUP_CELLS\r\n *\r\n * Fires between begin- and endUpdate in <ungroupCells>. The <code>cells</code>\r\n * property contains the array of cells that was passed to <ungroupCells>.\r\n *\r\n * Event: mxEvent.REMOVE_CELLS_FROM_PARENT\r\n *\r\n * Fires between begin- and endUpdate in <removeCellsFromParent>. The\r\n * <code>cells</code> property contains the array of cells that was passed to\r\n * <removeCellsFromParent>.\r\n *\r\n * Event: mxEvent.ADD_CELLS\r\n *\r\n * Fires between begin- and endUpdate in <addCells>. The <code>cells</code>,\r\n * <code>parent</code>, <code>index</code>, <code>source</code> and\r\n * <code>target</code> properties contain the respective arguments that were\r\n * passed to <addCells>.\r\n *\r\n * Event: mxEvent.CELLS_ADDED\r\n *\r\n * Fires between begin- and endUpdate in <cellsAdded>. The <code>cells</code>,\r\n * <code>parent</code>, <code>index</code>, <code>source</code>,\r\n * <code>target</code> and <code>absolute</code> properties contain the\r\n * respective arguments that were passed to <cellsAdded>.\r\n *\r\n * Event: mxEvent.REMOVE_CELLS\r\n *\r\n * Fires between begin- and endUpdate in <removeCells>. The <code>cells</code>\r\n * and <code>includeEdges</code> arguments contain the respective arguments\r\n * that were passed to <removeCells>.\r\n *\r\n * Event: mxEvent.CELLS_REMOVED\r\n *\r\n * Fires between begin- and endUpdate in <cellsRemoved>. The <code>cells</code>\r\n * argument contains the array of cells that was removed.\r\n *\r\n * Event: mxEvent.SPLIT_EDGE\r\n *\r\n * Fires between begin- and endUpdate in <splitEdge>. The <code>edge</code>\r\n * property contains the edge to be splitted, the <code>cells</code>,\r\n * <code>newEdge</code>, <code>dx</code> and <code>dy</code> properties contain\r\n * the respective arguments that were passed to <splitEdge>.\r\n *\r\n * Event: mxEvent.TOGGLE_CELLS\r\n *\r\n * Fires between begin- and endUpdate in <toggleCells>. The <code>show</code>,\r\n * <code>cells</code> and <code>includeEdges</code> properties contain the\r\n * respective arguments that were passed to <toggleCells>.\r\n *\r\n * Event: mxEvent.FOLD_CELLS\r\n *\r\n * Fires between begin- and endUpdate in <foldCells>. The\r\n * <code>collapse</code>, <code>cells</code> and <code>recurse</code>\r\n * properties contain the respective arguments that were passed to <foldCells>.\r\n *\r\n * Event: mxEvent.CELLS_FOLDED\r\n *\r\n * Fires between begin- and endUpdate in cellsFolded. The\r\n * <code>collapse</code>, <code>cells</code> and <code>recurse</code>\r\n * properties contain the respective arguments that were passed to\r\n * <cellsFolded>.\r\n *\r\n * Event: mxEvent.UPDATE_CELL_SIZE\r\n *\r\n * Fires between begin- and endUpdate in <updateCellSize>. The\r\n * <code>cell</code> and <code>ignoreChildren</code> properties contain the\r\n * respective arguments that were passed to <updateCellSize>.\r\n *\r\n * Event: mxEvent.RESIZE_CELLS\r\n *\r\n * Fires between begin- and endUpdate in <resizeCells>. The <code>cells</code>\r\n * and <code>bounds</code> properties contain the respective arguments that\r\n * were passed to <resizeCells>.\r\n *\r\n * Event: mxEvent.CELLS_RESIZED\r\n *\r\n * Fires between begin- and endUpdate in <cellsResized>. The <code>cells</code>\r\n * and <code>bounds</code> properties contain the respective arguments that\r\n * were passed to <cellsResized>.\r\n *\r\n * Event: mxEvent.MOVE_CELLS\r\n *\r\n * Fires between begin- and endUpdate in <moveCells>. The <code>cells</code>,\r\n * <code>dx</code>, <code>dy</code>, <code>clone</code>, <code>target</code>\r\n * and <code>event</code> properties contain the respective arguments that\r\n * were passed to <moveCells>.\r\n *\r\n * Event: mxEvent.CELLS_MOVED\r\n *\r\n * Fires between begin- and endUpdate in <cellsMoved>. The <code>cells</code>,\r\n * <code>dx</code>, <code>dy</code> and <code>disconnect</code> properties\r\n * contain the respective arguments that were passed to <cellsMoved>.\r\n *\r\n * Event: mxEvent.CONNECT_CELL\r\n *\r\n * Fires between begin- and endUpdate in <connectCell>. The <code>edge</code>,\r\n * <code>terminal</code> and <code>source</code> properties contain the\r\n * respective arguments that were passed to <connectCell>.\r\n *\r\n * Event: mxEvent.CELL_CONNECTED\r\n *\r\n * Fires between begin- and endUpdate in <cellConnected>. The\r\n * <code>edge</code>, <code>terminal</code> and <code>source</code> properties\r\n * contain the respective arguments that were passed to <cellConnected>.\r\n *\r\n * Event: mxEvent.REFRESH\r\n *\r\n * Fires after <refresh> was executed. This event has no properties.\r\n *\r\n * Event: mxEvent.CLICK\r\n *\r\n * Fires in <click> after a click event. The <code>event</code> property\r\n * contains the original mouse event and <code>cell</code> property contains\r\n * the cell under the mouse or null if the background was clicked.\r\n *\r\n * Event: mxEvent.DOUBLE_CLICK\r\n *\r\n * Fires in <dblClick> after a double click. The <code>event</code> property\r\n * contains the original mouse event and the <code>cell</code> property\r\n * contains the cell under the mouse or null if the background was clicked.\r\n *\r\n * Event: mxEvent.GESTURE\r\n *\r\n * Fires in <fireGestureEvent> after a touch gesture. The <code>event</code>\r\n * property contains the original gesture end event and the <code>cell</code>\r\n * property contains the optional cell associated with the gesture.\r\n *\r\n * Event: mxEvent.TAP_AND_HOLD\r\n *\r\n * Fires in <tapAndHold> if a tap and hold event was detected. The <code>event</code>\r\n * property contains the initial touch event and the <code>cell</code> property\r\n * contains the cell under the mouse or null if the background was clicked.\r\n *\r\n * Event: mxEvent.FIRE_MOUSE_EVENT\r\n *\r\n * Fires in <fireMouseEvent> before the mouse listeners are invoked. The\r\n * <code>eventName</code> property contains the event name and the\r\n * <code>event</code> property contains the <mxMouseEvent>.\r\n *\r\n * Event: mxEvent.SIZE\r\n *\r\n * Fires after <sizeDidChange> was executed. The <code>bounds</code> property\r\n * contains the new graph bounds.\r\n *\r\n * Event: mxEvent.START_EDITING\r\n *\r\n * Fires before the in-place editor starts in <startEditingAtCell>. The\r\n * <code>cell</code> property contains the cell that is being edited and the\r\n * <code>event</code> property contains the optional event argument that was\r\n * passed to <startEditingAtCell>.\r\n *\r\n * Event: mxEvent.EDITING_STARTED\r\n *\r\n * Fires after the in-place editor starts in <startEditingAtCell>. The\r\n * <code>cell</code> property contains the cell that is being edited and the\r\n * <code>event</code> property contains the optional event argument that was\r\n * passed to <startEditingAtCell>.\r\n *\r\n * Event: mxEvent.EDITING_STOPPED\r\n *\r\n * Fires after the in-place editor stops in <stopEditing>.\r\n *\r\n * Event: mxEvent.LABEL_CHANGED\r\n *\r\n * Fires between begin- and endUpdate in <cellLabelChanged>. The\r\n * <code>cell</code> property contains the cell, the <code>value</code>\r\n * property contains the new value for the cell, the <code>old</code> property\r\n * contains the old value and the optional <code>event</code> property contains\r\n * the mouse event that started the edit.\r\n *\r\n * Event: mxEvent.ADD_OVERLAY\r\n *\r\n * Fires after an overlay is added in <addCellOverlay>. The <code>cell</code>\r\n * property contains the cell and the <code>overlay</code> property contains\r\n * the <mxCellOverlay> that was added.\r\n *\r\n * Event: mxEvent.REMOVE_OVERLAY\r\n *\r\n * Fires after an overlay is removed in <removeCellOverlay> and\r\n * <removeCellOverlays>. The <code>cell</code> property contains the cell and\r\n * the <code>overlay</code> property contains the <mxCellOverlay> that was\r\n * removed.\r\n *\r\n * Constructor: mxGraph\r\n *\r\n * Constructs a new mxGraph in the specified container. Model is an optional\r\n * mxGraphModel. If no model is provided, a new mxGraphModel instance is\r\n * used as the model. The container must have a valid owner document prior\r\n * to calling this function in Internet Explorer. RenderHint is a string to\r\n * affect the display performance and rendering in IE, but not in SVG-based\r\n * browsers. The parameter is mapped to <dialect>, which may\r\n * be one of <mxConstants.DIALECT_SVG> for SVG-based browsers,\r\n * <mxConstants.DIALECT_STRICTHTML> for fastest display mode,\r\n * <mxConstants.DIALECT_PREFERHTML> for faster display mode,\r\n * <mxConstants.DIALECT_MIXEDHTML> for fast and <mxConstants.DIALECT_VML>\r\n * for exact display mode (slowest). The dialects are defined in mxConstants.\r\n * The default values are DIALECT_SVG for SVG-based browsers and\r\n * DIALECT_MIXED for IE.\r\n *\r\n * The possible values for the renderingHint parameter are explained below:\r\n *\r\n * fast - The parameter is based on the fact that the display performance is\r\n * highly improved in IE if the VML is not contained within a VML group\r\n * element. The lack of a group element only slightly affects the display while\r\n * panning, but improves the performance by almost a factor of 2, while keeping\r\n * the display sufficiently accurate. This also allows to render certain shapes as HTML\r\n * if the display accuracy is not affected, which is implemented by\r\n * <mxShape.isMixedModeHtml>. This is the default setting and is mapped to\r\n * DIALECT_MIXEDHTML.\r\n * faster - Same as fast, but more expensive shapes are avoided. This is\r\n * controlled by <mxShape.preferModeHtml>. The default implementation will\r\n * avoid gradients and rounded rectangles, but more significant shapes, such\r\n * as rhombus, ellipse, actor and cylinder will be rendered accurately. This\r\n * setting is mapped to DIALECT_PREFERHTML.\r\n * fastest - Almost anything will be rendered in Html. This allows for\r\n * rectangles, labels and images. This setting is mapped to\r\n * DIALECT_STRICTHTML.\r\n * exact - If accurate panning is required and if the diagram is small (up\r\n * to 100 cells), then this value should be used. In this mode, a group is\r\n * created that contains the VML. This allows for accurate panning and is\r\n * mapped to DIALECT_VML.\r\n *\r\n * Example:\r\n *\r\n * To create a graph inside a DOM node with an id of graph:\r\n * (code)\r\n * var container = document.getElementById('graph');\r\n * var graph = new mxGraph(container);\r\n * (end)\r\n *\r\n * Parameters:\r\n *\r\n * container - Optional DOM node that acts as a container for the graph.\r\n * If this is null then the container can be initialized later using\r\n * <init>.\r\n * model - Optional <mxGraphModel> that constitutes the graph data.\r\n * renderHint - Optional string that specifies the display accuracy and\r\n * performance. Default is mxConstants.DIALECT_MIXEDHTML (for IE).\r\n * stylesheet - Optional <mxStylesheet> to be used in the graph.\r\n */\nvar _default = exports[\"default\"] = mxCurrentRootChange;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxCurrentRootChange.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxCylinder.js":
/*!*********************************************!*\
  !*** ./src/workflow/mxClient/mxCylinder.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.fill.js */ \"../../node_modules/core-js/modules/es.array.fill.js\");\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxShape = _interopRequireDefault(__webpack_require__(/*! ./mxShape.js */ \"./src/workflow/mxClient/mxShape.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxCylinder(bounds, fill, stroke, strokewidth) {\n  _mxShape[\"default\"].call(this);\n  this.bounds = bounds;\n  this.fill = fill;\n  this.stroke = stroke;\n  this.strokewidth = strokewidth != null ? strokewidth : 1;\n}\n;\n\n/**\r\n * Extends mxShape.\r\n */\n_mxGraphUtils[\"default\"].extend(mxCylinder, _mxShape[\"default\"]);\n\n/**\r\n * Variable: maxHeight\r\n *\r\n * Defines the maximum height of the top and bottom part\r\n * of the cylinder shape.\r\n */\nmxCylinder.prototype.maxHeight = 40;\n\n/**\r\n * Variable: svgStrokeTolerance\r\n *\r\n * Sets stroke tolerance to 0 for SVG.\r\n */\nmxCylinder.prototype.svgStrokeTolerance = 0;\n\n/**\r\n * Function: paintVertexShape\r\n *\r\n * Redirects to redrawPath for subclasses to work.\r\n */\nmxCylinder.prototype.paintVertexShape = function (c, x, y, w, h) {\n  c.translate(x, y);\n  c.begin();\n  this.redrawPath(c, x, y, w, h, false);\n  c.fillAndStroke();\n  c.setShadow(false);\n  c.begin();\n  this.redrawPath(c, x, y, w, h, true);\n  c.stroke();\n};\n\n/**\r\n * Function: redrawPath\r\n *\r\n * Draws the path for this shape.\r\n */\nmxCylinder.prototype.redrawPath = function (c, x, y, w, h, isForeground) {\n  var dy = Math.min(this.maxHeight, Math.round(h / 5));\n  if (isForeground && this.fill != null || !isForeground && this.fill == null) {\n    c.moveTo(0, dy);\n    c.curveTo(0, 2 * dy, w, 2 * dy, w, dy);\n\n    // Needs separate shapes for correct hit-detection\n    if (!isForeground) {\n      c.stroke();\n      c.begin();\n    }\n  }\n  if (!isForeground) {\n    c.moveTo(0, dy);\n    c.curveTo(0, -dy / 3, w, -dy / 3, w, dy);\n    c.lineTo(w, h - dy);\n    c.curveTo(w, h + dy / 3, 0, h + dy / 3, 0, h - dy);\n    c.close();\n  }\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxConnector\r\n *\r\n * Extends <mxShape> to implement a connector shape. The connector\r\n * shape allows for arrow heads on either side.\r\n *\r\n * This shape is registered under <mxConstants.SHAPE_CONNECTOR> in\r\n * <mxCellRenderer>.\r\n *\r\n * Constructor: mxConnector\r\n *\r\n * Constructs a new connector shape.\r\n *\r\n * Parameters:\r\n *\r\n * points - Array of <mxPoints> that define the points. This is stored in\r\n * <mxShape.points>.\r\n * stroke - String that defines the stroke color. This is stored in <stroke>.\r\n * Default is 'black'.\r\n * strokewidth - Optional integer that defines the stroke width. Default is\r\n * 1. This is stored in <strokewidth>.\r\n */\nvar _default = exports[\"default\"] = mxCylinder;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxCylinder.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxDefaultKeyHandler.js":
/*!******************************************************!*\
  !*** ./src/workflow/mxClient/mxDefaultKeyHandler.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.function.bind.js */ \"../../node_modules/core-js/modules/es.function.bind.js\");\nvar _mxEventObject = _interopRequireDefault(__webpack_require__(/*! ./mxEventObject.js */ \"./src/workflow/mxClient/mxEventObject.js\"));\nvar _mxKeyHandler = _interopRequireDefault(__webpack_require__(/*! ./mxKeyHandler.js */ \"./src/workflow/mxClient/mxKeyHandler.js\"));\nvar _mxEvent = _interopRequireDefault(__webpack_require__(/*! ./mxEvent.js */ \"./src/workflow/mxClient/mxEvent.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxDefaultKeyHandler(editor) {\n  if (editor != null) {\n    this.editor = editor;\n    this.handler = new _mxKeyHandler[\"default\"](editor.graph);\n\n    // Extends the escape function of the internal key\n    // handle to hide the properties dialog and fire\n    // the escape event via the editor instance\n    var old = this.handler.escape;\n    this.handler.escape = function (evt) {\n      old.apply(this, arguments);\n      editor.hideProperties();\n      editor.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].ESCAPE, 'event', evt));\n    };\n  }\n}\n;\n\n/**\r\n * Variable: editor\r\n *\r\n * Reference to the enclosing <mxEditor>.\r\n */\nmxDefaultKeyHandler.prototype.editor = null;\n\n/**\r\n * Variable: handler\r\n *\r\n * Holds the <mxKeyHandler> for key event handling.\r\n */\nmxDefaultKeyHandler.prototype.handler = null;\n\n/**\r\n * Function: bindAction\r\n *\r\n * Binds the specified keycode to the given action in <editor>. The\r\n * optional control flag specifies if the control key must be pressed\r\n * to trigger the action.\r\n *\r\n * Parameters:\r\n *\r\n * code - Integer that specifies the keycode.\r\n * action - Name of the action to execute in <editor>.\r\n * control - Optional boolean that specifies if control must be pressed.\r\n * Default is false.\r\n */\nmxDefaultKeyHandler.prototype.bindAction = function (code, action, control) {\n  var keyHandler = _mxGraphUtils[\"default\"].bind(this, function () {\n    this.editor.execute(action);\n  });\n\n  // Binds the function to control-down keycode\n  if (control) {\n    this.handler.bindControlKey(code, keyHandler);\n  }\n\n  // Binds the function to the normal keycode\n  else {\n    this.handler.bindKey(code, keyHandler);\n  }\n};\n\n/**\r\n * Function: destroy\r\n *\r\n * Destroys the <handler> associated with this object. This does normally\r\n * not need to be called, the <handler> is destroyed automatically when the\r\n * window unloads (in IE) by <mxEditor>.\r\n */\nmxDefaultKeyHandler.prototype.destroy = function () {\n  this.handler.destroy();\n  this.handler = null;\n};\nmxDefaultKeyHandler.getName = function () {\n  return 'mxDefaultKeyHandler';\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxDefaultPopupMenu\r\n *\r\n * Creates popupmenus for mouse events. This object holds an XML node\r\n * which is a description of the popup menu to be created. In\r\n * <createMenu>, the configuration is applied to the context and\r\n * the resulting menu items are added to the menu dynamically. See\r\n * <createMenu> for a description of the configuration format.\r\n *\r\n * This class does not create the DOM nodes required for the popup menu, it\r\n * only parses an XML description to invoke the respective methods on an\r\n * <mxPopupMenu> each time the menu is displayed.\r\n *\r\n * Codec:\r\n *\r\n * This class uses the <mxDefaultPopupMenuCodec> to read configuration\r\n * data into an existing instance, however, the actual parsing is done\r\n * by this class during program execution, so the format is described\r\n * below.\r\n *\r\n * Constructor: mxDefaultPopupMenu\r\n *\r\n * Constructs a new popupmenu-factory based on given configuration.\r\n *\r\n * Paramaters:\r\n *\r\n * config - XML node that contains the configuration data.\r\n */\nvar _default = exports[\"default\"] = mxDefaultKeyHandler;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxDefaultKeyHandler.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxDefaultPopupMenu.js":
/*!*****************************************************!*\
  !*** ./src/workflow/mxClient/mxDefaultPopupMenu.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _mxResources = _interopRequireDefault(__webpack_require__(/*! ./mxResources.js */ \"./src/workflow/mxClient/mxResources.js\"));\nvar _mxUtils = _interopRequireDefault(__webpack_require__(/*! ./mxUtils.js */ \"./src/workflow/mxClient/mxUtils.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxDefaultPopupMenu(config) {\n  this.config = config;\n}\n;\n\n/**\r\n * Variable: imageBasePath\r\n *\r\n * Base path for all icon attributes in the config. Default is null.\r\n */\nmxDefaultPopupMenu.prototype.imageBasePath = null;\n\n/**\r\n * Variable: config\r\n *\r\n * XML node used as the description of new menu items. This node is\r\n * used in <createMenu> to dynamically create the menu items if their\r\n * respective conditions evaluate to true for the given arguments.\r\n */\nmxDefaultPopupMenu.prototype.config = null;\n\n/**\r\n * Function: createMenu\r\n *\r\n * This function is called from <mxEditor> to add items to the\r\n * given menu based on <config>. The config is a sequence of\r\n * the following nodes and attributes.\r\n *\r\n * Child Nodes:\r\n *\r\n * add - Adds a new menu item. See below for attributes.\r\n * separator - Adds a separator. No attributes.\r\n * condition - Adds a custom condition. Name attribute.\r\n *\r\n * The add-node may have a child node that defines a function to be invoked\r\n * before the action is executed (or instead of an action to be executed).\r\n *\r\n * Attributes:\r\n *\r\n * as - Resource key for the label (needs entry in property file).\r\n * action - Name of the action to execute in enclosing editor.\r\n * icon - Optional icon (relative/absolute URL).\r\n * iconCls - Optional CSS class for the icon.\r\n * if - Optional name of condition that must be true (see below).\r\n * enabled-if - Optional name of condition that specifies if the menu item\r\n * should be enabled.\r\n * name - Name of custom condition. Only for condition nodes.\r\n *\r\n * Conditions:\r\n *\r\n * nocell - No cell under the mouse.\r\n * ncells - More than one cell selected.\r\n * notRoot - Drilling position is other than home.\r\n * cell - Cell under the mouse.\r\n * notEmpty - Exactly one cell with children under mouse.\r\n * expandable - Exactly one expandable cell under mouse.\r\n * collapsable - Exactly one collapsable cell under mouse.\r\n * validRoot - Exactly one cell which is a possible root under mouse.\r\n * swimlane - Exactly one cell which is a swimlane under mouse.\r\n *\r\n * Example:\r\n *\r\n * To add a new item for a given action to the popupmenu:\r\n *\r\n * (code)\r\n * <mxDefaultPopupMenu as=\"popupHandler\">\r\n *   <add as=\"delete\" action=\"delete\" icon=\"images/delete.gif\" if=\"cell\"/>\r\n * </mxDefaultPopupMenu>\r\n * (end)\r\n *\r\n * To add a new item for a custom function:\r\n *\r\n * (code)\r\n * <mxDefaultPopupMenu as=\"popupHandler\">\r\n *   <add as=\"action1\"><![CDATA[\r\n *\t\tfunction (editor, cell, evt)\r\n *\t\t{\r\n *\t\t\teditor.execute('action1', cell, 'myArg');\r\n *\t\t}\r\n *   ]]></add>\r\n * </mxDefaultPopupMenu>\r\n * (end)\r\n *\r\n * The above example invokes action1 with an additional third argument via\r\n * the editor instance. The third argument is passed to the function that\r\n * defines action1. If the add-node has no action-attribute, then only the\r\n * function defined in the text content is executed, otherwise first the\r\n * function and then the action defined in the action-attribute is\r\n * executed. The function in the text content has 3 arguments, namely the\r\n * <mxEditor> instance, the <mxCell> instance under the mouse, and the\r\n * native mouse event.\r\n *\r\n * Custom Conditions:\r\n *\r\n * To add a new condition for popupmenu items:\r\n *\r\n * (code)\r\n * <condition name=\"condition1\"><![CDATA[\r\n *   function (editor, cell, evt)\r\n *   {\r\n *     return cell != null;\r\n *   }\r\n * ]]></condition>\r\n * (end)\r\n *\r\n * The new condition can then be used in any item as follows:\r\n *\r\n * (code)\r\n * <add as=\"action1\" action=\"action1\" icon=\"action1.gif\" if=\"condition1\"/>\r\n * (end)\r\n *\r\n * The order in which the items and conditions appear is not significant as\r\n * all connditions are evaluated before any items are created.\r\n *\r\n * Parameters:\r\n *\r\n * editor - Enclosing <mxEditor> instance.\r\n * menu - <mxPopupMenu> that is used for adding items and separators.\r\n * cell - Optional <mxCell> which is under the mousepointer.\r\n * evt - Optional mouse event which triggered the menu.\r\n */\nmxDefaultPopupMenu.prototype.createMenu = function (editor, menu, cell, evt) {\n  if (this.config != null) {\n    var conditions = this.createConditions(editor, cell, evt);\n    var item = this.config.firstChild;\n    this.addItems(editor, menu, cell, evt, conditions, item, null);\n  }\n};\n\n/**\r\n * Function: addItems\r\n *\r\n * Recursively adds the given items and all of its children into the given menu.\r\n *\r\n * Parameters:\r\n *\r\n * editor - Enclosing <mxEditor> instance.\r\n * menu - <mxPopupMenu> that is used for adding items and separators.\r\n * cell - Optional <mxCell> which is under the mousepointer.\r\n * evt - Optional mouse event which triggered the menu.\r\n * conditions - Array of names boolean conditions.\r\n * item - XML node that represents the current menu item.\r\n * parent - DOM node that represents the parent menu item.\r\n */\nmxDefaultPopupMenu.prototype.addItems = function (editor, menu, cell, evt, conditions, item, parent) {\n  var addSeparator = false;\n  while (item != null) {\n    if (item.nodeName == 'add') {\n      var condition = item.getAttribute('if');\n      if (condition == null || conditions[condition]) {\n        var as = item.getAttribute('as');\n        as = _mxResources[\"default\"].get(as) || as;\n        var funct = _mxUtils[\"default\"].eval(_mxUtils[\"default\"].getTextContent(item));\n        var action = item.getAttribute('action');\n        var icon = item.getAttribute('icon');\n        var iconCls = item.getAttribute('iconCls');\n        var enabledCond = item.getAttribute('enabled-if');\n        var enabled = enabledCond == null || conditions[enabledCond];\n        if (addSeparator) {\n          menu.addSeparator(parent);\n          addSeparator = false;\n        }\n        if (icon != null && this.imageBasePath) {\n          icon = this.imageBasePath + icon;\n        }\n        var row = this.addAction(menu, editor, as, icon, funct, action, cell, parent, iconCls, enabled);\n        this.addItems(editor, menu, cell, evt, conditions, item.firstChild, row);\n      }\n    } else if (item.nodeName == 'separator') {\n      addSeparator = true;\n    }\n    item = item.nextSibling;\n  }\n};\n\n/**\r\n * Function: addAction\r\n *\r\n * Helper method to bind an action to a new menu item.\r\n *\r\n * Parameters:\r\n *\r\n * menu - <mxPopupMenu> that is used for adding items and separators.\r\n * editor - Enclosing <mxEditor> instance.\r\n * lab - String that represents the label of the menu item.\r\n * icon - Optional URL that represents the icon of the menu item.\r\n * action - Optional name of the action to execute in the given editor.\r\n * funct - Optional function to execute before the optional action. The\r\n * function takes an <mxEditor>, the <mxCell> under the mouse and the\r\n * mouse event that triggered the call.\r\n * cell - Optional <mxCell> to use as an argument for the action.\r\n * parent - DOM node that represents the parent menu item.\r\n * iconCls - Optional CSS class for the menu icon.\r\n * enabled - Optional boolean that specifies if the menu item is enabled.\r\n * Default is true.\r\n */\nmxDefaultPopupMenu.prototype.addAction = function (menu, editor, lab, icon, funct, action, cell, parent, iconCls, enabled) {\n  var clickHandler = function clickHandler(evt) {\n    if (typeof funct == 'function') {\n      funct.call(editor, editor, cell, evt);\n    }\n    if (action != null) {\n      editor.execute(action, cell, evt);\n    }\n  };\n  return menu.addItem(lab, icon, clickHandler, parent, iconCls, enabled);\n};\n\n/**\r\n * Function: createConditions\r\n *\r\n * Evaluates the default conditions for the given context.\r\n */\nmxDefaultPopupMenu.prototype.createConditions = function (editor, cell, evt) {\n  // Creates array with conditions\n  var model = editor.graph.getModel();\n  var childCount = model.getChildCount(cell);\n\n  // Adds some frequently used conditions\n  var conditions = [];\n  conditions['nocell'] = cell == null;\n  conditions['ncells'] = editor.graph.getSelectionCount() > 1;\n  conditions['notRoot'] = model.getRoot() != model.getParent(editor.graph.getDefaultParent());\n  conditions['cell'] = cell != null;\n  var isCell = cell != null && editor.graph.getSelectionCount() == 1;\n  conditions['nonEmpty'] = isCell && childCount > 0;\n  conditions['expandable'] = isCell && editor.graph.isCellFoldable(cell, false);\n  conditions['collapsable'] = isCell && editor.graph.isCellFoldable(cell, true);\n  conditions['validRoot'] = isCell && editor.graph.isValidRoot(cell);\n  conditions['emptyValidRoot'] = conditions['validRoot'] && childCount == 0;\n  conditions['swimlane'] = isCell && editor.graph.isSwimlane(cell);\n\n  // Evaluates dynamic conditions from config file\n  var condNodes = this.config.getElementsByTagName('condition');\n  for (var i = 0; i < condNodes.length; i++) {\n    var funct = _mxUtils[\"default\"].eval(_mxUtils[\"default\"].getTextContent(condNodes[i]));\n    var name = condNodes[i].getAttribute('name');\n    if (name != null && typeof funct == 'function') {\n      conditions[name] = funct(editor, cell, evt);\n    }\n  }\n  return conditions;\n};\nmxDefaultPopupMenu.getName = function () {\n  return 'mxDefaultPopupMenu';\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxDefaultToolbar\r\n *\r\n * Toolbar for the editor. This modifies the state of the graph\r\n * or inserts new cells upon mouse clicks.\r\n *\r\n * Example:\r\n *\r\n * Create a toolbar with a button to copy the selection into the clipboard,\r\n * and a combo box with one action to paste the selection from the clipboard\r\n * into the graph.\r\n *\r\n * (code)\r\n * var toolbar = new mxDefaultToolbar(container, editor);\r\n * toolbar.addItem('Copy', null, 'copy');\r\n *\r\n * var combo = toolbar.addActionCombo('More actions...');\r\n * toolbar.addActionOption(combo, 'Paste', 'paste');\r\n * (end)\r\n *\r\n * Codec:\r\n *\r\n * This class uses the <mxDefaultToolbarCodec> to read configuration\r\n * data into an existing instance. See <mxDefaultToolbarCodec> for a\r\n * description of the configuration format.\r\n *\r\n * Constructor: mxDefaultToolbar\r\n *\r\n * Constructs a new toolbar for the given container and editor. The\r\n * container and editor may be null if a prototypical instance for a\r\n * <mxDefaultKeyHandlerCodec> is created.\r\n *\r\n * Parameters:\r\n *\r\n * container - DOM node that contains the toolbar.\r\n * editor - Reference to the enclosing <mxEditor>.\r\n */\nvar _default = exports[\"default\"] = mxDefaultPopupMenu;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxDefaultPopupMenu.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxDefaultToolbar.js":
/*!***************************************************!*\
  !*** ./src/workflow/mxClient/mxDefaultToolbar.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.function.bind.js */ \"../../node_modules/core-js/modules/es.function.bind.js\");\n__webpack_require__(/*! core-js/modules/es.object.to-string.js */ \"../../node_modules/core-js/modules/es.object.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.promise.js */ \"../../node_modules/core-js/modules/es.promise.js\");\nvar _mxClient = _interopRequireDefault(__webpack_require__(/*! ./mxClient.js */ \"./src/workflow/mxClient/mxClient.js\"));\nvar _mxEvent = _interopRequireDefault(__webpack_require__(/*! ./mxEvent.js */ \"./src/workflow/mxClient/mxEvent.js\"));\nvar _mxToolbar = _interopRequireDefault(__webpack_require__(/*! ./mxToolbar.js */ \"./src/workflow/mxClient/mxToolbar.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxGeometry = _interopRequireDefault(__webpack_require__(/*! ./mxGeometry.js */ \"./src/workflow/mxClient/mxGeometry.js\"));\nvar _mxUtils = _interopRequireDefault(__webpack_require__(/*! ./mxUtils.js */ \"./src/workflow/mxClient/mxUtils.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxDefaultToolbar(container, editor) {\n  this.editor = editor;\n  if (container != null && editor != null) {\n    this.init(container);\n  }\n}\n;\n\n/**\r\n * Variable: editor\r\n *\r\n * Reference to the enclosing <mxEditor>.\r\n */\nmxDefaultToolbar.prototype.editor = null;\n\n/**\r\n * Variable: toolbar\r\n *\r\n * Holds the internal <mxToolbar>.\r\n */\nmxDefaultToolbar.prototype.toolbar = null;\n\n/**\r\n * Variable: resetHandler\r\n *\r\n * Reference to the function used to reset the <toolbar>.\r\n */\nmxDefaultToolbar.prototype.resetHandler = null;\n\n/**\r\n * Variable: spacing\r\n *\r\n * Defines the spacing between existing and new vertices in\r\n * gridSize units when a new vertex is dropped on an existing\r\n * cell. Default is 4 (40 pixels).\r\n */\nmxDefaultToolbar.prototype.spacing = 4;\n\n/**\r\n * Variable: connectOnDrop\r\n *\r\n * Specifies if elements should be connected if new cells are dropped onto\r\n * connectable elements. Default is false.\r\n */\nmxDefaultToolbar.prototype.connectOnDrop = false;\n\n/**\r\n * Variable: init\r\n *\r\n * Constructs the <toolbar> for the given container and installs a listener\r\n * that updates the <mxEditor.insertFunction> on <editor> if an item is\r\n * selected in the toolbar. This assumes that <editor> is not null.\r\n *\r\n * Parameters:\r\n *\r\n * container - DOM node that contains the toolbar.\r\n */\nmxDefaultToolbar.prototype.init = function (container) {\n  if (container != null) {\n    this.toolbar = new _mxToolbar[\"default\"](container);\n\n    // Installs the insert function in the editor if an item is\n    // selected in the toolbar\n    this.toolbar.addListener(_mxEvent[\"default\"].SELECT, _mxGraphUtils[\"default\"].bind(this, function (sender, evt) {\n      var funct = evt.getProperty('function');\n      if (funct != null) {\n        this.editor.insertFunction = _mxGraphUtils[\"default\"].bind(this, function () {\n          funct.apply(this, arguments);\n          this.toolbar.resetMode();\n        });\n      } else {\n        this.editor.insertFunction = null;\n      }\n    }));\n\n    // Resets the selected tool after a doubleclick or escape keystroke\n    this.resetHandler = _mxGraphUtils[\"default\"].bind(this, function () {\n      if (this.toolbar != null) {\n        this.toolbar.resetMode(true);\n      }\n    });\n    this.editor.graph.addListener(_mxEvent[\"default\"].DOUBLE_CLICK, this.resetHandler);\n    this.editor.addListener(_mxEvent[\"default\"].ESCAPE, this.resetHandler);\n  }\n};\n\n/**\r\n * Function: addItem\r\n *\r\n * Adds a new item that executes the given action in <editor>. The title,\r\n * icon and pressedIcon are used to display the toolbar item.\r\n *\r\n * Parameters:\r\n *\r\n * title - String that represents the title (tooltip) for the item.\r\n * icon - URL of the icon to be used for displaying the item.\r\n * action - Name of the action to execute when the item is clicked.\r\n * pressed - Optional URL of the icon for the pressed state.\r\n */\nmxDefaultToolbar.prototype.addItem = function (title, icon, action, pressed) {\n  var clickHandler = _mxGraphUtils[\"default\"].bind(this, function () {\n    if (action != null && action.length > 0) {\n      this.editor.execute(action);\n    }\n  });\n  return this.toolbar.addItem(title, icon, clickHandler, pressed);\n};\n\n/**\r\n * Function: addSeparator\r\n *\r\n * Adds a vertical separator using the optional icon.\r\n *\r\n * Parameters:\r\n *\r\n * icon - Optional URL of the icon that represents the vertical separator.\r\n * Default is <mxClient.imageBasePath> + '/separator.gif'.\r\n */\nmxDefaultToolbar.prototype.addSeparator = function (icon) {\n  icon = icon || _mxClient[\"default\"].imageBasePath + '/separator.gif';\n  this.toolbar.addSeparator(icon);\n};\n\n/**\r\n * Function: addCombo\r\n *\r\n * Helper method to invoke <mxToolbar.addCombo> on <toolbar> and return the\r\n * resulting DOM node.\r\n */\nmxDefaultToolbar.prototype.addCombo = function () {\n  return this.toolbar.addCombo();\n};\n\n/**\r\n * Function: addActionCombo\r\n *\r\n * Helper method to invoke <mxToolbar.addActionCombo> on <toolbar> using\r\n * the given title and return the resulting DOM node.\r\n *\r\n * Parameters:\r\n *\r\n * title - String that represents the title of the combo.\r\n */\nmxDefaultToolbar.prototype.addActionCombo = function (title) {\n  return this.toolbar.addActionCombo(title);\n};\n\n/**\r\n * Function: addActionOption\r\n *\r\n * Binds the given action to a option with the specified label in the\r\n * given combo. Combo is an object returned from an earlier call to\r\n * <addCombo> or <addActionCombo>.\r\n *\r\n * Parameters:\r\n *\r\n * combo - DOM node that represents the combo box.\r\n * title - String that represents the title of the combo.\r\n * action - Name of the action to execute in <editor>.\r\n */\nmxDefaultToolbar.prototype.addActionOption = function (combo, title, action) {\n  var clickHandler = _mxGraphUtils[\"default\"].bind(this, function () {\n    this.editor.execute(action);\n  });\n  this.addOption(combo, title, clickHandler);\n};\n\n/**\r\n * Function: addOption\r\n *\r\n * Helper method to invoke <mxToolbar.addOption> on <toolbar> and return\r\n * the resulting DOM node that represents the option.\r\n *\r\n * Parameters:\r\n *\r\n * combo - DOM node that represents the combo box.\r\n * title - String that represents the title of the combo.\r\n * value - Object that represents the value of the option.\r\n */\nmxDefaultToolbar.prototype.addOption = function (combo, title, value) {\n  return this.toolbar.addOption(combo, title, value);\n};\n\n/**\r\n * Function: addMode\r\n *\r\n * Creates an item for selecting the given mode in the <editor>'s graph.\r\n * Supported modenames are select, connect and pan.\r\n *\r\n * Parameters:\r\n *\r\n * title - String that represents the title of the item.\r\n * icon - URL of the icon that represents the item.\r\n * mode - String that represents the mode name to be used in\r\n * <mxEditor.setMode>.\r\n * pressed - Optional URL of the icon that represents the pressed state.\r\n * funct - Optional JavaScript function that takes the <mxEditor> as the\r\n * first and only argument that is executed after the mode has been\r\n * selected.\r\n */\nmxDefaultToolbar.prototype.addMode = function (title, icon, mode, pressed, funct) {\n  var clickHandler = _mxGraphUtils[\"default\"].bind(this, function () {\n    this.editor.setMode(mode);\n    if (funct != null) {\n      funct(this.editor);\n    }\n  });\n  return this.toolbar.addSwitchMode(title, icon, clickHandler, pressed);\n};\n\n/**\r\n * Function: addPrototype\r\n *\r\n * Creates an item for inserting a clone of the specified prototype cell into\r\n * the <editor>'s graph. The ptype may either be a cell or a function that\r\n * returns a cell.\r\n *\r\n * Parameters:\r\n *\r\n * title - String that represents the title of the item.\r\n * icon - URL of the icon that represents the item.\r\n * ptype - Function or object that represents the prototype cell. If ptype\r\n * is a function then it is invoked with no arguments to create new\r\n * instances.\r\n * pressed - Optional URL of the icon that represents the pressed state.\r\n * insert - Optional JavaScript function that handles an insert of the new\r\n * cell. This function takes the <mxEditor>, new cell to be inserted, mouse\r\n * event and optional <mxCell> under the mouse pointer as arguments.\r\n * toggle - Optional boolean that specifies if the item can be toggled.\r\n * Default is true.\r\n */\nmxDefaultToolbar.prototype.addPrototype = function (title, icon, ptype, pressed, insert, toggle) {\n  // Creates a wrapper function that is in charge of constructing\n  // the new cell instance to be inserted into the graph\n  var factory = _mxGraphUtils[\"default\"].bind(this, function () {\n    if (typeof ptype == 'function') {\n      return ptype();\n    } else if (ptype != null) {\n      return this.editor.graph.cloneCells([ptype])[0];\n    }\n    return null;\n  });\n\n  // Defines the function for a click event on the graph\n  // after this item has been selected in the toolbar\n  var clickHandler = _mxGraphUtils[\"default\"].bind(this, function (evt, cell) {\n    if (typeof insert == 'function') {\n      insert(this.editor, factory(), evt, cell);\n    } else {\n      this.drop(factory(), evt, cell);\n    }\n    this.toolbar.resetMode();\n    _mxEvent[\"default\"].consume(evt);\n  });\n  var img = this.toolbar.addMode(title, icon, clickHandler, pressed, null, toggle);\n\n  // Creates a wrapper function that calls the click handler without\n  // the graph argument\n  var dropHandler = function dropHandler(graph, evt, cell) {\n    clickHandler(evt, cell);\n  };\n  this.installDropHandler(img, dropHandler);\n  return img;\n};\n\n/**\r\n * Function: drop\r\n *\r\n * Handles a drop from a toolbar item to the graph. The given vertex\r\n * represents the new cell to be inserted. This invokes <insert> or\r\n * <connect> depending on the given target cell.\r\n *\r\n * Parameters:\r\n *\r\n * vertex - <mxCell> to be inserted.\r\n * evt - Mouse event that represents the drop.\r\n * target - Optional <mxCell> that represents the drop target.\r\n */\nmxDefaultToolbar.prototype.drop = function (vertex, evt, target) {\n  var graph = this.editor.graph;\n  var model = graph.getModel();\n  if (target == null || model.isEdge(target) || !this.connectOnDrop || !graph.isCellConnectable(target)) {\n    while (target != null && !graph.isValidDropTarget(target, [vertex], evt)) {\n      target = model.getParent(target);\n    }\n    this.insert(vertex, evt, target);\n  } else {\n    this.connect(vertex, evt, target);\n  }\n};\n\n/**\r\n * Function: insert\r\n *\r\n * Handles a drop by inserting the given vertex into the given parent cell\r\n * or the default parent if no parent is specified.\r\n *\r\n * Parameters:\r\n *\r\n * vertex - <mxCell> to be inserted.\r\n * evt - Mouse event that represents the drop.\r\n * parent - Optional <mxCell> that represents the parent.\r\n */\nmxDefaultToolbar.prototype.insert = function (vertex, evt, target) {\n  var graph = this.editor.graph;\n  if (graph.canImportCell(vertex)) {\n    var x = _mxEvent[\"default\"].getClientX(evt);\n    var y = _mxEvent[\"default\"].getClientY(evt);\n    var pt = _mxUtils[\"default\"].convertPoint(graph.container, x, y);\n\n    // Splits the target edge or inserts into target group\n    if (graph.isSplitEnabled() && graph.isSplitTarget(target, [vertex], evt)) {\n      return graph.splitEdge(target, [vertex], null, pt.x, pt.y);\n    } else {\n      return this.editor.addVertex(target, vertex, pt.x, pt.y);\n    }\n  }\n  return null;\n};\n\n/**\r\n * Function: connect\r\n *\r\n * Handles a drop by connecting the given vertex to the given source cell.\r\n *\r\n * vertex - <mxCell> to be inserted.\r\n * evt - Mouse event that represents the drop.\r\n * source - Optional <mxCell> that represents the source terminal.\r\n */\nmxDefaultToolbar.prototype.connect = function (vertex, evt, source) {\n  var graph = this.editor.graph;\n  var model = graph.getModel();\n  if (source != null && graph.isCellConnectable(vertex) && graph.isEdgeValid(null, source, vertex)) {\n    var edge = null;\n    model.beginUpdate();\n    try {\n      var geo = model.getGeometry(source);\n      var g = model.getGeometry(vertex).clone();\n\n      // Moves the vertex away from the drop target that will\n      // be used as the source for the new connection\n      g.x = geo.x + (geo.width - g.width) / 2;\n      g.y = geo.y + (geo.height - g.height) / 2;\n      var step = this.spacing * graph.gridSize;\n      var dist = model.getDirectedEdgeCount(source, true) * 20;\n      if (this.editor.horizontalFlow) {\n        g.x += (g.width + geo.width) / 2 + step + dist;\n      } else {\n        g.y += (g.height + geo.height) / 2 + step + dist;\n      }\n      vertex.setGeometry(g);\n\n      // Fires two add-events with the code below - should be fixed\n      // to only fire one add event for both inserts\n      var parent = model.getParent(source);\n      graph.addCell(vertex, parent);\n      graph.constrainChild(vertex);\n\n      // Creates the edge using the editor instance and calls\n      // the second function that fires an add event\n      edge = this.editor.createEdge(source, vertex);\n      if (model.getGeometry(edge) == null) {\n        var edgeGeometry = new _mxGeometry[\"default\"]();\n        edgeGeometry.relative = true;\n        model.setGeometry(edge, edgeGeometry);\n      }\n      graph.addEdge(edge, parent, source, vertex);\n    } finally {\n      model.endUpdate();\n    }\n    graph.setSelectionCells([vertex, edge]);\n    graph.scrollCellToVisible(vertex);\n  }\n};\n\n/**\r\n * Function: installDropHandler\r\n *\r\n * Makes the given img draggable using the given function for handling a\r\n * drop event.\r\n *\r\n * Parameters:\r\n *\r\n * img - DOM node that represents the image.\r\n * dropHandler - Function that handles a drop of the image.\r\n */\nmxDefaultToolbar.prototype.installDropHandler = function (img, dropHandler) {\n  var sprite = document.createElement('img');\n  sprite.setAttribute('src', img.getAttribute('src'));\n\n  // Handles delayed loading of the images\n  var loader = _mxGraphUtils[\"default\"].bind(this, function (evt) {\n    // Preview uses the image node with double size. Later this can be\n    // changed to use a separate preview and guides, but for this the\n    // dropHandler must use the additional x- and y-arguments and the\n    // dragsource which makeDraggable returns much be configured to\n    // use guides via mxDragSource.isGuidesEnabled.\n    sprite.style.width = 2 * img.offsetWidth + 'px';\n    sprite.style.height = 2 * img.offsetHeight + 'px';\n    _mxUtils[\"default\"].makeDraggable(img, this.editor.graph, dropHandler, sprite);\n    _mxEvent[\"default\"].removeListener(sprite, 'load', loader);\n  });\n  if (_mxClient[\"default\"].IS_IE) {\n    loader();\n  } else {\n    _mxEvent[\"default\"].addListener(sprite, 'load', loader);\n  }\n};\n\n/**\r\n * Function: destroy\r\n *\r\n * Destroys the <toolbar> associated with this object and removes all\r\n * installed listeners. This does normally not need to be called, the\r\n * <toolbar> is destroyed automatically when the window unloads (in IE) by\r\n * <mxEditor>.\r\n */\nmxDefaultToolbar.prototype.destroy = function () {\n  if (this.resetHandler != null) {\n    this.editor.graph.removeListener('dblclick', this.resetHandler);\n    this.editor.removeListener('escape', this.resetHandler);\n    this.resetHandler = null;\n  }\n  if (this.toolbar != null) {\n    this.toolbar.destroy();\n    this.toolbar = null;\n  }\n};\nmxDefaultToolbar.getName = function () {\n  return 'mxDefaultToolbar';\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxEditor\r\n *\r\n * Extends <mxEventSource> to implement a application wrapper for a graph that\r\n * adds <actions>, I/O using <mxCodec>, auto-layout using <mxLayoutManager>,\r\n * command history using <undoManager>, and standard dialogs and widgets, eg.\r\n * properties, help, outline, toolbar, and popupmenu. It also adds <templates>\r\n * to be used as cells in toolbars, auto-validation using the <validation>\r\n * flag, attribute cycling using <cycleAttributeValues>, higher-level events\r\n * such as <root>, and backend integration using <urlPost> and <urlImage>.\r\n *\r\n * Actions:\r\n *\r\n * Actions are functions stored in the <actions> array under their names. The\r\n * functions take the <mxEditor> as the first, and an optional <mxCell> as the\r\n * second argument and are invoked using <execute>. Any additional arguments\r\n * passed to execute are passed on to the action as-is.\r\n *\r\n * A list of built-in actions is available in the <addActions> description.\r\n *\r\n * Read/write Diagrams:\r\n *\r\n * To read a diagram from an XML string, for example from a textfield within the\r\n * page, the following code is used:\r\n *\r\n * (code)\r\n * var doc = mxUtils.parseXML(xmlString);\r\n * var node = doc.documentElement;\r\n * editor.readGraphModel(node);\r\n * (end)\r\n *\r\n * For reading a diagram from a remote location, use the <open> method.\r\n *\r\n * To save diagrams in XML on a server, you can set the <urlPost> variable.\r\n * This variable will be used in <getUrlPost> to construct a URL for the post\r\n * request that is issued in the <save> method. The post request contains the\r\n * XML representation of the diagram as returned by <writeGraphModel> in the\r\n * xml parameter.\r\n *\r\n * On the server side, the post request is processed using standard\r\n * technologies such as Java Servlets, CGI, .NET or ASP.\r\n *\r\n * Here are some examples of processing a post request in various languages.\r\n *\r\n * - Java: URLDecoder.decode(request.getParameter(\"xml\"), \"UTF-8\").replace(\"\\n\", \"&#xa;\")\r\n *\r\n * Note that the linefeeds should only be replaced if the XML is\r\n * processed in Java, for example when creating an image, but not\r\n * if the XML is passed back to the client-side.\r\n *\r\n * - .NET: HttpUtility.UrlDecode(context.Request.Params[\"xml\"])\r\n * - PHP: urldecode($_POST[\"xml\"])\r\n *\r\n * Creating images:\r\n *\r\n * A backend (Java, PHP or C#) is required for creating images. The\r\n * distribution contains an example for each backend (ImageHandler.java,\r\n * ImageHandler.cs and graph.php). More information about using a backend\r\n * to create images can be found in the readme.html files. Note that the\r\n * preview is implemented using VML/SVG in the browser and does not require\r\n * a backend. The backend is only required to creates images (bitmaps).\r\n *\r\n * Special characters:\r\n *\r\n * Note There are five characters that should always appear in XML content as\r\n * escapes, so that they do not interact with the syntax of the markup. These\r\n * are part of the language for all documents based on XML and for HTML.\r\n *\r\n * - &lt; (<)\r\n * - &gt; (>)\r\n * - &amp; (&)\r\n * - &quot; (\")\r\n * - &apos; (')\r\n *\r\n * Although it is part of the XML language, &apos; is not defined in HTML.\r\n * For this reason the XHTML specification recommends instead the use of\r\n * &#39; if text may be passed to a HTML user agent.\r\n *\r\n * If you are having problems with special characters on the server-side then\r\n * you may want to try the <escapePostData> flag.\r\n *\r\n * For converting decimal escape sequences inside strings, a user has provided\r\n * us with the following function:\r\n *\r\n * (code)\r\n * function html2js(text)\r\n * {\r\n *   var entitySearch = /&#[0-9]+;/;\r\n *   var entity;\r\n *\r\n *   while (entity = entitySearch.exec(text))\r\n *   {\r\n *     var charCode = entity[0].substring(2, entity[0].length -1);\r\n *     text = text.substring(0, entity.index)\r\n *            + String.fromCharCode(charCode)\r\n *            + text.substring(entity.index + entity[0].length);\r\n *   }\r\n *\r\n *   return text;\r\n * }\r\n * (end)\r\n *\r\n * Otherwise try using hex escape sequences and the built-in unescape function\r\n * for converting such strings.\r\n *\r\n * Local Files:\r\n *\r\n * For saving and opening local files, no standardized method exists that\r\n * works across all browsers. The recommended way of dealing with local files\r\n * is to create a backend that streams the XML data back to the browser (echo)\r\n * as an attachment so that a Save-dialog is displayed on the client-side and\r\n * the file can be saved to the local disk.\r\n *\r\n * For example, in PHP the code that does this looks as follows.\r\n *\r\n * (code)\r\n * $xml = stripslashes($_POST[\"xml\"]);\r\n * header(\"Content-Disposition: attachment; filename=\\\"diagram.xml\\\"\");\r\n * echo($xml);\r\n * (end)\r\n *\r\n * To open a local file, the file should be uploaded via a form in the browser\r\n * and then opened from the server in the editor.\r\n *\r\n * Cell Properties:\r\n *\r\n * The properties displayed in the properties dialog are the attributes and\r\n * values of the cell's user object, which is an XML node. The XML node is\r\n * defined in the templates section of the config file.\r\n *\r\n * The templates are stored in <mxEditor.templates> and contain cells which\r\n * are cloned at insertion time to create new vertices by use of drag and\r\n * drop from the toolbar. Each entry in the toolbar for adding a new vertex\r\n * must refer to an existing template.\r\n *\r\n * In the following example, the task node is a business object and only the\r\n * mxCell node and its mxGeometry child contain graph information:\r\n *\r\n * (code)\r\n * <Task label=\"Task\" description=\"\">\r\n *   <mxCell vertex=\"true\">\r\n *     <mxGeometry as=\"geometry\" width=\"72\" height=\"32\"/>\r\n *   </mxCell>\r\n * </Task>\r\n * (end)\r\n *\r\n * The idea is that the XML representation is inverse from the in-memory\r\n * representation: The outer XML node is the user object and the inner node is\r\n * the cell. This means the user object of the cell is the Task node with no\r\n * children for the above example:\r\n *\r\n * (code)\r\n * <Task label=\"Task\" description=\"\"/>\r\n * (end)\r\n *\r\n * The Task node can have any tag name, attributes and child nodes. The\r\n * <mxCodec> will use the XML hierarchy as the user object, while removing the\r\n * \"known annotations\", such as the mxCell node. At save-time the cell data\r\n * will be \"merged\" back into the user object. The user object is only modified\r\n * via the properties dialog during the lifecycle of the cell.\r\n *\r\n * In the default implementation of <createProperties>, the user object's\r\n * attributes are put into a form for editing. Attributes are changed using\r\n * the <mxCellAttributeChange> action in the model. The dialog can be replaced\r\n * by overriding the <createProperties> hook or by replacing the showProperties\r\n * action in <actions>. Alternatively, the entry in the config file's popupmenu\r\n * section can be modified to invoke a different action.\r\n *\r\n * If you want to displey the properties dialog on a doubleclick, you can set\r\n * <mxEditor.dblClickAction> to showProperties as follows:\r\n *\r\n * (code)\r\n * editor.dblClickAction = 'showProperties';\r\n * (end)\r\n *\r\n * Popupmenu and Toolbar:\r\n *\r\n * The toolbar and popupmenu are typically configured using the respective\r\n * sections in the config file, that is, the popupmenu is defined as follows:\r\n *\r\n * (code)\r\n * <mxEditor>\r\n *   <mxDefaultPopupMenu as=\"popupHandler\">\r\n * \t\t<add as=\"cut\" action=\"cut\" icon=\"images/cut.gif\"/>\r\n *      ...\r\n * (end)\r\n *\r\n * New entries can be added to the toolbar by inserting an add-node into the\r\n * above configuration. Existing entries may be removed and changed by\r\n * modifying or removing the respective entries in the configuration.\r\n * The configuration is read by the <mxDefaultPopupMenuCodec>, the format of the\r\n * configuration is explained in <mxDefaultPopupMenu.decode>.\r\n *\r\n * The toolbar is defined in the mxDefaultToolbar section. Items can be added\r\n * and removed in this section.\r\n *\r\n * (code)\r\n * <mxEditor>\r\n *   <mxDefaultToolbar>\r\n *     <add as=\"save\" action=\"save\" icon=\"images/save.gif\"/>\r\n *     <add as=\"Swimlane\" template=\"swimlane\" icon=\"images/swimlane.gif\"/>\r\n *     ...\r\n * (end)\r\n *\r\n * The format of the configuration is described in\r\n * <mxDefaultToolbarCodec.decode>.\r\n *\r\n * Ids:\r\n *\r\n * For the IDs, there is an implicit behaviour in <mxCodec>: It moves the Id\r\n * from the cell to the user object at encoding time and vice versa at decoding\r\n * time. For example, if the Task node from above has an id attribute, then\r\n * the <mxCell.id> of the corresponding cell will have this value. If there\r\n * is no Id collision in the model, then the cell may be retrieved using this\r\n * Id with the <mxGraphModel.getCell> function. If there is a collision, a new\r\n * Id will be created for the cell using <mxGraphModel.createId>. At encoding\r\n * time, this new Id will replace the value previously stored under the id\r\n * attribute in the Task node.\r\n *\r\n * See <mxEditorCodec>, <mxDefaultToolbarCodec> and <mxDefaultPopupMenuCodec>\r\n * for information about configuring the editor and user interface.\r\n *\r\n * Programmatically inserting cells:\r\n *\r\n * For inserting a new cell, say, by clicking a button in the document,\r\n * the following code can be used. This requires an reference to the editor.\r\n *\r\n * (code)\r\n * var userObject = new Object();\r\n * var parent = editor.graph.getDefaultParent();\r\n * var model = editor.graph.model;\r\n * model.beginUpdate();\r\n * try\r\n * {\r\n *   editor.graph.insertVertex(parent, null, userObject, 20, 20, 80, 30);\r\n * }\r\n * finally\r\n * {\r\n *   model.endUpdate();\r\n * }\r\n * (end)\r\n *\r\n * If a template cell from the config file should be inserted, then a clone\r\n * of the template can be created as follows. The clone is then inserted using\r\n * the add function instead of addVertex.\r\n *\r\n * (code)\r\n * var template = editor.templates['task'];\r\n * var clone = editor.graph.model.cloneCell(template);\r\n * (end)\r\n *\r\n * Resources:\r\n *\r\n * resources/editor - Language resources for mxEditor\r\n *\r\n * Callback: onInit\r\n *\r\n * Called from within the constructor. In the callback,\r\n * \"this\" refers to the editor instance.\r\n *\r\n * Cookie: mxgraph=seen\r\n *\r\n * Set when the editor is started. Never expires. Use\r\n * <resetFirstTime> to reset this cookie. This cookie\r\n * only exists if <onInit> is implemented.\r\n *\r\n * Event: mxEvent.OPEN\r\n *\r\n * Fires after a file was opened in <open>. The <code>filename</code> property\r\n * contains the filename that was used. The same value is also available in\r\n * <filename>.\r\n *\r\n * Event: mxEvent.SAVE\r\n *\r\n * Fires after the current file was saved in <save>. The <code>url</code>\r\n * property contains the URL that was used for saving.\r\n *\r\n * Event: mxEvent.POST\r\n *\r\n * Fires if a successful response was received in <postDiagram>. The\r\n * <code>request</code> property contains the <mxXmlRequest>, the\r\n * <code>url</code> and <code>data</code> properties contain the URL and the\r\n * data that were used in the post request.\r\n *\r\n * Event: mxEvent.ROOT\r\n *\r\n * Fires when the current root has changed, or when the title of the current\r\n * root has changed. This event has no properties.\r\n *\r\n * Event: mxEvent.BEFORE_ADD_VERTEX\r\n *\r\n * Fires before a vertex is added in <addVertex>. The <code>vertex</code>\r\n * property contains the new vertex and the <code>parent</code> property\r\n * contains its parent.\r\n *\r\n * Event: mxEvent.ADD_VERTEX\r\n *\r\n * Fires between begin- and endUpdate in <addVertex>. The <code>vertex</code>\r\n * property contains the vertex that is being inserted.\r\n *\r\n * Event: mxEvent.AFTER_ADD_VERTEX\r\n *\r\n * Fires after a vertex was inserted and selected in <addVertex>. The\r\n * <code>vertex</code> property contains the new vertex.\r\n *\r\n * Example:\r\n *\r\n * For starting an in-place edit after a new vertex has been added to the\r\n * graph, the following code can be used.\r\n *\r\n * (code)\r\n * editor.addListener(mxEvent.AFTER_ADD_VERTEX, function(sender, evt)\r\n * {\r\n *   var vertex = evt.getProperty('vertex');\r\n *\r\n *   if (editor.graph.isCellEditable(vertex))\r\n *   {\r\n *   \teditor.graph.startEditingAtCell(vertex);\r\n *   }\r\n * });\r\n * (end)\r\n *\r\n * Event: mxEvent.ESCAPE\r\n *\r\n * Fires when the escape key is pressed. The <code>event</code> property\r\n * contains the key event.\r\n *\r\n * Constructor: mxEditor\r\n *\r\n * Constructs a new editor. This function invokes the <onInit> callback\r\n * upon completion.\r\n *\r\n * Example:\r\n *\r\n * (code)\r\n * var config = mxRequestUtils.load('config/diagrameditor.xml').getDocumentElement();\r\n * var editor = new mxEditor(config);\r\n * (end)\r\n *\r\n * Parameters:\r\n *\r\n * config - Optional XML node that contains the configuration.\r\n */\nvar _default = exports[\"default\"] = mxDefaultToolbar;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxDefaultToolbar.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxDictionary.js":
/*!***********************************************!*\
  !*** ./src/workflow/mxClient/mxDictionary.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.map.js */ \"../../node_modules/core-js/modules/es.array.map.js\");\nvar _mxObjectIdentity = _interopRequireDefault(__webpack_require__(/*! ./mxObjectIdentity.js */ \"./src/workflow/mxClient/mxObjectIdentity.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxDictionary() {\n  this.clear();\n}\n;\n\n/**\r\n * Function: map\r\n *\r\n * Stores the (key, value) pairs in this dictionary.\r\n */\nmxDictionary.prototype.map = null;\n\n/**\r\n * Function: clear\r\n *\r\n * Clears the dictionary.\r\n */\nmxDictionary.prototype.clear = function () {\n  this.map = {};\n};\n\n/**\r\n * Function: get\r\n *\r\n * Returns the value for the given key.\r\n */\nmxDictionary.prototype.get = function (key) {\n  var id = _mxObjectIdentity[\"default\"].get(key);\n  return this.map[id];\n};\n\n/**\r\n * Function: put\r\n *\r\n * Stores the value under the given key and returns the previous\r\n * value for that key.\r\n */\nmxDictionary.prototype.put = function (key, value) {\n  var id = _mxObjectIdentity[\"default\"].get(key);\n  var previous = this.map[id];\n  this.map[id] = value;\n  return previous;\n};\n\n/**\r\n * Function: remove\r\n *\r\n * Removes the value for the given key and returns the value that\r\n * has been removed.\r\n */\nmxDictionary.prototype.remove = function (key) {\n  var id = _mxObjectIdentity[\"default\"].get(key);\n  var previous = this.map[id];\n  delete this.map[id];\n  return previous;\n};\n\n/**\r\n * Function: getKeys\r\n *\r\n * Returns all keys as an array.\r\n */\nmxDictionary.prototype.getKeys = function () {\n  var result = [];\n  for (var key in this.map) {\n    result.push(key);\n  }\n  return result;\n};\n\n/**\r\n * Function: getValues\r\n *\r\n * Returns all values as an array.\r\n */\nmxDictionary.prototype.getValues = function () {\n  var result = [];\n  for (var key in this.map) {\n    result.push(this.map[key]);\n  }\n  return result;\n};\n\n/**\r\n * Function: visit\r\n *\r\n * Visits all entries in the dictionary using the given function with the\r\n * following signature: function(key, value) where key is a string and\r\n * value is an object.\r\n *\r\n * Parameters:\r\n *\r\n * visitor - A function that takes the key and value as arguments.\r\n */\nmxDictionary.prototype.visit = function (visitor) {\n  for (var key in this.map) {\n    visitor(key, this.map[key]);\n  }\n};\n/**\r\n * Copyright (c) 2006-2016, JGraph Ltd\r\n * Copyright (c) 2006-2016, Gaudenz Alder\r\n */\nvar _default = exports[\"default\"] = mxDictionary;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxDictionary.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxDivResizer.js":
/*!***********************************************!*\
  !*** ./src/workflow/mxClient/mxDivResizer.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.function.bind.js */ \"../../node_modules/core-js/modules/es.function.bind.js\");\n__webpack_require__(/*! core-js/modules/es.parse-int.js */ \"../../node_modules/core-js/modules/es.parse-int.js\");\nvar _mxEvent = _interopRequireDefault(__webpack_require__(/*! ./mxEvent.js */ \"./src/workflow/mxClient/mxEvent.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxDivResizer(div, container) {\n  if (div.nodeName.toLowerCase() == 'div') {\n    if (container == null) {\n      container = window;\n    }\n    this.div = div;\n    var style = _mxGraphUtils[\"default\"].getCurrentStyle(div);\n    if (style != null) {\n      this.resizeWidth = style.width == 'auto';\n      this.resizeHeight = style.height == 'auto';\n    }\n    _mxEvent[\"default\"].addListener(container, 'resize', _mxGraphUtils[\"default\"].bind(this, function (evt) {\n      if (!this.handlingResize) {\n        this.handlingResize = true;\n        this.resize();\n        this.handlingResize = false;\n      }\n    }));\n    this.resize();\n  }\n}\n;\n\n/**\r\n * Function: resizeWidth\r\n *\r\n * Boolean specifying if the width should be updated.\r\n */\nmxDivResizer.prototype.resizeWidth = true;\n\n/**\r\n * Function: resizeHeight\r\n *\r\n * Boolean specifying if the height should be updated.\r\n */\nmxDivResizer.prototype.resizeHeight = true;\n\n/**\r\n * Function: handlingResize\r\n *\r\n * Boolean specifying if the width should be updated.\r\n */\nmxDivResizer.prototype.handlingResize = false;\n\n/**\r\n * Function: resize\r\n *\r\n * Updates the style of the DIV after the window has been resized.\r\n */\nmxDivResizer.prototype.resize = function () {\n  var w = this.getDocumentWidth();\n  var h = this.getDocumentHeight();\n  var l = parseInt(this.div.style.left);\n  var r = parseInt(this.div.style.right);\n  var t = parseInt(this.div.style.top);\n  var b = parseInt(this.div.style.bottom);\n  if (this.resizeWidth && !isNaN(l) && !isNaN(r) && l >= 0 && r >= 0 && w - r - l > 0) {\n    this.div.style.width = w - r - l + 'px';\n  }\n  if (this.resizeHeight && !isNaN(t) && !isNaN(b) && t >= 0 && b >= 0 && h - t - b > 0) {\n    this.div.style.height = h - t - b + 'px';\n  }\n};\n\n/**\r\n * Function: getDocumentWidth\r\n *\r\n * Hook for subclassers to return the width of the document (without\r\n * scrollbars).\r\n */\nmxDivResizer.prototype.getDocumentWidth = function () {\n  return document.body.clientWidth;\n};\n\n/**\r\n * Function: getDocumentHeight\r\n *\r\n * Hook for subclassers to return the height of the document (without\r\n * scrollbars).\r\n */\nmxDivResizer.prototype.getDocumentHeight = function () {\n  return document.body.clientHeight;\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxDragSource\r\n *\r\n * Wrapper to create a drag source from a DOM element so that the element can\r\n * be dragged over a graph and dropped into the graph as a new cell.\r\n *\r\n * Problem is that in the dropHandler the current preview location is not\r\n * available, so the preview and the dropHandler must match.\r\n *\r\n * Constructor: mxDragSource\r\n *\r\n * Constructs a new drag source for the given element.\r\n */\nvar _default = exports[\"default\"] = mxDivResizer;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxDivResizer.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxDoubleEllipse.js":
/*!**************************************************!*\
  !*** ./src/workflow/mxClient/mxDoubleEllipse.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.fill.js */ \"../../node_modules/core-js/modules/es.array.fill.js\");\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxRectangle = _interopRequireDefault(__webpack_require__(/*! ./mxRectangle.js */ \"./src/workflow/mxClient/mxRectangle.js\"));\nvar _mxShape = _interopRequireDefault(__webpack_require__(/*! ./mxShape.js */ \"./src/workflow/mxClient/mxShape.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ./mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxDoubleEllipse(bounds, fill, stroke, strokewidth) {\n  _mxShape[\"default\"].call(this);\n  this.bounds = bounds;\n  this.fill = fill;\n  this.stroke = stroke;\n  this.strokewidth = strokewidth != null ? strokewidth : 1;\n}\n;\n\n/**\r\n * Extends mxShape.\r\n */\n_mxGraphUtils[\"default\"].extend(mxDoubleEllipse, _mxShape[\"default\"]);\n\n/**\r\n * Variable: vmlScale\r\n *\r\n * Scale for improving the precision of VML rendering. Default is 10.\r\n */\nmxDoubleEllipse.prototype.vmlScale = 10;\n\n/**\r\n * Function: paintBackground\r\n *\r\n * Paints the background.\r\n */\nmxDoubleEllipse.prototype.paintBackground = function (c, x, y, w, h) {\n  c.ellipse(x, y, w, h);\n  c.fillAndStroke();\n};\n\n/**\r\n * Function: paintForeground\r\n *\r\n * Paints the foreground.\r\n */\nmxDoubleEllipse.prototype.paintForeground = function (c, x, y, w, h) {\n  if (!this.outline) {\n    var margin = _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_MARGIN, Math.min(3 + this.strokewidth, Math.min(w / 5, h / 5)));\n    x += margin;\n    y += margin;\n    w -= 2 * margin;\n    h -= 2 * margin;\n\n    // FIXME: Rounding issues in IE8 standards mode (not in 1.x)\n    if (w > 0 && h > 0) {\n      c.ellipse(x, y, w, h);\n    }\n    c.stroke();\n  }\n};\n\n/**\r\n * Function: getLabelBounds\r\n *\r\n * Returns the bounds for the label.\r\n */\nmxDoubleEllipse.prototype.getLabelBounds = function (rect) {\n  var margin = _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_MARGIN, Math.min(3 + this.strokewidth, Math.min(rect.width / 5 / this.scale, rect.height / 5 / this.scale))) * this.scale;\n  return new _mxRectangle[\"default\"](rect.x + margin, rect.y + margin, rect.width - 2 * margin, rect.height - 2 * margin);\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxRhombus\r\n *\r\n * Extends <mxShape> to implement a rhombus (aka diamond) shape.\r\n * This shape is registered under <mxConstants.SHAPE_RHOMBUS>\r\n * in <mxCellRenderer>.\r\n *\r\n * Constructor: mxRhombus\r\n *\r\n * Constructs a new rhombus shape.\r\n *\r\n * Parameters:\r\n *\r\n * bounds - <mxRectangle> that defines the bounds. This is stored in\r\n * <mxShape.bounds>.\r\n * fill - String that defines the fill color. This is stored in <fill>.\r\n * stroke - String that defines the stroke color. This is stored in <stroke>.\r\n * strokewidth - Optional integer that defines the stroke width. Default is\r\n * 1. This is stored in <strokewidth>.\r\n */\nvar _default = exports[\"default\"] = mxDoubleEllipse;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxDoubleEllipse.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxDragSource.js":
/*!***********************************************!*\
  !*** ./src/workflow/mxClient/mxDragSource.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.function.bind.js */ \"../../node_modules/core-js/modules/es.function.bind.js\");\n__webpack_require__(/*! core-js/modules/es.object.to-string.js */ \"../../node_modules/core-js/modules/es.object.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.parse-int.js */ \"../../node_modules/core-js/modules/es.parse-int.js\");\n__webpack_require__(/*! core-js/modules/es.promise.js */ \"../../node_modules/core-js/modules/es.promise.js\");\nvar _mxGuide = _interopRequireDefault(__webpack_require__(/*! ./mxGuide.js */ \"./src/workflow/mxClient/mxGuide.js\"));\nvar _mxPoint = _interopRequireDefault(__webpack_require__(/*! ./mxPoint.js */ \"./src/workflow/mxClient/mxPoint.js\"));\nvar _mxEventUtils = _interopRequireDefault(__webpack_require__(/*! ./mxEventUtils.js */ \"./src/workflow/mxClient/mxEventUtils.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxRectangle = _interopRequireDefault(__webpack_require__(/*! ./mxRectangle.js */ \"./src/workflow/mxClient/mxRectangle.js\"));\nvar _mxCellHighlight = _interopRequireDefault(__webpack_require__(/*! ./mxCellHighlight.js */ \"./src/workflow/mxClient/mxCellHighlight.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ./mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nvar _mxClient = _interopRequireDefault(__webpack_require__(/*! ./mxClient.js */ \"./src/workflow/mxClient/mxClient.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxDragSource(element, dropHandler) {\n  this.element = element;\n  this.dropHandler = dropHandler;\n\n  // Handles a drag gesture on the element\n  _mxEventUtils[\"default\"].addGestureListeners(element, _mxGraphUtils[\"default\"].bind(this, function (evt) {\n    this.mouseDown(evt);\n  }));\n\n  // Prevents native drag and drop\n  _mxEventUtils[\"default\"].addListener(element, 'dragstart', function (evt) {\n    _mxEventUtils[\"default\"].consume(evt);\n  });\n  this.eventConsumer = function (sender, evt) {\n    var evtName = evt.getProperty('eventName');\n    var me = evt.getProperty('event');\n    if (evtName != _mxEventUtils[\"default\"].MOUSE_DOWN) {\n      me.consume();\n    }\n  };\n}\n;\n\n/**\r\n * Variable: element\r\n *\r\n * Reference to the DOM node which was made draggable.\r\n */\nmxDragSource.prototype.element = null;\n\n/**\r\n * Variable: dropHandler\r\n *\r\n * Holds the DOM node that is used to represent the drag preview. If this is\r\n * null then the source element will be cloned and used for the drag preview.\r\n */\nmxDragSource.prototype.dropHandler = null;\n\n/**\r\n * Variable: dragOffset\r\n *\r\n * <mxPoint> that specifies the offset of the <dragElement>. Default is null.\r\n */\nmxDragSource.prototype.dragOffset = null;\n\n/**\r\n * Variable: dragElement\r\n *\r\n * Holds the DOM node that is used to represent the drag preview. If this is\r\n * null then the source element will be cloned and used for the drag preview.\r\n */\nmxDragSource.prototype.dragElement = null;\n\n/**\r\n * Variable: previewElement\r\n *\r\n * Optional <mxRectangle> that specifies the unscaled size of the preview.\r\n */\nmxDragSource.prototype.previewElement = null;\n\n/**\r\n * Variable: enabled\r\n *\r\n * Specifies if this drag source is enabled. Default is true.\r\n */\nmxDragSource.prototype.enabled = true;\n\n/**\r\n * Variable: currentGraph\r\n *\r\n * Reference to the <mxGraph> that is the current drop target.\r\n */\nmxDragSource.prototype.currentGraph = null;\n\n/**\r\n * Variable: currentDropTarget\r\n *\r\n * Holds the current drop target under the mouse.\r\n */\nmxDragSource.prototype.currentDropTarget = null;\n\n/**\r\n * Variable: currentPoint\r\n *\r\n * Holds the current drop location.\r\n */\nmxDragSource.prototype.currentPoint = null;\n\n/**\r\n * Variable: currentGuide\r\n *\r\n * Holds an <mxGuide> for the <currentGraph> if <dragPreview> is not null.\r\n */\nmxDragSource.prototype.currentGuide = null;\n\n/**\r\n * Variable: currentGuide\r\n *\r\n * Holds an <mxGuide> for the <currentGraph> if <dragPreview> is not null.\r\n */\nmxDragSource.prototype.currentHighlight = null;\n\n/**\r\n * Variable: autoscroll\r\n *\r\n * Specifies if the graph should scroll automatically. Default is true.\r\n */\nmxDragSource.prototype.autoscroll = true;\n\n/**\r\n * Variable: guidesEnabled\r\n *\r\n * Specifies if <mxGuide> should be enabled. Default is true.\r\n */\nmxDragSource.prototype.guidesEnabled = true;\n\n/**\r\n * Variable: gridEnabled\r\n *\r\n * Specifies if the grid should be allowed. Default is true.\r\n */\nmxDragSource.prototype.gridEnabled = true;\n\n/**\r\n * Variable: highlightDropTargets\r\n *\r\n * Specifies if drop targets should be highlighted. Default is true.\r\n */\nmxDragSource.prototype.highlightDropTargets = true;\n\n/**\r\n * Variable: dragElementZIndex\r\n *\r\n * ZIndex for the drag element. Default is 100.\r\n */\nmxDragSource.prototype.dragElementZIndex = 100;\n\n/**\r\n * Variable: dragElementOpacity\r\n *\r\n * Opacity of the drag element in %. Default is 70.\r\n */\nmxDragSource.prototype.dragElementOpacity = 70;\n\n/**\r\n * Function: isEnabled\r\n *\r\n * Returns <enabled>.\r\n */\nmxDragSource.prototype.isEnabled = function () {\n  return this.enabled;\n};\n\n/**\r\n * Function: setEnabled\r\n *\r\n * Sets <enabled>.\r\n */\nmxDragSource.prototype.setEnabled = function (value) {\n  this.enabled = value;\n};\n\n/**\r\n * Function: isGuidesEnabled\r\n *\r\n * Returns <guidesEnabled>.\r\n */\nmxDragSource.prototype.isGuidesEnabled = function () {\n  return this.guidesEnabled;\n};\n\n/**\r\n * Function: setGuidesEnabled\r\n *\r\n * Sets <guidesEnabled>.\r\n */\nmxDragSource.prototype.setGuidesEnabled = function (value) {\n  this.guidesEnabled = value;\n};\n\n/**\r\n * Function: isGridEnabled\r\n *\r\n * Returns <gridEnabled>.\r\n */\nmxDragSource.prototype.isGridEnabled = function () {\n  return this.gridEnabled;\n};\n\n/**\r\n * Function: setGridEnabled\r\n *\r\n * Sets <gridEnabled>.\r\n */\nmxDragSource.prototype.setGridEnabled = function (value) {\n  this.gridEnabled = value;\n};\n\n/**\r\n * Function: getGraphForEvent\r\n *\r\n * Returns the graph for the given mouse event. This implementation returns\r\n * null.\r\n */\nmxDragSource.prototype.getGraphForEvent = function (evt) {\n  return null;\n};\n\n/**\r\n * Function: getDropTarget\r\n *\r\n * Returns the drop target for the given graph and coordinates. This\r\n * implementation uses <mxGraph.getCellAt>.\r\n */\nmxDragSource.prototype.getDropTarget = function (graph, x, y, evt) {\n  return graph.getCellAt(x, y);\n};\n\n/**\r\n * Function: createDragElement\r\n *\r\n * Creates and returns a clone of the <dragElementPrototype> or the <element>\r\n * if the former is not defined.\r\n */\nmxDragSource.prototype.createDragElement = function (evt) {\n  return this.element.cloneNode(true);\n};\n\n/**\r\n * Function: createPreviewElement\r\n *\r\n * Creates and returns an element which can be used as a preview in the given\r\n * graph.\r\n */\nmxDragSource.prototype.createPreviewElement = function (graph) {\n  return null;\n};\n\n/**\r\n * Function: isActive\r\n *\r\n * Returns true if this drag source is active.\r\n */\nmxDragSource.prototype.isActive = function () {\n  return this.mouseMoveHandler != null;\n};\n\n/**\r\n * Function: reset\r\n *\r\n * Stops and removes everything and restores the state of the object.\r\n */\nmxDragSource.prototype.reset = function () {\n  if (this.currentGraph != null) {\n    this.dragExit(this.currentGraph);\n    this.currentGraph = null;\n  }\n  this.removeDragElement();\n  this.removeListeners();\n  this.stopDrag();\n};\n\n/**\r\n * Function: mouseDown\r\n *\r\n * Returns the drop target for the given graph and coordinates. This\r\n * implementation uses <mxGraph.getCellAt>.\r\n *\r\n * To ignore popup menu events for a drag source, this function can be\r\n * overridden as follows.\r\n *\r\n * (code)\r\n * var mouseDown = dragSource.mouseDown;\r\n *\r\n * dragSource.mouseDown = function(evt)\r\n * {\r\n *   if (!mxEventUtils.isPopupTrigger(evt))\r\n *   {\r\n *     mouseDown.apply(this, arguments);\r\n *   }\r\n * };\r\n * (end)\r\n */\nmxDragSource.prototype.mouseDown = function (evt) {\n  if (this.enabled && !_mxEventUtils[\"default\"].isConsumed(evt) && this.mouseMoveHandler == null) {\n    this.startDrag(evt);\n    this.mouseMoveHandler = _mxGraphUtils[\"default\"].bind(this, this.mouseMove);\n    this.mouseUpHandler = _mxGraphUtils[\"default\"].bind(this, this.mouseUp);\n    _mxEventUtils[\"default\"].addGestureListeners(document, null, this.mouseMoveHandler, this.mouseUpHandler);\n    if (_mxClient[\"default\"].IS_TOUCH && !_mxEventUtils[\"default\"].isMouseEvent(evt)) {\n      this.eventSource = _mxEventUtils[\"default\"].getSource(evt);\n      _mxEventUtils[\"default\"].addGestureListeners(this.eventSource, null, this.mouseMoveHandler, this.mouseUpHandler);\n    }\n  }\n};\n\n/**\r\n * Function: startDrag\r\n *\r\n * Creates the <dragElement> using <createDragElement>.\r\n */\nmxDragSource.prototype.startDrag = function (evt) {\n  this.dragElement = this.createDragElement(evt);\n  this.dragElement.style.position = 'absolute';\n  this.dragElement.style.zIndex = this.dragElementZIndex;\n  _mxGraphUtils[\"default\"].setOpacity(this.dragElement, this.dragElementOpacity);\n};\n\n/**\r\n * Function: stopDrag\r\n *\r\n * Invokes <removeDragElement>.\r\n */\nmxDragSource.prototype.stopDrag = function () {\n  // LATER: This used to have a mouse event. If that is still needed we need to add another\n  // final call to the DnD protocol to add a cleanup step in the case of escape press, which\n  // is not associated with a mouse event and which currently calles this method.\n  this.removeDragElement();\n};\n\n/**\r\n * Function: removeDragElement\r\n *\r\n * Removes and destroys the <dragElement>.\r\n */\nmxDragSource.prototype.removeDragElement = function () {\n  if (this.dragElement != null) {\n    if (this.dragElement.parentNode != null) {\n      this.dragElement.parentNode.removeChild(this.dragElement);\n    }\n    this.dragElement = null;\n  }\n};\n\n/**\r\n * Function: graphContainsEvent\r\n *\r\n * Returns true if the given graph contains the given event.\r\n */\nmxDragSource.prototype.graphContainsEvent = function (graph, evt) {\n  var x = _mxEventUtils[\"default\"].getClientX(evt);\n  var y = _mxEventUtils[\"default\"].getClientY(evt);\n  var offset = _mxGraphUtils[\"default\"].getOffset(graph.container, null, _mxPoint[\"default\"]);\n  var origin = _mxGraphUtils[\"default\"].getScrollOrigin(null, _mxPoint[\"default\"]);\n\n  // Checks if event is inside the bounds of the graph container\n  return x >= offset.x - origin.x && y >= offset.y - origin.y && x <= offset.x - origin.x + graph.container.offsetWidth && y <= offset.y - origin.y + graph.container.offsetHeight;\n};\n\n/**\r\n * Function: mouseMove\r\n *\r\n * Gets the graph for the given event using <getGraphForEvent>, updates the\r\n * <currentGraph>, calling <dragEnter> and <dragExit> on the new and old graph,\r\n * respectively, and invokes <dragOver> if <currentGraph> is not null.\r\n */\nmxDragSource.prototype.mouseMove = function (evt) {\n  var graph = this.getGraphForEvent(evt);\n\n  // Checks if event is inside the bounds of the graph container\n  if (graph != null && !this.graphContainsEvent(graph, evt)) {\n    graph = null;\n  }\n  if (graph != this.currentGraph) {\n    if (this.currentGraph != null) {\n      this.dragExit(this.currentGraph, evt);\n    }\n    this.currentGraph = graph;\n    if (this.currentGraph != null) {\n      this.dragEnter(this.currentGraph, evt);\n    }\n  }\n  if (this.currentGraph != null) {\n    this.dragOver(this.currentGraph, evt);\n  }\n  if (this.dragElement != null && (this.previewElement == null || this.previewElement.style.visibility != 'visible')) {\n    var x = _mxEventUtils[\"default\"].getClientX(evt);\n    var y = _mxEventUtils[\"default\"].getClientY(evt);\n    if (this.dragElement.parentNode == null) {\n      document.body.appendChild(this.dragElement);\n    }\n    this.dragElement.style.visibility = 'visible';\n    if (this.dragOffset != null) {\n      x += this.dragOffset.x;\n      y += this.dragOffset.y;\n    }\n    var offset = _mxGraphUtils[\"default\"].getDocumentScrollOrigin(document, _mxPoint[\"default\"]);\n    this.dragElement.style.left = x + offset.x + 'px';\n    this.dragElement.style.top = y + offset.y + 'px';\n  } else if (this.dragElement != null) {\n    this.dragElement.style.visibility = 'hidden';\n  }\n  _mxEventUtils[\"default\"].consume(evt);\n};\n\n/**\r\n * Function: mouseUp\r\n *\r\n * Processes the mouse up event and invokes <drop>, <dragExit> and <stopDrag>\r\n * as required.\r\n */\nmxDragSource.prototype.mouseUp = function (evt) {\n  if (this.currentGraph != null) {\n    if (this.currentPoint != null && (this.previewElement == null || this.previewElement.style.visibility != 'hidden')) {\n      var scale = this.currentGraph.view.scale;\n      var tr = this.currentGraph.view.translate;\n      var x = this.currentPoint.x / scale - tr.x;\n      var y = this.currentPoint.y / scale - tr.y;\n      this.drop(this.currentGraph, evt, this.currentDropTarget, x, y);\n    }\n    this.dragExit(this.currentGraph);\n    this.currentGraph = null;\n  }\n  this.stopDrag();\n  this.removeListeners();\n  _mxEventUtils[\"default\"].consume(evt);\n};\n\n/**\r\n * Function: removeListeners\r\n *\r\n * Actives the given graph as a drop target.\r\n */\nmxDragSource.prototype.removeListeners = function () {\n  if (this.eventSource != null) {\n    _mxEventUtils[\"default\"].removeGestureListeners(this.eventSource, null, this.mouseMoveHandler, this.mouseUpHandler);\n    this.eventSource = null;\n  }\n  _mxEventUtils[\"default\"].removeGestureListeners(document, null, this.mouseMoveHandler, this.mouseUpHandler);\n  this.mouseMoveHandler = null;\n  this.mouseUpHandler = null;\n};\n\n/**\r\n * Function: dragEnter\r\n *\r\n * Actives the given graph as a drop target.\r\n */\nmxDragSource.prototype.dragEnter = function (graph, evt) {\n  graph.isMouseDown = true;\n  graph.isMouseTrigger = _mxEventUtils[\"default\"].isMouseEvent(evt);\n  this.previewElement = this.createPreviewElement(graph);\n\n  // Guide is only needed if preview element is used\n  if (this.isGuidesEnabled() && this.previewElement != null) {\n    this.currentGuide = new _mxGuide[\"default\"](graph, graph.graphHandler.getGuideStates());\n  }\n  if (this.highlightDropTargets) {\n    this.currentHighlight = new _mxCellHighlight[\"default\"](graph, _mxConstants[\"default\"].DROP_TARGET_COLOR);\n  }\n\n  // Consumes all events in the current graph before they are fired\n  graph.addListener(_mxEventUtils[\"default\"].FIRE_MOUSE_EVENT, this.eventConsumer);\n};\n\n/**\r\n * Function: dragExit\r\n *\r\n * Deactivates the given graph as a drop target.\r\n */\nmxDragSource.prototype.dragExit = function (graph, evt) {\n  this.currentDropTarget = null;\n  this.currentPoint = null;\n  graph.isMouseDown = false;\n\n  // Consumes all events in the current graph before they are fired\n  graph.removeListener(this.eventConsumer);\n  if (this.previewElement != null) {\n    if (this.previewElement.parentNode != null) {\n      this.previewElement.parentNode.removeChild(this.previewElement);\n    }\n    this.previewElement = null;\n  }\n  if (this.currentGuide != null) {\n    this.currentGuide.destroy();\n    this.currentGuide = null;\n  }\n  if (this.currentHighlight != null) {\n    this.currentHighlight.destroy();\n    this.currentHighlight = null;\n  }\n};\n\n/**\r\n * Function: dragOver\r\n *\r\n * Implements autoscroll, updates the <currentPoint>, highlights any drop\r\n * targets and updates the preview.\r\n */\nmxDragSource.prototype.dragOver = function (graph, evt) {\n  var offset = _mxGraphUtils[\"default\"].getOffset(graph.container, null, _mxPoint[\"default\"]);\n  var origin = _mxGraphUtils[\"default\"].getScrollOrigin(graph.container, _mxPoint[\"default\"]);\n  var x = _mxEventUtils[\"default\"].getClientX(evt) - offset.x + origin.x - graph.panDx;\n  var y = _mxEventUtils[\"default\"].getClientY(evt) - offset.y + origin.y - graph.panDy;\n  if (graph.autoScroll && (this.autoscroll == null || this.autoscroll)) {\n    graph.scrollPointToVisible(x, y, graph.autoExtend);\n  }\n\n  // Highlights the drop target under the mouse\n  if (this.currentHighlight != null && graph.isDropEnabled()) {\n    this.currentDropTarget = this.getDropTarget(graph, x, y, evt);\n    var state = graph.getView().getState(this.currentDropTarget);\n    this.currentHighlight.highlight(state);\n  }\n\n  // Updates the location of the preview\n  if (this.previewElement != null) {\n    if (this.previewElement.parentNode == null) {\n      graph.container.appendChild(this.previewElement);\n      this.previewElement.style.zIndex = '3';\n      this.previewElement.style.position = 'absolute';\n    }\n    var gridEnabled = this.isGridEnabled() && graph.isGridEnabledEvent(evt);\n    var hideGuide = true;\n\n    // Grid and guides\n    if (this.currentGuide != null && this.currentGuide.isEnabledForEvent(evt)) {\n      // LATER: HTML preview appears smaller than SVG preview\n      var w = parseInt(this.previewElement.style.width);\n      var h = parseInt(this.previewElement.style.height);\n      var bounds = new _mxRectangle[\"default\"](0, 0, w, h);\n      var delta = new _mxPoint[\"default\"](x, y);\n      delta = this.currentGuide.move(bounds, delta, gridEnabled);\n      hideGuide = false;\n      x = delta.x;\n      y = delta.y;\n    } else if (gridEnabled) {\n      var scale = graph.view.scale;\n      var tr = graph.view.translate;\n      var off = graph.gridSize / 2;\n      x = (graph.snap(x / scale - tr.x - off) + tr.x) * scale;\n      y = (graph.snap(y / scale - tr.y - off) + tr.y) * scale;\n    }\n    if (this.currentGuide != null && hideGuide) {\n      this.currentGuide.hide();\n    }\n    if (this.previewOffset != null) {\n      x += this.previewOffset.x;\n      y += this.previewOffset.y;\n    }\n    this.previewElement.style.left = Math.round(x) + 'px';\n    this.previewElement.style.top = Math.round(y) + 'px';\n    this.previewElement.style.visibility = 'visible';\n  }\n  this.currentPoint = new _mxPoint[\"default\"](x, y);\n};\n\n/**\r\n * Function: drop\r\n *\r\n * Returns the drop target for the given graph and coordinates. This\r\n * implementation uses <mxGraph.getCellAt>.\r\n */\nmxDragSource.prototype.drop = function (graph, evt, dropTarget, x, y) {\n  this.dropHandler(graph, evt, dropTarget, x, y);\n\n  // Had to move this to after the insert because it will\n  // affect the scrollbars of the window in IE to try and\n  // make the complete container visible.\n  // LATER: Should be made optional.\n  if (graph.container.style.visibility != 'hidden') {\n    graph.container.focus();\n  }\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxToolbar\r\n *\r\n * Creates a toolbar inside a given DOM node. The toolbar may contain icons,\r\n * buttons and combo boxes.\r\n *\r\n * Event: mxEventUtils.SELECT\r\n *\r\n * Fires when an item was selected in the toolbar. The <code>function</code>\r\n * property contains the function that was selected in <selectMode>.\r\n *\r\n * Constructor: mxToolbar\r\n *\r\n * Constructs a toolbar in the specified container.\r\n *\r\n * Parameters:\r\n *\r\n * container - DOM node that contains the toolbar.\r\n */\nvar _default = exports[\"default\"] = mxDragSource;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxDragSource.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxEdgeHandler.js":
/*!************************************************!*\
  !*** ./src/workflow/mxClient/mxEdgeHandler.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.fill.js */ \"../../node_modules/core-js/modules/es.array.fill.js\");\n__webpack_require__(/*! core-js/modules/es.array.slice.js */ \"../../node_modules/core-js/modules/es.array.slice.js\");\n__webpack_require__(/*! core-js/modules/es.array.splice.js */ \"../../node_modules/core-js/modules/es.array.splice.js\");\n__webpack_require__(/*! core-js/modules/es.function.bind.js */ \"../../node_modules/core-js/modules/es.function.bind.js\");\n__webpack_require__(/*! core-js/modules/es.number.constructor.js */ \"../../node_modules/core-js/modules/es.number.constructor.js\");\nvar _mxEvent = _interopRequireDefault(__webpack_require__(/*! ./mxEvent.js */ \"./src/workflow/mxClient/mxEvent.js\"));\nvar _mxRectangle = _interopRequireDefault(__webpack_require__(/*! ./mxRectangle.js */ \"./src/workflow/mxClient/mxRectangle.js\"));\nvar _mxRectangleShape = _interopRequireDefault(__webpack_require__(/*! ./mxRectangleShape.js */ \"./src/workflow/mxClient/mxRectangleShape.js\"));\nvar _mxClient = _interopRequireDefault(__webpack_require__(/*! ./mxClient.js */ \"./src/workflow/mxClient/mxClient.js\"));\nvar _mxPoint = _interopRequireDefault(__webpack_require__(/*! ./mxPoint.js */ \"./src/workflow/mxClient/mxPoint.js\"));\nvar _mxConstraintHandler = _interopRequireDefault(__webpack_require__(/*! ./mxConstraintHandler.js */ \"./src/workflow/mxClient/mxConstraintHandler.js\"));\nvar _mxGraphHandler = _interopRequireDefault(__webpack_require__(/*! ./mxGraphHandler.js */ \"./src/workflow/mxClient/mxGraphHandler.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxCellMarker = _interopRequireDefault(__webpack_require__(/*! ./mxCellMarker.js */ \"./src/workflow/mxClient/mxCellMarker.js\"));\nvar _mxConnectionConstraint = _interopRequireDefault(__webpack_require__(/*! ./mxConnectionConstraint.js */ \"./src/workflow/mxClient/mxConnectionConstraint.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ./mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nvar _mxEdgeStyle = _interopRequireDefault(__webpack_require__(/*! ./mxEdgeStyle.js */ \"./src/workflow/mxClient/mxEdgeStyle.js\"));\nvar _mxImageShape = _interopRequireDefault(__webpack_require__(/*! ./mxImageShape.js */ \"./src/workflow/mxClient/mxImageShape.js\"));\nvar _workflowUtil = __webpack_require__(/*! ../util/workflowUtil */ \"./src/workflow/util/workflowUtil.js\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxEdgeHandler(state) {\n  if (state != null) {\n    this.state = state;\n    this.init();\n\n    // Handles escape keystrokes\n    this.escapeHandler = _mxGraphUtils[\"default\"].bind(this, function (sender, evt) {\n      this.reset();\n    });\n    this.state.view.graph.addListener(_mxEvent[\"default\"].ESCAPE, this.escapeHandler);\n  }\n}\n;\n\n/**\r\n * Variable: graph\r\n *\r\n * Reference to the enclosing <mxGraph>.\r\n */\nmxEdgeHandler.prototype.graph = null;\n\n/**\r\n * Variable: state\r\n *\r\n * Reference to the <mxCellState> being modified.\r\n */\nmxEdgeHandler.prototype.state = null;\n\n/**\r\n * Variable: marker\r\n *\r\n * Holds the <mxTerminalMarker> which is used for highlighting terminals.\r\n */\nmxEdgeHandler.prototype.marker = null;\n\n/**\r\n * Variable: constraintHandler\r\n *\r\n * Holds the <mxConstraintHandler> used for drawing and highlighting\r\n * constraints.\r\n */\nmxEdgeHandler.prototype.constraintHandler = null;\n\n/**\r\n * Variable: error\r\n *\r\n * Holds the current validation error while a connection is being changed.\r\n */\nmxEdgeHandler.prototype.error = null;\n\n/**\r\n * Variable: shape\r\n *\r\n * Holds the <mxShape> that represents the preview edge.\r\n */\nmxEdgeHandler.prototype.shape = null;\n\n/**\r\n * Variable: bends\r\n *\r\n * Holds the <mxShapes> that represent the points.\r\n */\nmxEdgeHandler.prototype.bends = null;\n\n/**\r\n * Variable: labelShape\r\n *\r\n * Holds the <mxShape> that represents the label position.\r\n */\nmxEdgeHandler.prototype.labelShape = null;\n\n/**\r\n * Variable: cloneEnabled\r\n *\r\n * Specifies if cloning by control-drag is enabled. Default is true.\r\n */\nmxEdgeHandler.prototype.cloneEnabled = true;\n\n/**\r\n * Variable: addEnabled\r\n *\r\n * Specifies if adding bends by shift-click is enabled. Default is false.\r\n * Note: This experimental feature is not recommended for production use.\r\n */\nmxEdgeHandler.prototype.addEnabled = false;\n\n/**\r\n * Variable: removeEnabled\r\n *\r\n * Specifies if removing bends by shift-click is enabled. Default is false.\r\n * Note: This experimental feature is not recommended for production use.\r\n */\nmxEdgeHandler.prototype.removeEnabled = false;\n\n/**\r\n * Variable: dblClickRemoveEnabled\r\n *\r\n * Specifies if removing bends by double click is enabled. Default is false.\r\n */\nmxEdgeHandler.prototype.dblClickRemoveEnabled = false;\n\n/**\r\n * Variable: mergeRemoveEnabled\r\n *\r\n * Specifies if removing bends by dropping them on other bends is enabled.\r\n * Default is false.\r\n */\nmxEdgeHandler.prototype.mergeRemoveEnabled = false;\n\n/**\r\n * Variable: straightRemoveEnabled\r\n *\r\n * Specifies if removing bends by creating straight segments should be enabled.\r\n * If enabled, this can be overridden by holding down the alt key while moving.\r\n * Default is false.\r\n */\nmxEdgeHandler.prototype.straightRemoveEnabled = false;\n\n/**\r\n * Variable: virtualBendsEnabled\r\n *\r\n * Specifies if virtual bends should be added in the center of each\r\n * segments. These bends can then be used to add new waypoints.\r\n * Default is false.\r\n */\nmxEdgeHandler.prototype.virtualBendsEnabled = false;\n\n/**\r\n * Variable: virtualBendOpacity\r\n *\r\n * Opacity to be used for virtual bends (see <virtualBendsEnabled>).\r\n * Default is 20.\r\n */\nmxEdgeHandler.prototype.virtualBendOpacity = 20;\n\n/**\r\n * Variable: parentHighlightEnabled\r\n *\r\n * Specifies if the parent should be highlighted if a child cell is selected.\r\n * Default is false.\r\n */\nmxEdgeHandler.prototype.parentHighlightEnabled = false;\n\n/**\r\n * Variable: preferHtml\r\n *\r\n * Specifies if bends should be added to the graph container. This is updated\r\n * in <init> based on whether the edge or one of its terminals has an HTML\r\n * label in the container.\r\n */\nmxEdgeHandler.prototype.preferHtml = false;\n\n/**\r\n * Variable: allowHandleBoundsCheck\r\n *\r\n * Specifies if the bounds of handles should be used for hit-detection in IE\r\n * Default is true.\r\n */\nmxEdgeHandler.prototype.allowHandleBoundsCheck = true;\n\n/**\r\n * Variable: snapToTerminals\r\n *\r\n * Specifies if waypoints should snap to the routing centers of terminals.\r\n * Default is false.\r\n */\nmxEdgeHandler.prototype.snapToTerminals = false;\n\n/**\r\n * Variable: handleImage\r\n *\r\n * Optional <mxImage> to be used as handles. Default is null.\r\n */\nmxEdgeHandler.prototype.handleImage = null;\n\n/**\r\n * Variable: tolerance\r\n *\r\n * Optional tolerance for hit-detection in <getHandleForEvent>. Default is 0.\r\n */\nmxEdgeHandler.prototype.tolerance = 0;\n\n/**\r\n * Variable: outlineConnect\r\n *\r\n * Specifies if connections to the outline of a highlighted target should be\r\n * enabled. This will allow to place the connection point along the outline of\r\n * the highlighted target. Default is false.\r\n */\nmxEdgeHandler.prototype.outlineConnect = false;\n\n/**\r\n * Variable: manageLabelHandle\r\n *\r\n * Specifies if the label handle should be moved if it intersects with another\r\n * handle. Uses <checkLabelHandle> for checking and moving. Default is false.\r\n */\nmxEdgeHandler.prototype.manageLabelHandle = false;\n\n/**\r\n * Function: init\r\n *\r\n * Initializes the shapes required for this edge handler.\r\n */\nmxEdgeHandler.prototype.init = function () {\n  this.graph = this.state.view.graph;\n  this.marker = this.createMarker();\n  this.constraintHandler = new _mxConstraintHandler[\"default\"](this.graph);\n\n  // Clones the original points from the cell\n  // and makes sure at least one point exists\n  this.points = [];\n\n  // Uses the absolute points of the state\n  // for the initial configuration and preview\n  this.abspoints = this.getSelectionPoints(this.state);\n  this.shape = this.createSelectionShape(this.abspoints);\n  this.shape.dialect = this.graph.dialect != _mxConstants[\"default\"].DIALECT_SVG ? _mxConstants[\"default\"].DIALECT_MIXEDHTML : _mxConstants[\"default\"].DIALECT_SVG;\n  this.shape.init(this.graph.getView().getOverlayPane());\n  this.shape.pointerEvents = false;\n  this.shape.setCursor(_mxConstants[\"default\"].CURSOR_MOVABLE_EDGE);\n  _mxEvent[\"default\"].redirectMouseEvents(this.shape.node, this.graph, this.state);\n\n  // Updates preferHtml\n  this.preferHtml = this.state.text != null && this.state.text.node.parentNode == this.graph.container;\n  if (!this.preferHtml) {\n    // Checks source terminal\n    var sourceState = this.state.getVisibleTerminalState(true);\n    if (sourceState != null) {\n      this.preferHtml = sourceState.text != null && sourceState.text.node.parentNode == this.graph.container;\n    }\n    if (!this.preferHtml) {\n      // Checks target terminal\n      var targetState = this.state.getVisibleTerminalState(false);\n      if (targetState != null) {\n        this.preferHtml = targetState.text != null && targetState.text.node.parentNode == this.graph.container;\n      }\n    }\n  }\n\n  // Adds highlight for parent group\n  if (this.parentHighlightEnabled) {\n    var parent = this.graph.model.getParent(this.state.cell);\n    if (this.graph.model.isVertex(parent)) {\n      var pstate = this.graph.view.getState(parent);\n      if (pstate != null) {\n        this.parentHighlight = this.createParentHighlightShape(pstate);\n        // VML dialect required here for event transparency in IE\n        this.parentHighlight.dialect = this.graph.dialect != _mxConstants[\"default\"].DIALECT_SVG ? _mxConstants[\"default\"].DIALECT_VML : _mxConstants[\"default\"].DIALECT_SVG;\n        this.parentHighlight.pointerEvents = false;\n        this.parentHighlight.rotation = Number(pstate.style[_mxConstants[\"default\"].STYLE_ROTATION] || '0');\n        this.parentHighlight.init(this.graph.getView().getOverlayPane());\n      }\n    }\n  }\n\n  // Creates bends for the non-routed absolute points\n  // or bends that don't correspond to points\n  if (this.shape.style.editable !== 0 && (this.graph.getSelectionCount() < _mxGraphHandler[\"default\"].prototype.maxCells || _mxGraphHandler[\"default\"].prototype.maxCells <= 0)) {\n    this.bends = this.createBends();\n    if (this.isVirtualBendsEnabled()) {\n      this.virtualBends = this.createVirtualBends();\n    }\n  }\n\n  // Adds a rectangular handle for the label position\n  this.label = new _mxPoint[\"default\"](this.state.absoluteOffset.x, this.state.absoluteOffset.y);\n  this.labelShape = this.createLabelHandleShape();\n  this.initBend(this.labelShape);\n  this.labelShape.setCursor(_mxConstants[\"default\"].CURSOR_LABEL_HANDLE);\n  this.customHandles = this.createCustomHandles();\n  this.redraw();\n};\n\n/**\r\n * Function: createCustomHandles\r\n *\r\n * Returns an array of custom handles. This implementation returns null.\r\n */\nmxEdgeHandler.prototype.createCustomHandles = function () {\n  return null;\n};\n\n/**\r\n * Function: isVirtualBendsEnabled\r\n *\r\n * Returns true if virtual bends should be added. This returns true if\r\n * <virtualBendsEnabled> is true and the current style allows and\r\n * renders custom waypoints.\r\n */\nmxEdgeHandler.prototype.isVirtualBendsEnabled = function (evt) {\n  return this.virtualBendsEnabled && (this.state.style[_mxConstants[\"default\"].STYLE_EDGE] == null || this.state.style[_mxConstants[\"default\"].STYLE_EDGE] == _mxConstants[\"default\"].NONE || this.state.style[_mxConstants[\"default\"].STYLE_NOEDGESTYLE] == 1) && _mxGraphUtils[\"default\"].getValue(this.state.style, _mxConstants[\"default\"].STYLE_SHAPE, null) != 'arrow';\n};\n\n/**\r\n * Function: isAddPointEvent\r\n *\r\n * Returns true if the given event is a trigger to add a new point. This\r\n * implementation returns true if shift is pressed.\r\n */\nmxEdgeHandler.prototype.isAddPointEvent = function (evt) {\n  return _mxEvent[\"default\"].isShiftDown(evt);\n};\n\n/**\r\n * Function: isRemovePointEvent\r\n *\r\n * Returns true if the given event is a trigger to remove a point. This\r\n * implementation returns true if shift is pressed.\r\n */\nmxEdgeHandler.prototype.isRemovePointEvent = function (evt) {\n  return _mxEvent[\"default\"].isShiftDown(evt);\n};\n\n/**\r\n * Function: getSelectionPoints\r\n *\r\n * Returns the list of points that defines the selection stroke.\r\n */\nmxEdgeHandler.prototype.getSelectionPoints = function (state) {\n  return state.absolutePoints;\n};\n\n/**\r\n * Function: createSelectionShape\r\n *\r\n * Creates the shape used to draw the selection border.\r\n */\nmxEdgeHandler.prototype.createParentHighlightShape = function (bounds) {\n  var shape = new _mxRectangleShape[\"default\"](bounds, null, this.getSelectionColor());\n  shape.strokewidth = this.getSelectionStrokeWidth();\n  shape.isDashed = this.isSelectionDashed();\n  return shape;\n};\n\n/**\r\n * Function: createSelectionShape\r\n *\r\n * Creates the shape used to draw the selection border.\r\n */\nmxEdgeHandler.prototype.createSelectionShape = function (points) {\n  var shape = new this.state.shape.constructor();\n  shape.outline = true;\n  shape.apply(this.state);\n  shape.isDashed = this.isSelectionDashed();\n  shape.stroke = this.getSelectionColor();\n  shape.isShadow = false;\n  return shape;\n};\n\n/**\r\n * Function: getSelectionColor\r\n *\r\n * Returns <mxConstants.EDGE_SELECTION_COLOR>.\r\n */\nmxEdgeHandler.prototype.getSelectionColor = function () {\n  if ((0, _workflowUtil.isBizFlow)(this.graph.flowType)) {\n    return _mxConstants[\"default\"].BIZFLOW_EDGE_SELECTION_COLOR;\n  }\n  return _mxConstants[\"default\"].EDGE_SELECTION_COLOR;\n};\n\n/**\r\n * Function: getSelectionStrokeWidth\r\n *\r\n * Returns <mxConstants.EDGE_SELECTION_STROKEWIDTH>.\r\n */\nmxEdgeHandler.prototype.getSelectionStrokeWidth = function () {\n  if ((0, _workflowUtil.isBizFlow)(this.graph.flowType)) {\n    return _mxConstants[\"default\"].BIZFLOW_EDGE_SELECTION_STROKEWIDTH;\n  }\n  return _mxConstants[\"default\"].EDGE_SELECTION_STROKEWIDTH;\n};\n\n/**\r\n * Function: isSelectionDashed\r\n *\r\n * Returns <mxConstants.EDGE_SELECTION_DASHED>.\r\n */\nmxEdgeHandler.prototype.isSelectionDashed = function () {\n  if ((0, _workflowUtil.isBizFlow)(this.graph.flowType)) {\n    return _mxConstants[\"default\"].BIZFLOW_EDGE_SELECTION_DASHED;\n  }\n  return _mxConstants[\"default\"].EDGE_SELECTION_DASHED;\n};\n\n/**\r\n * Function: isConnectableCell\r\n *\r\n * Returns true if the given cell is connectable. This is a hook to\r\n * disable floating connections. This implementation returns true.\r\n */\nmxEdgeHandler.prototype.isConnectableCell = function (cell) {\n  return true;\n};\n\n/**\r\n * Function: getCellAt\r\n *\r\n * Creates and returns the <mxCellMarker> used in <marker>.\r\n */\nmxEdgeHandler.prototype.getCellAt = function (x, y) {\n  return !this.outlineConnect ? this.graph.getCellAt(x, y) : null;\n};\n\n/**\r\n * Function: createMarker\r\n *\r\n * Creates and returns the <mxCellMarker> used in <marker>.\r\n */\nmxEdgeHandler.prototype.createMarker = function () {\n  var marker = new _mxCellMarker[\"default\"](this.graph);\n  var self = this; // closure\n\n  // Only returns edges if they are connectable and never returns\n  // the edge that is currently being modified\n  marker.getCell = function (me) {\n    var cell = _mxCellMarker[\"default\"].prototype.getCell.apply(this, arguments);\n\n    // Checks for cell at preview point (with grid)\n    if ((cell == self.state.cell || cell == null) && self.currentPoint != null) {\n      cell = self.graph.getCellAt(self.currentPoint.x, self.currentPoint.y);\n    }\n\n    // Uses connectable parent vertex if one exists\n    if (cell != null && !this.graph.isCellConnectable(cell)) {\n      var parent = this.graph.getModel().getParent(cell);\n      if (this.graph.getModel().isVertex(parent) && this.graph.isCellConnectable(parent)) {\n        cell = parent;\n      }\n    }\n    var model = self.graph.getModel();\n    if (this.graph.isSwimlane(cell) && self.currentPoint != null && this.graph.hitsSwimlaneContent(cell, self.currentPoint.x, self.currentPoint.y) || !self.isConnectableCell(cell) || cell == self.state.cell || cell != null && !self.graph.connectableEdges && model.isEdge(cell) || model.isAncestor(self.state.cell, cell)) {\n      cell = null;\n    }\n    if (!this.graph.isCellConnectable(cell)) {\n      cell = null;\n    }\n    return cell;\n  };\n\n  // Sets the highlight color according to validateConnection\n  marker.isValidState = function (state) {\n    var model = self.graph.getModel();\n    var other = self.graph.view.getTerminalPort(state, self.graph.view.getState(model.getTerminal(self.state.cell, !self.isSource)), !self.isSource);\n    var otherCell = other != null ? other.cell : null;\n    var source = self.isSource ? state.cell : otherCell;\n    var target = self.isSource ? otherCell : state.cell;\n\n    // Updates the error message of the handler\n    self.error = self.validateConnection(source, target);\n    return self.error == null;\n  };\n  return marker;\n};\n\n/**\r\n * Function: validateConnection\r\n *\r\n * Returns the error message or an empty string if the connection for the\r\n * given source, target pair is not valid. Otherwise it returns null. This\r\n * implementation uses <mxGraph.getEdgeValidationError>.\r\n *\r\n * Parameters:\r\n *\r\n * source - <mxCell> that represents the source terminal.\r\n * target - <mxCell> that represents the target terminal.\r\n */\nmxEdgeHandler.prototype.validateConnection = function (source, target) {\n  return this.graph.getEdgeValidationError(this.state.cell, source, target);\n};\n\n/**\r\n * Function: createBends\r\n *\r\n * Creates and returns the bends used for modifying the edge. This is\r\n * typically an array of <mxRectangleShapes>.\r\n */\nmxEdgeHandler.prototype.createBends = function () {\n  var cell = this.state.cell;\n  var bends = [];\n  for (var i = 0; i < this.abspoints.length; i++) {\n    if (this.isHandleVisible(i)) {\n      var source = i == 0;\n      var target = i == this.abspoints.length - 1;\n      var terminal = source || target;\n      if (terminal || this.graph.isCellBendable(cell)) {\n        _mxGraphUtils[\"default\"].bind(this, function (index) {\n          var bend = this.createHandleShape(index);\n          this.initBend(bend, _mxGraphUtils[\"default\"].bind(this, _mxGraphUtils[\"default\"].bind(this, function () {\n            if (this.dblClickRemoveEnabled) {\n              this.removePoint(this.state, index);\n            }\n          })));\n          if (this.isHandleEnabled(i)) {\n            bend.setCursor(terminal ? _mxConstants[\"default\"].CURSOR_TERMINAL_HANDLE : _mxConstants[\"default\"].CURSOR_BEND_HANDLE);\n          }\n          bends.push(bend);\n          if (!terminal) {\n            this.points.push(new _mxPoint[\"default\"](0, 0));\n            bend.node.style.visibility = 'hidden';\n          }\n        })(i);\n      }\n    }\n  }\n  return bends;\n};\n\n/**\r\n * Function: createVirtualBends\r\n *\r\n * Creates and returns the bends used for modifying the edge. This is\r\n * typically an array of <mxRectangleShapes>.\r\n */\nmxEdgeHandler.prototype.createVirtualBends = function () {\n  var cell = this.state.cell;\n  var last = this.abspoints[0];\n  var bends = [];\n  if (this.graph.isCellBendable(cell)) {\n    for (var i = 1; i < this.abspoints.length; i++) {\n      _mxGraphUtils[\"default\"].bind(this, function (bend) {\n        this.initBend(bend);\n        bend.setCursor(_mxConstants[\"default\"].CURSOR_VIRTUAL_BEND_HANDLE);\n        bends.push(bend);\n      })(this.createHandleShape());\n    }\n  }\n  return bends;\n};\n\n/**\r\n * Function: isHandleEnabled\r\n *\r\n * Creates the shape used to display the given bend.\r\n */\nmxEdgeHandler.prototype.isHandleEnabled = function (index) {\n  return true;\n};\n\n/**\r\n * Function: isHandleVisible\r\n *\r\n * Returns true if the handle at the given index is visible.\r\n */\nmxEdgeHandler.prototype.isHandleVisible = function (index) {\n  var source = this.state.getVisibleTerminalState(true);\n  var target = this.state.getVisibleTerminalState(false);\n  var geo = this.graph.getCellGeometry(this.state.cell);\n  var edgeStyle = geo != null ? this.graph.view.getEdgeStyle(this.state, geo.points, source, target) : null;\n  return edgeStyle != _mxEdgeStyle[\"default\"].EntityRelation || index == 0 || index == this.abspoints.length - 1;\n};\n\n/**\r\n * Function: createHandleShape\r\n *\r\n * Creates the shape used to display the given bend. Note that the index may be\r\n * null for special cases, such as when called from\r\n * <mxElbowEdgeHandler.createVirtualBend>. Only images and rectangles should be\r\n * returned if support for HTML labels with not foreign objects is required.\r\n * Index if null for virtual handles.\r\n */\nmxEdgeHandler.prototype.createHandleShape = function (index) {\n  if (this.handleImage != null) {\n    var shape = new _mxImageShape[\"default\"](new _mxRectangle[\"default\"](0, 0, this.handleImage.width, this.handleImage.height), this.handleImage.src);\n\n    // Allows HTML rendering of the images\n    shape.preserveImageAspect = false;\n    return shape;\n  } else {\n    var s = _mxConstants[\"default\"].HANDLE_SIZE;\n    if (this.preferHtml) {\n      s -= 1;\n    }\n    return new _mxRectangleShape[\"default\"](new _mxRectangle[\"default\"](0, 0, s, s), _mxConstants[\"default\"].HANDLE_FILLCOLOR, _mxConstants[\"default\"].HANDLE_STROKECOLOR);\n  }\n};\n\n/**\r\n * Function: createLabelHandleShape\r\n *\r\n * Creates the shape used to display the the label handle.\r\n */\nmxEdgeHandler.prototype.createLabelHandleShape = function () {\n  if (this.labelHandleImage != null) {\n    var shape = new _mxImageShape[\"default\"](new _mxRectangle[\"default\"](0, 0, this.labelHandleImage.width, this.labelHandleImage.height), this.labelHandleImage.src);\n\n    // Allows HTML rendering of the images\n    shape.preserveImageAspect = false;\n    return shape;\n  } else {\n    var s = _mxConstants[\"default\"].LABEL_HANDLE_SIZE;\n    return new _mxRectangleShape[\"default\"](new _mxRectangle[\"default\"](0, 0, s, s), _mxConstants[\"default\"].LABEL_HANDLE_FILLCOLOR, _mxConstants[\"default\"].HANDLE_STROKECOLOR);\n  }\n};\n\n/**\r\n * Function: initBend\r\n *\r\n * Helper method to initialize the given bend.\r\n *\r\n * Parameters:\r\n *\r\n * bend - <mxShape> that represents the bend to be initialized.\r\n */\nmxEdgeHandler.prototype.initBend = function (bend, dblClick) {\n  if (this.preferHtml) {\n    bend.dialect = _mxConstants[\"default\"].DIALECT_STRICTHTML;\n    bend.init(this.graph.container);\n  } else {\n    bend.dialect = this.graph.dialect != _mxConstants[\"default\"].DIALECT_SVG ? _mxConstants[\"default\"].DIALECT_MIXEDHTML : _mxConstants[\"default\"].DIALECT_SVG;\n    bend.init(this.graph.getView().getOverlayPane());\n  }\n  _mxEvent[\"default\"].redirectMouseEvents(bend.node, this.graph, this.state, null, null, null, dblClick);\n\n  // Fixes lost event tracking for images in quirks / IE8 standards\n  if (_mxClient[\"default\"].IS_QUIRKS || document.documentMode == 8) {\n    _mxEvent[\"default\"].addListener(bend.node, 'dragstart', function (evt) {\n      _mxEvent[\"default\"].consume(evt);\n      return false;\n    });\n  }\n  if (_mxClient[\"default\"].IS_TOUCH) {\n    bend.node.setAttribute('pointer-events', 'none');\n  }\n};\n\n/**\r\n * Function: getHandleForEvent\r\n *\r\n * Returns the index of the handle for the given event.\r\n */\nmxEdgeHandler.prototype.getHandleForEvent = function (me) {\n  // Connection highlight may consume events before they reach sizer handle\n  var tol = !_mxEvent[\"default\"].isMouseEvent(me.getEvent()) ? this.tolerance : 1;\n  var hit = this.allowHandleBoundsCheck && (_mxClient[\"default\"].IS_IE || tol > 0) ? new _mxRectangle[\"default\"](me.getGraphX() - tol, me.getGraphY() - tol, 2 * tol, 2 * tol) : null;\n  var minDistSq = null;\n  var result = null;\n  function checkShape(shape) {\n    if (shape != null && shape.node.style.display != 'none' && shape.node.style.visibility != 'hidden' && (me.isSource(shape) || hit != null && _mxGraphUtils[\"default\"].intersects(shape.bounds, hit))) {\n      var dx = me.getGraphX() - shape.bounds.getCenterX();\n      var dy = me.getGraphY() - shape.bounds.getCenterY();\n      var tmp = dx * dx + dy * dy;\n      if (minDistSq == null || tmp <= minDistSq) {\n        minDistSq = tmp;\n        return true;\n      }\n    }\n    return false;\n  }\n  if (this.customHandles != null && this.isCustomHandleEvent(me)) {\n    // Inverse loop order to match display order\n    for (var i = this.customHandles.length - 1; i >= 0; i--) {\n      if (checkShape(this.customHandles[i].shape)) {\n        // LATER: Return reference to active shape\n        return _mxEvent[\"default\"].CUSTOM_HANDLE - i;\n      }\n    }\n  }\n  if (me.isSource(this.state.text) || checkShape(this.labelShape)) {\n    result = _mxEvent[\"default\"].LABEL_HANDLE;\n  }\n  if (this.bends != null) {\n    for (var i = 0; i < this.bends.length; i++) {\n      if (checkShape(this.bends[i])) {\n        result = i;\n      }\n    }\n  }\n  if (this.virtualBends != null && this.isAddVirtualBendEvent(me)) {\n    for (var i = 0; i < this.virtualBends.length; i++) {\n      if (checkShape(this.virtualBends[i])) {\n        result = _mxEvent[\"default\"].VIRTUAL_HANDLE - i;\n      }\n    }\n  }\n  return result;\n};\n\n/**\r\n * Function: isAddVirtualBendEvent\r\n *\r\n * Returns true if the given event allows virtual bends to be added. This\r\n * implementation returns true.\r\n */\nmxEdgeHandler.prototype.isAddVirtualBendEvent = function (me) {\n  return true;\n};\n\n/**\r\n * Function: isCustomHandleEvent\r\n *\r\n * Returns true if the given event allows custom handles to be changed. This\r\n * implementation returns true.\r\n */\nmxEdgeHandler.prototype.isCustomHandleEvent = function (me) {\n  return true;\n};\n\n/**\r\n * Function: mouseDown\r\n *\r\n * Handles the event by checking if a special element of the handler\r\n * was clicked, in which case the index parameter is non-null. The\r\n * indices may be one of <LABEL_HANDLE> or the number of the respective\r\n * control point. The source and target points are used for reconnecting\r\n * the edge.\r\n */\nmxEdgeHandler.prototype.mouseDown = function (sender, me) {\n  var handle = this.getHandleForEvent(me);\n  if (this.bends != null && this.bends[handle] != null) {\n    var b = this.bends[handle].bounds;\n    this.snapPoint = new _mxPoint[\"default\"](b.getCenterX(), b.getCenterY());\n  }\n  if (this.addEnabled && handle == null && this.isAddPointEvent(me.getEvent())) {\n    this.addPoint(this.state, me.getEvent());\n    me.consume();\n  } else if (handle != null && !me.isConsumed() && this.graph.isEnabled()) {\n    if (this.removeEnabled && this.isRemovePointEvent(me.getEvent())) {\n      this.removePoint(this.state, handle);\n    } else if (handle != _mxEvent[\"default\"].LABEL_HANDLE || this.graph.isLabelMovable(me.getCell())) {\n      if (handle <= _mxEvent[\"default\"].VIRTUAL_HANDLE) {\n        _mxGraphUtils[\"default\"].setOpacity(this.virtualBends[_mxEvent[\"default\"].VIRTUAL_HANDLE - handle].node, 100);\n      }\n      this.start(me.getX(), me.getY(), handle);\n    }\n    me.consume();\n  }\n};\n\n/**\r\n * Function: start\r\n *\r\n * Starts the handling of the mouse gesture.\r\n */\nmxEdgeHandler.prototype.start = function (x, y, index) {\n  this.startX = x;\n  this.startY = y;\n  this.isSource = this.bends == null ? false : index == 0;\n  this.isTarget = this.bends == null ? false : index == this.bends.length - 1;\n  this.isLabel = index == _mxEvent[\"default\"].LABEL_HANDLE;\n  if (this.isSource || this.isTarget) {\n    var cell = this.state.cell;\n    var terminal = this.graph.model.getTerminal(cell, this.isSource);\n    if (terminal == null && this.graph.isTerminalPointMovable(cell, this.isSource) || terminal != null && this.graph.isCellDisconnectable(cell, terminal, this.isSource)) {\n      this.index = index;\n    }\n  } else {\n    this.index = index;\n  }\n\n  // Hides other custom handles\n  if (this.index <= _mxEvent[\"default\"].CUSTOM_HANDLE && this.index > _mxEvent[\"default\"].VIRTUAL_HANDLE) {\n    if (this.customHandles != null) {\n      for (var i = 0; i < this.customHandles.length; i++) {\n        if (i != _mxEvent[\"default\"].CUSTOM_HANDLE - this.index) {\n          this.customHandles[i].setVisible(false);\n        }\n      }\n    }\n  }\n};\n\n/**\r\n * Function: clonePreviewState\r\n *\r\n * Returns a clone of the current preview state for the given point and terminal.\r\n */\nmxEdgeHandler.prototype.clonePreviewState = function (point, terminal) {\n  return this.state.clone();\n};\n\n/**\r\n * Function: getSnapToTerminalTolerance\r\n *\r\n * Returns the tolerance for the guides. Default value is\r\n * gridSize * scale / 2.\r\n */\nmxEdgeHandler.prototype.getSnapToTerminalTolerance = function () {\n  return this.graph.gridSize * this.graph.view.scale / 2;\n};\n\n/**\r\n * Function: updateHint\r\n *\r\n * Hook for subclassers do show details while the handler is active.\r\n */\nmxEdgeHandler.prototype.updateHint = function (me, point) {};\n\n/**\r\n * Function: removeHint\r\n *\r\n * Hooks for subclassers to hide details when the handler gets inactive.\r\n */\nmxEdgeHandler.prototype.removeHint = function () {};\n\n/**\r\n * Function: roundLength\r\n *\r\n * Hook for rounding the unscaled width or height. This uses Math.round.\r\n */\nmxEdgeHandler.prototype.roundLength = function (length) {\n  return Math.round(length);\n};\n\n/**\r\n * Function: isSnapToTerminalsEvent\r\n *\r\n * Returns true if <snapToTerminals> is true and if alt is not pressed.\r\n */\nmxEdgeHandler.prototype.isSnapToTerminalsEvent = function (me) {\n  return this.snapToTerminals && !_mxEvent[\"default\"].isAltDown(me.getEvent());\n};\n\n/**\r\n * Function: getPointForEvent\r\n *\r\n * Returns the point for the given event.\r\n */\nmxEdgeHandler.prototype.getPointForEvent = function (me) {\n  var view = this.graph.getView();\n  var scale = view.scale;\n  var point = new _mxPoint[\"default\"](this.roundLength(me.getGraphX() / scale) * scale, this.roundLength(me.getGraphY() / scale) * scale);\n  var tt = this.getSnapToTerminalTolerance();\n  var overrideX = false;\n  var overrideY = false;\n  if (tt > 0 && this.isSnapToTerminalsEvent(me)) {\n    var snapToPoint = function snapToPoint(pt) {\n      if (pt != null) {\n        var x = pt.x;\n        if (Math.abs(point.x - x) < tt) {\n          point.x = x;\n          overrideX = true;\n        }\n        var y = pt.y;\n        if (Math.abs(point.y - y) < tt) {\n          point.y = y;\n          overrideY = true;\n        }\n      }\n    }; // Temporary function\n    var snapToTerminal = function snapToTerminal(terminal) {\n      if (terminal != null) {\n        snapToPoint.call(this, new _mxPoint[\"default\"](view.getRoutingCenterX(terminal), view.getRoutingCenterY(terminal)));\n      }\n    };\n    ;\n    snapToTerminal.call(this, this.state.getVisibleTerminalState(true));\n    snapToTerminal.call(this, this.state.getVisibleTerminalState(false));\n    if (this.state.absolutePoints != null) {\n      for (var i = 0; i < this.state.absolutePoints.length; i++) {\n        snapToPoint.call(this, this.state.absolutePoints[i]);\n      }\n    }\n  }\n  if (this.graph.isGridEnabledEvent(me.getEvent())) {\n    var tr = view.translate;\n    if (!overrideX) {\n      point.x = (this.graph.snap(point.x / scale - tr.x) + tr.x) * scale;\n    }\n    if (!overrideY) {\n      point.y = (this.graph.snap(point.y / scale - tr.y) + tr.y) * scale;\n    }\n  }\n  return point;\n};\n\n/**\r\n * Function: getPreviewTerminalState\r\n *\r\n * Updates the given preview state taking into account the state of the constraint handler.\r\n */\nmxEdgeHandler.prototype.getPreviewTerminalState = function (me) {\n  this.constraintHandler.update(me, this.isSource, true, me.isSource(this.marker.highlight.shape) ? null : this.currentPoint);\n  if (this.constraintHandler.currentFocus != null && this.constraintHandler.currentConstraint != null) {\n    // Handles special case where grid is large and connection point is at actual point in which\n    // case the outline is not followed as long as we're < gridSize / 2 away from that point\n    if (this.marker.highlight != null && this.marker.highlight.state != null && this.marker.highlight.state.cell == this.constraintHandler.currentFocus.cell) {\n      // Direct repaint needed if cell already highlighted\n      if (this.marker.highlight.shape.stroke != 'transparent') {\n        this.marker.highlight.shape.stroke = 'transparent';\n        this.marker.highlight.repaint();\n      }\n    } else {\n      this.marker.markCell(this.constraintHandler.currentFocus.cell, 'transparent');\n    }\n    var model = this.graph.getModel();\n    var other = this.graph.view.getTerminalPort(this.state, this.graph.view.getState(model.getTerminal(this.state.cell, !this.isSource)), !this.isSource);\n    var otherCell = other != null ? other.cell : null;\n    var source = this.isSource ? this.constraintHandler.currentFocus.cell : otherCell;\n    var target = this.isSource ? otherCell : this.constraintHandler.currentFocus.cell;\n\n    // Updates the error message of the handler\n    this.error = this.validateConnection(source, target);\n    var result = null;\n    if (this.error == null) {\n      result = this.constraintHandler.currentFocus;\n    } else {\n      this.constraintHandler.reset();\n    }\n    return result;\n  } else if (!this.graph.isIgnoreTerminalEvent(me.getEvent())) {\n    this.marker.process(me);\n    return this.marker.getValidState();\n  } else {\n    this.marker.reset();\n    return null;\n  }\n};\n\n/**\r\n * Function: getPreviewPoints\r\n *\r\n * Updates the given preview state taking into account the state of the constraint handler.\r\n *\r\n * Parameters:\r\n *\r\n * pt - <mxPoint> that contains the current pointer position.\r\n * me - Optional <mxMouseEvent> that contains the current event.\r\n */\nmxEdgeHandler.prototype.getPreviewPoints = function (pt, me) {\n  var geometry = this.graph.getCellGeometry(this.state.cell);\n  var points = geometry.points != null ? geometry.points.slice() : null;\n  var point = new _mxPoint[\"default\"](pt.x, pt.y);\n  var result = null;\n  if (!this.isSource && !this.isTarget) {\n    this.convertPoint(point, false);\n    if (points == null) {\n      points = [point];\n    } else {\n      // Adds point from virtual bend\n      if (this.index <= _mxEvent[\"default\"].VIRTUAL_HANDLE) {\n        points.splice(_mxEvent[\"default\"].VIRTUAL_HANDLE - this.index, 0, point);\n      }\n\n      // Removes point if dragged on terminal point\n      if (!this.isSource && !this.isTarget) {\n        for (var i = 0; i < this.bends.length; i++) {\n          if (i != this.index) {\n            var bend = this.bends[i];\n            if (bend != null && _mxGraphUtils[\"default\"].contains(bend.bounds, pt.x, pt.y)) {\n              if (this.index <= _mxEvent[\"default\"].VIRTUAL_HANDLE) {\n                points.splice(_mxEvent[\"default\"].VIRTUAL_HANDLE - this.index, 1);\n              } else {\n                points.splice(this.index - 1, 1);\n              }\n              result = points;\n            }\n          }\n        }\n\n        // Removes point if user tries to straighten a segment\n        if (result == null && this.straightRemoveEnabled && (me == null || !_mxEvent[\"default\"].isAltDown(me.getEvent()))) {\n          var checkRemove = function checkRemove(idx, tmp) {\n            if (idx > 0 && idx < abs.length - 1 && _mxGraphUtils[\"default\"].ptSegDistSq(abs[idx - 1].x, abs[idx - 1].y, abs[idx + 1].x, abs[idx + 1].y, tmp.x, tmp.y) < tol) {\n              points.splice(idx - 1, 1);\n              result = points;\n            }\n          };\n          var tol = this.graph.tolerance * this.graph.tolerance;\n          var abs = this.state.absolutePoints.slice();\n          abs[this.index] = pt;\n\n          // Handes special case where removing waypoint affects tolerance (flickering)\n          var src = this.state.getVisibleTerminalState(true);\n          if (src != null) {\n            var c = this.graph.getConnectionConstraint(this.state, src, true);\n\n            // Checks if point is not fixed\n            if (c == null || this.graph.getConnectionPoint(src, c) == null) {\n              abs[0] = new _mxPoint[\"default\"](src.view.getRoutingCenterX(src), src.view.getRoutingCenterY(src));\n            }\n          }\n          var trg = this.state.getVisibleTerminalState(false);\n          if (trg != null) {\n            var c = this.graph.getConnectionConstraint(this.state, trg, false);\n\n            // Checks if point is not fixed\n            if (c == null || this.graph.getConnectionPoint(trg, c) == null) {\n              abs[abs.length - 1] = new _mxPoint[\"default\"](trg.view.getRoutingCenterX(trg), trg.view.getRoutingCenterY(trg));\n            }\n          }\n          ;\n\n          // LATER: Check if other points can be removed if a segment is made straight\n          checkRemove(this.index, pt);\n        }\n      }\n\n      // Updates existing point\n      if (result == null && this.index > _mxEvent[\"default\"].VIRTUAL_HANDLE) {\n        points[this.index - 1] = point;\n      }\n    }\n  } else if (this.graph.resetEdgesOnConnect) {\n    points = null;\n  }\n  return result != null ? result : points;\n};\n\n/**\r\n * Function: isOutlineConnectEvent\r\n *\r\n * Returns true if <outlineConnect> is true and the source of the event is the outline shape\r\n * or shift is pressed.\r\n */\nmxEdgeHandler.prototype.isOutlineConnectEvent = function (me) {\n  var offset = _mxGraphUtils[\"default\"].getOffset(this.graph.container, null, _mxPoint[\"default\"]);\n  var evt = me.getEvent();\n  var clientX = _mxEvent[\"default\"].getClientX(evt);\n  var clientY = _mxEvent[\"default\"].getClientY(evt);\n  var doc = document.documentElement;\n  var left = (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);\n  var top = (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);\n  var gridX = this.currentPoint.x - this.graph.container.scrollLeft + offset.x - left;\n  var gridY = this.currentPoint.y - this.graph.container.scrollTop + offset.y - top;\n  return this.outlineConnect && !_mxEvent[\"default\"].isShiftDown(me.getEvent()) && (me.isSource(this.marker.highlight.shape) || _mxEvent[\"default\"].isAltDown(me.getEvent()) && me.getState() != null || this.marker.highlight.isHighlightAt(clientX, clientY) || (gridX != clientX || gridY != clientY) && me.getState() == null && this.marker.highlight.isHighlightAt(gridX, gridY));\n};\n\n/**\r\n * Function: updatePreviewState\r\n *\r\n * Updates the given preview state taking into account the state of the constraint handler.\r\n */\nmxEdgeHandler.prototype.updatePreviewState = function (edge, point, terminalState, me, outline) {\n  // Computes the points for the edge style and terminals\n  var sourceState = this.isSource ? terminalState : this.state.getVisibleTerminalState(true);\n  var targetState = this.isTarget ? terminalState : this.state.getVisibleTerminalState(false);\n  var sourceConstraint = this.graph.getConnectionConstraint(edge, sourceState, true);\n  var targetConstraint = this.graph.getConnectionConstraint(edge, targetState, false);\n  var constraint = this.constraintHandler.currentConstraint;\n  if (constraint == null && outline) {\n    if (terminalState != null) {\n      // Handles special case where mouse is on outline away from actual end point\n      // in which case the grid is ignored and mouse point is used instead\n      if (me.isSource(this.marker.highlight.shape)) {\n        point = new _mxPoint[\"default\"](me.getGraphX(), me.getGraphY());\n      }\n      constraint = this.graph.getOutlineConstraint(point, terminalState, me);\n      this.constraintHandler.setFocus(me, terminalState, this.isSource);\n      this.constraintHandler.currentConstraint = constraint;\n      this.constraintHandler.currentPoint = point;\n    } else {\n      constraint = new _mxConnectionConstraint[\"default\"]();\n    }\n  }\n  if (this.outlineConnect && this.marker.highlight != null && this.marker.highlight.shape != null) {\n    var s = this.graph.view.scale;\n    if (this.constraintHandler.currentConstraint != null && this.constraintHandler.currentFocus != null) {\n      this.marker.highlight.shape.stroke = outline ? _mxConstants[\"default\"].OUTLINE_HIGHLIGHT_COLOR : 'transparent';\n      this.marker.highlight.shape.strokewidth = _mxConstants[\"default\"].OUTLINE_HIGHLIGHT_STROKEWIDTH / s / s;\n      this.marker.highlight.repaint();\n    } else if (this.marker.hasValidState()) {\n      this.marker.highlight.shape.stroke = this.marker.getValidState() == me.getState() ? _mxConstants[\"default\"].DEFAULT_VALID_COLOR : 'transparent';\n      this.marker.highlight.shape.strokewidth = _mxConstants[\"default\"].HIGHLIGHT_STROKEWIDTH / s / s;\n      this.marker.highlight.repaint();\n    }\n  }\n  if (this.isSource) {\n    sourceConstraint = constraint;\n  } else if (this.isTarget) {\n    targetConstraint = constraint;\n  }\n  if (this.isSource || this.isTarget) {\n    if (constraint != null && constraint.point != null) {\n      edge.style[this.isSource ? _mxConstants[\"default\"].STYLE_EXIT_X : _mxConstants[\"default\"].STYLE_ENTRY_X] = constraint.point.x;\n      edge.style[this.isSource ? _mxConstants[\"default\"].STYLE_EXIT_Y : _mxConstants[\"default\"].STYLE_ENTRY_Y] = constraint.point.y;\n    } else {\n      delete edge.style[this.isSource ? _mxConstants[\"default\"].STYLE_EXIT_X : _mxConstants[\"default\"].STYLE_ENTRY_X];\n      delete edge.style[this.isSource ? _mxConstants[\"default\"].STYLE_EXIT_Y : _mxConstants[\"default\"].STYLE_ENTRY_Y];\n    }\n  }\n  edge.setVisibleTerminalState(sourceState, true);\n  edge.setVisibleTerminalState(targetState, false);\n  if (!this.isSource || sourceState != null) {\n    edge.view.updateFixedTerminalPoint(edge, sourceState, true, sourceConstraint);\n  }\n  if (!this.isTarget || targetState != null) {\n    edge.view.updateFixedTerminalPoint(edge, targetState, false, targetConstraint);\n  }\n  if ((this.isSource || this.isTarget) && terminalState == null) {\n    edge.setAbsoluteTerminalPoint(point, this.isSource);\n    if (this.marker.getMarkedState() == null) {\n      this.error = this.graph.allowDanglingEdges ? null : '';\n    }\n  }\n  edge.view.updatePoints(edge, this.points, sourceState, targetState);\n  edge.view.updateFloatingTerminalPoints(edge, sourceState, targetState);\n};\n\n/**\r\n * Function: mouseMove\r\n *\r\n * Handles the event by updating the preview.\r\n */\nmxEdgeHandler.prototype.mouseMove = function (sender, me) {\n  if (this.index != null && this.marker != null) {\n    this.currentPoint = this.getPointForEvent(me);\n    this.error = null;\n\n    // Uses the current point from the constraint handler if available\n    if (!this.graph.isIgnoreTerminalEvent(me.getEvent()) && _mxEvent[\"default\"].isShiftDown(me.getEvent()) && this.snapPoint != null) {\n      if (Math.abs(this.snapPoint.x - this.currentPoint.x) < Math.abs(this.snapPoint.y - this.currentPoint.y)) {\n        this.currentPoint.x = this.snapPoint.x;\n      } else {\n        this.currentPoint.y = this.snapPoint.y;\n      }\n    }\n    if (this.index <= _mxEvent[\"default\"].CUSTOM_HANDLE && this.index > _mxEvent[\"default\"].VIRTUAL_HANDLE) {\n      if (this.customHandles != null) {\n        this.customHandles[_mxEvent[\"default\"].CUSTOM_HANDLE - this.index].processEvent(me);\n      }\n    } else if (this.isLabel) {\n      this.label.x = this.currentPoint.x;\n      this.label.y = this.currentPoint.y;\n    } else {\n      this.points = this.getPreviewPoints(this.currentPoint, me);\n      var terminalState = this.isSource || this.isTarget ? this.getPreviewTerminalState(me) : null;\n      if (this.constraintHandler.currentConstraint != null && this.constraintHandler.currentFocus != null && this.constraintHandler.currentPoint != null) {\n        this.currentPoint = this.constraintHandler.currentPoint.clone();\n      } else if (this.outlineConnect) {\n        // Need to check outline before cloning terminal state\n        var outline = this.isSource || this.isTarget ? this.isOutlineConnectEvent(me) : false;\n        if (outline) {\n          terminalState = this.marker.highlight.state;\n        } else if (terminalState != null && terminalState != me.getState() && this.marker.highlight.shape != null) {\n          this.marker.highlight.shape.stroke = 'transparent';\n          this.marker.highlight.repaint();\n          terminalState = null;\n        }\n      }\n      var clone = this.clonePreviewState(this.currentPoint, terminalState != null ? terminalState.cell : null);\n      this.updatePreviewState(clone, this.currentPoint, terminalState, me, outline);\n\n      // Sets the color of the preview to valid or invalid, updates the\n      // points of the preview and redraws\n      var color = this.error == null ? this.marker.validColor : this.marker.invalidColor;\n      this.setPreviewColor(color);\n      this.abspoints = clone.absolutePoints;\n      this.active = true;\n    }\n\n    // This should go before calling isOutlineConnectEvent above. As a workaround\n    // we add an offset of gridSize to the hint to avoid problem with hit detection\n    // in highlight.isHighlightAt (which uses comonentFromPoint)\n    this.updateHint(me, this.currentPoint);\n    this.drawPreview();\n    _mxEvent[\"default\"].consume(me.getEvent());\n    me.consume();\n  }\n  // Workaround for disabling the connect highlight when over handle\n  else if (_mxClient[\"default\"].IS_IE && this.getHandleForEvent(me) != null) {\n    me.consume(false);\n  }\n};\n\n/**\r\n * Function: mouseUp\r\n *\r\n * Handles the event to applying the previewed changes on the edge by\r\n * using <moveLabel>, <connect> or <changePoints>.\r\n */\nmxEdgeHandler.prototype.mouseUp = function (sender, me) {\n  // Workaround for wrong event source in Webkit\n  if (this.index != null && this.marker != null) {\n    var edge = this.state.cell;\n\n    // Ignores event if mouse has not been moved\n    if (me.getX() != this.startX || me.getY() != this.startY) {\n      var clone = !this.graph.isIgnoreTerminalEvent(me.getEvent()) && this.graph.isCloneEvent(me.getEvent()) && this.cloneEnabled && this.graph.isCellsCloneable();\n\n      // Displays the reason for not carriying out the change\n      // if there is an error message with non-zero length\n      if (this.error != null) {\n        if (this.error.length > 0) {\n          this.graph.validationAlert(this.error);\n        }\n      } else if (this.index <= _mxEvent[\"default\"].CUSTOM_HANDLE && this.index > _mxEvent[\"default\"].VIRTUAL_HANDLE) {\n        if (this.customHandles != null) {\n          var model = this.graph.getModel();\n          model.beginUpdate();\n          try {\n            this.customHandles[_mxEvent[\"default\"].CUSTOM_HANDLE - this.index].execute();\n          } finally {\n            model.endUpdate();\n          }\n        }\n      } else if (this.isLabel) {\n        this.moveLabel(this.state, this.label.x, this.label.y);\n      } else if (this.isSource || this.isTarget) {\n        var terminal = null;\n        if (this.constraintHandler.currentConstraint != null && this.constraintHandler.currentFocus != null) {\n          terminal = this.constraintHandler.currentFocus.cell;\n        }\n        if (terminal == null && this.marker.hasValidState() && this.marker.highlight != null && this.marker.highlight.shape != null && this.marker.highlight.shape.stroke != 'transparent' && this.marker.highlight.shape.stroke != 'white') {\n          terminal = this.marker.validState.cell;\n        }\n        if (terminal != null) {\n          edge = this.connect(edge, terminal, this.isSource, clone, me);\n        } else if (this.graph.isAllowDanglingEdges()) {\n          var pt = this.abspoints[this.isSource ? 0 : this.abspoints.length - 1];\n          pt.x = this.roundLength(pt.x / this.graph.view.scale - this.graph.view.translate.x);\n          pt.y = this.roundLength(pt.y / this.graph.view.scale - this.graph.view.translate.y);\n          var pstate = this.graph.getView().getState(this.graph.getModel().getParent(edge));\n          if (pstate != null) {\n            pt.x -= pstate.origin.x;\n            pt.y -= pstate.origin.y;\n          }\n          pt.x -= this.graph.panDx / this.graph.view.scale;\n          pt.y -= this.graph.panDy / this.graph.view.scale;\n\n          // Destroys and recreates this handler\n          edge = this.changeTerminalPoint(edge, pt, this.isSource, clone);\n        }\n      } else if (this.active) {\n        edge = this.changePoints(edge, this.points, clone);\n      } else {\n        this.graph.getView().invalidate(this.state.cell);\n        this.graph.getView().validate(this.state.cell);\n      }\n    }\n\n    // Resets the preview color the state of the handler if this\n    // handler has not been recreated\n    if (this.marker != null) {\n      this.reset();\n\n      // Updates the selection if the edge has been cloned\n      if (edge != this.state.cell) {\n        this.graph.setSelectionCell(edge);\n      }\n    }\n    me.consume();\n  }\n};\n\n/**\r\n * Function: reset\r\n *\r\n * Resets the state of this handler.\r\n */\nmxEdgeHandler.prototype.reset = function () {\n  this.error = null;\n  this.index = null;\n  this.label = null;\n  this.points = null;\n  this.snapPoint = null;\n  this.active = false;\n  this.isLabel = false;\n  this.isSource = false;\n  this.isTarget = false;\n  if (this.livePreview && this.sizers != null) {\n    for (var i = 0; i < this.sizers.length; i++) {\n      if (this.sizers[i] != null) {\n        this.sizers[i].node.style.display = '';\n      }\n    }\n  }\n  if (this.marker != null) {\n    this.marker.reset();\n  }\n  if (this.constraintHandler != null) {\n    this.constraintHandler.reset();\n  }\n  if (this.customHandles != null) {\n    for (var i = 0; i < this.customHandles.length; i++) {\n      this.customHandles[i].reset();\n    }\n  }\n  this.setPreviewColor(_mxConstants[\"default\"].EDGE_SELECTION_COLOR);\n  this.removeHint();\n  this.redraw();\n};\n\n/**\r\n * Function: setPreviewColor\r\n *\r\n * Sets the color of the preview to the given value.\r\n */\nmxEdgeHandler.prototype.setPreviewColor = function (color) {\n  if (this.shape != null) {\n    this.shape.stroke = color;\n  }\n};\n\n/**\r\n * Function: convertPoint\r\n *\r\n * Converts the given point in-place from screen to unscaled, untranslated\r\n * graph coordinates and applies the grid. Returns the given, modified\r\n * point instance.\r\n *\r\n * Parameters:\r\n *\r\n * point - <mxPoint> to be converted.\r\n * gridEnabled - Boolean that specifies if the grid should be applied.\r\n */\nmxEdgeHandler.prototype.convertPoint = function (point, gridEnabled) {\n  var scale = this.graph.getView().getScale();\n  var tr = this.graph.getView().getTranslate();\n  if (gridEnabled) {\n    point.x = this.graph.snap(point.x);\n    point.y = this.graph.snap(point.y);\n  }\n  point.x = Math.round(point.x / scale - tr.x);\n  point.y = Math.round(point.y / scale - tr.y);\n  var pstate = this.graph.getView().getState(this.graph.getModel().getParent(this.state.cell));\n  if (pstate != null) {\n    point.x -= pstate.origin.x;\n    point.y -= pstate.origin.y;\n  }\n  return point;\n};\n\n/**\r\n * Function: moveLabel\r\n *\r\n * Changes the coordinates for the label of the given edge.\r\n *\r\n * Parameters:\r\n *\r\n * edge - <mxCell> that represents the edge.\r\n * x - Integer that specifies the x-coordinate of the new location.\r\n * y - Integer that specifies the y-coordinate of the new location.\r\n */\nmxEdgeHandler.prototype.moveLabel = function (edgeState, x, y) {\n  var model = this.graph.getModel();\n  var geometry = model.getGeometry(edgeState.cell);\n  if (geometry != null) {\n    var scale = this.graph.getView().scale;\n    geometry = geometry.clone();\n    if (geometry.relative) {\n      // Resets the relative location stored inside the geometry\n      var pt = this.graph.getView().getRelativePoint(edgeState, x, y);\n      geometry.x = Math.round(pt.x * 10000) / 10000;\n      geometry.y = Math.round(pt.y);\n\n      // Resets the offset inside the geometry to find the offset\n      // from the resulting point\n      geometry.offset = new _mxPoint[\"default\"](0, 0);\n      var pt = this.graph.view.getPoint(edgeState, geometry);\n      geometry.offset = new _mxPoint[\"default\"](Math.round((x - pt.x) / scale), Math.round((y - pt.y) / scale));\n    } else {\n      var points = edgeState.absolutePoints;\n      var p0 = points[0];\n      var pe = points[points.length - 1];\n      if (p0 != null && pe != null) {\n        var cx = p0.x + (pe.x - p0.x) / 2;\n        var cy = p0.y + (pe.y - p0.y) / 2;\n        geometry.offset = new _mxPoint[\"default\"](Math.round((x - cx) / scale), Math.round((y - cy) / scale));\n        geometry.x = 0;\n        geometry.y = 0;\n      }\n    }\n    model.setGeometry(edgeState.cell, geometry);\n  }\n};\n\n/**\r\n * Function: connect\r\n *\r\n * Changes the terminal or terminal point of the given edge in the graph\r\n * model.\r\n *\r\n * Parameters:\r\n *\r\n * edge - <mxCell> that represents the edge to be reconnected.\r\n * terminal - <mxCell> that represents the new terminal.\r\n * isSource - Boolean indicating if the new terminal is the source or\r\n * target terminal.\r\n * isClone - Boolean indicating if the new connection should be a clone of\r\n * the old edge.\r\n * me - <mxMouseEvent> that contains the mouse up event.\r\n */\nmxEdgeHandler.prototype.connect = function (edge, terminal, isSource, isClone, me) {\n  var model = this.graph.getModel();\n  var parent = model.getParent(edge);\n  model.beginUpdate();\n  try {\n    // Clones and adds the cell\n    if (isClone) {\n      var clone = this.graph.cloneCells([edge])[0];\n      model.add(parent, clone, model.getChildCount(parent));\n      var other = model.getTerminal(edge, !isSource);\n      this.graph.connectCell(clone, other, !isSource);\n      edge = clone;\n    }\n    var constraint = this.constraintHandler.currentConstraint;\n    if (constraint == null) {\n      constraint = new _mxConnectionConstraint[\"default\"]();\n    }\n    this.graph.connectCell(edge, terminal, isSource, constraint);\n  } finally {\n    model.endUpdate();\n  }\n  return edge;\n};\n\n/**\r\n * Function: changeTerminalPoint\r\n *\r\n * Changes the terminal point of the given edge.\r\n */\nmxEdgeHandler.prototype.changeTerminalPoint = function (edge, point, isSource, clone) {\n  var model = this.graph.getModel();\n  model.beginUpdate();\n  try {\n    if (clone) {\n      var parent = model.getParent(edge);\n      var terminal = model.getTerminal(edge, !isSource);\n      edge = this.graph.cloneCells([edge])[0];\n      model.add(parent, edge, model.getChildCount(parent));\n      model.setTerminal(edge, terminal, !isSource);\n    }\n    var geo = model.getGeometry(edge);\n    if (geo != null) {\n      geo = geo.clone();\n      geo.setTerminalPoint(point, isSource);\n      model.setGeometry(edge, geo);\n      this.graph.connectCell(edge, null, isSource, new _mxConnectionConstraint[\"default\"]());\n    }\n  } finally {\n    model.endUpdate();\n  }\n  return edge;\n};\n\n/**\r\n * Function: changePoints\r\n *\r\n * Changes the control points of the given edge in the graph model.\r\n */\nmxEdgeHandler.prototype.changePoints = function (edge, points, clone) {\n  var model = this.graph.getModel();\n  model.beginUpdate();\n  try {\n    if (clone) {\n      var parent = model.getParent(edge);\n      var source = model.getTerminal(edge, true);\n      var target = model.getTerminal(edge, false);\n      edge = this.graph.cloneCells([edge])[0];\n      model.add(parent, edge, model.getChildCount(parent));\n      model.setTerminal(edge, source, true);\n      model.setTerminal(edge, target, false);\n    }\n    var geo = model.getGeometry(edge);\n    if (geo != null) {\n      geo = geo.clone();\n      geo.points = points;\n      model.setGeometry(edge, geo);\n    }\n  } finally {\n    model.endUpdate();\n  }\n  return edge;\n};\n\n/**\r\n * Function: addPoint\r\n *\r\n * Adds a control point for the given state and event.\r\n */\nmxEdgeHandler.prototype.addPoint = function (state, evt) {\n  var pt = _mxGraphUtils[\"default\"].convertPoint(this.graph.container, _mxEvent[\"default\"].getClientX(evt), _mxEvent[\"default\"].getClientY(evt));\n  var gridEnabled = this.graph.isGridEnabledEvent(evt);\n  this.convertPoint(pt, gridEnabled);\n  this.addPointAt(state, pt.x, pt.y);\n  _mxEvent[\"default\"].consume(evt);\n};\n\n/**\r\n * Function: addPointAt\r\n *\r\n * Adds a control point at the given point.\r\n */\nmxEdgeHandler.prototype.addPointAt = function (state, x, y) {\n  var geo = this.graph.getCellGeometry(state.cell);\n  var pt = new _mxPoint[\"default\"](x, y);\n  if (geo != null) {\n    geo = geo.clone();\n    var t = this.graph.view.translate;\n    var s = this.graph.view.scale;\n    var offset = new _mxPoint[\"default\"](t.x * s, t.y * s);\n    var parent = this.graph.model.getParent(this.state.cell);\n    if (this.graph.model.isVertex(parent)) {\n      var pState = this.graph.view.getState(parent);\n      offset = new _mxPoint[\"default\"](pState.x, pState.y);\n    }\n    var index = _mxGraphUtils[\"default\"].findNearestSegment(state, pt.x * s + offset.x, pt.y * s + offset.y);\n    if (geo.points == null) {\n      geo.points = [pt];\n    } else {\n      geo.points.splice(index, 0, pt);\n    }\n    this.graph.getModel().setGeometry(state.cell, geo);\n    this.refresh();\n    this.redraw();\n  }\n};\n\n/**\r\n * Function: removePoint\r\n *\r\n * Removes the control point at the given index from the given state.\r\n */\nmxEdgeHandler.prototype.removePoint = function (state, index) {\n  if (index > 0 && index < this.abspoints.length - 1) {\n    var geo = this.graph.getCellGeometry(this.state.cell);\n    if (geo != null && geo.points != null) {\n      geo = geo.clone();\n      geo.points.splice(index - 1, 1);\n      this.graph.getModel().setGeometry(state.cell, geo);\n      this.refresh();\n      this.redraw();\n    }\n  }\n};\n\n/**\r\n * Function: getHandleFillColor\r\n *\r\n * Returns the fillcolor for the handle at the given index.\r\n */\nmxEdgeHandler.prototype.getHandleFillColor = function (index) {\n  var isSource = index == 0;\n  var cell = this.state.cell;\n  var terminal = this.graph.getModel().getTerminal(cell, isSource);\n  var color = _mxConstants[\"default\"].HANDLE_FILLCOLOR;\n  if (terminal != null && !this.graph.isCellDisconnectable(cell, terminal, isSource) || terminal == null && !this.graph.isTerminalPointMovable(cell, isSource)) {\n    color = _mxConstants[\"default\"].LOCKED_HANDLE_FILLCOLOR;\n  } else if (terminal != null && this.graph.isCellDisconnectable(cell, terminal, isSource)) {\n    color = _mxConstants[\"default\"].CONNECT_HANDLE_FILLCOLOR;\n  }\n  return color;\n};\n\n/**\r\n * Function: redraw\r\n *\r\n * Redraws the preview, and the bends- and label control points.\r\n */\nmxEdgeHandler.prototype.redraw = function () {\n  this.abspoints = this.state.absolutePoints.slice();\n  this.redrawHandles();\n  var g = this.graph.getModel().getGeometry(this.state.cell);\n  var pts = g.points;\n  if (this.bends != null && this.bends.length > 0) {\n    if (pts != null) {\n      if (this.points == null) {\n        this.points = [];\n      }\n      for (var i = 1; i < this.bends.length - 1; i++) {\n        if (this.bends[i] != null && this.abspoints[i] != null) {\n          this.points[i - 1] = pts[i - 1];\n        }\n      }\n    }\n  }\n  this.drawPreview();\n};\n\n/**\r\n * Function: redrawHandles\r\n *\r\n * Redraws the handles.\r\n */\nmxEdgeHandler.prototype.redrawHandles = function () {\n  var cell = this.state.cell;\n  var bindToPrevNode = cell.getProperty(\"controlIntensity\", \"bindToPrevNode\");\n  var bindToNextNode = cell.getProperty(\"controlIntensity\", \"bindToNextNode\");\n\n  // Updates the handle for the label position\n  var b = this.labelShape.bounds;\n  this.label = new _mxPoint[\"default\"](this.state.absoluteOffset.x, this.state.absoluteOffset.y);\n  this.labelShape.bounds = new _mxRectangle[\"default\"](Math.round(this.label.x - b.width / 2), Math.round(this.label.y - b.height / 2), b.width, b.height);\n\n  // Shows or hides the label handle depending on the label\n  var lab = this.graph.getLabel(cell);\n  this.labelShape.visible = lab != null && lab.length > 0 && this.graph.isLabelMovable(cell);\n  if (this.bends != null && this.bends.length > 0) {\n    var n = this.abspoints.length - 1;\n    var p0 = this.abspoints[0];\n    var x0 = p0.x;\n    var y0 = p0.y;\n    b = this.bends[0].bounds;\n    this.bends[0].bounds = new _mxRectangle[\"default\"](Math.floor(x0 - b.width / 2), Math.floor(y0 - b.height / 2), b.width, b.height);\n    this.bends[0].fill = this.getHandleFillColor(0);\n    this.bends[0].visible = bindToPrevNode !== true && bindToPrevNode !== \"1\";\n    this.bends[0].redraw();\n    if (this.manageLabelHandle) {\n      this.checkLabelHandle(this.bends[0].bounds);\n    }\n    var pe = this.abspoints[n];\n    var xn = pe.x;\n    var yn = pe.y;\n    var bn = this.bends.length - 1;\n    b = this.bends[bn].bounds;\n    this.bends[bn].bounds = new _mxRectangle[\"default\"](Math.floor(xn - b.width / 2), Math.floor(yn - b.height / 2), b.width, b.height);\n    this.bends[bn].fill = this.getHandleFillColor(bn);\n    this.bends[bn].visible = bindToNextNode !== true && bindToNextNode !== \"1\";\n    this.bends[bn].redraw();\n    if (this.manageLabelHandle) {\n      this.checkLabelHandle(this.bends[bn].bounds);\n    }\n    this.redrawInnerBends(p0, pe);\n  }\n  if (this.abspoints != null && this.virtualBends != null && this.virtualBends.length > 0) {\n    var last = this.abspoints[0];\n    for (var i = 0; i < this.virtualBends.length; i++) {\n      if (this.virtualBends[i] != null && this.abspoints[i + 1] != null) {\n        var pt = this.abspoints[i + 1];\n        var b = this.virtualBends[i];\n        var x = last.x + (pt.x - last.x) / 2;\n        var y = last.y + (pt.y - last.y) / 2;\n        b.bounds = new _mxRectangle[\"default\"](Math.floor(x - b.bounds.width / 2), Math.floor(y - b.bounds.height / 2), b.bounds.width, b.bounds.height);\n        b.redraw();\n        _mxGraphUtils[\"default\"].setOpacity(b.node, this.virtualBendOpacity);\n        last = pt;\n        if (this.manageLabelHandle) {\n          this.checkLabelHandle(b.bounds);\n        }\n      }\n    }\n  }\n  if (this.labelShape != null) {\n    this.labelShape.redraw();\n  }\n  if (this.customHandles != null) {\n    for (var i = 0; i < this.customHandles.length; i++) {\n      this.customHandles[i].redraw();\n    }\n  }\n};\n\n/**\r\n * Function: hideHandles\r\n *\r\n * Shortcut to <hideSizers>.\r\n */\nmxEdgeHandler.prototype.setHandlesVisible = function (visible) {\n  if (this.bends != null) {\n    for (var i = 0; i < this.bends.length; i++) {\n      this.bends[i].node.style.display = visible ? '' : 'none';\n    }\n  }\n  if (this.virtualBends != null) {\n    for (var i = 0; i < this.virtualBends.length; i++) {\n      this.virtualBends[i].node.style.display = visible ? '' : 'none';\n    }\n  }\n  if (this.labelShape != null) {\n    this.labelShape.node.style.display = visible ? '' : 'none';\n  }\n  if (this.customHandles != null) {\n    for (var i = 0; i < this.customHandles.length; i++) {\n      this.customHandles[i].setVisible(visible);\n    }\n  }\n};\n\n/**\r\n * Function: redrawInnerBends\r\n *\r\n * Updates and redraws the inner bends.\r\n *\r\n * Parameters:\r\n *\r\n * p0 - <mxPoint> that represents the location of the first point.\r\n * pe - <mxPoint> that represents the location of the last point.\r\n */\nmxEdgeHandler.prototype.redrawInnerBends = function (p0, pe) {\n  for (var i = 1; i < this.bends.length - 1; i++) {\n    if (this.bends[i] != null) {\n      if (this.abspoints[i] != null) {\n        var x = this.abspoints[i].x;\n        var y = this.abspoints[i].y;\n        var b = this.bends[i].bounds;\n        this.bends[i].node.style.visibility = 'visible';\n        this.bends[i].bounds = new _mxRectangle[\"default\"](Math.round(x - b.width / 2), Math.round(y - b.height / 2), b.width, b.height);\n        if (this.manageLabelHandle) {\n          this.checkLabelHandle(this.bends[i].bounds);\n        } else if (this.handleImage == null && this.labelShape.visible && _mxGraphUtils[\"default\"].intersects(this.bends[i].bounds, this.labelShape.bounds)) {\n          w = _mxConstants[\"default\"].HANDLE_SIZE + 3;\n          h = _mxConstants[\"default\"].HANDLE_SIZE + 3;\n          this.bends[i].bounds = new _mxRectangle[\"default\"](Math.round(x - w / 2), Math.round(y - h / 2), w, h);\n        }\n        this.bends[i].redraw();\n      } else {\n        this.bends[i].destroy();\n        this.bends[i] = null;\n      }\n    }\n  }\n};\n\n/**\r\n * Function: checkLabelHandle\r\n *\r\n * Checks if the label handle intersects the given bounds and moves it if it\r\n * intersects.\r\n */\nmxEdgeHandler.prototype.checkLabelHandle = function (b) {\n  if (this.labelShape != null) {\n    var b2 = this.labelShape.bounds;\n    if (_mxGraphUtils[\"default\"].intersects(b, b2)) {\n      if (b.getCenterY() < b2.getCenterY()) {\n        b2.y = b.y + b.height;\n      } else {\n        b2.y = b.y - b2.height;\n      }\n    }\n  }\n};\n\n/**\r\n * Function: drawPreview\r\n *\r\n * Redraws the preview.\r\n */\nmxEdgeHandler.prototype.drawPreview = function () {\n  if (this.isLabel) {\n    var b = this.labelShape.bounds;\n    var bounds = new _mxRectangle[\"default\"](Math.round(this.label.x - b.width / 2), Math.round(this.label.y - b.height / 2), b.width, b.height);\n    this.labelShape.bounds = bounds;\n    this.labelShape.redraw();\n  } else if (this.shape != null) {\n    this.shape.apply(this.state);\n    this.shape.points = this.abspoints;\n    this.shape.scale = this.state.view.scale;\n    this.shape.isDashed = this.isSelectionDashed();\n    this.shape.stroke = this.getSelectionColor();\n    this.shape.strokewidth = this.getSelectionStrokeWidth() / this.shape.scale / this.shape.scale;\n    this.shape.arrowStrokewidth = this.getSelectionStrokeWidth();\n    this.shape.isShadow = false;\n    this.shape.redraw();\n  }\n  if (this.parentHighlight != null) {\n    this.parentHighlight.redraw();\n  }\n};\n\n/**\r\n * Function: refresh\r\n *\r\n * Refreshes the bends of this handler.\r\n */\nmxEdgeHandler.prototype.refresh = function () {\n  this.abspoints = this.getSelectionPoints(this.state);\n  this.points = [];\n  if (this.shape != null) {\n    this.shape.points = this.abspoints;\n  }\n  if (this.bends != null) {\n    this.destroyBends(this.bends);\n    this.bends = this.createBends();\n  }\n  if (this.virtualBends != null) {\n    this.destroyBends(this.virtualBends);\n    this.virtualBends = this.createVirtualBends();\n  }\n  if (this.customHandles != null) {\n    this.destroyBends(this.customHandles);\n    this.customHandles = this.createCustomHandles();\n  }\n\n  // Puts label node on top of bends\n  if (this.labelShape != null && this.labelShape.node != null && this.labelShape.node.parentNode != null) {\n    this.labelShape.node.parentNode.appendChild(this.labelShape.node);\n  }\n};\n\n/**\r\n * Function: destroyBends\r\n *\r\n * Destroys all elements in <bends>.\r\n */\nmxEdgeHandler.prototype.destroyBends = function (bends) {\n  if (bends != null) {\n    for (var i = 0; i < bends.length; i++) {\n      if (bends[i] != null) {\n        bends[i].destroy();\n      }\n    }\n  }\n};\n\n/**\r\n * Function: destroy\r\n *\r\n * Destroys the handler and all its resources and DOM nodes. This does\r\n * normally not need to be called as handlers are destroyed automatically\r\n * when the corresponding cell is deselected.\r\n */\nmxEdgeHandler.prototype.destroy = function () {\n  if (this.escapeHandler != null) {\n    this.state.view.graph.removeListener(this.escapeHandler);\n    this.escapeHandler = null;\n  }\n  if (this.marker != null) {\n    this.marker.destroy();\n    this.marker = null;\n  }\n  if (this.shape != null) {\n    this.shape.destroy();\n    this.shape = null;\n  }\n  if (this.parentHighlight != null) {\n    this.parentHighlight.destroy();\n    this.parentHighlight = null;\n  }\n  if (this.labelShape != null) {\n    this.labelShape.destroy();\n    this.labelShape = null;\n  }\n  if (this.constraintHandler != null) {\n    this.constraintHandler.destroy();\n    this.constraintHandler = null;\n  }\n  this.destroyBends(this.virtualBends);\n  this.virtualBends = null;\n  this.destroyBends(this.customHandles);\n  this.customHandles = null;\n  this.destroyBends(this.bends);\n  this.bends = null;\n  this.removeHint();\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxElbowEdgeHandler\r\n *\r\n * Graph event handler that reconnects edges and modifies control points and\r\n * the edge label location. Uses <mxTerminalMarker> for finding and\r\n * highlighting new source and target vertices. This handler is automatically\r\n * created in <mxGraph.createHandler>. It extends <mxEdgeHandler>.\r\n *\r\n * Constructor: mxEdgeHandler\r\n *\r\n * Constructs an edge handler for the specified <mxCellState>.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> of the cell to be modified.\r\n */\nvar _default = exports[\"default\"] = mxEdgeHandler;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxEdgeHandler.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxEdgeSegmentHandler.js":
/*!*******************************************************!*\
  !*** ./src/workflow/mxClient/mxEdgeSegmentHandler.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _mxElbowEdgeHandler = _interopRequireDefault(__webpack_require__(/*! ./mxElbowEdgeHandler.js */ \"./src/workflow/mxClient/mxElbowEdgeHandler.js\"));\nvar _mxPoint = _interopRequireDefault(__webpack_require__(/*! ./mxPoint.js */ \"./src/workflow/mxClient/mxPoint.js\"));\nvar _mxEdgeHandler = _interopRequireDefault(__webpack_require__(/*! ./mxEdgeHandler.js */ \"./src/workflow/mxClient/mxEdgeHandler.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxRectangle = _interopRequireDefault(__webpack_require__(/*! ./mxRectangle.js */ \"./src/workflow/mxClient/mxRectangle.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ./mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nvar _mxUtils = _interopRequireDefault(__webpack_require__(/*! ./mxUtils.js */ \"./src/workflow/mxClient/mxUtils.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxEdgeSegmentHandler(state) {\n  _mxEdgeHandler[\"default\"].call(this, state);\n}\n;\n\n/**\r\n * Extends mxEdgeHandler.\r\n */\n_mxGraphUtils[\"default\"].extend(mxEdgeSegmentHandler, _mxElbowEdgeHandler[\"default\"]);\n\n/**\r\n * Function: getCurrentPoints\r\n *\r\n * Returns the current absolute points.\r\n */\nmxEdgeSegmentHandler.prototype.getCurrentPoints = function () {\n  var pts = this.state.absolutePoints;\n  if (pts != null) {\n    // Special case for straight edges where we add a virtual middle handle for moving the edge\n    if (pts.length == 2 || pts.length == 3 && (pts[0].x == pts[1].x && pts[1].x == pts[2].x || pts[0].y == pts[1].y && pts[1].y == pts[2].y)) {\n      var cx = pts[0].x + (pts[pts.length - 1].x - pts[0].x) / 2;\n      var cy = pts[0].y + (pts[pts.length - 1].y - pts[0].y) / 2;\n      pts = [pts[0], new _mxPoint[\"default\"](cx, cy), new _mxPoint[\"default\"](cx, cy), pts[pts.length - 1]];\n    }\n  }\n  return pts;\n};\n\n/**\r\n * Function: getPreviewPoints\r\n *\r\n * Updates the given preview state taking into account the state of the constraint handler.\r\n */\nmxEdgeSegmentHandler.prototype.getPreviewPoints = function (point) {\n  if (this.isSource || this.isTarget) {\n    return _mxElbowEdgeHandler[\"default\"].prototype.getPreviewPoints.apply(this, arguments);\n  } else {\n    var pts = this.getCurrentPoints();\n    var last = this.convertPoint(pts[0].clone(), false);\n    point = this.convertPoint(point.clone(), false);\n    var result = [];\n    for (var i = 1; i < pts.length; i++) {\n      var pt = this.convertPoint(pts[i].clone(), false);\n      if (i == this.index) {\n        if (Math.round(last.x - pt.x) == 0) {\n          last.x = point.x;\n          pt.x = point.x;\n        }\n        if (Math.round(last.y - pt.y) == 0) {\n          last.y = point.y;\n          pt.y = point.y;\n        }\n      }\n      if (i < pts.length - 1) {\n        result.push(pt);\n      }\n      last = pt;\n    }\n\n    // Replaces single point that intersects with source or target\n    if (result.length == 1) {\n      var source = this.state.getVisibleTerminalState(true);\n      var target = this.state.getVisibleTerminalState(false);\n      var scale = this.state.view.getScale();\n      var tr = this.state.view.getTranslate();\n      var x = result[0].x * scale + tr.x;\n      var y = result[0].y * scale + tr.y;\n      if (source != null && _mxUtils[\"default\"].contains(source, x, y) || target != null && _mxUtils[\"default\"].contains(target, x, y)) {\n        result = [point, point];\n      }\n    }\n    return result;\n  }\n};\n\n/**\r\n * Function: updatePreviewState\r\n *\r\n * Overridden to perform optimization of the edge style result.\r\n */\nmxEdgeSegmentHandler.prototype.updatePreviewState = function (edge, point, terminalState, me) {\n  _mxEdgeHandler[\"default\"].prototype.updatePreviewState.apply(this, arguments);\n\n  // Checks and corrects preview by running edge style again\n  if (!this.isSource && !this.isTarget) {\n    point = this.convertPoint(point.clone(), false);\n    var pts = edge.absolutePoints;\n    var pt0 = pts[0];\n    var pt1 = pts[1];\n    var result = [];\n    for (var i = 2; i < pts.length; i++) {\n      var pt2 = pts[i];\n\n      // Merges adjacent segments only if more than 2 to allow for straight edges\n      if ((Math.round(pt0.x - pt1.x) != 0 || Math.round(pt1.x - pt2.x) != 0) && (Math.round(pt0.y - pt1.y) != 0 || Math.round(pt1.y - pt2.y) != 0)) {\n        result.push(this.convertPoint(pt1.clone(), false));\n      }\n      pt0 = pt1;\n      pt1 = pt2;\n    }\n    var source = this.state.getVisibleTerminalState(true);\n    var target = this.state.getVisibleTerminalState(false);\n    var rpts = this.state.absolutePoints;\n\n    // A straight line is represented by 3 handles\n    if (result.length == 0 && (Math.round(pts[0].x - pts[pts.length - 1].x) == 0 || Math.round(pts[0].y - pts[pts.length - 1].y) == 0)) {\n      result = [point, point];\n    }\n    // Handles special case of transitions from straight vertical to routed\n    else if (pts.length == 5 && result.length == 2 && source != null && target != null && rpts != null && Math.round(rpts[0].x - rpts[rpts.length - 1].x) == 0) {\n      var view = this.graph.getView();\n      var scale = view.getScale();\n      var tr = view.getTranslate();\n      var y0 = view.getRoutingCenterY(source) / scale - tr.y;\n\n      // Use fixed connection point y-coordinate if one exists\n      var sc = this.graph.getConnectionConstraint(edge, source, true);\n      if (sc != null) {\n        var pt = this.graph.getConnectionPoint(source, sc);\n        if (pt != null) {\n          this.convertPoint(pt, false);\n          y0 = pt.y;\n        }\n      }\n      var ye = view.getRoutingCenterY(target) / scale - tr.y;\n\n      // Use fixed connection point y-coordinate if one exists\n      var tc = this.graph.getConnectionConstraint(edge, target, false);\n      if (tc) {\n        var pt = this.graph.getConnectionPoint(target, tc);\n        if (pt != null) {\n          this.convertPoint(pt, false);\n          ye = pt.y;\n        }\n      }\n      result = [new _mxPoint[\"default\"](point.x, y0), new _mxPoint[\"default\"](point.x, ye)];\n    }\n    this.points = result;\n\n    // LATER: Check if points and result are different\n    edge.view.updateFixedTerminalPoints(edge, source, target);\n    edge.view.updatePoints(edge, this.points, source, target);\n    edge.view.updateFloatingTerminalPoints(edge, source, target);\n  }\n};\n\n/**\r\n * Overriden to merge edge segments.\r\n */\nmxEdgeSegmentHandler.prototype.connect = function (edge, terminal, isSource, isClone, me) {\n  // Merges adjacent edge segments\n  var pts = this.abspoints;\n  var pt0 = pts[0];\n  var pt1 = pts[1];\n  var result = [];\n  for (var i = 2; i < pts.length; i++) {\n    var pt2 = pts[i];\n\n    // Merges adjacent segments only if more than 2 to allow for straight edges\n    if ((Math.round(pt0.x - pt1.x) != 0 || Math.round(pt1.x - pt2.x) != 0) && (Math.round(pt0.y - pt1.y) != 0 || Math.round(pt1.y - pt2.y) != 0)) {\n      result.push(this.convertPoint(pt1.clone(), false));\n    }\n    pt0 = pt1;\n    pt1 = pt2;\n  }\n  var model = this.graph.getModel();\n  model.beginUpdate();\n  try {\n    var geo = model.getGeometry(edge);\n    if (geo != null) {\n      geo = geo.clone();\n      geo.points = result;\n      model.setGeometry(edge, geo);\n    }\n    edge = _mxEdgeHandler[\"default\"].prototype.connect.apply(this, arguments);\n  } finally {\n    model.endUpdate();\n  }\n  return edge;\n};\n\n/**\r\n * Function: getTooltipForNode\r\n *\r\n * Returns no tooltips.\r\n */\nmxEdgeSegmentHandler.prototype.getTooltipForNode = function (node) {\n  return null;\n};\n\n/**\r\n * Function: createBends\r\n *\r\n * Adds custom bends for the center of each segment.\r\n */\nmxEdgeSegmentHandler.prototype.start = function (x, y, index) {\n  _mxEdgeHandler[\"default\"].prototype.start.apply(this, arguments);\n  if (this.bends[index] != null && !this.isSource && !this.isTarget) {\n    _mxGraphUtils[\"default\"].setOpacity(this.bends[index].node, 100);\n  }\n};\n\n/**\r\n * Function: createBends\r\n *\r\n * Adds custom bends for the center of each segment.\r\n */\nmxEdgeSegmentHandler.prototype.createBends = function () {\n  var bends = [];\n\n  // Source\n  var bend = this.createHandleShape(0);\n  this.initBend(bend);\n  bend.setCursor(_mxConstants[\"default\"].CURSOR_TERMINAL_HANDLE);\n  bends.push(bend);\n  var pts = this.getCurrentPoints();\n\n  // Waypoints (segment handles)\n  if (this.graph.isCellBendable(this.state.cell)) {\n    if (this.points == null) {\n      this.points = [];\n    }\n    for (var i = 0; i < pts.length - 1; i++) {\n      bend = this.createVirtualBend();\n      bends.push(bend);\n      var horizontal = Math.round(pts[i].x - pts[i + 1].x) == 0;\n\n      // Special case where dy is 0 as well\n      if (Math.round(pts[i].y - pts[i + 1].y) == 0 && i < pts.length - 2) {\n        horizontal = Math.round(pts[i].x - pts[i + 2].x) == 0;\n      }\n      bend.setCursor(horizontal ? 'col-resize' : 'row-resize');\n      this.points.push(new _mxPoint[\"default\"](0, 0));\n    }\n  }\n\n  // Target\n  var bend = this.createHandleShape(pts.length);\n  this.initBend(bend);\n  bend.setCursor(_mxConstants[\"default\"].CURSOR_TERMINAL_HANDLE);\n  bends.push(bend);\n  return bends;\n};\n\n/**\r\n * Function: redraw\r\n *\r\n * Overridden to invoke <refresh> before the redraw.\r\n */\nmxEdgeSegmentHandler.prototype.redraw = function () {\n  this.refresh();\n  _mxEdgeHandler[\"default\"].prototype.redraw.apply(this, arguments);\n};\n\n/**\r\n * Function: redrawInnerBends\r\n *\r\n * Updates the position of the custom bends.\r\n */\nmxEdgeSegmentHandler.prototype.redrawInnerBends = function (p0, pe) {\n  if (this.graph.isCellBendable(this.state.cell)) {\n    var pts = this.getCurrentPoints();\n    if (pts != null && pts.length > 1) {\n      var straight = false;\n\n      // Puts handle in the center of straight edges\n      if (pts.length == 4 && Math.round(pts[1].x - pts[2].x) == 0 && Math.round(pts[1].y - pts[2].y) == 0) {\n        straight = true;\n        if (Math.round(pts[0].y - pts[pts.length - 1].y) == 0) {\n          var cx = pts[0].x + (pts[pts.length - 1].x - pts[0].x) / 2;\n          pts[1] = new _mxPoint[\"default\"](cx, pts[1].y);\n          pts[2] = new _mxPoint[\"default\"](cx, pts[2].y);\n        } else {\n          var cy = pts[0].y + (pts[pts.length - 1].y - pts[0].y) / 2;\n          pts[1] = new _mxPoint[\"default\"](pts[1].x, cy);\n          pts[2] = new _mxPoint[\"default\"](pts[2].x, cy);\n        }\n      }\n      for (var i = 0; i < pts.length - 1; i++) {\n        if (this.bends[i + 1] != null) {\n          var p0 = pts[i];\n          var pe = pts[i + 1];\n          var pt = new _mxPoint[\"default\"](p0.x + (pe.x - p0.x) / 2, p0.y + (pe.y - p0.y) / 2);\n          var b = this.bends[i + 1].bounds;\n          this.bends[i + 1].bounds = new _mxRectangle[\"default\"](Math.floor(pt.x - b.width / 2), Math.floor(pt.y - b.height / 2), b.width, b.height);\n          this.bends[i + 1].redraw();\n          if (this.manageLabelHandle) {\n            this.checkLabelHandle(this.bends[i + 1].bounds);\n          }\n        }\n      }\n      if (straight) {\n        _mxGraphUtils[\"default\"].setOpacity(this.bends[1].node, this.virtualBendOpacity);\n        _mxGraphUtils[\"default\"].setOpacity(this.bends[3].node, this.virtualBendOpacity);\n      }\n    }\n  }\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxKeyHandler\r\n *\r\n * Event handler that listens to keystroke events. This is not a singleton,\r\n * however, it is normally only required once if the target is the document\r\n * element (default).\r\n *\r\n * This handler installs a key event listener in the topmost DOM node and\r\n * processes all events that originate from descandants of <mxGraph.container>\r\n * or from the topmost DOM node. The latter means that all unhandled keystrokes\r\n * are handled by this object regardless of the focused state of the <graph>.\r\n *\r\n * Example:\r\n *\r\n * The following example creates a key handler that listens to the delete key\r\n * (46) and deletes the selection cells if the graph is enabled.\r\n *\r\n * (code)\r\n * var keyHandler = new mxKeyHandler(graph);\r\n * keyHandler.bindKey(46, function(evt)\r\n * {\r\n *   if (graph.isEnabled())\r\n *   {\r\n *     graph.removeCells();\r\n *   }\r\n * });\r\n * (end)\r\n *\r\n * Keycodes:\r\n *\r\n * See http://tinyurl.com/yp8jgl or http://tinyurl.com/229yqw for a list of\r\n * keycodes or install a key event listener into the document element and print\r\n * the key codes of the respective events to the console.\r\n *\r\n * To support the Command key and the Control key on the Mac, the following\r\n * code can be used.\r\n *\r\n * (code)\r\n * keyHandler.getFunction = function(evt)\r\n * {\r\n *   if (evt != null)\r\n *   {\r\n *     return (mxEvent.isControlDown(evt) || (mxClient.IS_MAC && evt.metaKey)) ? this.controlKeys[evt.keyCode] : this.normalKeys[evt.keyCode];\r\n *   }\r\n *\r\n *   return null;\r\n * };\r\n * (end)\r\n *\r\n * Constructor: mxKeyHandler\r\n *\r\n * Constructs an event handler that executes functions bound to specific\r\n * keystrokes.\r\n *\r\n * Parameters:\r\n *\r\n * graph - Reference to the associated <mxGraph>.\r\n * target - Optional reference to the event target. If null, the document\r\n * element is used as the event target, that is, the object where the key\r\n * event listener is installed.\r\n */\nvar _default = exports[\"default\"] = mxEdgeSegmentHandler;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxEdgeSegmentHandler.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxEdgeStyle.js":
/*!**********************************************!*\
  !*** ./src/workflow/mxClient/mxEdgeStyle.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.slice.js */ \"../../node_modules/core-js/modules/es.array.slice.js\");\n__webpack_require__(/*! core-js/modules/es.array.splice.js */ \"../../node_modules/core-js/modules/es.array.splice.js\");\nvar _mxCellState = _interopRequireDefault(__webpack_require__(/*! ./mxCellState.js */ \"./src/workflow/mxClient/mxCellState.js\"));\nvar _mxPoint = _interopRequireDefault(__webpack_require__(/*! ./mxPoint.js */ \"./src/workflow/mxClient/mxPoint.js\"));\nvar _mxRectangle = _interopRequireDefault(__webpack_require__(/*! ./mxRectangle.js */ \"./src/workflow/mxClient/mxRectangle.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ./mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nvar mxEdgeStyle = {\n  /**\r\n   * Class: mxEdgeStyle\r\n   *\r\n   * Provides various edge styles to be used as the values for\r\n   * <mxConstants.STYLE_EDGE> in a cell style.\r\n   *\r\n   * Example:\r\n   *\r\n   * (code)\r\n   * var style = stylesheet.getDefaultEdgeStyle();\r\n   * style[mxConstants.STYLE_EDGE] = mxEdgeStyle.ElbowConnector;\r\n   * (end)\r\n   *\r\n   * Sets the default edge style to <ElbowConnector>.\r\n   *\r\n   * Custom edge style:\r\n   *\r\n   * To write a custom edge style, a function must be added to the mxEdgeStyle\r\n   * object as follows:\r\n   *\r\n   * (code)\r\n   * mxEdgeStyle.MyStyle = function(state, source, target, points, result)\r\n   * {\r\n   *   if (source != null && target != null)\r\n   *   {\r\n   *     var pt = new mxPoint(target.getCenterX(), source.getCenterY());\r\n   *\r\n   *     if (mxGraphUtils.contains(source, pt.x, pt.y))\r\n   *     {\r\n   *       pt.y = source.y + source.height;\r\n   *     }\r\n   *\r\n   *     result.push(pt);\r\n   *   }\r\n   * };\r\n   * (end)\r\n   *\r\n   * In the above example, a right angle is created using a point on the\r\n   * horizontal center of the target vertex and the vertical center of the source\r\n   * vertex. The code checks if that point intersects the source vertex and makes\r\n   * the edge straight if it does. The point is then added into the result array,\r\n   * which acts as the return value of the function.\r\n   *\r\n   * The new edge style should then be registered in the <mxStyleRegistry> as follows:\r\n   * (code)\r\n   * mxStyleRegistry.putValue('myEdgeStyle', mxEdgeStyle.MyStyle);\r\n   * (end)\r\n   *\r\n   * The custom edge style above can now be used in a specific edge as follows:\r\n   *\r\n   * (code)\r\n   * model.setStyle(edge, 'edgeStyle=myEdgeStyle');\r\n   * (end)\r\n   *\r\n   * Note that the key of the <mxStyleRegistry> entry for the function should\r\n   * be used in string values, unless <mxGraphView.allowEval> is true, in\r\n   * which case you can also use mxEdgeStyle.MyStyle for the value in the\r\n   * cell style above.\r\n   *\r\n   * Or it can be used for all edges in the graph as follows:\r\n   *\r\n   * (code)\r\n   * var style = graph.getStylesheet().getDefaultEdgeStyle();\r\n   * style[mxConstants.STYLE_EDGE] = mxEdgeStyle.MyStyle;\r\n   * (end)\r\n   *\r\n   * Note that the object can be used directly when programmatically setting\r\n   * the value, but the key in the <mxStyleRegistry> should be used when\r\n   * setting the value via a key, value pair in a cell style.\r\n   *\r\n   * Function: EntityRelation\r\n   *\r\n   * Implements an entity relation style for edges (as used in database\r\n   * schema diagrams). At the time the function is called, the result\r\n   * array contains a placeholder (null) for the first absolute point,\r\n   * that is, the point where the edge and source terminal are connected.\r\n   * The implementation of the style then adds all intermediate waypoints\r\n   * except for the last point, that is, the connection point between the\r\n   * edge and the target terminal. The first ant the last point in the\r\n   * result array are then replaced with mxPoints that take into account\r\n   * the terminal's perimeter and next point on the edge.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * state - <mxCellState> that represents the edge to be updated.\r\n   * source - <mxCellState> that represents the source terminal.\r\n   * target - <mxCellState> that represents the target terminal.\r\n   * points - List of relative control points.\r\n   * result - Array of <mxPoints> that represent the actual points of the\r\n   * edge.\r\n   */\n  EntityRelation: function EntityRelation(state, source, target, points, result) {\n    var view = state.view;\n    var graph = view.graph;\n    var segment = _mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_SEGMENT, _mxConstants[\"default\"].ENTITY_SEGMENT) * view.scale;\n    var pts = state.absolutePoints;\n    var p0 = pts[0];\n    var pe = pts[pts.length - 1];\n    var isSourceLeft = false;\n    if (p0 != null) {\n      source = new _mxCellState[\"default\"]();\n      source.x = p0.x;\n      source.y = p0.y;\n    } else if (source != null) {\n      var constraint = _mxGraphUtils[\"default\"].getPortConstraints(source, state, true, _mxConstants[\"default\"].DIRECTION_MASK_NONE);\n      if (constraint != _mxConstants[\"default\"].DIRECTION_MASK_NONE && constraint != _mxConstants[\"default\"].DIRECTION_MASK_WEST + _mxConstants[\"default\"].DIRECTION_MASK_EAST) {\n        isSourceLeft = constraint == _mxConstants[\"default\"].DIRECTION_MASK_WEST;\n      } else {\n        var sourceGeometry = graph.getCellGeometry(source.cell);\n        if (sourceGeometry.relative) {\n          isSourceLeft = sourceGeometry.x <= 0.5;\n        } else if (target != null) {\n          isSourceLeft = target.x + target.width < source.x;\n        }\n      }\n    } else {\n      return;\n    }\n    var isTargetLeft = true;\n    if (pe != null) {\n      target = new _mxCellState[\"default\"]();\n      target.x = pe.x;\n      target.y = pe.y;\n    } else if (target != null) {\n      var constraint = _mxGraphUtils[\"default\"].getPortConstraints(target, state, false, _mxConstants[\"default\"].DIRECTION_MASK_NONE);\n      if (constraint != _mxConstants[\"default\"].DIRECTION_MASK_NONE && constraint != _mxConstants[\"default\"].DIRECTION_MASK_WEST + _mxConstants[\"default\"].DIRECTION_MASK_EAST) {\n        isTargetLeft = constraint == _mxConstants[\"default\"].DIRECTION_MASK_WEST;\n      } else {\n        var targetGeometry = graph.getCellGeometry(target.cell);\n        if (targetGeometry.relative) {\n          isTargetLeft = targetGeometry.x <= 0.5;\n        } else if (source != null) {\n          isTargetLeft = source.x + source.width < target.x;\n        }\n      }\n    }\n    if (source != null && target != null) {\n      var x0 = isSourceLeft ? source.x : source.x + source.width;\n      var y0 = view.getRoutingCenterY(source);\n      var xe = isTargetLeft ? target.x : target.x + target.width;\n      var ye = view.getRoutingCenterY(target);\n      var seg = segment;\n      var dx = isSourceLeft ? -seg : seg;\n      var dep = new _mxPoint[\"default\"](x0 + dx, y0);\n      dx = isTargetLeft ? -seg : seg;\n      var arr = new _mxPoint[\"default\"](xe + dx, ye);\n\n      // Adds intermediate points if both go out on same side\n      if (isSourceLeft == isTargetLeft) {\n        var x = isSourceLeft ? Math.min(x0, xe) - segment : Math.max(x0, xe) + segment;\n        result.push(new _mxPoint[\"default\"](x, y0));\n        result.push(new _mxPoint[\"default\"](x, ye));\n      } else if (dep.x < arr.x == isSourceLeft) {\n        var midY = y0 + (ye - y0) / 2;\n        result.push(dep);\n        result.push(new _mxPoint[\"default\"](dep.x, midY));\n        result.push(new _mxPoint[\"default\"](arr.x, midY));\n        result.push(arr);\n      } else {\n        result.push(dep);\n        result.push(arr);\n      }\n    }\n  },\n  /**\r\n  * Function: Loop\r\n  *\r\n  * Implements a self-reference, aka. loop.\r\n  */\n  Loop: function Loop(state, source, target, points, result) {\n    var pts = state.absolutePoints;\n    var p0 = pts[0];\n    var pe = pts[pts.length - 1];\n    if (p0 != null && pe != null) {\n      if (points != null && points.length > 0) {\n        for (var i = 0; i < points.length; i++) {\n          var pt = points[i];\n          pt = state.view.transformControlPoint(state, pt);\n          result.push(new _mxPoint[\"default\"](pt.x, pt.y));\n        }\n      }\n      return;\n    }\n    if (source != null) {\n      var view = state.view;\n      var graph = view.graph;\n      var pt = points != null && points.length > 0 ? points[0] : null;\n      if (pt != null) {\n        pt = view.transformControlPoint(state, pt);\n        if (_mxGraphUtils[\"default\"].contains(source, pt.x, pt.y)) {\n          pt = null;\n        }\n      }\n      var x = 0;\n      var dx = 0;\n      var y = 0;\n      var dy = 0;\n      var seg = _mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_SEGMENT, graph.gridSize) * view.scale;\n      var dir = _mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_DIRECTION, _mxConstants[\"default\"].DIRECTION_WEST);\n      if (dir == _mxConstants[\"default\"].DIRECTION_NORTH || dir == _mxConstants[\"default\"].DIRECTION_SOUTH) {\n        x = view.getRoutingCenterX(source);\n        dx = seg;\n      } else {\n        y = view.getRoutingCenterY(source);\n        dy = seg;\n      }\n      if (pt == null || pt.x < source.x || pt.x > source.x + source.width) {\n        if (pt != null) {\n          x = pt.x;\n          dy = Math.max(Math.abs(y - pt.y), dy);\n        } else {\n          if (dir == _mxConstants[\"default\"].DIRECTION_NORTH) {\n            y = source.y - 2 * dx;\n          } else if (dir == _mxConstants[\"default\"].DIRECTION_SOUTH) {\n            y = source.y + source.height + 2 * dx;\n          } else if (dir == _mxConstants[\"default\"].DIRECTION_EAST) {\n            x = source.x - 2 * dy;\n          } else {\n            x = source.x + source.width + 2 * dy;\n          }\n        }\n      } else if (pt != null) {\n        x = view.getRoutingCenterX(source);\n        dx = Math.max(Math.abs(x - pt.x), dy);\n        y = pt.y;\n        dy = 0;\n      }\n      result.push(new _mxPoint[\"default\"](x - dx, y - dy));\n      result.push(new _mxPoint[\"default\"](x + dx, y + dy));\n    }\n  },\n  /**\r\n   * Function: ElbowConnector\r\n   *\r\n   * Uses either <SideToSide> or <TopToBottom> depending on the horizontal\r\n   * flag in the cell style. <SideToSide> is used if horizontal is true or\r\n   * unspecified. See <EntityRelation> for a description of the\r\n   * parameters.\r\n   */\n  ElbowConnector: function ElbowConnector(state, source, target, points, result) {\n    var pt = points != null && points.length > 0 ? points[0] : null;\n    var vertical = false;\n    var horizontal = false;\n    if (source != null && target != null) {\n      if (pt != null) {\n        var left = Math.min(source.x, target.x);\n        var right = Math.max(source.x + source.width, target.x + target.width);\n        var top = Math.min(source.y, target.y);\n        var bottom = Math.max(source.y + source.height, target.y + target.height);\n        pt = state.view.transformControlPoint(state, pt);\n        vertical = pt.y < top || pt.y > bottom;\n        horizontal = pt.x < left || pt.x > right;\n      } else {\n        var left = Math.max(source.x, target.x);\n        var right = Math.min(source.x + source.width, target.x + target.width);\n        vertical = left == right;\n        if (!vertical) {\n          var top = Math.max(source.y, target.y);\n          var bottom = Math.min(source.y + source.height, target.y + target.height);\n          horizontal = top == bottom;\n        }\n      }\n    }\n    if (!horizontal && (vertical || state.style[_mxConstants[\"default\"].STYLE_ELBOW] == _mxConstants[\"default\"].ELBOW_VERTICAL)) {\n      mxEdgeStyle.TopToBottom(state, source, target, points, result);\n    } else {\n      mxEdgeStyle.SideToSide(state, source, target, points, result);\n    }\n  },\n  /**\r\n   * Function: SideToSide\r\n   *\r\n   * Implements a vertical elbow edge. See <EntityRelation> for a description\r\n   * of the parameters.\r\n   */\n  SideToSide: function SideToSide(state, source, target, points, result) {\n    var view = state.view;\n    var pt = points != null && points.length > 0 ? points[0] : null;\n    var pts = state.absolutePoints;\n    var p0 = pts[0];\n    var pe = pts[pts.length - 1];\n    if (pt != null) {\n      pt = view.transformControlPoint(state, pt);\n    }\n    if (p0 != null) {\n      source = new _mxCellState[\"default\"]();\n      source.x = p0.x;\n      source.y = p0.y;\n    }\n    if (pe != null) {\n      target = new _mxCellState[\"default\"]();\n      target.x = pe.x;\n      target.y = pe.y;\n    }\n    if (source != null && target != null) {\n      var l = Math.max(source.x, target.x);\n      var r = Math.min(source.x + source.width, target.x + target.width);\n      var x = pt != null ? pt.x : Math.round(r + (l - r) / 2);\n      var y1 = view.getRoutingCenterY(source);\n      var y2 = view.getRoutingCenterY(target);\n      if (pt != null) {\n        if (pt.y >= source.y && pt.y <= source.y + source.height) {\n          y1 = pt.y;\n        }\n        if (pt.y >= target.y && pt.y <= target.y + target.height) {\n          y2 = pt.y;\n        }\n      }\n      if (!_mxGraphUtils[\"default\"].contains(target, x, y1) && !_mxGraphUtils[\"default\"].contains(source, x, y1)) {\n        result.push(new _mxPoint[\"default\"](x, y1));\n      }\n      if (!_mxGraphUtils[\"default\"].contains(target, x, y2) && !_mxGraphUtils[\"default\"].contains(source, x, y2)) {\n        result.push(new _mxPoint[\"default\"](x, y2));\n      }\n      if (result.length == 1) {\n        if (pt != null) {\n          if (!_mxGraphUtils[\"default\"].contains(target, x, pt.y) && !_mxGraphUtils[\"default\"].contains(source, x, pt.y)) {\n            result.push(new _mxPoint[\"default\"](x, pt.y));\n          }\n        } else {\n          var t = Math.max(source.y, target.y);\n          var b = Math.min(source.y + source.height, target.y + target.height);\n          result.push(new _mxPoint[\"default\"](x, t + (b - t) / 2));\n        }\n      }\n    }\n  },\n  /**\r\n   * Function: TopToBottom\r\n   *\r\n   * Implements a horizontal elbow edge. See <EntityRelation> for a\r\n   * description of the parameters.\r\n   */\n  TopToBottom: function TopToBottom(state, source, target, points, result) {\n    var view = state.view;\n    var pt = points != null && points.length > 0 ? points[0] : null;\n    var pts = state.absolutePoints;\n    var p0 = pts[0];\n    var pe = pts[pts.length - 1];\n    if (pt != null) {\n      pt = view.transformControlPoint(state, pt);\n    }\n    if (p0 != null) {\n      source = new _mxCellState[\"default\"]();\n      source.x = p0.x;\n      source.y = p0.y;\n    }\n    if (pe != null) {\n      target = new _mxCellState[\"default\"]();\n      target.x = pe.x;\n      target.y = pe.y;\n    }\n    if (source != null && target != null) {\n      var t = Math.max(source.y, target.y);\n      var b = Math.min(source.y + source.height, target.y + target.height);\n      var x = view.getRoutingCenterX(source);\n      if (pt != null && pt.x >= source.x && pt.x <= source.x + source.width) {\n        x = pt.x;\n      }\n      var y = pt != null ? pt.y : Math.round(b + (t - b) / 2);\n      if (!_mxGraphUtils[\"default\"].contains(target, x, y) && !_mxGraphUtils[\"default\"].contains(source, x, y)) {\n        result.push(new _mxPoint[\"default\"](x, y));\n      }\n      if (pt != null && pt.x >= target.x && pt.x <= target.x + target.width) {\n        x = pt.x;\n      } else {\n        x = view.getRoutingCenterX(target);\n      }\n      if (!_mxGraphUtils[\"default\"].contains(target, x, y) && !_mxGraphUtils[\"default\"].contains(source, x, y)) {\n        result.push(new _mxPoint[\"default\"](x, y));\n      }\n      if (result.length == 1) {\n        if (pt != null && result.length == 1) {\n          if (!_mxGraphUtils[\"default\"].contains(target, pt.x, y) && !_mxGraphUtils[\"default\"].contains(source, pt.x, y)) {\n            result.push(new _mxPoint[\"default\"](pt.x, y));\n          }\n        } else {\n          var l = Math.max(source.x, target.x);\n          var r = Math.min(source.x + source.width, target.x + target.width);\n          result.push(new _mxPoint[\"default\"](l + (r - l) / 2, y));\n        }\n      }\n    }\n  },\n  /**\r\n   * Function: SegmentConnector\r\n   *\r\n   * Implements an orthogonal edge style. Use <mxEdgeSegmentHandler>\r\n   * as an interactive handler for this style.\r\n   */\n  SegmentConnector: function SegmentConnector(state, source, target, hints, result) {\n    // Creates array of all way- and terminalpoints\n    var pts = state.absolutePoints;\n    var tol = Math.max(1, state.view.scale);\n\n    // Whether the first segment outgoing from the source end is horizontal\n    var lastPushed = result.length > 0 ? result[0] : null;\n    var horizontal = true;\n    var hint = null;\n\n    // Adds waypoints only if outside of tolerance\n    function pushPoint(pt) {\n      if (lastPushed == null || Math.abs(lastPushed.x - pt.x) >= tol || Math.abs(lastPushed.y - pt.y) >= tol) {\n        result.push(pt);\n        lastPushed = pt;\n      }\n      return lastPushed;\n    }\n    ;\n\n    // Adds the first point\n    var pt = pts[0];\n    if (pt == null && source != null) {\n      pt = new _mxPoint[\"default\"](state.view.getRoutingCenterX(source), state.view.getRoutingCenterY(source));\n    } else if (pt != null) {\n      pt = pt.clone();\n    }\n    pt && (pt.x = Math.round(pt.x));\n    pt && (pt.y = Math.round(pt.y));\n    var lastInx = pts.length - 1;\n\n    // Adds the waypoints\n    if (hints != null && hints.length > 0) {\n      // Converts all hints and removes nulls\n      var newHints = [];\n      for (var i = 0; i < hints.length; i++) {\n        var tmp = state.view.transformControlPoint(state, hints[i]);\n        if (tmp != null) {\n          tmp.x = Math.round(tmp.x);\n          tmp.y = Math.round(tmp.y);\n          newHints.push(tmp);\n        }\n      }\n      if (newHints.length == 0) {\n        return;\n      }\n      hints = newHints;\n\n      // Aligns source and target hint to fixed points\n      if (pt != null && hints[0] != null) {\n        if (Math.abs(hints[0].x - pt.x) < tol) {\n          hints[0].x = pt.x;\n        }\n        if (Math.abs(hints[0].y - pt.y) < tol) {\n          hints[0].y = pt.y;\n        }\n      }\n      var pe = pts[lastInx];\n      if (pe != null && hints[hints.length - 1] != null) {\n        if (Math.abs(hints[hints.length - 1].x - pe.x) < tol) {\n          hints[hints.length - 1].x = pe.x;\n        }\n        if (Math.abs(hints[hints.length - 1].y - pe.y) < tol) {\n          hints[hints.length - 1].y = pe.y;\n        }\n      }\n      hint = hints[0];\n      var currentTerm = source;\n      var currentPt = pts[0];\n      var hozChan = false;\n      var vertChan = false;\n      var currentHint = hint;\n      if (currentPt != null) {\n        currentPt.x = Math.round(currentPt.x);\n        currentPt.y = Math.round(currentPt.y);\n        currentTerm = null;\n      }\n\n      // Check for alignment with fixed points and with channels\n      // at source and target segments only\n      for (var i = 0; i < 2; i++) {\n        var fixedVertAlign = currentPt != null && currentPt.x == currentHint.x;\n        var fixedHozAlign = currentPt != null && currentPt.y == currentHint.y;\n        var inHozChan = currentTerm != null && currentHint.y >= currentTerm.y && currentHint.y <= currentTerm.y + currentTerm.height;\n        var inVertChan = currentTerm != null && currentHint.x >= currentTerm.x && currentHint.x <= currentTerm.x + currentTerm.width;\n        hozChan = fixedHozAlign || currentPt == null && inHozChan;\n        vertChan = fixedVertAlign || currentPt == null && inVertChan;\n\n        // If the current hint falls in both the hor and vert channels in the case\n        // of a floating port, or if the hint is exactly co-incident with a\n        // fixed point, ignore the source and try to work out the orientation\n        // from the target end\n        if (!(i == 0 && (hozChan && vertChan || fixedVertAlign && fixedHozAlign))) {\n          if (currentPt != null && !fixedHozAlign && !fixedVertAlign && (inHozChan || inVertChan)) {\n            horizontal = inHozChan ? false : true;\n            break;\n          }\n          if (vertChan || hozChan) {\n            horizontal = hozChan;\n            if (i == 1) {\n              // Work back from target end\n              horizontal = hints.length % 2 == 0 ? hozChan : vertChan;\n            }\n            break;\n          }\n        }\n        currentTerm = target;\n        currentPt = pts[lastInx];\n        if (currentPt != null) {\n          currentPt.x = Math.round(currentPt.x);\n          currentPt.y = Math.round(currentPt.y);\n          currentTerm = null;\n        }\n        currentHint = hints[hints.length - 1];\n        if (fixedVertAlign && fixedHozAlign) {\n          hints = hints.slice(1);\n        }\n      }\n      if (pt) {\n        if (horizontal && (pts[0] != null && pts[0].y != hint.y || pts[0] == null && source != null && (hint.y < source.y || hint.y > source.y + source.height))) {\n          pushPoint(new _mxPoint[\"default\"](pt.x, hint.y));\n        } else if (!horizontal && (pts[0] != null && pts[0].x != hint.x || pts[0] == null && source != null && (hint.x < source.x || hint.x > source.x + source.width))) {\n          pushPoint(new _mxPoint[\"default\"](hint.x, pt.y));\n        }\n        if (horizontal) {\n          pt.y = hint.y;\n        } else {\n          pt.x = hint.x;\n        }\n        for (var i = 0; i < hints.length; i++) {\n          horizontal = !horizontal;\n          hint = hints[i];\n          if (horizontal) {\n            pt.y = hint.y;\n          } else {\n            pt.x = hint.x;\n          }\n          pushPoint(pt.clone());\n        }\n      }\n    } else {\n      hint = pt;\n      // FIXME: First click in connect preview toggles orientation\n      horizontal = true;\n    }\n\n    // Adds the last point\n    pt = pts[lastInx];\n    if (pt == null && target != null) {\n      pt = new _mxPoint[\"default\"](state.view.getRoutingCenterX(target), state.view.getRoutingCenterY(target));\n    }\n    if (pt != null) {\n      pt.x = Math.round(pt.x);\n      pt.y = Math.round(pt.y);\n      if (hint != null) {\n        if (horizontal && (pts[lastInx] != null && pts[lastInx].y != hint.y || pts[lastInx] == null && target != null && (hint.y < target.y || hint.y > target.y + target.height))) {\n          pushPoint(new _mxPoint[\"default\"](pt.x, hint.y));\n        } else if (!horizontal && (pts[lastInx] != null && pts[lastInx].x != hint.x || pts[lastInx] == null && target != null && (hint.x < target.x || hint.x > target.x + target.width))) {\n          pushPoint(new _mxPoint[\"default\"](hint.x, pt.y));\n        }\n      }\n    }\n\n    // Removes bends inside the source terminal for floating ports\n    if (pts[0] == null && source != null) {\n      while (result.length > 1 && result[1] != null && _mxGraphUtils[\"default\"].contains(source, result[1].x, result[1].y)) {\n        result.splice(1, 1);\n      }\n    }\n\n    // Removes bends inside the target terminal\n    if (pts[lastInx] == null && target != null) {\n      while (result.length > 1 && result[result.length - 1] != null && _mxGraphUtils[\"default\"].contains(target, result[result.length - 1].x, result[result.length - 1].y)) {\n        result.splice(result.length - 1, 1);\n      }\n    }\n\n    // Removes last point if inside tolerance with end point\n    if (pe != null && result[result.length - 1] != null && Math.abs(pe.x - result[result.length - 1].x) < tol && Math.abs(pe.y - result[result.length - 1].y) < tol) {\n      result.splice(result.length - 1, 1);\n\n      // Lines up second last point in result with end point\n      if (result[result.length - 1] != null) {\n        if (Math.abs(result[result.length - 1].x - pe.x) < tol) {\n          result[result.length - 1].x = pe.x;\n        }\n        if (Math.abs(result[result.length - 1].y - pe.y) < tol) {\n          result[result.length - 1].y = pe.y;\n        }\n      }\n    }\n  },\n  orthBuffer: 20,\n  orthPointsFallback: true,\n  dirVectors: [[-1, 0], [0, -1], [1, 0], [0, 1], [-1, 0], [0, -1], [1, 0]],\n  wayPoints1: [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0]],\n  routePatterns: [[[513, 2308, 2081, 2562], [513, 1090, 514, 2184, 2114, 2561], [513, 1090, 514, 2564, 2184, 2562], [513, 2308, 2561, 1090, 514, 2568, 2308]], [[514, 1057, 513, 2308, 2081, 2562], [514, 2184, 2114, 2561], [514, 2184, 2562, 1057, 513, 2564, 2184], [514, 1057, 513, 2568, 2308, 2561]], [[1090, 514, 1057, 513, 2308, 2081, 2562], [2114, 2561], [1090, 2562, 1057, 513, 2564, 2184], [1090, 514, 1057, 513, 2308, 2561, 2568]], [[2081, 2562], [1057, 513, 1090, 514, 2184, 2114, 2561], [1057, 513, 1090, 514, 2184, 2562, 2564], [1057, 2561, 1090, 514, 2568, 2308]]],\n  inlineRoutePatterns: [[null, [2114, 2568], null, null], [null, [514, 2081, 2114, 2568], null, null], [null, [2114, 2561], null, null], [[2081, 2562], [1057, 2114, 2568], [2184, 2562], null]],\n  vertexSeperations: [],\n  limits: [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]],\n  LEFT_MASK: 32,\n  TOP_MASK: 64,\n  RIGHT_MASK: 128,\n  BOTTOM_MASK: 256,\n  LEFT: 1,\n  TOP: 2,\n  RIGHT: 4,\n  BOTTOM: 8,\n  // TODO remove magic numbers\n  SIDE_MASK: 480,\n  //mxEdgeStyle.LEFT_MASK | mxEdgeStyle.TOP_MASK | mxEdgeStyle.RIGHT_MASK\n  //| mxEdgeStyle.BOTTOM_MASK,\n\n  CENTER_MASK: 512,\n  SOURCE_MASK: 1024,\n  TARGET_MASK: 2048,\n  VERTEX_MASK: 3072,\n  // mxEdgeStyle.SOURCE_MASK | mxEdgeStyle.TARGET_MASK,\n\n  getJettySize: function getJettySize(state, source, target, points, isSource) {\n    var value = _mxGraphUtils[\"default\"].getValue(state.style, isSource ? _mxConstants[\"default\"].STYLE_SOURCE_JETTY_SIZE : _mxConstants[\"default\"].STYLE_TARGET_JETTY_SIZE, _mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_JETTY_SIZE, mxEdgeStyle.orthBuffer));\n    if (value == 'auto') {\n      // Computes the automatic jetty size\n      var type = _mxGraphUtils[\"default\"].getValue(state.style, isSource ? _mxConstants[\"default\"].STYLE_STARTARROW : _mxConstants[\"default\"].STYLE_ENDARROW, _mxConstants[\"default\"].NONE);\n      if (type != _mxConstants[\"default\"].NONE) {\n        var size = _mxGraphUtils[\"default\"].getNumber(state.style, isSource ? _mxConstants[\"default\"].STYLE_STARTSIZE : _mxConstants[\"default\"].STYLE_ENDSIZE, _mxConstants[\"default\"].DEFAULT_MARKERSIZE);\n        value = Math.max(2, Math.ceil((size + mxEdgeStyle.orthBuffer) / mxEdgeStyle.orthBuffer)) * mxEdgeStyle.orthBuffer;\n      } else {\n        value = 2 * mxEdgeStyle.orthBuffer;\n      }\n    }\n    return value;\n  },\n  /**\r\n   * Function: OrthConnector\r\n   *\r\n   * Implements a local orthogonal router between the given\r\n   * cells.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * state - <mxCellState> that represents the edge to be updated.\r\n   * source - <mxCellState> that represents the source terminal.\r\n   * target - <mxCellState> that represents the target terminal.\r\n   * points - List of relative control points.\r\n   * result - Array of <mxPoints> that represent the actual points of the\r\n   * edge.\r\n   *\r\n   */\n  OrthConnector: function OrthConnector(state, source, target, points, result) {\n    var graph = state.view.graph;\n    var sourceEdge = source == null ? false : graph.getModel().isEdge(source.cell);\n    var targetEdge = target == null ? false : graph.getModel().isEdge(target.cell);\n    var pts = state.absolutePoints;\n    var p0 = pts[0];\n    var pe = pts[pts.length - 1];\n    var sourceX = source != null ? source.x : p0.x;\n    var sourceY = source != null ? source.y : p0.y;\n    var sourceWidth = source != null ? source.width : 0;\n    var sourceHeight = source != null ? source.height : 0;\n    var targetX = target != null ? target.x : pe.x;\n    var targetY = target != null ? target.y : pe.y;\n    var targetWidth = target != null ? target.width : 0;\n    var targetHeight = target != null ? target.height : 0;\n    var scaledSourceBuffer = state.view.scale * mxEdgeStyle.getJettySize(state, source, target, points, true);\n    var scaledTargetBuffer = state.view.scale * mxEdgeStyle.getJettySize(state, source, target, points, false);\n\n    // Workaround for loop routing within buffer zone\n    if (source != null && target == source) {\n      scaledTargetBuffer = Math.max(scaledSourceBuffer, scaledTargetBuffer);\n      scaledSourceBuffer = scaledTargetBuffer;\n    }\n    var totalBuffer = scaledTargetBuffer + scaledSourceBuffer;\n    var tooShort = false;\n\n    // Checks minimum distance for fixed points and falls back to segment connector\n    if (p0 != null && pe != null) {\n      var dx = pe.x - p0.x;\n      var dy = pe.y - p0.y;\n      tooShort = dx * dx + dy * dy < totalBuffer * totalBuffer;\n    }\n    if (tooShort || mxEdgeStyle.orthPointsFallback && points != null && points.length > 0 || sourceEdge || targetEdge) {\n      mxEdgeStyle.SegmentConnector(state, source, target, points, result);\n      return;\n    }\n\n    // Determine the side(s) of the source and target vertices\n    // that the edge may connect to\n    // portConstraint [source, target]\n    var portConstraint = [_mxConstants[\"default\"].DIRECTION_MASK_ALL, _mxConstants[\"default\"].DIRECTION_MASK_ALL];\n    var rotation = 0;\n    if (source != null) {\n      portConstraint[0] = _mxGraphUtils[\"default\"].getPortConstraints(source, state, true, _mxConstants[\"default\"].DIRECTION_MASK_ALL);\n      rotation = _mxGraphUtils[\"default\"].getValue(source.style, _mxConstants[\"default\"].STYLE_ROTATION, 0);\n      if (rotation != 0) {\n        var newRect = _mxGraphUtils[\"default\"].getBoundingBox(new _mxRectangle[\"default\"](sourceX, sourceY, sourceWidth, sourceHeight), rotation, null, _mxRectangle[\"default\"], _mxPoint[\"default\"]);\n        sourceX = newRect.x;\n        sourceY = newRect.y;\n        sourceWidth = newRect.width;\n        sourceHeight = newRect.height;\n      }\n    }\n    if (target != null) {\n      portConstraint[1] = _mxGraphUtils[\"default\"].getPortConstraints(target, state, false, _mxConstants[\"default\"].DIRECTION_MASK_ALL);\n      rotation = _mxGraphUtils[\"default\"].getValue(target.style, _mxConstants[\"default\"].STYLE_ROTATION, 0);\n      if (rotation != 0) {\n        var newRect = _mxGraphUtils[\"default\"].getBoundingBox(new _mxRectangle[\"default\"](targetX, targetY, targetWidth, targetHeight), rotation, null, _mxRectangle[\"default\"], _mxPoint[\"default\"]);\n        targetX = newRect.x;\n        targetY = newRect.y;\n        targetWidth = newRect.width;\n        targetHeight = newRect.height;\n      }\n    }\n\n    // Avoids floating point number errors\n    sourceX = Math.round(sourceX * 10) / 10;\n    sourceY = Math.round(sourceY * 10) / 10;\n    sourceWidth = Math.round(sourceWidth * 10) / 10;\n    sourceHeight = Math.round(sourceHeight * 10) / 10;\n    targetX = Math.round(targetX * 10) / 10;\n    targetY = Math.round(targetY * 10) / 10;\n    targetWidth = Math.round(targetWidth * 10) / 10;\n    targetHeight = Math.round(targetHeight * 10) / 10;\n    var dir = [0, 0];\n\n    // Work out which faces of the vertices present against each other\n    // in a way that would allow a 3-segment connection if port constraints\n    // permitted.\n    // geo -> [source, target] [x, y, width, height]\n    var geo = [[sourceX, sourceY, sourceWidth, sourceHeight], [targetX, targetY, targetWidth, targetHeight]];\n    var buffer = [scaledSourceBuffer, scaledTargetBuffer];\n    for (var i = 0; i < 2; i++) {\n      mxEdgeStyle.limits[i][1] = geo[i][0] - buffer[i];\n      mxEdgeStyle.limits[i][2] = geo[i][1] - buffer[i];\n      mxEdgeStyle.limits[i][4] = geo[i][0] + geo[i][2] + buffer[i];\n      mxEdgeStyle.limits[i][8] = geo[i][1] + geo[i][3] + buffer[i];\n    }\n\n    // Work out which quad the target is in\n    var sourceCenX = geo[0][0] + geo[0][2] / 2.0;\n    var sourceCenY = geo[0][1] + geo[0][3] / 2.0;\n    var targetCenX = geo[1][0] + geo[1][2] / 2.0;\n    var targetCenY = geo[1][1] + geo[1][3] / 2.0;\n    var dx = sourceCenX - targetCenX;\n    var dy = sourceCenY - targetCenY;\n    var quad = 0;\n    if (dx < 0) {\n      if (dy < 0) {\n        quad = 2;\n      } else {\n        quad = 1;\n      }\n    } else {\n      if (dy <= 0) {\n        quad = 3;\n\n        // Special case on x = 0 and negative y\n        if (dx == 0) {\n          quad = 2;\n        }\n      }\n    }\n\n    // Check for connection constraints\n    var currentTerm = null;\n    if (source != null) {\n      currentTerm = p0;\n    }\n    var constraint = [[0.5, 0.5], [0.5, 0.5]];\n    for (var i = 0; i < 2; i++) {\n      if (currentTerm != null) {\n        constraint[i][0] = (currentTerm.x - geo[i][0]) / geo[i][2];\n        if (Math.abs(currentTerm.x - geo[i][0]) <= 1) {\n          dir[i] = _mxConstants[\"default\"].DIRECTION_MASK_WEST;\n        } else if (Math.abs(currentTerm.x - geo[i][0] - geo[i][2]) <= 1) {\n          dir[i] = _mxConstants[\"default\"].DIRECTION_MASK_EAST;\n        }\n        constraint[i][1] = (currentTerm.y - geo[i][1]) / geo[i][3];\n        if (Math.abs(currentTerm.y - geo[i][1]) <= 1) {\n          dir[i] = _mxConstants[\"default\"].DIRECTION_MASK_NORTH;\n        } else if (Math.abs(currentTerm.y - geo[i][1] - geo[i][3]) <= 1) {\n          dir[i] = _mxConstants[\"default\"].DIRECTION_MASK_SOUTH;\n        }\n      }\n      currentTerm = null;\n      if (target != null) {\n        currentTerm = pe;\n      }\n    }\n    var sourceTopDist = geo[0][1] - (geo[1][1] + geo[1][3]);\n    var sourceLeftDist = geo[0][0] - (geo[1][0] + geo[1][2]);\n    var sourceBottomDist = geo[1][1] - (geo[0][1] + geo[0][3]);\n    var sourceRightDist = geo[1][0] - (geo[0][0] + geo[0][2]);\n    mxEdgeStyle.vertexSeperations[1] = Math.max(sourceLeftDist - totalBuffer, 0);\n    mxEdgeStyle.vertexSeperations[2] = Math.max(sourceTopDist - totalBuffer, 0);\n    mxEdgeStyle.vertexSeperations[4] = Math.max(sourceBottomDist - totalBuffer, 0);\n    mxEdgeStyle.vertexSeperations[3] = Math.max(sourceRightDist - totalBuffer, 0);\n\n    //==============================================================\n    // Start of source and target direction determination\n\n    // Work through the preferred orientations by relative positioning\n    // of the vertices and list them in preferred and available order\n\n    var dirPref = [];\n    var horPref = [];\n    var vertPref = [];\n    horPref[0] = sourceLeftDist >= sourceRightDist ? _mxConstants[\"default\"].DIRECTION_MASK_WEST : _mxConstants[\"default\"].DIRECTION_MASK_EAST;\n    vertPref[0] = sourceTopDist >= sourceBottomDist ? _mxConstants[\"default\"].DIRECTION_MASK_NORTH : _mxConstants[\"default\"].DIRECTION_MASK_SOUTH;\n    horPref[1] = _mxGraphUtils[\"default\"].reversePortConstraints(horPref[0]);\n    vertPref[1] = _mxGraphUtils[\"default\"].reversePortConstraints(vertPref[0]);\n    var preferredHorizDist = sourceLeftDist >= sourceRightDist ? sourceLeftDist : sourceRightDist;\n    var preferredVertDist = sourceTopDist >= sourceBottomDist ? sourceTopDist : sourceBottomDist;\n    var prefOrdering = [[0, 0], [0, 0]];\n    var preferredOrderSet = false;\n\n    // If the preferred port isn't available, switch it\n    for (var i = 0; i < 2; i++) {\n      if (dir[i] != 0x0) {\n        continue;\n      }\n      if ((horPref[i] & portConstraint[i]) == 0) {\n        horPref[i] = _mxGraphUtils[\"default\"].reversePortConstraints(horPref[i]);\n      }\n      if ((vertPref[i] & portConstraint[i]) == 0) {\n        vertPref[i] = mxUtils.reversePortConstraints(vertPref[i]);\n      }\n      prefOrdering[i][0] = vertPref[i];\n      prefOrdering[i][1] = horPref[i];\n    }\n    if (preferredVertDist > 0 && preferredHorizDist > 0) {\n      // Possibility of two segment edge connection\n      if ((horPref[0] & portConstraint[0]) > 0 && (vertPref[1] & portConstraint[1]) > 0) {\n        prefOrdering[0][0] = horPref[0];\n        prefOrdering[0][1] = vertPref[0];\n        prefOrdering[1][0] = vertPref[1];\n        prefOrdering[1][1] = horPref[1];\n        preferredOrderSet = true;\n      } else if ((vertPref[0] & portConstraint[0]) > 0 && (horPref[1] & portConstraint[1]) > 0) {\n        prefOrdering[0][0] = vertPref[0];\n        prefOrdering[0][1] = horPref[0];\n        prefOrdering[1][0] = horPref[1];\n        prefOrdering[1][1] = vertPref[1];\n        preferredOrderSet = true;\n      }\n    }\n    if (preferredVertDist > 0 && !preferredOrderSet) {\n      prefOrdering[0][0] = vertPref[0];\n      prefOrdering[0][1] = horPref[0];\n      prefOrdering[1][0] = vertPref[1];\n      prefOrdering[1][1] = horPref[1];\n      preferredOrderSet = true;\n    }\n    if (preferredHorizDist > 0 && !preferredOrderSet) {\n      prefOrdering[0][0] = horPref[0];\n      prefOrdering[0][1] = vertPref[0];\n      prefOrdering[1][0] = horPref[1];\n      prefOrdering[1][1] = vertPref[1];\n      preferredOrderSet = true;\n    }\n\n    // The source and target prefs are now an ordered list of\n    // the preferred port selections\n    // It the list can contain gaps, compact it\n\n    for (var i = 0; i < 2; i++) {\n      if (dir[i] != 0x0) {\n        continue;\n      }\n      if ((prefOrdering[i][0] & portConstraint[i]) == 0) {\n        prefOrdering[i][0] = prefOrdering[i][1];\n      }\n      dirPref[i] = prefOrdering[i][0] & portConstraint[i];\n      dirPref[i] |= (prefOrdering[i][1] & portConstraint[i]) << 8;\n      dirPref[i] |= (prefOrdering[1 - i][i] & portConstraint[i]) << 16;\n      dirPref[i] |= (prefOrdering[1 - i][1 - i] & portConstraint[i]) << 24;\n      if ((dirPref[i] & 0xF) == 0) {\n        dirPref[i] = dirPref[i] << 8;\n      }\n      if ((dirPref[i] & 0xF00) == 0) {\n        dirPref[i] = dirPref[i] & 0xF | dirPref[i] >> 8;\n      }\n      if ((dirPref[i] & 0xF0000) == 0) {\n        dirPref[i] = dirPref[i] & 0xFFFF | (dirPref[i] & 0xF000000) >> 8;\n      }\n      dir[i] = dirPref[i] & 0xF;\n      if (portConstraint[i] == _mxConstants[\"default\"].DIRECTION_MASK_WEST || portConstraint[i] == _mxConstants[\"default\"].DIRECTION_MASK_NORTH || portConstraint[i] == _mxConstants[\"default\"].DIRECTION_MASK_EAST || portConstraint[i] == _mxConstants[\"default\"].DIRECTION_MASK_SOUTH) {\n        dir[i] = portConstraint[i];\n      }\n    }\n\n    //==============================================================\n    // End of source and target direction determination\n\n    var sourceIndex = dir[0] == _mxConstants[\"default\"].DIRECTION_MASK_EAST ? 3 : dir[0];\n    var targetIndex = dir[1] == _mxConstants[\"default\"].DIRECTION_MASK_EAST ? 3 : dir[1];\n    sourceIndex -= quad;\n    targetIndex -= quad;\n    if (sourceIndex < 1) {\n      sourceIndex += 4;\n    }\n    if (targetIndex < 1) {\n      targetIndex += 4;\n    }\n    var routePattern = mxEdgeStyle.routePatterns[sourceIndex - 1][targetIndex - 1];\n    mxEdgeStyle.wayPoints1[0][0] = geo[0][0];\n    mxEdgeStyle.wayPoints1[0][1] = geo[0][1];\n    switch (dir[0]) {\n      case _mxConstants[\"default\"].DIRECTION_MASK_WEST:\n        mxEdgeStyle.wayPoints1[0][0] -= scaledSourceBuffer;\n        mxEdgeStyle.wayPoints1[0][1] += constraint[0][1] * geo[0][3];\n        break;\n      case _mxConstants[\"default\"].DIRECTION_MASK_SOUTH:\n        mxEdgeStyle.wayPoints1[0][0] += constraint[0][0] * geo[0][2];\n        mxEdgeStyle.wayPoints1[0][1] += geo[0][3] + scaledSourceBuffer;\n        break;\n      case _mxConstants[\"default\"].DIRECTION_MASK_EAST:\n        mxEdgeStyle.wayPoints1[0][0] += geo[0][2] + scaledSourceBuffer;\n        mxEdgeStyle.wayPoints1[0][1] += constraint[0][1] * geo[0][3];\n        break;\n      case _mxConstants[\"default\"].DIRECTION_MASK_NORTH:\n        mxEdgeStyle.wayPoints1[0][0] += constraint[0][0] * geo[0][2];\n        mxEdgeStyle.wayPoints1[0][1] -= scaledSourceBuffer;\n        break;\n    }\n    var currentIndex = 0;\n\n    // Orientation, 0 horizontal, 1 vertical\n    var lastOrientation = (dir[0] & (_mxConstants[\"default\"].DIRECTION_MASK_EAST | _mxConstants[\"default\"].DIRECTION_MASK_WEST)) > 0 ? 0 : 1;\n    var initialOrientation = lastOrientation;\n    var currentOrientation = 0;\n    for (var i = 0; i < routePattern.length; i++) {\n      var nextDirection = routePattern[i] & 0xF;\n\n      // Rotate the index of this direction by the quad\n      // to get the real direction\n      var directionIndex = nextDirection == _mxConstants[\"default\"].DIRECTION_MASK_EAST ? 3 : nextDirection;\n      directionIndex += quad;\n      if (directionIndex > 4) {\n        directionIndex -= 4;\n      }\n      var direction = mxEdgeStyle.dirVectors[directionIndex - 1];\n      currentOrientation = directionIndex % 2 > 0 ? 0 : 1;\n      // Only update the current index if the point moved\n      // in the direction of the current segment move,\n      // otherwise the same point is moved until there is\n      // a segment direction change\n      if (currentOrientation != lastOrientation) {\n        currentIndex++;\n        // Copy the previous way point into the new one\n        // We can't base the new position on index - 1\n        // because sometime elbows turn out not to exist,\n        // then we'd have to rewind.\n        mxEdgeStyle.wayPoints1[currentIndex][0] = mxEdgeStyle.wayPoints1[currentIndex - 1][0];\n        mxEdgeStyle.wayPoints1[currentIndex][1] = mxEdgeStyle.wayPoints1[currentIndex - 1][1];\n      }\n      var tar = (routePattern[i] & mxEdgeStyle.TARGET_MASK) > 0;\n      var sou = (routePattern[i] & mxEdgeStyle.SOURCE_MASK) > 0;\n      var side = (routePattern[i] & mxEdgeStyle.SIDE_MASK) >> 5;\n      side = side << quad;\n      if (side > 0xF) {\n        side = side >> 4;\n      }\n      var center = (routePattern[i] & mxEdgeStyle.CENTER_MASK) > 0;\n      if ((sou || tar) && side < 9) {\n        var limit = 0;\n        var souTar = sou ? 0 : 1;\n        if (center && currentOrientation == 0) {\n          limit = geo[souTar][0] + constraint[souTar][0] * geo[souTar][2];\n        } else if (center) {\n          limit = geo[souTar][1] + constraint[souTar][1] * geo[souTar][3];\n        } else {\n          limit = mxEdgeStyle.limits[souTar][side];\n        }\n        if (currentOrientation == 0) {\n          var lastX = mxEdgeStyle.wayPoints1[currentIndex][0];\n          var deltaX = (limit - lastX) * direction[0];\n          if (deltaX > 0) {\n            mxEdgeStyle.wayPoints1[currentIndex][0] += direction[0] * deltaX;\n          }\n        } else {\n          var lastY = mxEdgeStyle.wayPoints1[currentIndex][1];\n          var deltaY = (limit - lastY) * direction[1];\n          if (deltaY > 0) {\n            mxEdgeStyle.wayPoints1[currentIndex][1] += direction[1] * deltaY;\n          }\n        }\n      } else if (center) {\n        // Which center we're travelling to depend on the current direction\n        mxEdgeStyle.wayPoints1[currentIndex][0] += direction[0] * Math.abs(mxEdgeStyle.vertexSeperations[directionIndex] / 2);\n        mxEdgeStyle.wayPoints1[currentIndex][1] += direction[1] * Math.abs(mxEdgeStyle.vertexSeperations[directionIndex] / 2);\n      }\n      if (currentIndex > 0 && mxEdgeStyle.wayPoints1[currentIndex][currentOrientation] == mxEdgeStyle.wayPoints1[currentIndex - 1][currentOrientation]) {\n        currentIndex--;\n      } else {\n        lastOrientation = currentOrientation;\n      }\n    }\n    for (var i = 0; i <= currentIndex; i++) {\n      if (i == currentIndex) {\n        // Last point can cause last segment to be in\n        // same direction as jetty/approach. If so,\n        // check the number of points is consistent\n        // with the relative orientation of source and target\n        // jx. Same orientation requires an even\n        // number of turns (points), different requires\n        // odd.\n        var targetOrientation = (dir[1] & (_mxConstants[\"default\"].DIRECTION_MASK_EAST | _mxConstants[\"default\"].DIRECTION_MASK_WEST)) > 0 ? 0 : 1;\n        var sameOrient = targetOrientation == initialOrientation ? 0 : 1;\n\n        // (currentIndex + 1) % 2 is 0 for even number of points,\n        // 1 for odd\n        if (sameOrient != (currentIndex + 1) % 2) {\n          // The last point isn't required\n          break;\n        }\n      }\n      result.push(new _mxPoint[\"default\"](Math.round(mxEdgeStyle.wayPoints1[i][0]), Math.round(mxEdgeStyle.wayPoints1[i][1])));\n    }\n\n    // Removes duplicates\n    var index = 1;\n    while (index < result.length) {\n      if (result[index - 1] == null || result[index] == null || result[index - 1].x != result[index].x || result[index - 1].y != result[index].y) {\n        index++;\n      } else {\n        result.splice(index, 1);\n      }\n    }\n  },\n  getRoutePattern: function getRoutePattern(dir, quad, dx, dy) {\n    var sourceIndex = dir[0] == _mxConstants[\"default\"].DIRECTION_MASK_EAST ? 3 : dir[0];\n    var targetIndex = dir[1] == _mxConstants[\"default\"].DIRECTION_MASK_EAST ? 3 : dir[1];\n    sourceIndex -= quad;\n    targetIndex -= quad;\n    if (sourceIndex < 1) {\n      sourceIndex += 4;\n    }\n    if (targetIndex < 1) {\n      targetIndex += 4;\n    }\n    var result = routePatterns[sourceIndex - 1][targetIndex - 1];\n    if (dx == 0 || dy == 0) {\n      if (inlineRoutePatterns[sourceIndex - 1][targetIndex - 1] != null) {\n        result = inlineRoutePatterns[sourceIndex - 1][targetIndex - 1];\n      }\n    }\n    return result;\n  }\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\nvar _default = exports[\"default\"] = mxEdgeStyle;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxEdgeStyle.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxEditor.js":
/*!*******************************************!*\
  !*** ./src/workflow/mxClient/mxEditor.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.filter.js */ \"../../node_modules/core-js/modules/es.array.filter.js\");\n__webpack_require__(/*! core-js/modules/es.date.to-string.js */ \"../../node_modules/core-js/modules/es.date.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.function.bind.js */ \"../../node_modules/core-js/modules/es.function.bind.js\");\n__webpack_require__(/*! core-js/modules/es.object.to-string.js */ \"../../node_modules/core-js/modules/es.object.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.parse-float.js */ \"../../node_modules/core-js/modules/es.parse-float.js\");\nvar _mxCell = _interopRequireDefault(__webpack_require__(/*! ./mxCell.js */ \"./src/workflow/mxClient/mxCell.js\"));\nvar _mxStackLayout = _interopRequireDefault(__webpack_require__(/*! ./mxStackLayout.js */ \"./src/workflow/mxClient/mxStackLayout.js\"));\nvar _mxGraph = _interopRequireDefault(__webpack_require__(/*! ./mxGraph.js */ \"./src/workflow/mxClient/mxGraph.js\"));\nvar _mxSwimlaneManager = _interopRequireDefault(__webpack_require__(/*! ./mxSwimlaneManager.js */ \"./src/workflow/mxClient/mxSwimlaneManager.js\"));\nvar _mxDefaultPopupMenu = _interopRequireDefault(__webpack_require__(/*! ./mxDefaultPopupMenu.js */ \"./src/workflow/mxClient/mxDefaultPopupMenu.js\"));\nvar _mxWindow = _interopRequireDefault(__webpack_require__(/*! ./mxWindow.js */ \"./src/workflow/mxClient/mxWindow.js\"));\nvar _mxClient = _interopRequireDefault(__webpack_require__(/*! ./mxClient.js */ \"./src/workflow/mxClient/mxClient.js\"));\nvar _mxOutline = _interopRequireDefault(__webpack_require__(/*! ./mxOutline.js */ \"./src/workflow/mxClient/mxOutline.js\"));\nvar _mxRubberband = _interopRequireDefault(__webpack_require__(/*! ./mxRubberband.js */ \"./src/workflow/mxClient/mxRubberband.js\"));\nvar _mxPrintPreview = _interopRequireDefault(__webpack_require__(/*! ./mxPrintPreview.js */ \"./src/workflow/mxClient/mxPrintPreview.js\"));\nvar _mxEventSource = _interopRequireDefault(__webpack_require__(/*! ./mxEventSource.js */ \"./src/workflow/mxClient/mxEventSource.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxLog = _interopRequireDefault(__webpack_require__(/*! ./mxLog.js */ \"./src/workflow/mxClient/mxLog.js\"));\nvar _mxDefaultKeyHandler = _interopRequireDefault(__webpack_require__(/*! ./mxDefaultKeyHandler.js */ \"./src/workflow/mxClient/mxDefaultKeyHandler.js\"));\nvar _mxEventObject = _interopRequireDefault(__webpack_require__(/*! ./mxEventObject.js */ \"./src/workflow/mxClient/mxEventObject.js\"));\nvar _mxEvent = _interopRequireDefault(__webpack_require__(/*! ./mxEvent.js */ \"./src/workflow/mxClient/mxEvent.js\"));\nvar _mxClipboard = _interopRequireDefault(__webpack_require__(/*! ./mxClipboard.js */ \"./src/workflow/mxClient/mxClipboard.js\"));\nvar _mxForm = _interopRequireDefault(__webpack_require__(/*! ./mxForm.js */ \"./src/workflow/mxClient/mxForm.js\"));\nvar _mxUndoManager = _interopRequireDefault(__webpack_require__(/*! ./mxUndoManager.js */ \"./src/workflow/mxClient/mxUndoManager.js\"));\nvar _mxCodec = _interopRequireDefault(__webpack_require__(/*! ./mxCodec.js */ \"./src/workflow/mxClient/mxCodec.js\"));\nvar _mxGeometry = _interopRequireDefault(__webpack_require__(/*! ./mxGeometry.js */ \"./src/workflow/mxClient/mxGeometry.js\"));\nvar _mxCompactTreeLayout = _interopRequireDefault(__webpack_require__(/*! ./mxCompactTreeLayout.js */ \"./src/workflow/mxClient/mxCompactTreeLayout.js\"));\nvar _mxDefaultToolbar = _interopRequireDefault(__webpack_require__(/*! ./mxDefaultToolbar.js */ \"./src/workflow/mxClient/mxDefaultToolbar.js\"));\nvar _mxCellAttributeChange = _interopRequireDefault(__webpack_require__(/*! ./mxCellAttributeChange.js */ \"./src/workflow/mxClient/mxCellAttributeChange.js\"));\nvar _mxResources = _interopRequireDefault(__webpack_require__(/*! ./mxResources.js */ \"./src/workflow/mxClient/mxResources.js\"));\nvar _mxLayoutManager = _interopRequireDefault(__webpack_require__(/*! ./mxLayoutManager.js */ \"./src/workflow/mxClient/mxLayoutManager.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ./mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nvar _mxDivResizer = _interopRequireDefault(__webpack_require__(/*! ./mxDivResizer.js */ \"./src/workflow/mxClient/mxDivResizer.js\"));\nvar _mxUtils = _interopRequireDefault(__webpack_require__(/*! ./mxUtils.js */ \"./src/workflow/mxClient/mxUtils.js\"));\nvar _mxRequestUtils = _interopRequireDefault(__webpack_require__(/*! ./mxRequestUtils.js */ \"./src/workflow/mxClient/mxRequestUtils.js\"));\nvar _mxValueChange = _interopRequireDefault(__webpack_require__(/*! ./mxValueChange.js */ \"./src/workflow/mxClient/mxValueChange.js\"));\nvar _mxRootChange = _interopRequireDefault(__webpack_require__(/*! ./mxRootChange.js */ \"./src/workflow/mxClient/mxRootChange.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxEditor(config) {\n  this.actions = [];\n  this.addActions();\n\n  // Executes the following only if a document has been instanciated.\n  // That is, don't execute when the editorcodec is setup.\n  if (document.body != null) {\n    // Defines instance fields\n    this.cycleAttributeValues = [];\n    this.popupHandler = new _mxDefaultPopupMenu[\"default\"]();\n    this.undoManager = new _mxUndoManager[\"default\"]();\n\n    // Creates the graph and toolbar without the containers\n    this.graph = this.createGraph();\n    this.toolbar = this.createToolbar();\n\n    // Creates the global keyhandler (requires graph instance)\n    this.keyHandler = new _mxDefaultKeyHandler[\"default\"](this);\n\n    // Configures the editor using the URI\n    // which was passed to the ctor\n    this.configure(config);\n\n    // Assigns the swimlaneIndicatorColorAttribute on the graph\n    this.graph.swimlaneIndicatorColorAttribute = this.cycleAttributeName;\n\n    // Checks if the <onInit> hook has been set\n    if (this.onInit != null) {\n      // Invokes the <onInit> hook\n      this.onInit();\n    }\n\n    // Automatic deallocation of memory\n    if (_mxClient[\"default\"].IS_IE) {\n      _mxEvent[\"default\"].addListener(window, 'unload', _mxGraphUtils[\"default\"].bind(this, function () {\n        this.destroy();\n      }));\n    }\n  }\n}\n;\n\n/**\r\n * Installs the required language resources at class\r\n * loading time.\r\n */\n/*if (mxLoadResources)\r\n{\r\n\tmxResources.add(mxClient.basePath+'/resources/editor');\r\n}*/\n\n/**\r\n * Extends mxEventSource.\r\n */\nmxEditor.prototype = new _mxEventSource[\"default\"]();\nmxEditor.prototype.constructor = mxEditor;\n\n/**\r\n * Group: Controls and Handlers\r\n */\n\n/**\r\n * Variable: askZoomResource\r\n *\r\n * Specifies the resource key for the zoom dialog. If the resource for this\r\n * key does not exist then the value is used as the error message. Default\r\n * is 'askZoom'.\r\n */\nmxEditor.prototype.askZoomResource = _mxClient[\"default\"].language != 'none' ? 'askZoom' : '';\n\n/**\r\n * Variable: lastSavedResource\r\n *\r\n * Specifies the resource key for the last saved info. If the resource for\r\n * this key does not exist then the value is used as the error message.\r\n * Default is 'lastSaved'.\r\n */\nmxEditor.prototype.lastSavedResource = _mxClient[\"default\"].language != 'none' ? 'lastSaved' : '';\n\n/**\r\n * Variable: currentFileResource\r\n *\r\n * Specifies the resource key for the current file info. If the resource for\r\n * this key does not exist then the value is used as the error message.\r\n * Default is 'lastSaved'.\r\n */\nmxEditor.prototype.currentFileResource = _mxClient[\"default\"].language != 'none' ? 'currentFile' : '';\n\n/**\r\n * Variable: propertiesResource\r\n *\r\n * Specifies the resource key for the properties window title. If the\r\n * resource for this key does not exist then the value is used as the\r\n * error message. Default is 'properties'.\r\n */\nmxEditor.prototype.propertiesResource = _mxClient[\"default\"].language != 'none' ? 'properties' : '';\n\n/**\r\n * Variable: tasksResource\r\n *\r\n * Specifies the resource key for the tasks window title. If the\r\n * resource for this key does not exist then the value is used as the\r\n * error message. Default is 'tasks'.\r\n */\nmxEditor.prototype.tasksResource = _mxClient[\"default\"].language != 'none' ? 'tasks' : '';\n\n/**\r\n * Variable: helpResource\r\n *\r\n * Specifies the resource key for the help window title. If the\r\n * resource for this key does not exist then the value is used as the\r\n * error message. Default is 'help'.\r\n */\nmxEditor.prototype.helpResource = _mxClient[\"default\"].language != 'none' ? 'help' : '';\n\n/**\r\n * Variable: outlineResource\r\n *\r\n * Specifies the resource key for the outline window title. If the\r\n * resource for this key does not exist then the value is used as the\r\n * error message. Default is 'outline'.\r\n */\nmxEditor.prototype.outlineResource = _mxClient[\"default\"].language != 'none' ? 'outline' : '';\n\n/**\r\n * Variable: outline\r\n *\r\n * Reference to the <mxWindow> that contains the outline. The <mxOutline>\r\n * is stored in outline.outline.\r\n */\nmxEditor.prototype.outline = null;\n\n/**\r\n * Variable: graph\r\n *\r\n * Holds a <mxGraph> for displaying the diagram. The graph\r\n * is created in <setGraphContainer>.\r\n */\nmxEditor.prototype.graph = null;\n\n/**\r\n * Variable: graphRenderHint\r\n *\r\n * Holds the render hint used for creating the\r\n * graph in <setGraphContainer>. See <mxGraph>.\r\n * Default is null.\r\n */\nmxEditor.prototype.graphRenderHint = null;\n\n/**\r\n * Variable: toolbar\r\n *\r\n * Holds a <mxDefaultToolbar> for displaying the toolbar. The\r\n * toolbar is created in <setToolbarContainer>.\r\n */\nmxEditor.prototype.toolbar = null;\n\n/**\r\n * Variable: status\r\n *\r\n * DOM container that holds the statusbar. Default is null.\r\n * Use <setStatusContainer> to set this value.\r\n */\nmxEditor.prototype.status = null;\n\n/**\r\n * Variable: popupHandler\r\n *\r\n * Holds a <mxDefaultPopupMenu> for displaying\r\n * popupmenus.\r\n */\nmxEditor.prototype.popupHandler = null;\n\n/**\r\n * Variable: undoManager\r\n *\r\n * Holds an <mxUndoManager> for the command history.\r\n */\nmxEditor.prototype.undoManager = null;\n\n/**\r\n * Variable: keyHandler\r\n *\r\n * Holds a <mxDefaultKeyHandler> for handling keyboard events.\r\n * The handler is created in <setGraphContainer>.\r\n */\nmxEditor.prototype.keyHandler = null;\n\n/**\r\n * Group: Actions and Options\r\n */\n\n/**\r\n * Variable: actions\r\n *\r\n * Maps from actionnames to actions, which are functions taking\r\n * the editor and the cell as arguments. Use <addAction>\r\n * to add or replace an action and <execute> to execute an action\r\n * by name, passing the cell to be operated upon as the second\r\n * argument.\r\n */\nmxEditor.prototype.actions = null;\n\n/**\r\n * Variable: dblClickAction\r\n *\r\n * Specifies the name of the action to be executed\r\n * when a cell is double clicked. Default is edit.\r\n *\r\n * To handle a singleclick, use the following code.\r\n *\r\n * (code)\r\n * editor.graph.addListener(mxEvent.CLICK, function(sender, evt)\r\n * {\r\n *   var e = evt.getProperty('event');\r\n *   var cell = evt.getProperty('cell');\r\n *\r\n *   if (cell != null && !e.isConsumed())\r\n *   {\r\n *     // Do something useful with cell...\r\n *     e.consume();\r\n *   }\r\n * });\r\n * (end)\r\n */\nmxEditor.prototype.dblClickAction = 'edit';\n\n/**\r\n * Variable: swimlaneRequired\r\n *\r\n * Specifies if new cells must be inserted\r\n * into an existing swimlane. Otherwise, cells\r\n * that are not swimlanes can be inserted as\r\n * top-level cells. Default is false.\r\n */\nmxEditor.prototype.swimlaneRequired = false;\n\n/**\r\n * Variable: disableContextMenu\r\n *\r\n * Specifies if the context menu should be disabled in the graph container.\r\n * Default is true.\r\n */\nmxEditor.prototype.disableContextMenu = true;\n\n/**\r\n * Group: Templates\r\n */\n\n/**\r\n * Variable: insertFunction\r\n *\r\n * Specifies the function to be used for inserting new\r\n * cells into the graph. This is assigned from the\r\n * <mxDefaultToolbar> if a vertex-tool is clicked.\r\n */\nmxEditor.prototype.insertFunction = null;\n\n/**\r\n * Variable: forcedInserting\r\n *\r\n * Specifies if a new cell should be inserted on a single\r\n * click even using <insertFunction> if there is a cell\r\n * under the mousepointer, otherwise the cell under the\r\n * mousepointer is selected. Default is false.\r\n */\nmxEditor.prototype.forcedInserting = false;\n\n/**\r\n * Variable: templates\r\n *\r\n * Maps from names to protoype cells to be used\r\n * in the toolbar for inserting new cells into\r\n * the diagram.\r\n */\nmxEditor.prototype.templates = null;\n\n/**\r\n * Variable: defaultEdge\r\n *\r\n * Prototype edge cell that is used for creating\r\n * new edges.\r\n */\nmxEditor.prototype.defaultEdge = null;\n\n/**\r\n * Variable: defaultEdgeStyle\r\n *\r\n * Specifies the edge style to be returned in <getEdgeStyle>.\r\n * Default is null.\r\n */\nmxEditor.prototype.defaultEdgeStyle = null;\n\n/**\r\n * Variable: defaultGroup\r\n *\r\n * Prototype group cell that is used for creating\r\n * new groups.\r\n */\nmxEditor.prototype.defaultGroup = null;\n\n/**\r\n * Variable: graphRenderHint\r\n *\r\n * Default size for the border of new groups. If null,\r\n * then then <mxGraph.gridSize> is used. Default is\r\n * null.\r\n */\nmxEditor.prototype.groupBorderSize = null;\n\n/**\r\n * Group: Backend Integration\r\n */\n\n/**\r\n * Variable: filename\r\n *\r\n * Contains the URL of the last opened file as a string.\r\n * Default is null.\r\n */\nmxEditor.prototype.filename = null;\n\n/**\r\n * Variable: lineFeed\r\n *\r\n * Character to be used for encoding linefeeds in <save>. Default is '&#xa;'.\r\n */\nmxEditor.prototype.linefeed = '&#xa;';\n\n/**\r\n * Variable: postParameterName\r\n *\r\n * Specifies if the name of the post parameter that contains the diagram\r\n * data in a post request to the server. Default is xml.\r\n */\nmxEditor.prototype.postParameterName = 'xml';\n\n/**\r\n * Variable: escapePostData\r\n *\r\n * Specifies if the data in the post request for saving a diagram\r\n * should be converted using encodeURIComponent. Default is true.\r\n */\nmxEditor.prototype.escapePostData = true;\n\n/**\r\n * Variable: urlPost\r\n *\r\n * Specifies the URL to be used for posting the diagram\r\n * to a backend in <save>.\r\n */\nmxEditor.prototype.urlPost = null;\n\n/**\r\n * Variable: urlImage\r\n *\r\n * Specifies the URL to be used for creating a bitmap of\r\n * the graph in the image action.\r\n */\nmxEditor.prototype.urlImage = null;\n\n/**\r\n * Group: Autolayout\r\n */\n\n/**\r\n * Variable: horizontalFlow\r\n *\r\n * Specifies the direction of the flow\r\n * in the diagram. This is used in the\r\n * layout algorithms. Default is false,\r\n * ie. vertical flow.\r\n */\nmxEditor.prototype.horizontalFlow = false;\n\n/**\r\n * Variable: layoutDiagram\r\n *\r\n * Specifies if the top-level elements in the\r\n * diagram should be layed out using a vertical\r\n * or horizontal stack depending on the setting\r\n * of <horizontalFlow>. The spacing between the\r\n * swimlanes is specified by <swimlaneSpacing>.\r\n * Default is false.\r\n *\r\n * If the top-level elements are swimlanes, then\r\n * the intra-swimlane layout is activated by\r\n * the <layoutSwimlanes> switch.\r\n */\nmxEditor.prototype.layoutDiagram = false;\n\n/**\r\n * Variable: swimlaneSpacing\r\n *\r\n * Specifies the spacing between swimlanes if\r\n * automatic layout is turned on in\r\n * <layoutDiagram>. Default is 0.\r\n */\nmxEditor.prototype.swimlaneSpacing = 0;\n\n/**\r\n * Variable: maintainSwimlanes\r\n *\r\n * Specifies if the swimlanes should be kept at the same\r\n * width or height depending on the setting of\r\n * <horizontalFlow>.  Default is false.\r\n *\r\n * For horizontal flows, all swimlanes\r\n * have the same height and for vertical flows, all swimlanes\r\n * have the same width. Furthermore, the swimlanes are\r\n * automatically \"stacked\" if <layoutDiagram> is true.\r\n */\nmxEditor.prototype.maintainSwimlanes = false;\n\n/**\r\n * Variable: layoutSwimlanes\r\n *\r\n * Specifies if the children of swimlanes should\r\n * be layed out, either vertically or horizontally\r\n * depending on <horizontalFlow>.\r\n * Default is false.\r\n */\nmxEditor.prototype.layoutSwimlanes = false;\n\n/**\r\n * Group: Attribute Cycling\r\n */\n\n/**\r\n * Variable: cycleAttributeValues\r\n *\r\n * Specifies the attribute values to be cycled when\r\n * inserting new swimlanes. Default is an empty\r\n * array.\r\n */\nmxEditor.prototype.cycleAttributeValues = null;\n\n/**\r\n * Variable: cycleAttributeIndex\r\n *\r\n * Index of the last consumed attribute index. If a new\r\n * swimlane is inserted, then the <cycleAttributeValues>\r\n * at this index will be used as the value for\r\n * <cycleAttributeName>. Default is 0.\r\n */\nmxEditor.prototype.cycleAttributeIndex = 0;\n\n/**\r\n * Variable: cycleAttributeName\r\n *\r\n * Name of the attribute to be assigned a <cycleAttributeValues>\r\n * when inserting new swimlanes. Default is fillColor.\r\n */\nmxEditor.prototype.cycleAttributeName = 'fillColor';\n\n/**\r\n * Group: Windows\r\n */\n\n/**\r\n * Variable: tasks\r\n *\r\n * Holds the <mxWindow> created in <showTasks>.\r\n */\nmxEditor.prototype.tasks = null;\n\n/**\r\n * Variable: tasksWindowImage\r\n *\r\n * Icon for the tasks window.\r\n */\nmxEditor.prototype.tasksWindowImage = null;\n\n/**\r\n * Variable: tasksTop\r\n *\r\n * Specifies the top coordinate of the tasks window in pixels.\r\n * Default is 20.\r\n */\nmxEditor.prototype.tasksTop = 20;\n\n/**\r\n * Variable: help\r\n *\r\n * Holds the <mxWindow> created in <showHelp>.\r\n */\nmxEditor.prototype.help = null;\n\n/**\r\n * Variable: helpWindowImage\r\n *\r\n * Icon for the help window.\r\n */\nmxEditor.prototype.helpWindowImage = null;\n\n/**\r\n * Variable: urlHelp\r\n *\r\n * Specifies the URL to be used for the contents of the\r\n * Online Help window. This is usually specified in the\r\n * resources file under urlHelp for language-specific\r\n * online help support.\r\n */\nmxEditor.prototype.urlHelp = null;\n\n/**\r\n * Variable: helpWidth\r\n *\r\n * Specifies the width of the help window in pixels.\r\n * Default is 300.\r\n */\nmxEditor.prototype.helpWidth = 300;\n\n/**\r\n * Variable: helpWidth\r\n *\r\n * Specifies the width of the help window in pixels.\r\n * Default is 260.\r\n */\nmxEditor.prototype.helpHeight = 260;\n\n/**\r\n * Variable: propertiesWidth\r\n *\r\n * Specifies the width of the properties window in pixels.\r\n * Default is 240.\r\n */\nmxEditor.prototype.propertiesWidth = 240;\n\n/**\r\n * Variable: propertiesHeight\r\n *\r\n * Specifies the height of the properties window in pixels.\r\n * If no height is specified then the window will be automatically\r\n * sized to fit its contents. Default is null.\r\n */\nmxEditor.prototype.propertiesHeight = null;\n\n/**\r\n * Variable: movePropertiesDialog\r\n *\r\n * Specifies if the properties dialog should be automatically\r\n * moved near the cell it is displayed for, otherwise the\r\n * dialog is not moved. This value is only taken into\r\n * account if the dialog is already visible. Default is false.\r\n */\nmxEditor.prototype.movePropertiesDialog = false;\n\n/**\r\n * Variable: validating\r\n *\r\n * Specifies if <mxGraph.validateGraph> should automatically be invoked after\r\n * each change. Default is false.\r\n */\nmxEditor.prototype.validating = false;\n\n/**\r\n * Variable: modified\r\n *\r\n * True if the graph has been modified since it was last saved.\r\n */\nmxEditor.prototype.modified = false;\n\n/**\r\n * Function: isModified\r\n *\r\n * Returns <modified>.\r\n */\nmxEditor.prototype.isModified = function () {\n  return this.modified;\n};\n\n/**\r\n * Function: setModified\r\n *\r\n * Sets <modified> to the specified boolean value.\r\n */\nmxEditor.prototype.setModified = function (value) {\n  this.modified = value;\n};\n\n/**\r\n * Function: addActions\r\n *\r\n * Adds the built-in actions to the editor instance.\r\n *\r\n * save - Saves the graph using <urlPost>.\r\n * print - Shows the graph in a new print preview window.\r\n * show - Shows the graph in a new window.\r\n * exportImage - Shows the graph as a bitmap image using <getUrlImage>.\r\n * refresh - Refreshes the graph's display.\r\n * cut - Copies the current selection into the clipboard\r\n * and removes it from the graph.\r\n * copy - Copies the current selection into the clipboard.\r\n * paste - Pastes the clipboard into the graph.\r\n * delete - Removes the current selection from the graph.\r\n * group - Puts the current selection into a new group.\r\n * ungroup - Removes the selected groups and selects the children.\r\n * undo - Undoes the last change on the graph model.\r\n * redo - Redoes the last change on the graph model.\r\n * zoom - Sets the zoom via a dialog.\r\n * zoomIn - Zooms into the graph.\r\n * zoomOut - Zooms out of the graph\r\n * actualSize - Resets the scale and translation on the graph.\r\n * fit - Changes the scale so that the graph fits into the window.\r\n * showProperties - Shows the properties dialog.\r\n * selectAll - Selects all cells.\r\n * selectNone - Clears the selection.\r\n * selectVertices - Selects all vertices.\r\n * selectEdges = Selects all edges.\r\n * edit - Starts editing the current selection cell.\r\n * enterGroup - Drills down into the current selection cell.\r\n * exitGroup - Moves up in the drilling hierachy\r\n * home - Moves to the topmost parent in the drilling hierarchy\r\n * selectPrevious - Selects the previous cell.\r\n * selectNext - Selects the next cell.\r\n * selectParent - Selects the parent of the selection cell.\r\n * selectChild - Selects the first child of the selection cell.\r\n * collapse - Collapses the currently selected cells.\r\n * expand - Expands the currently selected cells.\r\n * bold - Toggle bold text style.\r\n * italic - Toggle italic text style.\r\n * underline - Toggle underline text style.\r\n * alignCellsLeft - Aligns the selection cells at the left.\r\n * alignCellsCenter - Aligns the selection cells in the center.\r\n * alignCellsRight - Aligns the selection cells at the right.\r\n * alignCellsTop - Aligns the selection cells at the top.\r\n * alignCellsMiddle - Aligns the selection cells in the middle.\r\n * alignCellsBottom - Aligns the selection cells at the bottom.\r\n * alignFontLeft - Sets the horizontal text alignment to left.\r\n * alignFontCenter - Sets the horizontal text alignment to center.\r\n * alignFontRight - Sets the horizontal text alignment to right.\r\n * alignFontTop - Sets the vertical text alignment to top.\r\n * alignFontMiddle - Sets the vertical text alignment to middle.\r\n * alignFontBottom - Sets the vertical text alignment to bottom.\r\n * toggleTasks - Shows or hides the tasks window.\r\n * toggleHelp - Shows or hides the help window.\r\n * toggleOutline - Shows or hides the outline window.\r\n * toggleConsole - Shows or hides the console window.\r\n */\nmxEditor.prototype.addActions = function () {\n  this.addAction('save', function (editor) {\n    editor.save();\n  });\n  this.addAction('print', function (editor) {\n    var preview = new _mxPrintPreview[\"default\"](editor.graph, 1);\n    preview.open();\n  });\n  this.addAction('show', function (editor) {\n    _mxUtils[\"default\"].show(editor.graph, null, 10, 10);\n  });\n  this.addAction('exportImage', function (editor) {\n    var url = editor.getUrlImage();\n    if (url == null || _mxClient[\"default\"].IS_LOCAL) {\n      editor.execute('show');\n    } else {\n      var node = _mxUtils[\"default\"].getViewXml(editor.graph, 1);\n      var xml = _mxUtils[\"default\"].getXml(node, '\\n');\n      _mxUtils[\"default\"].submit(url, editor.postParameterName + '=' + encodeURIComponent(xml), document, '_blank');\n    }\n  });\n  this.addAction('refresh', function (editor) {\n    editor.graph.refresh();\n  });\n  this.addAction('cut', function (editor) {\n    if (editor.graph.isEnabled()) {\n      _mxClipboard[\"default\"].cut(editor.graph);\n    }\n  });\n  this.addAction('copy', function (editor) {\n    if (editor.graph.isEnabled()) {\n      _mxClipboard[\"default\"].copy(editor.graph);\n    }\n  });\n  this.addAction('paste', function (editor) {\n    if (editor.graph.isEnabled()) {\n      _mxClipboard[\"default\"].paste(editor.graph);\n    }\n  });\n  this.addAction('delete', function (editor) {\n    if (editor.graph.isEnabled()) {\n      editor.graph.removeCells();\n    }\n  });\n  this.addAction('group', function (editor) {\n    if (editor.graph.isEnabled()) {\n      editor.graph.setSelectionCell(editor.groupCells());\n    }\n  });\n  this.addAction('ungroup', function (editor) {\n    if (editor.graph.isEnabled()) {\n      editor.graph.setSelectionCells(editor.graph.ungroupCells());\n    }\n  });\n  this.addAction('removeFromParent', function (editor) {\n    if (editor.graph.isEnabled()) {\n      editor.graph.removeCellsFromParent();\n    }\n  });\n  this.addAction('undo', function (editor) {\n    if (editor.graph.isEnabled()) {\n      editor.undo();\n    }\n  });\n  this.addAction('redo', function (editor) {\n    if (editor.graph.isEnabled()) {\n      editor.redo();\n    }\n  });\n  this.addAction('zoomIn', function (editor) {\n    editor.graph.zoomIn();\n  });\n  this.addAction('zoomOut', function (editor) {\n    editor.graph.zoomOut();\n  });\n  this.addAction('actualSize', function (editor) {\n    editor.graph.zoomActual();\n  });\n  this.addAction('fit', function (editor) {\n    editor.graph.fit();\n  });\n  this.addAction('showProperties', function (editor, cell) {\n    editor.showProperties(cell);\n  });\n  this.addAction('selectAll', function (editor) {\n    if (editor.graph.isEnabled()) {\n      editor.graph.selectAll();\n    }\n  });\n  this.addAction('selectNone', function (editor) {\n    if (editor.graph.isEnabled()) {\n      editor.graph.clearSelection();\n    }\n  });\n  this.addAction('selectVertices', function (editor) {\n    if (editor.graph.isEnabled()) {\n      editor.graph.selectVertices();\n    }\n  });\n  this.addAction('selectEdges', function (editor) {\n    if (editor.graph.isEnabled()) {\n      editor.graph.selectEdges();\n    }\n  });\n  this.addAction('edit', function (editor, cell) {\n    if (editor.graph.isEnabled() && editor.graph.isCellEditable(cell)) {\n      editor.graph.startEditingAtCell(cell);\n    }\n  });\n  this.addAction('toBack', function (editor, cell) {\n    if (editor.graph.isEnabled()) {\n      editor.graph.orderCells(true);\n    }\n  });\n  this.addAction('toFront', function (editor, cell) {\n    if (editor.graph.isEnabled()) {\n      editor.graph.orderCells(false);\n    }\n  });\n  this.addAction('enterGroup', function (editor, cell) {\n    editor.graph.enterGroup(cell);\n  });\n  this.addAction('exitGroup', function (editor) {\n    editor.graph.exitGroup();\n  });\n  this.addAction('home', function (editor) {\n    editor.graph.home();\n  });\n  this.addAction('selectPrevious', function (editor) {\n    if (editor.graph.isEnabled()) {\n      editor.graph.selectPreviousCell();\n    }\n  });\n  this.addAction('selectNext', function (editor) {\n    if (editor.graph.isEnabled()) {\n      editor.graph.selectNextCell();\n    }\n  });\n  this.addAction('selectParent', function (editor) {\n    if (editor.graph.isEnabled()) {\n      editor.graph.selectParentCell();\n    }\n  });\n  this.addAction('selectChild', function (editor) {\n    if (editor.graph.isEnabled()) {\n      editor.graph.selectChildCell();\n    }\n  });\n  this.addAction('collapse', function (editor) {\n    if (editor.graph.isEnabled()) {\n      editor.graph.foldCells(true);\n    }\n  });\n  this.addAction('collapseAll', function (editor) {\n    if (editor.graph.isEnabled()) {\n      var cells = editor.graph.getChildVertices();\n      editor.graph.foldCells(true, false, cells);\n    }\n  });\n  this.addAction('expand', function (editor) {\n    if (editor.graph.isEnabled()) {\n      editor.graph.foldCells(false);\n    }\n  });\n  this.addAction('expandAll', function (editor) {\n    if (editor.graph.isEnabled()) {\n      var cells = editor.graph.getChildVertices();\n      editor.graph.foldCells(false, false, cells);\n    }\n  });\n  this.addAction('bold', function (editor) {\n    if (editor.graph.isEnabled()) {\n      editor.graph.toggleCellStyleFlags(_mxConstants[\"default\"].STYLE_FONTSTYLE, _mxConstants[\"default\"].FONT_BOLD);\n    }\n  });\n  this.addAction('italic', function (editor) {\n    if (editor.graph.isEnabled()) {\n      editor.graph.toggleCellStyleFlags(_mxConstants[\"default\"].STYLE_FONTSTYLE, _mxConstants[\"default\"].FONT_ITALIC);\n    }\n  });\n  this.addAction('underline', function (editor) {\n    if (editor.graph.isEnabled()) {\n      editor.graph.toggleCellStyleFlags(_mxConstants[\"default\"].STYLE_FONTSTYLE, _mxConstants[\"default\"].FONT_UNDERLINE);\n    }\n  });\n  this.addAction('alignCellsLeft', function (editor) {\n    if (editor.graph.isEnabled()) {\n      editor.graph.alignCells(_mxConstants[\"default\"].ALIGN_LEFT);\n    }\n  });\n  this.addAction('alignCellsCenter', function (editor) {\n    if (editor.graph.isEnabled()) {\n      editor.graph.alignCells(_mxConstants[\"default\"].ALIGN_CENTER);\n    }\n  });\n  this.addAction('alignCellsRight', function (editor) {\n    if (editor.graph.isEnabled()) {\n      editor.graph.alignCells(_mxConstants[\"default\"].ALIGN_RIGHT);\n    }\n  });\n  this.addAction('alignCellsTop', function (editor) {\n    if (editor.graph.isEnabled()) {\n      editor.graph.alignCells(_mxConstants[\"default\"].ALIGN_TOP);\n    }\n  });\n  this.addAction('alignCellsMiddle', function (editor) {\n    if (editor.graph.isEnabled()) {\n      editor.graph.alignCells(_mxConstants[\"default\"].ALIGN_MIDDLE);\n    }\n  });\n  this.addAction('alignCellsBottom', function (editor) {\n    if (editor.graph.isEnabled()) {\n      editor.graph.alignCells(_mxConstants[\"default\"].ALIGN_BOTTOM);\n    }\n  });\n  this.addAction('alignFontLeft', function (editor) {\n    editor.graph.setCellStyles(_mxConstants[\"default\"].STYLE_ALIGN, _mxConstants[\"default\"].ALIGN_LEFT);\n  });\n  this.addAction('alignFontCenter', function (editor) {\n    if (editor.graph.isEnabled()) {\n      editor.graph.setCellStyles(_mxConstants[\"default\"].STYLE_ALIGN, _mxConstants[\"default\"].ALIGN_CENTER);\n    }\n  });\n  this.addAction('alignFontRight', function (editor) {\n    if (editor.graph.isEnabled()) {\n      editor.graph.setCellStyles(_mxConstants[\"default\"].STYLE_ALIGN, _mxConstants[\"default\"].ALIGN_RIGHT);\n    }\n  });\n  this.addAction('alignFontTop', function (editor) {\n    if (editor.graph.isEnabled()) {\n      editor.graph.setCellStyles(_mxConstants[\"default\"].STYLE_VERTICAL_ALIGN, _mxConstants[\"default\"].ALIGN_TOP);\n    }\n  });\n  this.addAction('alignFontMiddle', function (editor) {\n    if (editor.graph.isEnabled()) {\n      editor.graph.setCellStyles(_mxConstants[\"default\"].STYLE_VERTICAL_ALIGN, _mxConstants[\"default\"].ALIGN_MIDDLE);\n    }\n  });\n  this.addAction('alignFontBottom', function (editor) {\n    if (editor.graph.isEnabled()) {\n      editor.graph.setCellStyles(_mxConstants[\"default\"].STYLE_VERTICAL_ALIGN, _mxConstants[\"default\"].ALIGN_BOTTOM);\n    }\n  });\n  this.addAction('zoom', function (editor) {\n    var current = editor.graph.getView().scale * 100;\n    var scale = parseFloat(_mxUtils[\"default\"].prompt(_mxResources[\"default\"].get(editor.askZoomResource) || editor.askZoomResource, current)) / 100;\n    if (!isNaN(scale)) {\n      editor.graph.getView().setScale(scale);\n    }\n  });\n  this.addAction('toggleTasks', function (editor) {\n    if (editor.tasks != null) {\n      editor.tasks.setVisible(!editor.tasks.isVisible());\n    } else {\n      editor.showTasks();\n    }\n  });\n  this.addAction('toggleHelp', function (editor) {\n    if (editor.help != null) {\n      editor.help.setVisible(!editor.help.isVisible());\n    } else {\n      editor.showHelp();\n    }\n  });\n  this.addAction('toggleOutline', function (editor) {\n    if (editor.outline == null) {\n      editor.showOutline();\n    } else {\n      editor.outline.setVisible(!editor.outline.isVisible());\n    }\n  });\n  this.addAction('toggleConsole', function (editor) {\n    _mxLog[\"default\"].setVisible(!_mxLog[\"default\"].isVisible());\n  });\n};\n\n/**\r\n * Function: configure\r\n *\r\n * Configures the editor using the specified node. To load the\r\n * configuration from a given URL the following code can be used to obtain\r\n * the XML node.\r\n *\r\n * (code)\r\n * var node = mxRequestUtils.load(url).getDocumentElement();\r\n * (end)\r\n *\r\n * Parameters:\r\n *\r\n * node - XML node that contains the configuration.\r\n */\nmxEditor.prototype.configure = function (node) {\n  if (node != null) {\n    // Creates a decoder for the XML data\n    // and uses it to configure the editor\n    var dec = new _mxCodec[\"default\"](node.ownerDocument);\n    dec.decode(node, this);\n\n    // Resets the counters, modified state and\n    // command history\n    this.resetHistory();\n  }\n};\n\n/**\r\n * Function: resetFirstTime\r\n *\r\n * Resets the cookie that is used to remember if the editor has already\r\n * been used.\r\n */\nmxEditor.prototype.resetFirstTime = function () {\n  document.cookie = 'mxgraph=seen; expires=Fri, 27 Jul 2001 02:47:11 UTC; path=/';\n};\n\n/**\r\n * Function: resetHistory\r\n *\r\n * Resets the command history, modified state and counters.\r\n */\nmxEditor.prototype.resetHistory = function () {\n  this.lastSnapshot = new Date().getTime();\n  this.undoManager.clear();\n  this.ignoredChanges = 0;\n  this.setModified(false);\n};\n\n/**\r\n * Function: addAction\r\n *\r\n * Binds the specified actionname to the specified function.\r\n *\r\n * Parameters:\r\n *\r\n * actionname - String that specifies the name of the action\r\n * to be added.\r\n * funct - Function that implements the new action. The first\r\n * argument of the function is the editor it is used\r\n * with, the second argument is the cell it operates\r\n * upon.\r\n *\r\n * Example:\r\n * (code)\r\n * editor.addAction('test', function(editor, cell)\r\n * {\r\n * \t\tmxUtils.alert(\"test \"+cell);\r\n * });\r\n * (end)\r\n */\nmxEditor.prototype.addAction = function (actionname, funct) {\n  this.actions[actionname] = funct;\n};\n\n/**\r\n * Function: execute\r\n *\r\n * Executes the function with the given name in <actions> passing the\r\n * editor instance and given cell as the first and second argument. All\r\n * additional arguments are passed to the action as well. This method\r\n * contains a try-catch block and displays an error message if an action\r\n * causes an exception. The exception is re-thrown after the error\r\n * message was displayed.\r\n *\r\n * Example:\r\n *\r\n * (code)\r\n * editor.execute(\"showProperties\", cell);\r\n * (end)\r\n */\nmxEditor.prototype.execute = function (actionname, cell, evt) {\n  var action = this.actions[actionname];\n  if (action != null) {\n    try {\n      // Creates the array of arguments by replacing the actionname\n      // with the editor instance in the args of this function\n      var args = arguments;\n      args[0] = this;\n\n      // Invokes the function on the editor using the args\n      action.apply(this, args);\n    } catch (e) {\n      _mxUtils[\"default\"].error('Cannot execute ' + actionname + ': ' + e.message, 280, true);\n      throw e;\n    }\n  } else {\n    _mxUtils[\"default\"].error('Cannot find action ' + actionname, 280, true);\n  }\n};\n\n/**\r\n * Function: addTemplate\r\n *\r\n * Adds the specified template under the given name in <templates>.\r\n */\nmxEditor.prototype.addTemplate = function (name, template) {\n  this.templates[name] = template;\n};\n\n/**\r\n * Function: getTemplate\r\n *\r\n * Returns the template for the given name.\r\n */\nmxEditor.prototype.getTemplate = function (name) {\n  return this.templates[name];\n};\n\n/**\r\n * Function: createGraph\r\n *\r\n * Creates the <graph> for the editor. The graph is created with no\r\n * container and is initialized from <setGraphContainer>.\r\n */\nmxEditor.prototype.createGraph = function () {\n  var graph = new _mxGraph[\"default\"](null, null, this.graphRenderHint);\n\n  // Enables rubberband, tooltips, panning\n  graph.setTooltips(true);\n  graph.setPanning(true);\n\n  // Overrides the dblclick method on the graph to\n  // invoke the dblClickAction for a cell and reset\n  // the selection tool in the toolbar\n  this.installDblClickHandler(graph);\n\n  // Installs the command history\n  this.installUndoHandler(graph);\n\n  // Installs the handlers for the root event\n  this.installDrillHandler(graph);\n\n  // Installs the handler for validation\n  this.installChangeHandler(graph);\n\n  // Installs the handler for calling the\n  // insert function and consume the\n  // event if an insert function is defined\n  this.installInsertHandler(graph);\n\n  // Redirects the function for creating the\n  // popupmenu items\n  graph.popupMenuHandler.factoryMethod = _mxGraphUtils[\"default\"].bind(this, function (menu, cell, evt) {\n    return this.createPopupMenu(menu, cell, evt);\n  });\n\n  // Redirects the function for creating\n  // new connections in the diagram\n  graph.connectionHandler.factoryMethod = _mxGraphUtils[\"default\"].bind(this, function (source, target) {\n    return this.createEdge(source, target);\n  });\n\n  // Maintains swimlanes and installs autolayout\n  this.createSwimlaneManager(graph);\n  this.createLayoutManager(graph);\n  return graph;\n};\n\n/**\r\n * Function: createSwimlaneManager\r\n *\r\n * Sets the graph's container using <mxGraph.init>.\r\n */\nmxEditor.prototype.createSwimlaneManager = function (graph) {\n  var swimlaneMgr = new _mxSwimlaneManager[\"default\"](graph, false);\n  swimlaneMgr.isHorizontal = _mxGraphUtils[\"default\"].bind(this, function () {\n    return this.horizontalFlow;\n  });\n  swimlaneMgr.isEnabled = _mxGraphUtils[\"default\"].bind(this, function () {\n    return this.maintainSwimlanes;\n  });\n  return swimlaneMgr;\n};\n\n/**\r\n * Function: createLayoutManager\r\n *\r\n * Creates a layout manager for the swimlane and diagram layouts, that\r\n * is, the locally defined inter- and intraswimlane layouts.\r\n */\nmxEditor.prototype.createLayoutManager = function (graph) {\n  var layoutMgr = new _mxLayoutManager[\"default\"](graph);\n  var self = this; // closure\n  layoutMgr.getLayout = function (cell) {\n    var layout = null;\n    var model = self.graph.getModel();\n    if (model.getParent(cell) != null) {\n      // Executes the swimlane layout if a child of\n      // a swimlane has been changed. The layout is\n      // lazy created in createSwimlaneLayout.\n      if (self.layoutSwimlanes && graph.isSwimlane(cell)) {\n        if (self.swimlaneLayout == null) {\n          self.swimlaneLayout = self.createSwimlaneLayout();\n        }\n        layout = self.swimlaneLayout;\n      }\n\n      // Executes the diagram layout if the modified\n      // cell is a top-level cell. The layout is\n      // lazy created in createDiagramLayout.\n      else if (self.layoutDiagram && (graph.isValidRoot(cell) || model.getParent(model.getParent(cell)) == null)) {\n        if (self.diagramLayout == null) {\n          self.diagramLayout = self.createDiagramLayout();\n        }\n        layout = self.diagramLayout;\n      }\n    }\n    return layout;\n  };\n  return layoutMgr;\n};\n\n/**\r\n * Function: setGraphContainer\r\n *\r\n * Sets the graph's container using <mxGraph.init>.\r\n */\nmxEditor.prototype.setGraphContainer = function (container) {\n  if (this.graph.container == null) {\n    // Creates the graph instance inside the given container and render hint\n    //this.graph = new mxGraph(container, null, this.graphRenderHint);\n    this.graph.init(container);\n\n    // Install rubberband selection as the last\n    // action handler in the chain\n    this.rubberband = new _mxRubberband[\"default\"](this.graph);\n\n    // Disables the context menu\n    if (this.disableContextMenu) {\n      _mxEvent[\"default\"].disableContextMenu(container);\n    }\n\n    // Workaround for stylesheet directives in IE\n    if (_mxClient[\"default\"].IS_QUIRKS) {\n      new _mxDivResizer[\"default\"](container);\n    }\n  }\n};\n\n/**\r\n * Function: installDblClickHandler\r\n *\r\n * Overrides <mxGraph.dblClick> to invoke <dblClickAction>\r\n * on a cell and reset the selection tool in the toolbar.\r\n */\nmxEditor.prototype.installDblClickHandler = function (graph) {\n  // Installs a listener for double click events\n  graph.addListener(_mxEvent[\"default\"].DOUBLE_CLICK, _mxGraphUtils[\"default\"].bind(this, function (sender, evt) {\n    var cell = evt.getProperty('cell');\n    if (cell != null && graph.isEnabled() && this.dblClickAction != null) {\n      this.execute(this.dblClickAction, cell);\n      evt.consume();\n    }\n  }));\n};\n\n/**\r\n * Function: installUndoHandler\r\n *\r\n * Adds the <undoManager> to the graph model and the view.\r\n */\nmxEditor.prototype.installUndoHandler = function (graph) {\n  var listener = _mxGraphUtils[\"default\"].bind(this, function (sender, evt) {\n    var edit = evt.getProperty('edit');\n    this.undoManager.undoableEditHappened(edit);\n  });\n  graph.getModel().addListener(_mxEvent[\"default\"].UNDO, listener);\n  graph.getView().addListener(_mxEvent[\"default\"].UNDO, listener);\n\n  // Keeps the selection state in sync\n  var undoHandler = function undoHandler(sender, evt) {\n    var changes = evt.getProperty('edit').changes;\n    graph.setSelectionCells(graph.getSelectionCellsForChanges(changes));\n  };\n  this.undoManager.addListener(_mxEvent[\"default\"].UNDO, undoHandler);\n  this.undoManager.addListener(_mxEvent[\"default\"].REDO, undoHandler);\n};\n\n/**\r\n * Function: installDrillHandler\r\n *\r\n * Installs listeners for dispatching the <root> event.\r\n */\nmxEditor.prototype.installDrillHandler = function (graph) {\n  var listener = _mxGraphUtils[\"default\"].bind(this, function (sender) {\n    this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].ROOT));\n  });\n  graph.getView().addListener(_mxEvent[\"default\"].DOWN, listener);\n  graph.getView().addListener(_mxEvent[\"default\"].UP, listener);\n};\n\n/**\r\n * Function: installChangeHandler\r\n *\r\n * Installs the listeners required to automatically validate\r\n * the graph. On each change of the root, this implementation\r\n * fires a <root> event.\r\n */\nmxEditor.prototype.installChangeHandler = function (graph) {\n  var listener = _mxGraphUtils[\"default\"].bind(this, function (sender, evt) {\n    // Updates the modified state\n    this.setModified(true);\n\n    // Automatically validates the graph\n    // after each change\n    if (this.validating == true) {\n      graph.validateGraph();\n    }\n\n    // Checks if the root has been changed\n    var changes = evt.getProperty('edit').changes;\n    for (var i = 0; i < changes.length; i++) {\n      var change = changes[i];\n      if (change instanceof _mxRootChange[\"default\"] || change instanceof _mxValueChange[\"default\"] && change.cell == this.graph.model.root || change instanceof _mxCellAttributeChange[\"default\"] && change.cell == this.graph.model.root) {\n        this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].ROOT));\n        break;\n      }\n    }\n  });\n  graph.getModel().addListener(_mxEvent[\"default\"].CHANGE, listener);\n};\n\n/**\r\n * Function: installInsertHandler\r\n *\r\n * Installs the handler for invoking <insertFunction> if\r\n * one is defined.\r\n */\nmxEditor.prototype.installInsertHandler = function (graph) {\n  var self = this; // closure\n  var insertHandler = {\n    mouseDown: function mouseDown(sender, me) {\n      if (self.insertFunction != null && !me.isPopupTrigger() && (self.forcedInserting || me.getState() == null)) {\n        self.graph.clearSelection();\n        self.insertFunction(me.getEvent(), me.getCell());\n\n        // Consumes the rest of the events\n        // for this gesture (down, move, up)\n        this.isActive = true;\n        me.consume();\n      }\n    },\n    mouseMove: function mouseMove(sender, me) {\n      if (this.isActive) {\n        me.consume();\n      }\n    },\n    mouseUp: function mouseUp(sender, me) {\n      if (this.isActive) {\n        this.isActive = false;\n        me.consume();\n      }\n    }\n  };\n  graph.addMouseListener(insertHandler);\n};\n\n/**\r\n * Function: createDiagramLayout\r\n *\r\n * Creates the layout instance used to layout the\r\n * swimlanes in the diagram.\r\n */\nmxEditor.prototype.createDiagramLayout = function () {\n  var gs = this.graph.gridSize;\n  var layout = new _mxStackLayout[\"default\"](this.graph, !this.horizontalFlow, this.swimlaneSpacing, 2 * gs, 2 * gs);\n\n  // Overrides isIgnored to only take into account swimlanes\n  layout.isVertexIgnored = function (cell) {\n    return !layout.graph.isSwimlane(cell);\n  };\n  return layout;\n};\n\n/**\r\n * Function: createSwimlaneLayout\r\n *\r\n * Creates the layout instance used to layout the\r\n * children of each swimlane.\r\n */\nmxEditor.prototype.createSwimlaneLayout = function () {\n  return new _mxCompactTreeLayout[\"default\"](this.graph, this.horizontalFlow);\n};\n\n/**\r\n * Function: createToolbar\r\n *\r\n * Creates the <toolbar> with no container.\r\n */\nmxEditor.prototype.createToolbar = function () {\n  return new _mxDefaultToolbar[\"default\"](null, this);\n};\n\n/**\r\n * Function: setToolbarContainer\r\n *\r\n * Initializes the toolbar for the given container.\r\n */\nmxEditor.prototype.setToolbarContainer = function (container) {\n  this.toolbar.init(container);\n\n  // Workaround for stylesheet directives in IE\n  if (_mxClient[\"default\"].IS_QUIRKS) {\n    new _mxDivResizer[\"default\"](container);\n  }\n};\n\n/**\r\n * Function: setStatusContainer\r\n *\r\n * Creates the <status> using the specified container.\r\n *\r\n * This implementation adds listeners in the editor to\r\n * display the last saved time and the current filename\r\n * in the status bar.\r\n *\r\n * Parameters:\r\n *\r\n * container - DOM node that will contain the statusbar.\r\n */\nmxEditor.prototype.setStatusContainer = function (container) {\n  if (this.status == null) {\n    this.status = container;\n\n    // Prints the last saved time in the status bar\n    // when files are saved\n    this.addListener(_mxEvent[\"default\"].SAVE, _mxGraphUtils[\"default\"].bind(this, function () {\n      var tstamp = new Date().toLocaleString();\n      this.setStatus((_mxResources[\"default\"].get(this.lastSavedResource) || this.lastSavedResource) + ': ' + tstamp);\n    }));\n\n    // Updates the statusbar to display the filename\n    // when new files are opened\n    this.addListener(_mxEvent[\"default\"].OPEN, _mxGraphUtils[\"default\"].bind(this, function () {\n      this.setStatus((_mxResources[\"default\"].get(this.currentFileResource) || this.currentFileResource) + ': ' + this.filename);\n    }));\n\n    // Workaround for stylesheet directives in IE\n    if (_mxClient[\"default\"].IS_QUIRKS) {\n      new _mxDivResizer[\"default\"](container);\n    }\n  }\n};\n\n/**\r\n * Function: setStatus\r\n *\r\n * Display the specified message in the status bar.\r\n *\r\n * Parameters:\r\n *\r\n * message - String the specified the message to\r\n * be displayed.\r\n */\nmxEditor.prototype.setStatus = function (message) {\n  if (this.status != null && message != null) {\n    this.status.innerHTML = message;\n  }\n};\n\n/**\r\n * Function: setTitleContainer\r\n *\r\n * Creates a listener to update the inner HTML of the\r\n * specified DOM node with the value of <getTitle>.\r\n *\r\n * Parameters:\r\n *\r\n * container - DOM node that will contain the title.\r\n */\nmxEditor.prototype.setTitleContainer = function (container) {\n  this.addListener(_mxEvent[\"default\"].ROOT, _mxGraphUtils[\"default\"].bind(this, function (sender) {\n    container.innerHTML = this.getTitle();\n  }));\n\n  // Workaround for stylesheet directives in IE\n  if (_mxClient[\"default\"].IS_QUIRKS) {\n    new _mxDivResizer[\"default\"](container);\n  }\n};\n\n/**\r\n * Function: treeLayout\r\n *\r\n * Executes a vertical or horizontal compact tree layout\r\n * using the specified cell as an argument. The cell may\r\n * either be a group or the root of a tree.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> to use in the compact tree layout.\r\n * horizontal - Optional boolean to specify the tree's\r\n * orientation. Default is true.\r\n */\nmxEditor.prototype.treeLayout = function (cell, horizontal) {\n  if (cell != null) {\n    var layout = new _mxCompactTreeLayout[\"default\"](this.graph, horizontal);\n    layout.execute(cell);\n  }\n};\n\n/**\r\n * Function: getTitle\r\n *\r\n * Returns the string value for the current root of the\r\n * diagram.\r\n */\nmxEditor.prototype.getTitle = function () {\n  var title = '';\n  var graph = this.graph;\n  var cell = graph.getCurrentRoot();\n  while (cell != null && graph.getModel().getParent(graph.getModel().getParent(cell)) != null) {\n    // Append each label of a valid root\n    if (graph.isValidRoot(cell)) {\n      title = ' > ' + graph.convertValueToString(cell) + title;\n    }\n    cell = graph.getModel().getParent(cell);\n  }\n  var prefix = this.getRootTitle();\n  return prefix + title;\n};\n\n/**\r\n * Function: getRootTitle\r\n *\r\n * Returns the string value of the root cell in\r\n * <mxGraph.model>.\r\n */\nmxEditor.prototype.getRootTitle = function () {\n  var root = this.graph.getModel().getRoot();\n  return this.graph.convertValueToString(root);\n};\n\n/**\r\n * Function: undo\r\n *\r\n * Undo the last change in <graph>.\r\n */\nmxEditor.prototype.undo = function () {\n  this.undoManager.undo();\n};\n\n/**\r\n * Function: redo\r\n *\r\n * Redo the last change in <graph>.\r\n */\nmxEditor.prototype.redo = function () {\n  this.undoManager.redo();\n};\n\n/**\r\n * Function: groupCells\r\n *\r\n * Invokes <createGroup> to create a new group cell and the invokes\r\n * <mxGraph.groupCells>, using the grid size of the graph as the spacing\r\n * in the group's content area.\r\n */\nmxEditor.prototype.groupCells = function () {\n  var border = this.groupBorderSize != null ? this.groupBorderSize : this.graph.gridSize;\n  return this.graph.groupCells(this.createGroup(), border);\n};\n\n/**\r\n * Function: createGroup\r\n *\r\n * Creates and returns a clone of <defaultGroup> to be used\r\n * as a new group cell in <group>.\r\n */\nmxEditor.prototype.createGroup = function () {\n  var model = this.graph.getModel();\n  return model.cloneCell(this.defaultGroup);\n};\n\n/**\r\n * Function: open\r\n *\r\n * Opens the specified file synchronously and parses it using\r\n * <readGraphModel>. It updates <filename> and fires an <open>-event after\r\n * the file has been opened. Exceptions should be handled as follows:\r\n *\r\n * (code)\r\n * try\r\n * {\r\n *   editor.open(filename);\r\n * }\r\n * catch (e)\r\n * {\r\n *   mxUtils.error('Cannot open ' + filename +\r\n *     ': ' + e.message, 280, true);\r\n * }\r\n * (end)\r\n *\r\n * Parameters:\r\n *\r\n * filename - URL of the file to be opened.\r\n */\nmxEditor.prototype.open = function (filename) {\n  if (filename != null) {\n    var xml = _mxRequestUtils[\"default\"].load(filename).getXml();\n    this.readGraphModel(xml.documentElement);\n    this.filename = filename;\n    this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].OPEN, 'filename', filename));\n  }\n};\n\n/**\r\n * Function: readGraphModel\r\n *\r\n * Reads the specified XML node into the existing graph model and resets\r\n * the command history and modified state.\r\n */\nmxEditor.prototype.readGraphModel = function (node) {\n  var dec = new _mxCodec[\"default\"](node.ownerDocument);\n  dec.decode(node, this.graph.getModel());\n  this.resetHistory();\n};\n\n/**\r\n * Function: save\r\n *\r\n * Posts the string returned by <writeGraphModel> to the given URL or the\r\n * URL returned by <getUrlPost>. The actual posting is carried out by\r\n * <postDiagram>. If the URL is null then the resulting XML will be\r\n * displayed using <mxUtils.popup>. Exceptions should be handled as\r\n * follows:\r\n *\r\n * (code)\r\n * try\r\n * {\r\n *   editor.save();\r\n * }\r\n * catch (e)\r\n * {\r\n *   mxUtils.error('Cannot save : ' + e.message, 280, true);\r\n * }\r\n * (end)\r\n */\nmxEditor.prototype.save = function (url, linefeed) {\n  // Gets the URL to post the data to\n  url = url || this.getUrlPost();\n\n  // Posts the data if the URL is not empty\n  if (url != null && url.length > 0) {\n    var data = this.writeGraphModel(linefeed);\n    this.postDiagram(url, data);\n\n    // Resets the modified flag\n    this.setModified(false);\n  }\n\n  // Dispatches a save event\n  this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].SAVE, 'url', url));\n};\n\n/**\r\n * Function: postDiagram\r\n *\r\n * Hook for subclassers to override the posting of a diagram\r\n * represented by the given node to the given URL. This fires\r\n * an asynchronous <post> event if the diagram has been posted.\r\n *\r\n * Example:\r\n *\r\n * To replace the diagram with the diagram in the response, use the\r\n * following code.\r\n *\r\n * (code)\r\n * editor.addListener(mxEvent.POST, function(sender, evt)\r\n * {\r\n *   // Process response (replace diagram)\r\n *   var req = evt.getProperty('request');\r\n *   var root = req.getDocumentElement();\r\n *   editor.graph.readGraphModel(root)\r\n * });\r\n * (end)\r\n */\nmxEditor.prototype.postDiagram = function (url, data) {\n  if (this.escapePostData) {\n    data = encodeURIComponent(data);\n  }\n  _mxUtils[\"default\"].post(url, this.postParameterName + '=' + data, _mxGraphUtils[\"default\"].bind(this, function (req) {\n    this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].POST, 'request', req, 'url', url, 'data', data));\n  }));\n};\n\n/**\r\n * Function: writeGraphModel\r\n *\r\n * Hook to create the string representation of the diagram. The default\r\n * implementation uses an <mxCodec> to encode the graph model as\r\n * follows:\r\n *\r\n * (code)\r\n * var enc = new mxCodec();\r\n * var node = enc.encode(this.graph.getModel());\r\n * return mxUtils.getXml(node, this.linefeed);\r\n * (end)\r\n *\r\n * Parameters:\r\n *\r\n * linefeed - Optional character to be used as the linefeed. Default is\r\n * <linefeed>.\r\n */\nmxEditor.prototype.writeGraphModel = function (linefeed) {\n  linefeed = linefeed != null ? linefeed : this.linefeed;\n  var enc = new _mxCodec[\"default\"]();\n  var node = enc.encode(this.graph.getModel());\n  return _mxUtils[\"default\"].getXml(node, linefeed);\n};\n\n/**\r\n * Function: getUrlPost\r\n *\r\n * Returns the URL to post the diagram to. This is used\r\n * in <save>. The default implementation returns <urlPost>,\r\n * adding <code>?draft=true</code>.\r\n */\nmxEditor.prototype.getUrlPost = function () {\n  return this.urlPost;\n};\n\n/**\r\n * Function: getUrlImage\r\n *\r\n * Returns the URL to create the image with. This is typically\r\n * the URL of a backend which accepts an XML representation\r\n * of a graph view to create an image. The function is used\r\n * in the image action to create an image. This implementation\r\n * returns <urlImage>.\r\n */\nmxEditor.prototype.getUrlImage = function () {\n  return this.urlImage;\n};\n\n/**\r\n * Function: swapStyles\r\n *\r\n * Swaps the styles for the given names in the graph's\r\n * stylesheet and refreshes the graph.\r\n */\nmxEditor.prototype.swapStyles = function (first, second) {\n  var style = this.graph.getStylesheet().styles[second];\n  this.graph.getView().getStylesheet().putCellStyle(second, this.graph.getStylesheet().styles[first]);\n  this.graph.getStylesheet().putCellStyle(first, style);\n  this.graph.refresh();\n};\n\n/**\r\n * Function: showProperties\r\n *\r\n * Creates and shows the properties dialog for the given\r\n * cell. The content area of the dialog is created using\r\n * <createProperties>.\r\n */\nmxEditor.prototype.showProperties = function (cell) {\n  cell = cell || this.graph.getSelectionCell();\n\n  // Uses the root node for the properties dialog\n  // if not cell was passed in and no cell is\n  // selected\n  if (cell == null) {\n    cell = this.graph.getCurrentRoot();\n    if (cell == null) {\n      cell = this.graph.getModel().getRoot();\n    }\n  }\n  if (cell != null) {\n    // Makes sure there is no in-place editor in the\n    // graph and computes the location of the dialog\n    this.graph.stopEditing(true);\n    var offset = _mxUtils[\"default\"].getOffset(this.graph.container);\n    var x = offset.x + 10;\n    var y = offset.y;\n\n    // Avoids moving the dialog if it is alredy open\n    if (this.properties != null && !this.movePropertiesDialog) {\n      x = this.properties.getX();\n      y = this.properties.getY();\n    }\n\n    // Places the dialog near the cell for which it\n    // displays the properties\n    else {\n      var bounds = this.graph.getCellBounds(cell);\n      if (bounds != null) {\n        x += bounds.x + Math.min(200, bounds.width);\n        y += bounds.y;\n      }\n    }\n\n    // Hides the existing properties dialog and creates a new one with the\n    // contents created in the hook method\n    this.hideProperties();\n    var node = this.createProperties(cell);\n    if (node != null) {\n      // Displays the contents in a window and stores a reference to the\n      // window for later hiding of the window\n      this.properties = new _mxWindow[\"default\"](_mxResources[\"default\"].get(this.propertiesResource) || this.propertiesResource, node, x, y, this.propertiesWidth, this.propertiesHeight, false);\n      this.properties.setVisible(true);\n    }\n  }\n};\n\n/**\r\n * Function: isPropertiesVisible\r\n *\r\n * Returns true if the properties dialog is currently visible.\r\n */\nmxEditor.prototype.isPropertiesVisible = function () {\n  return this.properties != null;\n};\n\n/**\r\n * Function: createProperties\r\n *\r\n * Creates and returns the DOM node that represents the contents\r\n * of the properties dialog for the given cell. This implementation\r\n * works for user objects that are XML nodes and display all the\r\n * node attributes in a form.\r\n */\nmxEditor.prototype.createProperties = function (cell) {\n  var model = this.graph.getModel();\n  var value = model.getValue(cell);\n  if (_mxGraphUtils[\"default\"].isNode(value)) {\n    // Creates a form for the user object inside\n    // the cell\n    var form = new _mxForm[\"default\"]('properties');\n\n    // Adds a readonly field for the cell id\n    var id = form.addText('ID', cell.getId());\n    id.setAttribute('readonly', 'true');\n    var geo = null;\n    var yField = null;\n    var xField = null;\n    var widthField = null;\n    var heightField = null;\n\n    // Adds fields for the location and size\n    if (model.isVertex(cell)) {\n      geo = model.getGeometry(cell);\n      if (geo != null) {\n        yField = form.addText('top', geo.y);\n        xField = form.addText('left', geo.x);\n        widthField = form.addText('width', geo.width);\n        heightField = form.addText('height', geo.height);\n      }\n    }\n\n    // Adds a field for the cell style\n    var tmp = model.getStyle(cell);\n    var style = form.addText('Style', tmp || '');\n\n    // Creates textareas for each attribute of the\n    // user object within the cell\n    var attrs = value.attributes;\n    var texts = [];\n    for (var i = 0; i < attrs.length; i++) {\n      // Creates a textarea with more lines for\n      // the cell label\n      var val = attrs[i].value;\n      texts[i] = form.addTextarea(attrs[i].nodeName, val, attrs[i].nodeName == 'label' ? 4 : 2);\n    }\n\n    // Adds an OK and Cancel button to the dialog\n    // contents and implements the respective\n    // actions below\n\n    // Defines the function to be executed when the\n    // OK button is pressed in the dialog\n    var okFunction = _mxGraphUtils[\"default\"].bind(this, function () {\n      // Hides the dialog\n      this.hideProperties();\n\n      // Supports undo for the changes on the underlying\n      // XML structure / XML node attribute changes.\n      model.beginUpdate();\n      try {\n        if (geo != null) {\n          geo = geo.clone();\n          geo.x = parseFloat(xField.value);\n          geo.y = parseFloat(yField.value);\n          geo.width = parseFloat(widthField.value);\n          geo.height = parseFloat(heightField.value);\n          model.setGeometry(cell, geo);\n        }\n\n        // Applies the style\n        if (style.value.length > 0) {\n          model.setStyle(cell, style.value);\n        } else {\n          model.setStyle(cell, null);\n        }\n\n        // Creates an undoable change for each\n        // attribute and executes it using the\n        // model, which will also make the change\n        // part of the current transaction\n        for (var i = 0; i < attrs.length; i++) {\n          var edit = new _mxCellAttributeChange[\"default\"](cell, attrs[i].nodeName, texts[i].value);\n          model.execute(edit);\n        }\n\n        // Checks if the graph wants cells to\n        // be automatically sized and updates\n        // the size as an undoable step if\n        // the feature is enabled\n        if (this.graph.isAutoSizeCell(cell)) {\n          this.graph.updateCellSize(cell);\n        }\n      } finally {\n        model.endUpdate();\n      }\n    });\n\n    // Defines the function to be executed when the\n    // Cancel button is pressed in the dialog\n    var cancelFunction = _mxGraphUtils[\"default\"].bind(this, function () {\n      // Hides the dialog\n      this.hideProperties();\n    });\n    form.addButtons(okFunction, cancelFunction);\n    return form.table;\n  }\n  return null;\n};\n\n/**\r\n * Function: hideProperties\r\n *\r\n * Hides the properties dialog.\r\n */\nmxEditor.prototype.hideProperties = function () {\n  if (this.properties != null) {\n    this.properties.destroy();\n    this.properties = null;\n  }\n};\n\n/**\r\n * Function: showTasks\r\n *\r\n * Shows the tasks window. The tasks window is created using <createTasks>. The\r\n * default width of the window is 200 pixels, the y-coordinate of the location\r\n * can be specifies in <tasksTop> and the x-coordinate is right aligned with a\r\n * 20 pixel offset from the right border. To change the location of the tasks\r\n * window, the following code can be used:\r\n *\r\n * (code)\r\n * var oldShowTasks = mxEditor.prototype.showTasks;\r\n * mxEditor.prototype.showTasks = function()\r\n * {\r\n *   oldShowTasks.apply(this, arguments); // \"supercall\"\r\n *\r\n *   if (this.tasks != null)\r\n *   {\r\n *     this.tasks.setLocation(10, 10);\r\n *   }\r\n * };\r\n * (end)\r\n */\nmxEditor.prototype.showTasks = function () {\n  if (this.tasks == null) {\n    var div = document.createElement('div');\n    div.style.padding = '4px';\n    div.style.paddingLeft = '20px';\n    var w = document.body.clientWidth;\n    var wnd = new _mxWindow[\"default\"](_mxResources[\"default\"].get(this.tasksResource) || this.tasksResource, div, w - 220, this.tasksTop, 200);\n    wnd.setClosable(true);\n    wnd.destroyOnClose = false;\n\n    // Installs a function to update the contents\n    // of the tasks window on every change of the\n    // model, selection or root.\n    var funct = _mxGraphUtils[\"default\"].bind(this, function (sender) {\n      _mxEvent[\"default\"].release(div);\n      div.innerHTML = '';\n      this.createTasks(div);\n    });\n    this.graph.getModel().addListener(_mxEvent[\"default\"].CHANGE, funct);\n    this.graph.getSelectionModel().addListener(_mxEvent[\"default\"].CHANGE, funct);\n    this.graph.addListener(_mxEvent[\"default\"].ROOT, funct);\n\n    // Assigns the icon to the tasks window\n    if (this.tasksWindowImage != null) {\n      wnd.setImage(this.tasksWindowImage);\n    }\n    this.tasks = wnd;\n    this.createTasks(div);\n  }\n  this.tasks.setVisible(true);\n};\n\n/**\r\n * Function: refreshTasks\r\n *\r\n * Updates the contents of the tasks window using <createTasks>.\r\n */\nmxEditor.prototype.refreshTasks = function (div) {\n  if (this.tasks != null) {\n    var div = this.tasks.content;\n    _mxEvent[\"default\"].release(div);\n    div.innerHTML = '';\n    this.createTasks(div);\n  }\n};\n\n/**\r\n * Function: createTasks\r\n *\r\n * Updates the contents of the given DOM node to\r\n * display the tasks associated with the current\r\n * editor state. This is invoked whenever there\r\n * is a possible change of state in the editor.\r\n * Default implementation is empty.\r\n */\nmxEditor.prototype.createTasks = function (div) {\n  // override\n};\n\n/**\r\n * Function: showHelp\r\n *\r\n * Shows the help window. If the help window does not exist\r\n * then it is created using an iframe pointing to the resource\r\n * for the <code>urlHelp</code> key or <urlHelp> if the resource\r\n * is undefined.\r\n */\nmxEditor.prototype.showHelp = function (tasks) {\n  if (this.help == null) {\n    var frame = document.createElement('iframe');\n    frame.setAttribute('src', _mxResources[\"default\"].get('urlHelp') || this.urlHelp);\n    frame.setAttribute('height', '100%');\n    frame.setAttribute('width', '100%');\n    frame.setAttribute('frameBorder', '0');\n    frame.style.backgroundColor = 'white';\n    var w = document.body.clientWidth;\n    var h = document.body.clientHeight || document.documentElement.clientHeight;\n    var wnd = new _mxWindow[\"default\"](_mxResources[\"default\"].get(this.helpResource) || this.helpResource, frame, (w - this.helpWidth) / 2, (h - this.helpHeight) / 3, this.helpWidth, this.helpHeight);\n    wnd.setMaximizable(true);\n    wnd.setClosable(true);\n    wnd.destroyOnClose = false;\n    wnd.setResizable(true);\n\n    // Assigns the icon to the help window\n    if (this.helpWindowImage != null) {\n      wnd.setImage(this.helpWindowImage);\n    }\n\n    // Workaround for ignored iframe height 100% in FF\n    if (_mxClient[\"default\"].IS_NS) {\n      var handler = function handler(sender) {\n        var h = wnd.div.offsetHeight;\n        frame.setAttribute('height', h - 26 + 'px');\n      };\n      wnd.addListener(_mxEvent[\"default\"].RESIZE_END, handler);\n      wnd.addListener(_mxEvent[\"default\"].MAXIMIZE, handler);\n      wnd.addListener(_mxEvent[\"default\"].NORMALIZE, handler);\n      wnd.addListener(_mxEvent[\"default\"].SHOW, handler);\n    }\n    this.help = wnd;\n  }\n  this.help.setVisible(true);\n};\n\n/**\r\n * Function: showOutline\r\n *\r\n * Shows the outline window. If the window does not exist, then it is\r\n * created using an <mxOutline>.\r\n */\nmxEditor.prototype.showOutline = function () {\n  var create = this.outline == null;\n  if (create) {\n    var div = document.createElement('div');\n    div.style.overflow = 'hidden';\n    div.style.position = 'relative';\n    div.style.width = '100%';\n    div.style.height = '100%';\n    div.style.background = 'white';\n    div.style.cursor = 'move';\n    if (document.documentMode == 8) {\n      div.style.filter = 'progid:DXImageTransform.Microsoft.alpha(opacity=100)';\n    }\n    var wnd = new _mxWindow[\"default\"](_mxResources[\"default\"].get(this.outlineResource) || this.outlineResource, div, 600, 480, 200, 200, false);\n\n    // Creates the outline in the specified div\n    // and links it to the existing graph\n    var outline = new _mxOutline[\"default\"](this.graph, div);\n    wnd.setClosable(true);\n    wnd.setResizable(true);\n    wnd.destroyOnClose = false;\n    wnd.addListener(_mxEvent[\"default\"].RESIZE_END, function () {\n      outline.update();\n    });\n    this.outline = wnd;\n    this.outline.outline = outline;\n  }\n\n  // Finally shows the outline\n  this.outline.setVisible(true);\n  this.outline.outline.update(true);\n};\n\n/**\r\n * Function: setMode\r\n *\r\n * Puts the graph into the specified mode. The following modenames are\r\n * supported:\r\n *\r\n * select - Selects using the left mouse button, new connections\r\n * are disabled.\r\n * connect - Selects using the left mouse button or creates new\r\n * connections if mouse over cell hotspot. See <mxConnectionHandler>.\r\n * pan - Pans using the left mouse button, new connections are disabled.\r\n */\nmxEditor.prototype.setMode = function (modename) {\n  if (modename == 'select') {\n    this.graph.panningHandler.useLeftButtonForPanning = false;\n    this.graph.setConnectable(false);\n  } else if (modename == 'connect') {\n    this.graph.panningHandler.useLeftButtonForPanning = false;\n    this.graph.setConnectable(true);\n  } else if (modename == 'pan') {\n    this.graph.panningHandler.useLeftButtonForPanning = true;\n    this.graph.setConnectable(false);\n  }\n};\n\n/**\r\n * Function: createPopupMenu\r\n *\r\n * Uses <popupHandler> to create the menu in the graph's\r\n * panning handler. The redirection is setup in\r\n * <setToolbarContainer>.\r\n */\nmxEditor.prototype.createPopupMenu = function (menu, cell, evt) {\n  this.popupHandler.createMenu(this, menu, cell, evt);\n};\n\n/**\r\n * Function: createEdge\r\n *\r\n * Uses <defaultEdge> as the prototype for creating new edges\r\n * in the connection handler of the graph. The style of the\r\n * edge will be overridden with the value returned by\r\n * <getEdgeStyle>.\r\n */\nmxEditor.prototype.createEdge = function (source, target) {\n  // Clones the defaultedge prototype\n  var e = null;\n  if (this.defaultEdge != null) {\n    var model = this.graph.getModel();\n    e = model.cloneCell(this.defaultEdge);\n  } else {\n    e = new _mxCell[\"default\"]('');\n    e.setEdge(true);\n    var geo = new _mxGeometry[\"default\"]();\n    geo.relative = true;\n    e.setGeometry(geo);\n  }\n\n  // Overrides the edge style\n  var style = this.getEdgeStyle();\n  if (style != null) {\n    e.setStyle(style);\n  }\n  return e;\n};\n\n/**\r\n * Function: getEdgeStyle\r\n *\r\n * Returns a string identifying the style of new edges.\r\n * The function is used in <createEdge> when new edges\r\n * are created in the graph.\r\n */\nmxEditor.prototype.getEdgeStyle = function () {\n  return this.defaultEdgeStyle;\n};\n\n/**\r\n * Function: consumeCycleAttribute\r\n *\r\n * Returns the next attribute in <cycleAttributeValues>\r\n * or null, if not attribute should be used in the\r\n * specified cell.\r\n */\nmxEditor.prototype.consumeCycleAttribute = function (cell) {\n  return this.cycleAttributeValues != null && this.cycleAttributeValues.length > 0 && this.graph.isSwimlane(cell) ? this.cycleAttributeValues[this.cycleAttributeIndex++ % this.cycleAttributeValues.length] : null;\n};\n\n/**\r\n * Function: cycleAttribute\r\n *\r\n * Uses the returned value from <consumeCycleAttribute>\r\n * as the value for the <cycleAttributeName> key in\r\n * the given cell's style.\r\n */\nmxEditor.prototype.cycleAttribute = function (cell) {\n  if (this.cycleAttributeName != null) {\n    var value = this.consumeCycleAttribute(cell);\n    if (value != null) {\n      cell.setStyle(cell.getStyle() + ';' + this.cycleAttributeName + '=' + value);\n    }\n  }\n};\n\n/**\r\n * Function: addVertex\r\n *\r\n * Adds the given vertex as a child of parent at the specified\r\n * x and y coordinate and fires an <addVertex> event.\r\n */\nmxEditor.prototype.addVertex = function (parent, vertex, x, y) {\n  var model = this.graph.getModel();\n  while (parent != null && !this.graph.isValidDropTarget(parent)) {\n    parent = model.getParent(parent);\n  }\n  parent = parent != null ? parent : this.graph.getSwimlaneAt(x, y);\n  var scale = this.graph.getView().scale;\n  var geo = model.getGeometry(vertex);\n  var pgeo = model.getGeometry(parent);\n  if (this.graph.isSwimlane(vertex) && !this.graph.swimlaneNesting) {\n    parent = null;\n  } else if (parent == null && this.swimlaneRequired) {\n    return null;\n  } else if (parent != null && pgeo != null) {\n    // Keeps vertex inside parent\n    var state = this.graph.getView().getState(parent);\n    if (state != null) {\n      x -= state.origin.x * scale;\n      y -= state.origin.y * scale;\n      if (this.graph.isConstrainedMoving) {\n        var width = geo.width;\n        var height = geo.height;\n        var tmp = state.x + state.width;\n        if (x + width > tmp) {\n          x -= x + width - tmp;\n        }\n        tmp = state.y + state.height;\n        if (y + height > tmp) {\n          y -= y + height - tmp;\n        }\n      }\n    } else if (pgeo != null) {\n      x -= pgeo.x * scale;\n      y -= pgeo.y * scale;\n    }\n  }\n  geo = geo.clone();\n  geo.x = this.graph.snap(x / scale - this.graph.getView().translate.x - this.graph.gridSize / 2);\n  geo.y = this.graph.snap(y / scale - this.graph.getView().translate.y - this.graph.gridSize / 2);\n  vertex.setGeometry(geo);\n  if (parent == null) {\n    parent = this.graph.getDefaultParent();\n  }\n  this.cycleAttribute(vertex);\n  this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].BEFORE_ADD_VERTEX, 'vertex', vertex, 'parent', parent));\n  model.beginUpdate();\n  try {\n    vertex = this.graph.addCell(vertex, parent);\n    if (vertex != null) {\n      this.graph.constrainChild(vertex);\n      this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].ADD_VERTEX, 'vertex', vertex));\n    }\n  } finally {\n    model.endUpdate();\n  }\n  if (vertex != null) {\n    this.graph.setSelectionCell(vertex);\n    this.graph.scrollCellToVisible(vertex);\n    this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].AFTER_ADD_VERTEX, 'vertex', vertex));\n  }\n  return vertex;\n};\n\n/**\r\n * Function: destroy\r\n *\r\n * Removes the editor and all its associated resources. This does not\r\n * normally need to be called, it is called automatically when the window\r\n * unloads.\r\n */\nmxEditor.prototype.destroy = function () {\n  if (!this.destroyed) {\n    this.destroyed = true;\n    if (this.tasks != null) {\n      this.tasks.destroy();\n    }\n    if (this.outline != null) {\n      this.outline.destroy();\n    }\n    if (this.properties != null) {\n      this.properties.destroy();\n    }\n    if (this.keyHandler != null) {\n      this.keyHandler.destroy();\n    }\n    if (this.rubberband != null) {\n      this.rubberband.destroy();\n    }\n    if (this.toolbar != null) {\n      this.toolbar.destroy();\n    }\n    if (this.graph != null) {\n      this.graph.destroy();\n    }\n    this.status = null;\n    this.templates = null;\n  }\n};\nmxEditor.getName = function () {\n  return 'mxEditor';\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\nvar _default = exports[\"default\"] = mxEditor;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxEditor.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxEffects.js":
/*!********************************************!*\
  !*** ./src/workflow/mxClient/mxEffects.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/web.timers.js */ \"../../node_modules/core-js/modules/web.timers.js\");\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxChildChange = _interopRequireDefault(__webpack_require__(/*! ./mxChildChange.js */ \"./src/workflow/mxClient/mxChildChange.js\"));\nvar _mxValueChange = _interopRequireDefault(__webpack_require__(/*! ./mxValueChange.js */ \"./src/workflow/mxClient/mxValueChange.js\"));\nvar _mxGeometryChange = _interopRequireDefault(__webpack_require__(/*! ./mxGeometryChange.js */ \"./src/workflow/mxClient/mxGeometryChange.js\"));\nvar _mxTerminalChange = _interopRequireDefault(__webpack_require__(/*! ./mxTerminalChange.js */ \"./src/workflow/mxClient/mxTerminalChange.js\"));\nvar _mxStyleChange = _interopRequireDefault(__webpack_require__(/*! ./mxStyleChange.js */ \"./src/workflow/mxClient/mxStyleChange.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nvar mxEffects = {\n  /**\r\n   * Class: mxEffects\r\n   *\r\n   * Provides animation effects.\r\n   */\n\n  /**\r\n   * Function: animateChanges\r\n   *\r\n   * Asynchronous animated move operation. See also: <mxMorphing>.\r\n   *\r\n   * Example:\r\n   *\r\n   * (code)\r\n   * graph.model.addListener(mxEvent.CHANGE, function(sender, evt)\r\n   * {\r\n   *   var changes = evt.getProperty('edit').changes;\r\n   *\r\n   *   if (changes.length < 10)\r\n   *   {\r\n   *     mxEffects.animateChanges(graph, changes);\r\n   *   }\r\n   * });\r\n   * (end)\r\n   *\r\n   * Parameters:\r\n   *\r\n   * graph - <mxGraph> that received the changes.\r\n   * changes - Array of changes to be animated.\r\n   * done - Optional function argument that is invoked after the\r\n   * last step of the animation.\r\n   */\n  animateChanges: function animateChanges(graph, changes, done) {\n    var maxStep = 10;\n    var step = 0;\n    var animate = function animate() {\n      var isRequired = false;\n      for (var i = 0; i < changes.length; i++) {\n        var change = changes[i];\n        if (change instanceof _mxGeometryChange[\"default\"] || change instanceof _mxTerminalChange[\"default\"] || change instanceof _mxValueChange[\"default\"] || change instanceof _mxChildChange[\"default\"] || change instanceof _mxStyleChange[\"default\"]) {\n          var state = graph.getView().getState(change.cell || change.child, false);\n          if (state != null) {\n            isRequired = true;\n            if (change.constructor != _mxGeometryChange[\"default\"] || graph.model.isEdge(change.cell)) {\n              _mxGraphUtils[\"default\"].setOpacity(state.shape.node, 100 * step / maxStep);\n            } else {\n              var scale = graph.getView().scale;\n              var dx = (change.geometry.x - change.previous.x) * scale;\n              var dy = (change.geometry.y - change.previous.y) * scale;\n              var sx = (change.geometry.width - change.previous.width) * scale;\n              var sy = (change.geometry.height - change.previous.height) * scale;\n              if (step == 0) {\n                state.x -= dx;\n                state.y -= dy;\n                state.width -= sx;\n                state.height -= sy;\n              } else {\n                state.x += dx / maxStep;\n                state.y += dy / maxStep;\n                state.width += sx / maxStep;\n                state.height += sy / maxStep;\n              }\n              graph.cellRenderer.redraw(state);\n\n              // Fades all connected edges and children\n              mxEffects.cascadeOpacity(graph, change.cell, 100 * step / maxStep);\n            }\n          }\n        }\n      }\n      if (step < maxStep && isRequired) {\n        step++;\n        window.setTimeout(animate, delay);\n      } else if (done != null) {\n        done();\n      }\n    };\n    var delay = 30;\n    animate();\n  },\n  /**\r\n   * Function: cascadeOpacity\r\n   *\r\n   * Sets the opacity on the given cell and its descendants.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * graph - <mxGraph> that contains the cells.\r\n   * cell - <mxCell> to set the opacity for.\r\n   * opacity - New value for the opacity in %.\r\n   */\n  cascadeOpacity: function cascadeOpacity(graph, cell, opacity) {\n    // Fades all children\n    var childCount = graph.model.getChildCount(cell);\n    for (var i = 0; i < childCount; i++) {\n      var child = graph.model.getChildAt(cell, i);\n      var childState = graph.getView().getState(child);\n      if (childState != null) {\n        _mxGraphUtils[\"default\"].setOpacity(childState.shape.node, opacity);\n        mxEffects.cascadeOpacity(graph, child, opacity);\n      }\n    }\n\n    // Fades all connected edges\n    var edges = graph.model.getEdges(cell);\n    if (edges != null) {\n      for (var i = 0; i < edges.length; i++) {\n        var edgeState = graph.getView().getState(edges[i]);\n        if (edgeState != null) {\n          _mxGraphUtils[\"default\"].setOpacity(edgeState.shape.node, opacity);\n        }\n      }\n    }\n  },\n  /**\r\n   * Function: fadeOut\r\n   *\r\n   * Asynchronous fade-out operation.\r\n   */\n  fadeOut: function fadeOut(node, from, remove, step, delay, isEnabled) {\n    step = step || 40;\n    delay = delay || 30;\n    var opacity = from || 100;\n    _mxGraphUtils[\"default\"].setOpacity(node, opacity);\n    if (isEnabled || isEnabled == null) {\n      var f = function f() {\n        opacity = Math.max(opacity - step, 0);\n        _mxGraphUtils[\"default\"].setOpacity(node, opacity);\n        if (opacity > 0) {\n          window.setTimeout(f, delay);\n        } else {\n          node.style.visibility = 'hidden';\n          if (remove && node.parentNode) {\n            node.parentNode.removeChild(node);\n          }\n        }\n      };\n      window.setTimeout(f, delay);\n    } else {\n      node.style.visibility = 'hidden';\n      if (remove && node.parentNode) {\n        node.parentNode.removeChild(node);\n      }\n    }\n  }\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\nvar _default = exports[\"default\"] = mxEffects;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxEffects.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxElbowEdgeHandler.js":
/*!*****************************************************!*\
  !*** ./src/workflow/mxClient/mxElbowEdgeHandler.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.function.bind.js */ \"../../node_modules/core-js/modules/es.function.bind.js\");\nvar _mxClient = _interopRequireDefault(__webpack_require__(/*! ./mxClient.js */ \"./src/workflow/mxClient/mxClient.js\"));\nvar _mxEvent = _interopRequireDefault(__webpack_require__(/*! ./mxEvent.js */ \"./src/workflow/mxClient/mxEvent.js\"));\nvar _mxPoint = _interopRequireDefault(__webpack_require__(/*! ./mxPoint.js */ \"./src/workflow/mxClient/mxPoint.js\"));\nvar _mxEdgeHandler = _interopRequireDefault(__webpack_require__(/*! ./mxEdgeHandler.js */ \"./src/workflow/mxClient/mxEdgeHandler.js\"));\nvar _mxResources = _interopRequireDefault(__webpack_require__(/*! ./mxResources.js */ \"./src/workflow/mxClient/mxResources.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxRectangle = _interopRequireDefault(__webpack_require__(/*! ./mxRectangle.js */ \"./src/workflow/mxClient/mxRectangle.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ./mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nvar _mxEdgeStyle = _interopRequireDefault(__webpack_require__(/*! ./mxEdgeStyle.js */ \"./src/workflow/mxClient/mxEdgeStyle.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxElbowEdgeHandler(state) {\n  _mxEdgeHandler[\"default\"].call(this, state);\n}\n;\n\n/**\r\n * Extends mxEdgeHandler.\r\n */\n_mxGraphUtils[\"default\"].extend(mxElbowEdgeHandler, _mxEdgeHandler[\"default\"]);\n\n/**\r\n * Specifies if a double click on the middle handle should call\r\n * <mxGraph.flipEdge>. Default is true.\r\n */\nmxElbowEdgeHandler.prototype.flipEnabled = true;\n\n/**\r\n * Variable: doubleClickOrientationResource\r\n *\r\n * Specifies the resource key for the tooltip to be displayed on the single\r\n * control point for routed edges. If the resource for this key does not\r\n * exist then the value is used as the error message. Default is\r\n * 'doubleClickOrientation'.\r\n */\nmxElbowEdgeHandler.prototype.doubleClickOrientationResource = _mxClient[\"default\"].language != 'none' ? 'doubleClickOrientation' : '';\n\n/**\r\n * Function: createBends\r\n *\r\n * Overrides <mxEdgeHandler.createBends> to create custom bends.\r\n */\nmxElbowEdgeHandler.prototype.createBends = function () {\n  var bends = [];\n\n  // Source\n  var bend = this.createHandleShape(0);\n  this.initBend(bend);\n  bend.setCursor(_mxConstants[\"default\"].CURSOR_TERMINAL_HANDLE);\n  bends.push(bend);\n\n  // Virtual\n  bends.push(this.createVirtualBend(_mxGraphUtils[\"default\"].bind(this, function (evt) {\n    if (!_mxEvent[\"default\"].isConsumed(evt) && this.flipEnabled) {\n      this.graph.flipEdge(this.state.cell, evt);\n      _mxEvent[\"default\"].consume(evt);\n    }\n  })));\n  this.points.push(new _mxPoint[\"default\"](0, 0));\n\n  // Target\n  bend = this.createHandleShape(2);\n  this.initBend(bend);\n  bend.setCursor(_mxConstants[\"default\"].CURSOR_TERMINAL_HANDLE);\n  bends.push(bend);\n  return bends;\n};\n\n/**\r\n * Function: createVirtualBend\r\n *\r\n * Creates a virtual bend that supports double clicking and calls\r\n * <mxGraph.flipEdge>.\r\n */\nmxElbowEdgeHandler.prototype.createVirtualBend = function (dblClickHandler) {\n  var bend = this.createHandleShape();\n  this.initBend(bend, dblClickHandler);\n  bend.setCursor(this.getCursorForBend());\n  if (!this.graph.isCellBendable(this.state.cell)) {\n    bend.node.style.display = 'none';\n  }\n  return bend;\n};\n\n/**\r\n * Function: getCursorForBend\r\n *\r\n * Returns the cursor to be used for the bend.\r\n */\nmxElbowEdgeHandler.prototype.getCursorForBend = function () {\n  return this.state.style[_mxConstants[\"default\"].STYLE_EDGE] == _mxEdgeStyle[\"default\"].TopToBottom || this.state.style[_mxConstants[\"default\"].STYLE_EDGE] == _mxConstants[\"default\"].EDGESTYLE_TOPTOBOTTOM || (this.state.style[_mxConstants[\"default\"].STYLE_EDGE] == _mxEdgeStyle[\"default\"].ElbowConnector || this.state.style[_mxConstants[\"default\"].STYLE_EDGE] == _mxConstants[\"default\"].EDGESTYLE_ELBOW) && this.state.style[_mxConstants[\"default\"].STYLE_ELBOW] == _mxConstants[\"default\"].ELBOW_VERTICAL ? 'row-resize' : 'col-resize';\n};\n\n/**\r\n * Function: getTooltipForNode\r\n *\r\n * Returns the tooltip for the given node.\r\n */\nmxElbowEdgeHandler.prototype.getTooltipForNode = function (node) {\n  var tip = null;\n  if (this.bends != null && this.bends[1] != null && (node == this.bends[1].node || node.parentNode == this.bends[1].node)) {\n    tip = this.doubleClickOrientationResource;\n    tip = _mxResources[\"default\"].get(tip) || tip; // translate\n  }\n  return tip;\n};\n\n/**\r\n * Function: convertPoint\r\n *\r\n * Converts the given point in-place from screen to unscaled, untranslated\r\n * graph coordinates and applies the grid.\r\n *\r\n * Parameters:\r\n *\r\n * point - <mxPoint> to be converted.\r\n * gridEnabled - Boolean that specifies if the grid should be applied.\r\n */\nmxElbowEdgeHandler.prototype.convertPoint = function (point, gridEnabled) {\n  var scale = this.graph.getView().getScale();\n  var tr = this.graph.getView().getTranslate();\n  var origin = this.state.origin;\n  if (gridEnabled) {\n    point.x = this.graph.snap(point.x);\n    point.y = this.graph.snap(point.y);\n  }\n  point.x = Math.round(point.x / scale - tr.x - origin.x);\n  point.y = Math.round(point.y / scale - tr.y - origin.y);\n  return point;\n};\n\n/**\r\n * Function: redrawInnerBends\r\n *\r\n * Updates and redraws the inner bends.\r\n *\r\n * Parameters:\r\n *\r\n * p0 - <mxPoint> that represents the location of the first point.\r\n * pe - <mxPoint> that represents the location of the last point.\r\n */\nmxElbowEdgeHandler.prototype.redrawInnerBends = function (p0, pe) {\n  var g = this.graph.getModel().getGeometry(this.state.cell);\n  var pts = this.state.absolutePoints;\n  var pt = null;\n\n  // Keeps the virtual bend on the edge shape\n  if (pts.length > 1) {\n    p0 = pts[1];\n    pe = pts[pts.length - 2];\n  } else if (g.points != null && g.points.length > 0) {\n    pt = pts[0];\n  }\n  if (pt == null) {\n    pt = new _mxPoint[\"default\"](p0.x + (pe.x - p0.x) / 2, p0.y + (pe.y - p0.y) / 2);\n  } else {\n    pt = new _mxPoint[\"default\"](this.graph.getView().scale * (pt.x + this.graph.getView().translate.x + this.state.origin.x), this.graph.getView().scale * (pt.y + this.graph.getView().translate.y + this.state.origin.y));\n  }\n\n  // Makes handle slightly bigger if the yellow  label handle\n  // exists and intersects this green handle\n  var b = this.bends[1].bounds;\n  var w = b.width;\n  var h = b.height;\n  var bounds = new _mxRectangle[\"default\"](Math.round(pt.x - w / 2), Math.round(pt.y - h / 2), w, h);\n  if (this.manageLabelHandle) {\n    this.checkLabelHandle(bounds);\n  } else if (this.handleImage == null && this.labelShape.visible && _mxGraphUtils[\"default\"].intersects(bounds, this.labelShape.bounds)) {\n    w = _mxConstants[\"default\"].HANDLE_SIZE + 3;\n    h = _mxConstants[\"default\"].HANDLE_SIZE + 3;\n    bounds = new _mxRectangle[\"default\"](Math.floor(pt.x - w / 2), Math.floor(pt.y - h / 2), w, h);\n  }\n  this.bends[1].bounds = bounds;\n  this.bends[1].redraw();\n  if (this.manageLabelHandle) {\n    this.checkLabelHandle(this.bends[1].bounds);\n  }\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\nvar _default = exports[\"default\"] = mxElbowEdgeHandler;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxElbowEdgeHandler.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxEllipse.js":
/*!********************************************!*\
  !*** ./src/workflow/mxClient/mxEllipse.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.fill.js */ \"../../node_modules/core-js/modules/es.array.fill.js\");\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxShape = _interopRequireDefault(__webpack_require__(/*! ./mxShape.js */ \"./src/workflow/mxClient/mxShape.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxEllipse(bounds, fill, stroke, strokewidth) {\n  _mxShape[\"default\"].call(this);\n  this.bounds = bounds;\n  this.fill = fill;\n  this.stroke = stroke;\n  this.strokewidth = strokewidth != null ? strokewidth : 1;\n}\n;\n\n/**\r\n * Extends mxShape.\r\n */\n_mxGraphUtils[\"default\"].extend(mxEllipse, _mxShape[\"default\"]);\n\n/**\r\n * Function: paintVertexShape\r\n *\r\n * Paints the ellipse shape.\r\n */\nmxEllipse.prototype.paintVertexShape = function (c, x, y, w, h) {\n  c.ellipse(x, y, w, h);\n  c.fillAndStroke();\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxDoubleEllipse\r\n *\r\n * Extends <mxShape> to implement a double ellipse shape. This shape is\r\n * registered under <mxConstants.SHAPE_DOUBLE_ELLIPSE> in <mxCellRenderer>.\r\n * Use the following override to only fill the inner ellipse in this shape:\r\n *\r\n * (code)\r\n * mxDoubleEllipse.prototype.paintVertexShape = function(c, x, y, w, h)\r\n * {\r\n *   c.ellipse(x, y, w, h);\r\n *   c.stroke();\r\n *\r\n *   var inset = mxGraphUtils.getValue(this.style, mxConstants.STYLE_MARGIN, Math.min(3 + this.strokewidth, Math.min(w / 5, h / 5)));\r\n *   x += inset;\r\n *   y += inset;\r\n *   w -= 2 * inset;\r\n *   h -= 2 * inset;\r\n *\r\n *   if (w > 0 && h > 0)\r\n *   {\r\n *     c.ellipse(x, y, w, h);\r\n *   }\r\n *\r\n *   c.fillAndStroke();\r\n * };\r\n * (end)\r\n *\r\n * Constructor: mxDoubleEllipse\r\n *\r\n * Constructs a new ellipse shape.\r\n *\r\n * Parameters:\r\n *\r\n * bounds - <mxRectangle> that defines the bounds. This is stored in\r\n * <mxShape.bounds>.\r\n * fill - String that defines the fill color. This is stored in <fill>.\r\n * stroke - String that defines the stroke color. This is stored in <stroke>.\r\n * strokewidth - Optional integer that defines the stroke width. Default is\r\n * 1. This is stored in <strokewidth>.\r\n */\nvar _default = exports[\"default\"] = mxEllipse;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxEllipse.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxEvent.js":
/*!******************************************!*\
  !*** ./src/workflow/mxClient/mxEvent.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.index-of.js */ \"../../node_modules/core-js/modules/es.array.index-of.js\");\nvar _mxClient = _interopRequireDefault(__webpack_require__(/*! ./mxClient.js */ \"./src/workflow/mxClient/mxClient.js\"));\nvar _mxMouseEvent = _interopRequireDefault(__webpack_require__(/*! ./mxMouseEvent.js */ \"./src/workflow/mxClient/mxMouseEvent.js\"));\nvar _mxEventUtils = _interopRequireDefault(__webpack_require__(/*! ./mxEventUtils.js */ \"./src/workflow/mxClient/mxEventUtils.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nvar mxEvent = {\n  /**\r\n   * Class: mxEvent\r\n   *\r\n   * Cross-browser DOM event support. For internal event handling,\r\n   * <mxEventSource> and the graph event dispatch loop in <mxGraph> are used.\r\n   *\r\n   * Memory Leaks:\r\n   *\r\n   * Use this class for adding and removing listeners to/from DOM nodes. The\r\n   * <removeAllListeners> function is provided to remove all listeners that\r\n   * have been added using <addListener>. The function should be invoked when\r\n   * the last reference is removed in the JavaScript code, typically when the\r\n   * referenced DOM node is removed from the DOM, and helps to reduce memory\r\n   * leaks in IE6.\r\n   */\n\n  /**\r\n   * Function: addListener\r\n   *\r\n   * <mxGraphUtils.bind> in order to bind the \"this\" keyword inside the function\r\n   * to a given execution scope.\r\n   */\n  addListener: _mxEventUtils[\"default\"].addListener,\n  //瑙ｉ櫎渚濊禆锛岃鐩存帴浣跨敤 mxEventUtils.addListener\n\n  /**\r\n   * Function: removeListener\r\n   *\r\n   * Removes the specified listener from the given element.\r\n   */\n  removeListener: _mxEventUtils[\"default\"].removeListener,\n  //瑙ｉ櫎渚濊禆锛岃鐩存帴浣跨敤 mxEventUtils.removeListener\n\n  /**\r\n   * Function: removeAllListeners\r\n   *\r\n   * Removes all listeners from the given element.\r\n   */\n  //瑙ｉ櫎渚濊禆锛岃鐩存帴浣跨敤 mxEventUtils.removeAllListeners\n  removeAllListeners: function removeAllListeners(element) {\n    _mxEventUtils[\"default\"].removeAllListeners(element);\n  },\n  /**\r\n   * Function: addGestureListeners\r\n   *\r\n   * Adds the given listeners for touch, mouse and/or pointer events. If\r\n   * <mxClient.IS_POINTER> is true then pointer events will be registered,\r\n   * else the respective mouse events will be registered. If <mxClient.IS_POINTER>\r\n   * is false and <mxClient.IS_TOUCH> is true then the respective touch events\r\n   * will be registered as well as the mouse events.\r\n   */\n  //瑙ｉ櫎渚濊禆锛岃鐩存帴浣跨敤 mxEventUtils.addGestureListeners\n  addGestureListeners: function addGestureListeners(node, startListener, moveListener, endListener) {\n    _mxEventUtils[\"default\"].addGestureListeners(node, startListener, moveListener, endListener);\n  },\n  /**\r\n   * Function: removeGestureListeners\r\n   *\r\n   * Removes the given listeners from mousedown, mousemove, mouseup and the\r\n   * respective touch events if <mxClient.IS_TOUCH> is true.\r\n   */\n  //瑙ｉ櫎渚濊禆锛岃鐩存帴浣跨敤 mxEventUtils.removeGestureListeners\n  removeGestureListeners: function removeGestureListeners(node, startListener, moveListener, endListener) {\n    _mxEventUtils[\"default\"].removeGestureListeners(node, startListener, moveListener, endListener);\n  },\n  /**\r\n   * Function: redirectMouseEvents\r\n   *\r\n   * Redirects the mouse events from the given DOM node to the graph dispatch\r\n   * loop using the event and given state as event arguments. State can\r\n   * either be an instance of <mxCellState> or a function that returns an\r\n   * <mxCellState>. The down, move, up and dblClick arguments are optional\r\n   * functions that take the trigger event as arguments and replace the\r\n   * default behaviour.\r\n   */\n  redirectMouseEvents: function redirectMouseEvents(node, graph, state, down, move, up, dblClick) {\n    var getState = function getState(evt) {\n      return typeof state == 'function' ? state(evt) : state;\n    };\n    mxEvent.addGestureListeners(node, function (evt) {\n      if (down != null) {\n        down(evt);\n      } else if (!mxEvent.isConsumed(evt)) {\n        graph.fireMouseEvent(mxEvent.MOUSE_DOWN, new _mxMouseEvent[\"default\"](evt, getState(evt)));\n      }\n    }, function (evt) {\n      if (move != null) {\n        move(evt);\n      } else if (!mxEvent.isConsumed(evt)) {\n        graph.fireMouseEvent(mxEvent.MOUSE_MOVE, new _mxMouseEvent[\"default\"](evt, getState(evt)));\n      }\n    }, function (evt) {\n      if (up != null) {\n        up(evt);\n      } else if (!mxEvent.isConsumed(evt)) {\n        graph.fireMouseEvent(mxEvent.MOUSE_UP, new _mxMouseEvent[\"default\"](evt, getState(evt)));\n      }\n    });\n    mxEvent.addListener(node, 'dblclick', function (evt) {\n      if (dblClick != null) {\n        dblClick(evt);\n      } else if (!mxEvent.isConsumed(evt)) {\n        var tmp = getState(evt);\n        graph.dblClick(evt, tmp != null ? tmp.cell : null);\n      }\n    });\n  },\n  /**\r\n   * Function: release\r\n   *\r\n   * Removes the known listeners from the given DOM node and its descendants.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * element - DOM node to remove the listeners from.\r\n   */\n  release: function release(element) {\n    _mxEventUtils[\"default\"].release(element);\n  },\n  /**\r\n   * Function: addMouseWheelListener\r\n   *\r\n   * Installs the given function as a handler for mouse wheel events. The\r\n   * function has two arguments: the mouse event and a boolean that specifies\r\n   * if the wheel was moved up or down.\r\n   *\r\n   * This has been tested with IE 6 and 7, Firefox (all versions), Opera and\r\n   * Safari. It does currently not work on Safari for Mac.\r\n   *\r\n   * Example:\r\n   *\r\n   * (code)\r\n   * mxEvent.addMouseWheelListener(function (evt, up)\r\n   * {\r\n   *   mxLog.show();\r\n   *   mxLog.debug('mouseWheel: up='+up);\r\n   * });\r\n   *(end)\r\n   *\r\n   * Parameters:\r\n   *\r\n   * funct - Handler function that takes the event argument and a boolean up\r\n   * argument for the mousewheel direction.\r\n   */\n  addMouseWheelListener: function addMouseWheelListener(funct) {\n    if (funct != null) {\n      var wheelHandler = function wheelHandler(evt) {\n        // IE does not give an event object but the\n        // global event object is the mousewheel event\n        // at this point in time.\n        if (evt == null) {\n          evt = window.event;\n        }\n        var delta = 0;\n        if (_mxClient[\"default\"].IS_FF) {\n          delta = -evt.detail / 2;\n        } else {\n          delta = evt.wheelDelta / 120;\n        }\n\n        // Handles the event using the given function\n        if (delta != 0) {\n          funct(evt, delta > 0);\n        }\n      };\n\n      // Webkit has NS event API, but IE event name and details\n      if (_mxClient[\"default\"].IS_NS && document.documentMode == null) {\n        var eventName = _mxClient[\"default\"].IS_SF || _mxClient[\"default\"].IS_GC ? 'mousewheel' : 'DOMMouseScroll';\n        mxEvent.addListener(window, eventName, wheelHandler);\n      } else {\n        mxEvent.addListener(document, 'mousewheel', wheelHandler);\n      }\n    }\n  },\n  /**\r\n   * Function: disableContextMenu\r\n   *\r\n   * Disables the context menu for the given element.\r\n   */\n  disableContextMenu: function () {\n    if (_mxClient[\"default\"].IS_IE && (typeof document.documentMode === 'undefined' || document.documentMode < 9)) {\n      return function (element) {\n        mxEvent.addListener(element, 'contextmenu', function () {\n          return false;\n        });\n      };\n    } else {\n      return function (element) {\n        element.setAttribute('oncontextmenu', 'return false;');\n      };\n    }\n  }(),\n  /**\r\n   * Function: getSource\r\n   *\r\n   * Returns the event's target or srcElement depending on the browser.\r\n   */\n  getSource: function getSource(evt) {\n    return _mxEventUtils[\"default\"].getSource(evt);\n  },\n  /**\r\n   * Function: isConsumed\r\n   *\r\n   * Returns true if the event has been consumed using <consume>.\r\n   */\n  isConsumed: function isConsumed(evt) {\n    return _mxEventUtils[\"default\"].isConsumed(evt);\n  },\n  /**\r\n   * Function: isTouchEvent\r\n   *\r\n   * Returns true if the event was generated using a touch device (not a pen or mouse).\r\n   */\n  isTouchEvent: function isTouchEvent(evt) {\n    return evt.pointerType != null ? evt.pointerType == 'touch' || evt.pointerType === evt.MSPOINTER_TYPE_TOUCH : evt.mozInputSource != null ? evt.mozInputSource == 5 : evt.type.indexOf('touch') == 0;\n  },\n  /**\r\n   * Function: isMultiTouchEvent\r\n   *\r\n   * Returns true if the event was generated using a touch device (not a pen or mouse).\r\n   */\n  isMultiTouchEvent: function isMultiTouchEvent(evt) {\n    return evt.type != null && evt.type.indexOf('touch') == 0 && evt.touches != null && evt.touches.length > 1;\n  },\n  /**\r\n   * Function: isMouseEvent\r\n   *\r\n   * Returns true if the event was generated using a mouse (not a pen or touch device).\r\n   */\n  isMouseEvent: _mxEventUtils[\"default\"].isMouseEvent,\n  /**\r\n   * Function: isLeftMouseButton\r\n   *\r\n   * Returns true if the left mouse button is pressed for the given event.\r\n   * To check if a button is pressed during a mouseMove you should use the\r\n   * <mxGraph.isMouseDown> property. Note that this returns true in Firefox\r\n   * for control+left-click on the Mac.\r\n   */\n  isLeftMouseButton: function isLeftMouseButton(evt) {\n    _mxEventUtils[\"default\"].isLeftMouseButton(evt);\n  },\n  /**\r\n   * Function: isMiddleMouseButton\r\n   *\r\n   * Returns true if the middle mouse button is pressed for the given event.\r\n   * To check if a button is pressed during a mouseMove you should use the\r\n   * <mxGraph.isMouseDown> property.\r\n   */\n  isMiddleMouseButton: function isMiddleMouseButton(evt) {\n    _mxEventUtils[\"default\"].isMiddleMouseButton(evt);\n  },\n  /**\r\n   * Function: isRightMouseButton\r\n   *\r\n   * Returns true if the right mouse button was pressed. Note that this\r\n   * button might not be available on some systems. For handling a popup\r\n   * trigger <isPopupTrigger> should be used.\r\n   */\n  isRightMouseButton: function isRightMouseButton(evt) {\n    _mxEventUtils[\"default\"].isRightMouseButton(evt);\n  },\n  /**\r\n   * Function: isPopupTrigger\r\n   *\r\n   * Returns true if the event is a popup trigger. This implementation\r\n   * returns true if the right button or the left button and control was\r\n   * pressed on a Mac.\r\n   */\n  isPopupTrigger: function isPopupTrigger(evt) {\n    return _mxEventUtils[\"default\"].isPopupTrigger(evt);\n  },\n  /**\r\n   * Function: isShiftDown\r\n   *\r\n   * Returns true if the shift key is pressed for the given event.\r\n   */\n  isShiftDown: function isShiftDown(evt) {\n    return _mxEventUtils[\"default\"].isShiftDown(evt);\n  },\n  /**\r\n   * Function: isAltDown\r\n   *\r\n   * Returns true if the alt key is pressed for the given event.\r\n   */\n  isAltDown: function isAltDown(evt) {\n    return _mxEventUtils[\"default\"].isAltDown(evt);\n  },\n  /**\r\n   * Function: isControlDown\r\n   *\r\n   * Returns true if the control key is pressed for the given event.\r\n   */\n  isControlDown: function isControlDown(evt) {\n    return _mxEventUtils[\"default\"].isControlDown(evt);\n  },\n  /**\r\n   * Function: isMetaDown\r\n   *\r\n   * Returns true if the meta key is pressed for the given event.\r\n   */\n  isMetaDown: function isMetaDown(evt) {\n    return _mxEventUtils[\"default\"].isMetaDown(evt);\n  },\n  /**\r\n   * Function: getMainEvent\r\n   *\r\n   * Returns the touch or mouse event that contains the mouse coordinates.\r\n   */\n  getMainEvent: function getMainEvent(e) {\n    return _mxEventUtils[\"default\"].getMainEvent(e);\n  },\n  /**\r\n   * Function: getClientX\r\n   *\r\n   * Returns true if the meta key is pressed for the given event.\r\n   */\n  getClientX: function getClientX(e) {\n    return _mxEventUtils[\"default\"].getMainEvent(e).clientX;\n  },\n  /**\r\n   * Function: getClientY\r\n   *\r\n   * Returns true if the meta key is pressed for the given event.\r\n   */\n  getClientY: function getClientY(e) {\n    return _mxEventUtils[\"default\"].getMainEvent(e).clientY;\n  },\n  /**\r\n   * Function: consume\r\n   *\r\n   * Consumes the given event.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * evt - Native event to be consumed.\r\n   * preventDefault - Optional boolean to prevent the default for the event.\r\n   * Default is true.\r\n   * stopPropagation - Option boolean to stop event propagation. Default is\r\n   * true.\r\n   */\n  consume: function consume(evt, preventDefault, stopPropagation) {\n    _mxEventUtils[\"default\"].consume(evt, preventDefault, stopPropagation);\n  },\n  //\n  // Special handles in mouse events\n  //\n\n  /**\r\n  * Variable: LABEL_HANDLE\r\n  *\r\n  * Index for the label handle in an mxMouseEvent. This should be a negative\r\n  * value that does not interfere with any possible handle indices. Default\r\n  * is -1.\r\n  */\n  LABEL_HANDLE: _mxEventUtils[\"default\"].LABEL_HANDLE,\n  /**\r\n   * Variable: ROTATION_HANDLE\r\n   *\r\n   * Index for the rotation handle in an mxMouseEvent. This should be a\r\n   * negative value that does not interfere with any possible handle indices.\r\n   * Default is -2.\r\n   */\n  ROTATION_HANDLE: _mxEventUtils[\"default\"].ROTATION_HANDLE,\n  /**\r\n   * Variable: CUSTOM_HANDLE\r\n   *\r\n   * Start index for the custom handles in an mxMouseEvent. This should be a\r\n   * negative value and is the start index which is decremented for each\r\n   * custom handle. Default is -100.\r\n   */\n  CUSTOM_HANDLE: _mxEventUtils[\"default\"].CUSTOM_HANDLE,\n  /**\r\n   * Variable: VIRTUAL_HANDLE\r\n   *\r\n   * Start index for the virtual handles in an mxMouseEvent. This should be a\r\n   * negative value and is the start index which is decremented for each\r\n   * virtual handle. Default is -100000. This assumes that there are no more\r\n   * than VIRTUAL_HANDLE - CUSTOM_HANDLE custom handles.\r\n   *\r\n   */\n  VIRTUAL_HANDLE: _mxEventUtils[\"default\"].VIRTUAL_HANDLE,\n  //\n  // Event names\n  //\n\n  /**\r\n   * Variable: MOUSE_DOWN\r\n   *\r\n   * Specifies the event name for mouseDown.\r\n   */\n  MOUSE_DOWN: _mxEventUtils[\"default\"].MOUSE_DOWN,\n  /**\r\n   * Variable: MOUSE_MOVE\r\n   *\r\n   * Specifies the event name for mouseMove.\r\n   */\n  MOUSE_MOVE: _mxEventUtils[\"default\"].MOUSE_MOVE,\n  /**\r\n   * Variable: MOUSE_UP\r\n   *\r\n   * Specifies the event name for mouseUp.\r\n   */\n  MOUSE_UP: _mxEventUtils[\"default\"].MOUSE_UP,\n  /**\r\n   * Variable: ACTIVATE\r\n   *\r\n   * Specifies the event name for activate.\r\n   */\n  ACTIVATE: _mxEventUtils[\"default\"].ACTIVATE,\n  /**\r\n   * Variable: RESIZE_START\r\n   *\r\n   * Specifies the event name for resizeStart.\r\n   */\n  RESIZE_START: _mxEventUtils[\"default\"].RESIZE_START,\n  /**\r\n   * Variable: RESIZE\r\n   *\r\n   * Specifies the event name for resize.\r\n   */\n  RESIZE: _mxEventUtils[\"default\"].RESIZE,\n  /**\r\n   * Variable: RESIZE_END\r\n   *\r\n   * Specifies the event name for resizeEnd.\r\n   */\n  RESIZE_END: _mxEventUtils[\"default\"].RESIZE_END,\n  /**\r\n   * Variable: MOVE_START\r\n   *\r\n   * Specifies the event name for moveStart.\r\n   */\n  MOVE_START: _mxEventUtils[\"default\"].MOVE_START,\n  /**\r\n   * Variable: MOVE\r\n   *\r\n   * Specifies the event name for move.\r\n   */\n  MOVE: _mxEventUtils[\"default\"].MOVE,\n  /**\r\n   * Variable: MOVE_END\r\n   *\r\n   * Specifies the event name for moveEnd.\r\n   */\n  MOVE_END: _mxEventUtils[\"default\"].MOVE_END,\n  /**\r\n   * Variable: PAN_START\r\n   *\r\n   * Specifies the event name for panStart.\r\n   */\n  PAN_START: _mxEventUtils[\"default\"].PAN_START,\n  /**\r\n   * Variable: PAN\r\n   *\r\n   * Specifies the event name for pan.\r\n   */\n  PAN: _mxEventUtils[\"default\"].PAN,\n  /**\r\n   * Variable: PAN_END\r\n   *\r\n   * Specifies the event name for panEnd.\r\n   */\n  PAN_END: _mxEventUtils[\"default\"].PAN_END,\n  /**\r\n   * Variable: MINIMIZE\r\n   *\r\n   * Specifies the event name for minimize.\r\n   */\n  MINIMIZE: _mxEventUtils[\"default\"].MINIMIZE,\n  /**\r\n   * Variable: NORMALIZE\r\n   *\r\n   * Specifies the event name for normalize.\r\n   */\n  NORMALIZE: _mxEventUtils[\"default\"].NORMALIZE,\n  /**\r\n   * Variable: MAXIMIZE\r\n   *\r\n   * Specifies the event name for maximize.\r\n   */\n  MAXIMIZE: _mxEventUtils[\"default\"].MAXIMIZE,\n  /**\r\n   * Variable: HIDE\r\n   *\r\n   * Specifies the event name for hide.\r\n   */\n  HIDE: _mxEventUtils[\"default\"].HIDE,\n  /**\r\n   * Variable: SHOW\r\n   *\r\n   * Specifies the event name for show.\r\n   */\n  SHOW: _mxEventUtils[\"default\"].SHOW,\n  /**\r\n   * Variable: CLOSE\r\n   *\r\n   * Specifies the event name for close.\r\n   */\n  CLOSE: _mxEventUtils[\"default\"].CLOSE,\n  /**\r\n   * Variable: DESTROY\r\n   *\r\n   * Specifies the event name for destroy.\r\n   */\n  DESTROY: _mxEventUtils[\"default\"].DESTROY,\n  /**\r\n   * Variable: REFRESH\r\n   *\r\n   * Specifies the event name for refresh.\r\n   */\n  REFRESH: _mxEventUtils[\"default\"].REFRESH,\n  /**\r\n   * Variable: SIZE\r\n   *\r\n   * Specifies the event name for size.\r\n   */\n  SIZE: _mxEventUtils[\"default\"].SIZE,\n  /**\r\n   * Variable: SELECT\r\n   *\r\n   * Specifies the event name for select.\r\n   */\n  SELECT: _mxEventUtils[\"default\"].SELECT,\n  /**\r\n   * Variable: FIRED\r\n   *\r\n   * Specifies the event name for fired.\r\n   */\n  FIRED: _mxEventUtils[\"default\"].FIRED,\n  /**\r\n   * Variable: FIRE_MOUSE_EVENT\r\n   *\r\n   * Specifies the event name for fireMouseEvent.\r\n   */\n  FIRE_MOUSE_EVENT: _mxEventUtils[\"default\"].FIRE_MOUSE_EVENT,\n  /**\r\n   * Variable: GESTURE\r\n   *\r\n   * Specifies the event name for gesture.\r\n   */\n  GESTURE: _mxEventUtils[\"default\"].GESTURE,\n  /**\r\n   * Variable: TAP_AND_HOLD\r\n   *\r\n   * Specifies the event name for tapAndHold.\r\n   */\n  TAP_AND_HOLD: _mxEventUtils[\"default\"].TAP_AND_HOLD,\n  /**\r\n   * Variable: GET\r\n   *\r\n   * Specifies the event name for get.\r\n   */\n  GET: _mxEventUtils[\"default\"].GET,\n  /**\r\n   * Variable: RECEIVE\r\n   *\r\n   * Specifies the event name for receive.\r\n   */\n  RECEIVE: _mxEventUtils[\"default\"].RECEIVE,\n  /**\r\n   * Variable: CONNECT\r\n   *\r\n   * Specifies the event name for connect.\r\n   */\n  CONNECT: _mxEventUtils[\"default\"].CONNECT,\n  /**\r\n   * Variable: DISCONNECT\r\n   *\r\n   * Specifies the event name for disconnect.\r\n   */\n  DISCONNECT: _mxEventUtils[\"default\"].DISCONNECT,\n  /**\r\n   * Variable: SUSPEND\r\n   *\r\n   * Specifies the event name for suspend.\r\n   */\n  SUSPEND: _mxEventUtils[\"default\"].SUSPEND,\n  /**\r\n   * Variable: RESUME\r\n   *\r\n   * Specifies the event name for suspend.\r\n   */\n  RESUME: _mxEventUtils[\"default\"].RESUME,\n  /**\r\n   * Variable: MARK\r\n   *\r\n   * Specifies the event name for mark.\r\n   */\n  MARK: _mxEventUtils[\"default\"].MARK,\n  /**\r\n   * Variable: ROOT\r\n   *\r\n   * Specifies the event name for root.\r\n   */\n  ROOT: _mxEventUtils[\"default\"].ROOT,\n  /**\r\n   * Variable: POST\r\n   *\r\n   * Specifies the event name for post.\r\n   */\n  POST: _mxEventUtils[\"default\"].POST,\n  /**\r\n   * Variable: OPEN\r\n   *\r\n   * Specifies the event name for open.\r\n   */\n  OPEN: _mxEventUtils[\"default\"].OPEN,\n  /**\r\n   * Variable: SAVE\r\n   *\r\n   * Specifies the event name for open.\r\n   */\n  SAVE: _mxEventUtils[\"default\"].SAVE,\n  /**\r\n   * Variable: BEFORE_ADD_VERTEX\r\n   *\r\n   * Specifies the event name for beforeAddVertex.\r\n   */\n  BEFORE_ADD_VERTEX: _mxEventUtils[\"default\"].BEFORE_ADD_VERTEX,\n  /**\r\n   * Variable: ADD_VERTEX\r\n   *\r\n   * Specifies the event name for addVertex.\r\n   */\n  ADD_VERTEX: _mxEventUtils[\"default\"].ADD_VERTEX,\n  /**\r\n   * Variable: AFTER_ADD_VERTEX\r\n   *\r\n   * Specifies the event name for afterAddVertex.\r\n   */\n  AFTER_ADD_VERTEX: _mxEventUtils[\"default\"].AFTER_ADD_VERTEX,\n  /**\r\n   * Variable: DONE\r\n   *\r\n   * Specifies the event name for done.\r\n   */\n  DONE: _mxEventUtils[\"default\"].DONE,\n  /**\r\n   * Variable: EXECUTE\r\n   *\r\n   * Specifies the event name for execute.\r\n   */\n  EXECUTE: _mxEventUtils[\"default\"].EXECUTE,\n  /**\r\n   * Variable: EXECUTED\r\n   *\r\n   * Specifies the event name for executed.\r\n   */\n  EXECUTED: _mxEventUtils[\"default\"].EXECUTED,\n  /**\r\n   * Variable: BEGIN_UPDATE\r\n   *\r\n   * Specifies the event name for beginUpdate.\r\n   */\n  BEGIN_UPDATE: _mxEventUtils[\"default\"].BEGIN_UPDATE,\n  /**\r\n   * Variable: START_EDIT\r\n   *\r\n   * Specifies the event name for startEdit.\r\n   */\n  START_EDIT: _mxEventUtils[\"default\"].START_EDIT,\n  /**\r\n   * Variable: END_UPDATE\r\n   *\r\n   * Specifies the event name for endUpdate.\r\n   */\n  END_UPDATE: _mxEventUtils[\"default\"].END_UPDATE,\n  /**\r\n   * Variable: END_EDIT\r\n   *\r\n   * Specifies the event name for endEdit.\r\n   */\n  END_EDIT: _mxEventUtils[\"default\"].END_EDIT,\n  /**\r\n   * Variable: BEFORE_UNDO\r\n   *\r\n   * Specifies the event name for beforeUndo.\r\n   */\n  BEFORE_UNDO: _mxEventUtils[\"default\"].BEFORE_UNDO,\n  /**\r\n   * Variable: UNDO\r\n   *\r\n   * Specifies the event name for undo.\r\n   */\n  UNDO: _mxEventUtils[\"default\"].UNDO,\n  /**\r\n   * Variable: REDO\r\n   *\r\n   * Specifies the event name for redo.\r\n   */\n  REDO: _mxEventUtils[\"default\"].REDO,\n  /**\r\n   * Variable: CHANGE\r\n   *\r\n   * Specifies the event name for change.\r\n   */\n  CHANGE: _mxEventUtils[\"default\"].CHANGE,\n  /**\r\n   * Variable: NOTIFY\r\n   *\r\n   * Specifies the event name for notify.\r\n   */\n  NOTIFY: _mxEventUtils[\"default\"].NOTIFY,\n  /**\r\n   * Variable: LAYOUT_CELLS\r\n   *\r\n   * Specifies the event name for layoutCells.\r\n   */\n  LAYOUT_CELLS: _mxEventUtils[\"default\"].LAYOUT_CELLS,\n  /**\r\n   * Variable: CLICK\r\n   *\r\n   * Specifies the event name for click.\r\n   */\n  CLICK: _mxEventUtils[\"default\"].CLICK,\n  /**\r\n   * Variable: SCALE\r\n   *\r\n   * Specifies the event name for scale.\r\n   */\n  SCALE: _mxEventUtils[\"default\"].SCALE,\n  /**\r\n   * Variable: TRANSLATE\r\n   *\r\n   * Specifies the event name for translate.\r\n   */\n  TRANSLATE: _mxEventUtils[\"default\"].TRANSLATE,\n  /**\r\n   * Variable: SCALE_AND_TRANSLATE\r\n   *\r\n   * Specifies the event name for scaleAndTranslate.\r\n   */\n  SCALE_AND_TRANSLATE: _mxEventUtils[\"default\"].SCALE_AND_TRANSLATE,\n  /**\r\n   * Variable: UP\r\n   *\r\n   * Specifies the event name for up.\r\n   */\n  UP: _mxEventUtils[\"default\"].UP,\n  /**\r\n   * Variable: DOWN\r\n   *\r\n   * Specifies the event name for down.\r\n   */\n  DOWN: _mxEventUtils[\"default\"].DOWN,\n  /**\r\n   * Variable: ADD\r\n   *\r\n   * Specifies the event name for add.\r\n   */\n  ADD: _mxEventUtils[\"default\"].ADD,\n  /**\r\n   * Variable: REMOVE\r\n   *\r\n   * Specifies the event name for remove.\r\n   */\n  REMOVE: _mxEventUtils[\"default\"].REMOVE,\n  /**\r\n   * Variable: CLEAR\r\n   *\r\n   * Specifies the event name for clear.\r\n   */\n  CLEAR: _mxEventUtils[\"default\"].CLEAR,\n  /**\r\n   * Variable: ADD_CELLS\r\n   *\r\n   * Specifies the event name for addCells.\r\n   */\n  ADD_CELLS: _mxEventUtils[\"default\"].ADD_CELLS,\n  /**\r\n   * Variable: CELLS_ADDED\r\n   *\r\n   * Specifies the event name for cellsAdded.\r\n   */\n  CELLS_ADDED: _mxEventUtils[\"default\"].CELLS_ADDED,\n  /**\r\n   * Variable: MOVE_CELLS\r\n   *\r\n   * Specifies the event name for moveCells.\r\n   */\n  MOVE_CELLS: _mxEventUtils[\"default\"].MOVE_CELLS,\n  /**\r\n   * Variable: CELLS_MOVED\r\n   *\r\n   * Specifies the event name for cellsMoved.\r\n   */\n  CELLS_MOVED: _mxEventUtils[\"default\"].CELLS_MOVED,\n  /**\r\n   * Variable: RESIZE_CELLS\r\n   *\r\n   * Specifies the event name for resizeCells.\r\n   */\n  RESIZE_CELLS: _mxEventUtils[\"default\"].RESIZE_CELLS,\n  /**\r\n   * Variable: CELLS_RESIZED\r\n   *\r\n   * Specifies the event name for cellsResized.\r\n   */\n  CELLS_RESIZED: _mxEventUtils[\"default\"].CELLS_RESIZED,\n  /**\r\n   * Variable: TOGGLE_CELLS\r\n   *\r\n   * Specifies the event name for toggleCells.\r\n   */\n  TOGGLE_CELLS: _mxEventUtils[\"default\"].TOGGLE_CELLS,\n  /**\r\n   * Variable: CELLS_TOGGLED\r\n   *\r\n   * Specifies the event name for cellsToggled.\r\n   */\n  CELLS_TOGGLED: _mxEventUtils[\"default\"].CELLS_TOGGLED,\n  /**\r\n   * Variable: ORDER_CELLS\r\n   *\r\n   * Specifies the event name for orderCells.\r\n   */\n  ORDER_CELLS: _mxEventUtils[\"default\"].ORDER_CELLS,\n  PASTE_CELLS: _mxEventUtils[\"default\"].PASTE_CELLS,\n  /**\r\n   * Variable: CELLS_ORDERED\r\n   *\r\n   * Specifies the event name for cellsOrdered.\r\n   */\n  CELLS_ORDERED: _mxEventUtils[\"default\"].CELLS_ORDERED,\n  /**\r\n   * Variable: REMOVE_CELLS\r\n   *\r\n   * Specifies the event name for removeCells.\r\n   */\n  REMOVE_CELLS: _mxEventUtils[\"default\"].REMOVE_CELLS,\n  /**\r\n   * Variable: CELLS_REMOVED\r\n   *\r\n   * Specifies the event name for cellsRemoved.\r\n   */\n  CELLS_REMOVED: _mxEventUtils[\"default\"].CELLS_REMOVED,\n  /**\r\n   * Variable: GROUP_CELLS\r\n   *\r\n   * Specifies the event name for groupCells.\r\n   */\n  GROUP_CELLS: _mxEventUtils[\"default\"].GROUP_CELLS,\n  /**\r\n   * Variable: UNGROUP_CELLS\r\n   *\r\n   * Specifies the event name for ungroupCells.\r\n   */\n  UNGROUP_CELLS: _mxEventUtils[\"default\"].UNGROUP_CELLS,\n  /**\r\n   * Variable: REMOVE_CELLS_FROM_PARENT\r\n   *\r\n   * Specifies the event name for removeCellsFromParent.\r\n   */\n  REMOVE_CELLS_FROM_PARENT: _mxEventUtils[\"default\"].REMOVE_CELLS_FROM_PARENT,\n  /**\r\n   * Variable: FOLD_CELLS\r\n   *\r\n   * Specifies the event name for foldCells.\r\n   */\n  FOLD_CELLS: _mxEventUtils[\"default\"].FOLD_CELLS,\n  /**\r\n   * Variable: CELLS_FOLDED\r\n   *\r\n   * Specifies the event name for cellsFolded.\r\n   */\n  CELLS_FOLDED: _mxEventUtils[\"default\"].CELLS_FOLDED,\n  /**\r\n   * Variable: ALIGN_CELLS\r\n   *\r\n   * Specifies the event name for alignCells.\r\n   */\n  ALIGN_CELLS: _mxEventUtils[\"default\"].ALIGN_CELLS,\n  /**\r\n   * Variable: LABEL_CHANGED\r\n   *\r\n   * Specifies the event name for labelChanged.\r\n   */\n  LABEL_CHANGED: _mxEventUtils[\"default\"].LABEL_CHANGED,\n  /**\r\n   * Variable: CONNECT_CELL\r\n   *\r\n   * Specifies the event name for connectCell.\r\n   */\n  CONNECT_CELL: _mxEventUtils[\"default\"].CONNECT_CELL,\n  /**\r\n   * Variable: CELL_CONNECTED\r\n   *\r\n   * Specifies the event name for cellConnected.\r\n   */\n  CELL_CONNECTED: _mxEventUtils[\"default\"].CELL_CONNECTED,\n  /**\r\n   * Variable: SPLIT_EDGE\r\n   *\r\n   * Specifies the event name for splitEdge.\r\n   */\n  SPLIT_EDGE: _mxEventUtils[\"default\"].SPLIT_EDGE,\n  /**\r\n   * Variable: FLIP_EDGE\r\n   *\r\n   * Specifies the event name for flipEdge.\r\n   */\n  FLIP_EDGE: _mxEventUtils[\"default\"].FLIP_EDGE,\n  /**\r\n   * Variable: START_EDITING\r\n   *\r\n   * Specifies the event name for startEditing.\r\n   */\n  START_EDITING: _mxEventUtils[\"default\"].START_EDITING,\n  /**\r\n   * Variable: EDITING_STARTED\r\n   *\r\n   * Specifies the event name for editingStarted.\r\n   */\n  EDITING_STARTED: _mxEventUtils[\"default\"].EDITING_STARTED,\n  /**\r\n   * Variable: EDITING_STOPPED\r\n   *\r\n   * Specifies the event name for editingStopped.\r\n   */\n  EDITING_STOPPED: _mxEventUtils[\"default\"].EDITING_STOPPED,\n  /**\r\n   * Variable: ADD_OVERLAY\r\n   *\r\n   * Specifies the event name for addOverlay.\r\n   */\n  ADD_OVERLAY: _mxEventUtils[\"default\"].ADD_OVERLAY,\n  /**\r\n   * Variable: REMOVE_OVERLAY\r\n   *\r\n   * Specifies the event name for removeOverlay.\r\n   */\n  REMOVE_OVERLAY: _mxEventUtils[\"default\"].REMOVE_OVERLAY,\n  /**\r\n   * Variable: UPDATE_CELL_SIZE\r\n   *\r\n   * Specifies the event name for updateCellSize.\r\n   */\n  UPDATE_CELL_SIZE: _mxEventUtils[\"default\"].UPDATE_CELL_SIZE,\n  /**\r\n   * Variable: ESCAPE\r\n   *\r\n   * Specifies the event name for escape.\r\n   */\n  ESCAPE: _mxEventUtils[\"default\"].ESCAPE,\n  /**\r\n   * Variable: DOUBLE_CLICK\r\n   *\r\n   * Specifies the event name for doubleClick.\r\n   */\n  DOUBLE_CLICK: _mxEventUtils[\"default\"].DOUBLE_CLICK,\n  /**\r\n   * Variable: START\r\n   *\r\n   * Specifies the event name for start.\r\n   */\n  START: _mxEventUtils[\"default\"].START,\n  /**\r\n   * Variable: RESET\r\n   *\r\n   * Specifies the event name for reset.\r\n   */\n  RESET: _mxEventUtils[\"default\"].RESET\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxXmlRequest\r\n *\r\n * XML HTTP request wrapper. See also: <mxRequestUtils.get>, <mxUtils.post> and\r\n * <mxRequestUtils.load>. This class provides a cross-browser abstraction for Ajax\r\n * requests.\r\n *\r\n * Encoding:\r\n *\r\n * For encoding parameter values, the built-in encodeURIComponent JavaScript\r\n * method must be used. For automatic encoding of post data in <mxEditor> the\r\n * <mxEditor.escapePostData> switch can be set to true (default). The encoding\r\n * will be carried out using the conte type of the page. That is, the page\r\n * containting the editor should contain a meta tag in the header, eg.\r\n * <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\r\n *\r\n * Example:\r\n *\r\n * (code)\r\n * var onload = function(req)\r\n * {\r\n *   mxUtils.alert(req.getDocumentElement());\r\n * }\r\n *\r\n * var onerror = function(req)\r\n * {\r\n *   mxUtils.alert('Error');\r\n * }\r\n * new mxXmlRequest(url, 'key=value').send(onload, onerror);\r\n * (end)\r\n *\r\n * Sends an asynchronous POST request to the specified URL.\r\n *\r\n * Example:\r\n *\r\n * (code)\r\n * var req = new mxXmlRequest(url, 'key=value', 'POST', false);\r\n * req.send();\r\n * mxUtils.alert(req.getDocumentElement());\r\n * (end)\r\n *\r\n * Sends a synchronous POST request to the specified URL.\r\n *\r\n * Example:\r\n *\r\n * (code)\r\n * var encoder = new mxCodec();\r\n * var result = encoder.encode(graph.getModel());\r\n * var xml = encodeURIComponent(mxUtils.getXml(result));\r\n * new mxXmlRequest(url, 'xml='+xml).send();\r\n * (end)\r\n *\r\n * Sends an encoded graph model to the specified URL using xml as the\r\n * parameter name. The parameter can then be retrieved in C# as follows:\r\n *\r\n * (code)\r\n * string xml = HttpUtility.UrlDecode(context.Request.Params[\"xml\"]);\r\n * (end)\r\n *\r\n * Or in Java as follows:\r\n *\r\n * (code)\r\n * String xml = URLDecoder.decode(request.getParameter(\"xml\"), \"UTF-8\").replace(\"\\n\", \"&#xa;\");\r\n * (end)\r\n *\r\n * Note that the linefeeds should only be replaced if the XML is\r\n * processed in Java, for example when creating an image.\r\n *\r\n * Constructor: mxXmlRequest\r\n *\r\n * Constructs an XML HTTP request.\r\n *\r\n * Parameters:\r\n *\r\n * url - Target URL of the request.\r\n * params - Form encoded parameters to send with a POST request.\r\n * method - String that specifies the request method. Possible values are\r\n * POST and GET. Default is POST.\r\n * async - Boolean specifying if an asynchronous request should be used.\r\n * Default is true.\r\n * username - String specifying the username to be used for the request.\r\n * password - String specifying the password to be used for the request.\r\n */\nvar _default = exports[\"default\"] = mxEvent;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxEvent.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxEventObject.js":
/*!************************************************!*\
  !*** ./src/workflow/mxClient/mxEventObject.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.function.name.js */ \"../../node_modules/core-js/modules/es.function.name.js\");\nfunction mxEventObject(name) {\n  this.name = name;\n  this.properties = [];\n  for (var i = 1; i < arguments.length; i += 2) {\n    if (arguments[i + 1] != null) {\n      this.properties[arguments[i]] = arguments[i + 1];\n    }\n  }\n}\n;\n\n/**\r\n * Variable: name\r\n *\r\n * Holds the name.\r\n */\nmxEventObject.prototype.name = null;\n\n/**\r\n * Variable: properties\r\n *\r\n * Holds the properties as an associative array.\r\n */\nmxEventObject.prototype.properties = null;\n\n/**\r\n * Variable: consumed\r\n *\r\n * Holds the consumed state. Default is false.\r\n */\nmxEventObject.prototype.consumed = false;\n\n/**\r\n * Function: getName\r\n *\r\n * Returns <name>.\r\n */\nmxEventObject.prototype.getName = function () {\n  return this.name;\n};\n\n/**\r\n * Function: getProperties\r\n *\r\n * Returns <properties>.\r\n */\nmxEventObject.prototype.getProperties = function () {\n  return this.properties;\n};\n\n/**\r\n * Function: getProperty\r\n *\r\n * Returns the property for the given key.\r\n */\nmxEventObject.prototype.getProperty = function (key) {\n  return this.properties[key];\n};\n\n/**\r\n * Function: isConsumed\r\n *\r\n * Returns true if the event has been consumed.\r\n */\nmxEventObject.prototype.isConsumed = function () {\n  return this.consumed;\n};\n\n/**\r\n * Function: consume\r\n *\r\n * Consumes the event.\r\n */\nmxEventObject.prototype.consume = function () {\n  this.consumed = true;\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxMouseEvent\r\n *\r\n * Base class for all mouse events in mxGraph. A listener for this event should\r\n * implement the following methods:\r\n *\r\n * (code)\r\n * graph.addMouseListener(\r\n * {\r\n *   mouseDown: function(sender, evt)\r\n *   {\r\n *     mxLog.debug('mouseDown');\r\n *   },\r\n *   mouseMove: function(sender, evt)\r\n *   {\r\n *     mxLog.debug('mouseMove');\r\n *   },\r\n *   mouseUp: function(sender, evt)\r\n *   {\r\n *     mxLog.debug('mouseUp');\r\n *   }\r\n * });\r\n * (end)\r\n *\r\n * Constructor: mxMouseEvent\r\n *\r\n * Constructs a new event object for the given arguments.\r\n *\r\n * Parameters:\r\n *\r\n * evt - Native mouse event.\r\n * state - Optional <mxCellState> under the mouse.\r\n *\r\n */\nvar _default = exports[\"default\"] = mxEventObject;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxEventObject.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxEventSource.js":
/*!************************************************!*\
  !*** ./src/workflow/mxClient/mxEventSource.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.splice.js */ \"../../node_modules/core-js/modules/es.array.splice.js\");\nvar _mxEventObject = _interopRequireDefault(__webpack_require__(/*! ./mxEventObject.js */ \"./src/workflow/mxClient/mxEventObject.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxEventSource(eventSource) {\n  this.setEventSource(eventSource);\n}\n;\n\n/**\r\n * Variable: eventListeners\r\n *\r\n * Holds the event names and associated listeners in an array. The array\r\n * contains the event name followed by the respective listener for each\r\n * registered listener.\r\n */\nmxEventSource.prototype.eventListeners = null;\n\n/**\r\n * Variable: eventsEnabled\r\n *\r\n * Specifies if events can be fired. Default is true.\r\n */\nmxEventSource.prototype.eventsEnabled = true;\n\n/**\r\n * Variable: eventSource\r\n *\r\n * Optional source for events. Default is null.\r\n */\nmxEventSource.prototype.eventSource = null;\n\n/**\r\n * Function: isEventsEnabled\r\n *\r\n * Returns <eventsEnabled>.\r\n */\nmxEventSource.prototype.isEventsEnabled = function () {\n  return this.eventsEnabled;\n};\n\n/**\r\n * Function: setEventsEnabled\r\n *\r\n * Sets <eventsEnabled>.\r\n */\nmxEventSource.prototype.setEventsEnabled = function (value) {\n  this.eventsEnabled = value;\n};\n\n/**\r\n * Function: getEventSource\r\n *\r\n * Returns <eventSource>.\r\n */\nmxEventSource.prototype.getEventSource = function () {\n  return this.eventSource;\n};\n\n/**\r\n * Function: setEventSource\r\n *\r\n * Sets <eventSource>.\r\n */\nmxEventSource.prototype.setEventSource = function (value) {\n  this.eventSource = value;\n};\n\n/**\r\n * Function: addListener\r\n *\r\n * Binds the specified function to the given event name. If no event name\r\n * is given, then the listener is registered for all events.\r\n *\r\n * The parameters of the listener are the sender and an <mxEventObject>.\r\n */\nmxEventSource.prototype.addListener = function (name, funct) {\n  if (this.eventListeners == null) {\n    this.eventListeners = [];\n  }\n  this.eventListeners.push(name);\n  this.eventListeners.push(funct);\n};\n\n/**\r\n * Function: removeListener\r\n *\r\n * Removes all occurrences of the given listener from <eventListeners>.\r\n */\nmxEventSource.prototype.removeListener = function (funct) {\n  if (this.eventListeners != null) {\n    var i = 0;\n    while (i < this.eventListeners.length) {\n      if (this.eventListeners[i + 1] == funct) {\n        this.eventListeners.splice(i, 2);\n      } else {\n        i += 2;\n      }\n    }\n  }\n};\n\n/**\r\n * Function: fireEvent\r\n *\r\n * Dispatches the given event to the listeners which are registered for\r\n * the event. The sender argument is optional. The current execution scope\r\n * (\"this\") is used for the listener invocation (see <mxGraphUtils.bind>).\r\n *\r\n * Example:\r\n *\r\n * (code)\r\n * fireEvent(new mxEventObject(\"eventName\", key1, val1, .., keyN, valN))\r\n * (end)\r\n *\r\n * Parameters:\r\n *\r\n * evt - <mxEventObject> that represents the event.\r\n * sender - Optional sender to be passed to the listener. Default value is\r\n * the return value of <getEventSource>.\r\n */\nmxEventSource.prototype.fireEvent = function (evt, sender) {\n  if (this.eventListeners != null && this.isEventsEnabled()) {\n    if (evt == null) {\n      evt = new _mxEventObject[\"default\"]();\n    }\n    if (sender == null) {\n      sender = this.getEventSource();\n    }\n    if (sender == null) {\n      sender = this;\n    }\n    var args = [sender, evt];\n    for (var i = 0; i < this.eventListeners.length; i += 2) {\n      var listen = this.eventListeners[i];\n      if (listen == null || listen == evt.getName()) {\n        this.eventListeners[i + 1].apply(this, args);\n      }\n    }\n  }\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\nvar _default = exports[\"default\"] = mxEventSource;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxEventSource.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxEventUtils.js":
/*!***********************************************!*\
  !*** ./src/workflow/mxClient/mxEventUtils.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.index-of.js */ \"../../node_modules/core-js/modules/es.array.index-of.js\");\n__webpack_require__(/*! core-js/modules/es.array.splice.js */ \"../../node_modules/core-js/modules/es.array.splice.js\");\n__webpack_require__(/*! core-js/modules/es.function.name.js */ \"../../node_modules/core-js/modules/es.function.name.js\");\nvar _mxClient = _interopRequireDefault(__webpack_require__(/*! ./mxClient.js */ \"./src/workflow/mxClient/mxClient.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nvar mxEventUtils = {\n  /**\r\n   * Variable: LABEL_HANDLE\r\n   *\r\n   * Index for the label handle in an mxMouseEvent. This should be a negative\r\n   * value that does not interfere with any possible handle indices. Default\r\n   * is -1.\r\n   */\n  LABEL_HANDLE: -1,\n  /**\r\n   * Variable: ROTATION_HANDLE\r\n   *\r\n   * Index for the rotation handle in an mxMouseEvent. This should be a\r\n   * negative value that does not interfere with any possible handle indices.\r\n   * Default is -2.\r\n   */\n  ROTATION_HANDLE: -2,\n  /**\r\n   * Variable: CUSTOM_HANDLE\r\n   *\r\n   * Start index for the custom handles in an mxMouseEvent. This should be a\r\n   * negative value and is the start index which is decremented for each\r\n   * custom handle. Default is -100.\r\n   */\n  CUSTOM_HANDLE: -100,\n  /**\r\n   * Variable: VIRTUAL_HANDLE\r\n   *\r\n   * Start index for the virtual handles in an mxMouseEvent. This should be a\r\n   * negative value and is the start index which is decremented for each\r\n   * virtual handle. Default is -100000. This assumes that there are no more\r\n   * than VIRTUAL_HANDLE - CUSTOM_HANDLE custom handles.\r\n   *\r\n   */\n  VIRTUAL_HANDLE: -100000,\n  //\n  // Event names\n  //\n\n  /**\r\n   * Variable: MOUSE_DOWN\r\n   *\r\n   * Specifies the event name for mouseDown.\r\n   */\n  MOUSE_DOWN: 'mouseDown',\n  /**\r\n   * Variable: MOUSE_MOVE\r\n   *\r\n   * Specifies the event name for mouseMove.\r\n   */\n  MOUSE_MOVE: 'mouseMove',\n  /**\r\n   * Variable: MOUSE_UP\r\n   *\r\n   * Specifies the event name for mouseUp.\r\n   */\n  MOUSE_UP: 'mouseUp',\n  /**\r\n   * Variable: ACTIVATE\r\n   *\r\n   * Specifies the event name for activate.\r\n   */\n  ACTIVATE: 'activate',\n  /**\r\n   * Variable: RESIZE_START\r\n   *\r\n   * Specifies the event name for resizeStart.\r\n   */\n  RESIZE_START: 'resizeStart',\n  /**\r\n   * Variable: RESIZE\r\n   *\r\n   * Specifies the event name for resize.\r\n   */\n  RESIZE: 'resize',\n  /**\r\n   * Variable: RESIZE_END\r\n   *\r\n   * Specifies the event name for resizeEnd.\r\n   */\n  RESIZE_END: 'resizeEnd',\n  /**\r\n   * Variable: MOVE_START\r\n   *\r\n   * Specifies the event name for moveStart.\r\n   */\n  MOVE_START: 'moveStart',\n  /**\r\n   * Variable: MOVE\r\n   *\r\n   * Specifies the event name for move.\r\n   */\n  MOVE: 'move',\n  /**\r\n   * Variable: MOVE_END\r\n   *\r\n   * Specifies the event name for moveEnd.\r\n   */\n  MOVE_END: 'moveEnd',\n  /**\r\n   * Variable: PAN_START\r\n   *\r\n   * Specifies the event name for panStart.\r\n   */\n  PAN_START: 'panStart',\n  /**\r\n   * Variable: PAN\r\n   *\r\n   * Specifies the event name for pan.\r\n   */\n  PAN: 'pan',\n  /**\r\n   * Variable: PAN_END\r\n   *\r\n   * Specifies the event name for panEnd.\r\n   */\n  PAN_END: 'panEnd',\n  /**\r\n   * Variable: MINIMIZE\r\n   *\r\n   * Specifies the event name for minimize.\r\n   */\n  MINIMIZE: 'minimize',\n  /**\r\n   * Variable: NORMALIZE\r\n   *\r\n   * Specifies the event name for normalize.\r\n   */\n  NORMALIZE: 'normalize',\n  /**\r\n   * Variable: MAXIMIZE\r\n   *\r\n   * Specifies the event name for maximize.\r\n   */\n  MAXIMIZE: 'maximize',\n  /**\r\n   * Variable: HIDE\r\n   *\r\n   * Specifies the event name for hide.\r\n   */\n  HIDE: 'hide',\n  /**\r\n   * Variable: SHOW\r\n   *\r\n   * Specifies the event name for show.\r\n   */\n  SHOW: 'show',\n  /**\r\n   * Variable: CLOSE\r\n   *\r\n   * Specifies the event name for close.\r\n   */\n  CLOSE: 'close',\n  /**\r\n   * Variable: DESTROY\r\n   *\r\n   * Specifies the event name for destroy.\r\n   */\n  DESTROY: 'destroy',\n  /**\r\n   * Variable: REFRESH\r\n   *\r\n   * Specifies the event name for refresh.\r\n   */\n  REFRESH: 'refresh',\n  /**\r\n   * Variable: SIZE\r\n   *\r\n   * Specifies the event name for size.\r\n   */\n  SIZE: 'size',\n  /**\r\n   * Variable: SELECT\r\n   *\r\n   * Specifies the event name for select.\r\n   */\n  SELECT: 'select',\n  /**\r\n   * Variable: FIRED\r\n   *\r\n   * Specifies the event name for fired.\r\n   */\n  FIRED: 'fired',\n  /**\r\n   * Variable: FIRE_MOUSE_EVENT\r\n   *\r\n   * Specifies the event name for fireMouseEvent.\r\n   */\n  FIRE_MOUSE_EVENT: 'fireMouseEvent',\n  /**\r\n   * Variable: GESTURE\r\n   *\r\n   * Specifies the event name for gesture.\r\n   */\n  GESTURE: 'gesture',\n  /**\r\n   * Variable: TAP_AND_HOLD\r\n   *\r\n   * Specifies the event name for tapAndHold.\r\n   */\n  TAP_AND_HOLD: 'tapAndHold',\n  /**\r\n   * Variable: GET\r\n   *\r\n   * Specifies the event name for get.\r\n   */\n  GET: 'get',\n  /**\r\n   * Variable: RECEIVE\r\n   *\r\n   * Specifies the event name for receive.\r\n   */\n  RECEIVE: 'receive',\n  /**\r\n   * Variable: CONNECT\r\n   *\r\n   * Specifies the event name for connect.\r\n   */\n  CONNECT: 'connect',\n  /**\r\n   * Variable: DISCONNECT\r\n   *\r\n   * Specifies the event name for disconnect.\r\n   */\n  DISCONNECT: 'disconnect',\n  /**\r\n   * Variable: SUSPEND\r\n   *\r\n   * Specifies the event name for suspend.\r\n   */\n  SUSPEND: 'suspend',\n  /**\r\n   * Variable: RESUME\r\n   *\r\n   * Specifies the event name for suspend.\r\n   */\n  RESUME: 'resume',\n  /**\r\n   * Variable: MARK\r\n   *\r\n   * Specifies the event name for mark.\r\n   */\n  MARK: 'mark',\n  /**\r\n   * Variable: ROOT\r\n   *\r\n   * Specifies the event name for root.\r\n   */\n  ROOT: 'root',\n  /**\r\n   * Variable: POST\r\n   *\r\n   * Specifies the event name for post.\r\n   */\n  POST: 'post',\n  /**\r\n   * Variable: OPEN\r\n   *\r\n   * Specifies the event name for open.\r\n   */\n  OPEN: 'open',\n  /**\r\n   * Variable: SAVE\r\n   *\r\n   * Specifies the event name for open.\r\n   */\n  SAVE: 'save',\n  /**\r\n   * Variable: BEFORE_ADD_VERTEX\r\n   *\r\n   * Specifies the event name for beforeAddVertex.\r\n   */\n  BEFORE_ADD_VERTEX: 'beforeAddVertex',\n  /**\r\n   * Variable: ADD_VERTEX\r\n   *\r\n   * Specifies the event name for addVertex.\r\n   */\n  ADD_VERTEX: 'addVertex',\n  /**\r\n   * Variable: AFTER_ADD_VERTEX\r\n   *\r\n   * Specifies the event name for afterAddVertex.\r\n   */\n  AFTER_ADD_VERTEX: 'afterAddVertex',\n  /**\r\n   * Variable: DONE\r\n   *\r\n   * Specifies the event name for done.\r\n   */\n  DONE: 'done',\n  /**\r\n   * Variable: EXECUTE\r\n   *\r\n   * Specifies the event name for execute.\r\n   */\n  EXECUTE: 'execute',\n  /**\r\n   * Variable: EXECUTED\r\n   *\r\n   * Specifies the event name for executed.\r\n   */\n  EXECUTED: 'executed',\n  /**\r\n   * Variable: BEGIN_UPDATE\r\n   *\r\n   * Specifies the event name for beginUpdate.\r\n   */\n  BEGIN_UPDATE: 'beginUpdate',\n  /**\r\n   * Variable: START_EDIT\r\n   *\r\n   * Specifies the event name for startEdit.\r\n   */\n  START_EDIT: 'startEdit',\n  /**\r\n   * Variable: END_UPDATE\r\n   *\r\n   * Specifies the event name for endUpdate.\r\n   */\n  END_UPDATE: 'endUpdate',\n  /**\r\n   * Variable: END_EDIT\r\n   *\r\n   * Specifies the event name for endEdit.\r\n   */\n  END_EDIT: 'endEdit',\n  /**\r\n   * Variable: BEFORE_UNDO\r\n   *\r\n   * Specifies the event name for beforeUndo.\r\n   */\n  BEFORE_UNDO: 'beforeUndo',\n  /**\r\n   * Variable: UNDO\r\n   *\r\n   * Specifies the event name for undo.\r\n   */\n  UNDO: 'undo',\n  /**\r\n   * Variable: REDO\r\n   *\r\n   * Specifies the event name for redo.\r\n   */\n  REDO: 'redo',\n  /**\r\n   * Variable: CHANGE\r\n   *\r\n   * Specifies the event name for change.\r\n   */\n  CHANGE: 'change',\n  /**\r\n   * Variable: NOTIFY\r\n   *\r\n   * Specifies the event name for notify.\r\n   */\n  NOTIFY: 'notify',\n  /**\r\n   * Variable: LAYOUT_CELLS\r\n   *\r\n   * Specifies the event name for layoutCells.\r\n   */\n  LAYOUT_CELLS: 'layoutCells',\n  /**\r\n   * Variable: CLICK\r\n   *\r\n   * Specifies the event name for click.\r\n   */\n  CLICK: 'click',\n  /**\r\n   * Variable: SCALE\r\n   *\r\n   * Specifies the event name for scale.\r\n   */\n  SCALE: 'scale',\n  /**\r\n   * Variable: TRANSLATE\r\n   *\r\n   * Specifies the event name for translate.\r\n   */\n  TRANSLATE: 'translate',\n  /**\r\n   * Variable: SCALE_AND_TRANSLATE\r\n   *\r\n   * Specifies the event name for scaleAndTranslate.\r\n   */\n  SCALE_AND_TRANSLATE: 'scaleAndTranslate',\n  /**\r\n   * Variable: UP\r\n   *\r\n   * Specifies the event name for up.\r\n   */\n  UP: 'up',\n  /**\r\n   * Variable: DOWN\r\n   *\r\n   * Specifies the event name for down.\r\n   */\n  DOWN: 'down',\n  /**\r\n   * Variable: ADD\r\n   *\r\n   * Specifies the event name for add.\r\n   */\n  ADD: 'add',\n  /**\r\n   * Variable: REMOVE\r\n   *\r\n   * Specifies the event name for remove.\r\n   */\n  REMOVE: 'remove',\n  /**\r\n   * Variable: CLEAR\r\n   *\r\n   * Specifies the event name for clear.\r\n   */\n  CLEAR: 'clear',\n  /**\r\n   * Variable: ADD_CELLS\r\n   *\r\n   * Specifies the event name for addCells.\r\n   */\n  ADD_CELLS: 'addCells',\n  /**\r\n   * Variable: CELLS_ADDED\r\n   *\r\n   * Specifies the event name for cellsAdded.\r\n   */\n  CELLS_ADDED: 'cellsAdded',\n  /**\r\n   * Variable: MOVE_CELLS\r\n   *\r\n   * Specifies the event name for moveCells.\r\n   */\n  MOVE_CELLS: 'moveCells',\n  /**\r\n   * Variable: CELLS_MOVED\r\n   *\r\n   * Specifies the event name for cellsMoved.\r\n   */\n  CELLS_MOVED: 'cellsMoved',\n  /**\r\n   * Variable: RESIZE_CELLS\r\n   *\r\n   * Specifies the event name for resizeCells.\r\n   */\n  RESIZE_CELLS: 'resizeCells',\n  /**\r\n   * Variable: CELLS_RESIZED\r\n   *\r\n   * Specifies the event name for cellsResized.\r\n   */\n  CELLS_RESIZED: 'cellsResized',\n  /**\r\n   * Variable: TOGGLE_CELLS\r\n   *\r\n   * Specifies the event name for toggleCells.\r\n   */\n  TOGGLE_CELLS: 'toggleCells',\n  /**\r\n   * Variable: CELLS_TOGGLED\r\n   *\r\n   * Specifies the event name for cellsToggled.\r\n   */\n  CELLS_TOGGLED: 'cellsToggled',\n  /**\r\n   * Variable: ORDER_CELLS\r\n   *\r\n   * Specifies the event name for orderCells.\r\n   */\n  ORDER_CELLS: 'orderCells',\n  PASTE_CELLS: 'pasteCells',\n  /**\r\n   * Variable: CELLS_ORDERED\r\n   *\r\n   * Specifies the event name for cellsOrdered.\r\n   */\n  CELLS_ORDERED: 'cellsOrdered',\n  /**\r\n   * Variable: REMOVE_CELLS\r\n   *\r\n   * Specifies the event name for removeCells.\r\n   */\n  REMOVE_CELLS: 'removeCells',\n  /**\r\n   * Variable: CELLS_REMOVED\r\n   *\r\n   * Specifies the event name for cellsRemoved.\r\n   */\n  CELLS_REMOVED: 'cellsRemoved',\n  /**\r\n   * Variable: GROUP_CELLS\r\n   *\r\n   * Specifies the event name for groupCells.\r\n   */\n  GROUP_CELLS: 'groupCells',\n  /**\r\n   * Variable: UNGROUP_CELLS\r\n   *\r\n   * Specifies the event name for ungroupCells.\r\n   */\n  UNGROUP_CELLS: 'ungroupCells',\n  /**\r\n   * Variable: REMOVE_CELLS_FROM_PARENT\r\n   *\r\n   * Specifies the event name for removeCellsFromParent.\r\n   */\n  REMOVE_CELLS_FROM_PARENT: 'removeCellsFromParent',\n  /**\r\n   * Variable: FOLD_CELLS\r\n   *\r\n   * Specifies the event name for foldCells.\r\n   */\n  FOLD_CELLS: 'foldCells',\n  /**\r\n   * Variable: CELLS_FOLDED\r\n   *\r\n   * Specifies the event name for cellsFolded.\r\n   */\n  CELLS_FOLDED: 'cellsFolded',\n  /**\r\n   * Variable: ALIGN_CELLS\r\n   *\r\n   * Specifies the event name for alignCells.\r\n   */\n  ALIGN_CELLS: 'alignCells',\n  /**\r\n   * Variable: LABEL_CHANGED\r\n   *\r\n   * Specifies the event name for labelChanged.\r\n   */\n  LABEL_CHANGED: 'labelChanged',\n  /**\r\n   * Variable: CONNECT_CELL\r\n   *\r\n   * Specifies the event name for connectCell.\r\n   */\n  CONNECT_CELL: 'connectCell',\n  /**\r\n   * Variable: CELL_CONNECTED\r\n   *\r\n   * Specifies the event name for cellConnected.\r\n   */\n  CELL_CONNECTED: 'cellConnected',\n  /**\r\n   * Variable: SPLIT_EDGE\r\n   *\r\n   * Specifies the event name for splitEdge.\r\n   */\n  SPLIT_EDGE: 'splitEdge',\n  /**\r\n   * Variable: FLIP_EDGE\r\n   *\r\n   * Specifies the event name for flipEdge.\r\n   */\n  FLIP_EDGE: 'flipEdge',\n  /**\r\n   * Variable: START_EDITING\r\n   *\r\n   * Specifies the event name for startEditing.\r\n   */\n  START_EDITING: 'startEditing',\n  /**\r\n   * Variable: EDITING_STARTED\r\n   *\r\n   * Specifies the event name for editingStarted.\r\n   */\n  EDITING_STARTED: 'editingStarted',\n  /**\r\n   * Variable: EDITING_STOPPED\r\n   *\r\n   * Specifies the event name for editingStopped.\r\n   */\n  EDITING_STOPPED: 'editingStopped',\n  /**\r\n   * Variable: ADD_OVERLAY\r\n   *\r\n   * Specifies the event name for addOverlay.\r\n   */\n  ADD_OVERLAY: 'addOverlay',\n  /**\r\n   * Variable: REMOVE_OVERLAY\r\n   *\r\n   * Specifies the event name for removeOverlay.\r\n   */\n  REMOVE_OVERLAY: 'removeOverlay',\n  /**\r\n   * Variable: UPDATE_CELL_SIZE\r\n   *\r\n   * Specifies the event name for updateCellSize.\r\n   */\n  UPDATE_CELL_SIZE: 'updateCellSize',\n  /**\r\n   * Variable: ESCAPE\r\n   *\r\n   * Specifies the event name for escape.\r\n   */\n  ESCAPE: 'escape',\n  /**\r\n   * Variable: DOUBLE_CLICK\r\n   *\r\n   * Specifies the event name for doubleClick.\r\n   */\n  DOUBLE_CLICK: 'doubleClick',\n  /**\r\n   * Variable: START\r\n   *\r\n   * Specifies the event name for start.\r\n   */\n  START: 'start',\n  /**\r\n   * Variable: RESET\r\n   *\r\n   * Specifies the event name for reset.\r\n   */\n  RESET: 'reset',\n  /* Variable: objects (from mxEvent)\r\n   * \r\n   * Contains all objects where any listener was added using <addListener>.\r\n   * This is used to reduce memory leaks in IE, see <mxClient.dispose>.\r\n   */\n  objects: [],\n  getSource: function getSource(evt) {\n    return evt.srcElement != null ? evt.srcElement : evt.target;\n  },\n  getMainEvent: function getMainEvent(e) {\n    if ((e.type == 'touchstart' || e.type == 'touchmove') && e.touches != null && e.touches[0] != null) {\n      e = e.touches[0];\n    } else if (e.type == 'touchend' && e.changedTouches != null && e.changedTouches[0] != null) {\n      e = e.changedTouches[0];\n    }\n    return e;\n  },\n  getClientX: function getClientX(e) {\n    return mxEventUtils.getMainEvent(e).clientX;\n  },\n  getClientY: function getClientY(e) {\n    return mxEventUtils.getMainEvent(e).clientY;\n  },\n  isLeftMouseButton: function isLeftMouseButton(evt) {\n    // Special case for mousemove and mousedown we check the buttons\n    // if it exists because which is 0 even if no button is pressed\n    if ('buttons' in evt && (evt.type == 'mousedown' || evt.type == 'mousemove')) {\n      return evt.buttons == 1;\n    } else if ('which' in evt) {\n      return evt.which === 1;\n    } else {\n      return evt.button === 1;\n    }\n  },\n  isMiddleMouseButton: function isMiddleMouseButton(evt) {\n    if ('which' in evt) {\n      return evt.which === 2;\n    } else {\n      return evt.button === 4;\n    }\n  },\n  isRightMouseButton: function isRightMouseButton(evt) {\n    if ('which' in evt) {\n      return evt.which === 3;\n    } else {\n      return evt.button === 2;\n    }\n  },\n  isPopupTrigger: function isPopupTrigger(evt) {\n    return mxEventUtils.isRightMouseButton(evt) || _mxClient[\"default\"].IS_MAC && mxEventUtils.isControlDown(evt) && !mxEventUtils.isShiftDown(evt) && !mxEventUtils.isMetaDown(evt) && !mxEventUtils.isAltDown(evt);\n  },\n  isShiftDown: function isShiftDown(evt) {\n    return evt != null ? evt.shiftKey : false;\n  },\n  isAltDown: function isAltDown(evt) {\n    return evt != null ? evt.altKey : false;\n  },\n  isControlDown: function isControlDown(evt) {\n    return evt != null ? evt.ctrlKey : false;\n  },\n  isMetaDown: function isMetaDown(evt) {\n    return evt != null ? evt.metaKey : false;\n  },\n  /**\r\n   * Function: consume\r\n   *\r\n   * Consumes the given event.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * evt - Native event to be consumed.\r\n   * preventDefault - Optional boolean to prevent the default for the event.\r\n   * Default is true.\r\n   * stopPropagation - Option boolean to stop event propagation. Default is\r\n   * true.\r\n   */\n  consume: function consume(evt, preventDefault, stopPropagation) {\n    preventDefault = preventDefault != null ? preventDefault : true;\n    stopPropagation = stopPropagation != null ? stopPropagation : true;\n    if (preventDefault) {\n      if (evt.preventDefault) {\n        if (stopPropagation) {\n          evt.stopPropagation();\n        }\n        evt.preventDefault();\n      } else if (stopPropagation) {\n        evt.cancelBubble = true;\n      }\n    }\n\n    // Opera\n    //evt.isConsumed = true;\n\n    // Other browsers\n    if (!evt.preventDefault) {\n      evt.returnValue = false;\n    }\n  },\n  /**\r\n    * Function: addListener\r\n    *\r\n    * <mxGraphUtils.bind> in order to bind the \"this\" keyword inside the function\r\n    * to a given execution scope.\r\n    */\n  addListener: function () {\n    var updateListenerList = function updateListenerList(element, eventName, funct) {\n      if (element.mxListenerList == null) {\n        element.mxListenerList = [];\n        mxEventUtils.objects.push(element);\n      }\n      var entry = {\n        name: eventName,\n        f: funct\n      };\n      element.mxListenerList.push(entry);\n    };\n    if (window.addEventListener) {\n      return function (element, eventName, funct) {\n        element.addEventListener(eventName, funct, false);\n        updateListenerList(element, eventName, funct);\n      };\n    } else {\n      return function (element, eventName, funct) {\n        element.attachEvent('on' + eventName, funct);\n        updateListenerList(element, eventName, funct);\n      };\n    }\n  }(),\n  /**\r\n   * Function: removeListener\r\n   *\r\n   * Removes the specified listener from the given element.\r\n   */\n  removeListener: function () {\n    var updateListener = function updateListener(element, eventName, funct) {\n      if (element.mxListenerList != null) {\n        var listenerCount = element.mxListenerList.length;\n        for (var i = 0; i < listenerCount; i++) {\n          var entry = element.mxListenerList[i];\n          if (entry.f == funct) {\n            element.mxListenerList.splice(i, 1);\n            break;\n          }\n        }\n        if (element.mxListenerList.length == 0) {\n          element.mxListenerList = null;\n          var idx = _mxGraphUtils[\"default\"].indexOf(mxEventUtils.objects, element);\n          if (idx >= 0) {\n            mxEventUtils.objects.splice(idx, 1);\n          }\n        }\n      }\n    };\n    if (window.removeEventListener) {\n      return function (element, eventName, funct) {\n        element.removeEventListener(eventName, funct, false);\n        updateListener(element, eventName, funct);\n      };\n    } else {\n      return function (element, eventName, funct) {\n        element.detachEvent('on' + eventName, funct);\n        updateListener(element, eventName, funct);\n      };\n    }\n  }(),\n  /**\r\n   * Function: addGestureListeners\r\n   *\r\n   * Adds the given listeners for touch, mouse and/or pointer events. If\r\n   * <mxClient.IS_POINTER> is true then pointer events will be registered,\r\n   * else the respective mouse events will be registered. If <mxClient.IS_POINTER>\r\n   * is false and <mxClient.IS_TOUCH> is true then the respective touch events\r\n   * will be registered as well as the mouse events.\r\n   */\n  addGestureListeners: function addGestureListeners(node, startListener, moveListener, endListener) {\n    if (startListener != null) {\n      mxEventUtils.addListener(node, _mxClient[\"default\"].IS_POINTER ? 'pointerdown' : 'mousedown', startListener);\n    }\n    if (moveListener != null) {\n      mxEventUtils.addListener(node, _mxClient[\"default\"].IS_POINTER ? 'pointermove' : 'mousemove', moveListener);\n    }\n    if (endListener != null) {\n      mxEventUtils.addListener(node, _mxClient[\"default\"].IS_POINTER ? 'pointerup' : 'mouseup', endListener);\n    }\n    if (!_mxClient[\"default\"].IS_POINTER && _mxClient[\"default\"].IS_TOUCH) {\n      if (startListener != null) {\n        mxEventUtils.addListener(node, 'touchstart', startListener);\n      }\n      if (moveListener != null) {\n        mxEventUtils.addListener(node, 'touchmove', moveListener);\n      }\n      if (endListener != null) {\n        mxEventUtils.addListener(node, 'touchend', endListener);\n      }\n    }\n  },\n  /**\r\n   * Function: removeGestureListeners\r\n   *\r\n   * Removes the given listeners from mousedown, mousemove, mouseup and the\r\n   * respective touch events if <mxClient.IS_TOUCH> is true.\r\n   */\n  removeGestureListeners: function removeGestureListeners(node, startListener, moveListener, endListener) {\n    if (startListener != null) {\n      mxEventUtils.removeListener(node, _mxClient[\"default\"].IS_POINTER ? 'pointerdown' : 'mousedown', startListener);\n    }\n    if (moveListener != null) {\n      mxEventUtils.removeListener(node, _mxClient[\"default\"].IS_POINTER ? 'pointermove' : 'mousemove', moveListener);\n    }\n    if (endListener != null) {\n      mxEventUtils.removeListener(node, _mxClient[\"default\"].IS_POINTER ? 'pointerup' : 'mouseup', endListener);\n    }\n    if (!_mxClient[\"default\"].IS_POINTER && _mxClient[\"default\"].IS_TOUCH) {\n      if (startListener != null) {\n        mxEventUtils.removeListener(node, 'touchstart', startListener);\n      }\n      if (moveListener != null) {\n        mxEventUtils.removeListener(node, 'touchmove', moveListener);\n      }\n      if (endListener != null) {\n        mxEventUtils.removeListener(node, 'touchend', endListener);\n      }\n    }\n  },\n  /**\r\n   * Function: removeAllListeners\r\n   *\r\n   * Removes all listeners from the given element.\r\n   */\n  removeAllListeners: function removeAllListeners(element) {\n    var list = element.mxListenerList;\n    if (list != null) {\n      while (list.length > 0) {\n        var entry = list[0];\n        mxEventUtils.removeListener(element, entry.name, entry.f);\n      }\n    }\n  },\n  /**\r\n   * Function: dispose (from mxClient)\r\n   *\r\n   * Frees up memory in IE by resolving cyclic dependencies between the DOM\r\n   * and the JavaScript objects.\r\n   */\n  dispose: function dispose() {\n    // Cleans all objects where listeners have been added\n    {\n      if (mxEventUtils.objects[i].mxListenerList != null) {\n        mxEventUtils.removeAllListeners(mxEventUtils.objects[i]);\n      }\n    }\n  },\n  /**\r\n   * Function: release\r\n   * \r\n   * Removes the known listeners from the given DOM node and its descendants.\r\n   * \r\n   * Parameters:\r\n   * \r\n   * element - DOM node to remove the listeners from.\r\n   */\n  release: function release(element) {\n    if (element != null) {\n      mxEventUtils.removeAllListeners(element);\n      var children = element.childNodes;\n      if (children != null) {\n        var childCount = children.length;\n        for (var i = 0; i < childCount; i += 1) {\n          mxEventUtils.release(children[i]);\n        }\n      }\n    }\n  },\n  /**\r\n   * Function: isConsumed\r\n   *\r\n   * Returns true if the event has been consumed using <consume>.\r\n   */\n  isConsumed: function isConsumed(evt) {\n    return evt.isConsumed != null && evt.isConsumed;\n  },\n  /**\r\n   * Function: redirectMouseEvents\r\n   *\r\n   * Redirects the mouse events from the given DOM node to the graph dispatch\r\n   * loop using the event and given state as event arguments. State can\r\n   * <mxCellState>. The down, move, up and dblClick arguments are optional\r\n   * functions that take the trigger event as arguments and replace the\r\n   * default behaviour.\r\n   */\n  redirectMouseEvents: function redirectMouseEvents(node, graph, state, down, move, up, dblClick, mouseEventFun) {\n    var getState = function getState(evt) {\n      return typeof state == 'function' ? state(evt) : state;\n    };\n    mxEventUtils.addGestureListeners(node, function (evt) {\n      if (down != null) {\n        down(evt);\n      } else if (!mxEventUtils.isConsumed(evt)) {\n        graph.fireMouseEvent(mxEventUtils.MOUSE_DOWN, new mouseEventFun(evt, getState(evt)));\n      }\n    }, function (evt) {\n      if (move != null) {\n        move(evt);\n      } else if (!mxEventUtils.isConsumed(evt)) {\n        graph.fireMouseEvent(mxEventUtils.MOUSE_MOVE, new mouseEventFun(evt, getState(evt)));\n      }\n    }, function (evt) {\n      if (up != null) {\n        up(evt);\n      } else if (!mxEventUtils.isConsumed(evt)) {\n        graph.fireMouseEvent(mxEventUtils.MOUSE_UP, new mouseEventFun(evt, getState(evt)));\n      }\n    });\n    mxEventUtils.addListener(node, 'dblclick', function (evt) {\n      if (dblClick != null) {\n        dblClick(evt);\n      } else if (!mxEventUtils.isConsumed(evt)) {\n        var tmp = getState(evt);\n        graph.dblClick(evt, tmp != null ? tmp.cell : null);\n      }\n    });\n  },\n  isMouseEvent: function isMouseEvent(evt) {\n    return evt.pointerType != null ? evt.pointerType == 'mouse' || evt.pointerType === evt.MSPOINTER_TYPE_MOUSE : evt.mozInputSource != null ? evt.mozInputSource == 1 : evt.type.indexOf('mouse') == 0;\n  }\n};\nvar _default = exports[\"default\"] = mxEventUtils;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxEventUtils.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxFastOrganicLayout.js":
/*!******************************************************!*\
  !*** ./src/workflow/mxClient/mxFastOrganicLayout.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _mxGraphLayout = _interopRequireDefault(__webpack_require__(/*! ./mxGraphLayout.js */ \"./src/workflow/mxClient/mxGraphLayout.js\"));\nvar _mxObjectIdentity = _interopRequireDefault(__webpack_require__(/*! ./mxObjectIdentity.js */ \"./src/workflow/mxClient/mxObjectIdentity.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxFastOrganicLayout(graph) {\n  _mxGraphLayout[\"default\"].call(this, graph);\n}\n;\n\n/**\r\n * Extends mxGraphLayout.\r\n */\nmxFastOrganicLayout.prototype = new _mxGraphLayout[\"default\"]();\nmxFastOrganicLayout.prototype.constructor = mxFastOrganicLayout;\n\n/**\r\n * Variable: useInputOrigin\r\n *\r\n * Specifies if the top left corner of the input cells should be the origin\r\n * of the layout result. Default is true.\r\n */\nmxFastOrganicLayout.prototype.useInputOrigin = true;\n\n/**\r\n * Variable: resetEdges\r\n *\r\n * Specifies if all edge points of traversed edges should be removed.\r\n * Default is true.\r\n */\nmxFastOrganicLayout.prototype.resetEdges = true;\n\n/**\r\n * Variable: disableEdgeStyle\r\n *\r\n * Specifies if the STYLE_NOEDGESTYLE flag should be set on edges that are\r\n * modified by the result. Default is true.\r\n */\nmxFastOrganicLayout.prototype.disableEdgeStyle = true;\n\n/**\r\n * Variable: forceConstant\r\n *\r\n * The force constant by which the attractive forces are divided and the\r\n * replusive forces are multiple by the square of. The value equates to the\r\n * average radius there is of free space around each node. Default is 50.\r\n */\nmxFastOrganicLayout.prototype.forceConstant = 50;\n\n/**\r\n * Variable: forceConstantSquared\r\n *\r\n * Cache of <forceConstant>^2 for performance.\r\n */\nmxFastOrganicLayout.prototype.forceConstantSquared = 0;\n\n/**\r\n * Variable: minDistanceLimit\r\n *\r\n * Minimal distance limit. Default is 2. Prevents of\r\n * dividing by zero.\r\n */\nmxFastOrganicLayout.prototype.minDistanceLimit = 2;\n\n/**\r\n * Variable: minDistanceLimit\r\n *\r\n * Minimal distance limit. Default is 2. Prevents of\r\n * dividing by zero.\r\n */\nmxFastOrganicLayout.prototype.maxDistanceLimit = 500;\n\n/**\r\n * Variable: minDistanceLimitSquared\r\n *\r\n * Cached version of <minDistanceLimit> squared.\r\n */\nmxFastOrganicLayout.prototype.minDistanceLimitSquared = 4;\n\n/**\r\n * Variable: initialTemp\r\n *\r\n * Start value of temperature. Default is 200.\r\n */\nmxFastOrganicLayout.prototype.initialTemp = 200;\n\n/**\r\n * Variable: temperature\r\n *\r\n * Temperature to limit displacement at later stages of layout.\r\n */\nmxFastOrganicLayout.prototype.temperature = 0;\n\n/**\r\n * Variable: maxIterations\r\n *\r\n * Total number of iterations to run the layout though.\r\n */\nmxFastOrganicLayout.prototype.maxIterations = 0;\n\n/**\r\n * Variable: iteration\r\n *\r\n * Current iteration count.\r\n */\nmxFastOrganicLayout.prototype.iteration = 0;\n\n/**\r\n * Variable: vertexArray\r\n *\r\n * An array of all vertices to be laid out.\r\n */\nmxFastOrganicLayout.prototype.vertexArray = [];\n\n/**\r\n * Variable: dispX\r\n *\r\n * An array of locally stored X co-ordinate displacements for the vertices.\r\n */\nmxFastOrganicLayout.prototype.dispX = [];\n\n/**\r\n * Variable: dispY\r\n *\r\n * An array of locally stored Y co-ordinate displacements for the vertices.\r\n */\nmxFastOrganicLayout.prototype.dispY = [];\n\n/**\r\n * Variable: cellLocation\r\n *\r\n * An array of locally stored co-ordinate positions for the vertices.\r\n */\nmxFastOrganicLayout.prototype.cellLocation = [];\n\n/**\r\n * Variable: radius\r\n *\r\n * The approximate radius of each cell, nodes only.\r\n */\nmxFastOrganicLayout.prototype.radius = [];\n\n/**\r\n * Variable: radiusSquared\r\n *\r\n * The approximate radius squared of each cell, nodes only.\r\n */\nmxFastOrganicLayout.prototype.radiusSquared = [];\n\n/**\r\n * Variable: isMoveable\r\n *\r\n * Array of booleans representing the movable states of the vertices.\r\n */\nmxFastOrganicLayout.prototype.isMoveable = [];\n\n/**\r\n * Variable: neighbours\r\n *\r\n * Local copy of cell neighbours.\r\n */\nmxFastOrganicLayout.prototype.neighbours = [];\n\n/**\r\n * Variable: indices\r\n *\r\n * Hashtable from cells to local indices.\r\n */\nmxFastOrganicLayout.prototype.indices = [];\n\n/**\r\n * Variable: allowedToRun\r\n *\r\n * Boolean flag that specifies if the layout is allowed to run. If this is\r\n * set to false, then the layout exits in the following iteration.\r\n */\nmxFastOrganicLayout.prototype.allowedToRun = true;\n\n/**\r\n * Function: isVertexIgnored\r\n *\r\n * Returns a boolean indicating if the given <mxCell> should be ignored as a\r\n * vertex. This returns true if the cell has no connections.\r\n *\r\n * Parameters:\r\n *\r\n * vertex - <mxCell> whose ignored state should be returned.\r\n */\nmxFastOrganicLayout.prototype.isVertexIgnored = function (vertex) {\n  return _mxGraphLayout[\"default\"].prototype.isVertexIgnored.apply(this, arguments) || this.graph.getConnections(vertex).length == 0;\n};\n\n/**\r\n * Function: execute\r\n *\r\n * Implements <mxGraphLayout.execute>. This operates on all children of the\r\n * given parent where <isVertexIgnored> returns false.\r\n */\nmxFastOrganicLayout.prototype.execute = function (parent) {\n  var model = this.graph.getModel();\n  this.vertexArray = [];\n  var cells = this.graph.getChildVertices(parent);\n  for (var i = 0; i < cells.length; i++) {\n    if (!this.isVertexIgnored(cells[i])) {\n      this.vertexArray.push(cells[i]);\n    }\n  }\n  var initialBounds = this.useInputOrigin ? this.graph.getBoundingBoxFromGeometry(this.vertexArray) : null;\n  var n = this.vertexArray.length;\n  this.indices = [];\n  this.dispX = [];\n  this.dispY = [];\n  this.cellLocation = [];\n  this.isMoveable = [];\n  this.neighbours = [];\n  this.radius = [];\n  this.radiusSquared = [];\n  if (this.forceConstant < 0.001) {\n    this.forceConstant = 0.001;\n  }\n  this.forceConstantSquared = this.forceConstant * this.forceConstant;\n\n  // Create a map of vertices first. This is required for the array of\n  // arrays called neighbours which holds, for each vertex, a list of\n  // ints which represents the neighbours cells to that vertex as\n  // the indices into vertexArray\n  for (var i = 0; i < this.vertexArray.length; i++) {\n    var vertex = this.vertexArray[i];\n    this.cellLocation[i] = [];\n\n    // Set up the mapping from array indices to cells\n    var id = _mxObjectIdentity[\"default\"].get(vertex);\n    this.indices[id] = i;\n    var bounds = this.getVertexBounds(vertex);\n\n    // Set the X,Y value of the internal version of the cell to\n    // the center point of the vertex for better positioning\n    var width = bounds.width;\n    var height = bounds.height;\n\n    // Randomize (0, 0) locations\n    var x = bounds.x;\n    var y = bounds.y;\n    this.cellLocation[i][0] = x + width / 2.0;\n    this.cellLocation[i][1] = y + height / 2.0;\n    this.radius[i] = Math.min(width, height);\n    this.radiusSquared[i] = this.radius[i] * this.radius[i];\n  }\n\n  // Moves cell location back to top-left from center locations used in\n  // algorithm, resetting the edge points is part of the transaction\n  model.beginUpdate();\n  try {\n    for (var i = 0; i < n; i++) {\n      this.dispX[i] = 0;\n      this.dispY[i] = 0;\n      this.isMoveable[i] = this.isVertexMovable(this.vertexArray[i]);\n\n      // Get lists of neighbours to all vertices, translate the cells\n      // obtained in indices into vertexArray and store as an array\n      // against the orginial cell index\n      var edges = this.graph.getConnections(this.vertexArray[i], parent);\n      var cells = this.graph.getOpposites(edges, this.vertexArray[i]);\n      this.neighbours[i] = [];\n      for (var j = 0; j < cells.length; j++) {\n        // Resets the points on the traversed edge\n        if (this.resetEdges) {\n          this.graph.resetEdge(edges[j]);\n        }\n        if (this.disableEdgeStyle) {\n          this.setEdgeStyleEnabled(edges[j], false);\n        }\n\n        // Looks the cell up in the indices dictionary\n        var id = _mxObjectIdentity[\"default\"].get(cells[j]);\n        var index = this.indices[id];\n\n        // Check the connected cell in part of the vertex list to be\n        // acted on by this layout\n        if (index != null) {\n          this.neighbours[i][j] = index;\n        }\n\n        // Else if index of the other cell doesn't correspond to\n        // any cell listed to be acted upon in this layout. Set\n        // the index to the value of this vertex (a dummy self-loop)\n        // so the attraction force of the edge is not calculated\n        else {\n          this.neighbours[i][j] = i;\n        }\n      }\n    }\n    this.temperature = this.initialTemp;\n\n    // If max number of iterations has not been set, guess it\n    if (this.maxIterations == 0) {\n      this.maxIterations = 20 * Math.sqrt(n);\n    }\n\n    // Main iteration loop\n    for (this.iteration = 0; this.iteration < this.maxIterations; this.iteration++) {\n      if (!this.allowedToRun) {\n        return;\n      }\n\n      // Calculate repulsive forces on all vertices\n      this.calcRepulsion();\n\n      // Calculate attractive forces through edges\n      this.calcAttraction();\n      this.calcPositions();\n      this.reduceTemperature();\n    }\n    var minx = null;\n    var miny = null;\n    for (var i = 0; i < this.vertexArray.length; i++) {\n      var vertex = this.vertexArray[i];\n      if (this.isVertexMovable(vertex)) {\n        var bounds = this.getVertexBounds(vertex);\n        if (bounds != null) {\n          this.cellLocation[i][0] -= bounds.width / 2.0;\n          this.cellLocation[i][1] -= bounds.height / 2.0;\n          var x = this.graph.snap(this.cellLocation[i][0]);\n          var y = this.graph.snap(this.cellLocation[i][1]);\n          this.setVertexLocation(vertex, x, y);\n          if (minx == null) {\n            minx = x;\n          } else {\n            minx = Math.min(minx, x);\n          }\n          if (miny == null) {\n            miny = y;\n          } else {\n            miny = Math.min(miny, y);\n          }\n        }\n      }\n    }\n\n    // Modifies the cloned geometries in-place. Not needed\n    // to clone the geometries again as we're in the same\n    // undoable change.\n    var dx = -(minx || 0) + 1;\n    var dy = -(miny || 0) + 1;\n    if (initialBounds != null) {\n      dx += initialBounds.x;\n      dy += initialBounds.y;\n    }\n    this.graph.moveCells(this.vertexArray, dx, dy);\n  } finally {\n    model.endUpdate();\n  }\n};\n\n/**\r\n * Function: calcPositions\r\n *\r\n * Takes the displacements calculated for each cell and applies them to the\r\n * local cache of cell positions. Limits the displacement to the current\r\n * temperature.\r\n */\nmxFastOrganicLayout.prototype.calcPositions = function () {\n  for (var index = 0; index < this.vertexArray.length; index++) {\n    if (this.isMoveable[index]) {\n      // Get the distance of displacement for this node for this\n      // iteration\n      var deltaLength = Math.sqrt(this.dispX[index] * this.dispX[index] + this.dispY[index] * this.dispY[index]);\n      if (deltaLength < 0.001) {\n        deltaLength = 0.001;\n      }\n\n      // Scale down by the current temperature if less than the\n      // displacement distance\n      var newXDisp = this.dispX[index] / deltaLength * Math.min(deltaLength, this.temperature);\n      var newYDisp = this.dispY[index] / deltaLength * Math.min(deltaLength, this.temperature);\n\n      // reset displacements\n      this.dispX[index] = 0;\n      this.dispY[index] = 0;\n\n      // Update the cached cell locations\n      this.cellLocation[index][0] += newXDisp;\n      this.cellLocation[index][1] += newYDisp;\n    }\n  }\n};\n\n/**\r\n * Function: calcAttraction\r\n *\r\n * Calculates the attractive forces between all laid out nodes linked by\r\n * edges\r\n */\nmxFastOrganicLayout.prototype.calcAttraction = function () {\n  // Check the neighbours of each vertex and calculate the attractive\n  // force of the edge connecting them\n  for (var i = 0; i < this.vertexArray.length; i++) {\n    for (var k = 0; k < this.neighbours[i].length; k++) {\n      // Get the index of the othe cell in the vertex array\n      var j = this.neighbours[i][k];\n\n      // Do not proceed self-loops\n      if (i != j && this.isMoveable[i] && this.isMoveable[j]) {\n        var xDelta = this.cellLocation[i][0] - this.cellLocation[j][0];\n        var yDelta = this.cellLocation[i][1] - this.cellLocation[j][1];\n\n        // The distance between the nodes\n        var deltaLengthSquared = xDelta * xDelta + yDelta * yDelta - this.radiusSquared[i] - this.radiusSquared[j];\n        if (deltaLengthSquared < this.minDistanceLimitSquared) {\n          deltaLengthSquared = this.minDistanceLimitSquared;\n        }\n        var deltaLength = Math.sqrt(deltaLengthSquared);\n        var force = deltaLengthSquared / this.forceConstant;\n        var displacementX = xDelta / deltaLength * force;\n        var displacementY = yDelta / deltaLength * force;\n        this.dispX[i] -= displacementX;\n        this.dispY[i] -= displacementY;\n        this.dispX[j] += displacementX;\n        this.dispY[j] += displacementY;\n      }\n    }\n  }\n};\n\n/**\r\n * Function: calcRepulsion\r\n *\r\n * Calculates the repulsive forces between all laid out nodes\r\n */\nmxFastOrganicLayout.prototype.calcRepulsion = function () {\n  var vertexCount = this.vertexArray.length;\n  for (var i = 0; i < vertexCount; i++) {\n    for (var j = i; j < vertexCount; j++) {\n      // Exits if the layout is no longer allowed to run\n      if (!this.allowedToRun) {\n        return;\n      }\n      if (j != i && this.isMoveable[i] && this.isMoveable[j]) {\n        var xDelta = this.cellLocation[i][0] - this.cellLocation[j][0];\n        var yDelta = this.cellLocation[i][1] - this.cellLocation[j][1];\n        if (xDelta == 0) {\n          xDelta = 0.01 + Math.random();\n        }\n        if (yDelta == 0) {\n          yDelta = 0.01 + Math.random();\n        }\n\n        // Distance between nodes\n        var deltaLength = Math.sqrt(xDelta * xDelta + yDelta * yDelta);\n        var deltaLengthWithRadius = deltaLength - this.radius[i] - this.radius[j];\n        if (deltaLengthWithRadius > this.maxDistanceLimit) {\n          // Ignore vertices too far apart\n          continue;\n        }\n        if (deltaLengthWithRadius < this.minDistanceLimit) {\n          deltaLengthWithRadius = this.minDistanceLimit;\n        }\n        var force = this.forceConstantSquared / deltaLengthWithRadius;\n        var displacementX = xDelta / deltaLength * force;\n        var displacementY = yDelta / deltaLength * force;\n        this.dispX[i] += displacementX;\n        this.dispY[i] += displacementY;\n        this.dispX[j] -= displacementX;\n        this.dispY[j] -= displacementY;\n      }\n    }\n  }\n};\n\n/**\r\n * Function: reduceTemperature\r\n *\r\n * Reduces the temperature of the layout from an initial setting in a linear\r\n * fashion to zero.\r\n */\nmxFastOrganicLayout.prototype.reduceTemperature = function () {\n  this.temperature = this.initialTemp * (1.0 - this.iteration / this.maxIterations);\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxCircleLayout\r\n *\r\n * Extends <mxGraphLayout> to implement a circluar layout for a given radius.\r\n * The vertices do not need to be connected for this layout to work and all\r\n * connections between vertices are not taken into account.\r\n *\r\n * Example:\r\n *\r\n * (code)\r\n * var layout = new mxCircleLayout(graph);\r\n * layout.execute(graph.getDefaultParent());\r\n * (end)\r\n *\r\n * Constructor: mxCircleLayout\r\n *\r\n * Constructs a new circular layout for the specified radius.\r\n *\r\n * Arguments:\r\n *\r\n * graph - <mxGraph> that contains the cells.\r\n * radius - Optional radius as an int. Default is 100.\r\n */\nvar _default = exports[\"default\"] = mxFastOrganicLayout;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxFastOrganicLayout.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxForm.js":
/*!*****************************************!*\
  !*** ./src/workflow/mxClient/mxForm.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _mxClient = _interopRequireDefault(__webpack_require__(/*! ./mxClient.js */ \"./src/workflow/mxClient/mxClient.js\"));\nvar _mxEvent = _interopRequireDefault(__webpack_require__(/*! ./mxEvent.js */ \"./src/workflow/mxClient/mxEvent.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxResources = _interopRequireDefault(__webpack_require__(/*! ./mxResources.js */ \"./src/workflow/mxClient/mxResources.js\"));\nvar _mxUtils = _interopRequireDefault(__webpack_require__(/*! ./mxUtils.js */ \"./src/workflow/mxClient/mxUtils.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxForm(className) {\n  this.table = document.createElement('table');\n  this.table.className = className;\n  this.body = document.createElement('tbody');\n  this.table.appendChild(this.body);\n}\n;\n\n/**\r\n * Variable: table\r\n *\r\n * Holds the DOM node that represents the table.\r\n */\nmxForm.prototype.table = null;\n\n/**\r\n * Variable: body\r\n *\r\n * Holds the DOM node that represents the tbody (table body). New rows\r\n * can be added to this object using DOM API.\r\n */\nmxForm.prototype.body = false;\n\n/**\r\n * Function: getTable\r\n *\r\n * Returns the table that contains this form.\r\n */\nmxForm.prototype.getTable = function () {\n  return this.table;\n};\n\n/**\r\n * Function: addButtons\r\n *\r\n * Helper method to add an OK and Cancel button using the respective\r\n * functions.\r\n */\nmxForm.prototype.addButtons = function (okFunct, cancelFunct) {\n  var tr = document.createElement('tr');\n  var td = document.createElement('td');\n  tr.appendChild(td);\n  td = document.createElement('td');\n\n  // Adds the ok button\n  var button = document.createElement('button');\n  _mxGraphUtils[\"default\"].write(button, _mxResources[\"default\"].get('ok') || 'OK');\n  td.appendChild(button);\n  _mxEvent[\"default\"].addListener(button, 'click', function () {\n    okFunct();\n  });\n\n  // Adds the cancel button\n  button = document.createElement('button');\n  _mxGraphUtils[\"default\"].write(button, _mxResources[\"default\"].get('cancel') || 'Cancel');\n  td.appendChild(button);\n  _mxEvent[\"default\"].addListener(button, 'click', function () {\n    cancelFunct();\n  });\n  tr.appendChild(td);\n  this.body.appendChild(tr);\n};\n\n/**\r\n * Function: addText\r\n *\r\n * Adds a textfield for the given name and value and returns the textfield.\r\n */\nmxForm.prototype.addText = function (name, value) {\n  var input = document.createElement('input');\n  input.setAttribute('type', 'text');\n  input.value = value;\n  return this.addField(name, input);\n};\n\n/**\r\n * Function: addCheckbox\r\n *\r\n * Adds a checkbox for the given name and value and returns the textfield.\r\n */\nmxForm.prototype.addCheckbox = function (name, value) {\n  var input = document.createElement('input');\n  input.setAttribute('type', 'checkbox');\n  this.addField(name, input);\n\n  // IE can only change the checked value if the input is inside the DOM\n  if (value) {\n    input.checked = true;\n  }\n  return input;\n};\n\n/**\r\n * Function: addTextarea\r\n *\r\n * Adds a textarea for the given name and value and returns the textarea.\r\n */\nmxForm.prototype.addTextarea = function (name, value, rows) {\n  var input = document.createElement('textarea');\n  if (_mxClient[\"default\"].IS_NS) {\n    rows--;\n  }\n  input.setAttribute('rows', rows || 2);\n  input.value = value;\n  return this.addField(name, input);\n};\n\n/**\r\n * Function: addCombo\r\n *\r\n * Adds a combo for the given name and returns the combo.\r\n */\nmxForm.prototype.addCombo = function (name, isMultiSelect, size) {\n  var select = document.createElement('select');\n  if (size != null) {\n    select.setAttribute('size', size);\n  }\n  if (isMultiSelect) {\n    select.setAttribute('multiple', 'true');\n  }\n  return this.addField(name, select);\n};\n\n/**\r\n * Function: addOption\r\n *\r\n * Adds an option for the given label to the specified combo.\r\n */\nmxForm.prototype.addOption = function (combo, label, value, isSelected) {\n  var option = document.createElement('option');\n  _mxUtils[\"default\"].writeln(option, label);\n  option.setAttribute('value', value);\n  if (isSelected) {\n    option.setAttribute('selected', isSelected);\n  }\n  combo.appendChild(option);\n};\n\n/**\r\n * Function: addField\r\n *\r\n * Adds a new row with the name and the input field in two columns and\r\n * returns the given input.\r\n */\nmxForm.prototype.addField = function (name, input) {\n  var tr = document.createElement('tr');\n  var td = document.createElement('td');\n  _mxGraphUtils[\"default\"].write(td, name);\n  tr.appendChild(td);\n  td = document.createElement('td');\n  td.appendChild(input);\n  tr.appendChild(td);\n  this.body.appendChild(tr);\n  return input;\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxImage\r\n *\r\n * Encapsulates the URL, width and height of an image.\r\n *\r\n * Constructor: mxImage\r\n *\r\n * Constructs a new image.\r\n */\nvar _default = exports[\"default\"] = mxForm;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxForm.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxGeometry.js":
/*!*********************************************!*\
  !*** ./src/workflow/mxClient/mxGeometry.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.parse-float.js */ \"../../node_modules/core-js/modules/es.parse-float.js\");\nvar _mxPoint = _interopRequireDefault(__webpack_require__(/*! ./mxPoint.js */ \"./src/workflow/mxClient/mxPoint.js\"));\nvar _mxRectangle = _interopRequireDefault(__webpack_require__(/*! ./mxRectangle.js */ \"./src/workflow/mxClient/mxRectangle.js\"));\nvar _mxUtils = _interopRequireDefault(__webpack_require__(/*! ./mxUtils.js */ \"./src/workflow/mxClient/mxUtils.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxGeometry(x, y, width, height) {\n  _mxRectangle[\"default\"].call(this, x, y, width, height);\n}\n;\n\n/**\r\n * Extends mxRectangle.\r\n */\nmxGeometry.prototype = new _mxRectangle[\"default\"]();\nmxGeometry.prototype.constructor = mxGeometry;\n\n/**\r\n * Variable: TRANSLATE_CONTROL_POINTS\r\n *\r\n * Global switch to translate the points in translate. Default is true.\r\n */\nmxGeometry.prototype.TRANSLATE_CONTROL_POINTS = true;\n\n/**\r\n * Variable: alternateBounds\r\n *\r\n * Stores alternate values for x, y, width and height in a rectangle. See\r\n * <swap> to exchange the values. Default is null.\r\n */\nmxGeometry.prototype.alternateBounds = null;\n\n/**\r\n * Variable: sourcePoint\r\n *\r\n * Defines the source <mxPoint> of the edge. This is used if the\r\n * corresponding edge does not have a source vertex. Otherwise it is\r\n * ignored. Default is  null.\r\n */\nmxGeometry.prototype.sourcePoint = null;\n\n/**\r\n * Variable: targetPoint\r\n *\r\n * Defines the target <mxPoint> of the edge. This is used if the\r\n * corresponding edge does not have a target vertex. Otherwise it is\r\n * ignored. Default is null.\r\n */\nmxGeometry.prototype.targetPoint = null;\n\n/**\r\n * Variable: points\r\n *\r\n * Array of <mxPoints> which specifies the control points along the edge.\r\n * These points are the intermediate points on the edge, for the endpoints\r\n * use <targetPoint> and <sourcePoint> or set the terminals of the edge to\r\n * a non-null value. Default is null.\r\n */\nmxGeometry.prototype.points = null;\n\n/**\r\n * Variable: offset\r\n *\r\n * For edges, this holds the offset (in pixels) from the position defined\r\n * by <x> and <y> on the edge. For relative geometries (for vertices), this\r\n * defines the absolute offset from the point defined by the relative\r\n * coordinates. For absolute geometries (for vertices), this defines the\r\n * offset for the label. Default is null.\r\n */\nmxGeometry.prototype.offset = null;\n\n/**\r\n * Variable: relative\r\n *\r\n * Specifies if the coordinates in the geometry are to be interpreted as\r\n * relative coordinates. For edges, this is used to define the location of\r\n * the edge label relative to the edge as rendered on the display. For\r\n * vertices, this specifies the relative location inside the bounds of the\r\n * parent cell.\r\n *\r\n * If this is false, then the coordinates are relative to the origin of the\r\n * parent cell or, for edges, the edge label position is relative to the\r\n * center of the edge as rendered on screen.\r\n *\r\n * Default is false.\r\n */\nmxGeometry.prototype.relative = false;\n\n/**\r\n * Function: swap\r\n *\r\n * Swaps the x, y, width and height with the values stored in\r\n * <alternateBounds> and puts the previous values into <alternateBounds> as\r\n * a rectangle. This operation is carried-out in-place, that is, using the\r\n * existing geometry instance. If this operation is called during a graph\r\n * model transactional change, then the geometry should be cloned before\r\n * calling this method and setting the geometry of the cell using\r\n * <mxGraphModel.setGeometry>.\r\n */\nmxGeometry.prototype.swap = function () {\n  if (this.alternateBounds != null) {\n    var old = new _mxRectangle[\"default\"](this.x, this.y, this.width, this.height);\n    this.x = this.alternateBounds.x;\n    this.y = this.alternateBounds.y;\n    this.width = this.alternateBounds.width;\n    this.height = this.alternateBounds.height;\n    this.alternateBounds = old;\n  }\n};\n\n/**\r\n * Function: getTerminalPoint\r\n *\r\n * Returns the <mxPoint> representing the source or target point of this\r\n * edge. This is only used if the edge has no source or target vertex.\r\n *\r\n * Parameters:\r\n *\r\n * isSource - Boolean that specifies if the source or target point\r\n * should be returned.\r\n */\nmxGeometry.prototype.getTerminalPoint = function (isSource) {\n  return isSource ? this.sourcePoint : this.targetPoint;\n};\n\n/**\r\n * Function: setTerminalPoint\r\n *\r\n * Sets the <sourcePoint> or <targetPoint> to the given <mxPoint> and\r\n * returns the new point.\r\n *\r\n * Parameters:\r\n *\r\n * point - Point to be used as the new source or target point.\r\n * isSource - Boolean that specifies if the source or target point\r\n * should be set.\r\n */\nmxGeometry.prototype.setTerminalPoint = function (point, isSource) {\n  if (isSource) {\n    this.sourcePoint = point;\n  } else {\n    this.targetPoint = point;\n  }\n  return point;\n};\n\n/**\r\n * Function: rotate\r\n *\r\n * Rotates the geometry by the given angle around the given center. That is,\r\n * <x> and <y> of the geometry, the <sourcePoint>, <targetPoint> and all\r\n * <points> are translated by the given amount. <x> and <y> are only\r\n * translated if <relative> is false.\r\n *\r\n * Parameters:\r\n *\r\n * angle - Number that specifies the rotation angle in degrees.\r\n * cx - <mxPoint> that specifies the center of the rotation.\r\n */\nmxGeometry.prototype.rotate = function (angle, cx) {\n  var rad = _mxUtils[\"default\"].toRadians(angle);\n  var cos = Math.cos(rad);\n  var sin = Math.sin(rad);\n\n  // Rotates the geometry\n  if (!this.relative) {\n    var ct = new _mxPoint[\"default\"](this.getCenterX(), this.getCenterY());\n    var pt = _mxUtils[\"default\"].getRotatedPoint(ct, cos, sin, cx);\n    this.x = Math.round(pt.x - this.width / 2);\n    this.y = Math.round(pt.y - this.height / 2);\n  }\n\n  // Rotates the source point\n  if (this.sourcePoint != null) {\n    var pt = _mxUtils[\"default\"].getRotatedPoint(this.sourcePoint, cos, sin, cx);\n    this.sourcePoint.x = Math.round(pt.x);\n    this.sourcePoint.y = Math.round(pt.y);\n  }\n\n  // Translates the target point\n  if (this.targetPoint != null) {\n    var pt = _mxUtils[\"default\"].getRotatedPoint(this.targetPoint, cos, sin, cx);\n    this.targetPoint.x = Math.round(pt.x);\n    this.targetPoint.y = Math.round(pt.y);\n  }\n\n  // Translate the control points\n  if (this.points != null) {\n    for (var i = 0; i < this.points.length; i++) {\n      if (this.points[i] != null) {\n        var pt = _mxUtils[\"default\"].getRotatedPoint(this.points[i], cos, sin, cx);\n        this.points[i].x = Math.round(pt.x);\n        this.points[i].y = Math.round(pt.y);\n      }\n    }\n  }\n};\n\n/**\r\n * Function: translate\r\n *\r\n * Translates the geometry by the specified amount. That is, <x> and <y> of the\r\n * geometry, the <sourcePoint>, <targetPoint> and all <points> are translated\r\n * by the given amount. <x> and <y> are only translated if <relative> is false.\r\n * If <TRANSLATE_CONTROL_POINTS> is false, then <points> are not modified by\r\n * this function.\r\n *\r\n * Parameters:\r\n *\r\n * dx - Number that specifies the x-coordinate of the translation.\r\n * dy - Number that specifies the y-coordinate of the translation.\r\n */\nmxGeometry.prototype.translate = function (dx, dy) {\n  dx = parseFloat(dx);\n  dy = parseFloat(dy);\n\n  // Translates the geometry\n  if (!this.relative) {\n    this.x = parseFloat(this.x) + dx;\n    this.y = parseFloat(this.y) + dy;\n  }\n\n  // Translates the source point\n  if (this.sourcePoint != null) {\n    this.sourcePoint.x = parseFloat(this.sourcePoint.x) + dx;\n    this.sourcePoint.y = parseFloat(this.sourcePoint.y) + dy;\n  }\n\n  // Translates the target point\n  if (this.targetPoint != null) {\n    this.targetPoint.x = parseFloat(this.targetPoint.x) + dx;\n    this.targetPoint.y = parseFloat(this.targetPoint.y) + dy;\n  }\n\n  // Translate the control points\n  if (this.TRANSLATE_CONTROL_POINTS && this.points != null) {\n    for (var i = 0; i < this.points.length; i++) {\n      if (this.points[i] != null) {\n        this.points[i].x = parseFloat(this.points[i].x) + dx;\n        this.points[i].y = parseFloat(this.points[i].y) + dy;\n      }\n    }\n  }\n};\n\n/**\r\n * Function: scale\r\n *\r\n * Scales the geometry by the given amount. That is, <x> and <y> of the\r\n * geometry, the <sourcePoint>, <targetPoint> and all <points> are scaled\r\n * by the given amount. <x>, <y>, <width> and <height> are only scaled if\r\n * <relative> is false. If <fixedAspect> is true, then the smaller value\r\n * is used to scale the width and the height.\r\n *\r\n * Parameters:\r\n *\r\n * sx - Number that specifies the horizontal scale factor.\r\n * sy - Number that specifies the vertical scale factor.\r\n * fixedAspect - Optional boolean to keep the aspect ratio fixed.\r\n */\nmxGeometry.prototype.scale = function (sx, sy, fixedAspect) {\n  sx = parseFloat(sx);\n  sy = parseFloat(sy);\n\n  // Translates the source point\n  if (this.sourcePoint != null) {\n    this.sourcePoint.x = parseFloat(this.sourcePoint.x) * sx;\n    this.sourcePoint.y = parseFloat(this.sourcePoint.y) * sy;\n  }\n\n  // Translates the target point\n  if (this.targetPoint != null) {\n    this.targetPoint.x = parseFloat(this.targetPoint.x) * sx;\n    this.targetPoint.y = parseFloat(this.targetPoint.y) * sy;\n  }\n\n  // Translate the control points\n  if (this.points != null) {\n    for (var i = 0; i < this.points.length; i++) {\n      if (this.points[i] != null) {\n        this.points[i].x = parseFloat(this.points[i].x) * sx;\n        this.points[i].y = parseFloat(this.points[i].y) * sy;\n      }\n    }\n  }\n\n  // Translates the geometry\n  if (!this.relative) {\n    this.x = parseFloat(this.x) * sx;\n    this.y = parseFloat(this.y) * sy;\n    if (fixedAspect) {\n      sy = sx = Math.min(sx, sy);\n    }\n    this.width = parseFloat(this.width) * sx;\n    this.height = parseFloat(this.height) * sy;\n  }\n};\n\n/**\r\n * Function: equals\r\n *\r\n * Returns true if the given object equals this geometry.\r\n */\nmxGeometry.prototype.equals = function (obj) {\n  return _mxRectangle[\"default\"].prototype.equals.apply(this, arguments) && this.relative == obj.relative && (this.sourcePoint == null && obj.sourcePoint == null || this.sourcePoint != null && this.sourcePoint.equals(obj.sourcePoint)) && (this.targetPoint == null && obj.targetPoint == null || this.targetPoint != null && this.targetPoint.equals(obj.targetPoint)) && (this.points == null && obj.points == null || this.points != null && _mxUtils[\"default\"].equalPoints(this.points, obj.points)) && (this.alternateBounds == null && obj.alternateBounds == null || this.alternateBounds != null && this.alternateBounds.equals(obj.alternateBounds)) && (this.offset == null && obj.offset == null || this.offset != null && this.offset.equals(obj.offset));\n};\nmxGeometry.getName = function () {\n  return 'mxGeometry';\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\nvar _default = exports[\"default\"] = mxGeometry;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxGeometry.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxGeometryChange.js":
/*!***************************************************!*\
  !*** ./src/workflow/mxClient/mxGeometryChange.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nfunction mxGeometryChange(model, cell, geometry) {\n  this.model = model;\n  this.cell = cell;\n  this.geometry = geometry;\n  this.previous = geometry;\n}\n;\n\n/**\r\n * Function: execute\r\n *\r\n * Changes the geometry of <cell> ro <previous> using\r\n * <mxGraphModel.geometryForCellChanged>.\r\n */\nmxGeometryChange.prototype.execute = function () {\n  this.geometry = this.previous;\n  this.previous = this.model.geometryForCellChanged(this.cell, this.previous);\n};\nmxGeometryChange.getName = function () {\n  return 'mxGeometryChange';\n};\n/**\r\n * Class: mxCollapseChange\r\n *\r\n * Action to change a cell's collapsed state in a model.\r\n *\r\n * Constructor: mxCollapseChange\r\n *\r\n * Constructs a change of a collapsed state in the\r\n * specified model.\r\n */\nvar _default = exports[\"default\"] = mxGeometryChange;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxGeometryChange.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxGraph.js":
/*!******************************************!*\
  !*** ./src/workflow/mxClient/mxGraph.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.concat.js */ \"../../node_modules/core-js/modules/es.array.concat.js\");\n__webpack_require__(/*! core-js/modules/es.array.fill.js */ \"../../node_modules/core-js/modules/es.array.fill.js\");\n__webpack_require__(/*! core-js/modules/es.array.index-of.js */ \"../../node_modules/core-js/modules/es.array.index-of.js\");\n__webpack_require__(/*! core-js/modules/es.array.slice.js */ \"../../node_modules/core-js/modules/es.array.slice.js\");\n__webpack_require__(/*! core-js/modules/es.array.splice.js */ \"../../node_modules/core-js/modules/es.array.splice.js\");\n__webpack_require__(/*! core-js/modules/es.date.to-string.js */ \"../../node_modules/core-js/modules/es.date.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.function.bind.js */ \"../../node_modules/core-js/modules/es.function.bind.js\");\n__webpack_require__(/*! core-js/modules/es.object.to-string.js */ \"../../node_modules/core-js/modules/es.object.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.parse-float.js */ \"../../node_modules/core-js/modules/es.parse-float.js\");\n__webpack_require__(/*! core-js/modules/es.parse-int.js */ \"../../node_modules/core-js/modules/es.parse-int.js\");\n__webpack_require__(/*! core-js/modules/es.regexp.exec.js */ \"../../node_modules/core-js/modules/es.regexp.exec.js\");\n__webpack_require__(/*! core-js/modules/es.regexp.to-string.js */ \"../../node_modules/core-js/modules/es.regexp.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.string.replace.js */ \"../../node_modules/core-js/modules/es.string.replace.js\");\n__webpack_require__(/*! core-js/modules/web.timers.js */ \"../../node_modules/core-js/modules/web.timers.js\");\nvar _mxCell = _interopRequireDefault(__webpack_require__(/*! ./mxCell.js */ \"./src/workflow/mxClient/mxCell.js\"));\nvar _mxSelectionCellsHandler = _interopRequireDefault(__webpack_require__(/*! ./mxSelectionCellsHandler.js */ \"./src/workflow/mxClient/mxSelectionCellsHandler.js\"));\nvar _mxPolyline = _interopRequireDefault(__webpack_require__(/*! ./mxPolyline.js */ \"./src/workflow/mxClient/mxPolyline.js\"));\nvar _mxPanningHandler = _interopRequireDefault(__webpack_require__(/*! ./mxPanningHandler.js */ \"./src/workflow/mxClient/mxPanningHandler.js\"));\nvar _mxElbowEdgeHandler = _interopRequireDefault(__webpack_require__(/*! ./mxElbowEdgeHandler.js */ \"./src/workflow/mxClient/mxElbowEdgeHandler.js\"));\nvar _mxConnectionHandler = _interopRequireDefault(__webpack_require__(/*! ./mxConnectionHandler.js */ \"./src/workflow/mxClient/mxConnectionHandler.js\"));\nvar _mxEdgeHandler = _interopRequireDefault(__webpack_require__(/*! ./mxEdgeHandler.js */ \"./src/workflow/mxClient/mxEdgeHandler.js\"));\nvar _mxGraphModel = _interopRequireDefault(__webpack_require__(/*! ./mxGraphModel.js */ \"./src/workflow/mxClient/mxGraphModel.js\"));\nvar _mxTooltipHandler = _interopRequireDefault(__webpack_require__(/*! ./mxTooltipHandler.js */ \"./src/workflow/mxClient/mxTooltipHandler.js\"));\nvar _mxClient = _interopRequireDefault(__webpack_require__(/*! ./mxClient.js */ \"./src/workflow/mxClient/mxClient.js\"));\nvar _mxCellOverlay = _interopRequireDefault(__webpack_require__(/*! ./mxCellOverlay.js */ \"./src/workflow/mxClient/mxCellOverlay.js\"));\nvar _mxPanningManager = _interopRequireDefault(__webpack_require__(/*! ./mxPanningManager.js */ \"./src/workflow/mxClient/mxPanningManager.js\"));\nvar _mxLabel = _interopRequireDefault(__webpack_require__(/*! ./mxLabel.js */ \"./src/workflow/mxClient/mxLabel.js\"));\nvar _mxStylesheet = _interopRequireDefault(__webpack_require__(/*! ./mxStylesheet.js */ \"./src/workflow/mxClient/mxStylesheet.js\"));\nvar _mxEventUtils = _interopRequireDefault(__webpack_require__(/*! ./mxEventUtils.js */ \"./src/workflow/mxClient/mxEventUtils.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxEventSource = _interopRequireDefault(__webpack_require__(/*! ./mxEventSource.js */ \"./src/workflow/mxClient/mxEventSource.js\"));\nvar _mxEdgeSegmentHandler = _interopRequireDefault(__webpack_require__(/*! ./mxEdgeSegmentHandler.js */ \"./src/workflow/mxClient/mxEdgeSegmentHandler.js\"));\nvar _mxConnectionConstraint = _interopRequireDefault(__webpack_require__(/*! ./mxConnectionConstraint.js */ \"./src/workflow/mxClient/mxConnectionConstraint.js\"));\nvar _mxEventObject = _interopRequireDefault(__webpack_require__(/*! ./mxEventObject.js */ \"./src/workflow/mxClient/mxEventObject.js\"));\nvar _mxEvent = _interopRequireDefault(__webpack_require__(/*! ./mxEvent.js */ \"./src/workflow/mxClient/mxEvent.js\"));\nvar _mxImage = _interopRequireDefault(__webpack_require__(/*! ./mxImage.js */ \"./src/workflow/mxClient/mxImage.js\"));\nvar _mxMouseEvent = _interopRequireDefault(__webpack_require__(/*! ./mxMouseEvent.js */ \"./src/workflow/mxClient/mxMouseEvent.js\"));\nvar _mxDictionary = _interopRequireDefault(__webpack_require__(/*! ./mxDictionary.js */ \"./src/workflow/mxClient/mxDictionary.js\"));\nvar _mxCellRenderer = _interopRequireDefault(__webpack_require__(/*! ./mxCellRenderer.js */ \"./src/workflow/mxClient/mxCellRenderer.js\"));\nvar _mxRectangle = _interopRequireDefault(__webpack_require__(/*! ./mxRectangle.js */ \"./src/workflow/mxClient/mxRectangle.js\"));\nvar _mxGraphSelectionModel = _interopRequireDefault(__webpack_require__(/*! ./mxGraphSelectionModel.js */ \"./src/workflow/mxClient/mxGraphSelectionModel.js\"));\nvar _mxRectangleShape = _interopRequireDefault(__webpack_require__(/*! ./mxRectangleShape.js */ \"./src/workflow/mxClient/mxRectangleShape.js\"));\nvar _mxGeometry = _interopRequireDefault(__webpack_require__(/*! ./mxGeometry.js */ \"./src/workflow/mxClient/mxGeometry.js\"));\nvar _mxPoint = _interopRequireDefault(__webpack_require__(/*! ./mxPoint.js */ \"./src/workflow/mxClient/mxPoint.js\"));\nvar _mxPopupMenuHandler = _interopRequireDefault(__webpack_require__(/*! ./mxPopupMenuHandler.js */ \"./src/workflow/mxClient/mxPopupMenuHandler.js\"));\nvar _mxVertexHandler = _interopRequireDefault(__webpack_require__(/*! ./mxVertexHandler.js */ \"./src/workflow/mxClient/mxVertexHandler.js\"));\nvar _mxGraphHandler = _interopRequireDefault(__webpack_require__(/*! ./mxGraphHandler.js */ \"./src/workflow/mxClient/mxGraphHandler.js\"));\nvar _mxResources = _interopRequireDefault(__webpack_require__(/*! ./mxResources.js */ \"./src/workflow/mxClient/mxResources.js\"));\nvar _mxCellEditor = _interopRequireDefault(__webpack_require__(/*! ./mxCellEditor.js */ \"./src/workflow/mxClient/mxCellEditor.js\"));\nvar _mxGraphView = _interopRequireDefault(__webpack_require__(/*! ./mxGraphView.js */ \"./src/workflow/mxClient/mxGraphView.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ./mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nvar _mxUtils = _interopRequireDefault(__webpack_require__(/*! ./mxUtils.js */ \"./src/workflow/mxClient/mxUtils.js\"));\nvar _mxEdgeStyle = _interopRequireDefault(__webpack_require__(/*! ./mxEdgeStyle.js */ \"./src/workflow/mxClient/mxEdgeStyle.js\"));\nvar _mxGeometryChange = _interopRequireDefault(__webpack_require__(/*! ./mxGeometryChange.js */ \"./src/workflow/mxClient/mxGeometryChange.js\"));\nvar _mxVisibleChange = _interopRequireDefault(__webpack_require__(/*! ./mxVisibleChange.js */ \"./src/workflow/mxClient/mxVisibleChange.js\"));\nvar _mxStyleChange = _interopRequireDefault(__webpack_require__(/*! ./mxStyleChange.js */ \"./src/workflow/mxClient/mxStyleChange.js\"));\nvar _mxChildChange = _interopRequireDefault(__webpack_require__(/*! ./mxChildChange.js */ \"./src/workflow/mxClient/mxChildChange.js\"));\nvar _mxValueChange = _interopRequireDefault(__webpack_require__(/*! ./mxValueChange.js */ \"./src/workflow/mxClient/mxValueChange.js\"));\nvar _mxRootChange = _interopRequireDefault(__webpack_require__(/*! ./mxRootChange.js */ \"./src/workflow/mxClient/mxRootChange.js\"));\nvar _mxTerminalChange = _interopRequireDefault(__webpack_require__(/*! ./mxTerminalChange.js */ \"./src/workflow/mxClient/mxTerminalChange.js\"));\nvar _mxGraphConstants = _interopRequireDefault(__webpack_require__(/*! ./mxGraphConstants */ \"./src/workflow/mxClient/mxGraphConstants.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxGraph(container, model, renderHint, stylesheet) {\n  // Initializes the variable in case the prototype has been\n  // modified to hold some listeners (which is possible because\n  // the createHandlers call is executed regardless of the\n  // arguments passed into the ctor).\n  this.mouseListeners = null;\n\n  // Converts the renderHint into a dialect\n  this.renderHint = renderHint;\n  if (_mxClient[\"default\"].IS_SVG) {\n    this.dialect = _mxConstants[\"default\"].DIALECT_SVG;\n  } else if (renderHint == _mxConstants[\"default\"].RENDERING_HINT_EXACT && _mxClient[\"default\"].IS_VML) {\n    this.dialect = _mxConstants[\"default\"].DIALECT_VML;\n  } else if (renderHint == _mxConstants[\"default\"].RENDERING_HINT_FASTEST) {\n    this.dialect = _mxConstants[\"default\"].DIALECT_STRICTHTML;\n  } else if (renderHint == _mxConstants[\"default\"].RENDERING_HINT_FASTER) {\n    this.dialect = _mxConstants[\"default\"].DIALECT_PREFERHTML;\n  } else\n    // default for VML\n    {\n      this.dialect = _mxConstants[\"default\"].DIALECT_MIXEDHTML;\n    }\n\n  // Initializes the main members that do not require a container\n  this.model = model != null ? model : new _mxGraphModel[\"default\"]();\n  this.multiplicities = [];\n  this.imageBundles = [];\n  this.cellRenderer = this.createCellRenderer();\n  this.setSelectionModel(this.createSelectionModel());\n  this.setStylesheet(stylesheet != null ? stylesheet : this.createStylesheet());\n  this.view = this.createGraphView();\n\n  // Adds a graph model listener to update the view\n  this.graphModelChangeListener = _mxGraphUtils[\"default\"].bind(this, function (sender, evt) {\n    this.graphModelChanged(evt.getProperty('edit').changes);\n  });\n  this.model.addListener(_mxEvent[\"default\"].CHANGE, this.graphModelChangeListener);\n\n  // Installs basic event handlers with disabled default settings.\n  this.createHandlers();\n\n  // Initializes the display if a container was specified\n  if (container != null) {\n    this.init(container);\n  }\n  this.view.revalidate();\n}\n;\n\n/**\r\n * Installs the required language resources at class\r\n * loading time.\r\n */\n/*if (mxLoadResources)\r\n{\r\n\tmxResources.add(mxClient.basePath+'/resources/graph');\r\n}*/\n\n/**\r\n * Extends mxEventSource.\r\n */\nmxGraph.prototype = new _mxEventSource[\"default\"]();\nmxGraph.prototype.constructor = mxGraph;\n\n/**\r\n * Variable: EMPTY_ARRAY\r\n *\r\n * Immutable empty array instance.\r\n */\nmxGraph.prototype.EMPTY_ARRAY = [];\n\n/**\r\n * Group: Variables\r\n */\n\n/**\r\n * Variable: mouseListeners\r\n *\r\n * Holds the mouse event listeners. See <fireMouseEvent>.\r\n */\nmxGraph.prototype.mouseListeners = null;\n\n/**\r\n * Variable: isMouseDown\r\n *\r\n * Holds the state of the mouse button.\r\n */\nmxGraph.prototype.isMouseDown = false;\n\n/**\r\n * Variable: model\r\n *\r\n * Holds the <mxGraphModel> that contains the cells to be displayed.\r\n */\nmxGraph.prototype.model = null;\n\n/**\r\n * Variable: view\r\n *\r\n * Holds the <mxGraphView> that caches the <mxCellStates> for the cells.\r\n */\nmxGraph.prototype.view = null;\n\n/**\r\n * Variable: stylesheet\r\n *\r\n * Holds the <mxStylesheet> that defines the appearance of the cells.\r\n *\r\n *\r\n * Example:\r\n *\r\n * Use the following code to read a stylesheet into an existing graph.\r\n *\r\n * (code)\r\n * var req = mxUtils.load('stylesheet.xml');\r\n * var root = req.getDocumentElement();\r\n * var dec = new mxCodec(root.ownerDocument);\r\n * dec.decode(root, graph.stylesheet);\r\n * (end)\r\n */\nmxGraph.prototype.stylesheet = null;\n\n/**\r\n * Variable: selectionModel\r\n *\r\n * Holds the <mxGraphSelectionModel> that models the current selection.\r\n */\nmxGraph.prototype.selectionModel = null;\n\n/**\r\n * Variable: cellEditor\r\n *\r\n * Holds the <mxCellEditor> that is used as the in-place editing.\r\n */\nmxGraph.prototype.cellEditor = null;\n\n/**\r\n * Variable: cellRenderer\r\n *\r\n * Holds the <mxCellRenderer> for rendering the cells in the graph.\r\n */\nmxGraph.prototype.cellRenderer = null;\n\n/**\r\n * Variable: multiplicities\r\n *\r\n * An array of <mxMultiplicities> describing the allowed\r\n * connections in a graph.\r\n */\nmxGraph.prototype.multiplicities = null;\n\n/**\r\n * Variable: renderHint\r\n *\r\n * RenderHint as it was passed to the constructor.\r\n */\nmxGraph.prototype.renderHint = null;\n\n/**\r\n * Variable: dialect\r\n *\r\n * Dialect to be used for drawing the graph. Possible values are all\r\n * constants in <mxConstants> with a DIALECT-prefix.\r\n */\nmxGraph.prototype.dialect = null;\n\n/**\r\n * Variable: gridSize\r\n *\r\n * Specifies the grid size. Default is 10.\r\n */\nmxGraph.prototype.gridSize = 10;\n\n/**\r\n * Variable: gridEnabled\r\n *\r\n * Specifies if the grid is enabled. This is used in <snap>. Default is\r\n * true.\r\n */\nmxGraph.prototype.gridEnabled = true;\n\n/**\r\n * Variable: portsEnabled\r\n *\r\n * Specifies if ports are enabled. This is used in <cellConnected> to update\r\n * the respective style. Default is true.\r\n */\nmxGraph.prototype.portsEnabled = true;\n\n/**\r\n * Variable: nativeDoubleClickEnabled\r\n *\r\n * Specifies if native double click events should be detected. Default is true.\r\n */\nmxGraph.prototype.nativeDblClickEnabled = true;\n\n/**\r\n * Variable: doubleTapEnabled\r\n *\r\n * Specifies if double taps on touch-based devices should be handled as a\r\n * double click. Default is true.\r\n */\nmxGraph.prototype.doubleTapEnabled = true;\n\n/**\r\n * Variable: doubleTapTimeout\r\n *\r\n * Specifies the timeout for double taps and non-native double clicks. Default\r\n * is 500 ms.\r\n */\nmxGraph.prototype.doubleTapTimeout = 500;\n\n/**\r\n * Variable: doubleTapTolerance\r\n *\r\n * Specifies the tolerance for double taps and double clicks in quirks mode.\r\n * Default is 25 pixels.\r\n */\nmxGraph.prototype.doubleTapTolerance = 25;\n\n/**\r\n * Variable: lastTouchX\r\n *\r\n * Holds the x-coordinate of the last touch event for double tap detection.\r\n */\nmxGraph.prototype.lastTouchY = 0;\n\n/**\r\n * Variable: lastTouchX\r\n *\r\n * Holds the y-coordinate of the last touch event for double tap detection.\r\n */\nmxGraph.prototype.lastTouchY = 0;\n\n/**\r\n * Variable: lastTouchTime\r\n *\r\n * Holds the time of the last touch event for double click detection.\r\n */\nmxGraph.prototype.lastTouchTime = 0;\n\n/**\r\n * Variable: tapAndHoldEnabled\r\n *\r\n * Specifies if tap and hold should be used for starting connections on touch-based\r\n * devices. Default is true.\r\n */\nmxGraph.prototype.tapAndHoldEnabled = true;\n\n/**\r\n * Variable: tapAndHoldDelay\r\n *\r\n * Specifies the time for a tap and hold. Default is 500 ms.\r\n */\nmxGraph.prototype.tapAndHoldDelay = 500;\n\n/**\r\n * Variable: tapAndHoldInProgress\r\n *\r\n * True if the timer for tap and hold events is running.\r\n */\nmxGraph.prototype.tapAndHoldInProgress = false;\n\n/**\r\n * Variable: tapAndHoldValid\r\n *\r\n * True as long as the timer is running and the touch events\r\n * stay within the given <tapAndHoldTolerance>.\r\n */\nmxGraph.prototype.tapAndHoldValid = false;\n\n/**\r\n * Variable: initialTouchX\r\n *\r\n * Holds the x-coordinate of the intial touch event for tap and hold.\r\n */\nmxGraph.prototype.initialTouchX = 0;\n\n/**\r\n * Variable: initialTouchY\r\n *\r\n * Holds the y-coordinate of the intial touch event for tap and hold.\r\n */\nmxGraph.prototype.initialTouchY = 0;\n\n/**\r\n * Variable: tolerance\r\n *\r\n * Tolerance for a move to be handled as a single click.\r\n * Default is 4 pixels.\r\n */\nmxGraph.prototype.tolerance = 4;\n\n/**\r\n * Variable: defaultOverlap\r\n *\r\n * Value returned by <getOverlap> if <isAllowOverlapParent> returns\r\n * true for the given cell. <getOverlap> is used in <constrainChild> if\r\n * <isConstrainChild> returns true. The value specifies the\r\n * portion of the child which is allowed to overlap the parent.\r\n */\nmxGraph.prototype.defaultOverlap = 0.5;\n\n/**\r\n * Variable: defaultParent\r\n *\r\n * Specifies the default parent to be used to insert new cells.\r\n * This is used in <getDefaultParent>. Default is null.\r\n */\nmxGraph.prototype.defaultParent = null;\n\n/**\r\n * Variable: alternateEdgeStyle\r\n *\r\n * Specifies the alternate edge style to be used if the main control point\r\n * on an edge is being doubleclicked. Default is null.\r\n */\nmxGraph.prototype.alternateEdgeStyle = null;\n\n/**\r\n * Variable: backgroundImage\r\n *\r\n * Specifies the <mxImage> to be returned by <getBackgroundImage>. Default\r\n * is null.\r\n *\r\n * Example:\r\n *\r\n * (code)\r\n * var img = new mxImage('http://www.example.com/maps/examplemap.jpg', 1024, 768);\r\n * graph.setBackgroundImage(img);\r\n * graph.view.validate();\r\n * (end)\r\n */\nmxGraph.prototype.backgroundImage = null;\n\n/**\r\n * Variable: pageVisible\r\n *\r\n * Specifies if the background page should be visible. Default is false.\r\n * Not yet implemented.\r\n */\nmxGraph.prototype.pageVisible = false;\n\n/**\r\n * Variable: pageBreaksVisible\r\n *\r\n * Specifies if a dashed line should be drawn between multiple pages. Default\r\n * is false. If you change this value while a graph is being displayed then you\r\n * should call <sizeDidChange> to force an update of the display.\r\n */\nmxGraph.prototype.pageBreaksVisible = false;\n\n/**\r\n * Variable: pageBreakColor\r\n *\r\n * Specifies the color for page breaks. Default is 'gray'.\r\n */\nmxGraph.prototype.pageBreakColor = 'gray';\n\n/**\r\n * Variable: pageBreakDashed\r\n *\r\n * Specifies the page breaks should be dashed. Default is true.\r\n */\nmxGraph.prototype.pageBreakDashed = true;\n\n/**\r\n * Variable: minPageBreakDist\r\n *\r\n * Specifies the minimum distance for page breaks to be visible. Default is\r\n * 20 (in pixels).\r\n */\nmxGraph.prototype.minPageBreakDist = 20;\n\n/**\r\n * Variable: preferPageSize\r\n *\r\n * Specifies if the graph size should be rounded to the next page number in\r\n * <sizeDidChange>. This is only used if the graph container has scrollbars.\r\n * Default is false.\r\n */\nmxGraph.prototype.preferPageSize = false;\n\n/**\r\n * Variable: pageFormat\r\n *\r\n * Specifies the page format for the background page. Default is\r\n * <mxConstants.PAGE_FORMAT_A4_PORTRAIT>. This is used as the default in\r\n * <mxPrintPreview> and for painting the background page if <pageVisible> is\r\n * true and the pagebreaks if <pageBreaksVisible> is true.\r\n */\nmxGraph.prototype.pageFormat = _mxConstants[\"default\"].PAGE_FORMAT_A4_PORTRAIT;\n\n/**\r\n * Variable: pageScale\r\n *\r\n * Specifies the scale of the background page. Default is 1.5.\r\n * Not yet implemented.\r\n */\nmxGraph.prototype.pageScale = 1.5;\n\n/**\r\n * Variable: enabled\r\n *\r\n * Specifies the return value for <isEnabled>. Default is true.\r\n */\nmxGraph.prototype.enabled = true;\nmxGraph.prototype.animation = false;\n\n/**\r\n * Variable: escapeEnabled\r\n *\r\n * Specifies if <mxKeyHandler> should invoke <escape> when the escape key\r\n * is pressed. Default is true.\r\n */\nmxGraph.prototype.escapeEnabled = true;\n\n/**\r\n * Variable: invokesStopCellEditing\r\n *\r\n * If true, when editing is to be stopped by way of selection changing,\r\n * data in diagram changing or other means stopCellEditing is invoked, and\r\n * changes are saved. This is implemented in a focus handler in\r\n * <mxCellEditor>. Default is true.\r\n */\nmxGraph.prototype.invokesStopCellEditing = true;\n\n/**\r\n * Variable: enterStopsCellEditing\r\n *\r\n * If true, pressing the enter key without pressing control or shift will stop\r\n * editing and accept the new value. This is used in <mxCellEditor> to stop\r\n * cell editing. Note: You can always use F2 and escape to stop editing.\r\n * Default is false.\r\n */\nmxGraph.prototype.enterStopsCellEditing = false;\n\n/**\r\n * Variable: useScrollbarsForPanning\r\n *\r\n * Specifies if scrollbars should be used for panning in <panGraph> if\r\n * any scrollbars are available. If scrollbars are enabled in CSS, but no\r\n * scrollbars appear because the graph is smaller than the container size,\r\n * then no panning occurs if this is true. Default is true.\r\n */\nmxGraph.prototype.useScrollbarsForPanning = true;\n\n/**\r\n * Variable: exportEnabled\r\n *\r\n * Specifies the return value for <canExportCell>. Default is true.\r\n */\nmxGraph.prototype.exportEnabled = true;\n\n/**\r\n * Variable: importEnabled\r\n *\r\n * Specifies the return value for <canImportCell>. Default is true.\r\n */\nmxGraph.prototype.importEnabled = true;\n\n/**\r\n * Variable: cellsLocked\r\n *\r\n * Specifies the return value for <isCellLocked>. Default is false.\r\n */\nmxGraph.prototype.cellsLocked = false;\n\n/**\r\n * Variable: cellsCloneable\r\n *\r\n * Specifies the return value for <isCellCloneable>. Default is true.\r\n */\nmxGraph.prototype.cellsCloneable = true;\n\n/**\r\n * Variable: foldingEnabled\r\n *\r\n * Specifies if folding (collapse and expand via an image icon in the graph\r\n * should be enabled). Default is true.\r\n */\nmxGraph.prototype.foldingEnabled = true;\n\n/**\r\n * Variable: cellsEditable\r\n *\r\n * Specifies the return value for <isCellEditable>. Default is true.\r\n */\nmxGraph.prototype.cellsEditable = true;\n\n/**\r\n * Variable: cellsDeletable\r\n *\r\n * Specifies the return value for <isCellDeletable>. Default is true.\r\n */\nmxGraph.prototype.cellsDeletable = true;\n\n/**\r\n * Variable: cellsMovable\r\n *\r\n * Specifies the return value for <isCellMovable>. Default is true.\r\n */\nmxGraph.prototype.cellsMovable = true;\n\n/**\r\n * Variable: edgeLabelsMovable\r\n *\r\n * Specifies the return value for edges in <isLabelMovable>. Default is true.\r\n */\nmxGraph.prototype.edgeLabelsMovable = true;\n\n/**\r\n * Variable: vertexLabelsMovable\r\n *\r\n * Specifies the return value for vertices in <isLabelMovable>. Default is false.\r\n */\nmxGraph.prototype.vertexLabelsMovable = false;\n\n/**\r\n * Variable: dropEnabled\r\n *\r\n * Specifies the return value for <isDropEnabled>. Default is false.\r\n */\nmxGraph.prototype.dropEnabled = false;\n\n/**\r\n * Variable: splitEnabled\r\n *\r\n * Specifies if dropping onto edges should be enabled. This is ignored if\r\n * <dropEnabled> is false. If enabled, it will call <splitEdge> to carry\r\n * out the drop operation. Default is true.\r\n */\nmxGraph.prototype.splitEnabled = true;\n\n/**\r\n * Variable: cellsResizable\r\n *\r\n * Specifies the return value for <isCellResizable>. Default is true.\r\n */\nmxGraph.prototype.cellsResizable = true;\n\n/**\r\n * Variable: cellsBendable\r\n *\r\n * Specifies the return value for <isCellsBendable>. Default is true.\r\n */\nmxGraph.prototype.cellsBendable = true;\n\n/**\r\n * Variable: cellsSelectable\r\n *\r\n * Specifies the return value for <isCellSelectable>. Default is true.\r\n */\nmxGraph.prototype.cellsSelectable = true;\n\n/**\r\n * Variable: cellsDisconnectable\r\n *\r\n * Specifies the return value for <isCellDisconntable>. Default is true.\r\n */\nmxGraph.prototype.cellsDisconnectable = true;\n\n/**\r\n * Variable: autoSizeCells\r\n *\r\n * Specifies if the graph should automatically update the cell size after an\r\n * edit. This is used in <isAutoSizeCell>. Default is false.\r\n */\nmxGraph.prototype.autoSizeCells = false;\n\n/**\r\n * Variable: autoSizeCellsOnAdd\r\n *\r\n * Specifies if autoSize style should be applied when cells are added. Default is false.\r\n */\nmxGraph.prototype.autoSizeCellsOnAdd = false;\n\n/**\r\n * Variable: autoScroll\r\n *\r\n * Specifies if the graph should automatically scroll if the mouse goes near\r\n * the container edge while dragging. This is only taken into account if the\r\n * container has scrollbars. Default is true.\r\n *\r\n * If you need this to work without scrollbars then set <ignoreScrollbars> to\r\n * true. Please consult the <ignoreScrollbars> for details. In general, with\r\n * no scrollbars, the use of <allowAutoPanning> is recommended.\r\n */\nmxGraph.prototype.autoScroll = true;\n\n/**\r\n * Variable: ignoreScrollbars\r\n *\r\n * Specifies if the graph should automatically scroll regardless of the\r\n * scrollbars. This will scroll the container using positive values for\r\n * scroll positions (ie usually only rightwards and downwards). To avoid\r\n * possible conflicts with panning, set <translateToScrollPosition> to true.\r\n */\nmxGraph.prototype.ignoreScrollbars = false;\n\n/**\r\n * Variable: translateToScrollPosition\r\n *\r\n * Specifies if the graph should automatically convert the current scroll\r\n * position to a translate in the graph view when a mouseUp event is received.\r\n * This can be used to avoid conflicts when using <autoScroll> and\r\n * <ignoreScrollbars> with no scrollbars in the container.\r\n */\nmxGraph.prototype.translateToScrollPosition = false;\n\n/**\r\n * Variable: timerAutoScroll\r\n *\r\n * Specifies if autoscrolling should be carried out via mxPanningManager even\r\n * if the container has scrollbars. This disables <scrollPointToVisible> and\r\n * uses <mxPanningManager> instead. If this is true then <autoExtend> is\r\n * disabled. It should only be used with a scroll buffer or when scollbars\r\n * are visible and scrollable in all directions. Default is false.\r\n */\nmxGraph.prototype.timerAutoScroll = false;\n\n/**\r\n * Variable: allowAutoPanning\r\n *\r\n * Specifies if panning via <panGraph> should be allowed to implement autoscroll\r\n * if no scrollbars are available in <scrollPointToVisible>. To enable panning\r\n * inside the container, near the edge, set <mxPanningManager.border> to a\r\n * positive value. Default is false.\r\n */\nmxGraph.prototype.allowAutoPanning = false;\n\n/**\r\n * Variable: autoExtend\r\n *\r\n * Specifies if the size of the graph should be automatically extended if the\r\n * mouse goes near the container edge while dragging. This is only taken into\r\n * account if the container has scrollbars. Default is true. See <autoScroll>.\r\n */\nmxGraph.prototype.autoExtend = true;\n\n/**\r\n * Variable: maximumGraphBounds\r\n *\r\n * <mxRectangle> that specifies the area in which all cells in the diagram\r\n * should be placed. Uses in <getMaximumGraphBounds>. Use a width or height of\r\n * 0 if you only want to give a upper, left corner.\r\n */\nmxGraph.prototype.maximumGraphBounds = null;\n\n/**\r\n * Variable: minimumGraphSize\r\n *\r\n * <mxRectangle> that specifies the minimum size of the graph. This is ignored\r\n * if the graph container has no scrollbars. Default is null.\r\n */\nmxGraph.prototype.minimumGraphSize = null;\n\n/**\r\n * Variable: minimumContainerSize\r\n *\r\n * <mxRectangle> that specifies the minimum size of the <container> if\r\n * <resizeContainer> is true.\r\n */\nmxGraph.prototype.minimumContainerSize = null;\n\n/**\r\n * Variable: maximumContainerSize\r\n *\r\n * <mxRectangle> that specifies the maximum size of the container if\r\n * <resizeContainer> is true.\r\n */\nmxGraph.prototype.maximumContainerSize = null;\n\n/**\r\n * Variable: resizeContainer\r\n *\r\n * Specifies if the container should be resized to the graph size when\r\n * the graph size has changed. Default is false.\r\n */\nmxGraph.prototype.resizeContainer = false;\n\n/**\r\n * Variable: border\r\n *\r\n * Border to be added to the bottom and right side when the container is\r\n * being resized after the graph has been changed. Default is 0.\r\n */\nmxGraph.prototype.border = 0;\n\n/**\r\n * Variable: keepEdgesInForeground\r\n *\r\n * Specifies if edges should appear in the foreground regardless of their order\r\n * in the model. If <keepEdgesInForeground> and <keepEdgesInBackground> are\r\n * both true then the normal order is applied. Default is false.\r\n */\nmxGraph.prototype.keepEdgesInForeground = false;\n\n/**\r\n * Variable: keepEdgesInBackground\r\n *\r\n * Specifies if edges should appear in the background regardless of their order\r\n * in the model. If <keepEdgesInForeground> and <keepEdgesInBackground> are\r\n * both true then the normal order is applied. Default is false.\r\n */\nmxGraph.prototype.keepEdgesInBackground = false;\n\n/**\r\n * Variable: allowNegativeCoordinates\r\n *\r\n * Specifies if negative coordinates for vertices are allowed. Default is true.\r\n */\nmxGraph.prototype.allowNegativeCoordinates = true;\n\n/**\r\n * Variable: constrainChildren\r\n *\r\n * Specifies if a child should be constrained inside the parent bounds after a\r\n * move or resize of the child. Default is true.\r\n */\nmxGraph.prototype.constrainChildren = true;\n\n/**\r\n * Variable: constrainRelativeChildren\r\n *\r\n * Specifies if child cells with relative geometries should be constrained\r\n * inside the parent bounds, if <constrainChildren> is true, and/or the\r\n * <maximumGraphBounds>. Default is false.\r\n */\nmxGraph.prototype.constrainRelativeChildren = false;\n\n/**\r\n * Variable: extendParents\r\n *\r\n * Specifies if a parent should contain the child bounds after a resize of\r\n * the child. Default is true. This has precedence over <constrainChildren>.\r\n */\nmxGraph.prototype.extendParents = true;\n\n/**\r\n * Variable: extendParentsOnAdd\r\n *\r\n * Specifies if parents should be extended according to the <extendParents>\r\n * switch if cells are added. Default is true.\r\n */\nmxGraph.prototype.extendParentsOnAdd = true;\n\n/**\r\n * Variable: extendParentsOnAdd\r\n *\r\n * Specifies if parents should be extended according to the <extendParents>\r\n * switch if cells are added. Default is false for backwards compatiblity.\r\n */\nmxGraph.prototype.extendParentsOnMove = false;\n\n/**\r\n * Variable: recursiveResize\r\n *\r\n * Specifies the return value for <isRecursiveResize>. Default is\r\n * false for backwards compatiblity.\r\n */\nmxGraph.prototype.recursiveResize = false;\n\n/**\r\n * Variable: collapseToPreferredSize\r\n *\r\n * Specifies if the cell size should be changed to the preferred size when\r\n * a cell is first collapsed. Default is true.\r\n */\nmxGraph.prototype.collapseToPreferredSize = true;\n\n/**\r\n * Variable: zoomFactor\r\n *\r\n * Specifies the factor used for <zoomIn> and <zoomOut>. Default is 1.2\r\n * (120%).\r\n */\nmxGraph.prototype.zoomFactor = 1.2;\n\n/**\r\n * Variable: keepSelectionVisibleOnZoom\r\n *\r\n * Specifies if the viewport should automatically contain the selection cells\r\n * after a zoom operation. Default is false.\r\n */\nmxGraph.prototype.keepSelectionVisibleOnZoom = false;\n\n/**\r\n * Variable: centerZoom\r\n *\r\n * Specifies if the zoom operations should go into the center of the actual\r\n * diagram rather than going from top, left. Default is true.\r\n */\nmxGraph.prototype.centerZoom = true;\n\n/**\r\n * Variable: resetViewOnRootChange\r\n *\r\n * Specifies if the scale and translate should be reset if the root changes in\r\n * the model. Default is true.\r\n */\nmxGraph.prototype.resetViewOnRootChange = true;\n\n/**\r\n * Variable: resetEdgesOnResize\r\n *\r\n * Specifies if edge control points should be reset after the resize of a\r\n * connected cell. Default is false.\r\n */\nmxGraph.prototype.resetEdgesOnResize = false;\n\n/**\r\n * Variable: resetEdgesOnMove\r\n *\r\n * Specifies if edge control points should be reset after the move of a\r\n * connected cell. Default is false.\r\n */\nmxGraph.prototype.resetEdgesOnMove = false;\n\n/**\r\n * Variable: resetEdgesOnConnect\r\n *\r\n * Specifies if edge control points should be reset after the the edge has been\r\n * reconnected. Default is true.\r\n */\nmxGraph.prototype.resetEdgesOnConnect = true;\n\n/**\r\n * Variable: allowLoops\r\n *\r\n * Specifies if loops (aka self-references) are allowed. Default is false.\r\n */\nmxGraph.prototype.allowLoops = false;\n\n/**\r\n * Variable: defaultLoopStyle\r\n *\r\n * <mxEdgeStyle> to be used for loops. This is a fallback for loops if the\r\n * <mxConstants.STYLE_LOOP> is undefined. Default is <mxEdgeStyle.Loop>.\r\n */\nmxGraph.prototype.defaultLoopStyle = _mxEdgeStyle[\"default\"].Loop;\n\n/**\r\n * Variable: multigraph\r\n *\r\n * Specifies if multiple edges in the same direction between the same pair of\r\n * vertices are allowed. Default is true.\r\n */\nmxGraph.prototype.multigraph = true;\n\n/**\r\n * Variable: connectableEdges\r\n *\r\n * Specifies if edges are connectable. Default is false. This overrides the\r\n * connectable field in edges.\r\n */\nmxGraph.prototype.connectableEdges = false;\n\n/**\r\n * Variable: allowDanglingEdges\r\n *\r\n * Specifies if edges with disconnected terminals are allowed in the graph.\r\n * Default is true.\r\n */\nmxGraph.prototype.allowDanglingEdges = true;\n\n/**\r\n * Variable: cloneInvalidEdges\r\n *\r\n * Specifies if edges that are cloned should be validated and only inserted\r\n * if they are valid. Default is true.\r\n */\nmxGraph.prototype.cloneInvalidEdges = false;\n\n/**\r\n * Variable: disconnectOnMove\r\n *\r\n * Specifies if edges should be disconnected from their terminals when they\r\n * are moved. Default is true.\r\n */\nmxGraph.prototype.disconnectOnMove = true;\n\n/**\r\n * Variable: labelsVisible\r\n *\r\n * Specifies if labels should be visible. This is used in <getLabel>. Default\r\n * is true.\r\n */\nmxGraph.prototype.labelsVisible = true;\n\n/**\r\n * Variable: htmlLabels\r\n *\r\n * Specifies the return value for <isHtmlLabel>. Default is false.\r\n */\nmxGraph.prototype.htmlLabels = false;\n\n/**\r\n * Variable: swimlaneSelectionEnabled\r\n *\r\n * Specifies if swimlanes should be selectable via the content if the\r\n * mouse is released. Default is true.\r\n */\nmxGraph.prototype.swimlaneSelectionEnabled = true;\n\n/**\r\n * Variable: swimlaneNesting\r\n *\r\n * Specifies if nesting of swimlanes is allowed. Default is true.\r\n */\nmxGraph.prototype.swimlaneNesting = true;\n\n/**\r\n * Variable: swimlaneIndicatorColorAttribute\r\n *\r\n * The attribute used to find the color for the indicator if the indicator\r\n * color is set to 'swimlane'. Default is <mxConstants.STYLE_FILLCOLOR>.\r\n */\nmxGraph.prototype.swimlaneIndicatorColorAttribute = _mxConstants[\"default\"].STYLE_FILLCOLOR;\n\n/**\r\n * Variable: imageBundles\r\n *\r\n * Holds the list of image bundles.\r\n */\nmxGraph.prototype.imageBundles = null;\n\n/**\r\n * Variable: minFitScale\r\n *\r\n * Specifies the minimum scale to be applied in <fit>. Default is 0.1. Set this\r\n * to null to allow any value.\r\n */\nmxGraph.prototype.minFitScale = 0.1;\n\n/**\r\n * Variable: maxFitScale\r\n *\r\n * Specifies the maximum scale to be applied in <fit>. Default is 8. Set this\r\n * to null to allow any value.\r\n */\nmxGraph.prototype.maxFitScale = 8;\n\n/**\r\n * Variable: panDx\r\n *\r\n * Current horizontal panning value. Default is 0.\r\n */\nmxGraph.prototype.panDx = 0;\n\n/**\r\n * Variable: panDy\r\n *\r\n * Current vertical panning value. Default is 0.\r\n */\nmxGraph.prototype.panDy = 0;\n\n/**\r\n * Variable: collapsedImage\r\n *\r\n * Specifies the <mxImage> to indicate a collapsed state.\r\n * Default value is mxClient.imageBasePath + '/collapsed.gif'\r\n */\nmxGraph.prototype.collapsedImage = new _mxImage[\"default\"](_mxGraphConstants[\"default\"].COLLAPSED_IMAGE, 15, 15);\n\n/**\r\n * Variable: expandedImage\r\n *\r\n * Specifies the <mxImage> to indicate a expanded state.\r\n * Default value is mxClient.imageBasePath + '/expanded.gif'\r\n */\nmxGraph.prototype.expandedImage = new _mxImage[\"default\"](_mxGraphConstants[\"default\"].EXPANDED_IMAGE, 15, 15);\n\n/**\r\n * Variable: warningImage\r\n *\r\n * Specifies the <mxImage> for the image to be used to display a warning\r\n * overlay. See <setCellWarning>. Default value is mxClient.imageBasePath +\r\n * '/warning'.  The extension for the image depends on the platform. It is\r\n * '.png' on the Mac and '.gif' on all other platforms.\r\n */\nmxGraph.prototype.warningImage = new _mxImage[\"default\"](_mxClient[\"default\"].imageBasePath + '/warning' + (_mxClient[\"default\"].IS_MAC ? '.png' : '.gif'), 16, 16);\n\n/**\r\n * Variable: alreadyConnectedResource\r\n *\r\n * Specifies the resource key for the error message to be displayed in\r\n * non-multigraphs when two vertices are already connected. If the resource\r\n * for this key does not exist then the value is used as the error message.\r\n * Default is 'alreadyConnected'.\r\n */\nmxGraph.prototype.alreadyConnectedResource = _mxClient[\"default\"].language != 'none' ? 'alreadyConnected' : '';\n\n/**\r\n * Variable: containsValidationErrorsResource\r\n *\r\n * Specifies the resource key for the warning message to be displayed when\r\n * a collapsed cell contains validation errors. If the resource for this\r\n * key does not exist then the value is used as the warning message.\r\n * Default is 'containsValidationErrors'.\r\n */\nmxGraph.prototype.containsValidationErrorsResource = _mxClient[\"default\"].language != 'none' ? 'containsValidationErrors' : '';\n\n/**\r\n * Variable: collapseExpandResource\r\n *\r\n * Specifies the resource key for the tooltip on the collapse/expand icon.\r\n * If the resource for this key does not exist then the value is used as\r\n * the tooltip. Default is 'collapse-expand'.\r\n */\nmxGraph.prototype.collapseExpandResource = _mxClient[\"default\"].language != 'none' ? 'collapse-expand' : '';\n\n/**\r\n * Function: init\r\n *\r\n * Initializes the <container> and creates the respective datastructures.\r\n *\r\n * Parameters:\r\n *\r\n * container - DOM node that will contain the graph display.\r\n */\nmxGraph.prototype.init = function (container) {\n  this.container = container;\n\n  // Initializes the in-place editor\n  this.cellEditor = this.createCellEditor();\n\n  // Initializes the container using the view\n  this.view.init();\n\n  // Updates the size of the container for the current graph\n  this.sizeDidChange();\n\n  // Hides tooltips and resets tooltip timer if mouse leaves container\n  _mxEvent[\"default\"].addListener(container, 'mouseleave', _mxGraphUtils[\"default\"].bind(this, function () {\n    if (this.tooltipHandler != null) {\n      this.tooltipHandler.hide();\n    }\n  }));\n\n  // Automatic deallocation of memory\n  if (_mxClient[\"default\"].IS_IE) {\n    _mxEvent[\"default\"].addListener(window, 'unload', _mxGraphUtils[\"default\"].bind(this, function () {\n      this.destroy();\n    }));\n\n    // Disable shift-click for text\n    _mxEvent[\"default\"].addListener(container, 'selectstart', _mxGraphUtils[\"default\"].bind(this, function (evt) {\n      return this.isEditing() || !this.isMouseDown && !_mxEvent[\"default\"].isShiftDown(evt);\n    }));\n  }\n\n  // Workaround for missing last shape and connect preview in IE8 standards\n  // mode if no initial graph displayed or no label for shape defined\n  if (document.documentMode == 8) {\n    container.insertAdjacentHTML('beforeend', '<v:group style=\"DISPLAY: none;\"></v:group>');\n  }\n};\n\n/**\r\n * Function: createHandlers\r\n *\r\n * Creates the tooltip-, panning-, connection- and graph-handler (in this\r\n * order). This is called in the constructor before <init> is called.\r\n */\nmxGraph.prototype.createHandlers = function () {\n  this.tooltipHandler = this.createTooltipHandler();\n  this.tooltipHandler.setEnabled(false);\n  this.selectionCellsHandler = this.createSelectionCellsHandler();\n  this.connectionHandler = this.createConnectionHandler();\n  this.connectionHandler.setEnabled(false);\n  this.graphHandler = this.createGraphHandler();\n  this.panningHandler = this.createPanningHandler();\n  this.panningHandler.panningEnabled = false;\n  this.popupMenuHandler = this.createPopupMenuHandler();\n};\n\n/**\r\n * Function: createTooltipHandler\r\n *\r\n * Creates and returns a new <mxTooltipHandler> to be used in this graph.\r\n */\nmxGraph.prototype.createTooltipHandler = function () {\n  return new _mxTooltipHandler[\"default\"](this);\n};\n\n/**\r\n * Function: createSelectionCellsHandler\r\n *\r\n * Creates and returns a new <mxTooltipHandler> to be used in this graph.\r\n */\nmxGraph.prototype.createSelectionCellsHandler = function () {\n  return new _mxSelectionCellsHandler[\"default\"](this);\n};\n\n/**\r\n * Function: createConnectionHandler\r\n *\r\n * Creates and returns a new <mxConnectionHandler> to be used in this graph.\r\n */\nmxGraph.prototype.createConnectionHandler = function () {\n  return new _mxConnectionHandler[\"default\"](this);\n};\n\n/**\r\n * Function: createGraphHandler\r\n *\r\n * Creates and returns a new <mxGraphHandler> to be used in this graph.\r\n */\nmxGraph.prototype.createGraphHandler = function () {\n  return new _mxGraphHandler[\"default\"](this);\n};\n\n/**\r\n * Function: createPanningHandler\r\n *\r\n * Creates and returns a new <mxPanningHandler> to be used in this graph.\r\n */\nmxGraph.prototype.createPanningHandler = function () {\n  return new _mxPanningHandler[\"default\"](this);\n};\n\n/**\r\n * Function: createPopupMenuHandler\r\n *\r\n * Creates and returns a new <mxPopupMenuHandler> to be used in this graph.\r\n */\nmxGraph.prototype.createPopupMenuHandler = function () {\n  return new _mxPopupMenuHandler[\"default\"](this);\n};\n\n/**\r\n * Function: createSelectionModel\r\n *\r\n * Creates a new <mxGraphSelectionModel> to be used in this graph.\r\n */\nmxGraph.prototype.createSelectionModel = function () {\n  return new _mxGraphSelectionModel[\"default\"](this);\n};\n\n/**\r\n * Function: createStylesheet\r\n *\r\n * Creates a new <mxGraphSelectionModel> to be used in this graph.\r\n */\nmxGraph.prototype.createStylesheet = function () {\n  return new _mxStylesheet[\"default\"]();\n};\n\n/**\r\n * Function: createGraphView\r\n *\r\n * Creates a new <mxGraphView> to be used in this graph.\r\n */\nmxGraph.prototype.createGraphView = function () {\n  return new _mxGraphView[\"default\"](this);\n};\n\n/**\r\n * Function: createCellRenderer\r\n *\r\n * Creates a new <mxCellRenderer> to be used in this graph.\r\n */\nmxGraph.prototype.createCellRenderer = function () {\n  return new _mxCellRenderer[\"default\"]();\n};\n\n/**\r\n * Function: createCellEditor\r\n *\r\n * Creates a new <mxCellEditor> to be used in this graph.\r\n */\nmxGraph.prototype.createCellEditor = function () {\n  return new _mxCellEditor[\"default\"](this);\n};\n\n/**\r\n * Function: getModel\r\n *\r\n * Returns the <mxGraphModel> that contains the cells.\r\n */\nmxGraph.prototype.getModel = function () {\n  return this.model;\n};\n\n/**\r\n * Function: getView\r\n *\r\n * Returns the <mxGraphView> that contains the <mxCellStates>.\r\n */\nmxGraph.prototype.getView = function () {\n  return this.view;\n};\n\n/**\r\n * Function: getStylesheet\r\n *\r\n * Returns the <mxStylesheet> that defines the style.\r\n */\nmxGraph.prototype.getStylesheet = function () {\n  return this.stylesheet;\n};\n\n/**\r\n * Function: setStylesheet\r\n *\r\n * Sets the <mxStylesheet> that defines the style.\r\n */\nmxGraph.prototype.setStylesheet = function (stylesheet) {\n  this.stylesheet = stylesheet;\n};\n\n/**\r\n * Function: getSelectionModel\r\n *\r\n * Returns the <mxGraphSelectionModel> that contains the selection.\r\n */\nmxGraph.prototype.getSelectionModel = function () {\n  return this.selectionModel;\n};\n\n/**\r\n * Function: setSelectionModel\r\n *\r\n * Sets the <mxSelectionModel> that contains the selection.\r\n */\nmxGraph.prototype.setSelectionModel = function (selectionModel) {\n  this.selectionModel = selectionModel;\n};\n\n/**\r\n * Function: getSelectionCellsForChanges\r\n *\r\n * Returns the cells to be selected for the given array of changes.\r\n */\nmxGraph.prototype.getSelectionCellsForChanges = function (changes) {\n  var cells = [];\n  for (var i = 0; i < changes.length; i++) {\n    var change = changes[i];\n    if (change.constructor != _mxRootChange[\"default\"]) {\n      var cell = null;\n      if (change instanceof _mxChildChange[\"default\"] && change.previous == null) {\n        cell = change.child;\n      } else if (change.cell != null && change.cell instanceof _mxCell[\"default\"]) {\n        cell = change.cell;\n      }\n      if (cell != null && _mxGraphUtils[\"default\"].indexOf(cells, cell) < 0) {\n        cells.push(cell);\n      }\n    }\n  }\n  return this.getModel().getTopmostCells(cells);\n};\n\n/**\r\n * Function: graphModelChanged\r\n *\r\n * Called when the graph model changes. Invokes <processChange> on each\r\n * item of the given array to update the view accordingly.\r\n *\r\n * Parameters:\r\n *\r\n * changes - Array that contains the individual changes.\r\n */\nmxGraph.prototype.graphModelChanged = function (changes) {\n  var styleChangesCount = 0;\n  for (var i = 0; i < changes.length; i++) {\n    var change = changes[i];\n    this.processChange(change);\n    if (change instanceof _mxStyleChange[\"default\"]) {\n      styleChangesCount++;\n    }\n  }\n  this.removeSelectionCells(this.getRemovedCellsForChanges(changes));\n  this.view.validate();\n  if (styleChangesCount == changes.length) {\n    return;\n  }\n  this.sizeDidChange();\n};\n\n/**\r\n * Function: getRemovedCellsForChanges\r\n *\r\n * Returns the cells that have been removed from the model.\r\n */\nmxGraph.prototype.getRemovedCellsForChanges = function (changes) {\n  var result = [];\n  for (var i = 0; i < changes.length; i++) {\n    var change = changes[i];\n\n    // Resets the view settings, removes all cells and clears\n    // the selection if the root changes.\n    if (change instanceof _mxRootChange[\"default\"]) {\n      break;\n    } else if (change instanceof _mxChildChange[\"default\"]) {\n      if (change.previous != null && change.parent == null) {\n        result = result.concat(this.model.getDescendants(change.child));\n      }\n    } else if (change instanceof _mxVisibleChange[\"default\"]) {\n      result = result.concat(this.model.getDescendants(change.cell));\n    }\n  }\n  return result;\n};\n\n/**\r\n * Function: processChange\r\n *\r\n * Processes the given change and invalidates the respective cached data\r\n * in <view>. This fires a <root> event if the root has changed in the\r\n * model.\r\n *\r\n * Parameters:\r\n *\r\n * change - Object that represents the change on the model.\r\n */\nmxGraph.prototype.processChange = function (change) {\n  // Resets the view settings, removes all cells and clears\n  // the selection if the root changes.\n  if (change instanceof _mxRootChange[\"default\"]) {\n    this.clearSelection();\n    this.removeStateForCell(change.previous);\n    if (this.resetViewOnRootChange) {\n      this.view.scale = 1;\n      this.view.translate.x = 0;\n      this.view.translate.y = 0;\n    }\n    this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].ROOT));\n  }\n\n  // Adds or removes a child to the view by online invaliding\n  // the minimal required portions of the cache, namely, the\n  // old and new parent and the child.\n  else if (change instanceof _mxChildChange[\"default\"]) {\n    var newParent = this.model.getParent(change.child);\n    this.view.invalidate(change.child, true, true);\n    if (newParent == null || this.isCellCollapsed(newParent)) {\n      this.view.invalidate(change.child, true, true);\n      this.removeStateForCell(change.child);\n\n      // Handles special case of current root of view being removed\n      if (this.view.currentRoot == change.child) {\n        this.home();\n      }\n    }\n    if (newParent != change.previous) {\n      // Refreshes the collapse/expand icons on the parents\n      if (newParent != null) {\n        this.view.invalidate(newParent, false, false);\n      }\n      if (change.previous != null) {\n        this.view.invalidate(change.previous, false, false);\n      }\n    }\n  }\n\n  // Handles two special cases where the shape does not need to be\n  // recreated from scratch, it only needs to be invalidated.\n  else if (change instanceof _mxTerminalChange[\"default\"] || change instanceof _mxGeometryChange[\"default\"]) {\n    // Checks if the geometry has changed to avoid unnessecary revalidation\n    if (change instanceof _mxTerminalChange[\"default\"] || change.previous == null && change.geometry != null || change.previous != null && !change.previous.equals(change.geometry)) {\n      this.view.invalidate(change.cell);\n    }\n  }\n\n  // Handles two special cases where only the shape, but no\n  // descendants need to be recreated\n  else if (change instanceof _mxValueChange[\"default\"]) {\n    this.view.invalidate(change.cell, false, false);\n  }\n\n  // Requires a new mxShape in JavaScript\n  else if (change instanceof _mxStyleChange[\"default\"]) {\n    this.view.invalidate(change.cell, true, true);\n    var state = this.view.getState(change.cell);\n    if (state != null) {\n      state.style = null;\n    }\n  }\n\n  // Removes the state from the cache by default\n  else if (change.cell != null && change.cell instanceof _mxCell[\"default\"]) {\n    this.removeStateForCell(change.cell);\n  }\n};\n\n/**\r\n * Function: removeStateForCell\r\n *\r\n * Removes all cached information for the given cell and its descendants.\r\n * This is called when a cell was removed from the model.\r\n *\r\n * Paramters:\r\n *\r\n * cell - <mxCell> that was removed from the model.\r\n */\nmxGraph.prototype.removeStateForCell = function (cell) {\n  var childCount = this.model.getChildCount(cell);\n  for (var i = 0; i < childCount; i++) {\n    this.removeStateForCell(this.model.getChildAt(cell, i));\n  }\n  this.view.invalidate(cell, false, true);\n  this.view.removeState(cell);\n};\n\n/**\r\n * Group: Overlays\r\n */\n\n/**\r\n * Function: addCellOverlay\r\n *\r\n * Adds an <mxCellOverlay> for the specified cell. This method fires an\r\n * <addoverlay> event and returns the new <mxCellOverlay>.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> to add the overlay for.\r\n * overlay - <mxCellOverlay> to be added for the cell.\r\n */\nmxGraph.prototype.addCellOverlay = function (cell, overlay) {\n  if (cell.overlays == null) {\n    cell.overlays = [];\n  }\n  cell.overlays.push(overlay);\n  var state = this.view.getState(cell);\n\n  // Immediately updates the cell display if the state exists\n  if (state != null) {\n    this.cellRenderer.redraw(state);\n  }\n  this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].ADD_OVERLAY, 'cell', cell, 'overlay', overlay));\n  return overlay;\n};\n\n/**\r\n * Function: getCellOverlays\r\n *\r\n * Returns the array of <mxCellOverlays> for the given cell or null, if\r\n * no overlays are defined.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose overlays should be returned.\r\n */\nmxGraph.prototype.getCellOverlays = function (cell) {\n  return cell.overlays;\n};\n\n/**\r\n * Function: removeCellOverlay\r\n *\r\n * Removes and returns the given <mxCellOverlay> from the given cell. This\r\n * method fires a <removeoverlay> event. If no overlay is given, then all\r\n * overlays are removed using <removeOverlays>.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose overlay should be removed.\r\n * overlay - Optional <mxCellOverlay> to be removed.\r\n */\nmxGraph.prototype.removeCellOverlay = function (cell, overlay) {\n  if (overlay == null) {\n    this.removeCellOverlays(cell);\n  } else {\n    var index = _mxGraphUtils[\"default\"].indexOf(cell.overlays, overlay);\n    if (index >= 0) {\n      cell.overlays.splice(index, 1);\n      if (cell.overlays.length == 0) {\n        cell.overlays = null;\n      }\n\n      // Immediately updates the cell display if the state exists\n      var state = this.view.getState(cell);\n      if (state != null) {\n        this.cellRenderer.redraw(state);\n      }\n      this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].REMOVE_OVERLAY, 'cell', cell, 'overlay', overlay));\n    } else {\n      overlay = null;\n    }\n  }\n  return overlay;\n};\n\n/**\r\n * Function: removeCellOverlays\r\n *\r\n * Removes all <mxCellOverlays> from the given cell. This method\r\n * fires a <removeoverlay> event for each <mxCellOverlay> and returns\r\n * the array of <mxCellOverlays> that was removed from the cell.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose overlays should be removed\r\n */\nmxGraph.prototype.removeCellOverlays = function (cell) {\n  var overlays = cell.overlays;\n  if (overlays != null) {\n    cell.overlays = null;\n\n    // Immediately updates the cell display if the state exists\n    var state = this.view.getState(cell);\n    if (state != null) {\n      this.cellRenderer.redraw(state);\n    }\n    for (var i = 0; i < overlays.length; i++) {\n      this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].REMOVE_OVERLAY, 'cell', cell, 'overlay', overlays[i]));\n    }\n  }\n  return overlays;\n};\n\n/**\r\n * Function: clearCellOverlays\r\n *\r\n * Removes all <mxCellOverlays> in the graph for the given cell and all its\r\n * descendants. If no cell is specified then all overlays are removed from\r\n * the graph. This implementation uses <removeCellOverlays> to remove the\r\n * overlays from the individual cells.\r\n *\r\n * Parameters:\r\n *\r\n * cell - Optional <mxCell> that represents the root of the subtree to\r\n * remove the overlays from. Default is the root in the model.\r\n */\nmxGraph.prototype.clearCellOverlays = function (cell) {\n  cell = cell != null ? cell : this.model.getRoot();\n  this.removeCellOverlays(cell);\n\n  // Recursively removes all overlays from the children\n  var childCount = this.model.getChildCount(cell);\n  for (var i = 0; i < childCount; i++) {\n    var child = this.model.getChildAt(cell, i);\n    this.clearCellOverlays(child); // recurse\n  }\n};\n\n/**\r\n * Function: setCellWarning\r\n *\r\n * Creates an overlay for the given cell using the warning and image or\r\n * <warningImage> and returns the new <mxCellOverlay>. The warning is\r\n * displayed as a tooltip in a red font and may contain HTML markup. If\r\n * the warning is null or a zero length string, then all overlays are\r\n * removed from the cell.\r\n *\r\n * Example:\r\n *\r\n * (code)\r\n * graph.setCellWarning(cell, '<b>Warning:</b>: Hello, World!');\r\n * (end)\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose warning should be set.\r\n * warning - String that represents the warning to be displayed.\r\n * img - Optional <mxImage> to be used for the overlay. Default is\r\n * <warningImage>.\r\n * isSelect - Optional boolean indicating if a click on the overlay\r\n * should select the corresponding cell. Default is false.\r\n */\nmxGraph.prototype.setCellWarning = function (cell, warning, img, isSelect) {\n  if (warning != null && warning.length > 0) {\n    img = img != null ? img : this.warningImage;\n\n    // Creates the overlay with the image and warning\n    var overlay = new _mxCellOverlay[\"default\"](img, '<font color=red>' + warning + '</font>');\n\n    // Adds a handler for single mouseclicks to select the cell\n    if (isSelect) {\n      overlay.addListener(_mxEvent[\"default\"].CLICK, _mxGraphUtils[\"default\"].bind(this, function (sender, evt) {\n        if (this.isEnabled()) {\n          this.setSelectionCell(cell);\n        }\n      }));\n    }\n\n    // Sets and returns the overlay in the graph\n    return this.addCellOverlay(cell, overlay);\n  } else {\n    this.removeCellOverlays(cell);\n  }\n  return null;\n};\n\n/**\r\n * Group: In-place editing\r\n */\n\n/**\r\n * Function: startEditing\r\n *\r\n * Calls <startEditingAtCell> using the given cell or the first selection\r\n * cell.\r\n *\r\n * Parameters:\r\n *\r\n * evt - Optional mouse event that triggered the editing.\r\n */\nmxGraph.prototype.startEditing = function (evt) {\n  this.startEditingAtCell(null, evt);\n};\n\n/**\r\n * Function: startEditingAtCell\r\n *\r\n * Fires a <startEditing> event and invokes <mxCellEditor.startEditing>\r\n * on <editor>. After editing was started, a <editingStarted> event is\r\n * fired.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> to start the in-place editor for.\r\n * evt - Optional mouse event that triggered the editing.\r\n */\nmxGraph.prototype.startEditingAtCell = function (cell, evt) {\n  if (evt == null || !_mxEvent[\"default\"].isMultiTouchEvent(evt)) {\n    if (cell == null) {\n      cell = this.getSelectionCell();\n      if (cell != null && !this.isCellEditable(cell)) {\n        cell = null;\n      }\n    }\n    if (cell != null) {\n      this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].START_EDITING, 'cell', cell, 'event', evt));\n      this.cellEditor.startEditing(cell, evt);\n      this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].EDITING_STARTED, 'cell', cell, 'event', evt));\n    }\n  }\n};\n\n/**\r\n * Function: getEditingValue\r\n *\r\n * Returns the initial value for in-place editing. This implementation\r\n * returns <convertValueToString> for the given cell. If this function is\r\n * overridden, then <mxGraphModel.valueForCellChanged> should take care\r\n * of correctly storing the actual new value inside the user object.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> for which the initial editing value should be returned.\r\n * evt - Optional mouse event that triggered the editor.\r\n */\nmxGraph.prototype.getEditingValue = function (cell, evt) {\n  return this.convertValueToString(cell);\n};\n\n/**\r\n * Function: stopEditing\r\n *\r\n * Stops the current editing  and fires a <editingStopped> event.\r\n *\r\n * Parameters:\r\n *\r\n * cancel - Boolean that specifies if the current editing value\r\n * should be stored.\r\n */\nmxGraph.prototype.stopEditing = function (cancel) {\n  this.cellEditor.stopEditing(cancel);\n  this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].EDITING_STOPPED, 'cancel', cancel));\n};\n\n/**\r\n * Function: labelChanged\r\n *\r\n * Sets the label of the specified cell to the given value using\r\n * <cellLabelChanged> and fires <mxEvent.LABEL_CHANGED> while the\r\n * transaction is in progress. Returns the cell whose label was changed.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose label should be changed.\r\n * value - New label to be assigned.\r\n * evt - Optional event that triggered the change.\r\n */\nmxGraph.prototype.labelChanged = function (cell, value, evt) {\n  this.model.beginUpdate();\n  try {\n    var old = cell.value;\n    this.cellLabelChanged(cell, value, this.isAutoSizeCell(cell));\n    this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].LABEL_CHANGED, 'cell', cell, 'value', value, 'old', old, 'event', evt));\n  } finally {\n    this.model.endUpdate();\n  }\n  return cell;\n};\n\n/**\r\n * Function: cellLabelChanged\r\n *\r\n * Sets the new label for a cell. If autoSize is true then\r\n * <cellSizeUpdated> will be called.\r\n *\r\n * In the following example, the function is extended to map changes to\r\n * attributes in an XML node, as shown in <convertValueToString>.\r\n * Alternatively, the handling of this can be implemented as shown in\r\n * <mxGraphModel.valueForCellChanged> without the need to clone the\r\n * user object.\r\n *\r\n * (code)\r\n * var graphCellLabelChanged = graph.cellLabelChanged;\r\n * graph.cellLabelChanged = function(cell, newValue, autoSize)\r\n * {\r\n * \t// Cloned for correct undo/redo\r\n * \tvar elt = cell.value.cloneNode(true);\r\n *  elt.setAttribute('label', newValue);\r\n *\r\n *  newValue = elt;\r\n *  graphCellLabelChanged.apply(this, arguments);\r\n * };\r\n * (end)\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose label should be changed.\r\n * value - New label to be assigned.\r\n * autoSize - Boolean that specifies if <cellSizeUpdated> should be called.\r\n */\nmxGraph.prototype.cellLabelChanged = function (cell, value, autoSize) {\n  this.model.beginUpdate();\n  try {\n    this.model.setValue(cell, value);\n    if (autoSize) {\n      this.cellSizeUpdated(cell, false);\n    }\n  } finally {\n    this.model.endUpdate();\n  }\n};\n\n/**\r\n * Group: Event processing\r\n */\n\n/**\r\n * Function: escape\r\n *\r\n * Processes an escape keystroke.\r\n *\r\n * Parameters:\r\n *\r\n * evt - Mouseevent that represents the keystroke.\r\n */\nmxGraph.prototype.escape = function (evt) {\n  this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].ESCAPE, 'event', evt));\n};\n\n/**\r\n * Function: click\r\n *\r\n * Processes a singleclick on an optional cell and fires a <click> event.\r\n * The click event is fired initially. If the graph is enabled and the\r\n * event has not been consumed, then the cell is selected using\r\n * <selectCellForEvent> or the selection is cleared using\r\n * <clearSelection>. The events consumed state is set to true if the\r\n * corresponding <mxMouseEvent> has been consumed.\r\n *\r\n * To handle a click event, use the following code.\r\n *\r\n * (code)\r\n * graph.addListener(mxEvent.CLICK, function(sender, evt)\r\n * {\r\n *   var e = evt.getProperty('event'); // mouse event\r\n *   var cell = evt.getProperty('cell'); // cell may be null\r\n *\r\n *   if (cell != null)\r\n *   {\r\n *     // Do something useful with cell and consume the event\r\n *     evt.consume();\r\n *   }\r\n * });\r\n * (end)\r\n *\r\n * Parameters:\r\n *\r\n * me - <mxMouseEvent> that represents the single click.\r\n */\nmxGraph.prototype.click = function (me) {\n  var evt = me.getEvent();\n  var cell = me.getCell();\n  var mxe = new _mxEventObject[\"default\"](_mxEvent[\"default\"].CLICK, 'event', evt, 'cell', cell);\n  if (me.isConsumed()) {\n    mxe.consume();\n  }\n  this.fireEvent(mxe);\n\n  // Handles the event if it has not been consumed\n  if (this.isEnabled() && !_mxEvent[\"default\"].isConsumed(evt) && !mxe.isConsumed()) {\n    if (cell != null) {\n      this.selectCellForEvent(cell, evt);\n    } else {\n      var swimlane = null;\n      if (this.isSwimlaneSelectionEnabled()) {\n        // Gets the swimlane at the location (includes\n        // content area of swimlanes)\n        swimlane = this.getSwimlaneAt(me.getGraphX(), me.getGraphY());\n      }\n\n      // Selects the swimlane and consumes the event\n      if (swimlane != null) {\n        this.selectCellForEvent(swimlane, evt);\n      }\n\n      // Ignores the event if the control key is pressed\n      else if (!this.isToggleEvent(evt)) {\n        this.clearSelection();\n      }\n    }\n  }\n};\n\n/**\r\n * Function: dblClick\r\n *\r\n * Processes a doubleclick on an optional cell and fires a <dblclick>\r\n * event. The event is fired initially. If the graph is enabled and the\r\n * event has not been consumed, then <edit> is called with the given\r\n * cell. The event is ignored if no cell was specified.\r\n *\r\n * Example for overriding this method.\r\n *\r\n * (code)\r\n * graph.dblClick = function(evt, cell)\r\n * {\r\n *   var mxe = new mxEventObject(mxEvent.DOUBLE_CLICK, 'event', evt, 'cell', cell);\r\n *   this.fireEvent(mxe);\r\n *\r\n *   if (this.isEnabled() && !mxEvent.isConsumed(evt) && !mxe.isConsumed())\r\n *   {\r\n * \t   mxUtils.alert('Hello, World!');\r\n *     mxe.consume();\r\n *   }\r\n * }\r\n * (end)\r\n *\r\n * Example listener for this event.\r\n *\r\n * (code)\r\n * graph.addListener(mxEvent.DOUBLE_CLICK, function(sender, evt)\r\n * {\r\n *   var cell = evt.getProperty('cell');\r\n *   // do something with the cell and consume the\r\n *   // event to prevent in-place editing from start\r\n * });\r\n * (end)\r\n *\r\n * Parameters:\r\n *\r\n * evt - Mouseevent that represents the doubleclick.\r\n * cell - Optional <mxCell> under the mousepointer.\r\n */\nmxGraph.prototype.dblClick = function (evt, cell) {\n  var mxe = new _mxEventObject[\"default\"](_mxEvent[\"default\"].DOUBLE_CLICK, 'event', evt, 'cell', cell);\n  this.fireEvent(mxe);\n\n  // Handles the event if it has not been consumed\n  if (this.isEnabled() && !_mxEvent[\"default\"].isConsumed(evt) && !mxe.isConsumed() && cell != null && this.isCellEditable(cell) && !this.isEditing(cell)) {\n    this.startEditingAtCell(cell, evt);\n    _mxEvent[\"default\"].consume(evt);\n  }\n};\n\n/**\r\n * Function: tapAndHold\r\n *\r\n * Handles the <mxMouseEvent> by highlighting the <mxCellState>.\r\n *\r\n * Parameters:\r\n *\r\n * me - <mxMouseEvent> that represents the touch event.\r\n * state - Optional <mxCellState> that is associated with the event.\r\n */\nmxGraph.prototype.tapAndHold = function (me) {\n  var evt = me.getEvent();\n  var mxe = new _mxEventObject[\"default\"](_mxEvent[\"default\"].TAP_AND_HOLD, 'event', evt, 'cell', me.getCell());\n\n  // LATER: Check if event should be consumed if me is consumed\n  this.fireEvent(mxe);\n  if (mxe.isConsumed()) {\n    // Resets the state of the panning handler\n    this.panningHandler.panningTrigger = false;\n  }\n\n  // Handles the event if it has not been consumed\n  if (this.isEnabled() && !_mxEvent[\"default\"].isConsumed(evt) && !mxe.isConsumed() && this.connectionHandler.isEnabled()) {\n    var state = this.view.getState(this.connectionHandler.marker.getCell(me));\n    if (state != null) {\n      this.connectionHandler.marker.currentColor = this.connectionHandler.marker.validColor;\n      this.connectionHandler.marker.markedState = state;\n      this.connectionHandler.marker.mark();\n      this.connectionHandler.first = new _mxPoint[\"default\"](me.getGraphX(), me.getGraphY());\n      this.connectionHandler.edgeState = this.connectionHandler.createEdgeState(me);\n      this.connectionHandler.previous = state;\n      this.connectionHandler.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].START, 'state', this.connectionHandler.previous));\n    }\n  }\n};\n\n/**\r\n * Function: scrollPointToVisible\r\n *\r\n * Scrolls the graph to the given point, extending the graph container if\r\n * specified.\r\n */\nmxGraph.prototype.scrollPointToVisible = function (x, y, extend, border) {\n  if (!this.timerAutoScroll && (this.ignoreScrollbars || _mxUtils[\"default\"].hasScrollbars(this.container))) {\n    var c = this.container;\n    border = border != null ? border : 20;\n    if (x >= c.scrollLeft && y >= c.scrollTop && x <= c.scrollLeft + c.clientWidth && y <= c.scrollTop + c.clientHeight) {\n      var dx = c.scrollLeft + c.clientWidth - x;\n      if (dx < border) {\n        var old = c.scrollLeft;\n        c.scrollLeft += border - dx;\n\n        // Automatically extends the canvas size to the bottom, right\n        // if the event is outside of the canvas and the edge of the\n        // canvas has been reached. Notes: Needs fix for IE.\n        if (extend && old == c.scrollLeft) {\n          if (this.dialect == _mxConstants[\"default\"].DIALECT_SVG) {\n            var root = this.view.getDrawPane().ownerSVGElement;\n            var width = this.container.scrollWidth + border - dx;\n\n            // Updates the clipping region. This is an expensive\n            // operation that should not be executed too often.\n            root.style.width = width + 'px';\n          } else {\n            var width = Math.max(c.clientWidth, c.scrollWidth) + border - dx;\n            var canvas = this.view.getCanvas();\n            canvas.style.width = width + 'px';\n          }\n          c.scrollLeft += border - dx;\n        }\n      } else {\n        dx = x - c.scrollLeft;\n        if (dx < border) {\n          c.scrollLeft -= border - dx;\n        }\n      }\n      var dy = c.scrollTop + c.clientHeight - y;\n      if (dy < border) {\n        var old = c.scrollTop;\n        c.scrollTop += border - dy;\n        if (old == c.scrollTop && extend) {\n          if (this.dialect == _mxConstants[\"default\"].DIALECT_SVG) {\n            var root = this.view.getDrawPane().ownerSVGElement;\n            var height = this.container.scrollHeight + border - dy;\n\n            // Updates the clipping region. This is an expensive\n            // operation that should not be executed too often.\n            root.style.height = height + 'px';\n          } else {\n            var height = Math.max(c.clientHeight, c.scrollHeight) + border - dy;\n            var canvas = this.view.getCanvas();\n            canvas.style.height = height + 'px';\n          }\n          c.scrollTop += border - dy;\n        }\n      } else {\n        dy = y - c.scrollTop;\n        if (dy < border) {\n          c.scrollTop -= border - dy;\n        }\n      }\n    }\n  } else if (this.allowAutoPanning && !this.panningHandler.isActive()) {\n    if (this.panningManager == null) {\n      this.panningManager = this.createPanningManager();\n    }\n    this.panningManager.panTo(x + this.panDx, y + this.panDy);\n  }\n};\n\n/**\r\n * Function: createPanningManager\r\n *\r\n * Creates and returns an <mxPanningManager>.\r\n */\nmxGraph.prototype.createPanningManager = function () {\n  return new _mxPanningManager[\"default\"](this);\n};\n\n/**\r\n * Function: getBorderSizes\r\n *\r\n * Returns the size of the border and padding on all four sides of the\r\n * container. The left, top, right and bottom borders are stored in the x, y,\r\n * width and height of the returned <mxRectangle>, respectively.\r\n */\nmxGraph.prototype.getBorderSizes = function () {\n  var css = _mxGraphUtils[\"default\"].getCurrentStyle(this.container);\n  return new _mxRectangle[\"default\"](_mxUtils[\"default\"].parseCssNumber(css.paddingLeft) + (css.borderLeftStyle != 'none' ? _mxUtils[\"default\"].parseCssNumber(css.borderLeftWidth) : 0), _mxUtils[\"default\"].parseCssNumber(css.paddingTop) + (css.borderTopStyle != 'none' ? _mxUtils[\"default\"].parseCssNumber(css.borderTopWidth) : 0), _mxUtils[\"default\"].parseCssNumber(css.paddingRight) + (css.borderRightStyle != 'none' ? _mxUtils[\"default\"].parseCssNumber(css.borderRightWidth) : 0), _mxUtils[\"default\"].parseCssNumber(css.paddingBottom) + (css.borderBottomStyle != 'none' ? _mxUtils[\"default\"].parseCssNumber(css.borderBottomWidth) : 0));\n};\n\n/**\r\n * Function: getPreferredPageSize\r\n *\r\n * Returns the preferred size of the background page if <preferPageSize> is true.\r\n */\nmxGraph.prototype.getPreferredPageSize = function (bounds, width, height) {\n  var scale = this.view.scale;\n  var tr = this.view.translate;\n  var fmt = this.pageFormat;\n  var ps = scale * this.pageScale;\n  var page = new _mxRectangle[\"default\"](0, 0, fmt.width * ps, fmt.height * ps);\n  var hCount = this.pageBreaksVisible ? Math.ceil(width / page.width) : 1;\n  var vCount = this.pageBreaksVisible ? Math.ceil(height / page.height) : 1;\n  return new _mxRectangle[\"default\"](0, 0, hCount * page.width + 2 + tr.x / scale, vCount * page.height + 2 + tr.y / scale);\n};\n\n/**\r\n * Function: fit\r\n *\r\n * Scales the graph such that the complete diagram fits into <container> and\r\n * returns the current scale in the view. To fit an initial graph prior to\r\n * rendering, set <mxGraphView.rendering> to false prior to changing the model\r\n * and execute the following after changing the model.\r\n *\r\n * (code)\r\n * graph.fit();\r\n * graph.view.rendering = true;\r\n * graph.refresh();\r\n * (end)\r\n *\r\n * To fit and center the graph, the following code can be used.\r\n *\r\n * (code)\r\n * var margin = 2;\r\n * var max = 3;\r\n *\r\n * var bounds = graph.getGraphBounds();\r\n * var cw = graph.container.clientWidth - margin;\r\n * var ch = graph.container.clientHeight - margin;\r\n * var w = bounds.width / graph.view.scale;\r\n * var h = bounds.height / graph.view.scale;\r\n * var s = Math.min(max, Math.min(cw / w, ch / h));\r\n *\r\n * graph.view.scaleAndTranslate(s,\r\n *   (margin + cw - w * s) / (2 * s) - bounds.x / graph.view.scale,\r\n *   (margin + ch - h * s) / (2 * s) - bounds.y / graph.view.scale);\r\n * (end)\r\n *\r\n * Parameters:\r\n *\r\n * border - Optional number that specifies the border. Default is <border>.\r\n * keepOrigin - Optional boolean that specifies if the translate should be\r\n * changed. Default is false.\r\n * margin - Optional margin in pixels. Default is 0.\r\n * enabled - Optional boolean that specifies if the scale should be set or\r\n * just returned. Default is true.\r\n * ignoreWidth - Optional boolean that specifies if the width should be\r\n * ignored. Default is false.\r\n * ignoreHeight - Optional boolean that specifies if the height should be\r\n * ignored. Default is false.\r\n */\nmxGraph.prototype.fit = function (border, keepOrigin, margin, enabled, ignoreWidth, ignoreHeight) {\n  if (this.container != null) {\n    border = border != null ? border : this.getBorder();\n    keepOrigin = keepOrigin != null ? keepOrigin : false;\n    margin = margin != null ? margin : 0;\n    enabled = enabled != null ? enabled : true;\n    ignoreWidth = ignoreWidth != null ? ignoreWidth : false;\n    ignoreHeight = ignoreHeight != null ? ignoreHeight : false;\n\n    // Adds spacing and border from css\n    var cssBorder = this.getBorderSizes();\n    var w1 = this.container.offsetWidth - cssBorder.x - cssBorder.width - 1;\n    var h1 = this.container.offsetHeight - cssBorder.y - cssBorder.height - 1;\n    var bounds = this.view.getGraphBounds();\n    if (bounds.width > 0 && bounds.height > 0) {\n      if (keepOrigin && bounds.x != null && bounds.y != null) {\n        bounds = bounds.clone();\n        bounds.width += bounds.x;\n        bounds.height += bounds.y;\n        bounds.x = 0;\n        bounds.y = 0;\n      }\n\n      // LATER: Use unscaled bounding boxes to fix rounding errors\n      var s = this.view.scale;\n      var w2 = bounds.width / s;\n      var h2 = bounds.height / s;\n\n      // Fits to the size of the background image if required\n      if (this.backgroundImage != null) {\n        w2 = Math.max(w2, this.backgroundImage.width - bounds.x / s);\n        h2 = Math.max(h2, this.backgroundImage.height - bounds.y / s);\n      }\n      var b = (keepOrigin ? border : 2 * border) + margin;\n      w1 -= b;\n      h1 -= b;\n      var s2 = ignoreWidth ? h1 / h2 : ignoreHeight ? w1 / w2 : Math.min(w1 / w2, h1 / h2);\n      if (this.minFitScale != null) {\n        s2 = Math.max(s2, this.minFitScale);\n      }\n      if (this.maxFitScale != null) {\n        s2 = Math.min(s2, this.maxFitScale);\n      }\n      if (enabled) {\n        if (!keepOrigin) {\n          if (!_mxUtils[\"default\"].hasScrollbars(this.container)) {\n            var x0 = bounds.x != null ? Math.floor(this.view.translate.x - bounds.x / s + border / s2 + margin / 2) : border;\n            var y0 = bounds.y != null ? Math.floor(this.view.translate.y - bounds.y / s + border / s2 + margin / 2) : border;\n            this.view.scaleAndTranslate(s2, x0, y0);\n          } else {\n            this.view.setScale(s2);\n            var b2 = this.getGraphBounds();\n            if (b2.x != null) {\n              this.container.scrollLeft = b2.x;\n            }\n            if (b2.y != null) {\n              this.container.scrollTop = b2.y;\n            }\n          }\n        } else if (this.view.scale != s2) {\n          this.view.setScale(s2);\n        }\n      } else {\n        return s2;\n      }\n    }\n  }\n  return this.view.scale;\n};\n\n/**\r\n * Function: sizeDidChange\r\n *\r\n * Called when the size of the graph has changed. This implementation fires\r\n * a <size> event after updating the clipping region of the SVG element in\r\n * SVG-bases browsers.\r\n */\nmxGraph.prototype.sizeDidChange = function () {\n  var bounds = this.getGraphBounds();\n  if (this.container != null) {\n    var border = this.getBorder();\n    var width = Math.max(0, bounds.x + bounds.width + border);\n    var height = Math.max(0, bounds.y + bounds.height + border);\n    if (this.minimumContainerSize != null) {\n      width = Math.max(width, this.minimumContainerSize.width);\n      height = Math.max(height, this.minimumContainerSize.height);\n    }\n    if (this.resizeContainer) {\n      this.doResizeContainer(width, height);\n    }\n    if (this.preferPageSize || !_mxClient[\"default\"].IS_IE && this.pageVisible) {\n      var size = this.getPreferredPageSize(bounds, width, height);\n      if (size != null) {\n        width = size.width * this.view.scale;\n        height = size.height * this.view.scale;\n      }\n    }\n    if (this.minimumGraphSize != null) {\n      width = Math.max(width, this.minimumGraphSize.width * this.view.scale);\n      height = Math.max(height, this.minimumGraphSize.height * this.view.scale);\n    }\n    width = Math.ceil(width);\n    height = Math.ceil(height);\n    if (this.dialect == _mxConstants[\"default\"].DIALECT_SVG) {\n      var root = this.view.getDrawPane().ownerSVGElement;\n      root.style.minWidth = Math.max(1, width) + 'px';\n      root.style.minHeight = Math.max(1, height) + 'px';\n      root.style.width = '100%';\n      root.style.height = '100%';\n    } else {\n      if (_mxClient[\"default\"].IS_QUIRKS) {\n        // Quirks mode has no minWidth/minHeight support\n        this.view.updateHtmlCanvasSize(Math.max(1, width), Math.max(1, height));\n      } else {\n        this.view.canvas.style.minWidth = Math.max(1, width) + 'px';\n        this.view.canvas.style.minHeight = Math.max(1, height) + 'px';\n      }\n    }\n    this.updatePageBreaks(this.pageBreaksVisible, width, height);\n  }\n  this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].SIZE, 'bounds', bounds));\n};\n\n/**\r\n * Function: doResizeContainer\r\n *\r\n * Resizes the container for the given graph width and height.\r\n */\nmxGraph.prototype.doResizeContainer = function (width, height) {\n  if (this.maximumContainerSize != null) {\n    width = Math.min(this.maximumContainerSize.width, width);\n    height = Math.min(this.maximumContainerSize.height, height);\n  }\n  this.container.style.width = Math.ceil(width) + 'px';\n  this.container.style.height = Math.ceil(height) + 'px';\n};\n\n/**\r\n * Function: updatePageBreaks\r\n *\r\n * Invokes from <sizeDidChange> to redraw the page breaks.\r\n *\r\n * Parameters:\r\n *\r\n * visible - Boolean that specifies if page breaks should be shown.\r\n * width - Specifies the width of the container in pixels.\r\n * height - Specifies the height of the container in pixels.\r\n */\nmxGraph.prototype.updatePageBreaks = function (visible, width, height) {\n  var scale = this.view.scale;\n  var tr = this.view.translate;\n  var fmt = this.pageFormat;\n  var ps = scale * this.pageScale;\n  var bounds = new _mxRectangle[\"default\"](0, 0, fmt.width * ps, fmt.height * ps);\n  var gb = _mxRectangle[\"default\"].fromRectangle(this.getGraphBounds());\n  bounds.x = Math.floor((gb.x - tr.x * scale) / bounds.width) * bounds.width + tr.x * scale;\n  bounds.y = Math.floor((gb.y - tr.y * scale) / bounds.height) * bounds.height + tr.y * scale;\n  gb.width = Math.ceil((gb.width + (gb.x - bounds.x)) / bounds.width) * bounds.width;\n  gb.height = Math.ceil((gb.height + (gb.y - bounds.y)) / bounds.height) * bounds.height;\n\n  // Does not show page breaks if the scale is too small\n  visible = visible && Math.min(bounds.width, bounds.height) > this.minPageBreakDist;\n  var horizontalCount = visible ? Math.ceil(gb.width / bounds.width) + 1 : 0;\n  var verticalCount = visible ? Math.ceil(gb.height / bounds.height) + 1 : 0;\n  var right = (horizontalCount - 1) * bounds.width;\n  var bottom = (verticalCount - 1) * bounds.height;\n  if (this.horizontalPageBreaks == null && horizontalCount > 0) {\n    this.horizontalPageBreaks = [];\n  }\n  if (this.verticalPageBreaks == null && verticalCount > 0) {\n    this.verticalPageBreaks = [];\n  }\n  var drawPageBreaks = _mxGraphUtils[\"default\"].bind(this, function (breaks) {\n    if (breaks != null) {\n      var count = breaks == this.horizontalPageBreaks ? horizontalCount : verticalCount;\n      for (var i = 0; i <= count; i++) {\n        var pts = breaks == this.horizontalPageBreaks ? [new _mxPoint[\"default\"](bounds.x + i * bounds.width, bounds.y), new _mxPoint[\"default\"](bounds.x + i * bounds.width, bounds.y + bottom)] : [new _mxPoint[\"default\"](bounds.x, bounds.y + i * bounds.height), new _mxPoint[\"default\"](bounds.x + right, bounds.y + i * bounds.height)];\n        if (breaks[i] != null) {\n          breaks[i].points = pts;\n          breaks[i].redraw();\n        } else {\n          var pageBreak = new _mxPolyline[\"default\"](pts, this.pageBreakColor);\n          pageBreak.dialect = this.dialect;\n          pageBreak.pointerEvents = false;\n          pageBreak.isDashed = this.pageBreakDashed;\n          pageBreak.init(this.view.backgroundPane);\n          pageBreak.redraw();\n          breaks[i] = pageBreak;\n        }\n      }\n      for (var i = count; i < breaks.length; i++) {\n        breaks[i].destroy();\n      }\n      breaks.splice(count, breaks.length - count);\n    }\n  });\n  drawPageBreaks(this.horizontalPageBreaks);\n  drawPageBreaks(this.verticalPageBreaks);\n};\n\n/**\r\n * Group: Cell styles\r\n */\n\n/**\r\n * Function: getCellStyle\r\n *\r\n * Returns an array of key, value pairs representing the cell style for the\r\n * given cell. If no string is defined in the model that specifies the\r\n * style, then the default style for the cell is returned or <EMPTY_ARRAY>,\r\n * if not style can be found. Note: You should try and get the cell state\r\n * for the given cell and use the cached style in the state before using\r\n * this method.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose style should be returned as an array.\r\n */\nmxGraph.prototype.getCellStyle = function (cell) {\n  var stylename = this.model.getStyle(cell);\n  var style = null;\n\n  // Gets the default style for the cell\n  if (this.model.isEdge(cell)) {\n    style = this.stylesheet.getDefaultEdgeStyle();\n  } else {\n    style = this.stylesheet.getDefaultVertexStyle();\n  }\n\n  // Resolves the stylename using the above as the default\n  if (stylename != null) {\n    style = this.postProcessCellStyle(this.stylesheet.getCellStyle(stylename, style));\n  }\n\n  // Returns a non-null value if no style can be found\n  if (style == null) {\n    style = mxGraph.prototype.EMPTY_ARRAY;\n  }\n  return style;\n};\n\n/**\r\n * Function: postProcessCellStyle\r\n *\r\n * Tries to resolve the value for the image style in the image bundles and\r\n * turns short data URIs as defined in mxImageBundle to data URIs as\r\n * defined in RFC 2397 of the IETF.\r\n */\nmxGraph.prototype.postProcessCellStyle = function (style) {\n  if (style != null) {\n    var key = style[_mxConstants[\"default\"].STYLE_IMAGE];\n    var image = this.getImageFromBundles(key);\n    if (image != null) {\n      style[_mxConstants[\"default\"].STYLE_IMAGE] = image;\n    } else {\n      image = key;\n    }\n\n    // Converts short data uris to normal data uris\n    if (image != null && image.substring(0, 11) == 'data:image/') {\n      if (image.substring(0, 20) == 'data:image/svg+xml,<') {\n        // Required for FF and IE11\n        image = image.substring(0, 19) + encodeURIComponent(image.substring(19));\n      } else if (image.substring(0, 22) != 'data:image/svg+xml,%3C') {\n        var comma = image.indexOf(',');\n\n        // Adds base64 encoding prefix if needed\n        if (comma > 0 && image.substring(comma - 7, comma + 1) != ';base64,') {\n          image = image.substring(0, comma) + ';base64,' + image.substring(comma + 1);\n        }\n      }\n      style[_mxConstants[\"default\"].STYLE_IMAGE] = image;\n    }\n  }\n  return style;\n};\n\n/**\r\n * Function: setCellStyle\r\n *\r\n * Sets the style of the specified cells. If no cells are given, then the\r\n * selection cells are changed.\r\n *\r\n * Parameters:\r\n *\r\n * style - String representing the new style of the cells.\r\n * cells - Optional array of <mxCells> to set the style for. Default is the\r\n * selection cells.\r\n */\nmxGraph.prototype.setCellStyle = function (style, cells) {\n  cells = cells || this.getSelectionCells();\n  if (cells != null) {\n    this.model.beginUpdate();\n    try {\n      for (var i = 0; i < cells.length; i++) {\n        this.model.setStyle(cells[i], style);\n      }\n    } finally {\n      this.model.endUpdate();\n    }\n  }\n};\n\n/**\r\n * Function: toggleCellStyle\r\n *\r\n * Toggles the boolean value for the given key in the style of the given cell\r\n * and returns the new value as 0 or 1. If no cell is specified then the\r\n * selection cell is used.\r\n *\r\n * Parameter:\r\n *\r\n * key - String representing the key for the boolean value to be toggled.\r\n * defaultValue - Optional boolean default value if no value is defined.\r\n * Default is false.\r\n * cell - Optional <mxCell> whose style should be modified. Default is\r\n * the selection cell.\r\n */\nmxGraph.prototype.toggleCellStyle = function (key, defaultValue, cell) {\n  cell = cell || this.getSelectionCell();\n  return this.toggleCellStyles(key, defaultValue, [cell]);\n};\n\n/**\r\n * Function: toggleCellStyles\r\n *\r\n * Toggles the boolean value for the given key in the style of the given cells\r\n * and returns the new value as 0 or 1. If no cells are specified, then the\r\n * selection cells are used. For example, this can be used to toggle\r\n * <mxConstants.STYLE_ROUNDED> or any other style with a boolean value.\r\n *\r\n * Parameter:\r\n *\r\n * key - String representing the key for the boolean value to be toggled.\r\n * defaultValue - Optional boolean default value if no value is defined.\r\n * Default is false.\r\n * cells - Optional array of <mxCells> whose styles should be modified.\r\n * Default is the selection cells.\r\n */\nmxGraph.prototype.toggleCellStyles = function (key, defaultValue, cells) {\n  defaultValue = defaultValue != null ? defaultValue : false;\n  cells = cells || this.getSelectionCells();\n  var value = null;\n  if (cells != null && cells.length > 0) {\n    var state = this.view.getState(cells[0]);\n    var style = state != null ? state.style : this.getCellStyle(cells[0]);\n    if (style != null) {\n      value = _mxGraphUtils[\"default\"].getValue(style, key, defaultValue) ? 0 : 1;\n      this.setCellStyles(key, value, cells);\n    }\n  }\n  return value;\n};\n\n/**\r\n * Function: setCellStyles\r\n *\r\n * Sets the key to value in the styles of the given cells. This will modify\r\n * the existing cell styles in-place and override any existing assignment\r\n * for the given key. If no cells are specified, then the selection cells\r\n * are changed. If no value is specified, then the respective key is\r\n * removed from the styles.\r\n *\r\n * Parameters:\r\n *\r\n * key - String representing the key to be assigned.\r\n * value - String representing the new value for the key.\r\n * cells - Optional array of <mxCells> to change the style for. Default is\r\n * the selection cells.\r\n */\nmxGraph.prototype.setCellStyles = function (key, value, cells) {\n  cells = cells || this.getSelectionCells();\n  _mxUtils[\"default\"].setCellStyles(this.model, cells, key, value);\n};\n\n/**\r\n * Function: toggleCellStyleFlags\r\n *\r\n * Toggles the given bit for the given key in the styles of the specified\r\n * cells.\r\n *\r\n * Parameters:\r\n *\r\n * key - String representing the key to toggle the flag in.\r\n * flag - Integer that represents the bit to be toggled.\r\n * cells - Optional array of <mxCells> to change the style for. Default is\r\n * the selection cells.\r\n */\nmxGraph.prototype.toggleCellStyleFlags = function (key, flag, cells) {\n  this.setCellStyleFlags(key, flag, null, cells);\n};\n\n/**\r\n * Function: setCellStyleFlags\r\n *\r\n * Sets or toggles the given bit for the given key in the styles of the\r\n * specified cells.\r\n *\r\n * Parameters:\r\n *\r\n * key - String representing the key to toggle the flag in.\r\n * flag - Integer that represents the bit to be toggled.\r\n * value - Boolean value to be used or null if the value should be toggled.\r\n * cells - Optional array of <mxCells> to change the style for. Default is\r\n * the selection cells.\r\n */\nmxGraph.prototype.setCellStyleFlags = function (key, flag, value, cells) {\n  cells = cells || this.getSelectionCells();\n  if (cells != null && cells.length > 0) {\n    if (value == null) {\n      var state = this.view.getState(cells[0]);\n      var style = state != null ? state.style : this.getCellStyle(cells[0]);\n      if (style != null) {\n        var current = parseInt(style[key] || 0);\n        value = !((current & flag) == flag);\n      }\n    }\n    _mxUtils[\"default\"].setCellStyleFlags(this.model, cells, key, flag, value);\n  }\n};\n\n/**\r\n * Group: Cell alignment and orientation\r\n */\n\n/**\r\n * Function: alignCells\r\n *\r\n * Aligns the given cells vertically or horizontally according to the given\r\n * alignment using the optional parameter as the coordinate.\r\n *\r\n * Parameters:\r\n *\r\n * align - Specifies the alignment. Possible values are all constants in\r\n * mxConstants with an ALIGN prefix.\r\n * cells - Array of <mxCells> to be aligned.\r\n * param - Optional coordinate for the alignment.\r\n */\nmxGraph.prototype.alignCells = function (align, cells, param) {\n  if (cells == null) {\n    cells = this.getSelectionCells();\n  }\n  if (cells != null && cells.length > 1) {\n    // Finds the required coordinate for the alignment\n    if (param == null) {\n      for (var i = 0; i < cells.length; i++) {\n        var state = this.view.getState(cells[i]);\n        if (state != null && !this.model.isEdge(cells[i])) {\n          if (param == null) {\n            if (align == _mxConstants[\"default\"].ALIGN_CENTER) {\n              param = state.x + state.width / 2;\n              break;\n            } else if (align == _mxConstants[\"default\"].ALIGN_RIGHT) {\n              param = state.x + state.width;\n            } else if (align == _mxConstants[\"default\"].ALIGN_TOP) {\n              param = state.y;\n            } else if (align == _mxConstants[\"default\"].ALIGN_MIDDLE) {\n              param = state.y + state.height / 2;\n              break;\n            } else if (align == _mxConstants[\"default\"].ALIGN_BOTTOM) {\n              param = state.y + state.height;\n            } else {\n              param = state.x;\n            }\n          } else {\n            if (align == _mxConstants[\"default\"].ALIGN_RIGHT) {\n              param = Math.max(param, state.x + state.width);\n            } else if (align == _mxConstants[\"default\"].ALIGN_TOP) {\n              param = Math.min(param, state.y);\n            } else if (align == _mxConstants[\"default\"].ALIGN_BOTTOM) {\n              param = Math.max(param, state.y + state.height);\n            } else {\n              param = Math.min(param, state.x);\n            }\n          }\n        }\n      }\n    }\n\n    // Aligns the cells to the coordinate\n    if (param != null) {\n      var s = this.view.scale;\n      this.model.beginUpdate();\n      try {\n        for (var i = 0; i < cells.length; i++) {\n          var state = this.view.getState(cells[i]);\n          if (state != null) {\n            var geo = this.getCellGeometry(cells[i]);\n            if (geo != null && !this.model.isEdge(cells[i])) {\n              geo = geo.clone();\n              if (align == _mxConstants[\"default\"].ALIGN_CENTER) {\n                geo.x += (param - state.x - state.width / 2) / s;\n              } else if (align == _mxConstants[\"default\"].ALIGN_RIGHT) {\n                geo.x += (param - state.x - state.width) / s;\n              } else if (align == _mxConstants[\"default\"].ALIGN_TOP) {\n                geo.y += (param - state.y) / s;\n              } else if (align == _mxConstants[\"default\"].ALIGN_MIDDLE) {\n                geo.y += (param - state.y - state.height / 2) / s;\n              } else if (align == _mxConstants[\"default\"].ALIGN_BOTTOM) {\n                geo.y += (param - state.y - state.height) / s;\n              } else {\n                geo.x += (param - state.x) / s;\n              }\n              this.resizeCell(cells[i], geo);\n            }\n          }\n        }\n        this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].ALIGN_CELLS, 'align', align, 'cells', cells));\n      } finally {\n        this.model.endUpdate();\n      }\n    }\n  }\n  return cells;\n};\n\n/**\r\n * Function: flipEdge\r\n *\r\n * Toggles the style of the given edge between null (or empty) and\r\n * <alternateEdgeStyle>. This method fires <mxEvent.FLIP_EDGE> while the\r\n * transaction is in progress. Returns the edge that was flipped.\r\n *\r\n * Here is an example that overrides this implementation to invert the\r\n * value of <mxConstants.STYLE_ELBOW> without removing any existing styles.\r\n *\r\n * (code)\r\n * graph.flipEdge = function(edge)\r\n * {\r\n *   if (edge != null)\r\n *   {\r\n *     var state = this.view.getState(edge);\r\n *     var style = (state != null) ? state.style : this.getCellStyle(edge);\r\n *\r\n *     if (style != null)\r\n *     {\r\n *       var elbow = mxGraphUtils.getValue(style, mxConstants.STYLE_ELBOW,\r\n *           mxConstants.ELBOW_HORIZONTAL);\r\n *       var value = (elbow == mxConstants.ELBOW_HORIZONTAL) ?\r\n *           mxConstants.ELBOW_VERTICAL : mxConstants.ELBOW_HORIZONTAL;\r\n *       this.setCellStyles(mxConstants.STYLE_ELBOW, value, [edge]);\r\n *     }\r\n *   }\r\n * };\r\n * (end)\r\n *\r\n * Parameters:\r\n *\r\n * edge - <mxCell> whose style should be changed.\r\n */\nmxGraph.prototype.flipEdge = function (edge) {\n  if (edge != null && this.alternateEdgeStyle != null) {\n    this.model.beginUpdate();\n    try {\n      var style = this.model.getStyle(edge);\n      if (style == null || style.length == 0) {\n        this.model.setStyle(edge, this.alternateEdgeStyle);\n      } else {\n        this.model.setStyle(edge, null);\n      }\n\n      // Removes all existing control points\n      this.resetEdge(edge);\n      this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].FLIP_EDGE, 'edge', edge));\n    } finally {\n      this.model.endUpdate();\n    }\n  }\n  return edge;\n};\n\n/**\r\n * Function: addImageBundle\r\n *\r\n * Adds the specified <mxImageBundle>.\r\n */\nmxGraph.prototype.addImageBundle = function (bundle) {\n  this.imageBundles.push(bundle);\n};\n\n/**\r\n * Function: removeImageBundle\r\n *\r\n * Removes the specified <mxImageBundle>.\r\n */\nmxGraph.prototype.removeImageBundle = function (bundle) {\n  var tmp = [];\n  for (var i = 0; i < this.imageBundles.length; i++) {\n    if (this.imageBundles[i] != bundle) {\n      tmp.push(this.imageBundles[i]);\n    }\n  }\n  this.imageBundles = tmp;\n};\n\n/**\r\n * Function: getImageFromBundles\r\n *\r\n * Searches all <imageBundles> for the specified key and returns the value\r\n * for the first match or null if the key is not found.\r\n */\nmxGraph.prototype.getImageFromBundles = function (key) {\n  if (key != null) {\n    for (var i = 0; i < this.imageBundles.length; i++) {\n      var image = this.imageBundles[i].getImage(key);\n      if (image != null) {\n        return image;\n      }\n    }\n  }\n  return null;\n};\n\n/**\r\n * Group: Order\r\n */\n\n/**\r\n * Function: orderCells\r\n *\r\n * Moves the given cells to the front or back. The change is carried out\r\n * using <cellsOrdered>. This method fires <mxEvent.ORDER_CELLS> while the\r\n * transaction is in progress.\r\n *\r\n * Parameters:\r\n *\r\n * back - Boolean that specifies if the cells should be moved to back.\r\n * cells - Array of <mxCells> to move to the background. If null is\r\n * specified then the selection cells are used.\r\n */\nmxGraph.prototype.orderCells = function (back, cells) {\n  if (cells == null) {\n    cells = _mxUtils[\"default\"].sortCells(this.getSelectionCells(), true);\n  }\n  this.model.beginUpdate();\n  try {\n    this.cellsOrdered(cells, back);\n    this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].ORDER_CELLS, 'back', back, 'cells', cells));\n  } finally {\n    this.model.endUpdate();\n  }\n  return cells;\n};\n\n/**\r\n * Function: cellsOrdered\r\n *\r\n * Moves the given cells to the front or back. This method fires\r\n * <mxEvent.CELLS_ORDERED> while the transaction is in progress.\r\n *\r\n * Parameters:\r\n *\r\n * cells - Array of <mxCells> whose order should be changed.\r\n * back - Boolean that specifies if the cells should be moved to back.\r\n */\nmxGraph.prototype.cellsOrdered = function (cells, back) {\n  if (cells != null) {\n    this.model.beginUpdate();\n    try {\n      for (var i = 0; i < cells.length; i++) {\n        var parent = this.model.getParent(cells[i]);\n        if (back) {\n          this.model.add(parent, cells[i], i);\n        } else {\n          this.model.add(parent, cells[i], this.model.getChildCount(parent) - 1);\n        }\n      }\n      this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].CELLS_ORDERED, 'back', back, 'cells', cells));\n    } finally {\n      this.model.endUpdate();\n    }\n  }\n};\n\n/**\r\n * Group: Grouping\r\n */\n\n/**\r\n * Function: groupCells\r\n *\r\n * Adds the cells into the given group. The change is carried out using\r\n * <cellsAdded>, <cellsMoved> and <cellsResized>. This method fires\r\n * <mxEvent.GROUP_CELLS> while the transaction is in progress. Returns the\r\n * new group. A group is only created if there is at least one entry in the\r\n * given array of cells.\r\n *\r\n * Parameters:\r\n *\r\n * group - <mxCell> that represents the target group. If null is specified\r\n * then a new group is created using <createGroupCell>.\r\n * border - Optional integer that specifies the border between the child\r\n * area and the group bounds. Default is 0.\r\n * cells - Optional array of <mxCells> to be grouped. If null is specified\r\n * then the selection cells are used.\r\n */\nmxGraph.prototype.groupCells = function (group, border, cells) {\n  if (cells == null) {\n    cells = _mxUtils[\"default\"].sortCells(this.getSelectionCells(), true);\n  }\n  cells = this.getCellsForGroup(cells);\n  if (group == null) {\n    group = this.createGroupCell(cells);\n  }\n  var bounds = this.getBoundsForGroup(group, cells, border);\n  if (cells.length > 0 && bounds != null) {\n    // Uses parent of group or previous parent of first child\n    var parent = this.model.getParent(group);\n    if (parent == null) {\n      parent = this.model.getParent(cells[0]);\n    }\n    this.model.beginUpdate();\n    try {\n      // Checks if the group has a geometry and\n      // creates one if one does not exist\n      if (this.getCellGeometry(group) == null) {\n        this.model.setGeometry(group, new _mxGeometry[\"default\"]());\n      }\n\n      // Adds the group into the parent\n      var index = this.model.getChildCount(parent);\n      this.cellsAdded([group], parent, index, null, null, false);\n\n      // Adds the children into the group and moves\n      index = this.model.getChildCount(group);\n      this.cellsAdded(cells, group, index, null, null, false, false);\n      this.cellsMoved(cells, -bounds.x, -bounds.y, false, true);\n\n      // Resizes the group\n      this.cellsResized([group], [bounds], false);\n      this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].GROUP_CELLS, 'group', group, 'border', border, 'cells', cells));\n    } finally {\n      this.model.endUpdate();\n    }\n  }\n  return group;\n};\n\n/**\r\n * Function: getCellsForGroup\r\n *\r\n * Returns the cells with the same parent as the first cell\r\n * in the given array.\r\n */\nmxGraph.prototype.getCellsForGroup = function (cells) {\n  var result = [];\n  if (cells != null && cells.length > 0) {\n    var parent = this.model.getParent(cells[0]);\n    result.push(cells[0]);\n\n    // Filters selection cells with the same parent\n    for (var i = 1; i < cells.length; i++) {\n      if (this.model.getParent(cells[i]) == parent) {\n        result.push(cells[i]);\n      }\n    }\n  }\n  return result;\n};\n\n/**\r\n * Function: getBoundsForGroup\r\n *\r\n * Returns the bounds to be used for the given group and children.\r\n */\nmxGraph.prototype.getBoundsForGroup = function (group, children, border) {\n  var result = this.getBoundingBoxFromGeometry(children, true);\n  if (result != null) {\n    if (this.isSwimlane(group)) {\n      var size = this.getStartSize(group);\n      result.x -= size.width;\n      result.y -= size.height;\n      result.width += size.width;\n      result.height += size.height;\n    }\n\n    // Adds the border\n    if (border != null) {\n      result.x -= border;\n      result.y -= border;\n      result.width += 2 * border;\n      result.height += 2 * border;\n    }\n  }\n  return result;\n};\n\n/**\r\n * Function: createGroupCell\r\n *\r\n * Hook for creating the group cell to hold the given array of <mxCells> if\r\n * no group cell was given to the <group> function.\r\n *\r\n * The following code can be used to set the style of new group cells.\r\n *\r\n * (code)\r\n * var graphCreateGroupCell = graph.createGroupCell;\r\n * graph.createGroupCell = function(cells)\r\n * {\r\n *   var group = graphCreateGroupCell.apply(this, arguments);\r\n *   group.setStyle('group');\r\n *\r\n *   return group;\r\n * };\r\n */\nmxGraph.prototype.createGroupCell = function (cells) {\n  var group = new _mxCell[\"default\"]('');\n  group.setVertex(true);\n  group.setConnectable(false);\n  return group;\n};\n\n/**\r\n * Function: ungroupCells\r\n *\r\n * Ungroups the given cells by moving the children the children to their\r\n * parents parent and removing the empty groups. Returns the children that\r\n * have been removed from the groups.\r\n *\r\n * Parameters:\r\n *\r\n * cells - Array of cells to be ungrouped. If null is specified then the\r\n * selection cells are used.\r\n */\nmxGraph.prototype.ungroupCells = function (cells) {\n  var result = [];\n  if (cells == null) {\n    cells = this.getSelectionCells();\n\n    // Finds the cells with children\n    var tmp = [];\n    for (var i = 0; i < cells.length; i++) {\n      if (this.model.getChildCount(cells[i]) > 0) {\n        tmp.push(cells[i]);\n      }\n    }\n    cells = tmp;\n  }\n  if (cells != null && cells.length > 0) {\n    this.model.beginUpdate();\n    try {\n      for (var i = 0; i < cells.length; i++) {\n        var children = this.model.getChildren(cells[i]);\n        if (children != null && children.length > 0) {\n          children = children.slice();\n          var parent = this.model.getParent(cells[i]);\n          var index = this.model.getChildCount(parent);\n          this.cellsAdded(children, parent, index, null, null, true);\n          result = result.concat(children);\n        }\n      }\n      this.removeCellsAfterUngroup(cells);\n      this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].UNGROUP_CELLS, 'cells', cells));\n    } finally {\n      this.model.endUpdate();\n    }\n  }\n  return result;\n};\n\n/**\r\n * Function: removeCellsAfterUngroup\r\n *\r\n * Hook to remove the groups after <ungroupCells>.\r\n *\r\n * Parameters:\r\n *\r\n * cells - Array of <mxCells> that were ungrouped.\r\n */\nmxGraph.prototype.removeCellsAfterUngroup = function (cells) {\n  this.cellsRemoved(this.addAllEdges(cells));\n};\n\n/**\r\n * Function: removeCellsFromParent\r\n *\r\n * Removes the specified cells from their parents and adds them to the\r\n * default parent. Returns the cells that were removed from their parents.\r\n *\r\n * Parameters:\r\n *\r\n * cells - Array of <mxCells> to be removed from their parents.\r\n */\nmxGraph.prototype.removeCellsFromParent = function (cells) {\n  if (cells == null) {\n    cells = this.getSelectionCells();\n  }\n  this.model.beginUpdate();\n  try {\n    var parent = this.getDefaultParent();\n    var index = this.model.getChildCount(parent);\n    this.cellsAdded(cells, parent, index, null, null, true);\n    this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].REMOVE_CELLS_FROM_PARENT, 'cells', cells));\n  } finally {\n    this.model.endUpdate();\n  }\n  return cells;\n};\n\n/**\r\n * Function: updateGroupBounds\r\n *\r\n * Updates the bounds of the given groups to include all children and returns\r\n * the passed-in cells. Call this with the groups in parent to child order,\r\n * top-most group first, the cells are processed in reverse order and cells\r\n * with no children are ignored.\r\n *\r\n * Parameters:\r\n *\r\n * cells - The groups whose bounds should be updated. If this is null, then\r\n * the selection cells are used.\r\n * border - Optional border to be added in the group. Default is 0.\r\n * moveGroup - Optional boolean that allows the group to be moved. Default\r\n * is false.\r\n * topBorder - Optional top border to be added in the group. Default is 0.\r\n * rightBorder - Optional top border to be added in the group. Default is 0.\r\n * bottomBorder - Optional top border to be added in the group. Default is 0.\r\n * leftBorder - Optional top border to be added in the group. Default is 0.\r\n */\nmxGraph.prototype.updateGroupBounds = function (cells, border, moveGroup, topBorder, rightBorder, bottomBorder, leftBorder) {\n  if (cells == null) {\n    cells = this.getSelectionCells();\n  }\n  border = border != null ? border : 0;\n  moveGroup = moveGroup != null ? moveGroup : false;\n  topBorder = topBorder != null ? topBorder : 0;\n  rightBorder = rightBorder != null ? rightBorder : 0;\n  bottomBorder = bottomBorder != null ? bottomBorder : 0;\n  leftBorder = leftBorder != null ? leftBorder : 0;\n  this.model.beginUpdate();\n  try {\n    for (var i = cells.length - 1; i >= 0; i--) {\n      var geo = this.getCellGeometry(cells[i]);\n      if (geo != null) {\n        var children = this.getChildCells(cells[i]);\n        if (children != null && children.length > 0) {\n          var bounds = this.getBoundingBoxFromGeometry(children, true);\n          if (bounds != null && bounds.width > 0 && bounds.height > 0) {\n            var left = 0;\n            var top = 0;\n\n            // Adds the size of the title area for swimlanes\n            if (this.isSwimlane(cells[i])) {\n              var size = this.getStartSize(cells[i]);\n              left = size.width;\n              top = size.height;\n            }\n            geo = geo.clone();\n            if (moveGroup) {\n              geo.x = Math.round(geo.x + bounds.x - border - left - leftBorder);\n              geo.y = Math.round(geo.y + bounds.y - border - top - topBorder);\n            }\n            geo.width = Math.round(bounds.width + 2 * border + left + leftBorder + rightBorder);\n            geo.height = Math.round(bounds.height + 2 * border + top + topBorder + bottomBorder);\n            this.model.setGeometry(cells[i], geo);\n            this.moveCells(children, border + left - bounds.x + leftBorder, border + top - bounds.y + topBorder);\n          }\n        }\n      }\n    }\n  } finally {\n    this.model.endUpdate();\n  }\n  return cells;\n};\n\n/**\r\n * Function: getBoundingBox\r\n *\r\n * Returns the bounding box for the given array of <mxCells>. The bounding box for\r\n * each cell and its descendants is computed using <mxGraphView.getBoundingBox>.\r\n *\r\n * Parameters:\r\n *\r\n * cells - Array of <mxCells> whose bounding box should be returned.\r\n */\nmxGraph.prototype.getBoundingBox = function (cells) {\n  var result = null;\n  if (cells != null && cells.length > 0) {\n    for (var i = 0; i < cells.length; i++) {\n      if (this.model.isVertex(cells[i]) || this.model.isEdge(cells[i])) {\n        var bbox = this.view.getBoundingBox(this.view.getState(cells[i]), true);\n        if (bbox != null) {\n          if (result == null) {\n            result = _mxRectangle[\"default\"].fromRectangle(bbox);\n          } else {\n            result.add(bbox);\n          }\n        }\n      }\n    }\n  }\n  return result;\n};\n\n/**\r\n * Group: Cell cloning, insertion and removal\r\n */\n\n/**\r\n * Function: cloneCells\r\n *\r\n * Returns the clones for the given cells. The clones are created recursively\r\n * using <mxGraphModel.cloneCells>. If the terminal of an edge is not in the\r\n * given array, then the respective end is assigned a terminal point and the\r\n * terminal is removed.\r\n *\r\n * Parameters:\r\n *\r\n * cells - Array of <mxCells> to be cloned.\r\n * allowInvalidEdges - Optional boolean that specifies if invalid edges\r\n * should be cloned. Default is true.\r\n * mapping - Optional mapping for existing clones.\r\n */\nmxGraph.prototype.cloneCells = function (cells, allowInvalidEdges, mapping) {\n  allowInvalidEdges = allowInvalidEdges != null ? allowInvalidEdges : true;\n  var clones = null;\n  if (cells != null) {\n    // Creates a dictionary for fast lookups\n    var dict = new _mxDictionary[\"default\"]();\n    var tmp = [];\n    for (var i = 0; i < cells.length; i++) {\n      dict.put(cells[i], true);\n      tmp.push(cells[i]);\n    }\n    if (tmp.length > 0) {\n      var scale = this.view.scale;\n      var trans = this.view.translate;\n      clones = this.model.cloneCells(cells, true, mapping);\n      for (var i = 0; i < cells.length; i++) {\n        if (!allowInvalidEdges && this.model.isEdge(clones[i]) && this.getEdgeValidationError(clones[i], this.model.getTerminal(clones[i], true), this.model.getTerminal(clones[i], false)) != null) {\n          clones[i] = null;\n        } else {\n          var g = this.model.getGeometry(clones[i]);\n          if (g != null) {\n            var state = this.view.getState(cells[i]);\n            var pstate = this.view.getState(this.model.getParent(cells[i]));\n            if (state != null && pstate != null) {\n              var dx = pstate.origin.x;\n              var dy = pstate.origin.y;\n              if (this.model.isEdge(clones[i])) {\n                var pts = state.absolutePoints;\n\n                // Checks if the source is cloned or sets the terminal point\n                var src = this.model.getTerminal(cells[i], true);\n                while (src != null && !dict.get(src)) {\n                  src = this.model.getParent(src);\n                }\n                if (src == null) {\n                  g.setTerminalPoint(new _mxPoint[\"default\"](pts[0].x / scale - trans.x, pts[0].y / scale - trans.y), true);\n                }\n\n                // Checks if the target is cloned or sets the terminal point\n                var trg = this.model.getTerminal(cells[i], false);\n                while (trg != null && !dict.get(trg)) {\n                  trg = this.model.getParent(trg);\n                }\n                if (trg == null) {\n                  var n = pts.length - 1;\n                  g.setTerminalPoint(new _mxPoint[\"default\"](pts[n].x / scale - trans.x, pts[n].y / scale - trans.y), false);\n                }\n\n                // Translates the control points\n                var points = g.points;\n                if (points != null) {\n                  for (var j = 0; j < points.length; j++) {\n                    points[j].x += dx;\n                    points[j].y += dy;\n                  }\n                }\n              } else {\n                g.translate(dx, dy);\n              }\n            }\n          }\n        }\n      }\n    } else {\n      clones = [];\n    }\n  }\n  return clones;\n};\n\n/**\r\n * Function: insertVertex\r\n *\r\n * Adds a new vertex into the given parent <mxCell> using value as the user\r\n * object and the given coordinates as the <mxGeometry> of the new vertex.\r\n * The id and style are used for the respective properties of the new\r\n * <mxCell>, which is returned.\r\n *\r\n * When adding new vertices from a mouse event, one should take into\r\n * account the offset of the graph container and the scale and translation\r\n * of the view in order to find the correct unscaled, untranslated\r\n * coordinates using <mxGraph.getPointForEvent> as follows:\r\n *\r\n * (code)\r\n * var pt = graph.getPointForEvent(evt);\r\n * var parent = graph.getDefaultParent();\r\n * graph.insertVertex(parent, null,\r\n * \t\t\t'Hello, World!', x, y, 220, 30);\r\n * (end)\r\n *\r\n * For adding image cells, the style parameter can be assigned as\r\n *\r\n * (code)\r\n * stylename;image=imageUrl\r\n * (end)\r\n *\r\n * See <mxGraph> for more information on using images.\r\n *\r\n * Parameters:\r\n *\r\n * parent - <mxCell> that specifies the parent of the new vertex.\r\n * id - Optional string that defines the Id of the new vertex.\r\n * value - Object to be used as the user object.\r\n * x - Integer that defines the x coordinate of the vertex.\r\n * y - Integer that defines the y coordinate of the vertex.\r\n * width - Integer that defines the width of the vertex.\r\n * height - Integer that defines the height of the vertex.\r\n * style - Optional string that defines the cell style.\r\n * relative - Optional boolean that specifies if the geometry is relative.\r\n * Default is false.\r\n */\nmxGraph.prototype.insertVertex = function (parent, id, value, x, y, width, height, style, relative) {\n  var vertex = this.createVertex(parent, id, value, x, y, width, height, style, relative);\n  return this.addCell(vertex, parent);\n};\n\n/**\r\n * Function: createVertex\r\n *\r\n * Hook method that creates the new vertex for <insertVertex>.\r\n */\nmxGraph.prototype.createVertex = function (parent, id, value, x, y, width, height, style, relative) {\n  // Creates the geometry for the vertex\n  var geometry = new _mxGeometry[\"default\"](x, y, width, height);\n  geometry.relative = relative != null ? relative : false;\n\n  // Creates the vertex\n  var vertex = new _mxCell[\"default\"](value, geometry, style);\n  vertex.setId(id);\n  vertex.setVertex(true);\n  vertex.setConnectable(true);\n  return vertex;\n};\n\n/**\r\n * Function: insertEdge\r\n *\r\n * Adds a new edge into the given parent <mxCell> using value as the user\r\n * object and the given source and target as the terminals of the new edge.\r\n * The id and style are used for the respective properties of the new\r\n * <mxCell>, which is returned.\r\n *\r\n * Parameters:\r\n *\r\n * parent - <mxCell> that specifies the parent of the new edge.\r\n * id - Optional string that defines the Id of the new edge.\r\n * value - JavaScript object to be used as the user object.\r\n * source - <mxCell> that defines the source of the edge.\r\n * target - <mxCell> that defines the target of the edge.\r\n * style - Optional string that defines the cell style.\r\n */\nmxGraph.prototype.insertEdge = function (parent, id, value, source, target, style) {\n  var edge = this.createEdge(parent, id, value, source, target, style);\n  return this.addEdge(edge, parent, source, target);\n};\n\n/**\r\n * Function: createEdge\r\n *\r\n * Hook method that creates the new edge for <insertEdge>. This\r\n * implementation does not set the source and target of the edge, these\r\n * are set when the edge is added to the model.\r\n *\r\n */\nmxGraph.prototype.createEdge = function (parent, id, value, source, target, style) {\n  // Creates the edge\n  var edge = new _mxCell[\"default\"](value, new _mxGeometry[\"default\"](), style);\n  edge.setId(id);\n  edge.setEdge(true);\n  edge.geometry.relative = true;\n\n  //TODO (画线) 常量抽取\n  edge.setGroup(\"DesignControl\");\n  edge.setType(\"SequenceFlow\");\n  return edge;\n};\n\n/**\r\n * Function: addEdge\r\n *\r\n * Adds the edge to the parent and connects it to the given source and\r\n * target terminals. This is a shortcut method. Returns the edge that was\r\n * added.\r\n *\r\n * Parameters:\r\n *\r\n * edge - <mxCell> to be inserted into the given parent.\r\n * parent - <mxCell> that represents the new parent. If no parent is\r\n * given then the default parent is used.\r\n * source - Optional <mxCell> that represents the source terminal.\r\n * target - Optional <mxCell> that represents the target terminal.\r\n * index - Optional index to insert the cells at. Default is to append.\r\n */\nmxGraph.prototype.addEdge = function (edge, parent, source, target, index) {\n  return this.addCell(edge, parent, index, source, target);\n};\n\n/**\r\n * Function: addCell\r\n *\r\n * Adds the cell to the parent and connects it to the given source and\r\n * target terminals. This is a shortcut method. Returns the cell that was\r\n * added.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> to be inserted into the given parent.\r\n * parent - <mxCell> that represents the new parent. If no parent is\r\n * given then the default parent is used.\r\n * index - Optional index to insert the cells at. Default is to append.\r\n * source - Optional <mxCell> that represents the source terminal.\r\n * target - Optional <mxCell> that represents the target terminal.\r\n */\nmxGraph.prototype.addCell = function (cell, parent, index, source, target) {\n  return this.addCells([cell], parent, index, source, target)[0];\n};\n\n/**\r\n * Function: addCells\r\n *\r\n * Adds the cells to the parent at the given index, connecting each cell to\r\n * the optional source and target terminal. The change is carried out using\r\n * <cellsAdded>. This method fires <mxEvent.ADD_CELLS> while the\r\n * transaction is in progress. Returns the cells that were added.\r\n *\r\n * Parameters:\r\n *\r\n * cells - Array of <mxCells> to be inserted.\r\n * parent - <mxCell> that represents the new parent. If no parent is\r\n * given then the default parent is used.\r\n * index - Optional index to insert the cells at. Default is to append.\r\n * source - Optional source <mxCell> for all inserted cells.\r\n * target - Optional target <mxCell> for all inserted cells.\r\n */\nmxGraph.prototype.addCells = function (cells, parent, index, source, target) {\n  if (parent == null) {\n    parent = this.getDefaultParent();\n  }\n  if (index == null) {\n    index = this.model.getChildCount(parent);\n  }\n  this.model.beginUpdate();\n  try {\n    this.cellsAdded(cells, parent, index, source, target, false, true);\n    this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].ADD_CELLS, 'cells', cells, 'parent', parent, 'index', index, 'source', source, 'target', target));\n  } finally {\n    this.model.endUpdate();\n  }\n  return cells;\n};\n\n/**\r\n * Function: cellsAdded\r\n *\r\n * Adds the specified cells to the given parent. This method fires\r\n * <mxEvent.CELLS_ADDED> while the transaction is in progress.\r\n */\nmxGraph.prototype.cellsAdded = function (cells, parent, index, source, target, absolute, constrain) {\n  if (cells != null && parent != null && index != null) {\n    this.model.beginUpdate();\n    try {\n      var parentState = absolute ? this.view.getState(parent) : null;\n      var o1 = parentState != null ? parentState.origin : null;\n      var zero = new _mxPoint[\"default\"](0, 0);\n      for (var i = 0; i < cells.length; i++) {\n        if (cells[i] == null) {\n          index--;\n        } else {\n          var previous = this.model.getParent(cells[i]);\n\n          // Keeps the cell at its absolute location\n          if (o1 != null && cells[i] != parent && parent != previous) {\n            var oldState = this.view.getState(previous);\n            var o2 = oldState != null ? oldState.origin : zero;\n            var geo = this.model.getGeometry(cells[i]);\n            if (geo != null) {\n              var dx = o2.x - o1.x;\n              var dy = o2.y - o1.y;\n\n              // FIXME: Cells should always be inserted first before any other edit\n              // to avoid forward references in sessions.\n              geo = geo.clone();\n              geo.translate(dx, dy);\n              if (!geo.relative && this.model.isVertex(cells[i]) && !this.isAllowNegativeCoordinates()) {\n                geo.x = Math.max(0, geo.x);\n                geo.y = Math.max(0, geo.y);\n              }\n              this.model.setGeometry(cells[i], geo);\n            }\n          }\n\n          // Decrements all following indices\n          // if cell is already in parent\n          if (parent == previous && index + i > this.model.getChildCount(parent)) {\n            index--;\n          }\n          this.model.add(parent, cells[i], index + i);\n          if (this.autoSizeCellsOnAdd) {\n            this.autoSizeCell(cells[i], true);\n          }\n\n          // Extends the parent or constrains the child\n          if (this.isExtendParentsOnAdd(cells[i]) && this.isExtendParent(cells[i])) {\n            this.extendParent(cells[i]);\n          }\n\n          // Additionally constrains the child after extending the parent\n          if (constrain == null || constrain) {\n            this.constrainChild(cells[i]);\n          }\n\n          // Sets the source terminal\n          if (source != null) {\n            this.cellConnected(cells[i], source, true);\n          }\n\n          // Sets the target terminal\n          if (target != null) {\n            this.cellConnected(cells[i], target, false);\n          }\n        }\n      }\n      this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].CELLS_ADDED, 'cells', cells, 'parent', parent, 'index', index, 'source', source, 'target', target, 'absolute', absolute));\n    } finally {\n      this.model.endUpdate();\n    }\n  }\n};\n\n/**\r\n * Function: autoSizeCell\r\n *\r\n * Resizes the specified cell to just fit around the its label and/or children\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCells> to be resized.\r\n * recurse - Optional boolean which specifies if all descendants should be\r\n * autosized. Default is true.\r\n */\nmxGraph.prototype.autoSizeCell = function (cell, recurse) {\n  recurse = recurse != null ? recurse : true;\n  if (recurse) {\n    var childCount = this.model.getChildCount(cell);\n    for (var i = 0; i < childCount; i++) {\n      this.autoSizeCell(this.model.getChildAt(cell, i));\n    }\n  }\n  if (this.getModel().isVertex(cell) && this.isAutoSizeCell(cell)) {\n    this.updateCellSize(cell);\n  }\n};\n\n/**\r\n * Function: removeCells\r\n *\r\n * Removes the given cells from the graph including all connected edges if\r\n * includeEdges is true. The change is carried out using <cellsRemoved>.\r\n * This method fires <mxEvent.REMOVE_CELLS> while the transaction is in\r\n * progress. The removed cells are returned as an array.\r\n *\r\n * Parameters:\r\n *\r\n * cells - Array of <mxCells> to remove. If null is specified then the\r\n * selection cells which are deletable are used.\r\n * includeEdges - Optional boolean which specifies if all connected edges\r\n * should be removed as well. Default is true.\r\n */\nmxGraph.prototype.removeCells = function (cells, includeEdges) {\n  includeEdges = includeEdges != null ? includeEdges : true;\n  if (cells == null) {\n    cells = this.getDeletableCells(this.getSelectionCells());\n  }\n\n  // Adds all edges to the cells\n  if (includeEdges) {\n    // FIXME: Remove duplicate cells in result or do not add if\n    // in cells or descendant of cells\n    cells = this.getDeletableCells(this.addAllEdges(cells));\n  }\n  this.model.beginUpdate();\n  try {\n    this.cellsRemoved(cells);\n    this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].REMOVE_CELLS, 'cells', cells, 'includeEdges', includeEdges));\n  } finally {\n    this.model.endUpdate();\n  }\n  return cells;\n};\n\n/**\r\n * Function: cellsRemoved\r\n *\r\n * Removes the given cells from the model. This method fires\r\n * <mxEvent.CELLS_REMOVED> while the transaction is in progress.\r\n *\r\n * Parameters:\r\n *\r\n * cells - Array of <mxCells> to remove.\r\n */\nmxGraph.prototype.cellsRemoved = function (cells) {\n  if (cells != null && cells.length > 0) {\n    var scale = this.view.scale;\n    var tr = this.view.translate;\n    this.model.beginUpdate();\n    try {\n      // Creates hashtable for faster lookup\n      var dict = new _mxDictionary[\"default\"]();\n      for (var i = 0; i < cells.length; i++) {\n        dict.put(cells[i], true);\n      }\n      for (var i = 0; i < cells.length; i++) {\n        // Disconnects edges which are not in cells\n        var edges = this.getAllEdges([cells[i]]);\n        var disconnectTerminal = _mxGraphUtils[\"default\"].bind(this, function (edge, source) {\n          var geo = this.model.getGeometry(edge);\n          if (geo != null) {\n            var state = this.view.getState(edge);\n            if (state != null) {\n              // Checks which side of the edge is being disconnected\n              var tmp = state.getVisibleTerminal(source);\n              var connected = false;\n              while (tmp != null) {\n                if (cells[i] == tmp) {\n                  connected = true;\n                  break;\n                }\n                tmp = this.model.getParent(tmp);\n              }\n              if (connected) {\n                var dx = tr.x;\n                var dy = tr.y;\n                var parentState = this.view.getState(this.model.getParent(edge));\n                if (parentState != null && this.model.isVertex(parentState.cell)) {\n                  dx = parentState.x / scale;\n                  dy = parentState.y / scale;\n                }\n                geo = geo.clone();\n                var pts = state.absolutePoints;\n                var n = source ? 0 : pts.length - 1;\n                geo.setTerminalPoint(new _mxPoint[\"default\"](pts[n].x / scale - dx, pts[n].y / scale - dy), source);\n                this.model.setTerminal(edges[j], null, source);\n                this.model.setGeometry(edges[j], geo);\n              }\n            }\n          }\n        });\n        for (var j = 0; j < edges.length; j++) {\n          if (!dict.get(edges[j])) {\n            disconnectTerminal(edges[j], true);\n            disconnectTerminal(edges[j], false);\n          }\n        }\n        this.model.remove(cells[i]);\n      }\n      this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].CELLS_REMOVED, 'cells', cells));\n    } finally {\n      this.model.endUpdate();\n    }\n  }\n};\n\n/**\r\n * Function: splitEdge\r\n *\r\n * Splits the given edge by adding the newEdge between the previous source\r\n * and the given cell and reconnecting the source of the given edge to the\r\n * given cell. This method fires <mxEvent.SPLIT_EDGE> while the transaction\r\n * is in progress. Returns the new edge that was inserted.\r\n *\r\n * Parameters:\r\n *\r\n * edge - <mxCell> that represents the edge to be splitted.\r\n * cells - <mxCells> that represents the cells to insert into the edge.\r\n * newEdge - <mxCell> that represents the edge to be inserted.\r\n * dx - Optional integer that specifies the vector to move the cells.\r\n * dy - Optional integer that specifies the vector to move the cells.\r\n */\nmxGraph.prototype.splitEdge = function (edge, cells, newEdge, dx, dy) {\n  dx = dx || 0;\n  dy = dy || 0;\n  var parent = this.model.getParent(edge);\n  var source = this.model.getTerminal(edge, true);\n  this.model.beginUpdate();\n  try {\n    if (newEdge == null) {\n      newEdge = this.cloneCells([edge])[0];\n      newEdge.setValue(null);\n      newEdge.setOriginId(null);\n      newEdge.setProperty('base', 'name', null);\n\n      // Removes waypoints before/after new cell\n      var state = this.view.getState(edge);\n      var geo = this.getCellGeometry(newEdge);\n      if (geo != null && geo.points != null && state != null) {\n        var t = this.view.translate;\n        var s = this.view.scale;\n        var idx = _mxUtils[\"default\"].findNearestSegment(state, (dx + t.x) * s, (dy + t.y) * s);\n        geo.points = geo.points.slice(0, idx);\n        geo = this.getCellGeometry(edge);\n        if (geo != null && geo.points != null) {\n          geo = geo.clone();\n          geo.points = geo.points.slice(idx);\n          this.model.setGeometry(edge, geo);\n        }\n      }\n    }\n    this.cellsMoved(cells, dx, dy, false, false);\n    this.cellsAdded(cells, parent, this.model.getChildCount(parent), null, null, true);\n    this.cellsAdded([newEdge], parent, this.model.getChildCount(parent), source, cells[0], false);\n    this.cellConnected(edge, cells[0], true);\n    this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].SPLIT_EDGE, 'edge', edge, 'cells', cells, 'newEdge', newEdge, 'dx', dx, 'dy', dy));\n  } finally {\n    this.model.endUpdate();\n  }\n  return newEdge;\n};\n\n/**\r\n * Group: Cell visibility\r\n */\n\n/**\r\n * Function: toggleCells\r\n *\r\n * Sets the visible state of the specified cells and all connected edges\r\n * if includeEdges is true. The change is carried out using <cellsToggled>.\r\n * This method fires <mxEvent.TOGGLE_CELLS> while the transaction is in\r\n * progress. Returns the cells whose visible state was changed.\r\n *\r\n * Parameters:\r\n *\r\n * show - Boolean that specifies the visible state to be assigned.\r\n * cells - Array of <mxCells> whose visible state should be changed. If\r\n * null is specified then the selection cells are used.\r\n * includeEdges - Optional boolean indicating if the visible state of all\r\n * connected edges should be changed as well. Default is true.\r\n */\nmxGraph.prototype.toggleCells = function (show, cells, includeEdges) {\n  if (cells == null) {\n    cells = this.getSelectionCells();\n  }\n\n  // Adds all connected edges recursively\n  if (includeEdges) {\n    cells = this.addAllEdges(cells);\n  }\n  this.model.beginUpdate();\n  try {\n    this.cellsToggled(cells, show);\n    this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].TOGGLE_CELLS, 'show', show, 'cells', cells, 'includeEdges', includeEdges));\n  } finally {\n    this.model.endUpdate();\n  }\n  return cells;\n};\n\n/**\r\n * Function: cellsToggled\r\n *\r\n * Sets the visible state of the specified cells.\r\n *\r\n * Parameters:\r\n *\r\n * cells - Array of <mxCells> whose visible state should be changed.\r\n * show - Boolean that specifies the visible state to be assigned.\r\n */\nmxGraph.prototype.cellsToggled = function (cells, show) {\n  if (cells != null && cells.length > 0) {\n    this.model.beginUpdate();\n    try {\n      for (var i = 0; i < cells.length; i++) {\n        this.model.setVisible(cells[i], show);\n      }\n    } finally {\n      this.model.endUpdate();\n    }\n  }\n};\n\n/**\r\n * Group: Folding\r\n */\n\n/**\r\n * Function: foldCells\r\n *\r\n * Sets the collapsed state of the specified cells and all descendants\r\n * if recurse is true. The change is carried out using <cellsFolded>.\r\n * This method fires <mxEvent.FOLD_CELLS> while the transaction is in\r\n * progress. Returns the cells whose collapsed state was changed.\r\n *\r\n * Parameters:\r\n *\r\n * collapsed - Boolean indicating the collapsed state to be assigned.\r\n * recurse - Optional boolean indicating if the collapsed state of all\r\n * descendants should be set. Default is false.\r\n * cells - Array of <mxCells> whose collapsed state should be set. If\r\n * null is specified then the foldable selection cells are used.\r\n * checkFoldable - Optional boolean indicating of isCellFoldable should be\r\n * checked. Default is false.\r\n * evt - Optional native event that triggered the invocation.\r\n */\nmxGraph.prototype.foldCells = function (collapse, recurse, cells, checkFoldable, evt) {\n  recurse = recurse != null ? recurse : false;\n  if (cells == null) {\n    cells = this.getFoldableCells(this.getSelectionCells(), collapse);\n  }\n  this.stopEditing(false);\n  this.model.beginUpdate();\n  try {\n    this.cellsFolded(cells, collapse, recurse, checkFoldable);\n    this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].FOLD_CELLS, 'collapse', collapse, 'recurse', recurse, 'cells', cells));\n  } finally {\n    this.model.endUpdate();\n  }\n  return cells;\n};\n\n/**\r\n * Function: cellsFolded\r\n *\r\n * Sets the collapsed state of the specified cells. This method fires\r\n * <mxEvent.CELLS_FOLDED> while the transaction is in progress. Returns the\r\n * cells whose collapsed state was changed.\r\n *\r\n * Parameters:\r\n *\r\n * cells - Array of <mxCells> whose collapsed state should be set.\r\n * collapsed - Boolean indicating the collapsed state to be assigned.\r\n * recurse - Boolean indicating if the collapsed state of all descendants\r\n * should be set.\r\n * checkFoldable - Optional boolean indicating of isCellFoldable should be\r\n * checked. Default is false.\r\n */\nmxGraph.prototype.cellsFolded = function (cells, collapse, recurse, checkFoldable) {\n  if (cells != null && cells.length > 0) {\n    this.model.beginUpdate();\n    try {\n      for (var i = 0; i < cells.length; i++) {\n        if ((!checkFoldable || this.isCellFoldable(cells[i], collapse)) && collapse != this.isCellCollapsed(cells[i])) {\n          this.model.setCollapsed(cells[i], collapse);\n          this.swapBounds(cells[i], collapse);\n          if (this.isExtendParent(cells[i])) {\n            this.extendParent(cells[i]);\n          }\n          if (recurse) {\n            var children = this.model.getChildren(cells[i]);\n            this.foldCells(children, collapse, recurse);\n          }\n          this.constrainChild(cells[i]);\n        }\n      }\n      this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].CELLS_FOLDED, 'cells', cells, 'collapse', collapse, 'recurse', recurse));\n    } finally {\n      this.model.endUpdate();\n    }\n  }\n};\n\n/**\r\n * Function: swapBounds\r\n *\r\n * Swaps the alternate and the actual bounds in the geometry of the given\r\n * cell invoking <updateAlternateBounds> before carrying out the swap.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> for which the bounds should be swapped.\r\n * willCollapse - Boolean indicating if the cell is going to be collapsed.\r\n */\nmxGraph.prototype.swapBounds = function (cell, willCollapse) {\n  if (cell != null) {\n    var geo = this.model.getGeometry(cell);\n    if (geo != null) {\n      geo = geo.clone();\n      this.updateAlternateBounds(cell, geo, willCollapse);\n      geo.swap();\n      this.model.setGeometry(cell, geo);\n    }\n  }\n};\n\n/**\r\n * Function: updateAlternateBounds\r\n *\r\n * Updates or sets the alternate bounds in the given geometry for the given\r\n * cell depending on whether the cell is going to be collapsed. If no\r\n * alternate bounds are defined in the geometry and\r\n * <collapseToPreferredSize> is true, then the preferred size is used for\r\n * the alternate bounds. The top, left corner is always kept at the same\r\n * location.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> for which the geometry is being udpated.\r\n * g - <mxGeometry> for which the alternate bounds should be updated.\r\n * willCollapse - Boolean indicating if the cell is going to be collapsed.\r\n */\nmxGraph.prototype.updateAlternateBounds = function (cell, geo, willCollapse) {\n  if (cell != null && geo != null) {\n    var state = this.view.getState(cell);\n    var style = state != null ? state.style : this.getCellStyle(cell);\n    if (geo.alternateBounds == null) {\n      var bounds = geo;\n      if (this.collapseToPreferredSize) {\n        var tmp = this.getPreferredSizeForCell(cell);\n        if (tmp != null) {\n          bounds = tmp;\n          var startSize = _mxGraphUtils[\"default\"].getValue(style, _mxConstants[\"default\"].STYLE_STARTSIZE);\n          if (startSize > 0) {\n            bounds.height = Math.max(bounds.height, startSize);\n          }\n        }\n      }\n      geo.alternateBounds = new _mxRectangle[\"default\"](0, 0, bounds.width, bounds.height);\n    }\n    if (geo.alternateBounds != null) {\n      geo.alternateBounds.x = geo.x;\n      geo.alternateBounds.y = geo.y;\n      var alpha = _mxUtils[\"default\"].toRadians(style[_mxConstants[\"default\"].STYLE_ROTATION] || 0);\n      if (alpha != 0) {\n        var dx = geo.alternateBounds.getCenterX() - geo.getCenterX();\n        var dy = geo.alternateBounds.getCenterY() - geo.getCenterY();\n        var cos = Math.cos(alpha);\n        var sin = Math.sin(alpha);\n        var dx2 = cos * dx - sin * dy;\n        var dy2 = sin * dx + cos * dy;\n        geo.alternateBounds.x += dx2 - dx;\n        geo.alternateBounds.y += dy2 - dy;\n      }\n    }\n  }\n};\n\n/**\r\n * Function: addAllEdges\r\n *\r\n * Returns an array with the given cells and all edges that are connected\r\n * to a cell or one of its descendants.\r\n */\nmxGraph.prototype.addAllEdges = function (cells) {\n  var allCells = cells.slice();\n  return _mxUtils[\"default\"].removeDuplicates(allCells.concat(this.getAllEdges(cells)));\n};\n\n/**\r\n * Function: getAllEdges\r\n *\r\n * Returns all edges connected to the given cells or its descendants.\r\n */\nmxGraph.prototype.getAllEdges = function (cells) {\n  var edges = [];\n  if (cells != null) {\n    for (var i = 0; i < cells.length; i++) {\n      var edgeCount = this.model.getEdgeCount(cells[i]);\n      for (var j = 0; j < edgeCount; j++) {\n        edges.push(this.model.getEdgeAt(cells[i], j));\n      }\n\n      // Recurses\n      var children = this.model.getChildren(cells[i]);\n      edges = edges.concat(this.getAllEdges(children));\n    }\n  }\n  return edges;\n};\n\n/**\r\n * Group: Cell sizing\r\n */\n\n/**\r\n * Function: updateCellSize\r\n *\r\n * Updates the size of the given cell in the model using <cellSizeUpdated>.\r\n * This method fires <mxEvent.UPDATE_CELL_SIZE> while the transaction is in\r\n * progress. Returns the cell whose size was updated.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose size should be updated.\r\n */\nmxGraph.prototype.updateCellSize = function (cell, ignoreChildren) {\n  ignoreChildren = ignoreChildren != null ? ignoreChildren : false;\n  this.model.beginUpdate();\n  try {\n    this.cellSizeUpdated(cell, ignoreChildren);\n    this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].UPDATE_CELL_SIZE, 'cell', cell, 'ignoreChildren', ignoreChildren));\n  } finally {\n    this.model.endUpdate();\n  }\n  return cell;\n};\n\n/**\r\n * Function: cellSizeUpdated\r\n *\r\n * Updates the size of the given cell in the model using\r\n * <getPreferredSizeForCell> to get the new size.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> for which the size should be changed.\r\n */\nmxGraph.prototype.cellSizeUpdated = function (cell, ignoreChildren) {\n  if (cell != null) {\n    this.model.beginUpdate();\n    try {\n      var size = this.getPreferredSizeForCell(cell);\n      var geo = this.model.getGeometry(cell);\n      if (size != null && geo != null) {\n        var collapsed = this.isCellCollapsed(cell);\n        geo = geo.clone();\n        if (this.isSwimlane(cell)) {\n          var state = this.view.getState(cell);\n          var style = state != null ? state.style : this.getCellStyle(cell);\n          var cellStyle = this.model.getStyle(cell);\n          if (cellStyle == null) {\n            cellStyle = '';\n          }\n          if (_mxGraphUtils[\"default\"].getValue(style, _mxConstants[\"default\"].STYLE_HORIZONTAL, true)) {\n            cellStyle = _mxUtils[\"default\"].setStyle(cellStyle, _mxConstants[\"default\"].STYLE_STARTSIZE, size.height + 8);\n            if (collapsed) {\n              geo.height = size.height + 8;\n            }\n            geo.width = size.width;\n          } else {\n            cellStyle = _mxUtils[\"default\"].setStyle(cellStyle, _mxConstants[\"default\"].STYLE_STARTSIZE, size.width + 8);\n            if (collapsed) {\n              geo.width = size.width + 8;\n            }\n            geo.height = size.height;\n          }\n          this.model.setStyle(cell, cellStyle);\n        } else {\n          geo.width = size.width;\n          geo.height = size.height;\n        }\n        if (!ignoreChildren && !collapsed) {\n          var bounds = this.view.getBounds(this.model.getChildren(cell));\n          if (bounds != null) {\n            //TODO: autoSize 之后和子元素有重合，增加类似padding的效果\n            if (this.isSwimlane(cell)) {\n              bounds.width += _mxConstants[\"default\"].DEFAULT_SWIMLANE_PADDING;\n              bounds.height += _mxConstants[\"default\"].DEFAULT_SWIMLANE_PADDING;\n            }\n            var tr = this.view.translate;\n            var scale = this.view.scale;\n            var width = (bounds.x + bounds.width) / scale - geo.x - tr.x;\n            var height = (bounds.y + bounds.height) / scale - geo.y - tr.y;\n\n            //不论是由大变小还是由小变大，都取最合适的宽高而不是取最大的宽高\n            geo.width = width; //Math.max(geo.width, width);\n            geo.height = height; //Math.max(geo.height, height);\n          }\n        }\n        this.cellsResized([cell], [geo], false);\n      }\n    } finally {\n      this.model.endUpdate();\n    }\n  }\n};\n\n/**\r\n * Function: getPreferredSizeForCell\r\n *\r\n * Returns the preferred width and height of the given <mxCell> as an\r\n * <mxRectangle>. To implement a minimum width, add a new style eg.\r\n * minWidth in the vertex and override this method as follows.\r\n *\r\n * (code)\r\n * var graphGetPreferredSizeForCell = graph.getPreferredSizeForCell;\r\n * graph.getPreferredSizeForCell = function(cell)\r\n * {\r\n *   var result = graphGetPreferredSizeForCell.apply(this, arguments);\r\n *   var style = this.getCellStyle(cell);\r\n *\r\n *   if (style['minWidth'] > 0)\r\n *   {\r\n *     result.width = Math.max(style['minWidth'], result.width);\r\n *   }\r\n *\r\n *   return result;\r\n * };\r\n * (end)\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> for which the preferred size should be returned.\r\n */\nmxGraph.prototype.getPreferredSizeForCell = function (cell) {\n  var result = null;\n  if (cell != null) {\n    var state = this.view.getState(cell) || this.view.createState(cell);\n    var style = state.style;\n    if (!this.model.isEdge(cell)) {\n      var fontSize = style[_mxConstants[\"default\"].STYLE_FONTSIZE] || _mxConstants[\"default\"].DEFAULT_FONTSIZE;\n      var dx = 0;\n      var dy = 0;\n\n      // Adds dimension of image if shape is a label\n      if (this.getImage(state) != null || style[_mxConstants[\"default\"].STYLE_IMAGE] != null) {\n        if (style[_mxConstants[\"default\"].STYLE_SHAPE] == _mxConstants[\"default\"].SHAPE_LABEL) {\n          if (style[_mxConstants[\"default\"].STYLE_VERTICAL_ALIGN] == _mxConstants[\"default\"].ALIGN_MIDDLE) {\n            dx += parseFloat(style[_mxConstants[\"default\"].STYLE_IMAGE_WIDTH]) || _mxLabel[\"default\"].prototype.imageSize;\n          }\n          if (style[_mxConstants[\"default\"].STYLE_ALIGN] != _mxConstants[\"default\"].ALIGN_CENTER) {\n            dy += parseFloat(style[_mxConstants[\"default\"].STYLE_IMAGE_HEIGHT]) || _mxLabel[\"default\"].prototype.imageSize;\n          }\n        }\n      }\n\n      // Adds spacings\n      dx += 2 * (style[_mxConstants[\"default\"].STYLE_SPACING] || 0);\n      dx += style[_mxConstants[\"default\"].STYLE_SPACING_LEFT] || 0;\n      dx += style[_mxConstants[\"default\"].STYLE_SPACING_RIGHT] || 0;\n      dy += 2 * (style[_mxConstants[\"default\"].STYLE_SPACING] || 0);\n      dy += style[_mxConstants[\"default\"].STYLE_SPACING_TOP] || 0;\n      dy += style[_mxConstants[\"default\"].STYLE_SPACING_BOTTOM] || 0;\n\n      // Add spacing for collapse/expand icon\n      // LATER: Check alignment and use constants\n      // for image spacing\n      var image = this.getFoldingImage(state);\n      if (image != null) {\n        dx += image.width + 8;\n      }\n\n      // Adds space for label\n      var value = this.cellRenderer.getLabelValue(state);\n      if (value != null && value.length > 0) {\n        if (!this.isHtmlLabel(state.cell)) {\n          value = _mxGraphUtils[\"default\"].htmlEntities(value);\n        }\n        value = value.replace(/\\n/g, '<br>');\n        var size = _mxUtils[\"default\"].getSizeForString(value, fontSize, style[_mxConstants[\"default\"].STYLE_FONTFAMILY]);\n        var width = size.width + dx;\n        var height = size.height + dy;\n        if (!_mxGraphUtils[\"default\"].getValue(style, _mxConstants[\"default\"].STYLE_HORIZONTAL, true)) {\n          var tmp = height;\n          height = width;\n          width = tmp;\n        }\n        if (this.gridEnabled) {\n          width = this.snap(width + this.gridSize / 2);\n          height = this.snap(height + this.gridSize / 2);\n        }\n        result = new _mxRectangle[\"default\"](0, 0, width, height);\n      } else {\n        var gs2 = 4 * this.gridSize;\n        result = new _mxRectangle[\"default\"](0, 0, gs2, gs2);\n      }\n    }\n  }\n  return result;\n};\n\n/**\r\n * Function: resizeCell\r\n *\r\n * Sets the bounds of the given cell using <resizeCells>. Returns the\r\n * cell which was passed to the function.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose bounds should be changed.\r\n * bounds - <mxRectangle> that represents the new bounds.\r\n */\nmxGraph.prototype.resizeCell = function (cell, bounds, recurse) {\n  return this.resizeCells([cell], [bounds], recurse)[0];\n};\n\n/**\r\n * Function: resizeCells\r\n *\r\n * Sets the bounds of the given cells and fires a <mxEvent.RESIZE_CELLS>\r\n * event while the transaction is in progress. Returns the cells which\r\n * have been passed to the function.\r\n *\r\n * Parameters:\r\n *\r\n * cells - Array of <mxCells> whose bounds should be changed.\r\n * bounds - Array of <mxRectangles> that represent the new bounds.\r\n */\nmxGraph.prototype.resizeCells = function (cells, bounds, recurse) {\n  recurse = recurse != null ? recurse : this.isRecursiveResize();\n  this.model.beginUpdate();\n  try {\n    this.cellsResized(cells, bounds, recurse);\n    this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].RESIZE_CELLS, 'cells', cells, 'bounds', bounds));\n  } finally {\n    this.model.endUpdate();\n  }\n  return cells;\n};\n\n/**\r\n * Function: cellsResized\r\n *\r\n * Sets the bounds of the given cells and fires a <mxEvent.CELLS_RESIZED>\r\n * event. If <extendParents> is true, then the parent is extended if a\r\n * child size is changed so that it overlaps with the parent.\r\n *\r\n * The following example shows how to control group resizes to make sure\r\n * that all child cells stay within the group.\r\n *\r\n * (code)\r\n * graph.addListener(mxEvent.CELLS_RESIZED, function(sender, evt)\r\n * {\r\n *   var cells = evt.getProperty('cells');\r\n *\r\n *   if (cells != null)\r\n *   {\r\n *     for (var i = 0; i < cells.length; i++)\r\n *     {\r\n *       if (graph.getModel().getChildCount(cells[i]) > 0)\r\n *       {\r\n *         var geo = graph.getCellGeometry(cells[i]);\r\n *\r\n *         if (geo != null)\r\n *         {\r\n *           var children = graph.getChildCells(cells[i], true, true);\r\n *           var bounds = graph.getBoundingBoxFromGeometry(children, true);\r\n *\r\n *           geo = geo.clone();\r\n *           geo.width = Math.max(geo.width, bounds.width);\r\n *           geo.height = Math.max(geo.height, bounds.height);\r\n *\r\n *           graph.getModel().setGeometry(cells[i], geo);\r\n *         }\r\n *       }\r\n *     }\r\n *   }\r\n * });\r\n * (end)\r\n *\r\n * Parameters:\r\n *\r\n * cells - Array of <mxCells> whose bounds should be changed.\r\n * bounds - Array of <mxRectangles> that represent the new bounds.\r\n * recurse - Optional boolean that specifies if the children should be resized.\r\n */\nmxGraph.prototype.cellsResized = function (cells, bounds, recurse) {\n  recurse = recurse != null ? recurse : false;\n  if (cells != null && bounds != null && cells.length == bounds.length) {\n    this.model.beginUpdate();\n    try {\n      for (var i = 0; i < cells.length; i++) {\n        this.cellResized(cells[i], bounds[i], false, recurse);\n        if (this.isExtendParent(cells[i])) {\n          this.extendParent(cells[i]);\n        }\n        this.constrainChild(cells[i]);\n      }\n      if (this.resetEdgesOnResize) {\n        this.resetEdges(cells);\n      }\n      this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].CELLS_RESIZED, 'cells', cells, 'bounds', bounds));\n    } finally {\n      this.model.endUpdate();\n    }\n  }\n};\n\n/**\r\n * Function: cellResized\r\n *\r\n * Resizes the parents recursively so that they contain the complete area\r\n * of the resized child cell.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose bounds should be changed.\r\n * bounds - <mxRectangles> that represent the new bounds.\r\n * ignoreRelative - Boolean that indicates if relative cells should be ignored.\r\n * recurse - Optional boolean that specifies if the children should be resized.\r\n */\nmxGraph.prototype.cellResized = function (cell, bounds, ignoreRelative, recurse) {\n  var geo = this.model.getGeometry(cell);\n  if (geo != null && (geo.x != bounds.x || geo.y != bounds.y || geo.width != bounds.width || geo.height != bounds.height)) {\n    geo = geo.clone();\n    if (!ignoreRelative && geo.relative) {\n      var offset = geo.offset;\n      if (offset != null) {\n        offset.x += bounds.x - geo.x;\n        offset.y += bounds.y - geo.y;\n      }\n    } else {\n      geo.x = bounds.x;\n      geo.y = bounds.y;\n    }\n    geo.width = bounds.width;\n    geo.height = bounds.height;\n    if (!geo.relative && this.model.isVertex(cell) && !this.isAllowNegativeCoordinates()) {\n      geo.x = Math.max(0, geo.x);\n      geo.y = Math.max(0, geo.y);\n    }\n    this.model.beginUpdate();\n    try {\n      if (recurse) {\n        this.resizeChildCells(cell, geo);\n      }\n      this.model.setGeometry(cell, geo);\n      this.constrainChildCells(cell);\n    } finally {\n      this.model.endUpdate();\n    }\n  }\n};\n\n/**\r\n * Function: resizeChildCells\r\n *\r\n * Resizes the child cells of the given cell for the given new geometry with\r\n * respect to the current geometry of the cell.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> that has been resized.\r\n * newGeo - <mxGeometry> that represents the new bounds.\r\n */\nmxGraph.prototype.resizeChildCells = function (cell, newGeo) {\n  var geo = this.model.getGeometry(cell);\n  var dx = newGeo.width / geo.width;\n  var dy = newGeo.height / geo.height;\n  var childCount = this.model.getChildCount(cell);\n  for (var i = 0; i < childCount; i++) {\n    this.scaleCell(this.model.getChildAt(cell, i), dx, dy, true);\n  }\n};\n\n/**\r\n * Function: constrainChildCells\r\n *\r\n * Constrains the children of the given cell using <constrainChild>.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> that has been resized.\r\n */\nmxGraph.prototype.constrainChildCells = function (cell) {\n  var childCount = this.model.getChildCount(cell);\n  for (var i = 0; i < childCount; i++) {\n    this.constrainChild(this.model.getChildAt(cell, i));\n  }\n};\n\n/**\r\n * Function: scaleCell\r\n *\r\n * Scales the points, position and size of the given cell according to the\r\n * given vertical and horizontal scaling factors.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose geometry should be scaled.\r\n * dx - Horizontal scaling factor.\r\n * dy - Vertical scaling factor.\r\n * recurse - Boolean indicating if the child cells should be scaled.\r\n */\nmxGraph.prototype.scaleCell = function (cell, dx, dy, recurse) {\n  var geo = this.model.getGeometry(cell);\n  if (geo != null) {\n    var state = this.view.getState(cell);\n    var style = state != null ? state.style : this.getCellStyle(cell);\n    geo = geo.clone();\n\n    // Stores values for restoring based on style\n    var x = geo.x;\n    var y = geo.y;\n    var w = geo.width;\n    var h = geo.height;\n    geo.scale(dx, dy, style[_mxConstants[\"default\"].STYLE_ASPECT] == 'fixed');\n    if (style[_mxConstants[\"default\"].STYLE_RESIZE_WIDTH] == '1') {\n      geo.width = w * dx;\n    } else if (style[_mxConstants[\"default\"].STYLE_RESIZE_WIDTH] == '0') {\n      geo.width = w;\n    }\n    if (style[_mxConstants[\"default\"].STYLE_RESIZE_HEIGHT] == '1') {\n      geo.height = h * dy;\n    } else if (style[_mxConstants[\"default\"].STYLE_RESIZE_HEIGHT] == '0') {\n      geo.height = h;\n    }\n    if (!this.isCellMovable(cell)) {\n      geo.x = x;\n      geo.y = y;\n    }\n    if (!this.isCellResizable(cell)) {\n      geo.width = w;\n      geo.height = h;\n    }\n    if (this.model.isVertex(cell)) {\n      this.cellResized(cell, geo, true, recurse);\n    } else {\n      this.model.setGeometry(cell, geo);\n    }\n  }\n};\n\n/**\r\n * Function: extendParent\r\n *\r\n * Resizes the parents recursively so that they contain the complete area\r\n * of the resized child cell.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> that has been resized.\r\n */\nmxGraph.prototype.extendParent = function (cell) {\n  if (cell != null) {\n    var parent = this.model.getParent(cell);\n    var p = this.getCellGeometry(parent);\n    if (parent != null && p != null && !this.isCellCollapsed(parent)) {\n      var geo = this.getCellGeometry(cell);\n      if (geo != null && !geo.relative && (p.width < geo.x + geo.width || p.height < geo.y + geo.height)) {\n        p = p.clone();\n        p.width = Math.max(p.width, geo.x + geo.width);\n        p.height = Math.max(p.height, geo.y + geo.height);\n        this.cellsResized([parent], [p], false);\n      }\n    }\n  }\n};\n\n/**\r\n * Group: Cell moving\r\n */\n\n/**\r\n * Function: importCells\r\n *\r\n * Clones and inserts the given cells into the graph using the move\r\n * method and returns the inserted cells. This shortcut is used if\r\n * cells are inserted via datatransfer.\r\n *\r\n * Parameters:\r\n *\r\n * cells - Array of <mxCells> to be imported.\r\n * dx - Integer that specifies the x-coordinate of the vector. Default is 0.\r\n * dy - Integer that specifies the y-coordinate of the vector. Default is 0.\r\n * target - <mxCell> that represents the new parent of the cells.\r\n * evt - Mouseevent that triggered the invocation.\r\n * mapping - Optional mapping for existing clones.\r\n */\nmxGraph.prototype.importCells = function (cells, dx, dy, target, evt, mapping) {\n  return this.moveCells(cells, dx, dy, true, target, evt, mapping);\n};\n\n/**\r\n * Function: moveCells\r\n *\r\n * Moves or clones the specified cells and moves the cells or clones by the\r\n * given amount, adding them to the optional target cell. The evt is the\r\n * mouse event as the mouse was released. The change is carried out using\r\n * <cellsMoved>. This method fires <mxEvent.MOVE_CELLS> while the\r\n * transaction is in progress. Returns the cells that were moved.\r\n *\r\n * Use the following code to move all cells in the graph.\r\n *\r\n * (code)\r\n * graph.moveCells(graph.getChildCells(null, true, true), 10, 10);\r\n * (end)\r\n *\r\n * Parameters:\r\n *\r\n * cells - Array of <mxCells> to be moved, cloned or added to the target.\r\n * dx - Integer that specifies the x-coordinate of the vector. Default is 0.\r\n * dy - Integer that specifies the y-coordinate of the vector. Default is 0.\r\n * clone - Boolean indicating if the cells should be cloned. Default is false.\r\n * target - <mxCell> that represents the new parent of the cells.\r\n * evt - Mouseevent that triggered the invocation.\r\n * mapping - Optional mapping for existing clones.\r\n */\nmxGraph.prototype.moveCells = function (cells, dx, dy, clone, target, evt, mapping) {\n  dx = dx != null ? dx : 0;\n  dy = dy != null ? dy : 0;\n  clone = clone != null ? clone : false;\n  if (cells != null && (dx != 0 || dy != 0 || clone || target != null)) {\n    // Removes descandants with ancestors in cells to avoid multiple moving\n    cells = this.model.getTopmostCells(cells);\n    this.model.beginUpdate();\n    try {\n      // Faster cell lookups to remove relative edge labels with selected\n      // terminals to avoid explicit and implicit move at same time\n      var dict = new _mxDictionary[\"default\"]();\n      for (var i = 0; i < cells.length; i++) {\n        dict.put(cells[i], true);\n      }\n      var isSelected = _mxGraphUtils[\"default\"].bind(this, function (cell) {\n        while (cell != null) {\n          if (dict.get(cell)) {\n            return true;\n          }\n          cell = this.model.getParent(cell);\n        }\n        return false;\n      });\n\n      // Removes relative edge labels with selected terminals\n      var checked = [];\n      // 记录cell与原parent的关系\n      var data = {};\n      for (var i = 0; i < cells.length; i++) {\n        var cell = cells[i];\n        var geo = this.getCellGeometry(cell);\n        var parent = this.model.getParent(cell);\n        if (target && parent && target != parent) {\n          data[cell.id] = parent.id;\n        }\n        if (geo == null || !geo.relative || !this.model.isEdge(parent) || !isSelected(this.model.getTerminal(parent, true)) && !isSelected(this.model.getTerminal(parent, false))) {\n          checked.push(cell);\n        }\n      }\n      cells = checked;\n      if (clone) {\n        cells = this.cloneCells(cells, this.isCloneInvalidEdges(), mapping);\n        if (target == null) {\n          target = this.getDefaultParent();\n        }\n      }\n\n      // FIXME: Cells should always be inserted first before any other edit\n      // to avoid forward references in sessions.\n      // Need to disable allowNegativeCoordinates if target not null to\n      // allow for temporary negative numbers until cellsAdded is called.\n      var previous = this.isAllowNegativeCoordinates();\n      if (target != null) {\n        this.setAllowNegativeCoordinates(true);\n      }\n      this.cellsMoved(cells, dx, dy, !clone && this.isDisconnectOnMove() && this.isAllowDanglingEdges(), target == null, this.isExtendParentsOnMove() && target == null);\n      this.setAllowNegativeCoordinates(previous);\n      if (target != null) {\n        var index = this.model.getChildCount(target);\n        this.cellsAdded(cells, target, index, null, null, true);\n      }\n\n      // Dispatches a move event\n      this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].MOVE_CELLS, 'cells', cells, 'dx', dx, 'dy', dy, 'clone', clone, 'target', target, 'event', evt, 'parentChanged', data));\n    } finally {\n      this.model.endUpdate();\n    }\n  }\n  return cells;\n};\n\n/**\r\n * Function: cellsMoved\r\n *\r\n * Moves the specified cells by the given vector, disconnecting the cells\r\n * using disconnectGraph is disconnect is true. This method fires\r\n * <mxEvent.CELLS_MOVED> while the transaction is in progress.\r\n */\nmxGraph.prototype.cellsMoved = function (cells, dx, dy, disconnect, constrain, extend) {\n  if (cells != null && (dx != 0 || dy != 0)) {\n    extend = extend != null ? extend : false;\n    this.model.beginUpdate();\n    try {\n      if (disconnect) {\n        this.disconnectGraph(cells);\n      }\n      for (var i = 0; i < cells.length; i++) {\n        this.translateCell(cells[i], dx, dy);\n        if (extend && this.isExtendParent(cells[i])) {\n          this.extendParent(cells[i]);\n        } else if (constrain) {\n          this.constrainChild(cells[i]);\n        }\n      }\n      if (this.resetEdgesOnMove) {\n        this.resetEdges(cells);\n      }\n      this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].CELLS_MOVED, 'cells', cells, 'dx', dx, 'dy', dy, 'disconnect', disconnect));\n    } finally {\n      this.model.endUpdate();\n    }\n  }\n};\n\n/**\r\n * Function: translateCell\r\n *\r\n * Translates the geometry of the given cell and stores the new,\r\n * translated geometry in the model as an atomic change.\r\n */\nmxGraph.prototype.translateCell = function (cell, dx, dy) {\n  var geo = this.model.getGeometry(cell);\n  if (geo != null) {\n    dx = parseFloat(dx);\n    dy = parseFloat(dy);\n    geo = geo.clone();\n    geo.translate(dx, dy);\n    if (!geo.relative && this.model.isVertex(cell) && !this.isAllowNegativeCoordinates()) {\n      geo.x = Math.max(0, parseFloat(geo.x));\n      geo.y = Math.max(0, parseFloat(geo.y));\n    }\n    if (geo.relative && !this.model.isEdge(cell)) {\n      var parent = this.model.getParent(cell);\n      var angle = 0;\n      if (this.model.isVertex(parent)) {\n        var state = this.view.getState(parent);\n        var style = state != null ? state.style : this.getCellStyle(parent);\n        angle = _mxGraphUtils[\"default\"].getValue(style, _mxConstants[\"default\"].STYLE_ROTATION, 0);\n      }\n      if (angle != 0) {\n        var rad = _mxUtils[\"default\"].toRadians(-angle);\n        var cos = Math.cos(rad);\n        var sin = Math.sin(rad);\n        var pt = _mxUtils[\"default\"].getRotatedPoint(new _mxPoint[\"default\"](dx, dy), cos, sin, new _mxPoint[\"default\"](0, 0));\n        dx = pt.x;\n        dy = pt.y;\n      }\n      if (geo.offset == null) {\n        geo.offset = new _mxPoint[\"default\"](dx, dy);\n      } else {\n        geo.offset.x = parseFloat(geo.offset.x) + dx;\n        geo.offset.y = parseFloat(geo.offset.y) + dy;\n      }\n    }\n    this.model.setGeometry(cell, geo);\n  }\n};\n\n/**\r\n * Function: getCellContainmentArea\r\n *\r\n * Returns the <mxRectangle> inside which a cell is to be kept.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> for which the area should be returned.\r\n */\nmxGraph.prototype.getCellContainmentArea = function (cell) {\n  if (cell != null && !this.model.isEdge(cell)) {\n    var parent = this.model.getParent(cell);\n    if (parent != null && parent != this.getDefaultParent()) {\n      var g = this.model.getGeometry(parent);\n      if (g != null) {\n        var x = 0;\n        var y = 0;\n        var w = g.width;\n        var h = g.height;\n        if (this.isSwimlane(parent)) {\n          var size = this.getStartSize(parent);\n          var state = this.view.getState(parent);\n          var style = state != null ? state.style : this.getCellStyle(parent);\n          var dir = _mxGraphUtils[\"default\"].getValue(style, _mxConstants[\"default\"].STYLE_DIRECTION, _mxConstants[\"default\"].DIRECTION_EAST);\n          var flipH = _mxGraphUtils[\"default\"].getValue(style, _mxConstants[\"default\"].STYLE_FLIPH, 0) == 1;\n          var flipV = _mxGraphUtils[\"default\"].getValue(style, _mxConstants[\"default\"].STYLE_FLIPV, 0) == 1;\n          if (dir == _mxConstants[\"default\"].DIRECTION_SOUTH || dir == _mxConstants[\"default\"].DIRECTION_NORTH) {\n            var tmp = size.width;\n            size.width = size.height;\n            size.height = tmp;\n          }\n          if (dir == _mxConstants[\"default\"].DIRECTION_EAST && !flipV || dir == _mxConstants[\"default\"].DIRECTION_NORTH && !flipH || dir == _mxConstants[\"default\"].DIRECTION_WEST && flipV || dir == _mxConstants[\"default\"].DIRECTION_SOUTH && flipH) {\n            x = size.width;\n            y = size.height;\n          }\n          w -= size.width;\n          h -= size.height;\n        }\n        return new _mxRectangle[\"default\"](x, y, w, h);\n      }\n    }\n  }\n  return null;\n};\n\n/**\r\n * Function: getMaximumGraphBounds\r\n *\r\n * Returns the bounds inside which the diagram should be kept as an\r\n * <mxRectangle>.\r\n */\nmxGraph.prototype.getMaximumGraphBounds = function () {\n  return this.maximumGraphBounds;\n};\n\n/**\r\n * Function: constrainChild\r\n *\r\n * Keeps the given cell inside the bounds returned by\r\n * <getCellContainmentArea> for its parent, according to the rules defined by\r\n * <getOverlap> and <isConstrainChild>. This modifies the cell's geometry\r\n * in-place and does not clone it.\r\n *\r\n * Parameters:\r\n *\r\n * cells - <mxCell> which should be constrained.\r\n * sizeFirst - Specifies if the size should be changed first. Default is true.\r\n */\nmxGraph.prototype.constrainChild = function (cell, sizeFirst) {\n  sizeFirst = sizeFirst != null ? sizeFirst : true;\n  if (cell != null) {\n    var geo = this.getCellGeometry(cell);\n    if (geo != null && (this.isConstrainRelativeChildren() || !geo.relative)) {\n      var parent = this.model.getParent(cell);\n      var pgeo = this.getCellGeometry(parent);\n      var max = this.getMaximumGraphBounds();\n\n      // Finds parent offset\n      if (max != null) {\n        var off = this.getBoundingBoxFromGeometry([parent], false);\n        if (off != null) {\n          max = _mxRectangle[\"default\"].fromRectangle(max);\n          max.x -= off.x;\n          max.y -= off.y;\n        }\n      }\n      if (this.isConstrainChild(cell)) {\n        var tmp = this.getCellContainmentArea(cell);\n        if (tmp != null) {\n          var overlap = this.getOverlap(cell);\n          if (overlap > 0) {\n            tmp = _mxRectangle[\"default\"].fromRectangle(tmp);\n            tmp.x -= tmp.width * overlap;\n            tmp.y -= tmp.height * overlap;\n            tmp.width += 2 * tmp.width * overlap;\n            tmp.height += 2 * tmp.height * overlap;\n          }\n\n          // Find the intersection between max and tmp\n          if (max == null) {\n            max = tmp;\n          } else {\n            max = _mxRectangle[\"default\"].fromRectangle(max);\n            max.intersect(tmp);\n          }\n        }\n      }\n      if (max != null) {\n        var cells = [cell];\n        if (!this.isCellCollapsed(cell)) {\n          var desc = this.model.getDescendants(cell);\n          for (var i = 0; i < desc.length; i++) {\n            if (this.isCellVisible(desc[i])) {\n              cells.push(desc[i]);\n            }\n          }\n        }\n        var bbox = this.getBoundingBoxFromGeometry(cells, false);\n        if (bbox != null) {\n          geo = geo.clone();\n\n          // Cumulative horizontal movement\n          var dx = 0;\n          if (geo.width > max.width) {\n            dx = geo.width - max.width;\n            geo.width -= dx;\n          }\n          if (bbox.x + bbox.width > max.x + max.width) {\n            dx -= bbox.x + bbox.width - max.x - max.width - dx;\n          }\n\n          // Cumulative vertical movement\n          var dy = 0;\n          if (geo.height > max.height) {\n            dy = geo.height - max.height;\n            geo.height -= dy;\n          }\n          if (bbox.y + bbox.height > max.y + max.height) {\n            dy -= bbox.y + bbox.height - max.y - max.height - dy;\n          }\n          if (bbox.x < max.x) {\n            dx -= bbox.x - max.x;\n          }\n          if (bbox.y < max.y) {\n            dy -= bbox.y - max.y;\n          }\n          if (dx != 0 || dy != 0) {\n            if (geo.relative) {\n              // Relative geometries are moved via absolute offset\n              if (geo.offset == null) {\n                geo.offset = new _mxPoint[\"default\"]();\n              }\n              geo.offset.x += dx;\n              geo.offset.y += dy;\n            } else {\n              geo.x += dx;\n              geo.y += dy;\n            }\n          }\n          this.model.setGeometry(cell, geo);\n        }\n      }\n    }\n  }\n};\n\n/**\r\n * Function: resetEdges\r\n *\r\n * Resets the control points of the edges that are connected to the given\r\n * cells if not both ends of the edge are in the given cells array.\r\n *\r\n * Parameters:\r\n *\r\n * cells - Array of <mxCells> for which the connected edges should be\r\n * reset.\r\n */\nmxGraph.prototype.resetEdges = function (cells) {\n  if (cells != null) {\n    // Prepares faster cells lookup\n    var dict = new _mxDictionary[\"default\"]();\n    for (var i = 0; i < cells.length; i++) {\n      dict.put(cells[i], true);\n    }\n    this.model.beginUpdate();\n    try {\n      for (var i = 0; i < cells.length; i++) {\n        var edges = this.model.getEdges(cells[i]);\n        if (edges != null) {\n          for (var j = 0; j < edges.length; j++) {\n            var state = this.view.getState(edges[j]);\n            var source = state != null ? state.getVisibleTerminal(true) : this.view.getVisibleTerminal(edges[j], true);\n            var target = state != null ? state.getVisibleTerminal(false) : this.view.getVisibleTerminal(edges[j], false);\n\n            // Checks if one of the terminals is not in the given array\n            if (!dict.get(source) || !dict.get(target)) {\n              this.resetEdge(edges[j]);\n            }\n          }\n        }\n        this.resetEdges(this.model.getChildren(cells[i]));\n      }\n    } finally {\n      this.model.endUpdate();\n    }\n  }\n};\n\n/**\r\n * Function: resetEdge\r\n *\r\n * Resets the control points of the given edge.\r\n *\r\n * Parameters:\r\n *\r\n * edge - <mxCell> whose points should be reset.\r\n */\nmxGraph.prototype.resetEdge = function (edge) {\n  var geo = this.model.getGeometry(edge);\n\n  // Resets the control points\n  if (geo != null && geo.points != null && geo.points.length > 0) {\n    geo = geo.clone();\n    geo.points = [];\n    this.model.setGeometry(edge, geo);\n  }\n  return edge;\n};\n\n/**\r\n * Group: Cell connecting and connection constraints\r\n */\n\n/**\r\n * Function: getOutlineConstraint\r\n *\r\n * Returns the constraint used to connect to the outline of the given state.\r\n */\nmxGraph.prototype.getOutlineConstraint = function (point, terminalState, me) {\n  if (terminalState.shape != null) {\n    var bounds = this.view.getPerimeterBounds(terminalState);\n    var direction = terminalState.style[_mxConstants[\"default\"].STYLE_DIRECTION];\n    if (direction == _mxConstants[\"default\"].DIRECTION_NORTH || direction == _mxConstants[\"default\"].DIRECTION_SOUTH) {\n      bounds.x += bounds.width / 2 - bounds.height / 2;\n      bounds.y += bounds.height / 2 - bounds.width / 2;\n      var tmp = bounds.width;\n      bounds.width = bounds.height;\n      bounds.height = tmp;\n    }\n    var alpha = _mxUtils[\"default\"].toRadians(terminalState.shape.getShapeRotation());\n    if (alpha != 0) {\n      var cos = Math.cos(-alpha);\n      var sin = Math.sin(-alpha);\n      var ct = new _mxPoint[\"default\"](bounds.getCenterX(), bounds.getCenterY());\n      point = _mxUtils[\"default\"].getRotatedPoint(point, cos, sin, ct);\n    }\n    var sx = 1;\n    var sy = 1;\n    var dx = 0;\n    var dy = 0;\n\n    // LATER: Add flipping support for image shapes\n    if (this.getModel().isVertex(terminalState.cell)) {\n      var flipH = terminalState.style[_mxConstants[\"default\"].STYLE_FLIPH];\n      var flipV = terminalState.style[_mxConstants[\"default\"].STYLE_FLIPV];\n\n      // Legacy support for stencilFlipH/V\n      if (terminalState.shape != null && terminalState.shape.stencil != null) {\n        flipH = _mxGraphUtils[\"default\"].getValue(terminalState.style, 'stencilFlipH', 0) == 1 || flipH;\n        flipV = _mxGraphUtils[\"default\"].getValue(terminalState.style, 'stencilFlipV', 0) == 1 || flipV;\n      }\n      if (direction == _mxConstants[\"default\"].DIRECTION_NORTH || direction == _mxConstants[\"default\"].DIRECTION_SOUTH) {\n        var tmp = flipH;\n        flipH = flipV;\n        flipV = tmp;\n      }\n      if (flipH) {\n        sx = -1;\n        dx = -bounds.width;\n      }\n      if (flipV) {\n        sy = -1;\n        dy = -bounds.height;\n      }\n    }\n    point = new _mxPoint[\"default\"]((point.x - bounds.x) * sx - dx + bounds.x, (point.y - bounds.y) * sy - dy + bounds.y);\n    var x = Math.round((point.x - bounds.x) * 1000 / bounds.width) / 1000;\n    var y = Math.round((point.y - bounds.y) * 1000 / bounds.height) / 1000;\n    return new _mxConnectionConstraint[\"default\"](new _mxPoint[\"default\"](x, y), false);\n  }\n  return null;\n};\n\n/**\r\n * Function: getAllConnectionConstraints\r\n *\r\n * Returns an array of all <mxConnectionConstraints> for the given terminal. If\r\n * the shape of the given terminal is a <mxStencilShape> then the constraints\r\n * of the corresponding <mxStencil> are returned.\r\n *\r\n * Parameters:\r\n *\r\n * terminal - <mxCellState> that represents the terminal.\r\n * source - Boolean that specifies if the terminal is the source or target.\r\n */\nmxGraph.prototype.getAllConnectionConstraints = function (terminal, source) {\n  if (terminal != null && terminal.shape != null && terminal.shape.stencil != null) {\n    return terminal.shape.stencil.constraints;\n  }\n  return null;\n};\n\n/**\r\n * Function: getConnectionConstraint\r\n *\r\n * Returns an <mxConnectionConstraint> that describes the given connection\r\n * point. This result can then be passed to <getConnectionPoint>.\r\n *\r\n * Parameters:\r\n *\r\n * edge - <mxCellState> that represents the edge.\r\n * terminal - <mxCellState> that represents the terminal.\r\n * source - Boolean indicating if the terminal is the source or target.\r\n */\nmxGraph.prototype.getConnectionConstraint = function (edge, terminal, source) {\n  var point = null;\n  var x = edge.style[source ? _mxConstants[\"default\"].STYLE_EXIT_X : _mxConstants[\"default\"].STYLE_ENTRY_X];\n  if (x != null) {\n    var y = edge.style[source ? _mxConstants[\"default\"].STYLE_EXIT_Y : _mxConstants[\"default\"].STYLE_ENTRY_Y];\n    if (y != null) {\n      point = new _mxPoint[\"default\"](parseFloat(x), parseFloat(y));\n    }\n  }\n  var perimeter = false;\n  if (point != null) {\n    perimeter = _mxGraphUtils[\"default\"].getValue(edge.style, source ? _mxConstants[\"default\"].STYLE_EXIT_PERIMETER : _mxConstants[\"default\"].STYLE_ENTRY_PERIMETER, true);\n  }\n  return new _mxConnectionConstraint[\"default\"](point, perimeter);\n};\n\n/**\r\n * Function: setConnectionConstraint\r\n *\r\n * Sets the <mxConnectionConstraint> that describes the given connection point.\r\n * If no constraint is given then nothing is changed. To remove an existing\r\n * constraint from the given edge, use an empty constraint instead.\r\n *\r\n * Parameters:\r\n *\r\n * edge - <mxCell> that represents the edge.\r\n * terminal - <mxCell> that represents the terminal.\r\n * source - Boolean indicating if the terminal is the source or target.\r\n * constraint - Optional <mxConnectionConstraint> to be used for this\r\n * connection.\r\n */\nmxGraph.prototype.setConnectionConstraint = function (edge, terminal, source, constraint) {\n  if (constraint != null) {\n    this.model.beginUpdate();\n    try {\n      if (constraint == null || constraint.point == null) {\n        this.setCellStyles(source ? _mxConstants[\"default\"].STYLE_EXIT_X : _mxConstants[\"default\"].STYLE_ENTRY_X, null, [edge]);\n        this.setCellStyles(source ? _mxConstants[\"default\"].STYLE_EXIT_Y : _mxConstants[\"default\"].STYLE_ENTRY_Y, null, [edge]);\n        this.setCellStyles(source ? _mxConstants[\"default\"].STYLE_EXIT_PERIMETER : _mxConstants[\"default\"].STYLE_ENTRY_PERIMETER, null, [edge]);\n      } else if (constraint.point != null) {\n        this.setCellStyles(source ? _mxConstants[\"default\"].STYLE_EXIT_X : _mxConstants[\"default\"].STYLE_ENTRY_X, constraint.point.x, [edge]);\n        this.setCellStyles(source ? _mxConstants[\"default\"].STYLE_EXIT_Y : _mxConstants[\"default\"].STYLE_ENTRY_Y, constraint.point.y, [edge]);\n\n        // Only writes 0 since 1 is default\n        if (!constraint.perimeter) {\n          this.setCellStyles(source ? _mxConstants[\"default\"].STYLE_EXIT_PERIMETER : _mxConstants[\"default\"].STYLE_ENTRY_PERIMETER, '0', [edge]);\n        } else {\n          this.setCellStyles(source ? _mxConstants[\"default\"].STYLE_EXIT_PERIMETER : _mxConstants[\"default\"].STYLE_ENTRY_PERIMETER, null, [edge]);\n        }\n      }\n    } finally {\n      this.model.endUpdate();\n    }\n  }\n};\n\n/**\r\n * Function: getConnectionPoint\r\n *\r\n * Returns the nearest point in the list of absolute points or the center\r\n * of the opposite terminal.\r\n *\r\n * Parameters:\r\n *\r\n * vertex - <mxCellState> that represents the vertex.\r\n * constraint - <mxConnectionConstraint> that represents the connection point\r\n * constraint as returned by <getConnectionConstraint>.\r\n */\nmxGraph.prototype.getConnectionPoint = function (vertex, constraint) {\n  var point = null;\n  if (vertex != null && constraint.point != null) {\n    var bounds = this.view.getPerimeterBounds(vertex);\n    var cx = new _mxPoint[\"default\"](bounds.getCenterX(), bounds.getCenterY());\n    var direction = vertex.style[_mxConstants[\"default\"].STYLE_DIRECTION];\n    var r1 = 0;\n\n    // Bounds need to be rotated by 90 degrees for further computation\n    if (direction != null) {\n      if (direction == _mxConstants[\"default\"].DIRECTION_NORTH) {\n        r1 += 270;\n      } else if (direction == _mxConstants[\"default\"].DIRECTION_WEST) {\n        r1 += 180;\n      } else if (direction == _mxConstants[\"default\"].DIRECTION_SOUTH) {\n        r1 += 90;\n      }\n\n      // Bounds need to be rotated by 90 degrees for further computation\n      if (direction == _mxConstants[\"default\"].DIRECTION_NORTH || direction == _mxConstants[\"default\"].DIRECTION_SOUTH) {\n        bounds.rotate90();\n      }\n    }\n    if (constraint.point != null) {\n      var sx = 1;\n      var sy = 1;\n      var dx = 0;\n      var dy = 0;\n\n      // LATER: Add flipping support for image shapes\n      if (this.getModel().isVertex(vertex.cell)) {\n        var flipH = vertex.style[_mxConstants[\"default\"].STYLE_FLIPH];\n        var flipV = vertex.style[_mxConstants[\"default\"].STYLE_FLIPV];\n\n        // Legacy support for stencilFlipH/V\n        if (vertex.shape != null && vertex.shape.stencil != null) {\n          flipH = _mxGraphUtils[\"default\"].getValue(vertex.style, 'stencilFlipH', 0) == 1 || flipH;\n          flipV = _mxGraphUtils[\"default\"].getValue(vertex.style, 'stencilFlipV', 0) == 1 || flipV;\n        }\n        if (direction == _mxConstants[\"default\"].DIRECTION_NORTH || direction == _mxConstants[\"default\"].DIRECTION_SOUTH) {\n          var tmp = flipH;\n          flipH = flipV;\n          flipV = tmp;\n        }\n        if (flipH) {\n          sx = -1;\n          dx = -bounds.width;\n        }\n        if (flipV) {\n          sy = -1;\n          dy = -bounds.height;\n        }\n      }\n      point = new _mxPoint[\"default\"](bounds.x + constraint.point.x * bounds.width * sx - dx, bounds.y + constraint.point.y * bounds.height * sy - dy);\n    }\n\n    // Rotation for direction before projection on perimeter\n    var r2 = vertex.style[_mxConstants[\"default\"].STYLE_ROTATION] || 0;\n    if (constraint.perimeter) {\n      if (r1 != 0 && point != null) {\n        // Only 90 degrees steps possible here so no trig needed\n        var cos = 0;\n        var sin = 0;\n        if (r1 == 90) {\n          sin = 1;\n        } else if (r1 == 180) {\n          cos = -1;\n        } else if (r1 == 270) {\n          sin = -1;\n        }\n        point = _mxUtils[\"default\"].getRotatedPoint(point, cos, sin, cx);\n      }\n      if (point != null && constraint.perimeter) {\n        point = this.view.getPerimeterPoint(vertex, point, false);\n      }\n    } else {\n      r2 += r1;\n    }\n\n    // Generic rotation after projection on perimeter\n    if (r2 != 0 && point != null) {\n      var rad = _mxUtils[\"default\"].toRadians(r2);\n      var cos = Math.cos(rad);\n      var sin = Math.sin(rad);\n      point = _mxUtils[\"default\"].getRotatedPoint(point, cos, sin, cx);\n    }\n  }\n  if (point != null) {\n    point.x = Math.round(point.x);\n    point.y = Math.round(point.y);\n  }\n  return point;\n};\n\n/**\r\n * Function: connectCell\r\n *\r\n * Connects the specified end of the given edge to the given terminal\r\n * using <cellConnected> and fires <mxEvent.CONNECT_CELL> while the\r\n * transaction is in progress. Returns the updated edge.\r\n *\r\n * Parameters:\r\n *\r\n * edge - <mxCell> whose terminal should be updated.\r\n * terminal - <mxCell> that represents the new terminal to be used.\r\n * source - Boolean indicating if the new terminal is the source or target.\r\n * constraint - Optional <mxConnectionConstraint> to be used for this\r\n * connection.\r\n */\nmxGraph.prototype.connectCell = function (edge, terminal, source, constraint) {\n  this.model.beginUpdate();\n  try {\n    var previous = this.model.getTerminal(edge, source);\n    this.cellConnected(edge, terminal, source, constraint);\n    this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].CONNECT_CELL, 'edge', edge, 'terminal', terminal, 'source', source, 'previous', previous));\n  } finally {\n    this.model.endUpdate();\n  }\n  return edge;\n};\n\n/**\r\n * Function: cellConnected\r\n *\r\n * Sets the new terminal for the given edge and resets the edge points if\r\n * <resetEdgesOnConnect> is true. This method fires\r\n * <mxEvent.CELL_CONNECTED> while the transaction is in progress.\r\n *\r\n * Parameters:\r\n *\r\n * edge - <mxCell> whose terminal should be updated.\r\n * terminal - <mxCell> that represents the new terminal to be used.\r\n * source - Boolean indicating if the new terminal is the source or target.\r\n * constraint - <mxConnectionConstraint> to be used for this connection.\r\n */\nmxGraph.prototype.cellConnected = function (edge, terminal, source, constraint) {\n  if (edge != null) {\n    this.model.beginUpdate();\n    try {\n      var previous = this.model.getTerminal(edge, source);\n\n      // Updates the constraint\n      this.setConnectionConstraint(edge, terminal, source, constraint);\n\n      // Checks if the new terminal is a port, uses the ID of the port in the\n      // style and the parent of the port as the actual terminal of the edge.\n      if (this.isPortsEnabled()) {\n        var id = null;\n        if (this.isPort(terminal)) {\n          id = terminal.getId();\n          terminal = this.getTerminalForPort(terminal, source);\n        }\n\n        // Sets or resets all previous information for connecting to a child port\n        var key = source ? _mxConstants[\"default\"].STYLE_SOURCE_PORT : _mxConstants[\"default\"].STYLE_TARGET_PORT;\n        this.setCellStyles(key, id, [edge]);\n      }\n      this.model.setTerminal(edge, terminal, source);\n      if (this.resetEdgesOnConnect) {\n        this.resetEdge(edge);\n      }\n      this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].CELL_CONNECTED, 'edge', edge, 'terminal', terminal, 'source', source, 'previous', previous));\n    } finally {\n      this.model.endUpdate();\n    }\n  }\n};\n\n/**\r\n * Function: disconnectGraph\r\n *\r\n * Disconnects the given edges from the terminals which are not in the\r\n * given array.\r\n *\r\n * Parameters:\r\n *\r\n * cells - Array of <mxCells> to be disconnected.\r\n */\nmxGraph.prototype.disconnectGraph = function (cells) {\n  if (cells != null) {\n    this.model.beginUpdate();\n    try {\n      var scale = this.view.scale;\n      var tr = this.view.translate;\n\n      // Fast lookup for finding cells in array\n      var dict = new _mxDictionary[\"default\"]();\n      for (var i = 0; i < cells.length; i++) {\n        dict.put(cells[i], true);\n      }\n      for (var i = 0; i < cells.length; i++) {\n        if (this.model.isEdge(cells[i])) {\n          var geo = this.model.getGeometry(cells[i]);\n          if (geo != null) {\n            var state = this.view.getState(cells[i]);\n            var pstate = this.view.getState(this.model.getParent(cells[i]));\n            if (state != null && pstate != null) {\n              geo = geo.clone();\n              var dx = -pstate.origin.x;\n              var dy = -pstate.origin.y;\n              var pts = state.absolutePoints;\n              var src = this.model.getTerminal(cells[i], true);\n              if (src != null && this.isCellDisconnectable(cells[i], src, true)) {\n                while (src != null && !dict.get(src)) {\n                  src = this.model.getParent(src);\n                }\n                if (src == null) {\n                  geo.setTerminalPoint(new _mxPoint[\"default\"](pts[0].x / scale - tr.x + dx, pts[0].y / scale - tr.y + dy), true);\n                  this.model.setTerminal(cells[i], null, true);\n                }\n              }\n              var trg = this.model.getTerminal(cells[i], false);\n              if (trg != null && this.isCellDisconnectable(cells[i], trg, false)) {\n                while (trg != null && !dict.get(trg)) {\n                  trg = this.model.getParent(trg);\n                }\n                if (trg == null) {\n                  var n = pts.length - 1;\n                  geo.setTerminalPoint(new _mxPoint[\"default\"](pts[n].x / scale - tr.x + dx, pts[n].y / scale - tr.y + dy), false);\n                  this.model.setTerminal(cells[i], null, false);\n                }\n              }\n              this.model.setGeometry(cells[i], geo);\n            }\n          }\n        }\n      }\n    } finally {\n      this.model.endUpdate();\n    }\n  }\n};\n\n/**\r\n * Group: Drilldown\r\n */\n\n/**\r\n * Function: getCurrentRoot\r\n *\r\n * Returns the current root of the displayed cell hierarchy. This is a\r\n * shortcut to <mxGraphView.currentRoot> in <view>.\r\n */\nmxGraph.prototype.getCurrentRoot = function () {\n  return this.view.currentRoot;\n};\n\n/**\r\n * Function: getTranslateForRoot\r\n *\r\n * Returns the translation to be used if the given cell is the root cell as\r\n * an <mxPoint>. This implementation returns null.\r\n *\r\n * Example:\r\n *\r\n * To keep the children at their absolute position while stepping into groups,\r\n * this function can be overridden as follows.\r\n *\r\n * (code)\r\n * var offset = new mxPoint(0, 0);\r\n *\r\n * while (cell != null)\r\n * {\r\n *   var geo = this.model.getGeometry(cell);\r\n *\r\n *   if (geo != null)\r\n *   {\r\n *     offset.x -= geo.x;\r\n *     offset.y -= geo.y;\r\n *   }\r\n *\r\n *   cell = this.model.getParent(cell);\r\n * }\r\n *\r\n * return offset;\r\n * (end)\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> that represents the root.\r\n */\nmxGraph.prototype.getTranslateForRoot = function (cell) {\n  return null;\n};\n\n/**\r\n * Function: isPort\r\n *\r\n * Returns true if the given cell is a \"port\", that is, when connecting to\r\n * it, the cell returned by getTerminalForPort should be used as the\r\n * terminal and the port should be referenced by the ID in either the\r\n * mxConstants.STYLE_SOURCE_PORT or the or the\r\n * mxConstants.STYLE_TARGET_PORT. Note that a port should not be movable.\r\n * This implementation always returns false.\r\n *\r\n * A typical implementation is the following:\r\n *\r\n * (code)\r\n * graph.isPort = function(cell)\r\n * {\r\n *   var geo = this.getCellGeometry(cell);\r\n *\r\n *   return (geo != null) ? geo.relative : false;\r\n * };\r\n * (end)\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> that represents the port.\r\n */\nmxGraph.prototype.isPort = function (cell) {\n  return false;\n};\n\n/**\r\n * Function: getTerminalForPort\r\n *\r\n * Returns the terminal to be used for a given port. This implementation\r\n * always returns the parent cell.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> that represents the port.\r\n * source - If the cell is the source or target port.\r\n */\nmxGraph.prototype.getTerminalForPort = function (cell, source) {\n  return this.model.getParent(cell);\n};\n\n/**\r\n * Function: getChildOffsetForCell\r\n *\r\n * Returns the offset to be used for the cells inside the given cell. The\r\n * root and layer cells may be identified using <mxGraphModel.isRoot> and\r\n * <mxGraphModel.isLayer>. For all other current roots, the\r\n * <mxGraphView.currentRoot> field points to the respective cell, so that\r\n * the following holds: cell == this.view.currentRoot. This implementation\r\n * returns null.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose offset should be returned.\r\n */\nmxGraph.prototype.getChildOffsetForCell = function (cell) {\n  return null;\n};\n\n/**\r\n * Function: enterGroup\r\n *\r\n * Uses the given cell as the root of the displayed cell hierarchy. If no\r\n * cell is specified then the selection cell is used. The cell is only used\r\n * if <isValidRoot> returns true.\r\n *\r\n * Parameters:\r\n *\r\n * cell - Optional <mxCell> to be used as the new root. Default is the\r\n * selection cell.\r\n */\nmxGraph.prototype.enterGroup = function (cell) {\n  cell = cell || this.getSelectionCell();\n  if (cell != null && this.isValidRoot(cell)) {\n    this.view.setCurrentRoot(cell);\n    this.clearSelection();\n  }\n};\n\n/**\r\n * Function: exitGroup\r\n *\r\n * Changes the current root to the next valid root in the displayed cell\r\n * hierarchy.\r\n */\nmxGraph.prototype.exitGroup = function () {\n  var root = this.model.getRoot();\n  var current = this.getCurrentRoot();\n  if (current != null) {\n    var next = this.model.getParent(current);\n\n    // Finds the next valid root in the hierarchy\n    while (next != root && !this.isValidRoot(next) && this.model.getParent(next) != root) {\n      next = this.model.getParent(next);\n    }\n\n    // Clears the current root if the new root is\n    // the model's root or one of the layers.\n    if (next == root || this.model.getParent(next) == root) {\n      this.view.setCurrentRoot(null);\n    } else {\n      this.view.setCurrentRoot(next);\n    }\n    var state = this.view.getState(current);\n\n    // Selects the previous root in the graph\n    if (state != null) {\n      this.setSelectionCell(current);\n    }\n  }\n};\n\n/**\r\n * Function: home\r\n *\r\n * Uses the root of the model as the root of the displayed cell hierarchy\r\n * and selects the previous root.\r\n */\nmxGraph.prototype.home = function () {\n  var current = this.getCurrentRoot();\n  if (current != null) {\n    this.view.setCurrentRoot(null);\n    var state = this.view.getState(current);\n    if (state != null) {\n      this.setSelectionCell(current);\n    }\n  }\n};\n\n/**\r\n * Function: isValidRoot\r\n *\r\n * Returns true if the given cell is a valid root for the cell display\r\n * hierarchy. This implementation returns true for all non-null values.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> which should be checked as a possible root.\r\n */\nmxGraph.prototype.isValidRoot = function (cell) {\n  return cell != null;\n};\n\n/**\r\n * Group: Graph display\r\n */\n\n/**\r\n * Function: getGraphBounds\r\n *\r\n * Returns the bounds of the visible graph. Shortcut to\r\n * <mxGraphView.getGraphBounds>. See also: <getBoundingBoxFromGeometry>.\r\n */\nmxGraph.prototype.getGraphBounds = function () {\n  return this.view.getGraphBounds();\n};\n\n/**\r\n * Function: getCellBounds\r\n *\r\n * Returns the scaled, translated bounds for the given cell. See\r\n * <mxGraphView.getBounds> for arrays.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose bounds should be returned.\r\n * includeEdge - Optional boolean that specifies if the bounds of\r\n * the connected edges should be included. Default is false.\r\n * includeDescendants - Optional boolean that specifies if the bounds\r\n * of all descendants should be included. Default is false.\r\n */\nmxGraph.prototype.getCellBounds = function (cell, includeEdges, includeDescendants) {\n  var cells = [cell];\n\n  // Includes all connected edges\n  if (includeEdges) {\n    cells = cells.concat(this.model.getEdges(cell));\n  }\n  var result = this.view.getBounds(cells);\n\n  // Recursively includes the bounds of the children\n  if (includeDescendants) {\n    var childCount = this.model.getChildCount(cell);\n    for (var i = 0; i < childCount; i++) {\n      var tmp = this.getCellBounds(this.model.getChildAt(cell, i), includeEdges, true);\n      if (result != null) {\n        result.add(tmp);\n      } else {\n        result = tmp;\n      }\n    }\n  }\n  return result;\n};\n\n/**\r\n * Function: getBoundingBoxFromGeometry\r\n *\r\n * Returns the bounding box for the geometries of the vertices in the\r\n * given array of cells. This can be used to find the graph bounds during\r\n * a layout operation (ie. before the last endUpdate) as follows:\r\n *\r\n * (code)\r\n * var cells = graph.getChildCells(graph.getDefaultParent(), true, true);\r\n * var bounds = graph.getBoundingBoxFromGeometry(cells, true);\r\n * (end)\r\n *\r\n * This can then be used to move cells to the origin:\r\n *\r\n * (code)\r\n * if (bounds.x < 0 || bounds.y < 0)\r\n * {\r\n *   graph.moveCells(cells, -Math.min(bounds.x, 0), -Math.min(bounds.y, 0))\r\n * }\r\n * (end)\r\n *\r\n * Or to translate the graph view:\r\n *\r\n * (code)\r\n * if (bounds.x < 0 || bounds.y < 0)\r\n * {\r\n *   graph.view.setTranslate(-Math.min(bounds.x, 0), -Math.min(bounds.y, 0));\r\n * }\r\n * (end)\r\n *\r\n * Parameters:\r\n *\r\n * cells - Array of <mxCells> whose bounds should be returned.\r\n * includeEdges - Specifies if edge bounds should be included by computing\r\n * the bounding box for all points in geometry. Default is false.\r\n */\nmxGraph.prototype.getBoundingBoxFromGeometry = function (cells, includeEdges) {\n  includeEdges = includeEdges != null ? includeEdges : false;\n  var result = null;\n  if (cells != null) {\n    for (var i = 0; i < cells.length; i++) {\n      if (includeEdges || this.model.isVertex(cells[i])) {\n        // Computes the bounding box for the points in the geometry\n        var geo = this.getCellGeometry(cells[i]);\n        if (geo != null) {\n          var bbox = null;\n          if (this.model.isEdge(cells[i])) {\n            var pts = geo.points;\n            if (pts != null && pts.length > 0) {\n              var tmp = new _mxRectangle[\"default\"](pts[0].x, pts[0].y, 0, 0);\n              var addPoint = function addPoint(pt) {\n                if (pt != null) {\n                  tmp.add(new _mxRectangle[\"default\"](pt.x, pt.y, 0, 0));\n                }\n              };\n              for (var j = 1; j < pts.length; j++) {\n                addPoint(pts[j]);\n              }\n              addPoint(geo.getTerminalPoint(true));\n              addPoint(geo.getTerminalPoint(false));\n              bbox = tmp;\n            }\n          } else {\n            var parent = this.model.getParent(cells[i]);\n            if (geo.relative) {\n              if (this.model.isVertex(parent) && parent != this.view.currentRoot) {\n                var tmp = this.getBoundingBoxFromGeometry([parent], false);\n                if (tmp != null) {\n                  bbox = new _mxRectangle[\"default\"](geo.x * tmp.width, geo.y * tmp.height, geo.width, geo.height);\n                  if (_mxGraphUtils[\"default\"].indexOf(cells, parent) >= 0) {\n                    bbox.x += tmp.x;\n                    bbox.y += tmp.y;\n                  }\n                }\n              }\n            } else {\n              bbox = _mxRectangle[\"default\"].fromRectangle(geo);\n              if (this.model.isVertex(parent) && _mxGraphUtils[\"default\"].indexOf(cells, parent) >= 0) {\n                var tmp = this.getBoundingBoxFromGeometry([parent], false);\n                if (tmp != null) {\n                  bbox.x += tmp.x;\n                  bbox.y += tmp.y;\n                }\n              }\n            }\n            if (bbox != null && geo.offset != null) {\n              bbox.x += geo.offset.x;\n              bbox.y += geo.offset.y;\n            }\n          }\n          if (bbox != null) {\n            if (result == null) {\n              result = _mxRectangle[\"default\"].fromRectangle(bbox);\n            } else {\n              result.add(bbox);\n            }\n          }\n        }\n      }\n    }\n  }\n  return result;\n};\n\n/**\r\n * Function: refresh\r\n *\r\n * Clears all cell states or the states for the hierarchy starting at the\r\n * given cell and validates the graph. This fires a refresh event as the\r\n * last step.\r\n *\r\n * Parameters:\r\n *\r\n * cell - Optional <mxCell> for which the cell states should be cleared.\r\n */\nmxGraph.prototype.refresh = function (cell) {\n  this.view.clear(cell, cell == null);\n  this.view.validate();\n  this.sizeDidChange();\n  this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].REFRESH));\n};\n\n/**\r\n * Function: snap\r\n *\r\n * Snaps the given numeric value to the grid if <gridEnabled> is true.\r\n *\r\n * Parameters:\r\n *\r\n * value - Numeric value to be snapped to the grid.\r\n */\nmxGraph.prototype.snap = function (value) {\n  if (this.gridEnabled) {\n    value = Math.round(value / this.gridSize) * this.gridSize;\n  }\n  return value;\n};\n\n/**\r\n * Function: panGraph\r\n *\r\n * Shifts the graph display by the given amount. This is used to preview\r\n * panning operations, use <mxGraphView.setTranslate> to set a persistent\r\n * translation of the view. Fires <mxEvent.PAN>.\r\n *\r\n * Parameters:\r\n *\r\n * dx - Amount to shift the graph along the x-axis.\r\n * dy - Amount to shift the graph along the y-axis.\r\n */\nmxGraph.prototype.panGraph = function (dx, dy) {\n  if (this.useScrollbarsForPanning && _mxUtils[\"default\"].hasScrollbars(this.container)) {\n    this.container.scrollLeft = -dx;\n    this.container.scrollTop = -dy;\n  } else {\n    var canvas = this.view.getCanvas();\n    if (this.dialect == _mxConstants[\"default\"].DIALECT_SVG) {\n      // Puts everything inside the container in a DIV so that it\n      // can be moved without changing the state of the container\n      if (dx == 0 && dy == 0) {\n        // Workaround for ignored removeAttribute on SVG element in IE9 standards\n        if (_mxClient[\"default\"].IS_IE) {\n          canvas.setAttribute('transform', 'translate(' + dx + ',' + dy + ')');\n        } else {\n          canvas.removeAttribute('transform');\n        }\n        if (this.shiftPreview1 != null) {\n          var child = this.shiftPreview1.firstChild;\n          while (child != null) {\n            var next = child.nextSibling;\n            this.container.appendChild(child);\n            child = next;\n          }\n          if (this.shiftPreview1.parentNode != null) {\n            this.shiftPreview1.parentNode.removeChild(this.shiftPreview1);\n          }\n          this.shiftPreview1 = null;\n          this.container.appendChild(canvas.parentNode);\n          child = this.shiftPreview2.firstChild;\n          while (child != null) {\n            var next = child.nextSibling;\n            this.container.appendChild(child);\n            child = next;\n          }\n          if (this.shiftPreview2.parentNode != null) {\n            this.shiftPreview2.parentNode.removeChild(this.shiftPreview2);\n          }\n          this.shiftPreview2 = null;\n        }\n      } else {\n        canvas.setAttribute('transform', 'translate(' + dx + ',' + dy + ')');\n        if (this.shiftPreview1 == null) {\n          // Needs two divs for stuff before and after the SVG element\n          this.shiftPreview1 = document.createElement('div');\n          this.shiftPreview1.style.position = 'absolute';\n          this.shiftPreview1.style.overflow = 'visible';\n          this.shiftPreview2 = document.createElement('div');\n          this.shiftPreview2.style.position = 'absolute';\n          this.shiftPreview2.style.overflow = 'visible';\n          var current = this.shiftPreview1;\n          var child = this.container.firstChild;\n          while (child != null) {\n            var next = child.nextSibling;\n\n            // SVG element is moved via transform attribute\n            if (child != canvas.parentNode) {\n              current.appendChild(child);\n            } else {\n              current = this.shiftPreview2;\n            }\n            child = next;\n          }\n\n          // Inserts elements only if not empty\n          if (this.shiftPreview1.firstChild != null) {\n            this.container.insertBefore(this.shiftPreview1, canvas.parentNode);\n          }\n          if (this.shiftPreview2.firstChild != null) {\n            this.container.appendChild(this.shiftPreview2);\n          }\n        }\n        this.shiftPreview1.style.left = dx + 'px';\n        this.shiftPreview1.style.top = dy + 'px';\n        this.shiftPreview2.style.left = dx + 'px';\n        this.shiftPreview2.style.top = dy + 'px';\n      }\n    } else {\n      canvas.style.left = dx + 'px';\n      canvas.style.top = dy + 'px';\n    }\n    this.panDx = dx;\n    this.panDy = dy;\n    this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].PAN));\n  }\n};\n\n/**\r\n * Function: zoomIn\r\n *\r\n * Zooms into the graph by <zoomFactor>.\r\n */\nmxGraph.prototype.zoomIn = function () {\n  this.zoom(this.zoomFactor);\n};\n\n/**\r\n * Function: zoomOut\r\n *\r\n * Zooms out of the graph by <zoomFactor>.\r\n */\nmxGraph.prototype.zoomOut = function () {\n  this.zoom(1 / this.zoomFactor);\n};\n\n/**\r\n * Function: zoomActual\r\n *\r\n * Resets the zoom and panning in the view.\r\n */\nmxGraph.prototype.zoomActual = function () {\n  if (this.view.scale == 1) {\n    this.view.setTranslate(0, 0);\n  } else {\n    this.view.translate.x = 0;\n    this.view.translate.y = 0;\n    this.view.setScale(1);\n  }\n};\n\n/**\r\n * Function: zoomTo\r\n *\r\n * Zooms the graph to the given scale with an optional boolean center\r\n * argument, which is passd to <zoom>.\r\n */\nmxGraph.prototype.zoomTo = function (scale, center) {\n  this.zoom(scale / this.view.scale, center);\n};\n\n/**\r\n * Function: center\r\n *\r\n * Centers the graph in the container.\r\n *\r\n * Parameters:\r\n *\r\n * horizontal - Optional boolean that specifies if the graph should be centered\r\n * horizontally. Default is true.\r\n * vertical - Optional boolean that specifies if the graph should be centered\r\n * vertically. Default is true.\r\n * cx - Optional float that specifies the horizontal center. Default is 0.5.\r\n * cy - Optional float that specifies the vertical center. Default is 0.5.\r\n */\nmxGraph.prototype.center = function (horizontal, vertical, cx, cy) {\n  horizontal = horizontal != null ? horizontal : true;\n  vertical = vertical != null ? vertical : true;\n  cx = cx != null ? cx : 0.5;\n  cy = cy != null ? cy : 0.5;\n  var hasScrollbars = _mxUtils[\"default\"].hasScrollbars(this.container);\n  var cw = this.container.clientWidth;\n  var ch = this.container.clientHeight;\n  var bounds = this.getGraphBounds();\n  var t = this.view.translate;\n  var s = this.view.scale;\n  var dx = horizontal ? cw - bounds.width : 0;\n  var dy = vertical ? ch - bounds.height : 0;\n  if (!hasScrollbars) {\n    this.view.setTranslate(horizontal ? Math.floor(t.x - bounds.x * s + dx * cx / s) : t.x, vertical ? Math.floor(t.y - bounds.y * s + dy * cy / s) : t.y);\n  } else {\n    bounds.x -= t.x;\n    bounds.y -= t.y;\n    var sw = this.container.scrollWidth;\n    var sh = this.container.scrollHeight;\n    if (sw > cw) {\n      dx = 0;\n    }\n    if (sh > ch) {\n      dy = 0;\n    }\n    this.view.setTranslate(Math.floor(dx / 2 - bounds.x), Math.floor(dy / 2 - bounds.y));\n    this.container.scrollLeft = (sw - cw) / 2;\n    this.container.scrollTop = (sh - ch) / 2;\n  }\n};\n\n/**\r\n * Function: zoom\r\n *\r\n * Zooms the graph using the given factor. Center is an optional boolean\r\n * argument that keeps the graph scrolled to the center. If the center argument\r\n * is omitted, then <centerZoom> will be used as its value.\r\n */\nmxGraph.prototype.zoom = function (factor, center) {\n  center = center != null ? center : this.centerZoom;\n  var scale = Math.round(this.view.scale * factor * 100) / 100;\n  var state = this.view.getState(this.getSelectionCell());\n  factor = scale / this.view.scale;\n  if (this.keepSelectionVisibleOnZoom && state != null) {\n    var rect = new _mxRectangle[\"default\"](state.x * factor, state.y * factor, state.width * factor, state.height * factor);\n\n    // Refreshes the display only once if a scroll is carried out\n    this.view.scale = scale;\n    if (!this.scrollRectToVisible(rect)) {\n      this.view.revalidate();\n\n      // Forces an event to be fired but does not revalidate again\n      this.view.setScale(scale);\n    }\n  } else {\n    var hasScrollbars = _mxUtils[\"default\"].hasScrollbars(this.container);\n    if (center && !hasScrollbars) {\n      var dx = this.container.offsetWidth;\n      var dy = this.container.offsetHeight;\n      if (factor > 1) {\n        var f = (factor - 1) / (scale * 2);\n        dx *= -f;\n        dy *= -f;\n      } else {\n        var f = (1 / factor - 1) / (this.view.scale * 2);\n        dx *= f;\n        dy *= f;\n      }\n      this.view.scaleAndTranslate(scale, this.view.translate.x + dx, this.view.translate.y + dy);\n    } else {\n      // Allows for changes of translate and scrollbars during setscale\n      var tx = this.view.translate.x;\n      var ty = this.view.translate.y;\n      var sl = this.container.scrollLeft;\n      var st = this.container.scrollTop;\n      this.view.setScale(scale);\n      if (hasScrollbars) {\n        var dx = 0;\n        var dy = 0;\n        if (center) {\n          dx = this.container.offsetWidth * (factor - 1) / 2;\n          dy = this.container.offsetHeight * (factor - 1) / 2;\n        }\n        this.container.scrollLeft = (this.view.translate.x - tx) * this.view.scale + Math.round(sl * factor + dx);\n        this.container.scrollTop = (this.view.translate.y - ty) * this.view.scale + Math.round(st * factor + dy);\n      }\n    }\n  }\n};\n\n/**\r\n * Function: zoomToRect\r\n *\r\n * Zooms the graph to the specified rectangle. If the rectangle does not have same aspect\r\n * ratio as the display container, it is increased in the smaller relative dimension only\r\n * until the aspect match. The original rectangle is centralised within this expanded one.\r\n *\r\n * Note that the input rectangular must be un-scaled and un-translated.\r\n *\r\n * Parameters:\r\n *\r\n * rect - The un-scaled and un-translated rectangluar region that should be just visible\r\n * after the operation\r\n */\nmxGraph.prototype.zoomToRect = function (rect) {\n  var scaleX = this.container.clientWidth / rect.width;\n  var scaleY = this.container.clientHeight / rect.height;\n  var aspectFactor = scaleX / scaleY;\n\n  // Remove any overlap of the rect outside the client area\n  rect.x = Math.max(0, rect.x);\n  rect.y = Math.max(0, rect.y);\n  var rectRight = Math.min(this.container.scrollWidth, rect.x + rect.width);\n  var rectBottom = Math.min(this.container.scrollHeight, rect.y + rect.height);\n  rect.width = rectRight - rect.x;\n  rect.height = rectBottom - rect.y;\n\n  // The selection area has to be increased to the same aspect\n  // ratio as the container, centred around the centre point of the\n  // original rect passed in.\n  if (aspectFactor < 1.0) {\n    // Height needs increasing\n    var newHeight = rect.height / aspectFactor;\n    var deltaHeightBuffer = (newHeight - rect.height) / 2.0;\n    rect.height = newHeight;\n\n    // Assign up to half the buffer to the upper part of the rect, not crossing 0\n    // put the rest on the bottom\n    var upperBuffer = Math.min(rect.y, deltaHeightBuffer);\n    rect.y = rect.y - upperBuffer;\n\n    // Check if the bottom has extended too far\n    rectBottom = Math.min(this.container.scrollHeight, rect.y + rect.height);\n    rect.height = rectBottom - rect.y;\n  } else {\n    // Width needs increasing\n    var newWidth = rect.width * aspectFactor;\n    var deltaWidthBuffer = (newWidth - rect.width) / 2.0;\n    rect.width = newWidth;\n\n    // Assign up to half the buffer to the upper part of the rect, not crossing 0\n    // put the rest on the bottom\n    var leftBuffer = Math.min(rect.x, deltaWidthBuffer);\n    rect.x = rect.x - leftBuffer;\n\n    // Check if the right hand side has extended too far\n    rectRight = Math.min(this.container.scrollWidth, rect.x + rect.width);\n    rect.width = rectRight - rect.x;\n  }\n  var scale = this.container.clientWidth / rect.width;\n  var newScale = this.view.scale * scale;\n  if (!_mxUtils[\"default\"].hasScrollbars(this.container)) {\n    this.view.scaleAndTranslate(newScale, this.view.translate.x - rect.x / this.view.scale, this.view.translate.y - rect.y / this.view.scale);\n  } else {\n    this.view.setScale(newScale);\n    this.container.scrollLeft = Math.round(rect.x * scale);\n    this.container.scrollTop = Math.round(rect.y * scale);\n  }\n};\n\n/**\r\n * Function: scrollCellToVisible\r\n *\r\n * Pans the graph so that it shows the given cell. Optionally the cell may\r\n * be centered in the container.\r\n *\r\n * To center a given graph if the <container> has no scrollbars, use the following code.\r\n *\r\n * [code]\r\n * var bounds = graph.getGraphBounds();\r\n * graph.view.setTranslate(-bounds.x - (bounds.width - container.clientWidth) / 2,\r\n * \t\t\t\t\t\t   -bounds.y - (bounds.height - container.clientHeight) / 2);\r\n * [/code]\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> to be made visible.\r\n * center - Optional boolean flag. Default is false.\r\n */\nmxGraph.prototype.scrollCellToVisible = function (cell, center) {\n  var x = -this.view.translate.x;\n  var y = -this.view.translate.y;\n  var state = this.view.getState(cell);\n  if (state != null) {\n    var bounds = new _mxRectangle[\"default\"](x + state.x, y + state.y, state.width, state.height);\n    if (center && this.container != null) {\n      var w = this.container.clientWidth;\n      var h = this.container.clientHeight;\n      bounds.x = bounds.getCenterX() - w / 2;\n      bounds.width = w;\n      bounds.y = bounds.getCenterY() - h / 2;\n      bounds.height = h;\n    }\n    var tr = new _mxPoint[\"default\"](this.view.translate.x, this.view.translate.y);\n    if (this.scrollRectToVisible(bounds)) {\n      // Triggers an update via the view's event source\n      var tr2 = new _mxPoint[\"default\"](this.view.translate.x, this.view.translate.y);\n      this.view.translate.x = tr.x;\n      this.view.translate.y = tr.y;\n      this.view.setTranslate(tr2.x, tr2.y);\n    }\n  }\n};\n\n/**\r\n * Function: scrollRectToVisible\r\n *\r\n * Pans the graph so that it shows the given rectangle.\r\n *\r\n * Parameters:\r\n *\r\n * rect - <mxRectangle> to be made visible.\r\n */\nmxGraph.prototype.scrollRectToVisible = function (rect) {\n  var isChanged = false;\n  if (rect != null) {\n    var w = this.container.offsetWidth;\n    var h = this.container.offsetHeight;\n    var widthLimit = Math.min(w, rect.width);\n    var heightLimit = Math.min(h, rect.height);\n    if (_mxUtils[\"default\"].hasScrollbars(this.container)) {\n      var c = this.container;\n      rect.x += this.view.translate.x;\n      rect.y += this.view.translate.y;\n      var dx = c.scrollLeft - rect.x;\n      var ddx = Math.max(dx - c.scrollLeft, 0);\n      if (dx > 0) {\n        c.scrollLeft -= dx + 2;\n      } else {\n        dx = rect.x + widthLimit - c.scrollLeft - c.clientWidth;\n        if (dx > 0) {\n          c.scrollLeft += dx + 2;\n        }\n      }\n      var dy = c.scrollTop - rect.y;\n      var ddy = Math.max(0, dy - c.scrollTop);\n      if (dy > 0) {\n        c.scrollTop -= dy + 2;\n      } else {\n        dy = rect.y + heightLimit - c.scrollTop - c.clientHeight;\n        if (dy > 0) {\n          c.scrollTop += dy + 2;\n        }\n      }\n      if (!this.useScrollbarsForPanning && (ddx != 0 || ddy != 0)) {\n        this.view.setTranslate(ddx, ddy);\n      }\n    } else {\n      var x = -this.view.translate.x;\n      var y = -this.view.translate.y;\n      var s = this.view.scale;\n      if (rect.x + widthLimit > x + w) {\n        this.view.translate.x -= (rect.x + widthLimit - w - x) / s;\n        isChanged = true;\n      }\n      if (rect.y + heightLimit > y + h) {\n        this.view.translate.y -= (rect.y + heightLimit - h - y) / s;\n        isChanged = true;\n      }\n      if (rect.x < x) {\n        this.view.translate.x += (x - rect.x) / s;\n        isChanged = true;\n      }\n      if (rect.y < y) {\n        this.view.translate.y += (y - rect.y) / s;\n        isChanged = true;\n      }\n      if (isChanged) {\n        this.view.refresh();\n\n        // Repaints selection marker (ticket 18)\n        if (this.selectionCellsHandler != null) {\n          this.selectionCellsHandler.refresh();\n        }\n      }\n    }\n  }\n  return isChanged;\n};\n\n/**\r\n * Function: getCellGeometry\r\n *\r\n * Returns the <mxGeometry> for the given cell. This implementation uses\r\n * <mxGraphModel.getGeometry>. Subclasses can override this to implement\r\n * specific geometries for cells in only one graph, that is, it can return\r\n * geometries that depend on the current state of the view.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose geometry should be returned.\r\n */\nmxGraph.prototype.getCellGeometry = function (cell) {\n  return this.model.getGeometry(cell);\n};\n\n/**\r\n * Function: isCellVisible\r\n *\r\n * Returns true if the given cell is visible in this graph. This\r\n * implementation uses <mxGraphModel.isVisible>. Subclassers can override\r\n * this to implement specific visibility for cells in only one graph, that\r\n * is, without affecting the visible state of the cell.\r\n *\r\n * When using dynamic filter expressions for cell visibility, then the\r\n * graph should be revalidated after the filter expression has changed.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose visible state should be returned.\r\n */\nmxGraph.prototype.isCellVisible = function (cell) {\n  return this.model.isVisible(cell);\n};\n\n/**\r\n * Function: isCellCollapsed\r\n *\r\n * Returns true if the given cell is collapsed in this graph. This\r\n * implementation uses <mxGraphModel.isCollapsed>. Subclassers can override\r\n * this to implement specific collapsed states for cells in only one graph,\r\n * that is, without affecting the collapsed state of the cell.\r\n *\r\n * When using dynamic filter expressions for the collapsed state, then the\r\n * graph should be revalidated after the filter expression has changed.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose collapsed state should be returned.\r\n */\nmxGraph.prototype.isCellCollapsed = function (cell) {\n  return this.model.isCollapsed(cell);\n};\n\n/**\r\n * Function: isCellConnectable\r\n *\r\n * Returns true if the given cell is connectable in this graph. This\r\n * implementation uses <mxGraphModel.isConnectable>. Subclassers can override\r\n * this to implement specific connectable states for cells in only one graph,\r\n * that is, without affecting the connectable state of the cell in the model.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose connectable state should be returned.\r\n */\nmxGraph.prototype.isCellConnectable = function (cell) {\n  return this.model.isConnectable(cell);\n};\n\n/**\r\n * Function: isOrthogonal\r\n *\r\n * Returns true if perimeter points should be computed such that the\r\n * resulting edge has only horizontal or vertical segments.\r\n *\r\n * Parameters:\r\n *\r\n * edge - <mxCellState> that represents the edge.\r\n */\nmxGraph.prototype.isOrthogonal = function (edge) {\n  var orthogonal = edge.style[_mxConstants[\"default\"].STYLE_ORTHOGONAL];\n  if (orthogonal != null) {\n    return orthogonal;\n  }\n  var tmp = this.view.getEdgeStyle(edge);\n  return tmp == _mxEdgeStyle[\"default\"].SegmentConnector || tmp == _mxEdgeStyle[\"default\"].ElbowConnector || tmp == _mxEdgeStyle[\"default\"].SideToSide || tmp == _mxEdgeStyle[\"default\"].TopToBottom || tmp == _mxEdgeStyle[\"default\"].EntityRelation || tmp == _mxEdgeStyle[\"default\"].OrthConnector;\n};\n\n/**\r\n * Function: isLoop\r\n *\r\n * Returns true if the given cell state is a loop.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> that represents a potential loop.\r\n */\nmxGraph.prototype.isLoop = function (state) {\n  var src = state.getVisibleTerminalState(true);\n  var trg = state.getVisibleTerminalState(false);\n  return src != null && src == trg;\n};\n\n/**\r\n * Function: isCloneEvent\r\n *\r\n * Returns true if the given event is a clone event. This implementation\r\n * returns true if control is pressed.\r\n */\nmxGraph.prototype.isCloneEvent = function (evt) {\n  return _mxEvent[\"default\"].isControlDown(evt);\n};\n\n/**\r\n * Function: isToggleEvent\r\n *\r\n * Returns true if the given event is a toggle event. This implementation\r\n * returns true if the meta key (Cmd) is pressed on Macs or if control is\r\n * pressed on any other platform.\r\n */\nmxGraph.prototype.isToggleEvent = function (evt) {\n  return _mxClient[\"default\"].IS_MAC ? _mxEvent[\"default\"].isMetaDown(evt) : _mxEvent[\"default\"].isControlDown(evt);\n};\n\n/**\r\n * Function: isGridEnabledEvent\r\n *\r\n * Returns true if the given mouse event should be aligned to the grid.\r\n */\nmxGraph.prototype.isGridEnabledEvent = function (evt) {\n  return evt != null && !_mxEvent[\"default\"].isAltDown(evt);\n};\n\n/**\r\n * Function: isConstrainedEvent\r\n *\r\n * Returns true if the given mouse event should be aligned to the grid.\r\n */\nmxGraph.prototype.isConstrainedEvent = function (evt) {\n  return _mxEvent[\"default\"].isShiftDown(evt);\n};\n\n/**\r\n * Function: isIgnoreTerminalEvent\r\n *\r\n * Returns true if the given mouse event should not allow any connections to be\r\n * made. This implementation returns false.\r\n */\nmxGraph.prototype.isIgnoreTerminalEvent = function (evt) {\n  return false;\n};\n\n/**\r\n * Group: Validation\r\n */\n\n/**\r\n * Function: validationAlert\r\n *\r\n * Displays the given validation error in a dialog. This implementation uses\r\n * mxUtils.alert.\r\n */\nmxGraph.prototype.validationAlert = function (message) {\n  _mxUtils[\"default\"].alert(message);\n};\n\n/**\r\n * Function: isEdgeValid\r\n *\r\n * Checks if the return value of <getEdgeValidationError> for the given\r\n * arguments is null.\r\n *\r\n * Parameters:\r\n *\r\n * edge - <mxCell> that represents the edge to validate.\r\n * source - <mxCell> that represents the source terminal.\r\n * target - <mxCell> that represents the target terminal.\r\n */\nmxGraph.prototype.isEdgeValid = function (edge, source, target) {\n  return this.getEdgeValidationError(edge, source, target) == null;\n};\n\n/**\r\n * Function: getEdgeValidationError\r\n *\r\n * Returns the validation error message to be displayed when inserting or\r\n * changing an edges' connectivity. A return value of null means the edge\r\n * is valid, a return value of '' means it's not valid, but do not display\r\n * an error message. Any other (non-empty) string returned from this method\r\n * is displayed as an error message when trying to connect an edge to a\r\n * source and target. This implementation uses the <multiplicities>, and\r\n * checks <multigraph>, <allowDanglingEdges> and <allowLoops> to generate\r\n * validation errors.\r\n *\r\n * For extending this method with specific checks for source/target cells,\r\n * the method can be extended as follows. Returning an empty string means\r\n * the edge is invalid with no error message, a non-null string specifies\r\n * the error message, and null means the edge is valid.\r\n *\r\n * (code)\r\n * graph.getEdgeValidationError = function(edge, source, target)\r\n * {\r\n *   if (source != null && target != null &&\r\n *     this.model.getValue(source) != null &&\r\n *     this.model.getValue(target) != null)\r\n *   {\r\n *     if (target is not valid for source)\r\n *     {\r\n *       return 'Invalid Target';\r\n *     }\r\n *   }\r\n *\r\n *   // \"Supercall\"\r\n *   return mxGraph.prototype.getEdgeValidationError.apply(this, arguments);\r\n * }\r\n * (end)\r\n *\r\n * Parameters:\r\n *\r\n * edge - <mxCell> that represents the edge to validate.\r\n * source - <mxCell> that represents the source terminal.\r\n * target - <mxCell> that represents the target terminal.\r\n */\nmxGraph.prototype.getEdgeValidationError = function (edge, source, target) {\n  if (edge != null && !this.isAllowDanglingEdges() && (source == null || target == null)) {\n    return '';\n  }\n  if (edge != null && this.model.getTerminal(edge, true) == null && this.model.getTerminal(edge, false) == null) {\n    return null;\n  }\n\n  // Checks if we're dealing with a loop\n  if (!this.allowLoops && source == target && source != null) {\n    return '';\n  }\n\n  // Checks if the connection is generally allowed\n  if (!this.isValidConnection(source, target)) {\n    return '';\n  }\n  if (source != null && target != null) {\n    var error = '';\n\n    // Checks if the cells are already connected\n    // and adds an error message if required\n    if (!this.multigraph) {\n      var tmp = this.model.getEdgesBetween(source, target, true);\n\n      // Checks if the source and target are not connected by another edge\n      if (tmp.length > 1 || tmp.length == 1 && tmp[0] != edge) {\n        error += (_mxResources[\"default\"].get(this.alreadyConnectedResource) || this.alreadyConnectedResource) + '\\n';\n      }\n    }\n\n    // Gets the number of outgoing edges from the source\n    // and the number of incoming edges from the target\n    // without counting the edge being currently changed.\n    var sourceOut = this.model.getDirectedEdgeCount(source, true, edge);\n    var targetIn = this.model.getDirectedEdgeCount(target, false, edge);\n\n    // Checks the change against each multiplicity rule\n    if (this.multiplicities != null) {\n      for (var i = 0; i < this.multiplicities.length; i++) {\n        var err = this.multiplicities[i].check(this, edge, source, target, sourceOut, targetIn);\n        if (err != null) {\n          error += err;\n        }\n      }\n    }\n\n    // Validates the source and target terminals independently\n    var err = this.validateEdge(edge, source, target);\n    if (err != null) {\n      error += err;\n    }\n    return error.length > 0 ? error : null;\n  }\n  return this.allowDanglingEdges ? null : '';\n};\n\n/**\r\n * Function: validateEdge\r\n *\r\n * Hook method for subclassers to return an error message for the given\r\n * edge and terminals. This implementation returns null.\r\n *\r\n * Parameters:\r\n *\r\n * edge - <mxCell> that represents the edge to validate.\r\n * source - <mxCell> that represents the source terminal.\r\n * target - <mxCell> that represents the target terminal.\r\n */\nmxGraph.prototype.validateEdge = function (edge, source, target) {\n  return null;\n};\n\n/**\r\n * Function: validateGraph\r\n *\r\n * Validates the graph by validating each descendant of the given cell or\r\n * the root of the model. Context is an object that contains the validation\r\n * state for the complete validation run. The validation errors are\r\n * attached to their cells using <setCellWarning>. Returns null in the case of\r\n * successful validation or an array of strings (warnings) in the case of\r\n * failed validations.\r\n *\r\n * Paramters:\r\n *\r\n * cell - Optional <mxCell> to start the validation recursion. Default is\r\n * the graph root.\r\n * context - Object that represents the global validation state.\r\n */\nmxGraph.prototype.validateGraph = function (cell, context) {\n  cell = cell != null ? cell : this.model.getRoot();\n  context = context != null ? context : new Object();\n  var isValid = true;\n  var childCount = this.model.getChildCount(cell);\n  for (var i = 0; i < childCount; i++) {\n    var tmp = this.model.getChildAt(cell, i);\n    var ctx = context;\n    if (this.isValidRoot(tmp)) {\n      ctx = new Object();\n    }\n    var warn = this.validateGraph(tmp, ctx);\n    if (warn != null) {\n      this.setCellWarning(tmp, warn.replace(/\\n/g, '<br>'));\n    } else {\n      this.setCellWarning(tmp, null);\n    }\n    isValid = isValid && warn == null;\n  }\n  var warning = '';\n\n  // Adds error for invalid children if collapsed (children invisible)\n  if (this.isCellCollapsed(cell) && !isValid) {\n    warning += (_mxResources[\"default\"].get(this.containsValidationErrorsResource) || this.containsValidationErrorsResource) + '\\n';\n  }\n\n  // Checks edges and cells using the defined multiplicities\n  if (this.model.isEdge(cell)) {\n    warning += this.getEdgeValidationError(cell, this.model.getTerminal(cell, true), this.model.getTerminal(cell, false)) || '';\n  } else {\n    warning += this.getCellValidationError(cell) || '';\n  }\n\n  // Checks custom validation rules\n  var err = this.validateCell(cell, context);\n  if (err != null) {\n    warning += err;\n  }\n\n  // Updates the display with the warning icons\n  // before any potential alerts are displayed.\n  // LATER: Move this into addCellOverlay. Redraw\n  // should check if overlay was added or removed.\n  if (this.model.getParent(cell) == null) {\n    this.view.validate();\n  }\n  return warning.length > 0 || !isValid ? warning : null;\n};\n\n/**\r\n * Function: getCellValidationError\r\n *\r\n * Checks all <multiplicities> that cannot be enforced while the graph is\r\n * being modified, namely, all multiplicities that require a minimum of\r\n * 1 edge.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> for which the multiplicities should be checked.\r\n */\nmxGraph.prototype.getCellValidationError = function (cell) {\n  var outCount = this.model.getDirectedEdgeCount(cell, true);\n  var inCount = this.model.getDirectedEdgeCount(cell, false);\n  var value = this.model.getValue(cell);\n  var error = '';\n  if (this.multiplicities != null) {\n    for (var i = 0; i < this.multiplicities.length; i++) {\n      var rule = this.multiplicities[i];\n      if (rule.source && _mxGraphUtils[\"default\"].isNode(value, rule.type, rule.attr, rule.value) && (rule.max == 0 && outCount > 0 || rule.min == 1 && outCount == 0 || rule.max == 1 && outCount > 1)) {\n        error += rule.countError + '\\n';\n      } else if (!rule.source && _mxGraphUtils[\"default\"].isNode(value, rule.type, rule.attr, rule.value) && (rule.max == 0 && inCount > 0 || rule.min == 1 && inCount == 0 || rule.max == 1 && inCount > 1)) {\n        error += rule.countError + '\\n';\n      }\n    }\n  }\n  return error.length > 0 ? error : null;\n};\n\n/**\r\n * Function: validateCell\r\n *\r\n * Hook method for subclassers to return an error message for the given\r\n * cell and validation context. This implementation returns null. Any HTML\r\n * breaks will be converted to linefeeds in the calling method.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> that represents the cell to validate.\r\n * context - Object that represents the global validation state.\r\n */\nmxGraph.prototype.validateCell = function (cell, context) {\n  return null;\n};\n\n/**\r\n * Group: Graph appearance\r\n */\n\n/**\r\n * Function: getBackgroundImage\r\n *\r\n * Returns the <backgroundImage> as an <mxImage>.\r\n */\nmxGraph.prototype.getBackgroundImage = function () {\n  return this.backgroundImage;\n};\n\n/**\r\n * Function: setBackgroundImage\r\n *\r\n * Sets the new <backgroundImage>.\r\n *\r\n * Parameters:\r\n *\r\n * image - New <mxImage> to be used for the background.\r\n */\nmxGraph.prototype.setBackgroundImage = function (image) {\n  this.backgroundImage = image;\n};\n\n/**\r\n * Function: getFoldingImage\r\n *\r\n * Returns the <mxImage> used to display the collapsed state of\r\n * the specified cell state. This returns null for all edges.\r\n */\nmxGraph.prototype.getFoldingImage = function (state) {\n  if (state != null && this.foldingEnabled && !this.getModel().isEdge(state.cell)) {\n    var tmp = this.isCellCollapsed(state.cell);\n    if (this.isCellFoldable(state.cell, !tmp)) {\n      return tmp ? this.collapsedImage : this.expandedImage;\n    }\n  }\n  return null;\n};\n\n/**\r\n * Function: convertValueToString\r\n *\r\n * Returns the textual representation for the given cell. This\r\n * implementation returns the nodename or string-representation of the user\r\n * object.\r\n *\r\n * Example:\r\n *\r\n * The following returns the label attribute from the cells user\r\n * object if it is an XML node.\r\n *\r\n * (code)\r\n * graph.convertValueToString = function(cell)\r\n * {\r\n * \treturn cell.getAttribute('label');\r\n * }\r\n * (end)\r\n *\r\n * See also: <cellLabelChanged>.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose textual representation should be returned.\r\n */\nmxGraph.prototype.convertValueToString = function (cell) {\n  var value = this.model.getValue(cell);\n  if (value != null) {\n    if (_mxGraphUtils[\"default\"].isNode(value)) {\n      return value.nodeName;\n    } else if (typeof value.toString == 'function') {\n      return value.toString();\n    }\n  }\n  return '';\n};\n\n/**\r\n * Function: getLabel\r\n *\r\n * Returns a string or DOM node that represents the label for the given\r\n * cell. This implementation uses <convertValueToString> if <labelsVisible>\r\n * is true. Otherwise it returns an empty string.\r\n *\r\n * To truncate a label to match the size of the cell, the following code\r\n * can be used.\r\n *\r\n * (code)\r\n * graph.getLabel = function(cell)\r\n * {\r\n *   var label = mxGraph.prototype.getLabel.apply(this, arguments);\r\n *\r\n *   if (label != null && this.model.isVertex(cell))\r\n *   {\r\n *     var geo = this.getCellGeometry(cell);\r\n *\r\n *     if (geo != null)\r\n *     {\r\n *       var max = parseInt(geo.width / 8);\r\n *\r\n *       if (label.length > max)\r\n *       {\r\n *         label = label.substring(0, max)+'...';\r\n *       }\r\n *     }\r\n *   }\r\n *   return mxGraphUtils.htmlEntities(label);\r\n * }\r\n * (end)\r\n *\r\n * A resize listener is needed in the graph to force a repaint of the label\r\n * after a resize.\r\n *\r\n * (code)\r\n * graph.addListener(mxEvent.RESIZE_CELLS, function(sender, evt)\r\n * {\r\n *   var cells = evt.getProperty('cells');\r\n *\r\n *   for (var i = 0; i < cells.length; i++)\r\n *   {\r\n *     this.view.removeState(cells[i]);\r\n *   }\r\n * });\r\n * (end)\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose label should be returned.\r\n */\nmxGraph.prototype.getLabel = function (cell) {\n  var result = '';\n  if (this.labelsVisible && cell != null) {\n    var state = this.view.getState(cell);\n    var style = state != null ? state.style : this.getCellStyle(cell);\n    if (!_mxGraphUtils[\"default\"].getValue(style, _mxConstants[\"default\"].STYLE_NOLABEL, false)) {\n      result = this.convertValueToString(cell);\n    }\n  }\n  return result;\n};\n\n/**\r\n * Function: isHtmlLabel\r\n *\r\n * Returns true if the label must be rendered as HTML markup. The default\r\n * implementation returns <htmlLabels>.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose label should be displayed as HTML markup.\r\n */\nmxGraph.prototype.isHtmlLabel = function (cell) {\n  return this.isHtmlLabels();\n};\n\n/**\r\n * Function: isHtmlLabels\r\n *\r\n * Returns <htmlLabels>.\r\n */\nmxGraph.prototype.isHtmlLabels = function () {\n  return this.htmlLabels;\n};\n\n/**\r\n * Function: setHtmlLabels\r\n *\r\n * Sets <htmlLabels>.\r\n */\nmxGraph.prototype.setHtmlLabels = function (value) {\n  this.htmlLabels = value;\n};\n\n/**\r\n * Function: isWrapping\r\n *\r\n * This enables wrapping for HTML labels.\r\n *\r\n * Returns true if no white-space CSS style directive should be used for\r\n * displaying the given cells label. This implementation returns true if\r\n * <mxConstants.STYLE_WHITE_SPACE> in the style of the given cell is 'wrap'.\r\n *\r\n * This is used as a workaround for IE ignoring the white-space directive\r\n * of child elements if the directive appears in a parent element. It\r\n * should be overridden to return true if a white-space directive is used\r\n * in the HTML markup that represents the given cells label. In order for\r\n * HTML markup to work in labels, <isHtmlLabel> must also return true\r\n * for the given cell.\r\n *\r\n * Example:\r\n *\r\n * (code)\r\n * graph.getLabel = function(cell)\r\n * {\r\n *   var tmp = mxGraph.prototype.getLabel.apply(this, arguments); // \"supercall\"\r\n *\r\n *   if (this.model.isEdge(cell))\r\n *   {\r\n *     tmp = '<div style=\"width: 150px; white-space:normal;\">'+tmp+'</div>';\r\n *   }\r\n *\r\n *   return tmp;\r\n * }\r\n *\r\n * graph.isWrapping = function(state)\r\n * {\r\n * \t return this.model.isEdge(state.cell);\r\n * }\r\n * (end)\r\n *\r\n * Makes sure no edge label is wider than 150 pixels, otherwise the content\r\n * is wrapped. Note: No width must be specified for wrapped vertex labels as\r\n * the vertex defines the width in its geometry.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCell> whose label should be wrapped.\r\n */\nmxGraph.prototype.isWrapping = function (cell) {\n  var state = this.view.getState(cell);\n  var style = state != null ? state.style : this.getCellStyle(cell);\n  return style != null ? style[_mxConstants[\"default\"].STYLE_WHITE_SPACE] == 'wrap' : false;\n};\n\n/**\r\n * Function: isLabelClipped\r\n *\r\n * Returns true if the overflow portion of labels should be hidden. If this\r\n * returns true then vertex labels will be clipped to the size of the vertices.\r\n * This implementation returns true if <mxConstants.STYLE_OVERFLOW> in the\r\n * style of the given cell is 'hidden'.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCell> whose label should be clipped.\r\n */\nmxGraph.prototype.isLabelClipped = function (cell) {\n  var state = this.view.getState(cell);\n  var style = state != null ? state.style : this.getCellStyle(cell);\n  return style != null ? style[_mxConstants[\"default\"].STYLE_OVERFLOW] == 'hidden' : false;\n};\n\n/**\r\n * Function: getTooltip\r\n *\r\n * Returns the string or DOM node that represents the tooltip for the given\r\n * state, node and coordinate pair. This implementation checks if the given\r\n * node is a folding icon or overlay and returns the respective tooltip. If\r\n * this does not result in a tooltip, the handler for the cell is retrieved\r\n * from <selectionCellsHandler> and the optional getTooltipForNode method is\r\n * called. If no special tooltip exists here then <getTooltipForCell> is used\r\n * with the cell in the given state as the argument to return a tooltip for the\r\n * given state.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> whose tooltip should be returned.\r\n * node - DOM node that is currently under the mouse.\r\n * x - X-coordinate of the mouse.\r\n * y - Y-coordinate of the mouse.\r\n */\nmxGraph.prototype.getTooltip = function (state, node, x, y) {\n  var tip = null;\n  if (state != null) {\n    // Checks if the mouse is over the folding icon\n    if (state.control != null && (node == state.control.node || node.parentNode == state.control.node)) {\n      tip = this.collapseExpandResource;\n      tip = _mxGraphUtils[\"default\"].htmlEntities(_mxResources[\"default\"].get(tip) || tip).replace(/\\\\n/g, '<br>');\n    }\n    if (tip == null && state.overlays != null) {\n      state.overlays.visit(function (id, shape) {\n        // LATER: Exit loop if tip is not null\n        if (tip == null && (node == shape.node || node.parentNode == shape.node)) {\n          tip = shape.overlay.toString();\n        }\n      });\n    }\n    if (tip == null) {\n      var handler = this.selectionCellsHandler.getHandler(state.cell);\n      if (handler != null && typeof handler.getTooltipForNode == 'function') {\n        tip = handler.getTooltipForNode(node);\n      }\n    }\n    if (tip == null) {\n      tip = this.getTooltipForCell(state.cell);\n    }\n  }\n  return tip;\n};\n\n/**\r\n * Function: getTooltipForCell\r\n *\r\n * Returns the string or DOM node to be used as the tooltip for the given\r\n * cell. This implementation uses the cells getTooltip function if it\r\n * exists, or else it returns <convertValueToString> for the cell.\r\n *\r\n * Example:\r\n *\r\n * (code)\r\n * graph.getTooltipForCell = function(cell)\r\n * {\r\n *   return 'Hello, World!';\r\n * }\r\n * (end)\r\n *\r\n * Replaces all tooltips with the string Hello, World!\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose tooltip should be returned.\r\n */\nmxGraph.prototype.getTooltipForCell = function (cell) {\n  var tip = null;\n  if (cell != null && cell.getTooltip != null) {\n    tip = cell.getTooltip();\n  } else {\n    tip = this.convertValueToString(cell);\n  }\n  return tip;\n};\n\n/**\r\n * Function: getCursorForMouseEvent\r\n *\r\n * Returns the cursor value to be used for the CSS of the shape for the\r\n * given event. This implementation calls <getCursorForCell>.\r\n *\r\n * Parameters:\r\n *\r\n * me - <mxMouseEvent> whose cursor should be returned.\r\n */\nmxGraph.prototype.getCursorForMouseEvent = function (me) {\n  return this.getCursorForCell(me.getCell());\n};\n\n/**\r\n * Function: getCursorForCell\r\n *\r\n * Returns the cursor value to be used for the CSS of the shape for the\r\n * given cell. This implementation returns null.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose cursor should be returned.\r\n */\nmxGraph.prototype.getCursorForCell = function (cell) {\n  return null;\n};\n\n/**\r\n * Function: getStartSize\r\n *\r\n * Returns the start size of the given swimlane, that is, the width or\r\n * height of the part that contains the title, depending on the\r\n * horizontal style. The return value is an <mxRectangle> with either\r\n * width or height set as appropriate.\r\n *\r\n * Parameters:\r\n *\r\n * swimlane - <mxCell> whose start size should be returned.\r\n */\nmxGraph.prototype.getStartSize = function (swimlane) {\n  var result = new _mxRectangle[\"default\"]();\n  var state = this.view.getState(swimlane);\n  var style = state != null ? state.style : this.getCellStyle(swimlane);\n  if (style != null) {\n    var size = parseInt(_mxGraphUtils[\"default\"].getValue(style, _mxConstants[\"default\"].STYLE_STARTSIZE, _mxConstants[\"default\"].DEFAULT_STARTSIZE));\n    if (_mxGraphUtils[\"default\"].getValue(style, _mxConstants[\"default\"].STYLE_HORIZONTAL, true)) {\n      result.height = size;\n    } else {\n      result.width = size;\n    }\n  }\n  return result;\n};\n\n/**\r\n * Function: getImage\r\n *\r\n * Returns the image URL for the given cell state. This implementation\r\n * returns the value stored under <mxConstants.STYLE_IMAGE> in the cell\r\n * style.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> whose image URL should be returned.\r\n */\nmxGraph.prototype.getImage = function (state) {\n  return state != null && state.style != null ? state.style[_mxConstants[\"default\"].STYLE_IMAGE] : null;\n};\n\n/**\r\n * Function: getVerticalAlign\r\n *\r\n * Returns the vertical alignment for the given cell state. This\r\n * implementation returns the value stored under\r\n * <mxConstants.STYLE_VERTICAL_ALIGN> in the cell style.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> whose vertical alignment should be\r\n * returned.\r\n */\nmxGraph.prototype.getVerticalAlign = function (state) {\n  return state != null && state.style != null ? state.style[_mxConstants[\"default\"].STYLE_VERTICAL_ALIGN] || _mxConstants[\"default\"].ALIGN_MIDDLE : null;\n};\n\n/**\r\n * Function: getIndicatorColor\r\n *\r\n * Returns the indicator color for the given cell state. This\r\n * implementation returns the value stored under\r\n * <mxConstants.STYLE_INDICATOR_COLOR> in the cell style.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> whose indicator color should be\r\n * returned.\r\n */\nmxGraph.prototype.getIndicatorColor = function (state) {\n  return state != null && state.style != null ? state.style[_mxConstants[\"default\"].STYLE_INDICATOR_COLOR] : null;\n};\n\n/**\r\n * Function: getIndicatorGradientColor\r\n *\r\n * Returns the indicator gradient color for the given cell state. This\r\n * implementation returns the value stored under\r\n * <mxConstants.STYLE_INDICATOR_GRADIENTCOLOR> in the cell style.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> whose indicator gradient color should be\r\n * returned.\r\n */\nmxGraph.prototype.getIndicatorGradientColor = function (state) {\n  return state != null && state.style != null ? state.style[_mxConstants[\"default\"].STYLE_INDICATOR_GRADIENTCOLOR] : null;\n};\n\n/**\r\n * Function: getIndicatorShape\r\n *\r\n * Returns the indicator shape for the given cell state. This\r\n * implementation returns the value stored under\r\n * <mxConstants.STYLE_INDICATOR_SHAPE> in the cell style.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> whose indicator shape should be returned.\r\n */\nmxGraph.prototype.getIndicatorShape = function (state) {\n  return state != null && state.style != null ? state.style[_mxConstants[\"default\"].STYLE_INDICATOR_SHAPE] : null;\n};\n\n/**\r\n * Function: getIndicatorImage\r\n *\r\n * Returns the indicator image for the given cell state. This\r\n * implementation returns the value stored under\r\n * <mxConstants.STYLE_INDICATOR_IMAGE> in the cell style.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> whose indicator image should be returned.\r\n */\nmxGraph.prototype.getIndicatorImage = function (state) {\n  return state != null && state.style != null ? state.style[_mxConstants[\"default\"].STYLE_INDICATOR_IMAGE] : null;\n};\n\n/**\r\n * Function: getBorder\r\n *\r\n * Returns the value of <border>.\r\n */\nmxGraph.prototype.getBorder = function () {\n  return this.border;\n};\n\n/**\r\n * Function: setBorder\r\n *\r\n * Sets the value of <border>.\r\n *\r\n * Parameters:\r\n *\r\n * value - Positive integer that represents the border to be used.\r\n */\nmxGraph.prototype.setBorder = function (value) {\n  this.border = value;\n};\n\n/**\r\n * Function: isSwimlane\r\n *\r\n * Returns true if the given cell is a swimlane in the graph. A swimlane is\r\n * a container cell with some specific behaviour. This implementation\r\n * checks if the shape associated with the given cell is a <mxSwimlane>.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> to be checked.\r\n */\nmxGraph.prototype.isSwimlane = function (cell) {\n  if (cell != null) {\n    if (this.model.getParent(cell) != this.model.getRoot()) {\n      var state = this.view.getState(cell);\n      var style = state != null ? state.style : this.getCellStyle(cell);\n      if (style != null && !this.model.isEdge(cell)) {\n        return style[_mxConstants[\"default\"].STYLE_SHAPE] == _mxConstants[\"default\"].SHAPE_SWIMLANE;\n      }\n    }\n  }\n  return false;\n};\n\n/**\r\n * Group: Graph behaviour\r\n */\n\n/**\r\n * Function: isResizeContainer\r\n *\r\n * Returns <resizeContainer>.\r\n */\nmxGraph.prototype.isResizeContainer = function () {\n  return this.resizeContainer;\n};\n\n/**\r\n * Function: setResizeContainer\r\n *\r\n * Sets <resizeContainer>.\r\n *\r\n * Parameters:\r\n *\r\n * value - Boolean indicating if the container should be resized.\r\n */\nmxGraph.prototype.setResizeContainer = function (value) {\n  this.resizeContainer = value;\n};\n\n/**\r\n * Function: isEnabled\r\n *\r\n * Returns true if the graph is <enabled>.\r\n */\nmxGraph.prototype.isEnabled = function () {\n  return this.enabled && !this.animation;\n};\n\n/**\r\n * Function: setEnabled\r\n *\r\n * Specifies if the graph should allow any interactions. This\r\n * implementation updates <enabled>.\r\n *\r\n * Parameters:\r\n *\r\n * value - Boolean indicating if the graph should be enabled.\r\n */\nmxGraph.prototype.setEnabled = function (value) {\n  this.enabled = value;\n};\nmxGraph.prototype.isAnimation = function () {\n  return this.animation;\n};\nmxGraph.prototype.setAnimation = function (animation) {\n  this.animation = animation;\n};\n\n/**\r\n * Function: isEscapeEnabled\r\n *\r\n * Returns <escapeEnabled>.\r\n */\nmxGraph.prototype.isEscapeEnabled = function () {\n  return this.escapeEnabled;\n};\n\n/**\r\n * Function: setEscapeEnabled\r\n *\r\n * Sets <escapeEnabled>.\r\n *\r\n * Parameters:\r\n *\r\n * enabled - Boolean indicating if escape should be enabled.\r\n */\nmxGraph.prototype.setEscapeEnabled = function (value) {\n  this.escapeEnabled = value;\n};\n\n/**\r\n * Function: isInvokesStopCellEditing\r\n *\r\n * Returns <invokesStopCellEditing>.\r\n */\nmxGraph.prototype.isInvokesStopCellEditing = function () {\n  return this.invokesStopCellEditing;\n};\n\n/**\r\n * Function: setInvokesStopCellEditing\r\n *\r\n * Sets <invokesStopCellEditing>.\r\n */\nmxGraph.prototype.setInvokesStopCellEditing = function (value) {\n  this.invokesStopCellEditing = value;\n};\n\n/**\r\n * Function: isEnterStopsCellEditing\r\n *\r\n * Returns <enterStopsCellEditing>.\r\n */\nmxGraph.prototype.isEnterStopsCellEditing = function () {\n  return this.enterStopsCellEditing;\n};\n\n/**\r\n * Function: setEnterStopsCellEditing\r\n *\r\n * Sets <enterStopsCellEditing>.\r\n */\nmxGraph.prototype.setEnterStopsCellEditing = function (value) {\n  this.enterStopsCellEditing = value;\n};\n\n/**\r\n * Function: isCellLocked\r\n *\r\n * Returns true if the given cell may not be moved, sized, bended,\r\n * disconnected, edited or selected. This implementation returns true for\r\n * all vertices with a relative geometry if <locked> is false.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose locked state should be returned.\r\n */\nmxGraph.prototype.isCellLocked = function (cell) {\n  var geometry = this.model.getGeometry(cell);\n  return this.isCellsLocked() || geometry != null && this.model.isVertex(cell) && geometry.relative;\n};\n\n/**\r\n * Function: isCellsLocked\r\n *\r\n * Returns true if the given cell may not be moved, sized, bended,\r\n * disconnected, edited or selected. This implementation returns true for\r\n * all vertices with a relative geometry if <locked> is false.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose locked state should be returned.\r\n */\nmxGraph.prototype.isCellsLocked = function () {\n  return this.cellsLocked;\n};\n\n/**\r\n * Function: setLocked\r\n *\r\n * Sets if any cell may be moved, sized, bended, disconnected, edited or\r\n * selected.\r\n *\r\n * Parameters:\r\n *\r\n * value - Boolean that defines the new value for <cellsLocked>.\r\n */\nmxGraph.prototype.setCellsLocked = function (value) {\n  this.cellsLocked = value;\n};\n\n/**\r\n * Function: getCloneableCells\r\n *\r\n * Returns the cells which may be exported in the given array of cells.\r\n */\nmxGraph.prototype.getCloneableCells = function (cells) {\n  return this.model.filterCells(cells, _mxGraphUtils[\"default\"].bind(this, function (cell) {\n    return this.isCellCloneable(cell);\n  }));\n};\n\n/**\r\n * Function: isCellCloneable\r\n *\r\n * Returns true if the given cell is cloneable. This implementation returns\r\n * <isCellsCloneable> for all cells unless a cell style specifies\r\n * <mxConstants.STYLE_CLONEABLE> to be 0.\r\n *\r\n * Parameters:\r\n *\r\n * cell - Optional <mxCell> whose cloneable state should be returned.\r\n */\nmxGraph.prototype.isCellCloneable = function (cell) {\n  var state = this.view.getState(cell);\n  var style = state != null ? state.style : this.getCellStyle(cell);\n  return this.isCellsCloneable() && style[_mxConstants[\"default\"].STYLE_CLONEABLE] != 0;\n};\n\n/**\r\n * Function: isCellsCloneable\r\n *\r\n * Returns <cellsCloneable>, that is, if the graph allows cloning of cells\r\n * by using control-drag.\r\n */\nmxGraph.prototype.isCellsCloneable = function () {\n  return this.cellsCloneable;\n};\n\n/**\r\n * Function: setCellsCloneable\r\n *\r\n * Specifies if the graph should allow cloning of cells by holding down the\r\n * control key while cells are being moved. This implementation updates\r\n * <cellsCloneable>.\r\n *\r\n * Parameters:\r\n *\r\n * value - Boolean indicating if the graph should be cloneable.\r\n */\nmxGraph.prototype.setCellsCloneable = function (value) {\n  this.cellsCloneable = value;\n};\n\n/**\r\n * Function: getExportableCells\r\n *\r\n * Returns the cells which may be exported in the given array of cells.\r\n */\nmxGraph.prototype.getExportableCells = function (cells) {\n  return this.model.filterCells(cells, _mxGraphUtils[\"default\"].bind(this, function (cell) {\n    return this.canExportCell(cell);\n  }));\n};\n\n/**\r\n * Function: canExportCell\r\n *\r\n * Returns true if the given cell may be exported to the clipboard. This\r\n * implementation returns <exportEnabled> for all cells.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> that represents the cell to be exported.\r\n */\nmxGraph.prototype.canExportCell = function (cell) {\n  return this.exportEnabled;\n};\n\n/**\r\n * Function: getImportableCells\r\n *\r\n * Returns the cells which may be imported in the given array of cells.\r\n */\nmxGraph.prototype.getImportableCells = function (cells) {\n  return this.model.filterCells(cells, _mxGraphUtils[\"default\"].bind(this, function (cell) {\n    return this.canImportCell(cell);\n  }));\n};\n\n/**\r\n * Function: canImportCell\r\n *\r\n * Returns true if the given cell may be imported from the clipboard.\r\n * This implementation returns <importEnabled> for all cells.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> that represents the cell to be imported.\r\n */\nmxGraph.prototype.canImportCell = function (cell) {\n  return this.importEnabled;\n};\n\n/**\r\n * Function: isCellSelectable\r\n *\r\n * Returns true if the given cell is selectable. This implementation\r\n * returns <cellsSelectable>.\r\n *\r\n * To add a new style for making cells (un)selectable, use the following code.\r\n *\r\n * (code)\r\n * mxGraph.prototype.isCellSelectable = function(cell)\r\n * {\r\n *   var state = this.view.getState(cell);\r\n *   var style = (state != null) ? state.style : this.getCellStyle(cell);\r\n *\r\n *   return this.isCellsSelectable() && !this.isCellLocked(cell) && style['selectable'] != 0;\r\n * };\r\n * (end)\r\n *\r\n * You can then use the new style as shown in this example.\r\n *\r\n * (code)\r\n * graph.insertVertex(parent, null, 'Hello,', 20, 20, 80, 30, 'selectable=0');\r\n * (end)\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose selectable state should be returned.\r\n */\nmxGraph.prototype.isCellSelectable = function (cell) {\n  return this.isCellsSelectable();\n};\n\n/**\r\n * Function: isCellsSelectable\r\n *\r\n * Returns <cellsSelectable>.\r\n */\nmxGraph.prototype.isCellsSelectable = function () {\n  return this.cellsSelectable;\n};\n\n/**\r\n * Function: setCellsSelectable\r\n *\r\n * Sets <cellsSelectable>.\r\n */\nmxGraph.prototype.setCellsSelectable = function (value) {\n  this.cellsSelectable = value;\n};\n\n/**\r\n * Function: getDeletableCells\r\n *\r\n * Returns the cells which may be exported in the given array of cells.\r\n */\nmxGraph.prototype.getDeletableCells = function (cells) {\n  return this.model.filterCells(cells, _mxGraphUtils[\"default\"].bind(this, function (cell) {\n    return this.isCellDeletable(cell);\n  }));\n};\n\n/**\r\n * Function: isCellDeletable\r\n *\r\n * Returns true if the given cell is moveable. This returns\r\n * <cellsDeletable> for all given cells if a cells style does not specify\r\n * <mxConstants.STYLE_DELETABLE> to be 0.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose deletable state should be returned.\r\n */\nmxGraph.prototype.isCellDeletable = function (cell) {\n  var state = this.view.getState(cell);\n  var style = state != null ? state.style : this.getCellStyle(cell);\n  return this.isCellsDeletable() && style[_mxConstants[\"default\"].STYLE_DELETABLE] != 0;\n};\n\n/**\r\n * Function: isCellsDeletable\r\n *\r\n * Returns <cellsDeletable>.\r\n */\nmxGraph.prototype.isCellsDeletable = function () {\n  return this.cellsDeletable;\n};\n\n/**\r\n * Function: setCellsDeletable\r\n *\r\n * Sets <cellsDeletable>.\r\n *\r\n * Parameters:\r\n *\r\n * value - Boolean indicating if the graph should allow deletion of cells.\r\n */\nmxGraph.prototype.setCellsDeletable = function (value) {\n  this.cellsDeletable = value;\n};\n\n/**\r\n * Function: isLabelMovable\r\n *\r\n * Returns true if the given edges's label is moveable. This returns\r\n * <movable> for all given cells if <isLocked> does not return true\r\n * for the given cell.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose label should be moved.\r\n */\nmxGraph.prototype.isLabelMovable = function (cell) {\n  return !this.isCellLocked(cell) && (this.model.isEdge(cell) && this.edgeLabelsMovable || this.model.isVertex(cell) && this.vertexLabelsMovable);\n};\n\n/**\r\n * Function: isCellRotatable\r\n *\r\n * Returns true if the given cell is rotatable. This returns true for the given\r\n * cell if its style does not specify <mxConstants.STYLE_ROTATABLE> to be 0.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose rotatable state should be returned.\r\n */\nmxGraph.prototype.isCellRotatable = function (cell) {\n  var state = this.view.getState(cell);\n  var style = state != null ? state.style : this.getCellStyle(cell);\n  return style[_mxConstants[\"default\"].STYLE_ROTATABLE] != 0;\n};\n\n/**\r\n * Function: getMovableCells\r\n *\r\n * Returns the cells which are movable in the given array of cells.\r\n */\nmxGraph.prototype.getMovableCells = function (cells) {\n  return this.model.filterCells(cells, _mxGraphUtils[\"default\"].bind(this, function (cell) {\n    return this.isCellMovable(cell);\n  }));\n};\n\n/**\r\n * Function: isCellMovable\r\n *\r\n * Returns true if the given cell is moveable. This returns <cellsMovable>\r\n * for all given cells if <isCellLocked> does not return true for the given\r\n * cell and its style does not specify <mxConstants.STYLE_MOVABLE> to be 0.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose movable state should be returned.\r\n */\nmxGraph.prototype.isCellMovable = function (cell) {\n  var state = this.view.getState(cell);\n  var style = state != null ? state.style : this.getCellStyle(cell);\n  return this.isCellsMovable() && !this.isCellLocked(cell) && style[_mxConstants[\"default\"].STYLE_MOVABLE] != 0;\n};\n\n/**\r\n * Function: isCellsMovable\r\n *\r\n * Returns <cellsMovable>.\r\n */\nmxGraph.prototype.isCellsMovable = function () {\n  return this.cellsMovable;\n};\n\n/**\r\n * Function: setCellsMovable\r\n *\r\n * Specifies if the graph should allow moving of cells. This implementation\r\n * updates <cellsMsovable>.\r\n *\r\n * Parameters:\r\n *\r\n * value - Boolean indicating if the graph should allow moving of cells.\r\n */\nmxGraph.prototype.setCellsMovable = function (value) {\n  this.cellsMovable = value;\n};\n\n/**\r\n * Function: isGridEnabled\r\n *\r\n * Returns <gridEnabled> as a boolean.\r\n */\nmxGraph.prototype.isGridEnabled = function () {\n  return this.gridEnabled;\n};\n\n/**\r\n * Function: setGridEnabled\r\n *\r\n * Specifies if the grid should be enabled.\r\n *\r\n * Parameters:\r\n *\r\n * value - Boolean indicating if the grid should be enabled.\r\n */\nmxGraph.prototype.setGridEnabled = function (value) {\n  this.gridEnabled = value;\n};\n\n/**\r\n * Function: isPortsEnabled\r\n *\r\n * Returns <portsEnabled> as a boolean.\r\n */\nmxGraph.prototype.isPortsEnabled = function () {\n  return this.portsEnabled;\n};\n\n/**\r\n * Function: setPortsEnabled\r\n *\r\n * Specifies if the ports should be enabled.\r\n *\r\n * Parameters:\r\n *\r\n * value - Boolean indicating if the ports should be enabled.\r\n */\nmxGraph.prototype.setPortsEnabled = function (value) {\n  this.portsEnabled = value;\n};\n\n/**\r\n * Function: getGridSize\r\n *\r\n * Returns <gridSize>.\r\n */\nmxGraph.prototype.getGridSize = function () {\n  return this.gridSize;\n};\n\n/**\r\n * Function: setGridSize\r\n *\r\n * Sets <gridSize>.\r\n */\nmxGraph.prototype.setGridSize = function (value) {\n  this.gridSize = value;\n};\n\n/**\r\n * Function: getTolerance\r\n *\r\n * Returns <tolerance>.\r\n */\nmxGraph.prototype.getTolerance = function () {\n  return this.tolerance;\n};\n\n/**\r\n * Function: setTolerance\r\n *\r\n * Sets <tolerance>.\r\n */\nmxGraph.prototype.setTolerance = function (value) {\n  this.tolerance = value;\n};\n\n/**\r\n * Function: isVertexLabelsMovable\r\n *\r\n * Returns <vertexLabelsMovable>.\r\n */\nmxGraph.prototype.isVertexLabelsMovable = function () {\n  return this.vertexLabelsMovable;\n};\n\n/**\r\n * Function: setVertexLabelsMovable\r\n *\r\n * Sets <vertexLabelsMovable>.\r\n */\nmxGraph.prototype.setVertexLabelsMovable = function (value) {\n  this.vertexLabelsMovable = value;\n};\n\n/**\r\n * Function: isEdgeLabelsMovable\r\n *\r\n * Returns <edgeLabelsMovable>.\r\n */\nmxGraph.prototype.isEdgeLabelsMovable = function () {\n  return this.edgeLabelsMovable;\n};\n\n/**\r\n * Function: isEdgeLabelsMovable\r\n *\r\n * Sets <edgeLabelsMovable>.\r\n */\nmxGraph.prototype.setEdgeLabelsMovable = function (value) {\n  this.edgeLabelsMovable = value;\n};\n\n/**\r\n * Function: isSwimlaneNesting\r\n *\r\n * Returns <swimlaneNesting> as a boolean.\r\n */\nmxGraph.prototype.isSwimlaneNesting = function () {\n  return this.swimlaneNesting;\n};\n\n/**\r\n * Function: setSwimlaneNesting\r\n *\r\n * Specifies if swimlanes can be nested by drag and drop. This is only\r\n * taken into account if dropEnabled is true.\r\n *\r\n * Parameters:\r\n *\r\n * value - Boolean indicating if swimlanes can be nested.\r\n */\nmxGraph.prototype.setSwimlaneNesting = function (value) {\n  this.swimlaneNesting = value;\n};\n\n/**\r\n * Function: isSwimlaneSelectionEnabled\r\n *\r\n * Returns <swimlaneSelectionEnabled> as a boolean.\r\n */\nmxGraph.prototype.isSwimlaneSelectionEnabled = function () {\n  return this.swimlaneSelectionEnabled;\n};\n\n/**\r\n * Function: setSwimlaneSelectionEnabled\r\n *\r\n * Specifies if swimlanes should be selected if the mouse is released\r\n * over their content area.\r\n *\r\n * Parameters:\r\n *\r\n * value - Boolean indicating if swimlanes content areas\r\n * should be selected when the mouse is released over them.\r\n */\nmxGraph.prototype.setSwimlaneSelectionEnabled = function (value) {\n  this.swimlaneSelectionEnabled = value;\n};\n\n/**\r\n * Function: isMultigraph\r\n *\r\n * Returns <multigraph> as a boolean.\r\n */\nmxGraph.prototype.isMultigraph = function () {\n  return this.multigraph;\n};\n\n/**\r\n * Function: setMultigraph\r\n *\r\n * Specifies if the graph should allow multiple connections between the\r\n * same pair of vertices.\r\n *\r\n * Parameters:\r\n *\r\n * value - Boolean indicating if the graph allows multiple connections\r\n * between the same pair of vertices.\r\n */\nmxGraph.prototype.setMultigraph = function (value) {\n  this.multigraph = value;\n};\n\n/**\r\n * Function: isAllowLoops\r\n *\r\n * Returns <allowLoops> as a boolean.\r\n */\nmxGraph.prototype.isAllowLoops = function () {\n  return this.allowLoops;\n};\n\n/**\r\n * Function: setAllowDanglingEdges\r\n *\r\n * Specifies if dangling edges are allowed, that is, if edges are allowed\r\n * that do not have a source and/or target terminal defined.\r\n *\r\n * Parameters:\r\n *\r\n * value - Boolean indicating if dangling edges are allowed.\r\n */\nmxGraph.prototype.setAllowDanglingEdges = function (value) {\n  this.allowDanglingEdges = value;\n};\n\n/**\r\n * Function: isAllowDanglingEdges\r\n *\r\n * Returns <allowDanglingEdges> as a boolean.\r\n */\nmxGraph.prototype.isAllowDanglingEdges = function () {\n  return this.allowDanglingEdges;\n};\n\n/**\r\n * Function: setConnectableEdges\r\n *\r\n * Specifies if edges should be connectable.\r\n *\r\n * Parameters:\r\n *\r\n * value - Boolean indicating if edges should be connectable.\r\n */\nmxGraph.prototype.setConnectableEdges = function (value) {\n  this.connectableEdges = value;\n};\n\n/**\r\n * Function: isConnectableEdges\r\n *\r\n * Returns <connectableEdges> as a boolean.\r\n */\nmxGraph.prototype.isConnectableEdges = function () {\n  return this.connectableEdges;\n};\n\n/**\r\n * Function: setCloneInvalidEdges\r\n *\r\n * Specifies if edges should be inserted when cloned but not valid wrt.\r\n * <getEdgeValidationError>. If false such edges will be silently ignored.\r\n *\r\n * Parameters:\r\n *\r\n * value - Boolean indicating if cloned invalid edges should be\r\n * inserted into the graph or ignored.\r\n */\nmxGraph.prototype.setCloneInvalidEdges = function (value) {\n  this.cloneInvalidEdges = value;\n};\n\n/**\r\n * Function: isCloneInvalidEdges\r\n *\r\n * Returns <cloneInvalidEdges> as a boolean.\r\n */\nmxGraph.prototype.isCloneInvalidEdges = function () {\n  return this.cloneInvalidEdges;\n};\n\n/**\r\n * Function: setAllowLoops\r\n *\r\n * Specifies if loops are allowed.\r\n *\r\n * Parameters:\r\n *\r\n * value - Boolean indicating if loops are allowed.\r\n */\nmxGraph.prototype.setAllowLoops = function (value) {\n  this.allowLoops = value;\n};\n\n/**\r\n * Function: isDisconnectOnMove\r\n *\r\n * Returns <disconnectOnMove> as a boolean.\r\n */\nmxGraph.prototype.isDisconnectOnMove = function () {\n  return this.disconnectOnMove;\n};\n\n/**\r\n * Function: setDisconnectOnMove\r\n *\r\n * Specifies if edges should be disconnected when moved. (Note: Cloned\r\n * edges are always disconnected.)\r\n *\r\n * Parameters:\r\n *\r\n * value - Boolean indicating if edges should be disconnected\r\n * when moved.\r\n */\nmxGraph.prototype.setDisconnectOnMove = function (value) {\n  this.disconnectOnMove = value;\n};\n\n/**\r\n * Function: isDropEnabled\r\n *\r\n * Returns <dropEnabled> as a boolean.\r\n */\nmxGraph.prototype.isDropEnabled = function () {\n  return this.dropEnabled;\n};\n\n/**\r\n * Function: setDropEnabled\r\n *\r\n * Specifies if the graph should allow dropping of cells onto or into other\r\n * cells.\r\n *\r\n * Parameters:\r\n *\r\n * dropEnabled - Boolean indicating if the graph should allow dropping\r\n * of cells into other cells.\r\n */\nmxGraph.prototype.setDropEnabled = function (value) {\n  this.dropEnabled = value;\n};\n\n/**\r\n * Function: isSplitEnabled\r\n *\r\n * Returns <splitEnabled> as a boolean.\r\n */\nmxGraph.prototype.isSplitEnabled = function () {\n  return this.splitEnabled;\n};\n\n/**\r\n * Function: setSplitEnabled\r\n *\r\n * Specifies if the graph should allow dropping of cells onto or into other\r\n * cells.\r\n *\r\n * Parameters:\r\n *\r\n * dropEnabled - Boolean indicating if the graph should allow dropping\r\n * of cells into other cells.\r\n */\nmxGraph.prototype.setSplitEnabled = function (value) {\n  this.splitEnabled = value;\n};\n\n/**\r\n * Function: isCellResizable\r\n *\r\n * Returns true if the given cell is resizable. This returns\r\n * <cellsResizable> for all given cells if <isCellLocked> does not return\r\n * true for the given cell and its style does not specify\r\n * <mxConstants.STYLE_RESIZABLE> to be 0.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose resizable state should be returned.\r\n */\nmxGraph.prototype.isCellResizable = function (cell) {\n  var state = this.view.getState(cell);\n  var style = state != null ? state.style : this.getCellStyle(cell);\n  return this.isCellsResizable() && !this.isCellLocked(cell) && _mxGraphUtils[\"default\"].getValue(style, _mxConstants[\"default\"].STYLE_RESIZABLE, '1') != '0';\n};\n\n/**\r\n * Function: isCellsResizable\r\n *\r\n * Returns <cellsResizable>.\r\n */\nmxGraph.prototype.isCellsResizable = function () {\n  return this.cellsResizable;\n};\n\n/**\r\n * Function: setCellsResizable\r\n *\r\n * Specifies if the graph should allow resizing of cells. This\r\n * implementation updates <cellsResizable>.\r\n *\r\n * Parameters:\r\n *\r\n * value - Boolean indicating if the graph should allow resizing of\r\n * cells.\r\n */\nmxGraph.prototype.setCellsResizable = function (value) {\n  this.cellsResizable = value;\n};\n\n/**\r\n * Function: isTerminalPointMovable\r\n *\r\n * Returns true if the given terminal point is movable. This is independent\r\n * from <isCellConnectable> and <isCellDisconnectable> and controls if terminal\r\n * points can be moved in the graph if the edge is not connected. Note that it\r\n * is required for this to return true to connect unconnected edges. This\r\n * implementation returns true.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose terminal point should be moved.\r\n * source - Boolean indicating if the source or target terminal should be moved.\r\n */\nmxGraph.prototype.isTerminalPointMovable = function (cell, source) {\n  return true;\n};\n\n/**\r\n * Function: isCellBendable\r\n *\r\n * Returns true if the given cell is bendable. This returns <cellsBendable>\r\n * for all given cells if <isLocked> does not return true for the given\r\n * cell and its style does not specify <mxConstants.STYLE_BENDABLE> to be 0.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose bendable state should be returned.\r\n */\nmxGraph.prototype.isCellBendable = function (cell) {\n  var state = this.view.getState(cell);\n  var style = state != null ? state.style : this.getCellStyle(cell);\n  return this.isCellsBendable() && !this.isCellLocked(cell) && style[_mxConstants[\"default\"].STYLE_BENDABLE] != 0;\n};\n\n/**\r\n * Function: isCellsBendable\r\n *\r\n * Returns <cellsBenadable>.\r\n */\nmxGraph.prototype.isCellsBendable = function () {\n  return this.cellsBendable;\n};\n\n/**\r\n * Function: setCellsBendable\r\n *\r\n * Specifies if the graph should allow bending of edges. This\r\n * implementation updates <bendable>.\r\n *\r\n * Parameters:\r\n *\r\n * value - Boolean indicating if the graph should allow bending of\r\n * edges.\r\n */\nmxGraph.prototype.setCellsBendable = function (value) {\n  this.cellsBendable = value;\n};\n\n/**\r\n * Function: isCellEditable\r\n *\r\n * Returns true if the given cell is editable. This returns <cellsEditable> for\r\n * all given cells if <isCellLocked> does not return true for the given cell\r\n * and its style does not specify <mxConstants.STYLE_EDITABLE> to be 0.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose editable state should be returned.\r\n */\nmxGraph.prototype.isCellEditable = function (cell) {\n  var state = this.view.getState(cell);\n  var style = state != null ? state.style : this.getCellStyle(cell);\n  return this.isCellsEditable() && !this.isCellLocked(cell) && style[_mxConstants[\"default\"].STYLE_EDITABLE] != 0;\n};\n\n/**\r\n * Function: isCellsEditable\r\n *\r\n * Returns <cellsEditable>.\r\n */\nmxGraph.prototype.isCellsEditable = function () {\n  return this.cellsEditable;\n};\n\n/**\r\n * Function: setCellsEditable\r\n *\r\n * Specifies if the graph should allow in-place editing for cell labels.\r\n * This implementation updates <cellsEditable>.\r\n *\r\n * Parameters:\r\n *\r\n * value - Boolean indicating if the graph should allow in-place\r\n * editing.\r\n */\nmxGraph.prototype.setCellsEditable = function (value) {\n  this.cellsEditable = value;\n};\n\n/**\r\n * Function: isCellDisconnectable\r\n *\r\n * Returns true if the given cell is disconnectable from the source or\r\n * target terminal. This returns <isCellsDisconnectable> for all given\r\n * cells if <isCellLocked> does not return true for the given cell.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose disconnectable state should be returned.\r\n * terminal - <mxCell> that represents the source or target terminal.\r\n * source - Boolean indicating if the source or target terminal is to be\r\n * disconnected.\r\n */\nmxGraph.prototype.isCellDisconnectable = function (cell, terminal, source) {\n  return this.isCellsDisconnectable() && !this.isCellLocked(cell);\n};\n\n/**\r\n * Function: isCellsDisconnectable\r\n *\r\n * Returns <cellsDisconnectable>.\r\n */\nmxGraph.prototype.isCellsDisconnectable = function () {\n  return this.cellsDisconnectable;\n};\n\n/**\r\n * Function: setCellsDisconnectable\r\n *\r\n * Sets <cellsDisconnectable>.\r\n */\nmxGraph.prototype.setCellsDisconnectable = function (value) {\n  this.cellsDisconnectable = value;\n};\n\n/**\r\n * Function: isValidSource\r\n *\r\n * Returns true if the given cell is a valid source for new connections.\r\n * This implementation returns true for all non-null values and is\r\n * called by is called by <isValidConnection>.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> that represents a possible source or null.\r\n */\nmxGraph.prototype.isValidSource = function (cell) {\n  return cell == null && this.allowDanglingEdges || cell != null && (!this.model.isEdge(cell) || this.connectableEdges) && this.isCellConnectable(cell);\n};\n\n/**\r\n * Function: isValidTarget\r\n *\r\n * Returns <isValidSource> for the given cell. This is called by\r\n * <isValidConnection>.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> that represents a possible target or null.\r\n */\nmxGraph.prototype.isValidTarget = function (cell) {\n  return this.isValidSource(cell);\n};\n\n/**\r\n * Function: isValidConnection\r\n *\r\n * Returns true if the given target cell is a valid target for source.\r\n * This is a boolean implementation for not allowing connections between\r\n * certain pairs of vertices and is called by <getEdgeValidationError>.\r\n * This implementation returns true if <isValidSource> returns true for\r\n * the source and <isValidTarget> returns true for the target.\r\n *\r\n * Parameters:\r\n *\r\n * source - <mxCell> that represents the source cell.\r\n * target - <mxCell> that represents the target cell.\r\n */\nmxGraph.prototype.isValidConnection = function (source, target) {\n  return this.isValidSource(source) && this.isValidTarget(target);\n};\n\n/**\r\n * Function: setConnectable\r\n *\r\n * Specifies if the graph should allow new connections. This implementation\r\n * updates <mxConnectionHandler.enabled> in <connectionHandler>.\r\n *\r\n * Parameters:\r\n *\r\n * connectable - Boolean indicating if new connections should be allowed.\r\n */\nmxGraph.prototype.setConnectable = function (connectable) {\n  this.connectionHandler.setEnabled(connectable);\n};\n\n/**\r\n * Function: isConnectable\r\n *\r\n * Returns true if the <connectionHandler> is enabled.\r\n */\nmxGraph.prototype.isConnectable = function (connectable) {\n  return this.connectionHandler.isEnabled();\n};\n\n/**\r\n * Function: setTooltips\r\n *\r\n * Specifies if tooltips should be enabled. This implementation updates\r\n * <mxTooltipHandler.enabled> in <tooltipHandler>.\r\n *\r\n * Parameters:\r\n *\r\n * enabled - Boolean indicating if tooltips should be enabled.\r\n */\nmxGraph.prototype.setTooltips = function (enabled) {\n  this.tooltipHandler.setEnabled(enabled);\n};\n\n/**\r\n * Function: setPanning\r\n *\r\n * Specifies if panning should be enabled. This implementation updates\r\n * <mxPanningHandler.panningEnabled> in <panningHandler>.\r\n *\r\n * Parameters:\r\n *\r\n * enabled - Boolean indicating if panning should be enabled.\r\n */\nmxGraph.prototype.setPanning = function (enabled) {\n  this.panningHandler.panningEnabled = enabled;\n};\n\n/**\r\n * Function: isEditing\r\n *\r\n * Returns true if the given cell is currently being edited.\r\n * If no cell is specified then this returns true if any\r\n * cell is currently being edited.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> that should be checked.\r\n */\nmxGraph.prototype.isEditing = function (cell) {\n  if (this.cellEditor != null) {\n    var editingCell = this.cellEditor.getEditingCell();\n    return cell == null ? editingCell != null : cell == editingCell;\n  }\n  return false;\n};\n\n/**\r\n * Function: isAutoSizeCell\r\n *\r\n * Returns true if the size of the given cell should automatically be\r\n * updated after a change of the label. This implementation returns\r\n * <autoSizeCells> or checks if the cell style does specify\r\n * <mxConstants.STYLE_AUTOSIZE> to be 1.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> that should be resized.\r\n */\nmxGraph.prototype.isAutoSizeCell = function (cell) {\n  var state = this.view.getState(cell);\n  var style = state != null ? state.style : this.getCellStyle(cell);\n  return this.isAutoSizeCells() || style[_mxConstants[\"default\"].STYLE_AUTOSIZE] == 1;\n};\n\n/**\r\n * Function: isAutoSizeCells\r\n *\r\n * Returns <autoSizeCells>.\r\n */\nmxGraph.prototype.isAutoSizeCells = function () {\n  return this.autoSizeCells;\n};\n\n/**\r\n * Function: setAutoSizeCells\r\n *\r\n * Specifies if cell sizes should be automatically updated after a label\r\n * change. This implementation sets <autoSizeCells> to the given parameter.\r\n * To update the size of cells when the cells are added, set\r\n * <autoSizeCellsOnAdd> to true.\r\n *\r\n * Parameters:\r\n *\r\n * value - Boolean indicating if cells should be resized\r\n * automatically.\r\n */\nmxGraph.prototype.setAutoSizeCells = function (value) {\n  this.autoSizeCells = value;\n};\n\n/**\r\n * Function: isExtendParent\r\n *\r\n * Returns true if the parent of the given cell should be extended if the\r\n * child has been resized so that it overlaps the parent. This\r\n * implementation returns <isExtendParents> if the cell is not an edge.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> that has been resized.\r\n */\nmxGraph.prototype.isExtendParent = function (cell) {\n  return !this.getModel().isEdge(cell) && this.isExtendParents();\n};\n\n/**\r\n * Function: isExtendParents\r\n *\r\n * Returns <extendParents>.\r\n */\nmxGraph.prototype.isExtendParents = function () {\n  return this.extendParents;\n};\n\n/**\r\n * Function: setExtendParents\r\n *\r\n * Sets <extendParents>.\r\n *\r\n * Parameters:\r\n *\r\n * value - New boolean value for <extendParents>.\r\n */\nmxGraph.prototype.setExtendParents = function (value) {\n  this.extendParents = value;\n};\n\n/**\r\n * Function: isExtendParentsOnAdd\r\n *\r\n * Returns <extendParentsOnAdd>.\r\n */\nmxGraph.prototype.isExtendParentsOnAdd = function (cell) {\n  return this.extendParentsOnAdd;\n};\n\n/**\r\n * Function: setExtendParentsOnAdd\r\n *\r\n * Sets <extendParentsOnAdd>.\r\n *\r\n * Parameters:\r\n *\r\n * value - New boolean value for <extendParentsOnAdd>.\r\n */\nmxGraph.prototype.setExtendParentsOnAdd = function (value) {\n  this.extendParentsOnAdd = value;\n};\n\n/**\r\n * Function: isExtendParentsOnMove\r\n *\r\n * Returns <extendParentsOnAdd>.\r\n */\nmxGraph.prototype.isExtendParentsOnMove = function () {\n  return this.extendParentsOnMove;\n};\n\n/**\r\n * Function: setExtendParentsOnMove\r\n *\r\n * Sets <extendParentsOnAdd>.\r\n *\r\n * Parameters:\r\n *\r\n * value - New boolean value for <extendParentsOnAdd>.\r\n */\nmxGraph.prototype.setExtendParentsOnMove = function (value) {\n  this.extendParentsOnMove = value;\n};\n\n/**\r\n * Function: isRecursiveResize\r\n *\r\n * Returns <recursiveResize>.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> that is being resized.\r\n */\nmxGraph.prototype.isRecursiveResize = function (state) {\n  return this.recursiveResize;\n};\n\n/**\r\n * Function: setRecursiveResize\r\n *\r\n * Sets <recursiveResize>.\r\n *\r\n * Parameters:\r\n *\r\n * value - New boolean value for <recursiveResize>.\r\n */\nmxGraph.prototype.setRecursiveResize = function (value) {\n  this.recursiveResize = value;\n};\n\n/**\r\n * Function: isConstrainChild\r\n *\r\n * Returns true if the given cell should be kept inside the bounds of its\r\n * parent according to the rules defined by <getOverlap> and\r\n * <isAllowOverlapParent>. This implementation returns false for all children\r\n * of edges and <isConstrainChildren> otherwise.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> that should be constrained.\r\n */\nmxGraph.prototype.isConstrainChild = function (cell) {\n  return this.isConstrainChildren() && !this.getModel().isEdge(this.getModel().getParent(cell));\n};\n\n/**\r\n * Function: isConstrainChildren\r\n *\r\n * Returns <constrainChildren>.\r\n */\nmxGraph.prototype.isConstrainChildren = function () {\n  return this.constrainChildren;\n};\n\n/**\r\n * Function: setConstrainChildren\r\n *\r\n * Sets <constrainChildren>.\r\n */\nmxGraph.prototype.setConstrainChildren = function (value) {\n  this.constrainChildren = value;\n};\n\n/**\r\n * Function: isConstrainRelativeChildren\r\n *\r\n * Returns <constrainRelativeChildren>.\r\n */\nmxGraph.prototype.isConstrainRelativeChildren = function () {\n  return this.constrainRelativeChildren;\n};\n\n/**\r\n * Function: setConstrainRelativeChildren\r\n *\r\n * Sets <constrainRelativeChildren>.\r\n */\nmxGraph.prototype.setConstrainRelativeChildren = function (value) {\n  this.constrainRelativeChildren = value;\n};\n\n/**\r\n * Function: isConstrainChildren\r\n *\r\n * Returns <allowNegativeCoordinates>.\r\n */\nmxGraph.prototype.isAllowNegativeCoordinates = function () {\n  return this.allowNegativeCoordinates;\n};\n\n/**\r\n * Function: setConstrainChildren\r\n *\r\n * Sets <allowNegativeCoordinates>.\r\n */\nmxGraph.prototype.setAllowNegativeCoordinates = function (value) {\n  this.allowNegativeCoordinates = value;\n};\n\n/**\r\n * Function: getOverlap\r\n *\r\n * Returns a decimal number representing the amount of the width and height\r\n * of the given cell that is allowed to overlap its parent. A value of 0\r\n * means all children must stay inside the parent, 1 means the child is\r\n * allowed to be placed outside of the parent such that it touches one of\r\n * the parents sides. If <isAllowOverlapParent> returns false for the given\r\n * cell, then this method returns 0.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> for which the overlap ratio should be returned.\r\n */\nmxGraph.prototype.getOverlap = function (cell) {\n  return this.isAllowOverlapParent(cell) ? this.defaultOverlap : 0;\n};\n\n/**\r\n * Function: isAllowOverlapParent\r\n *\r\n * Returns true if the given cell is allowed to be placed outside of the\r\n * parents area.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> that represents the child to be checked.\r\n */\nmxGraph.prototype.isAllowOverlapParent = function (cell) {\n  return false;\n};\n\n/**\r\n * Function: getFoldableCells\r\n *\r\n * Returns the cells which are movable in the given array of cells.\r\n */\nmxGraph.prototype.getFoldableCells = function (cells, collapse) {\n  return this.model.filterCells(cells, _mxGraphUtils[\"default\"].bind(this, function (cell) {\n    return this.isCellFoldable(cell, collapse);\n  }));\n};\n\n/**\r\n * Function: isCellFoldable\r\n *\r\n * Returns true if the given cell is foldable. This implementation\r\n * returns true if the cell has at least one child and its style\r\n * does not specify <mxConstants.STYLE_FOLDABLE> to be 0.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose foldable state should be returned.\r\n */\nmxGraph.prototype.isCellFoldable = function (cell, collapse) {\n  var state = this.view.getState(cell);\n  var style = state != null ? state.style : this.getCellStyle(cell);\n  return this.model.getChildCount(cell) > 0 && style[_mxConstants[\"default\"].STYLE_FOLDABLE] != 0;\n};\n\n/**\r\n * Function: isValidDropTarget\r\n *\r\n * Returns true if the given cell is a valid drop target for the specified\r\n * cells. If <splitEnabled> is true then this returns <isSplitTarget> for\r\n * the given arguments else it returns true if the cell is not collapsed\r\n * and its child count is greater than 0.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> that represents the possible drop target.\r\n * cells - <mxCells> that should be dropped into the target.\r\n * evt - Mouseevent that triggered the invocation.\r\n */\nmxGraph.prototype.isValidDropTarget = function (cell, cells, evt) {\n  return cell != null && (this.isSplitEnabled() && this.isSplitTarget(cell, cells, evt) || !this.model.isEdge(cell) && (this.isSwimlane(cell) || this.model.getChildCount(cell) > 0 && !this.isCellCollapsed(cell)));\n};\n\n/**\r\n * Function: isSplitTarget\r\n *\r\n * Returns true if the given edge may be splitted into two edges with the\r\n * given cell as a new terminal between the two.\r\n *\r\n * Parameters:\r\n *\r\n * target - <mxCell> that represents the edge to be splitted.\r\n * cells - <mxCells> that should split the edge.\r\n * evt - Mouseevent that triggered the invocation.\r\n */\nmxGraph.prototype.isSplitTarget = function (target, cells, evt) {\n  if (this.model.isEdge(target) && cells != null && cells.length == 1 && this.isCellConnectable(cells[0]) && this.getEdgeValidationError(target, this.model.getTerminal(target, true), cells[0]) == null) {\n    var src = this.model.getTerminal(target, true);\n    var trg = this.model.getTerminal(target, false);\n    return !this.model.isAncestor(cells[0], src) && !this.model.isAncestor(cells[0], trg);\n  }\n  return false;\n};\n\n/**\r\n * Function: getDropTarget\r\n *\r\n * Returns the given cell if it is a drop target for the given cells or the\r\n * nearest ancestor that may be used as a drop target for the given cells.\r\n * If the given array contains a swimlane and <swimlaneNesting> is false\r\n * then this always returns null. If no cell is given, then the bottommost\r\n * swimlane at the location of the given event is returned.\r\n *\r\n * This function should only be used if <isDropEnabled> returns true.\r\n *\r\n * Parameters:\r\n *\r\n * cells - Array of <mxCells> which are to be dropped onto the target.\r\n * evt - Mouseevent for the drag and drop.\r\n * cell - <mxCell> that is under the mousepointer.\r\n * clone - Optional boolean to indicate of cells will be cloned.\r\n */\nmxGraph.prototype.getDropTarget = function (cells, evt, cell, clone) {\n  if (!this.isSwimlaneNesting()) {\n    for (var i = 0; i < cells.length; i++) {\n      if (this.isSwimlane(cells[i])) {\n        return null;\n      }\n    }\n  }\n  var pt = _mxUtils[\"default\"].convertPoint(this.container, _mxEvent[\"default\"].getClientX(evt), _mxEvent[\"default\"].getClientY(evt));\n  pt.x -= this.panDx;\n  pt.y -= this.panDy;\n  var swimlane = this.getSwimlaneAt(pt.x, pt.y);\n  if (cell == null) {\n    cell = swimlane;\n  } else if (swimlane != null) {\n    // Checks if the cell is an ancestor of the swimlane\n    // under the mouse and uses the swimlane in that case\n    var tmp = this.model.getParent(swimlane);\n    while (tmp != null && this.isSwimlane(tmp) && tmp != cell) {\n      tmp = this.model.getParent(tmp);\n    }\n    if (tmp == cell) {\n      cell = swimlane;\n    }\n  }\n  while (cell != null && !this.isValidDropTarget(cell, cells, evt) && !this.model.isLayer(cell)) {\n    cell = this.model.getParent(cell);\n  }\n\n  // Checks if parent is dropped into child if not cloning\n  if (clone == null || !clone) {\n    var parent = cell;\n    while (parent != null && _mxGraphUtils[\"default\"].indexOf(cells, parent) < 0) {\n      parent = this.model.getParent(parent);\n    }\n  }\n  return !this.model.isLayer(cell) && parent == null ? cell : null;\n};\n\n/**\r\n * Group: Cell retrieval\r\n */\n\n/**\r\n * Function: getDefaultParent\r\n *\r\n * Returns <defaultParent> or <mxGraphView.currentRoot> or the first child\r\n * child of <mxGraphModel.root> if both are null. The value returned by\r\n * this function should be used as the parent for new cells (aka default\r\n * layer).\r\n */\nmxGraph.prototype.getDefaultParent = function () {\n  var parent = this.getCurrentRoot();\n  if (parent == null) {\n    parent = this.defaultParent;\n    if (parent == null) {\n      var root = this.model.getRoot();\n      parent = this.model.getChildAt(root, 0);\n    }\n  }\n  return parent;\n};\n\n/**\r\n * Function: setDefaultParent\r\n *\r\n * Sets the <defaultParent> to the given cell. Set this to null to return\r\n * the first child of the root in getDefaultParent.\r\n */\nmxGraph.prototype.setDefaultParent = function (cell) {\n  this.defaultParent = cell;\n};\n\n/**\r\n * Function: getSwimlane\r\n *\r\n * Returns the nearest ancestor of the given cell which is a swimlane, or\r\n * the given cell, if it is itself a swimlane.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> for which the ancestor swimlane should be returned.\r\n */\nmxGraph.prototype.getSwimlane = function (cell) {\n  while (cell != null && !this.isSwimlane(cell)) {\n    cell = this.model.getParent(cell);\n  }\n  return cell;\n};\n\n/**\r\n * Function: getSwimlaneAt\r\n *\r\n * Returns the bottom-most swimlane that intersects the given point (x, y)\r\n * in the cell hierarchy that starts at the given parent.\r\n *\r\n * Parameters:\r\n *\r\n * x - X-coordinate of the location to be checked.\r\n * y - Y-coordinate of the location to be checked.\r\n * parent - <mxCell> that should be used as the root of the recursion.\r\n * Default is <defaultParent>.\r\n */\nmxGraph.prototype.getSwimlaneAt = function (x, y, parent) {\n  parent = parent || this.getDefaultParent();\n  if (parent != null) {\n    var childCount = this.model.getChildCount(parent);\n    for (var i = 0; i < childCount; i++) {\n      var child = this.model.getChildAt(parent, i);\n      var result = this.getSwimlaneAt(x, y, child);\n      if (result != null) {\n        return result;\n      } else if (this.isSwimlane(child)) {\n        var state = this.view.getState(child);\n        if (this.intersects(state, x, y)) {\n          return child;\n        }\n      }\n    }\n  }\n  return null;\n};\n\n/**\r\n * Function: getCellAt\r\n *\r\n * Returns the bottom-most cell that intersects the given point (x, y) in\r\n * the cell hierarchy starting at the given parent. This will also return\r\n * swimlanes if the given location intersects the content area of the\r\n * swimlane. If this is not desired, then the <hitsSwimlaneContent> may be\r\n * used if the returned cell is a swimlane to determine if the location\r\n * is inside the content area or on the actual title of the swimlane.\r\n *\r\n * Parameters:\r\n *\r\n * x - X-coordinate of the location to be checked.\r\n * y - Y-coordinate of the location to be checked.\r\n * parent - <mxCell> that should be used as the root of the recursion.\r\n * Default is current root of the view or the root of the model.\r\n * vertices - Optional boolean indicating if vertices should be returned.\r\n * Default is true.\r\n * edges - Optional boolean indicating if edges should be returned. Default\r\n * is true.\r\n * ignoreFn - Optional function that returns true if cell should be ignored.\r\n * The function is passed the cell state and the x and y parameter.\r\n */\nmxGraph.prototype.getCellAt = function (x, y, parent, vertices, edges, ignoreFn) {\n  vertices = vertices != null ? vertices : true;\n  edges = edges != null ? edges : true;\n  if (parent == null) {\n    parent = this.getCurrentRoot();\n    if (parent == null) {\n      parent = this.getModel().getRoot();\n    }\n  }\n  if (parent != null) {\n    var childCount = this.model.getChildCount(parent);\n    for (var i = childCount - 1; i >= 0; i--) {\n      var cell = this.model.getChildAt(parent, i);\n      var result = this.getCellAt(x, y, cell, vertices, edges, ignoreFn);\n      if (result != null) {\n        return result;\n      } else if (this.isCellVisible(cell) && (edges && this.model.isEdge(cell) || vertices && this.model.isVertex(cell))) {\n        var state = this.view.getState(cell);\n        if (state != null && (ignoreFn == null || !ignoreFn(state, x, y)) && this.intersects(state, x, y)) {\n          return cell;\n        }\n      }\n    }\n  }\n  return null;\n};\n\n/**\r\n * Function: intersects\r\n *\r\n * Returns the bottom-most cell that intersects the given point (x, y) in\r\n * the cell hierarchy that starts at the given parent.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> that represents the cell state.\r\n * x - X-coordinate of the location to be checked.\r\n * y - Y-coordinate of the location to be checked.\r\n */\nmxGraph.prototype.intersects = function (state, x, y) {\n  if (state != null) {\n    var pts = state.absolutePoints;\n    if (pts != null) {\n      var t2 = this.tolerance * this.tolerance;\n      var pt = pts[0];\n      for (var i = 1; i < pts.length; i++) {\n        var next = pts[i];\n        var dist = _mxUtils[\"default\"].ptSegDistSq(pt.x, pt.y, next.x, next.y, x, y);\n        if (dist <= t2) {\n          return true;\n        }\n        pt = next;\n      }\n    } else {\n      var alpha = _mxUtils[\"default\"].toRadians(_mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_ROTATION) || 0);\n      if (alpha != 0) {\n        var cos = Math.cos(-alpha);\n        var sin = Math.sin(-alpha);\n        var cx = new _mxPoint[\"default\"](state.getCenterX(), state.getCenterY());\n        var pt = _mxUtils[\"default\"].getRotatedPoint(new _mxPoint[\"default\"](x, y), cos, sin, cx);\n        x = pt.x;\n        y = pt.y;\n      }\n      if (_mxUtils[\"default\"].contains(state, x, y)) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/**\r\n * Function: hitsSwimlaneContent\r\n *\r\n * Returns true if the given coordinate pair is inside the content\r\n * are of the given swimlane.\r\n *\r\n * Parameters:\r\n *\r\n * swimlane - <mxCell> that specifies the swimlane.\r\n * x - X-coordinate of the mouse event.\r\n * y - Y-coordinate of the mouse event.\r\n */\nmxGraph.prototype.hitsSwimlaneContent = function (swimlane, x, y) {\n  var state = this.getView().getState(swimlane);\n  var size = this.getStartSize(swimlane);\n  if (state != null) {\n    var scale = this.getView().getScale();\n    x -= state.x;\n    y -= state.y;\n    if (size.width > 0 && x > 0 && x > size.width * scale) {\n      return true;\n    } else if (size.height > 0 && y > 0 && y > size.height * scale) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\r\n * Function: getChildVertices\r\n *\r\n * Returns the visible child vertices of the given parent.\r\n *\r\n * Parameters:\r\n *\r\n * parent - <mxCell> whose children should be returned.\r\n */\nmxGraph.prototype.getChildVertices = function (parent) {\n  return this.getChildCells(parent, true, false);\n};\n\n/**\r\n * Function: getChildEdges\r\n *\r\n * Returns the visible child edges of the given parent.\r\n *\r\n * Parameters:\r\n *\r\n * parent - <mxCell> whose child vertices should be returned.\r\n */\nmxGraph.prototype.getChildEdges = function (parent) {\n  return this.getChildCells(parent, false, true);\n};\n\n/**\r\n * Function: getChildCells\r\n *\r\n * Returns the visible child vertices or edges in the given parent. If\r\n * vertices and edges is false, then all children are returned.\r\n *\r\n * Parameters:\r\n *\r\n * parent - <mxCell> whose children should be returned.\r\n * vertices - Optional boolean that specifies if child vertices should\r\n * be returned. Default is false.\r\n * edges - Optional boolean that specifies if child edges should\r\n * be returned. Default is false.\r\n */\nmxGraph.prototype.getChildCells = function (parent, vertices, edges) {\n  parent = parent != null ? parent : this.getDefaultParent();\n  vertices = vertices != null ? vertices : false;\n  edges = edges != null ? edges : false;\n  var cells = this.model.getChildCells(parent, vertices, edges);\n  var result = [];\n\n  // Filters out the non-visible child cells\n  for (var i = 0; i < cells.length; i++) {\n    if (this.isCellVisible(cells[i])) {\n      result.push(cells[i]);\n    }\n  }\n  return result;\n};\n\n/**\r\n * Function: getConnections\r\n *\r\n * Returns all visible edges connected to the given cell without loops.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose connections should be returned.\r\n * parent - Optional parent of the opposite end for a connection to be\r\n * returned.\r\n */\nmxGraph.prototype.getConnections = function (cell, parent) {\n  return this.getEdges(cell, parent, true, true, false);\n};\n\n/**\r\n * Function: getIncomingEdges\r\n *\r\n * Returns the visible incoming edges for the given cell. If the optional\r\n * parent argument is specified, then only child edges of the given parent\r\n * are returned.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose incoming edges should be returned.\r\n * parent - Optional parent of the opposite end for an edge to be\r\n * returned.\r\n */\nmxGraph.prototype.getIncomingEdges = function (cell, parent) {\n  return this.getEdges(cell, parent, true, false, false);\n};\n\n/**\r\n * Function: getOutgoingEdges\r\n *\r\n * Returns the visible outgoing edges for the given cell. If the optional\r\n * parent argument is specified, then only child edges of the given parent\r\n * are returned.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose outgoing edges should be returned.\r\n * parent - Optional parent of the opposite end for an edge to be\r\n * returned.\r\n */\nmxGraph.prototype.getOutgoingEdges = function (cell, parent) {\n  return this.getEdges(cell, parent, false, true, false);\n};\n\n/**\r\n * Function: getEdges\r\n *\r\n * Returns the incoming and/or outgoing edges for the given cell.\r\n * If the optional parent argument is specified, then only edges are returned\r\n * where the opposite is in the given parent cell. If at least one of incoming\r\n * or outgoing is true, then loops are ignored, if both are false, then all\r\n * edges connected to the given cell are returned including loops.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose edges should be returned.\r\n * parent - Optional parent of the opposite end for an edge to be\r\n * returned.\r\n * incoming - Optional boolean that specifies if incoming edges should\r\n * be included in the result. Default is true.\r\n * outgoing - Optional boolean that specifies if outgoing edges should\r\n * be included in the result. Default is true.\r\n * includeLoops - Optional boolean that specifies if loops should be\r\n * included in the result. Default is true.\r\n * recurse - Optional boolean the specifies if the parent specified only\r\n * need be an ancestral parent, true, or the direct parent, false.\r\n * Default is false\r\n */\nmxGraph.prototype.getEdges = function (cell, parent, incoming, outgoing, includeLoops, recurse) {\n  incoming = incoming != null ? incoming : true;\n  outgoing = outgoing != null ? outgoing : true;\n  includeLoops = includeLoops != null ? includeLoops : true;\n  recurse = recurse != null ? recurse : false;\n  var edges = [];\n  var isCollapsed = this.isCellCollapsed(cell);\n  var childCount = this.model.getChildCount(cell);\n  for (var i = 0; i < childCount; i++) {\n    var child = this.model.getChildAt(cell, i);\n    if (isCollapsed || !this.isCellVisible(child)) {\n      edges = edges.concat(this.model.getEdges(child, incoming, outgoing));\n    }\n  }\n  edges = edges.concat(this.model.getEdges(cell, incoming, outgoing));\n  var result = [];\n  for (var i = 0; i < edges.length; i++) {\n    var state = this.view.getState(edges[i]);\n    var source = state != null ? state.getVisibleTerminal(true) : this.view.getVisibleTerminal(edges[i], true);\n    var target = state != null ? state.getVisibleTerminal(false) : this.view.getVisibleTerminal(edges[i], false);\n    if (includeLoops && source == target || source != target && (incoming && target == cell && (parent == null || this.isValidAncestor(source, parent, recurse)) || outgoing && source == cell && (parent == null || this.isValidAncestor(target, parent, recurse)))) {\n      result.push(edges[i]);\n    }\n  }\n  return result;\n};\n\n/**\r\n * Function: isValidAncestor\r\n *\r\n * Returns whether or not the specified parent is a valid\r\n * ancestor of the specified cell, either direct or indirectly\r\n * based on whether ancestor recursion is enabled.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> the possible child cell\r\n * parent - <mxCell> the possible parent cell\r\n * recurse - boolean whether or not to recurse the child ancestors\r\n */\nmxGraph.prototype.isValidAncestor = function (cell, parent, recurse) {\n  return recurse ? this.model.isAncestor(parent, cell) : this.model.getParent(cell) == parent;\n};\n\n/**\r\n * Function: getOpposites\r\n *\r\n * Returns all distinct visible opposite cells for the specified terminal\r\n * on the given edges.\r\n *\r\n * Parameters:\r\n *\r\n * edges - Array of <mxCells> that contains the edges whose opposite\r\n * terminals should be returned.\r\n * terminal - Terminal that specifies the end whose opposite should be\r\n * returned.\r\n * source - Optional boolean that specifies if source terminals should be\r\n * included in the result. Default is true.\r\n * targets - Optional boolean that specifies if targer terminals should be\r\n * included in the result. Default is true.\r\n */\nmxGraph.prototype.getOpposites = function (edges, terminal, sources, targets) {\n  sources = sources != null ? sources : true;\n  targets = targets != null ? targets : true;\n  var terminals = [];\n\n  // Fast lookup to avoid duplicates in terminals array\n  var dict = new _mxDictionary[\"default\"]();\n  if (edges != null) {\n    for (var i = 0; i < edges.length; i++) {\n      var state = this.view.getState(edges[i]);\n      var source = state != null ? state.getVisibleTerminal(true) : this.view.getVisibleTerminal(edges[i], true);\n      var target = state != null ? state.getVisibleTerminal(false) : this.view.getVisibleTerminal(edges[i], false);\n\n      // Checks if the terminal is the source of the edge and if the\n      // target should be stored in the result\n      if (source == terminal && target != null && target != terminal && targets) {\n        if (!dict.get(target)) {\n          dict.put(target, true);\n          terminals.push(target);\n        }\n      }\n\n      // Checks if the terminal is the taget of the edge and if the\n      // source should be stored in the result\n      else if (target == terminal && source != null && source != terminal && sources) {\n        if (!dict.get(source)) {\n          dict.put(source, true);\n          terminals.push(source);\n        }\n      }\n    }\n  }\n  return terminals;\n};\n\n/**\r\n * Function: getEdgesBetween\r\n *\r\n * Returns the edges between the given source and target. This takes into\r\n * account collapsed and invisible cells and returns the connected edges\r\n * as displayed on the screen.\r\n *\r\n * Parameters:\r\n *\r\n * source -\r\n * target -\r\n * directed -\r\n */\nmxGraph.prototype.getEdgesBetween = function (source, target, directed) {\n  directed = directed != null ? directed : false;\n  var edges = this.getEdges(source);\n  var result = [];\n\n  // Checks if the edge is connected to the correct\n  // cell and returns the first match\n  for (var i = 0; i < edges.length; i++) {\n    var state = this.view.getState(edges[i]);\n    var src = state != null ? state.getVisibleTerminal(true) : this.view.getVisibleTerminal(edges[i], true);\n    var trg = state != null ? state.getVisibleTerminal(false) : this.view.getVisibleTerminal(edges[i], false);\n    if (src == source && trg == target || !directed && src == target && trg == source) {\n      result.push(edges[i]);\n    }\n  }\n  return result;\n};\n\n/**\r\n * Function: getPointForEvent\r\n *\r\n * Returns an <mxPoint> representing the given event in the unscaled,\r\n * non-translated coordinate space of <container> and applies the grid.\r\n *\r\n * Parameters:\r\n *\r\n * evt - Mousevent that contains the mouse pointer location.\r\n * addOffset - Optional boolean that specifies if the position should be\r\n * offset by half of the <gridSize>. Default is true.\r\n */\nmxGraph.prototype.getPointForEvent = function (evt, addOffset) {\n  var p = _mxUtils[\"default\"].convertPoint(this.container, _mxEvent[\"default\"].getClientX(evt), _mxEvent[\"default\"].getClientY(evt));\n  var s = this.view.scale;\n  var tr = this.view.translate;\n  var off = addOffset != false ? this.gridSize / 2 : 0;\n  p.x = this.snap(p.x / s - tr.x - off);\n  p.y = this.snap(p.y / s - tr.y - off);\n  return p;\n};\n\n/**\r\n * Function: getCells\r\n *\r\n * Returns the child vertices and edges of the given parent that are contained\r\n * in the given rectangle. The result is added to the optional result array,\r\n * which is returned. If no result array is specified then a new array is\r\n * created and returned.\r\n *\r\n * Parameters:\r\n *\r\n * x - X-coordinate of the rectangle.\r\n * y - Y-coordinate of the rectangle.\r\n * width - Width of the rectangle.\r\n * height - Height of the rectangle.\r\n * parent - <mxCell> that should be used as the root of the recursion.\r\n * Default is current root of the view or the root of the model.\r\n * result - Optional array to store the result in.\r\n */\nmxGraph.prototype.getCells = function (x, y, width, height, parent, result) {\n  result = result != null ? result : [];\n  if (width > 0 || height > 0) {\n    var model = this.getModel();\n    var right = x + width;\n    var bottom = y + height;\n    if (parent == null) {\n      parent = this.getCurrentRoot();\n      if (parent == null) {\n        parent = model.getRoot();\n      }\n    }\n    if (parent != null) {\n      var childCount = model.getChildCount(parent);\n      for (var i = 0; i < childCount; i++) {\n        var cell = model.getChildAt(parent, i);\n        var state = this.view.getState(cell);\n        if (state != null && this.isCellVisible(cell)) {\n          var deg = _mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_ROTATION) || 0;\n          var box = state;\n          if (deg != 0) {\n            box = _mxUtils[\"default\"].getBoundingBox(box, deg);\n          }\n          if ((model.isEdge(cell) || model.isVertex(cell)) && box.x >= x && box.y + box.height <= bottom && box.y >= y && box.x + box.width <= right) {\n            result.push(cell);\n          } else {\n            this.getCells(x, y, width, height, cell, result);\n          }\n        }\n      }\n    }\n  }\n  return result;\n};\n\n/**\r\n * Function: getCellsBeyond\r\n *\r\n * Returns the children of the given parent that are contained in the\r\n * halfpane from the given point (x0, y0) rightwards or downwards\r\n * depending on rightHalfpane and bottomHalfpane.\r\n *\r\n * Parameters:\r\n *\r\n * x0 - X-coordinate of the origin.\r\n * y0 - Y-coordinate of the origin.\r\n * parent - Optional <mxCell> whose children should be checked. Default is\r\n * <defaultParent>.\r\n * rightHalfpane - Boolean indicating if the cells in the right halfpane\r\n * from the origin should be returned.\r\n * bottomHalfpane - Boolean indicating if the cells in the bottom halfpane\r\n * from the origin should be returned.\r\n */\nmxGraph.prototype.getCellsBeyond = function (x0, y0, parent, rightHalfpane, bottomHalfpane) {\n  var result = [];\n  if (rightHalfpane || bottomHalfpane) {\n    if (parent == null) {\n      parent = this.getDefaultParent();\n    }\n    if (parent != null) {\n      var childCount = this.model.getChildCount(parent);\n      for (var i = 0; i < childCount; i++) {\n        var child = this.model.getChildAt(parent, i);\n        var state = this.view.getState(child);\n        if (this.isCellVisible(child) && state != null) {\n          if ((!rightHalfpane || state.x >= x0) && (!bottomHalfpane || state.y >= y0)) {\n            result.push(child);\n          }\n        }\n      }\n    }\n  }\n  return result;\n};\n\n/**\r\n * Function: findTreeRoots\r\n *\r\n * Returns all children in the given parent which do not have incoming\r\n * edges. If the result is empty then the with the greatest difference\r\n * between incoming and outgoing edges is returned.\r\n *\r\n * Parameters:\r\n *\r\n * parent - <mxCell> whose children should be checked.\r\n * isolate - Optional boolean that specifies if edges should be ignored if\r\n * the opposite end is not a child of the given parent cell. Default is\r\n * false.\r\n * invert - Optional boolean that specifies if outgoing or incoming edges\r\n * should be counted for a tree root. If false then outgoing edges will be\r\n * counted. Default is false.\r\n */\nmxGraph.prototype.findTreeRoots = function (parent, isolate, invert) {\n  isolate = isolate != null ? isolate : false;\n  invert = invert != null ? invert : false;\n  var roots = [];\n  if (parent != null) {\n    var model = this.getModel();\n    var childCount = model.getChildCount(parent);\n    var best = null;\n    var maxDiff = 0;\n    for (var i = 0; i < childCount; i++) {\n      var cell = model.getChildAt(parent, i);\n      if (this.model.isVertex(cell) && this.isCellVisible(cell)) {\n        var conns = this.getConnections(cell, isolate ? parent : null);\n        var fanOut = 0;\n        var fanIn = 0;\n        for (var j = 0; j < conns.length; j++) {\n          var src = this.view.getVisibleTerminal(conns[j], true);\n          if (src == cell) {\n            fanOut++;\n          } else {\n            fanIn++;\n          }\n        }\n        if (invert && fanOut == 0 && fanIn > 0 || !invert && fanIn == 0 && fanOut > 0) {\n          roots.push(cell);\n        }\n        var diff = invert ? fanIn - fanOut : fanOut - fanIn;\n        if (diff > maxDiff) {\n          maxDiff = diff;\n          best = cell;\n        }\n      }\n    }\n    if (roots.length == 0 && best != null) {\n      roots.push(best);\n    }\n  }\n  return roots;\n};\n\n/**\r\n * Function: traverse\r\n *\r\n * Traverses the (directed) graph invoking the given function for each\r\n * visited vertex and edge. The function is invoked with the current vertex\r\n * and the incoming edge as a parameter. This implementation makes sure\r\n * each vertex is only visited once. The function may return false if the\r\n * traversal should stop at the given vertex.\r\n *\r\n * Example:\r\n *\r\n * (code)\r\n * mxLog.show();\r\n * var cell = graph.getSelectionCell();\r\n * graph.traverse(cell, false, function(vertex, edge)\r\n * {\r\n *   mxLog.debug(graph.getLabel(vertex));\r\n * });\r\n * (end)\r\n *\r\n * Parameters:\r\n *\r\n * vertex - <mxCell> that represents the vertex where the traversal starts.\r\n * directed - Optional boolean indicating if edges should only be traversed\r\n * from source to target. Default is true.\r\n * func - Visitor function that takes the current vertex and the incoming\r\n * edge as arguments. The traversal stops if the function returns false.\r\n * edge - Optional <mxCell> that represents the incoming edge. This is\r\n * null for the first step of the traversal.\r\n * visited - Optional <mxDictionary> from cells to true for the visited cells.\r\n */\nmxGraph.prototype.traverse = function (vertex, directed, func, edge, visited) {\n  if (func != null && vertex != null) {\n    directed = directed != null ? directed : true;\n    visited = visited || new _mxDictionary[\"default\"]();\n    if (!visited.get(vertex)) {\n      visited.put(vertex, true);\n      var result = func(vertex, edge);\n      if (result == null || result) {\n        var edgeCount = this.model.getEdgeCount(vertex);\n        if (edgeCount > 0) {\n          for (var i = 0; i < edgeCount; i++) {\n            var e = this.model.getEdgeAt(vertex, i);\n            var isSource = this.model.getTerminal(e, true) == vertex;\n            if (!directed || isSource) {\n              var next = this.model.getTerminal(e, !isSource);\n              this.traverse(next, directed, func, e, visited);\n            }\n          }\n        }\n      }\n    }\n  }\n};\n\n/**\r\n * Group: Selection\r\n */\n\n/**\r\n * Function: isCellSelected\r\n *\r\n * Returns true if the given cell is selected.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> for which the selection state should be returned.\r\n */\nmxGraph.prototype.isCellSelected = function (cell) {\n  return this.getSelectionModel().isSelected(cell);\n};\n\n/**\r\n * Function: isSelectionEmpty\r\n *\r\n * Returns true if the selection is empty.\r\n */\nmxGraph.prototype.isSelectionEmpty = function () {\n  return this.getSelectionModel().isEmpty();\n};\n\n/**\r\n * Function: clearSelection\r\n *\r\n * Clears the selection using <mxGraphSelectionModel.clear>.\r\n */\nmxGraph.prototype.clearSelection = function () {\n  return this.getSelectionModel().clear();\n};\n\n/**\r\n * Function: getSelectionCount\r\n *\r\n * Returns the number of selected cells.\r\n */\nmxGraph.prototype.getSelectionCount = function () {\n  return this.getSelectionModel().cells.length;\n};\n\n/**\r\n * Function: getSelectionCell\r\n *\r\n * Returns the first cell from the array of selected <mxCells>.\r\n */\nmxGraph.prototype.getSelectionCell = function () {\n  var cell = this.getSelectionModel().cells[0];\n  //如果没有选中的Cell，则认为当前选中的是整个画布\n  if (!cell) {\n    //TODO root正确查找 多选图形处理\n    cell = this.getModel().root.children[0];\n  }\n  return cell;\n};\n\n/**\r\n * Function: getSelectionCells\r\n *\r\n * Returns the array of selected <mxCells>.\r\n */\nmxGraph.prototype.getSelectionCells = function () {\n  return this.getSelectionModel().cells.slice();\n};\n\n/**\r\n * Function: setSelectionCell\r\n *\r\n * Sets the selection cell.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> to be selected.\r\n */\nmxGraph.prototype.setSelectionCell = function (cell) {\n  this.getSelectionModel().setCell(cell);\n};\n\n/**\r\n * Function: setSelectionCells\r\n *\r\n * Sets the selection cell.\r\n *\r\n * Parameters:\r\n *\r\n * cells - Array of <mxCells> to be selected.\r\n */\nmxGraph.prototype.setSelectionCells = function (cells) {\n  this.getSelectionModel().setCells(cells);\n};\n\n/**\r\n * Function: addSelectionCell\r\n *\r\n * Adds the given cell to the selection.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> to be add to the selection.\r\n */\nmxGraph.prototype.addSelectionCell = function (cell) {\n  this.getSelectionModel().addCell(cell);\n};\n\n/**\r\n * Function: addSelectionCells\r\n *\r\n * Adds the given cells to the selection.\r\n *\r\n * Parameters:\r\n *\r\n * cells - Array of <mxCells> to be added to the selection.\r\n */\nmxGraph.prototype.addSelectionCells = function (cells) {\n  this.getSelectionModel().addCells(cells);\n};\n\n/**\r\n * Function: removeSelectionCell\r\n *\r\n * Removes the given cell from the selection.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> to be removed from the selection.\r\n */\nmxGraph.prototype.removeSelectionCell = function (cell) {\n  this.getSelectionModel().removeCell(cell);\n};\n\n/**\r\n * Function: removeSelectionCells\r\n *\r\n * Removes the given cells from the selection.\r\n *\r\n * Parameters:\r\n *\r\n * cells - Array of <mxCells> to be removed from the selection.\r\n */\nmxGraph.prototype.removeSelectionCells = function (cells) {\n  this.getSelectionModel().removeCells(cells);\n};\n\n/**\r\n * Function: selectRegion\r\n *\r\n * Selects and returns the cells inside the given rectangle for the\r\n * specified event.\r\n *\r\n * Parameters:\r\n *\r\n * rect - <mxRectangle> that represents the region to be selected.\r\n * evt - Mouseevent that triggered the selection.\r\n */\nmxGraph.prototype.selectRegion = function (rect, evt) {\n  var cells = this.getCells(rect.x, rect.y, rect.width, rect.height);\n  this.selectCellsForEvent(cells, evt);\n  return cells;\n};\n\n/**\r\n * Function: selectNextCell\r\n *\r\n * Selects the next cell.\r\n */\nmxGraph.prototype.selectNextCell = function () {\n  this.selectCell(true);\n};\n\n/**\r\n * Function: selectPreviousCell\r\n *\r\n * Selects the previous cell.\r\n */\nmxGraph.prototype.selectPreviousCell = function () {\n  this.selectCell();\n};\n\n/**\r\n * Function: selectParentCell\r\n *\r\n * Selects the parent cell.\r\n */\nmxGraph.prototype.selectParentCell = function () {\n  this.selectCell(false, true);\n};\n\n/**\r\n * Function: selectChildCell\r\n *\r\n * Selects the first child cell.\r\n */\nmxGraph.prototype.selectChildCell = function () {\n  this.selectCell(false, false, true);\n};\n\n/**\r\n * Function: selectCell\r\n *\r\n * Selects the next, parent, first child or previous cell, if all arguments\r\n * are false.\r\n *\r\n * Parameters:\r\n *\r\n * isNext - Boolean indicating if the next cell should be selected.\r\n * isParent - Boolean indicating if the parent cell should be selected.\r\n * isChild - Boolean indicating if the first child cell should be selected.\r\n */\nmxGraph.prototype.selectCell = function (isNext, isParent, isChild) {\n  var sel = this.selectionModel;\n  var cell = sel.cells.length > 0 ? sel.cells[0] : null;\n  if (sel.cells.length > 1) {\n    sel.clear();\n  }\n  var parent = cell != null ? this.model.getParent(cell) : this.getDefaultParent();\n  var childCount = this.model.getChildCount(parent);\n  if (cell == null && childCount > 0) {\n    var child = this.model.getChildAt(parent, 0);\n    this.setSelectionCell(child);\n  } else if ((cell == null || isParent) && this.view.getState(parent) != null && this.model.getGeometry(parent) != null) {\n    if (this.getCurrentRoot() != parent) {\n      this.setSelectionCell(parent);\n    }\n  } else if (cell != null && isChild) {\n    var tmp = this.model.getChildCount(cell);\n    if (tmp > 0) {\n      var child = this.model.getChildAt(cell, 0);\n      this.setSelectionCell(child);\n    }\n  } else if (childCount > 0) {\n    var i = parent.getIndex(cell);\n    if (isNext) {\n      i++;\n      var child = this.model.getChildAt(parent, i % childCount);\n      this.setSelectionCell(child);\n    } else {\n      i--;\n      var index = i < 0 ? childCount - 1 : i;\n      var child = this.model.getChildAt(parent, index);\n      this.setSelectionCell(child);\n    }\n  }\n};\n\n/**\r\n * Function: selectAll\r\n *\r\n * Selects all children of the given parent cell or the children of the\r\n * default parent if no parent is specified. To select leaf vertices and/or\r\n * edges use <selectCells>.\r\n *\r\n * Parameters:\r\n *\r\n * parent - Optional <mxCell> whose children should be selected.\r\n * Default is <defaultParent>.\r\n * descendants - Optional boolean specifying whether all descendants should be\r\n * selected. Default is false.\r\n */\nmxGraph.prototype.selectAll = function (parent, descendants) {\n  parent = parent || this.getDefaultParent();\n  var cells = descendants ? this.model.filterDescendants(function (cell) {\n    return cell != parent;\n  }, parent) : this.model.getChildren(parent);\n  if (cells != null) {\n    this.setSelectionCells(cells);\n  }\n};\n\n/**\r\n * Function: selectVertices\r\n *\r\n * Select all vertices inside the given parent or the default parent.\r\n */\nmxGraph.prototype.selectVertices = function (parent) {\n  this.selectCells(true, false, parent);\n};\n\n/**\r\n * Function: selectVertices\r\n *\r\n * Select all vertices inside the given parent or the default parent.\r\n */\nmxGraph.prototype.selectEdges = function (parent) {\n  this.selectCells(false, true, parent);\n};\n\n/**\r\n * Function: selectCells\r\n *\r\n * Selects all vertices and/or edges depending on the given boolean\r\n * arguments recursively, starting at the given parent or the default\r\n * parent if no parent is specified. Use <selectAll> to select all cells.\r\n * For vertices, only cells with no children are selected.\r\n *\r\n * Parameters:\r\n *\r\n * vertices - Boolean indicating if vertices should be selected.\r\n * edges - Boolean indicating if edges should be selected.\r\n * parent - Optional <mxCell> that acts as the root of the recursion.\r\n * Default is <defaultParent>.\r\n */\nmxGraph.prototype.selectCells = function (vertices, edges, parent) {\n  parent = parent || this.getDefaultParent();\n  var filter = _mxGraphUtils[\"default\"].bind(this, function (cell) {\n    return this.view.getState(cell) != null && (this.model.getChildCount(cell) == 0 && this.model.isVertex(cell) && vertices && !this.model.isEdge(this.model.getParent(cell)) || this.model.isEdge(cell) && edges);\n  });\n  var cells = this.model.filterDescendants(filter, parent);\n  this.setSelectionCells(cells);\n};\n\n/**\r\n * Function: selectCellForEvent\r\n *\r\n * Selects the given cell by either adding it to the selection or\r\n * replacing the selection depending on whether the given mouse event is a\r\n * toggle event.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> to be selected.\r\n * evt - Optional mouseevent that triggered the selection.\r\n */\nmxGraph.prototype.selectCellForEvent = function (cell, evt) {\n  var isSelected = this.isCellSelected(cell);\n  if (this.isToggleEvent(evt)) {\n    if (isSelected) {\n      this.removeSelectionCell(cell);\n    } else {\n      this.addSelectionCell(cell);\n    }\n  } else if (!isSelected || this.getSelectionCount() != 1) {\n    this.setSelectionCell(cell);\n  }\n};\n\n/**\r\n * Function: selectCellsForEvent\r\n *\r\n * Selects the given cells by either adding them to the selection or\r\n * replacing the selection depending on whether the given mouse event is a\r\n * toggle event.\r\n *\r\n * Parameters:\r\n *\r\n * cells - Array of <mxCells> to be selected.\r\n * evt - Optional mouseevent that triggered the selection.\r\n */\nmxGraph.prototype.selectCellsForEvent = function (cells, evt) {\n  if (this.isToggleEvent(evt)) {\n    this.addSelectionCells(cells);\n  } else {\n    this.setSelectionCells(cells);\n  }\n};\n\n/**\r\n * Group: Selection state\r\n */\n\n/**\r\n * Function: createHandler\r\n *\r\n * Creates a new handler for the given cell state. This implementation\r\n * returns a new <mxEdgeHandler> of the corresponding cell is an edge,\r\n * otherwise it returns an <mxVertexHandler>.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> whose handler should be created.\r\n */\nmxGraph.prototype.createHandler = function (state) {\n  var result = null;\n  if (state != null) {\n    if (this.model.isEdge(state.cell)) {\n      var source = state.getVisibleTerminalState(true);\n      var target = state.getVisibleTerminalState(false);\n      var geo = this.getCellGeometry(state.cell);\n      var edgeStyle = this.view.getEdgeStyle(state, geo != null ? geo.points : null, source, target);\n      result = this.createEdgeHandler(state, edgeStyle);\n    } else {\n      result = this.createVertexHandler(state);\n    }\n  }\n  return result;\n};\n\n/**\r\n * Function: createVertexHandler\r\n *\r\n * Hooks to create a new <mxVertexHandler> for the given <mxCellState>.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> to create the handler for.\r\n */\nmxGraph.prototype.createVertexHandler = function (state) {\n  return new _mxVertexHandler[\"default\"](state);\n};\n\n/**\r\n * Function: createEdgeHandler\r\n *\r\n * Hooks to create a new <mxEdgeHandler> for the given <mxCellState>.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> to create the handler for.\r\n */\nmxGraph.prototype.createEdgeHandler = function (state, edgeStyle) {\n  var result = null;\n  if (edgeStyle == _mxEdgeStyle[\"default\"].Loop || edgeStyle == _mxEdgeStyle[\"default\"].ElbowConnector || edgeStyle == _mxEdgeStyle[\"default\"].SideToSide || edgeStyle == _mxEdgeStyle[\"default\"].TopToBottom) {\n    result = this.createElbowEdgeHandler(state);\n  } else if (edgeStyle == _mxEdgeStyle[\"default\"].SegmentConnector || edgeStyle == _mxEdgeStyle[\"default\"].OrthConnector) {\n    result = this.createEdgeSegmentHandler(state);\n  } else {\n    result = new _mxEdgeHandler[\"default\"](state);\n  }\n  return result;\n};\n\n/**\r\n * Function: createEdgeSegmentHandler\r\n *\r\n * Hooks to create a new <mxEdgeSegmentHandler> for the given <mxCellState>.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> to create the handler for.\r\n */\nmxGraph.prototype.createEdgeSegmentHandler = function (state) {\n  return new _mxEdgeSegmentHandler[\"default\"](state);\n};\n\n/**\r\n * Function: createElbowEdgeHandler\r\n *\r\n * Hooks to create a new <mxElbowEdgeHandler> for the given <mxCellState>.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> to create the handler for.\r\n */\nmxGraph.prototype.createElbowEdgeHandler = function (state) {\n  return new _mxElbowEdgeHandler[\"default\"](state);\n};\n\n/**\r\n * Group: Graph events\r\n */\n\n/**\r\n * Function: addMouseListener\r\n *\r\n * Adds a listener to the graph event dispatch loop. The listener\r\n * must implement the mouseDown, mouseMove and mouseUp methods\r\n * as shown in the <mxMouseEvent> class.\r\n *\r\n * Parameters:\r\n *\r\n * listener - Listener to be added to the graph event listeners.\r\n */\nmxGraph.prototype.addMouseListener = function (listener) {\n  if (this.mouseListeners == null) {\n    this.mouseListeners = [];\n  }\n  this.mouseListeners.push(listener);\n};\n\n/**\r\n * Function: removeMouseListener\r\n *\r\n * Removes the specified graph listener.\r\n *\r\n * Parameters:\r\n *\r\n * listener - Listener to be removed from the graph event listeners.\r\n */\nmxGraph.prototype.removeMouseListener = function (listener) {\n  if (this.mouseListeners != null) {\n    for (var i = 0; i < this.mouseListeners.length; i++) {\n      if (this.mouseListeners[i] == listener) {\n        this.mouseListeners.splice(i, 1);\n        break;\n      }\n    }\n  }\n};\n\n/**\r\n * Function: updateMouseEvent\r\n *\r\n * Sets the graphX and graphY properties if the given <mxMouseEvent> if\r\n * required and returned the event.\r\n *\r\n * Parameters:\r\n *\r\n * me - <mxMouseEvent> to be updated.\r\n * evtName - Name of the mouse event.\r\n */\nmxGraph.prototype.updateMouseEvent = function (me, evtName) {\n  if (me.graphX == null || me.graphY == null) {\n    var pt = _mxUtils[\"default\"].convertPoint(this.container, me.getX(), me.getY());\n    me.graphX = pt.x - this.panDx;\n    me.graphY = pt.y - this.panDy;\n\n    // Searches for rectangles using method if native hit detection is disabled on shape\n    if (me.getCell() == null && this.isMouseDown && evtName == _mxEvent[\"default\"].MOUSE_MOVE) {\n      me.state = this.view.getState(this.getCellAt(pt.x, pt.y, null, null, null, function (state) {\n        return state.shape == null || state.shape.paintBackground != _mxRectangleShape[\"default\"].prototype.paintBackground || _mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_POINTER_EVENTS, '1') == '1' || state.shape.fill != null && state.shape.fill != _mxConstants[\"default\"].NONE;\n      }));\n    }\n  }\n  return me;\n};\n\n/**\r\n * Function: getStateForEvent\r\n *\r\n * Returns the state for the given touch event.\r\n */\nmxGraph.prototype.getStateForTouchEvent = function (evt) {\n  var x = _mxEvent[\"default\"].getClientX(evt);\n  var y = _mxEvent[\"default\"].getClientY(evt);\n\n  // Dispatches the drop event to the graph which\n  // consumes and executes the source function\n  var pt = _mxUtils[\"default\"].convertPoint(this.container, x, y);\n  return this.view.getState(this.getCellAt(pt.x, pt.y));\n};\n\n/**\r\n * Function: isEventIgnored\r\n *\r\n * Returns true if the event should be ignored in <fireMouseEvent>.\r\n */\nmxGraph.prototype.isEventIgnored = function (evtName, me, sender) {\n  var mouseEvent = _mxEvent[\"default\"].isMouseEvent(me.getEvent());\n  var result = false;\n\n  // Drops events that are fired more than once\n  if (me.getEvent() == this.lastEvent) {\n    result = true;\n  } else {\n    this.lastEvent = me.getEvent();\n  }\n\n  // Installs event listeners to capture the complete gesture from the event source\n  // for non-MS touch events as a workaround for all events for the same geture being\n  // fired from the event source even if that was removed from the DOM.\n  if (this.eventSource != null && evtName != _mxEvent[\"default\"].MOUSE_MOVE) {\n    _mxEvent[\"default\"].removeGestureListeners(this.eventSource, null, this.mouseMoveRedirect, this.mouseUpRedirect);\n    this.mouseMoveRedirect = null;\n    this.mouseUpRedirect = null;\n    this.eventSource = null;\n  } else if (this.eventSource != null && me.getSource() != this.eventSource) {\n    result = true;\n  } else if (_mxClient[\"default\"].IS_TOUCH && evtName == _mxEvent[\"default\"].MOUSE_DOWN && !mouseEvent) {\n    this.eventSource = me.getSource();\n    this.mouseMoveRedirect = _mxGraphUtils[\"default\"].bind(this, function (evt) {\n      this.fireMouseEvent(_mxEvent[\"default\"].MOUSE_MOVE, new _mxMouseEvent[\"default\"](evt, this.getStateForTouchEvent(evt)));\n    });\n    this.mouseUpRedirect = _mxGraphUtils[\"default\"].bind(this, function (evt) {\n      this.fireMouseEvent(_mxEvent[\"default\"].MOUSE_UP, new _mxMouseEvent[\"default\"](evt, this.getStateForTouchEvent(evt)));\n    });\n    _mxEvent[\"default\"].addGestureListeners(this.eventSource, null, this.mouseMoveRedirect, this.mouseUpRedirect);\n  }\n\n  // Factored out the workarounds for FF to make it easier to override/remove\n  // Note this method has side-effects!\n  if (this.isSyntheticEventIgnored(evtName, me, sender)) {\n    result = true;\n  }\n\n  // Never fires mouseUp/-Down for double clicks\n  if (!_mxEvent[\"default\"].isPopupTrigger(this.lastEvent) && evtName != _mxEvent[\"default\"].MOUSE_MOVE && this.lastEvent.detail == 2) {\n    return true;\n  }\n\n  // Filters out of sequence events or mixed event types during a gesture\n  if (evtName == _mxEvent[\"default\"].MOUSE_UP && this.isMouseDown) {\n    this.isMouseDown = false;\n  } else if (evtName == _mxEvent[\"default\"].MOUSE_DOWN && !this.isMouseDown) {\n    this.isMouseDown = true;\n    this.isMouseTrigger = mouseEvent;\n  }\n  // Drops mouse events that are fired during touch gestures as a workaround for Webkit\n  // and mouse events that are not in sync with the current internal button state\n  else if (!result && ((!_mxClient[\"default\"].IS_FF || evtName != _mxEvent[\"default\"].MOUSE_MOVE) && this.isMouseDown && this.isMouseTrigger != mouseEvent || evtName == _mxEvent[\"default\"].MOUSE_DOWN && this.isMouseDown || evtName == _mxEvent[\"default\"].MOUSE_UP && !this.isMouseDown)) {\n    result = true;\n  }\n  if (!result && evtName == _mxEvent[\"default\"].MOUSE_DOWN) {\n    this.lastMouseX = me.getX();\n    this.lastMouseY = me.getY();\n  }\n  return result;\n};\n\n/**\r\n * Function: isSyntheticEventIgnored\r\n *\r\n * Hook for ignoring synthetic mouse events after touchend in Firefox.\r\n */\nmxGraph.prototype.isSyntheticEventIgnored = function (evtName, me, sender) {\n  var result = false;\n  var mouseEvent = _mxEvent[\"default\"].isMouseEvent(me.getEvent());\n\n  // LATER: This does not cover all possible cases that can go wrong in FF\n  if (this.ignoreMouseEvents && mouseEvent && evtName != _mxEvent[\"default\"].MOUSE_MOVE) {\n    this.ignoreMouseEvents = evtName != _mxEvent[\"default\"].MOUSE_UP;\n    result = true;\n  } else if (_mxClient[\"default\"].IS_FF && !mouseEvent && evtName == _mxEvent[\"default\"].MOUSE_UP) {\n    this.ignoreMouseEvents = true;\n  }\n  return result;\n};\n\n/**\r\n * Function: isEventSourceIgnored\r\n *\r\n * Returns true if the event should be ignored in <fireMouseEvent>. This\r\n * implementation returns true for select, option and input (if not of type\r\n * checkbox, radio, button, submit or file) event sources if the event is not\r\n * a mouse event or a left mouse button press event.\r\n *\r\n * Parameters:\r\n *\r\n * evtName - The name of the event.\r\n * me - <mxMouseEvent> that should be ignored.\r\n */\nmxGraph.prototype.isEventSourceIgnored = function (evtName, me) {\n  var source = me.getSource();\n  var name = source.nodeName != null ? source.nodeName.toLowerCase() : '';\n  var candidate = !_mxEvent[\"default\"].isMouseEvent(me.getEvent()) || _mxEvent[\"default\"].isLeftMouseButton(me.getEvent());\n  return evtName == _mxEvent[\"default\"].MOUSE_DOWN && candidate && (name == 'select' || name == 'option' || name == 'input' && source.type != 'checkbox' && source.type != 'radio' && source.type != 'button' && source.type != 'submit' && source.type != 'file');\n};\n\n/**\r\n * Function: getEventState\r\n *\r\n * Returns the <mxCellState> to be used when firing the mouse event for the\r\n * given state. This implementation returns the given state.\r\n *\r\n * Parameters:\r\n *\r\n * <mxCellState> - State whose event source should be returned.\r\n */\nmxGraph.prototype.getEventState = function (state) {\n  return state;\n};\n\n/**\r\n * Function: fireMouseEvent\r\n *\r\n * Dispatches the given event in the graph event dispatch loop. Possible\r\n * event names are <mxEvent.MOUSE_DOWN>, <mxEvent.MOUSE_MOVE> and\r\n * <mxEvent.MOUSE_UP>. All listeners are invoked for all events regardless\r\n * of the consumed state of the event.\r\n *\r\n * Parameters:\r\n *\r\n * evtName - String that specifies the type of event to be dispatched.\r\n * me - <mxMouseEvent> to be fired.\r\n * sender - Optional sender argument. Default is this.\r\n */\nmxGraph.prototype.fireMouseEvent = function (evtName, me, sender) {\n  if (this.isEventSourceIgnored(evtName, me)) {\n    if (this.tooltipHandler != null) {\n      this.tooltipHandler.hide();\n    }\n    return;\n  }\n  if (sender == null) {\n    sender = this;\n  }\n\n  // Updates the graph coordinates in the event\n  me = this.updateMouseEvent(me, evtName);\n\n  // Detects and processes double taps for touch-based devices which do not have native double click events\n  // or where detection of double click is not always possible (quirks, IE10+). Note that this can only handle\n  // double clicks on cells because the sequence of events in IE prevents detection on the background, it fires\n  // two mouse ups, one of which without a cell but no mousedown for the second click which means we cannot\n  // detect which mouseup(s) are part of the first click, ie we do not know when the first click ends.\n  if (!this.nativeDblClickEnabled && !_mxEvent[\"default\"].isPopupTrigger(me.getEvent()) || this.doubleTapEnabled && _mxClient[\"default\"].IS_TOUCH && _mxEvent[\"default\"].isTouchEvent(me.getEvent())) {\n    var currentTime = new Date().getTime();\n\n    // NOTE: Second mouseDown for double click missing in quirks mode\n    if (!_mxClient[\"default\"].IS_QUIRKS && evtName == _mxEvent[\"default\"].MOUSE_DOWN || _mxClient[\"default\"].IS_QUIRKS && evtName == _mxEvent[\"default\"].MOUSE_UP && !this.fireDoubleClick) {\n      if (this.lastTouchEvent != null && this.lastTouchEvent != me.getEvent() && currentTime - this.lastTouchTime < this.doubleTapTimeout && Math.abs(this.lastTouchX - me.getX()) < this.doubleTapTolerance && Math.abs(this.lastTouchY - me.getY()) < this.doubleTapTolerance && this.doubleClickCounter < 2) {\n        this.doubleClickCounter++;\n        var doubleClickFired = false;\n        if (evtName == _mxEvent[\"default\"].MOUSE_UP) {\n          if (me.getCell() == this.lastTouchCell && this.lastTouchCell != null) {\n            this.lastTouchTime = 0;\n            var cell = this.lastTouchCell;\n            this.lastTouchCell = null;\n\n            // Fires native dblclick event via event source\n            // NOTE: This fires two double click events on edges in quirks mode. While\n            // trying to fix this, we realized that nativeDoubleClick can be disabled for\n            // quirks and IE10+ (or we didn't find the case mentioned above where it\n            // would not work), ie. all double clicks seem to be working without this.\n            if (_mxClient[\"default\"].IS_QUIRKS) {\n              me.getSource().fireEvent('ondblclick');\n            }\n            this.dblClick(me.getEvent(), cell);\n            doubleClickFired = true;\n          }\n        } else {\n          this.fireDoubleClick = true;\n          this.lastTouchTime = 0;\n        }\n\n        // Do not ignore mouse up in quirks in this case\n        if (!_mxClient[\"default\"].IS_QUIRKS || doubleClickFired) {\n          _mxEvent[\"default\"].consume(me.getEvent());\n          return;\n        }\n      } else if (this.lastTouchEvent == null || this.lastTouchEvent != me.getEvent()) {\n        this.lastTouchCell = me.getCell();\n        this.lastTouchX = me.getX();\n        this.lastTouchY = me.getY();\n        this.lastTouchTime = currentTime;\n        this.lastTouchEvent = me.getEvent();\n        this.doubleClickCounter = 0;\n      }\n    } else if ((this.isMouseDown || evtName == _mxEvent[\"default\"].MOUSE_UP) && this.fireDoubleClick) {\n      this.fireDoubleClick = false;\n      var cell = this.lastTouchCell;\n      this.lastTouchCell = null;\n      this.isMouseDown = false;\n\n      // Workaround for Chrome/Safari not firing native double click events for double touch on background\n      var valid = cell != null || _mxEvent[\"default\"].isTouchEvent(me.getEvent()) && (_mxClient[\"default\"].IS_GC || _mxClient[\"default\"].IS_SF);\n      if (valid && Math.abs(this.lastTouchX - me.getX()) < this.doubleTapTolerance && Math.abs(this.lastTouchY - me.getY()) < this.doubleTapTolerance) {\n        this.dblClick(me.getEvent(), cell);\n      } else {\n        _mxEvent[\"default\"].consume(me.getEvent());\n      }\n      return;\n    }\n  }\n  if (!this.isEventIgnored(evtName, me, sender)) {\n    // Updates the event state via getEventState\n    me.state = this.getEventState(me.getState());\n    this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].FIRE_MOUSE_EVENT, 'eventName', evtName, 'event', me));\n    if (_mxClient[\"default\"].IS_OP || _mxClient[\"default\"].IS_SF || _mxClient[\"default\"].IS_GC || _mxClient[\"default\"].IS_IE11 || _mxClient[\"default\"].IS_IE && _mxClient[\"default\"].IS_SVG || me.getEvent().target != this.container) {\n      if (evtName == _mxEvent[\"default\"].MOUSE_MOVE && this.isMouseDown && this.autoScroll && !_mxEvent[\"default\"].isMultiTouchEvent(me.getEvent)) {\n        this.scrollPointToVisible(me.getGraphX(), me.getGraphY(), this.autoExtend);\n      } else if (evtName == _mxEvent[\"default\"].MOUSE_UP && this.ignoreScrollbars && this.translateToScrollPosition && (this.container.scrollLeft != 0 || this.container.scrollTop != 0)) {\n        var s = this.view.scale;\n        var tr = this.view.translate;\n        this.view.setTranslate(tr.x - this.container.scrollLeft / s, tr.y - this.container.scrollTop / s);\n        this.container.scrollLeft = 0;\n        this.container.scrollTop = 0;\n      }\n      if (this.mouseListeners != null) {\n        var args = [sender, me];\n\n        // Does not change returnValue in Opera\n        if (!me.getEvent().preventDefault) {\n          me.getEvent().returnValue = true;\n        }\n        for (var i = 0; i < this.mouseListeners.length; i++) {\n          var l = this.mouseListeners[i];\n          if (evtName == _mxEvent[\"default\"].MOUSE_DOWN) {\n            l.mouseDown.apply(l, args);\n          } else if (evtName == _mxEvent[\"default\"].MOUSE_MOVE) {\n            l.mouseMove.apply(l, args);\n          } else if (evtName == _mxEvent[\"default\"].MOUSE_UP) {\n            l.mouseUp.apply(l, args);\n          }\n        }\n      }\n\n      // Invokes the click handler\n      if (evtName == _mxEvent[\"default\"].MOUSE_UP) {\n        this.click(me);\n      }\n    }\n\n    // Detects tapAndHold events using a timer\n    if (_mxEvent[\"default\"].isTouchEvent(me.getEvent()) && evtName == _mxEvent[\"default\"].MOUSE_DOWN && this.tapAndHoldEnabled && !this.tapAndHoldInProgress) {\n      this.tapAndHoldInProgress = true;\n      this.initialTouchX = me.getGraphX();\n      this.initialTouchY = me.getGraphY();\n      var handler = function handler() {\n        if (this.tapAndHoldValid) {\n          this.tapAndHold(me);\n        }\n        this.tapAndHoldInProgress = false;\n        this.tapAndHoldValid = false;\n      };\n      if (this.tapAndHoldThread) {\n        window.clearTimeout(this.tapAndHoldThread);\n      }\n      this.tapAndHoldThread = window.setTimeout(_mxGraphUtils[\"default\"].bind(this, handler), this.tapAndHoldDelay);\n      this.tapAndHoldValid = true;\n    } else if (evtName == _mxEvent[\"default\"].MOUSE_UP) {\n      this.tapAndHoldInProgress = false;\n      this.tapAndHoldValid = false;\n    } else if (this.tapAndHoldValid) {\n      this.tapAndHoldValid = Math.abs(this.initialTouchX - me.getGraphX()) < this.tolerance && Math.abs(this.initialTouchY - me.getGraphY()) < this.tolerance;\n    }\n\n    // Stops editing for all events other than from cellEditor\n    if (evtName == _mxEvent[\"default\"].MOUSE_DOWN && this.isEditing() && !this.cellEditor.isEventSource(me.getEvent())) {\n      this.stopEditing(!this.isInvokesStopCellEditing());\n    }\n    this.consumeMouseEvent(evtName, me, sender);\n  }\n};\n\n/**\r\n * Function: consumeMouseEvent\r\n *\r\n * Destroys the graph and all its resources.\r\n */\nmxGraph.prototype.consumeMouseEvent = function (evtName, me, sender) {\n  // Workaround for duplicate click in Windows 8 with Chrome/FF/Opera with touch\n  if (evtName == _mxEvent[\"default\"].MOUSE_DOWN && _mxEvent[\"default\"].isTouchEvent(me.getEvent())) {\n    me.consume(false);\n  }\n};\n\n/**\r\n * Function: fireGestureEvent\r\n *\r\n * Dispatches a <mxEvent.GESTURE> event. The following example will resize the\r\n * cell under the mouse based on the scale property of the native touch event.\r\n *\r\n * (code)\r\n * graph.addListener(mxEvent.GESTURE, function(sender, eo)\r\n * {\r\n *   var evt = eo.getProperty('event');\r\n *   var state = graph.view.getState(eo.getProperty('cell'));\r\n *\r\n *   if (graph.isEnabled() && graph.isCellResizable(state.cell) && Math.abs(1 - evt.scale) > 0.2)\r\n *   {\r\n *     var scale = graph.view.scale;\r\n *     var tr = graph.view.translate;\r\n *\r\n *     var w = state.width * evt.scale;\r\n *     var h = state.height * evt.scale;\r\n *     var x = state.x - (w - state.width) / 2;\r\n *     var y = state.y - (h - state.height) / 2;\r\n *\r\n *     var bounds = new mxRectangle(graph.snap(x / scale) - tr.x,\r\n *     \t\tgraph.snap(y / scale) - tr.y, graph.snap(w / scale), graph.snap(h / scale));\r\n *     graph.resizeCell(state.cell, bounds);\r\n *     eo.consume();\r\n *   }\r\n * });\r\n * (end)\r\n *\r\n * Parameters:\r\n *\r\n * evt - Gestureend event that represents the gesture.\r\n * cell - Optional <mxCell> associated with the gesture.\r\n */\nmxGraph.prototype.fireGestureEvent = function (evt, cell) {\n  // Resets double tap event handling when gestures take place\n  this.lastTouchTime = 0;\n  this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].GESTURE, 'event', evt, 'cell', cell));\n};\n\n/**\r\n * Function: destroy\r\n *\r\n * Destroys the graph and all its resources.\r\n */\nmxGraph.prototype.destroy = function () {\n  if (!this.destroyed) {\n    this.destroyed = true;\n    if (this.tooltipHandler != null) {\n      this.tooltipHandler.destroy();\n    }\n    if (this.selectionCellsHandler != null) {\n      this.selectionCellsHandler.destroy();\n    }\n    if (this.panningHandler != null) {\n      this.panningHandler.destroy();\n    }\n    if (this.popupMenuHandler != null) {\n      this.popupMenuHandler.destroy();\n    }\n    if (this.connectionHandler != null) {\n      this.connectionHandler.destroy();\n    }\n    if (this.graphHandler != null) {\n      this.graphHandler.destroy();\n    }\n    if (this.cellEditor != null) {\n      this.cellEditor.destroy();\n    }\n    if (this.view != null) {\n      this.view.destroy();\n    }\n    if (this.model != null && this.graphModelChangeListener != null) {\n      this.model.removeListener(this.graphModelChangeListener);\n      this.graphModelChangeListener = null;\n    }\n    this.container = null;\n  }\n};\nmxGraph.getName = function () {\n  return 'mxGraph';\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxCellOverlay\r\n *\r\n * Extends <mxEventSource> to implement a graph overlay, represented by an icon\r\n * and a tooltip. Overlays can handle and fire <click> events and are added to\r\n * the graph using <mxGraph.addCellOverlay>, and removed using\r\n * <mxGraph.removeCellOverlay>, or <mxGraph.removeCellOverlays> to remove all overlays.\r\n * The <mxGraph.getCellOverlays> function returns the array of overlays for a given\r\n * cell in a graph. If multiple overlays exist for the same cell, then\r\n * <getBounds> should be overridden in at least one of the overlays.\r\n *\r\n * Overlays appear on top of all cells in a special layer. If this is not\r\n * desirable, then the image must be rendered as part of the shape or label of\r\n * the cell instead.\r\n *\r\n * Example:\r\n *\r\n * The following adds a new overlays for a given vertex and selects the cell\r\n * if the overlay is clicked.\r\n *\r\n * (code)\r\n * var overlay = new mxCellOverlay(img, html);\r\n * graph.addCellOverlay(vertex, overlay);\r\n * overlay.addListener(mxEvent.CLICK, function(sender, evt)\r\n * {\r\n *   var cell = evt.getProperty('cell');\r\n *   graph.setSelectionCell(cell);\r\n * });\r\n * (end)\r\n *\r\n * For cell overlays to be printed use <mxPrintPreview.printOverlays>.\r\n *\r\n * Event: mxEvent.CLICK\r\n *\r\n * Fires when the user clicks on the overlay. The <code>event</code> property\r\n * contains the corresponding mouse event and the <code>cell</code> property\r\n * contains the cell. For touch devices this is fired if the element receives\r\n * a touchend event.\r\n *\r\n * Constructor: mxCellOverlay\r\n *\r\n * Constructs a new overlay using the given image and tooltip.\r\n *\r\n * Parameters:\r\n *\r\n * image - <mxImage> that represents the icon to be displayed.\r\n * tooltip - Optional string that specifies the tooltip.\r\n * align - Optional horizontal alignment for the overlay. Possible\r\n * values are <ALIGN_LEFT>, <ALIGN_CENTER> and <ALIGN_RIGHT>\r\n * (default).\r\n * verticalAlign - Vertical alignment for the overlay. Possible\r\n * values are <ALIGN_TOP>, <ALIGN_MIDDLE> and <ALIGN_BOTTOM>\r\n * (default).\r\n */\nvar _default = exports[\"default\"] = mxGraph;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxGraph.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxGraphConstants.js":
/*!***************************************************!*\
  !*** ./src/workflow/mxClient/mxGraphConstants.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n//TODO: 与mxGraphConstant整合\nvar mxGraphConstants = {\n  ALIGN_LEFT: 'left',\n  /**\r\n   * Variable: ALIGN_CENTER\r\n   *\r\n   * Constant for center horizontal alignment. Default is center.\r\n   */\n  ALIGN_CENTER: 'center',\n  /**\r\n   * Variable: ALIGN_RIGHT\r\n   *\r\n   * Constant for right horizontal alignment. Default is right.\r\n   */\n  ALIGN_RIGHT: 'right',\n  /**\r\n   * Variable: ALIGN_TOP\r\n   *\r\n   * Constant for top vertical alignment. Default is top.\r\n   */\n  ALIGN_TOP: 'top',\n  /**\r\n   * Variable: ALIGN_MIDDLE\r\n   *\r\n   * Constant for middle vertical alignment. Default is middle.\r\n   */\n  ALIGN_MIDDLE: 'middle',\n  /**\r\n   * Variable: ALIGN_BOTTOM\r\n   *\r\n   * Constant for bottom vertical alignment. Default is bottom.\r\n   */\n  ALIGN_BOTTOM: 'bottom',\n  /**\r\n   * Variable: NONE\r\n   *\r\n   * Defines the value for none. Default is \"none\".\r\n   */\n  NONE: 'none',\n  //from mxHierarchicalEdgeStyle\n  EDGE_ORTHOGONAL: 1,\n  EDGE_POLYLINE: 2,\n  EDGE_STRAIGHT: 3,\n  EDGE_CURVE: 4,\n  //from mxObjectIdentity\n  FIELD_NAME: 'mxObjectId',\n  STYLE_PORT_CONSTRAINT: 'portConstraint',\n  /**\r\n   * Variable: DIRECTION_MASK_NONE\r\n   *\r\n   * Constant for no direction.\r\n   */\n  DIRECTION_MASK_NONE: 0,\n  /**\r\n   * Variable: DIRECTION_MASK_WEST\r\n   *\r\n   * Bitwise mask for west direction.\r\n   */\n  DIRECTION_MASK_WEST: 1,\n  /**\r\n   * Variable: DIRECTION_MASK_NORTH\r\n   *\r\n   * Bitwise mask for north direction.\r\n   */\n  DIRECTION_MASK_NORTH: 2,\n  /**\r\n   * Variable: DIRECTION_MASK_SOUTH\r\n   *\r\n   * Bitwise mask for south direction.\r\n   */\n  DIRECTION_MASK_SOUTH: 4,\n  /**\r\n   * Variable: DIRECTION_MASK_EAST\r\n   *\r\n   * Bitwise mask for east direction.\r\n   */\n  DIRECTION_MASK_EAST: 8,\n  /**\r\n   * Variable: DIRECTION_MASK_ALL\r\n   *\r\n   * Bitwise mask for all directions.\r\n   */\n  DIRECTION_MASK_ALL: 15,\n  STYLE_ROTATION: 'rotation',\n  /**\r\n   * Variable: DIRECTION_NORTH\r\n   *\r\n   * Constant for direction north. Default is north.\r\n   */\n  DIRECTION_NORTH: 'north',\n  /**\r\n   * Variable: DIRECTION_SOUTH\r\n   *\r\n   * Constant for direction south. Default is south.\r\n   */\n  DIRECTION_SOUTH: 'south',\n  /**\r\n   * Variable: DIRECTION_EAST\r\n   *\r\n   * Constant for direction east. Default is east.\r\n   */\n  DIRECTION_EAST: 'east',\n  /**\r\n   * Variable: DIRECTION_WEST\r\n   *\r\n   * Constant for direction west. Default is west.\r\n   */\n  DIRECTION_WEST: 'west',\n  /**\r\n   * Variable: NODETYPE_ELEMENT\r\n   *\r\n   * DOM node of type ELEMENT.\r\n   */\n  NODETYPE_ELEMENT: 1,\n  /**\r\n   * Variable: NODETYPE_ATTRIBUTE\r\n   *\r\n   * DOM node of type ATTRIBUTE.\r\n   */\n  NODETYPE_ATTRIBUTE: 2,\n  /**\r\n   * Variable: NODETYPE_TEXT\r\n   *\r\n   * DOM node of type TEXT.\r\n   */\n  NODETYPE_TEXT: 3,\n  /**\r\n   * Variable: NODETYPE_CDATA\r\n   *\r\n   * DOM node of type CDATA.\r\n   */\n  NODETYPE_CDATA: 4,\n  /**\r\n   * Variable: NODETYPE_ENTITY_REFERENCE\r\n   *\r\n   * DOM node of type ENTITY_REFERENCE.\r\n   */\n  NODETYPE_ENTITY_REFERENCE: 5,\n  /**\r\n   * Variable: NODETYPE_ENTITY\r\n   *\r\n   * DOM node of type ENTITY.\r\n   */\n  NODETYPE_ENTITY: 6,\n  /**\r\n   * Variable: NODETYPE_PROCESSING_INSTRUCTION\r\n   *\r\n   * DOM node of type PROCESSING_INSTRUCTION.\r\n   */\n  NODETYPE_PROCESSING_INSTRUCTION: 7,\n  /**\r\n   * Variable: NODETYPE_COMMENT\r\n   *\r\n   * DOM node of type COMMENT.\r\n   */\n  NODETYPE_COMMENT: 8,\n  /**\r\n   * Variable: NODETYPE_DOCUMENT\r\n   *\r\n   * DOM node of type DOCUMENT.\r\n   */\n  NODETYPE_DOCUMENT: 9,\n  /**\r\n   * Variable: NODETYPE_DOCUMENTTYPE\r\n   *\r\n   * DOM node of type DOCUMENTTYPE.\r\n   */\n  NODETYPE_DOCUMENTTYPE: 10,\n  /**\r\n   * Variable: NODETYPE_DOCUMENT_FRAGMENT\r\n   *\r\n   * DOM node of type DOCUMENT_FRAGMENT.\r\n   */\n  NODETYPE_DOCUMENT_FRAGMENT: 11,\n  COLLAPSED_IMAGE: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTVweCIgaGVpZ2h0PSIxNXB4IiB2aWV3Qm94PSIwIDAgMTUgMTUiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8ZGVmcz4KICAgICAgICA8bGluZWFyR3JhZGllbnQgeDE9IjQ1LjMzMzA4NzQlIiB5MT0iMTAwJSIgeDI9IjQ1LjMzMzA4NzYlIiB5Mj0iMCUiIGlkPSJsaW5lYXJHcmFkaWVudC0xIj4KICAgICAgICAgICAgPHN0b3Agc3RvcC1jb2xvcj0iIzUyOTVGMSIgb2Zmc2V0PSIwJSI+PC9zdG9wPgogICAgICAgICAgICA8c3RvcCBzdG9wLWNvbG9yPSIjNDRBN0Y5IiBvZmZzZXQ9IjEwMCUiPjwvc3RvcD4KICAgICAgICA8L2xpbmVhckdyYWRpZW50PgogICAgPC9kZWZzPgogICAgPGcgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTExNzQuMDAwMDAwLCAtMzgzLjAwMDAwMCkiPgogICAgICAgICAgICA8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSg5MTguMDAwMDAwLCAzNzMuMDAwMDAwKSI+CiAgICAgICAgICAgICAgICA8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyNTYuMDAwMDAwLCAxMC4wMDAwMDApIj4KICAgICAgICAgICAgICAgICAgICA8Y2lyY2xlIGZpbGw9IiM1NUI0RkYiIGN4PSI3LjUiIGN5PSI3LjUiIHI9IjcuNSI+PC9jaXJjbGU+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTcsNyBMMyw3IEwzLDggTDcsOCBMNywxMiBMOCwxMiBMOCw4IEwxMiw4IEwxMiw3IEw4LDcgTDgsMyBMNywzIEw3LDcgWiIgZmlsbD0iI0ZGRkZGRiIgZmlsbC1ydWxlPSJub256ZXJvIj48L3BhdGg+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgIDwvZz4KICAgICAgICA8L2c+CiAgICA8L2c+Cjwvc3ZnPg==',\n  EXPANDED_IMAGE: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTVweCIgaGVpZ2h0PSIxNXB4IiB2aWV3Qm94PSIwIDAgMTUgMTUiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8ZGVmcz4KICAgICAgICA8bGluZWFyR3JhZGllbnQgeDE9IjQ1LjMzMzA4NzQlIiB5MT0iMTAwJSIgeDI9IjQ1LjMzMzA4NzYlIiB5Mj0iMCUiIGlkPSJsaW5lYXJHcmFkaWVudC0xIj4KICAgICAgICAgICAgPHN0b3Agc3RvcC1jb2xvcj0iIzUyOTVGMSIgb2Zmc2V0PSIwJSI+PC9zdG9wPgogICAgICAgICAgICA8c3RvcCBzdG9wLWNvbG9yPSIjNDRBN0Y5IiBvZmZzZXQ9IjEwMCUiPjwvc3RvcD4KICAgICAgICA8L2xpbmVhckdyYWRpZW50PgogICAgPC9kZWZzPgogICAgPGcgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTU4MS4wMDAwMDAsIC0zODYuMDAwMDAwKSI+CiAgICAgICAgICAgIDxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDMyNS4wMDAwMDAsIDM3Ni4wMDAwMDApIj4KICAgICAgICAgICAgICAgIDxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDI1Ni4wMDAwMDAsIDEwLjAwMDAwMCkiPgogICAgICAgICAgICAgICAgICAgIDxjaXJjbGUgZmlsbD0iIzU1QjRGRiIgY3g9IjcuNSIgY3k9IjcuNSIgcj0iNy41Ij48L2NpcmNsZT4KICAgICAgICAgICAgICAgICAgICA8cG9seWdvbiBmaWxsPSIjRkZGRkZGIiBmaWxsLXJ1bGU9Im5vbnplcm8iIHBvaW50cz0iMyA4IDEyIDggMTIgNyAzIDciPjwvcG9seWdvbj4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgPC9nPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+'\n};\nvar _default = exports[\"default\"] = mxGraphConstants;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxGraphConstants.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxGraphHandler.js":
/*!*************************************************!*\
  !*** ./src/workflow/mxClient/mxGraphHandler.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.function.bind.js */ \"../../node_modules/core-js/modules/es.function.bind.js\");\nvar _mxGuide = _interopRequireDefault(__webpack_require__(/*! ./mxGuide.js */ \"./src/workflow/mxClient/mxGuide.js\"));\nvar _mxClient = _interopRequireDefault(__webpack_require__(/*! ./mxClient.js */ \"./src/workflow/mxClient/mxClient.js\"));\nvar _mxEvent = _interopRequireDefault(__webpack_require__(/*! ./mxEvent.js */ \"./src/workflow/mxClient/mxEvent.js\"));\nvar _mxPoint = _interopRequireDefault(__webpack_require__(/*! ./mxPoint.js */ \"./src/workflow/mxClient/mxPoint.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxRectangle = _interopRequireDefault(__webpack_require__(/*! ./mxRectangle.js */ \"./src/workflow/mxClient/mxRectangle.js\"));\nvar _mxCellHighlight = _interopRequireDefault(__webpack_require__(/*! ./mxCellHighlight.js */ \"./src/workflow/mxClient/mxCellHighlight.js\"));\nvar _mxRectangleShape = _interopRequireDefault(__webpack_require__(/*! ./mxRectangleShape.js */ \"./src/workflow/mxClient/mxRectangleShape.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ./mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nvar _mxUtils = _interopRequireDefault(__webpack_require__(/*! ./mxUtils.js */ \"./src/workflow/mxClient/mxUtils.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxGraphHandler(graph) {\n  this.graph = graph;\n  this.graph.addMouseListener(this);\n\n  // Repaints the handler after autoscroll\n  this.panHandler = _mxGraphUtils[\"default\"].bind(this, function () {\n    this.updatePreviewShape();\n    this.updateHint();\n  });\n  this.graph.addListener(_mxEvent[\"default\"].PAN, this.panHandler);\n\n  // Handles escape keystrokes\n  this.escapeHandler = _mxGraphUtils[\"default\"].bind(this, function (sender, evt) {\n    this.reset();\n  });\n  this.graph.addListener(_mxEvent[\"default\"].ESCAPE, this.escapeHandler);\n}\n;\n\n/**\r\n * Variable: graph\r\n *\r\n * Reference to the enclosing <mxGraph>.\r\n */\nmxGraphHandler.prototype.graph = null;\n\n/**\r\n * Variable: maxCells\r\n *\r\n * Defines the maximum number of cells to paint subhandles\r\n * for. Default is 50 for Firefox and 20 for IE. Set this\r\n * to 0 if you want an unlimited number of handles to be\r\n * displayed. This is only recommended if the number of\r\n * cells in the graph is limited to a small number, eg.\r\n * 500.\r\n */\nmxGraphHandler.prototype.maxCells = _mxClient[\"default\"].IS_IE ? 20 : 50;\n\n/**\r\n * Variable: enabled\r\n *\r\n * Specifies if events are handled. Default is true.\r\n */\nmxGraphHandler.prototype.enabled = true;\n\n/**\r\n * Variable: highlightEnabled\r\n *\r\n * Specifies if drop targets under the mouse should be enabled. Default is\r\n * true.\r\n */\nmxGraphHandler.prototype.highlightEnabled = true;\n\n/**\r\n * Variable: cloneEnabled\r\n *\r\n * Specifies if cloning by control-drag is enabled. Default is true.\r\n */\nmxGraphHandler.prototype.cloneEnabled = true;\n\n/**\r\n * Variable: moveEnabled\r\n *\r\n * Specifies if moving is enabled. Default is true.\r\n */\nmxGraphHandler.prototype.moveEnabled = true;\n\n/**\r\n * Variable: guidesEnabled\r\n *\r\n * Specifies if other cells should be used for snapping the right, center or\r\n * left side of the current selection. Default is false.\r\n */\nmxGraphHandler.prototype.guidesEnabled = false;\n\n/**\r\n * Variable: guide\r\n *\r\n * Holds the <mxGuide> instance that is used for alignment.\r\n */\nmxGraphHandler.prototype.guide = null;\n\n/**\r\n * Variable: currentDx\r\n *\r\n * Stores the x-coordinate of the current mouse move.\r\n */\nmxGraphHandler.prototype.currentDx = null;\n\n/**\r\n * Variable: currentDy\r\n *\r\n * Stores the y-coordinate of the current mouse move.\r\n */\nmxGraphHandler.prototype.currentDy = null;\n\n/**\r\n * Variable: updateCursor\r\n *\r\n * Specifies if a move cursor should be shown if the mouse is over a movable\r\n * cell. Default is true.\r\n */\nmxGraphHandler.prototype.updateCursor = true;\n\n/**\r\n * Variable: selectEnabled\r\n *\r\n * Specifies if selecting is enabled. Default is true.\r\n */\nmxGraphHandler.prototype.selectEnabled = true;\n\n/**\r\n * Variable: removeCellsFromParent\r\n *\r\n * Specifies if cells may be moved out of their parents. Default is true.\r\n */\nmxGraphHandler.prototype.removeCellsFromParent = true;\n\n/**\r\n * Variable: connectOnDrop\r\n *\r\n * Specifies if drop events are interpreted as new connections if no other\r\n * drop action is defined. Default is false.\r\n */\nmxGraphHandler.prototype.connectOnDrop = false;\n\n/**\r\n * Variable: scrollOnMove\r\n *\r\n * Specifies if the view should be scrolled so that a moved cell is\r\n * visible. Default is true.\r\n */\nmxGraphHandler.prototype.scrollOnMove = true;\n\n/**\r\n * Variable: minimumSize\r\n *\r\n * Specifies the minimum number of pixels for the width and height of a\r\n * selection border. Default is 6.\r\n */\nmxGraphHandler.prototype.minimumSize = 6;\n\n/**\r\n * Variable: previewColor\r\n *\r\n * Specifies the color of the preview shape. Default is black.\r\n */\nmxGraphHandler.prototype.previewColor = 'black';\n\n/**\r\n * Variable: htmlPreview\r\n *\r\n * Specifies if the graph container should be used for preview. If this is used\r\n * then drop target detection relies entirely on <mxGraph.getCellAt> because\r\n * the HTML preview does not \"let events through\". Default is false.\r\n */\nmxGraphHandler.prototype.htmlPreview = false;\n\n/**\r\n * Variable: shape\r\n *\r\n * Reference to the <mxShape> that represents the preview.\r\n */\nmxGraphHandler.prototype.shape = null;\n\n/**\r\n * Variable: scaleGrid\r\n *\r\n * Specifies if the grid should be scaled. Default is false.\r\n */\nmxGraphHandler.prototype.scaleGrid = false;\n\n/**\r\n * Variable: rotationEnabled\r\n *\r\n * Specifies if the bounding box should allow for rotation. Default is true.\r\n */\nmxGraphHandler.prototype.rotationEnabled = true;\n\n/**\r\n * Function: isEnabled\r\n *\r\n * Returns <enabled>.\r\n */\nmxGraphHandler.prototype.isEnabled = function () {\n  return this.enabled;\n};\n\n/**\r\n * Function: setEnabled\r\n *\r\n * Sets <enabled>.\r\n */\nmxGraphHandler.prototype.setEnabled = function (value) {\n  this.enabled = value;\n};\n\n/**\r\n * Function: isCloneEnabled\r\n *\r\n * Returns <cloneEnabled>.\r\n */\nmxGraphHandler.prototype.isCloneEnabled = function () {\n  return this.cloneEnabled;\n};\n\n/**\r\n * Function: setCloneEnabled\r\n *\r\n * Sets <cloneEnabled>.\r\n *\r\n * Parameters:\r\n *\r\n * value - Boolean that specifies the new clone enabled state.\r\n */\nmxGraphHandler.prototype.setCloneEnabled = function (value) {\n  this.cloneEnabled = value;\n};\n\n/**\r\n * Function: isMoveEnabled\r\n *\r\n * Returns <moveEnabled>.\r\n */\nmxGraphHandler.prototype.isMoveEnabled = function () {\n  return this.moveEnabled;\n};\n\n/**\r\n * Function: setMoveEnabled\r\n *\r\n * Sets <moveEnabled>.\r\n */\nmxGraphHandler.prototype.setMoveEnabled = function (value) {\n  this.moveEnabled = value;\n};\n\n/**\r\n * Function: isSelectEnabled\r\n *\r\n * Returns <selectEnabled>.\r\n */\nmxGraphHandler.prototype.isSelectEnabled = function () {\n  return this.selectEnabled;\n};\n\n/**\r\n * Function: setSelectEnabled\r\n *\r\n * Sets <selectEnabled>.\r\n */\nmxGraphHandler.prototype.setSelectEnabled = function (value) {\n  this.selectEnabled = value;\n};\n\n/**\r\n * Function: isRemoveCellsFromParent\r\n *\r\n * Returns <removeCellsFromParent>.\r\n */\nmxGraphHandler.prototype.isRemoveCellsFromParent = function () {\n  return this.removeCellsFromParent;\n};\n\n/**\r\n * Function: setRemoveCellsFromParent\r\n *\r\n * Sets <removeCellsFromParent>.\r\n */\nmxGraphHandler.prototype.setRemoveCellsFromParent = function (value) {\n  this.removeCellsFromParent = value;\n};\n\n/**\r\n * Function: getInitialCellForEvent\r\n *\r\n * Hook to return initial cell for the given event.\r\n */\nmxGraphHandler.prototype.getInitialCellForEvent = function (me) {\n  return me.getCell();\n};\n\n/**\r\n * Function: isDelayedSelection\r\n *\r\n * Hook to return true for delayed selections.\r\n */\nmxGraphHandler.prototype.isDelayedSelection = function (cell, me) {\n  return this.graph.isCellSelected(cell);\n};\n\n/**\r\n * Function: mouseDown\r\n *\r\n * Handles the event by selecing the given cell and creating a handle for\r\n * it. By consuming the event all subsequent events of the gesture are\r\n * redirected to this handler.\r\n */\nmxGraphHandler.prototype.mouseDown = function (sender, me) {\n  if (!me.isConsumed() && this.isEnabled() && this.graph.isEnabled() && me.getState() != null && !_mxEvent[\"default\"].isMultiTouchEvent(me.getEvent())) {\n    var cell = this.getInitialCellForEvent(me);\n    this.delayedSelection = this.isDelayedSelection(cell, me);\n    this.cell = null;\n    if (this.isSelectEnabled() && !this.delayedSelection) {\n      this.graph.selectCellForEvent(cell, me.getEvent());\n    }\n    if (this.isMoveEnabled()) {\n      var model = this.graph.model;\n      var geo = model.getGeometry(cell);\n      if (this.graph.isCellMovable(cell) && (!model.isEdge(cell) || this.graph.getSelectionCount() > 1 || geo.points != null && geo.points.length > 0 || model.getTerminal(cell, true) == null || model.getTerminal(cell, false) == null || this.graph.allowDanglingEdges || this.graph.isCloneEvent(me.getEvent()) && this.graph.isCellsCloneable())) {\n        this.start(cell, me.getX(), me.getY());\n      } else if (this.delayedSelection) {\n        this.cell = cell;\n      }\n      this.cellWasClicked = true;\n      me.consume();\n    }\n  }\n};\n\n/**\r\n * Function: getGuideStates\r\n *\r\n * Creates an array of cell states which should be used as guides.\r\n */\nmxGraphHandler.prototype.getGuideStates = function () {\n  var parent = this.graph.getDefaultParent();\n  var model = this.graph.getModel();\n  var filter = _mxGraphUtils[\"default\"].bind(this, function (cell) {\n    return this.graph.view.getState(cell) != null && model.isVertex(cell) && model.getGeometry(cell) != null && !model.getGeometry(cell).relative;\n  });\n  return this.graph.view.getCellStates(model.filterDescendants(filter, parent));\n};\n\n/**\r\n * Function: getCells\r\n *\r\n * Returns the cells to be modified by this handler. This implementation\r\n * returns all selection cells that are movable, or the given initial cell if\r\n * the given cell is not selected and movable. This handles the case of moving\r\n * unselectable or unselected cells.\r\n *\r\n * Parameters:\r\n *\r\n * initialCell - <mxCell> that triggered this handler.\r\n */\nmxGraphHandler.prototype.getCells = function (initialCell) {\n  if (!this.delayedSelection && this.graph.isCellMovable(initialCell)) {\n    return [initialCell];\n  } else {\n    return this.graph.getMovableCells(this.graph.getSelectionCells());\n  }\n};\n\n/**\r\n * Function: getPreviewBounds\r\n *\r\n * Returns the <mxRectangle> used as the preview bounds for\r\n * moving the given cells.\r\n */\nmxGraphHandler.prototype.getPreviewBounds = function (cells) {\n  var bounds = this.getBoundingBox(cells);\n  if (bounds != null) {\n    // Corrects width and height\n    bounds.width = Math.max(0, bounds.width - 1);\n    bounds.height = Math.max(0, bounds.height - 1);\n    if (bounds.width < this.minimumSize) {\n      var dx = this.minimumSize - bounds.width;\n      bounds.x -= dx / 2;\n      bounds.width = this.minimumSize;\n    } else {\n      bounds.x = Math.round(bounds.x);\n      bounds.width = Math.ceil(bounds.width);\n    }\n    var tr = this.graph.view.translate;\n    var s = this.graph.view.scale;\n    if (bounds.height < this.minimumSize) {\n      var dy = this.minimumSize - bounds.height;\n      bounds.y -= dy / 2;\n      bounds.height = this.minimumSize;\n    } else {\n      bounds.y = Math.round(bounds.y);\n      bounds.height = Math.ceil(bounds.height);\n    }\n  }\n  return bounds;\n};\n\n/**\r\n * Function: getBoundingBox\r\n *\r\n * Returns the union of the <mxCellStates> for the given array of <mxCells>.\r\n * For vertices, this method uses the bounding box of the corresponding shape\r\n * if one exists. The bounding box of the corresponding text label and all\r\n * controls and overlays are ignored. See also: <mxGraphView.getBounds> and\r\n * <mxGraph.getBoundingBox>.\r\n *\r\n * Parameters:\r\n *\r\n * cells - Array of <mxCells> whose bounding box should be returned.\r\n */\nmxGraphHandler.prototype.getBoundingBox = function (cells) {\n  var result = null;\n  if (cells != null && cells.length > 0) {\n    var model = this.graph.getModel();\n    for (var i = 0; i < cells.length; i++) {\n      if (model.isVertex(cells[i]) || model.isEdge(cells[i])) {\n        var state = this.graph.view.getState(cells[i]);\n        if (state != null) {\n          var bbox = state;\n          if (model.isVertex(cells[i]) && state.shape != null && state.shape.boundingBox != null) {\n            bbox = state.shape.boundingBox;\n          }\n          if (result == null) {\n            result = _mxRectangle[\"default\"].fromRectangle(bbox);\n          } else {\n            result.add(bbox);\n          }\n        }\n      }\n    }\n  }\n  return result;\n};\n\n/**\r\n * Function: createPreviewShape\r\n *\r\n * Creates the shape used to draw the preview for the given bounds.\r\n */\nmxGraphHandler.prototype.createPreviewShape = function (bounds) {\n  var shape = new _mxRectangleShape[\"default\"](bounds, null, this.previewColor);\n  shape.isDashed = true;\n  if (this.htmlPreview) {\n    shape.dialect = _mxConstants[\"default\"].DIALECT_STRICTHTML;\n    shape.init(this.graph.container);\n  } else {\n    // Makes sure to use either VML or SVG shapes in order to implement\n    // event-transparency on the background area of the rectangle since\n    // HTML shapes do not let mouseevents through even when transparent\n    shape.dialect = this.graph.dialect != _mxConstants[\"default\"].DIALECT_SVG ? _mxConstants[\"default\"].DIALECT_VML : _mxConstants[\"default\"].DIALECT_SVG;\n    shape.init(this.graph.getView().getOverlayPane());\n    shape.pointerEvents = false;\n\n    // Workaround for artifacts on iOS\n    if (_mxClient[\"default\"].IS_IOS) {\n      shape.getSvgScreenOffset = function () {\n        return 0;\n      };\n    }\n  }\n  return shape;\n};\n\n/**\r\n * Function: start\r\n *\r\n * Starts the handling of the mouse gesture.\r\n */\nmxGraphHandler.prototype.start = function (cell, x, y) {\n  this.cell = cell;\n  this.first = _mxUtils[\"default\"].convertPoint(this.graph.container, x, y);\n  this.cells = this.getCells(this.cell);\n  this.bounds = this.graph.getView().getBounds(this.cells);\n  this.pBounds = this.getPreviewBounds(this.cells);\n  if (this.guidesEnabled) {\n    this.guide = new _mxGuide[\"default\"](this.graph, this.getGuideStates());\n  }\n};\n\n/**\r\n * Function: useGuidesForEvent\r\n *\r\n * Returns true if the guides should be used for the given <mxMouseEvent>.\r\n * This implementation returns <mxGuide.isEnabledForEvent>.\r\n */\nmxGraphHandler.prototype.useGuidesForEvent = function (me) {\n  return this.guide != null ? this.guide.isEnabledForEvent(me.getEvent()) : true;\n};\n\n/**\r\n * Function: snap\r\n *\r\n * Snaps the given vector to the grid and returns the given mxPoint instance.\r\n */\nmxGraphHandler.prototype.snap = function (vector) {\n  var scale = this.scaleGrid ? this.graph.view.scale : 1;\n  vector.x = this.graph.snap(vector.x / scale) * scale;\n  vector.y = this.graph.snap(vector.y / scale) * scale;\n  return vector;\n};\n\n/**\r\n * Function: getDelta\r\n *\r\n * Returns an <mxPoint> that represents the vector for moving the cells\r\n * for the given <mxMouseEvent>.\r\n */\nmxGraphHandler.prototype.getDelta = function (me) {\n  var point = _mxUtils[\"default\"].convertPoint(this.graph.container, me.getX(), me.getY());\n  var s = this.graph.view.scale;\n  return new _mxPoint[\"default\"](this.roundLength((point.x - this.first.x) / s) * s, this.roundLength((point.y - this.first.y) / s) * s);\n};\n\n/**\r\n * Function: updateHint\r\n *\r\n * Hook for subclassers do show details while the handler is active.\r\n */\nmxGraphHandler.prototype.updateHint = function (me) {};\n\n/**\r\n * Function: removeHint\r\n *\r\n * Hooks for subclassers to hide details when the handler gets inactive.\r\n */\nmxGraphHandler.prototype.removeHint = function () {};\n\n/**\r\n * Function: roundLength\r\n *\r\n * Hook for rounding the unscaled vector. This uses Math.round.\r\n */\nmxGraphHandler.prototype.roundLength = function (length) {\n  return Math.round(length);\n};\n\n/**\r\n * Function: mouseMove\r\n *\r\n * Handles the event by highlighting possible drop targets and updating the\r\n * preview.\r\n */\nmxGraphHandler.prototype.mouseMove = function (sender, me) {\n  var graph = this.graph;\n  if (!me.isConsumed() && graph.isMouseDown && this.cell != null && this.first != null && this.bounds != null) {\n    // Stops moving if a multi touch event is received\n    if (_mxEvent[\"default\"].isMultiTouchEvent(me.getEvent())) {\n      this.reset();\n      return;\n    }\n    var delta = this.getDelta(me);\n    var dx = delta.x;\n    var dy = delta.y;\n    var tol = graph.tolerance;\n    if (this.shape != null || Math.abs(dx) > tol || Math.abs(dy) > tol) {\n      // Highlight is used for highlighting drop targets\n      if (this.highlight == null) {\n        this.highlight = new _mxCellHighlight[\"default\"](this.graph, _mxConstants[\"default\"].DROP_TARGET_COLOR, 3);\n      }\n      if (this.shape == null) {\n        this.shape = this.createPreviewShape(this.bounds);\n      }\n      var gridEnabled = graph.isGridEnabledEvent(me.getEvent());\n      var hideGuide = true;\n      if (this.guide != null && this.useGuidesForEvent(me)) {\n        delta = this.guide.move(this.bounds, new _mxPoint[\"default\"](dx, dy), gridEnabled);\n        hideGuide = false;\n        dx = delta.x;\n        dy = delta.y;\n      } else if (gridEnabled) {\n        var trx = graph.getView().translate;\n        var scale = graph.getView().scale;\n        var tx = this.bounds.x - (graph.snap(this.bounds.x / scale - trx.x) + trx.x) * scale;\n        var ty = this.bounds.y - (graph.snap(this.bounds.y / scale - trx.y) + trx.y) * scale;\n        var v = this.snap(new _mxPoint[\"default\"](dx, dy));\n        dx = v.x - tx;\n        dy = v.y - ty;\n      }\n      if (this.guide != null && hideGuide) {\n        this.guide.hide();\n      }\n\n      // Constrained movement if shift key is pressed\n      if (graph.isConstrainedEvent(me.getEvent())) {\n        if (Math.abs(dx) > Math.abs(dy)) {\n          dy = 0;\n        } else {\n          dx = 0;\n        }\n      }\n      this.currentDx = dx;\n      this.currentDy = dy;\n      this.updatePreviewShape();\n      var target = null;\n      var cell = me.getCell();\n      var clone = graph.isCloneEvent(me.getEvent()) && graph.isCellsCloneable() && this.isCloneEnabled();\n      if (graph.isDropEnabled() && this.highlightEnabled) {\n        // Contains a call to getCellAt to find the cell under the mouse\n        target = graph.getDropTarget(this.cells, me.getEvent(), cell, clone);\n      }\n      var state = graph.getView().getState(target);\n      var highlight = false;\n      if (state != null && (graph.model.getParent(this.cell) != target || clone)) {\n        if (this.target != target) {\n          this.target = target;\n          this.setHighlightColor(_mxConstants[\"default\"].DROP_TARGET_COLOR);\n        }\n        highlight = true;\n      } else {\n        this.target = null;\n        if (this.connectOnDrop && cell != null && this.cells.length == 1 && graph.getModel().isVertex(cell) && graph.isCellConnectable(cell)) {\n          state = graph.getView().getState(cell);\n          if (state != null) {\n            var error = graph.getEdgeValidationError(null, this.cell, cell);\n            var color = error == null ? _mxConstants[\"default\"].VALID_COLOR : _mxConstants[\"default\"].INVALID_CONNECT_TARGET_COLOR;\n            this.setHighlightColor(color);\n            highlight = true;\n          }\n        }\n      }\n      if (state != null && highlight) {\n        this.highlight.highlight(state);\n      } else {\n        this.highlight.hide();\n      }\n    }\n    this.updateHint(me);\n    me.consume();\n\n    // Cancels the bubbling of events to the container so\n    // that the droptarget is not reset due to an mouseMove\n    // fired on the container with no associated state.\n    _mxEvent[\"default\"].consume(me.getEvent());\n  } else if ((this.isMoveEnabled() || this.isCloneEnabled()) && this.updateCursor && !me.isConsumed() && me.getState() != null && !graph.isMouseDown) {\n    var cursor = graph.getCursorForMouseEvent(me);\n    if (cursor == null && graph.isEnabled() && graph.isCellMovable(me.getCell())) {\n      if (graph.getModel().isEdge(me.getCell())) {\n        cursor = _mxConstants[\"default\"].CURSOR_MOVABLE_EDGE;\n      } else {\n        cursor = _mxConstants[\"default\"].CURSOR_MOVABLE_VERTEX;\n      }\n    }\n\n    // Sets the cursor on the original source state under the mouse\n    // instead of the event source state which can be the parent\n    if (me.sourceState != null) {\n      me.sourceState.setCursor(cursor);\n    }\n  }\n};\n\n/**\r\n * Function: updatePreviewShape\r\n *\r\n * Updates the bounds of the preview shape.\r\n */\nmxGraphHandler.prototype.updatePreviewShape = function () {\n  if (this.shape != null) {\n    this.shape.bounds = new _mxRectangle[\"default\"](Math.round(this.pBounds.x + this.currentDx - this.graph.panDx), Math.round(this.pBounds.y + this.currentDy - this.graph.panDy), this.pBounds.width, this.pBounds.height);\n    this.shape.redraw();\n  }\n};\n\n/**\r\n * Function: setHighlightColor\r\n *\r\n * Sets the color of the rectangle used to highlight drop targets.\r\n *\r\n * Parameters:\r\n *\r\n * color - String that represents the new highlight color.\r\n */\nmxGraphHandler.prototype.setHighlightColor = function (color) {\n  if (this.highlight != null) {\n    this.highlight.setHighlightColor(color);\n  }\n};\n\n/**\r\n * Function: mouseUp\r\n *\r\n * Handles the event by applying the changes to the selection cells.\r\n */\nmxGraphHandler.prototype.mouseUp = function (sender, me) {\n  if (!me.isConsumed()) {\n    var graph = this.graph;\n    if (this.cell != null && this.first != null && this.shape != null && this.currentDx != null && this.currentDy != null) {\n      var cell = me.getCell();\n      if (this.connectOnDrop && this.target == null && cell != null && graph.getModel().isVertex(cell) && graph.isCellConnectable(cell) && graph.isEdgeValid(null, this.cell, cell)) {\n        graph.connectionHandler.connect(this.cell, cell, me.getEvent());\n      } else {\n        var clone = graph.isCloneEvent(me.getEvent()) && graph.isCellsCloneable() && this.isCloneEnabled();\n        var scale = graph.getView().scale;\n        var dx = this.roundLength(this.currentDx / scale);\n        var dy = this.roundLength(this.currentDy / scale);\n        var target = this.target;\n        if (graph.isSplitEnabled() && graph.isSplitTarget(target, this.cells, me.getEvent())) {\n          graph.splitEdge(target, this.cells, null, dx, dy);\n        } else {\n          this.moveCells(this.cells, dx, dy, clone, this.target, me.getEvent());\n        }\n      }\n    } else if (this.isSelectEnabled() && this.delayedSelection && this.cell != null) {\n      this.selectDelayed(me);\n    }\n  }\n\n  // Consumes the event if a cell was initially clicked\n  if (this.cellWasClicked) {\n    me.consume();\n  }\n  this.reset();\n};\n\n/**\r\n * Function: selectDelayed\r\n *\r\n * Implements the delayed selection for the given mouse event.\r\n */\nmxGraphHandler.prototype.selectDelayed = function (me) {\n  if (!this.graph.isCellSelected(this.cell) || !this.graph.popupMenuHandler.isPopupTrigger(me)) {\n    this.graph.selectCellForEvent(this.cell, me.getEvent());\n  }\n};\n\n/**\r\n * Function: reset\r\n *\r\n * Resets the state of this handler.\r\n */\nmxGraphHandler.prototype.reset = function () {\n  this.destroyShapes();\n  this.removeHint();\n  this.cellWasClicked = false;\n  this.delayedSelection = false;\n  this.currentDx = null;\n  this.currentDy = null;\n  this.guides = null;\n  this.first = null;\n  this.cell = null;\n  this.target = null;\n};\n\n/**\r\n * Function: shouldRemoveCellsFromParent\r\n *\r\n * Returns true if the given cells should be removed from the parent for the specified\r\n * mousereleased event.\r\n */\nmxGraphHandler.prototype.shouldRemoveCellsFromParent = function (parent, cells, evt) {\n  if (this.graph.getModel().isVertex(parent)) {\n    var pState = this.graph.getView().getState(parent);\n    var pt = _mxUtils[\"default\"].convertPoint(this.graph.container, _mxEvent[\"default\"].getClientX(evt), _mxEvent[\"default\"].getClientY(evt));\n    var alpha = _mxUtils[\"default\"].toRadians(_mxGraphUtils[\"default\"].getValue(pState.style, _mxConstants[\"default\"].STYLE_ROTATION) || 0);\n    if (alpha != 0) {\n      var cos = Math.cos(-alpha);\n      var sin = Math.sin(-alpha);\n      var cx = new _mxPoint[\"default\"](pState.getCenterX(), pState.getCenterY());\n      pt = _mxUtils[\"default\"].getRotatedPoint(pt, cos, sin, cx);\n    }\n    return pState != null && !_mxUtils[\"default\"].contains(pState, pt.x, pt.y);\n  }\n  return false;\n};\n\n/**\r\n * Function: moveCells\r\n *\r\n * Moves the given cells by the specified amount.\r\n */\nmxGraphHandler.prototype.moveCells = function (cells, dx, dy, clone, target, evt) {\n  if (clone) {\n    cells = this.graph.getCloneableCells(cells);\n  }\n\n  // Removes cells from parent\n  if (target == null && this.isRemoveCellsFromParent() && this.shouldRemoveCellsFromParent(this.graph.getModel().getParent(this.cell), cells, evt)) {\n    target = this.graph.getDefaultParent();\n  }\n\n  // Passes all selected cells in order to correctly clone or move into\n  // the target cell. The method checks for each cell if its movable.\n  cells = this.graph.moveCells(cells, dx - this.graph.panDx / this.graph.view.scale, dy - this.graph.panDy / this.graph.view.scale, clone, target, evt);\n  if (this.isSelectEnabled() && this.scrollOnMove) {\n    this.graph.scrollCellToVisible(cells[0]);\n  }\n\n  // Selects the new cells if cells have been cloned\n  if (clone) {\n    this.graph.setSelectionCells(cells);\n  }\n};\n\n/**\r\n * Function: destroyShapes\r\n *\r\n * Destroy the preview and highlight shapes.\r\n */\nmxGraphHandler.prototype.destroyShapes = function () {\n  // Destroys the preview dashed rectangle\n  if (this.shape != null) {\n    this.shape.destroy();\n    this.shape = null;\n  }\n  if (this.guide != null) {\n    this.guide.destroy();\n    this.guide = null;\n  }\n\n  // Destroys the drop target highlight\n  if (this.highlight != null) {\n    this.highlight.destroy();\n    this.highlight = null;\n  }\n};\n\n/**\r\n * Function: destroy\r\n *\r\n * Destroys the handler and all its resources and DOM nodes.\r\n */\nmxGraphHandler.prototype.destroy = function () {\n  this.graph.removeMouseListener(this);\n  this.graph.removeListener(this.panHandler);\n  if (this.escapeHandler != null) {\n    this.graph.removeListener(this.escapeHandler);\n    this.escapeHandler = null;\n  }\n  this.destroyShapes();\n  this.removeHint();\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxPanningHandler\r\n *\r\n * Event handler that pans and creates popupmenus. To use the left\r\n * mousebutton for panning without interfering with cell moving and\r\n * resizing, use <isUseLeftButton> and <isIgnoreCell>. For grid size\r\n * steps while panning, use <useGrid>. This handler is built-into\r\n * <mxGraph.panningHandler> and enabled using <mxGraph.setPanning>.\r\n *\r\n * Constructor: mxPanningHandler\r\n *\r\n * Constructs an event handler that creates a <mxPopupMenu>\r\n * and pans the graph.\r\n *\r\n * Event: mxEvent.PAN_START\r\n *\r\n * Fires when the panning handler changes its <active> state to true. The\r\n * <code>event</code> property contains the corresponding <mxMouseEvent>.\r\n *\r\n * Event: mxEvent.PAN\r\n *\r\n * Fires while handle is processing events. The <code>event</code> property contains\r\n * the corresponding <mxMouseEvent>.\r\n *\r\n * Event: mxEvent.PAN_END\r\n *\r\n * Fires when the panning handler changes its <active> state to false. The\r\n * <code>event</code> property contains the corresponding <mxMouseEvent>.\r\n */\nvar _default = exports[\"default\"] = mxGraphHandler;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxGraphHandler.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxGraphLayout.js":
/*!************************************************!*\
  !*** ./src/workflow/mxClient/mxGraphLayout.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _mxPoint = _interopRequireDefault(__webpack_require__(/*! ./mxPoint.js */ \"./src/workflow/mxClient/mxPoint.js\"));\nvar _mxDictionary = _interopRequireDefault(__webpack_require__(/*! ./mxDictionary.js */ \"./src/workflow/mxClient/mxDictionary.js\"));\nvar _mxRectangle = _interopRequireDefault(__webpack_require__(/*! ./mxRectangle.js */ \"./src/workflow/mxClient/mxRectangle.js\"));\nvar _mxGeometry = _interopRequireDefault(__webpack_require__(/*! ./mxGeometry.js */ \"./src/workflow/mxClient/mxGeometry.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ./mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxGraphLayout(graph) {\n  this.graph = graph;\n}\n;\n\n/**\r\n * Variable: graph\r\n *\r\n * Reference to the enclosing <mxGraph>.\r\n */\nmxGraphLayout.prototype.graph = null;\n\n/**\r\n * Variable: useBoundingBox\r\n *\r\n * Boolean indicating if the bounding box of the label should be used if\r\n * its available. Default is true.\r\n */\nmxGraphLayout.prototype.useBoundingBox = true;\n\n/**\r\n * Variable: parent\r\n *\r\n * The parent cell of the layout, if any\r\n */\nmxGraphLayout.prototype.parent = null;\n\n/**\r\n * Function: moveCell\r\n *\r\n * Notified when a cell is being moved in a parent that has automatic\r\n * layout to update the cell state (eg. index) so that the outcome of the\r\n * layout will position the vertex as close to the point (x, y) as\r\n * possible.\r\n *\r\n * Empty implementation.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> which has been moved.\r\n * x - X-coordinate of the new cell location.\r\n * y - Y-coordinate of the new cell location.\r\n */\nmxGraphLayout.prototype.moveCell = function (cell, x, y) {};\n\n/**\r\n * Function: execute\r\n *\r\n * Executes the layout algorithm for the children of the given parent.\r\n *\r\n * Parameters:\r\n *\r\n * parent - <mxCell> whose children should be layed out.\r\n */\nmxGraphLayout.prototype.execute = function (parent) {};\n\n/**\r\n * Function: getGraph\r\n *\r\n * Returns the graph that this layout operates on.\r\n */\nmxGraphLayout.prototype.getGraph = function () {\n  return this.graph;\n};\n\n/**\r\n * Function: getConstraint\r\n *\r\n * Returns the constraint for the given key and cell. The optional edge and\r\n * source arguments are used to return inbound and outgoing routing-\r\n * constraints for the given edge and vertex. This implementation always\r\n * returns the value for the given key in the style of the given cell.\r\n *\r\n * Parameters:\r\n *\r\n * key - Key of the constraint to be returned.\r\n * cell - <mxCell> whose constraint should be returned.\r\n * edge - Optional <mxCell> that represents the connection whose constraint\r\n * should be returned. Default is null.\r\n * source - Optional boolean that specifies if the connection is incoming\r\n * or outgoing. Default is null.\r\n */\nmxGraphLayout.prototype.getConstraint = function (key, cell, edge, source) {\n  var state = this.graph.view.getState(cell);\n  var style = state != null ? state.style : this.graph.getCellStyle(cell);\n  return style != null ? style[key] : null;\n};\n\n/**\r\n * Function: traverse\r\n *\r\n * Traverses the (directed) graph invoking the given function for each\r\n * visited vertex and edge. The function is invoked with the current vertex\r\n * and the incoming edge as a parameter. This implementation makes sure\r\n * each vertex is only visited once. The function may return false if the\r\n * traversal should stop at the given vertex.\r\n *\r\n * Example:\r\n *\r\n * (code)\r\n * mxLog.show();\r\n * var cell = graph.getSelectionCell();\r\n * graph.traverse(cell, false, function(vertex, edge)\r\n * {\r\n *   mxLog.debug(graph.getLabel(vertex));\r\n * });\r\n * (end)\r\n *\r\n * Parameters:\r\n *\r\n * vertex - <mxCell> that represents the vertex where the traversal starts.\r\n * directed - Optional boolean indicating if edges should only be traversed\r\n * from source to target. Default is true.\r\n * func - Visitor function that takes the current vertex and the incoming\r\n * edge as arguments. The traversal stops if the function returns false.\r\n * edge - Optional <mxCell> that represents the incoming edge. This is\r\n * null for the first step of the traversal.\r\n * visited - Optional <mxDictionary> of cell paths for the visited cells.\r\n */\nmxGraphLayout.traverse = function (vertex, directed, func, edge, visited) {\n  if (func != null && vertex != null) {\n    directed = directed != null ? directed : true;\n    visited = visited || new _mxDictionary[\"default\"]();\n    if (!visited.get(vertex)) {\n      visited.put(vertex, true);\n      var result = func(vertex, edge);\n      if (result == null || result) {\n        var edgeCount = this.graph.model.getEdgeCount(vertex);\n        if (edgeCount > 0) {\n          for (var i = 0; i < edgeCount; i++) {\n            var e = this.graph.model.getEdgeAt(vertex, i);\n            var isSource = this.graph.model.getTerminal(e, true) == vertex;\n            if (!directed || isSource) {\n              var next = this.graph.view.getVisibleTerminal(e, !isSource);\n              this.traverse(next, directed, func, e, visited);\n            }\n          }\n        }\n      }\n    }\n  }\n};\n\n/**\r\n * Function: isVertexMovable\r\n *\r\n * Returns a boolean indicating if the given <mxCell> is movable or\r\n * bendable by the algorithm. This implementation returns true if the given\r\n * cell is movable in the graph.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose movable state should be returned.\r\n */\nmxGraphLayout.prototype.isVertexMovable = function (cell) {\n  return this.graph.isCellMovable(cell);\n};\n\n/**\r\n * Function: isVertexIgnored\r\n *\r\n * Returns a boolean indicating if the given <mxCell> should be ignored by\r\n * the algorithm. This implementation returns false for all vertices.\r\n *\r\n * Parameters:\r\n *\r\n * vertex - <mxCell> whose ignored state should be returned.\r\n */\nmxGraphLayout.prototype.isVertexIgnored = function (vertex) {\n  return !this.graph.getModel().isVertex(vertex) || !this.graph.isCellVisible(vertex);\n};\n\n/**\r\n * Function: isEdgeIgnored\r\n *\r\n * Returns a boolean indicating if the given <mxCell> should be ignored by\r\n * the algorithm. This implementation returns false for all vertices.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose ignored state should be returned.\r\n */\nmxGraphLayout.prototype.isEdgeIgnored = function (edge) {\n  var model = this.graph.getModel();\n  return !model.isEdge(edge) || !this.graph.isCellVisible(edge) || model.getTerminal(edge, true) == null || model.getTerminal(edge, false) == null;\n};\n\n/**\r\n * Function: setEdgeStyleEnabled\r\n *\r\n * Disables or enables the edge style of the given edge.\r\n */\nmxGraphLayout.prototype.setEdgeStyleEnabled = function (edge, value) {\n  this.graph.setCellStyles(_mxConstants[\"default\"].STYLE_NOEDGESTYLE, value ? '0' : '1', [edge]);\n};\n\n/**\r\n * Function: setOrthogonalEdge\r\n *\r\n * Disables or enables orthogonal end segments of the given edge.\r\n */\nmxGraphLayout.prototype.setOrthogonalEdge = function (edge, value) {\n  this.graph.setCellStyles(_mxConstants[\"default\"].STYLE_ORTHOGONAL, value ? '1' : '0', [edge]);\n};\n\n/**\r\n * Function: getParentOffset\r\n *\r\n * Determines the offset of the given parent to the parent\r\n * of the layout\r\n */\nmxGraphLayout.prototype.getParentOffset = function (parent) {\n  var result = new _mxPoint[\"default\"]();\n  if (parent != null && parent != this.parent) {\n    var model = this.graph.getModel();\n    if (model.isAncestor(this.parent, parent)) {\n      var parentGeo = model.getGeometry(parent);\n      while (parent != this.parent) {\n        result.x = result.x + parentGeo.x;\n        result.y = result.y + parentGeo.y;\n        parent = model.getParent(parent);\n        ;\n        parentGeo = model.getGeometry(parent);\n      }\n    }\n  }\n  return result;\n};\n\n/**\r\n * Function: setEdgePoints\r\n *\r\n * Replaces the array of mxPoints in the geometry of the given edge\r\n * with the given array of mxPoints.\r\n */\nmxGraphLayout.prototype.setEdgePoints = function (edge, points) {\n  if (edge != null) {\n    var model = this.graph.model;\n    var geometry = model.getGeometry(edge);\n    if (geometry == null) {\n      geometry = new _mxGeometry[\"default\"]();\n      geometry.setRelative(true);\n    } else {\n      geometry = geometry.clone();\n    }\n    if (this.parent != null && points != null) {\n      var parent = model.getParent(edge);\n      var parentOffset = this.getParentOffset(parent);\n      for (var i = 0; i < points.length; i++) {\n        points[i].x = points[i].x - parentOffset.x;\n        points[i].y = points[i].y - parentOffset.y;\n      }\n    }\n    geometry.points = points;\n    model.setGeometry(edge, geometry);\n  }\n};\n\n/**\r\n * Function: setVertexLocation\r\n *\r\n * Sets the new position of the given cell taking into account the size of\r\n * the bounding box if <useBoundingBox> is true. The change is only carried\r\n * out if the new location is not equal to the existing location, otherwise\r\n * the geometry is not replaced with an updated instance. The new or old\r\n * bounds are returned (including overlapping labels).\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose geometry is to be set.\r\n * x - Integer that defines the x-coordinate of the new location.\r\n * y - Integer that defines the y-coordinate of the new location.\r\n */\nmxGraphLayout.prototype.setVertexLocation = function (cell, x, y) {\n  var model = this.graph.getModel();\n  var geometry = model.getGeometry(cell);\n  var result = null;\n  if (geometry != null) {\n    result = new _mxRectangle[\"default\"](x, y, geometry.width, geometry.height);\n\n    // Checks for oversize labels and shifts the result\n    // TODO: Use mxUtils.getStringSize for label bounds\n    if (this.useBoundingBox) {\n      var state = this.graph.getView().getState(cell);\n      if (state != null && state.text != null && state.text.boundingBox != null) {\n        var scale = this.graph.getView().scale;\n        var box = state.text.boundingBox;\n        if (state.text.boundingBox.x < state.x) {\n          x += (state.x - box.x) / scale;\n          result.width = box.width;\n        }\n        if (state.text.boundingBox.y < state.y) {\n          y += (state.y - box.y) / scale;\n          result.height = box.height;\n        }\n      }\n    }\n    if (this.parent != null) {\n      var parent = model.getParent(cell);\n      if (parent != null && parent != this.parent) {\n        var parentOffset = this.getParentOffset(parent);\n        x = x - parentOffset.x;\n        y = y - parentOffset.y;\n      }\n    }\n    if (geometry.x != x || geometry.y != y) {\n      geometry = geometry.clone();\n      geometry.x = x;\n      geometry.y = y;\n      model.setGeometry(cell, geometry);\n    }\n  }\n  return result;\n};\n\n/**\r\n * Function: getVertexBounds\r\n *\r\n * Returns an <mxRectangle> that defines the bounds of the given cell or\r\n * the bounding box if <useBoundingBox> is true.\r\n */\nmxGraphLayout.prototype.getVertexBounds = function (cell) {\n  var geo = this.graph.getModel().getGeometry(cell);\n\n  // Checks for oversize label bounding box and corrects\n  // the return value accordingly\n  // TODO: Use mxUtils.getStringSize for label bounds\n  if (this.useBoundingBox) {\n    var state = this.graph.getView().getState(cell);\n    if (state != null && state.text != null && state.text.boundingBox != null) {\n      var scale = this.graph.getView().scale;\n      var tmp = state.text.boundingBox;\n      var dx0 = Math.max(state.x - tmp.x, 0) / scale;\n      var dy0 = Math.max(state.y - tmp.y, 0) / scale;\n      var dx1 = Math.max(tmp.x + tmp.width - (state.x + state.width), 0) / scale;\n      var dy1 = Math.max(tmp.y + tmp.height - (state.y + state.height), 0) / scale;\n      geo = new _mxRectangle[\"default\"](geo.x - dx0, geo.y - dy0, geo.width + dx0 + dx1, geo.height + dy0 + dy1);\n    }\n  }\n  if (this.parent != null) {\n    var parent = this.graph.getModel().getParent(cell);\n    geo = geo.clone();\n    if (parent != null && parent != this.parent) {\n      var parentOffset = this.getParentOffset(parent);\n      geo.x = geo.x + parentOffset.x;\n      geo.y = geo.y + parentOffset.y;\n    }\n  }\n  return new _mxRectangle[\"default\"](geo.x, geo.y, geo.width, geo.height);\n};\n\n/**\r\n * Function: arrangeGroups\r\n *\r\n * Shortcut to <mxGraph.updateGroupBounds> with moveGroup set to true.\r\n */\nmxGraphLayout.prototype.arrangeGroups = function (cells, border, topBorder, rightBorder, bottomBorder, leftBorder) {\n  return this.graph.updateGroupBounds(cells, border, true, topBorder, rightBorder, bottomBorder, leftBorder);\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxStackLayout\r\n *\r\n * Extends <mxGraphLayout> to create a horizontal or vertical stack of the\r\n * child vertices. The children do not need to be connected for this layout\r\n * to work.\r\n *\r\n * Example:\r\n *\r\n * (code)\r\n * var layout = new mxStackLayout(graph, true);\r\n * layout.execute(graph.getDefaultParent());\r\n * (end)\r\n *\r\n * Constructor: mxStackLayout\r\n *\r\n * Constructs a new stack layout layout for the specified graph,\r\n * spacing, orientation and offset.\r\n */\nvar _default = exports[\"default\"] = mxGraphLayout;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxGraphLayout.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxGraphModel.js":
/*!***********************************************!*\
  !*** ./src/workflow/mxClient/mxGraphModel.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.concat.js */ \"../../node_modules/core-js/modules/es.array.concat.js\");\n__webpack_require__(/*! core-js/modules/es.array.index-of.js */ \"../../node_modules/core-js/modules/es.array.index-of.js\");\nvar _mxCell = _interopRequireDefault(__webpack_require__(/*! ./mxCell.js */ \"./src/workflow/mxClient/mxCell.js\"));\nvar _mxEventObject = _interopRequireDefault(__webpack_require__(/*! ./mxEventObject.js */ \"./src/workflow/mxClient/mxEventObject.js\"));\nvar _mxVisibleChange = _interopRequireDefault(__webpack_require__(/*! ./mxVisibleChange.js */ \"./src/workflow/mxClient/mxVisibleChange.js\"));\nvar _mxGeometryChange = _interopRequireDefault(__webpack_require__(/*! ./mxGeometryChange.js */ \"./src/workflow/mxClient/mxGeometryChange.js\"));\nvar _mxEvent = _interopRequireDefault(__webpack_require__(/*! ./mxEvent.js */ \"./src/workflow/mxClient/mxEvent.js\"));\nvar _mxDictionary = _interopRequireDefault(__webpack_require__(/*! ./mxDictionary.js */ \"./src/workflow/mxClient/mxDictionary.js\"));\nvar _mxObjectIdentity = _interopRequireDefault(__webpack_require__(/*! ./mxObjectIdentity.js */ \"./src/workflow/mxClient/mxObjectIdentity.js\"));\nvar _mxPropertyChange = _interopRequireDefault(__webpack_require__(/*! ./mxPropertyChange.js */ \"./src/workflow/mxClient/mxPropertyChange.js\"));\nvar _mxStyleChange = _interopRequireDefault(__webpack_require__(/*! ./mxStyleChange.js */ \"./src/workflow/mxClient/mxStyleChange.js\"));\nvar _mxCellPath = _interopRequireDefault(__webpack_require__(/*! ./mxCellPath.js */ \"./src/workflow/mxClient/mxCellPath.js\"));\nvar _mxChildChange = _interopRequireDefault(__webpack_require__(/*! ./mxChildChange.js */ \"./src/workflow/mxClient/mxChildChange.js\"));\nvar _mxCollapseChange = _interopRequireDefault(__webpack_require__(/*! ./mxCollapseChange.js */ \"./src/workflow/mxClient/mxCollapseChange.js\"));\nvar _mxValueChange = _interopRequireDefault(__webpack_require__(/*! ./mxValueChange.js */ \"./src/workflow/mxClient/mxValueChange.js\"));\nvar _mxPoint = _interopRequireDefault(__webpack_require__(/*! ./mxPoint.js */ \"./src/workflow/mxClient/mxPoint.js\"));\nvar _mxRootChange = _interopRequireDefault(__webpack_require__(/*! ./mxRootChange.js */ \"./src/workflow/mxClient/mxRootChange.js\"));\nvar _mxEventSource = _interopRequireDefault(__webpack_require__(/*! ./mxEventSource.js */ \"./src/workflow/mxClient/mxEventSource.js\"));\nvar _mxTerminalChange = _interopRequireDefault(__webpack_require__(/*! ./mxTerminalChange.js */ \"./src/workflow/mxClient/mxTerminalChange.js\"));\nvar _mxUndoableEdit = _interopRequireDefault(__webpack_require__(/*! ./mxUndoableEdit.js */ \"./src/workflow/mxClient/mxUndoableEdit.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxClipboard = _interopRequireDefault(__webpack_require__(/*! ./mxClipboard.js */ \"./src/workflow/mxClient/mxClipboard.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxGraphModel(root) {\n  this.currentEdit = this.createUndoableEdit();\n  if (root != null) {\n    this.setRoot(root);\n  } else {\n    this.clear();\n  }\n}\n;\n\n/**\r\n * Extends mxEventSource.\r\n */\nmxGraphModel.prototype = new _mxEventSource[\"default\"]();\nmxGraphModel.prototype.constructor = mxGraphModel;\n\n/**\r\n * Variable: root\r\n *\r\n * Holds the root cell, which in turn contains the cells that represent the\r\n * layers of the diagram as child cells. That is, the actual elements of the\r\n * diagram are supposed to live in the third generation of cells and below.\r\n */\nmxGraphModel.prototype.root = null;\n\n/**\r\n * Variable: cells\r\n *\r\n * Maps from Ids to cells.\r\n */\nmxGraphModel.prototype.cells = null;\n\n/**\r\n * Variable: maintainEdgeParent\r\n *\r\n * Specifies if edges should automatically be moved into the nearest common\r\n * ancestor of their terminals. Default is true.\r\n */\nmxGraphModel.prototype.maintainEdgeParent = true;\n\n/**\r\n * Variable: ignoreRelativeEdgeParent\r\n *\r\n * Specifies if relative edge parents should be ignored for finding the nearest\r\n * common ancestors of an edge's terminals. Default is true.\r\n */\nmxGraphModel.prototype.ignoreRelativeEdgeParent = true;\n\n/**\r\n * Variable: createIds\r\n *\r\n * Specifies if the model should automatically create Ids for new cells.\r\n * Default is true.\r\n */\nmxGraphModel.prototype.createIds = true;\n\n/**\r\n * Variable: prefix\r\n *\r\n * Defines the prefix of new Ids. Default is an empty string.\r\n */\nmxGraphModel.prototype.prefix = 'node_';\n\n/**\r\n * Variable: postfix\r\n *\r\n * Defines the postfix of new Ids. Default is an empty string.\r\n */\nmxGraphModel.prototype.postfix = '';\n\n/**\r\n * Variable: nextId\r\n *\r\n * Specifies the next Id to be created. Initial value is 0.\r\n */\nmxGraphModel.prototype.nextId = 0;\n\n/**\r\n * Variable: currentEdit\r\n *\r\n * Holds the changes for the current transaction. If the transaction is\r\n * closed then a new object is created for this variable using\r\n * <createUndoableEdit>.\r\n */\nmxGraphModel.prototype.currentEdit = null;\n\n/**\r\n * Variable: updateLevel\r\n *\r\n * Counter for the depth of nested transactions. Each call to <beginUpdate>\r\n * will increment this number and each call to <endUpdate> will decrement\r\n * it. When the counter reaches 0, the transaction is closed and the\r\n * respective events are fired. Initial value is 0.\r\n */\nmxGraphModel.prototype.updateLevel = 0;\n\n/**\r\n * Variable: endingUpdate\r\n *\r\n * True if the program flow is currently inside endUpdate.\r\n */\nmxGraphModel.prototype.endingUpdate = false;\n\n/**\r\n * Function: clear\r\n *\r\n * Sets a new root using <createRoot>.\r\n */\nmxGraphModel.prototype.clear = function () {\n  this.setRoot(this.createRoot());\n};\n\n/**\r\n * Function: isCreateIds\r\n *\r\n * Returns <createIds>.\r\n */\nmxGraphModel.prototype.isCreateIds = function () {\n  return this.createIds;\n};\n\n/**\r\n * Function: setCreateIds\r\n *\r\n * Sets <createIds>.\r\n */\nmxGraphModel.prototype.setCreateIds = function (value) {\n  this.createIds = value;\n};\n\n/**\r\n * Function: createRoot\r\n *\r\n * Creates a new root cell with a default layer (child 0).\r\n */\nmxGraphModel.prototype.createRoot = function () {\n  var cell = new _mxCell[\"default\"]();\n  cell.insert(new _mxCell[\"default\"]());\n  return cell;\n};\n\n/**\r\n * Function: getCell\r\n *\r\n * Returns the <mxCell> for the specified Id or null if no cell can be\r\n * found for the given Id.\r\n *\r\n * Parameters:\r\n *\r\n * id - A string representing the Id of the cell.\r\n */\nmxGraphModel.prototype.getCell = function (id) {\n  return this.cells != null ? this.cells[id] : null;\n};\n\n/**\r\n * Function: filterCells\r\n *\r\n * Returns the cells from the given array where the fiven filter function\r\n * returns true.\r\n */\nmxGraphModel.prototype.filterCells = function (cells, filter) {\n  var result = null;\n  if (cells != null) {\n    result = [];\n    for (var i = 0; i < cells.length; i++) {\n      if (filter(cells[i])) {\n        result.push(cells[i]);\n      }\n    }\n  }\n  return result;\n};\n\n/**\r\n * Function: getDescendants\r\n *\r\n * Returns all descendants of the given cell and the cell itself in an array.\r\n *\r\n * Parameters:\r\n *\r\n * parent - <mxCell> whose descendants should be returned.\r\n */\nmxGraphModel.prototype.getDescendants = function (parent) {\n  return this.filterDescendants(null, parent);\n};\n\n/**\r\n * Function: filterDescendants\r\n *\r\n * Visits all cells recursively and applies the specified filter function\r\n * to each cell. If the function returns true then the cell is added\r\n * to the resulting array. The parent and result paramters are optional.\r\n * If parent is not specified then the recursion starts at <root>.\r\n *\r\n * Example:\r\n * The following example extracts all vertices from a given model:\r\n * (code)\r\n * var filter = function(cell)\r\n * {\r\n * \treturn model.isVertex(cell);\r\n * }\r\n * var vertices = model.filterDescendants(filter);\r\n * (end)\r\n *\r\n * Parameters:\r\n *\r\n * filter - JavaScript function that takes an <mxCell> as an argument\r\n * and returns a boolean.\r\n * parent - Optional <mxCell> that is used as the root of the recursion.\r\n */\nmxGraphModel.prototype.filterDescendants = function (filter, parent) {\n  // Creates a new array for storing the result\n  var result = [];\n\n  // Recursion starts at the root of the model\n  parent = parent || this.getRoot();\n\n  // Checks if the filter returns true for the cell\n  // and adds it to the result array\n  if (filter == null || filter(parent)) {\n    result.push(parent);\n  }\n\n  // Visits the children of the cell\n  var childCount = this.getChildCount(parent);\n  for (var i = 0; i < childCount; i++) {\n    var child = this.getChildAt(parent, i);\n    result = result.concat(this.filterDescendants(filter, child));\n  }\n  return result;\n};\n\n/**\r\n * Function: getRoot\r\n *\r\n * Returns the root of the model or the topmost parent of the given cell.\r\n *\r\n * Parameters:\r\n *\r\n * cell - Optional <mxCell> that specifies the child.\r\n */\nmxGraphModel.prototype.getRoot = function (cell) {\n  var root = cell || this.root;\n  if (cell != null) {\n    while (cell != null) {\n      root = cell;\n      cell = this.getParent(cell);\n    }\n  }\n  return root;\n};\n\n/**\r\n * Function: setRoot\r\n *\r\n * Sets the <root> of the model using <mxRootChange> and adds the change to\r\n * the current transaction. This resets all datastructures in the model and\r\n * is the preferred way of clearing an existing model. Returns the new\r\n * root.\r\n *\r\n * Example:\r\n *\r\n * (code)\r\n * var root = new mxCell();\r\n * root.insert(new mxCell());\r\n * model.setRoot(root);\r\n * (end)\r\n *\r\n * Parameters:\r\n *\r\n * root - <mxCell> that specifies the new root.\r\n */\nmxGraphModel.prototype.setRoot = function (root) {\n  this.execute(new _mxRootChange[\"default\"](this, root));\n  return root;\n};\n\n/**\r\n * Function: rootChanged\r\n *\r\n * Inner callback to change the root of the model and update the internal\r\n * datastructures, such as <cells> and <nextId>. Returns the previous root.\r\n *\r\n * Parameters:\r\n *\r\n * root - <mxCell> that specifies the new root.\r\n */\nmxGraphModel.prototype.rootChanged = function (root) {\n  var oldRoot = this.root;\n  this.root = root;\n\n  // Resets counters and datastructures\n  this.nextId = 0;\n  this.cells = null;\n  this.cellAdded(root);\n  return oldRoot;\n};\n\n/**\r\n * Function: isRoot\r\n *\r\n * Returns true if the given cell is the root of the model and a non-null\r\n * value.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> that represents the possible root.\r\n */\nmxGraphModel.prototype.isRoot = function (cell) {\n  return cell != null && this.root == cell;\n};\n\n/**\r\n * Function: isLayer\r\n *\r\n * Returns true if <isRoot> returns true for the parent of the given cell.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> that represents the possible layer.\r\n */\nmxGraphModel.prototype.isLayer = function (cell) {\n  return this.isRoot(this.getParent(cell));\n};\n\n/**\r\n * Function: isAncestor\r\n *\r\n * Returns true if the given parent is an ancestor of the given child.\r\n *\r\n * Parameters:\r\n *\r\n * parent - <mxCell> that specifies the parent.\r\n * child - <mxCell> that specifies the child.\r\n */\nmxGraphModel.prototype.isAncestor = function (parent, child) {\n  while (child != null && child != parent) {\n    child = this.getParent(child);\n  }\n  return child == parent;\n};\n\n/**\r\n * Function: contains\r\n *\r\n * Returns true if the model contains the given <mxCell>.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> that specifies the cell.\r\n */\nmxGraphModel.prototype.contains = function (cell) {\n  return this.isAncestor(this.root, cell);\n};\n\n/**\r\n * Function: getParent\r\n *\r\n * Returns the parent of the given cell.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose parent should be returned.\r\n */\nmxGraphModel.prototype.getParent = function (cell) {\n  return cell != null ? cell.getParent() : null;\n};\n\n/**\r\n * Function: add\r\n *\r\n * Adds the specified child to the parent at the given index using\r\n * <mxChildChange> and adds the change to the current transaction. If no\r\n * index is specified then the child is appended to the parent's array of\r\n * children. Returns the inserted child.\r\n *\r\n * Parameters:\r\n *\r\n * parent - <mxCell> that specifies the parent to contain the child.\r\n * child - <mxCell> that specifies the child to be inserted.\r\n * index - Optional integer that specifies the index of the child.\r\n */\nmxGraphModel.prototype.add = function (parent, child, index) {\n  if (child != parent && parent != null && child != null) {\n    // Appends the child if no index was specified\n    if (index == null) {\n      index = this.getChildCount(parent);\n    }\n    var parentChanged = parent != this.getParent(child);\n    this.execute(new _mxChildChange[\"default\"](this, parent, child, index));\n\n    // Maintains the edges parents by moving the edges\n    // into the nearest common ancestor of its\n    // terminals\n    if (this.maintainEdgeParent && parentChanged) {\n      this.updateEdgeParents(child);\n    }\n  }\n  return child;\n};\n\n/**\r\n * Function: cellAdded\r\n *\r\n * Inner callback to update <cells> when a cell has been added. This\r\n * implementation resolves collisions by creating new Ids. To change the\r\n * ID of a cell after it was inserted into the model, use the following\r\n * code:\r\n *\r\n * (code\r\n * delete model.cells[cell.getId()];\r\n * cell.setId(newId);\r\n * model.cells[cell.getId()] = cell;\r\n * (end)\r\n *\r\n * If the change of the ID should be part of the command history, then the\r\n * cell should be removed from the model and a clone with the new ID should\r\n * be reinserted into the model instead.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> that specifies the cell that has been added.\r\n */\nmxGraphModel.prototype.cellAdded = function (cell) {\n  if (cell != null) {\n    // Creates an Id for the cell if not Id exists\n    if (cell.getId() == null && this.createIds) {\n      cell.setId(this.createId(cell), this);\n    }\n    if (cell.getId() != null) {\n      var collision = this.getCell(cell.getId());\n      if (collision != cell) {\n        // Creates new Id for the cell\n        // as long as there is a collision\n        while (collision != null) {\n          cell.setId(this.createId(cell), this);\n          collision = this.getCell(cell.getId());\n        }\n\n        // Lazily creates the cells dictionary\n        if (this.cells == null) {\n          this.cells = new Object();\n        }\n        this.cells[cell.getId()] = cell;\n      }\n    }\n\n    // Makes sure IDs of deleted cells are not reused\n    if (_mxGraphUtils[\"default\"].isNumeric(cell.getId())) {\n      this.nextId = Math.max(this.nextId, cell.getId());\n    }\n\n    // Recursively processes child cells\n    var childCount = this.getChildCount(cell);\n    for (var i = 0; i < childCount; i++) {\n      this.cellAdded(this.getChildAt(cell, i));\n    }\n  }\n};\n\n/**\r\n * Function: createId\r\n *\r\n * Hook method to create an Id for the specified cell. This implementation\r\n * concatenates <prefix>, id and <postfix> to create the Id and increments\r\n * <nextId>. The cell is ignored by this implementation, but can be used in\r\n * overridden methods to prefix the Ids with eg. the cell type.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> to create the Id for.\r\n */\nmxGraphModel.prototype.createId = function (cell) {\n  var id = this.nextId;\n  this.nextId++;\n  return (cell.getIdPrefix() || this.prefix) + id + this.postfix;\n};\n\n/**\r\n * Function: updateEdgeParents\r\n *\r\n * Updates the parent for all edges that are connected to cell or one of\r\n * its descendants using <updateEdgeParent>.\r\n */\nmxGraphModel.prototype.updateEdgeParents = function (cell, root) {\n  // Gets the topmost node of the hierarchy\n  root = root || this.getRoot(cell);\n\n  // Updates edges on children first\n  var childCount = this.getChildCount(cell);\n  for (var i = 0; i < childCount; i++) {\n    var child = this.getChildAt(cell, i);\n    this.updateEdgeParents(child, root);\n  }\n\n  // Updates the parents of all connected edges\n  var edgeCount = this.getEdgeCount(cell);\n  var edges = [];\n  for (var i = 0; i < edgeCount; i++) {\n    edges.push(this.getEdgeAt(cell, i));\n  }\n  for (var i = 0; i < edges.length; i++) {\n    var edge = edges[i];\n\n    // Updates edge parent if edge and child have\n    // a common root node (does not need to be the\n    // model root node)\n    if (this.isAncestor(root, edge)) {\n      this.updateEdgeParent(edge, root);\n    }\n  }\n};\n\n/**\r\n * Function: updateEdgeParent\r\n *\r\n * Inner callback to update the parent of the specified <mxCell> to the\r\n * nearest-common-ancestor of its two terminals.\r\n *\r\n * Parameters:\r\n *\r\n * edge - <mxCell> that specifies the edge.\r\n * root - <mxCell> that represents the current root of the model.\r\n */\nmxGraphModel.prototype.updateEdgeParent = function (edge, root) {\n  var source = this.getTerminal(edge, true);\n  var target = this.getTerminal(edge, false);\n  var cell = null;\n\n  // Uses the first non-relative descendants of the source terminal\n  while (source != null && !this.isEdge(source) && source.geometry != null && source.geometry.relative) {\n    source = this.getParent(source);\n  }\n\n  // Uses the first non-relative descendants of the target terminal\n  while (target != null && this.ignoreRelativeEdgeParent && !this.isEdge(target) && target.geometry != null && target.geometry.relative) {\n    target = this.getParent(target);\n  }\n  if (this.isAncestor(root, source) && this.isAncestor(root, target)) {\n    if (source == target) {\n      cell = this.getParent(source);\n    } else {\n      cell = this.getNearestCommonAncestor(source, target);\n    }\n    if (cell != null && (this.getParent(cell) != this.root || this.isAncestor(cell, edge)) && this.getParent(edge) != cell) {\n      var geo = this.getGeometry(edge);\n      if (geo != null) {\n        var origin1 = this.getOrigin(this.getParent(edge));\n        var origin2 = this.getOrigin(cell);\n        var dx = origin2.x - origin1.x;\n        var dy = origin2.y - origin1.y;\n        geo = geo.clone();\n        geo.translate(-dx, -dy);\n        this.setGeometry(edge, geo);\n      }\n      this.add(cell, edge, this.getChildCount(cell));\n    }\n  }\n};\n\n/**\r\n * Function: getOrigin\r\n *\r\n * Returns the absolute, accumulated origin for the children inside the\r\n * given parent as an <mxPoint>.\r\n */\nmxGraphModel.prototype.getOrigin = function (cell) {\n  var result = null;\n  if (cell != null) {\n    result = this.getOrigin(this.getParent(cell));\n    if (!this.isEdge(cell)) {\n      var geo = this.getGeometry(cell);\n      if (geo != null) {\n        result.x += geo.x;\n        result.y += geo.y;\n      }\n    }\n  } else {\n    result = new _mxPoint[\"default\"]();\n  }\n  return result;\n};\n\n/**\r\n * Function: getNearestCommonAncestor\r\n *\r\n * Returns the nearest common ancestor for the specified cells.\r\n *\r\n * Parameters:\r\n *\r\n * cell1 - <mxCell> that specifies the first cell in the tree.\r\n * cell2 - <mxCell> that specifies the second cell in the tree.\r\n */\nmxGraphModel.prototype.getNearestCommonAncestor = function (cell1, cell2) {\n  if (cell1 != null && cell2 != null) {\n    // Creates the cell path for the second cell\n    var path = _mxCellPath[\"default\"].create(cell2);\n    if (path != null && path.length > 0) {\n      // Bubbles through the ancestors of the first\n      // cell to find the nearest common ancestor.\n      var cell = cell1;\n      var current = _mxCellPath[\"default\"].create(cell);\n\n      // Inverts arguments\n      if (path.length < current.length) {\n        cell = cell2;\n        var tmp = current;\n        current = path;\n        path = tmp;\n      }\n      while (cell != null) {\n        var parent = this.getParent(cell);\n\n        // Checks if the cell path is equal to the beginning of the given cell path\n        if (path.indexOf(current + _mxCellPath[\"default\"].PATH_SEPARATOR) == 0 && parent != null) {\n          return cell;\n        }\n        current = _mxCellPath[\"default\"].getParentPath(current);\n        cell = parent;\n      }\n    }\n  }\n  return null;\n};\n\n/**\r\n * Function: remove\r\n *\r\n * Removes the specified cell from the model using <mxChildChange> and adds\r\n * the change to the current transaction. This operation will remove the\r\n * cell and all of its children from the model. Returns the removed cell.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> that should be removed.\r\n */\nmxGraphModel.prototype.remove = function (cell) {\n  if (cell == this.root) {\n    this.setRoot(null);\n  } else if (this.getParent(cell) != null) {\n    this.execute(new _mxChildChange[\"default\"](this, null, cell));\n  }\n  return cell;\n};\n\n/**\r\n * Function: cellRemoved\r\n *\r\n * Inner callback to update <cells> when a cell has been removed.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> that specifies the cell that has been removed.\r\n */\nmxGraphModel.prototype.cellRemoved = function (cell) {\n  if (cell != null && this.cells != null) {\n    // Recursively processes child cells\n    var childCount = this.getChildCount(cell);\n    for (var i = childCount - 1; i >= 0; i--) {\n      this.cellRemoved(this.getChildAt(cell, i));\n    }\n\n    // Removes the dictionary entry for the cell\n    if (this.cells != null && cell.getId() != null) {\n      delete this.cells[cell.getId()];\n    }\n  }\n};\n\n/**\r\n * Function: parentForCellChanged\r\n *\r\n * Inner callback to update the parent of a cell using <mxCell.insert>\r\n * on the parent and return the previous parent.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> to update the parent for.\r\n * parent - <mxCell> that specifies the new parent of the cell.\r\n * index - Optional integer that defines the index of the child\r\n * in the parent's child array.\r\n */\nmxGraphModel.prototype.parentForCellChanged = function (cell, parent, index) {\n  var previous = this.getParent(cell);\n  if (parent != null) {\n    if (parent != previous || previous.getIndex(cell) != index) {\n      parent.insert(cell, index);\n    }\n  } else if (previous != null) {\n    var oldIndex = previous.getIndex(cell);\n    previous.remove(oldIndex);\n  }\n\n  // Checks if the previous parent was already in the\n  // model and avoids calling cellAdded if it was.\n  if (!this.contains(previous) && parent != null) {\n    this.cellAdded(cell);\n  } else if (parent == null) {\n    this.cellRemoved(cell);\n  }\n  return previous;\n};\n\n/**\r\n * Function: getChildCount\r\n *\r\n * Returns the number of children in the given cell.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose number of children should be returned.\r\n */\nmxGraphModel.prototype.getChildCount = function (cell) {\n  return cell != null ? cell.getChildCount() : 0;\n};\n\n/**\r\n * Function: getChildAt\r\n *\r\n * Returns the child of the given <mxCell> at the given index.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> that represents the parent.\r\n * index - Integer that specifies the index of the child to be returned.\r\n */\nmxGraphModel.prototype.getChildAt = function (cell, index) {\n  return cell != null ? cell.getChildAt(index) : null;\n};\n\n/**\r\n * Function: getChildren\r\n *\r\n * Returns all children of the given <mxCell> as an array of <mxCells>. The\r\n * return value should be only be read.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> the represents the parent.\r\n */\nmxGraphModel.prototype.getChildren = function (cell) {\n  return cell != null ? cell.children : null;\n};\n\n/**\r\n * Function: getChildVertices\r\n *\r\n * Returns the child vertices of the given parent.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose child vertices should be returned.\r\n */\nmxGraphModel.prototype.getChildVertices = function (parent) {\n  return this.getChildCells(parent, true, false);\n};\n\n/**\r\n * Function: getChildEdges\r\n *\r\n * Returns the child edges of the given parent.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose child edges should be returned.\r\n */\nmxGraphModel.prototype.getChildEdges = function (parent) {\n  return this.getChildCells(parent, false, true);\n};\n\n/**\r\n * Function: getChildCells\r\n *\r\n * Returns the children of the given cell that are vertices and/or edges\r\n * depending on the arguments.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> the represents the parent.\r\n * vertices - Boolean indicating if child vertices should be returned.\r\n * Default is false.\r\n * edges - Boolean indicating if child edges should be returned.\r\n * Default is false.\r\n */\nmxGraphModel.prototype.getChildCells = function (parent, vertices, edges) {\n  vertices = vertices != null ? vertices : false;\n  edges = edges != null ? edges : false;\n  var childCount = this.getChildCount(parent);\n  var result = [];\n  for (var i = 0; i < childCount; i++) {\n    var child = this.getChildAt(parent, i);\n    if (!edges && !vertices || edges && this.isEdge(child) || vertices && this.isVertex(child)) {\n      result.push(child);\n    }\n  }\n  return result;\n};\n\n/**\r\n * Function: getTerminal\r\n *\r\n * Returns the source or target <mxCell> of the given edge depending on the\r\n * value of the boolean parameter.\r\n *\r\n * Parameters:\r\n *\r\n * edge - <mxCell> that specifies the edge.\r\n * isSource - Boolean indicating which end of the edge should be returned.\r\n */\nmxGraphModel.prototype.getTerminal = function (edge, isSource) {\n  return edge != null ? edge.getTerminal(isSource) : null;\n};\n\n/**\r\n * Function: setTerminal\r\n *\r\n * Sets the source or target terminal of the given <mxCell> using\r\n * <mxTerminalChange> and adds the change to the current transaction.\r\n * This implementation updates the parent of the edge using <updateEdgeParent>\r\n * if required.\r\n *\r\n * Parameters:\r\n *\r\n * edge - <mxCell> that specifies the edge.\r\n * terminal - <mxCell> that specifies the new terminal.\r\n * isSource - Boolean indicating if the terminal is the new source or\r\n * target terminal of the edge.\r\n */\nmxGraphModel.prototype.setTerminal = function (edge, terminal, isSource) {\n  var terminalChanged = terminal != this.getTerminal(edge, isSource);\n  this.execute(new _mxTerminalChange[\"default\"](this, edge, terminal, isSource));\n  if (this.maintainEdgeParent && terminalChanged) {\n    this.updateEdgeParent(edge, this.getRoot());\n  }\n  return terminal;\n};\n\n/**\r\n * Function: setTerminals\r\n *\r\n * Sets the source and target <mxCell> of the given <mxCell> in a single\r\n * transaction using <setTerminal> for each end of the edge.\r\n *\r\n * Parameters:\r\n *\r\n * edge - <mxCell> that specifies the edge.\r\n * source - <mxCell> that specifies the new source terminal.\r\n * target - <mxCell> that specifies the new target terminal.\r\n */\nmxGraphModel.prototype.setTerminals = function (edge, source, target) {\n  this.beginUpdate();\n  try {\n    this.setTerminal(edge, source, true);\n    this.setTerminal(edge, target, false);\n  } finally {\n    this.endUpdate();\n  }\n};\n\n/**\r\n * Function: terminalForCellChanged\r\n *\r\n * Inner helper function to update the terminal of the edge using\r\n * <mxCell.insertEdge> and return the previous terminal.\r\n *\r\n * Parameters:\r\n *\r\n * edge - <mxCell> that specifies the edge to be updated.\r\n * terminal - <mxCell> that specifies the new terminal.\r\n * isSource - Boolean indicating if the terminal is the new source or\r\n * target terminal of the edge.\r\n */\nmxGraphModel.prototype.terminalForCellChanged = function (edge, terminal, isSource) {\n  var previous = this.getTerminal(edge, isSource);\n  if (terminal != null) {\n    terminal.insertEdge(edge, isSource);\n  } else if (previous != null) {\n    previous.removeEdge(edge, isSource);\n  }\n  return previous;\n};\n\n/**\r\n * Function: getEdgeCount\r\n *\r\n * Returns the number of distinct edges connected to the given cell.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> that represents the vertex.\r\n */\nmxGraphModel.prototype.getEdgeCount = function (cell) {\n  return cell != null ? cell.getEdgeCount() : 0;\n};\n\n/**\r\n * Function: getEdgeAt\r\n *\r\n * Returns the edge of cell at the given index.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> that specifies the vertex.\r\n * index - Integer that specifies the index of the edge\r\n * to return.\r\n */\nmxGraphModel.prototype.getEdgeAt = function (cell, index) {\n  return cell != null ? cell.getEdgeAt(index) : null;\n};\n\n/**\r\n * Function: getDirectedEdgeCount\r\n *\r\n * Returns the number of incoming or outgoing edges, ignoring the given\r\n * edge.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose edge count should be returned.\r\n * outgoing - Boolean that specifies if the number of outgoing or\r\n * incoming edges should be returned.\r\n * ignoredEdge - <mxCell> that represents an edge to be ignored.\r\n */\nmxGraphModel.prototype.getDirectedEdgeCount = function (cell, outgoing, ignoredEdge) {\n  var count = 0;\n  var edgeCount = this.getEdgeCount(cell);\n  for (var i = 0; i < edgeCount; i++) {\n    var edge = this.getEdgeAt(cell, i);\n    if (edge != ignoredEdge && this.getTerminal(edge, outgoing) == cell) {\n      count++;\n    }\n  }\n  return count;\n};\n\n/**\r\n * Function: getConnections\r\n *\r\n * Returns all edges of the given cell without loops.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose edges should be returned.\r\n *\r\n */\nmxGraphModel.prototype.getConnections = function (cell) {\n  return this.getEdges(cell, true, true, false);\n};\n\n/**\r\n * Function: getIncomingEdges\r\n *\r\n * Returns the incoming edges of the given cell without loops.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose incoming edges should be returned.\r\n *\r\n */\nmxGraphModel.prototype.getIncomingEdges = function (cell) {\n  return this.getEdges(cell, true, false, false);\n};\n\n/**\r\n * Function: getOutgoingEdges\r\n *\r\n * Returns the outgoing edges of the given cell without loops.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose outgoing edges should be returned.\r\n *\r\n */\nmxGraphModel.prototype.getOutgoingEdges = function (cell) {\n  return this.getEdges(cell, false, true, false);\n};\n\n/**\r\n * Function: getEdges\r\n *\r\n * Returns all distinct edges connected to this cell as a new array of\r\n * <mxCells>. If at least one of incoming or outgoing is true, then loops\r\n * are ignored, otherwise if both are false, then all edges connected to\r\n * the given cell are returned including loops.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> that specifies the cell.\r\n * incoming - Optional boolean that specifies if incoming edges should be\r\n * returned. Default is true.\r\n * outgoing - Optional boolean that specifies if outgoing edges should be\r\n * returned. Default is true.\r\n * includeLoops - Optional boolean that specifies if loops should be returned.\r\n * Default is true.\r\n */\nmxGraphModel.prototype.getEdges = function (cell, incoming, outgoing, includeLoops) {\n  incoming = incoming != null ? incoming : true;\n  outgoing = outgoing != null ? outgoing : true;\n  includeLoops = includeLoops != null ? includeLoops : true;\n  var edgeCount = this.getEdgeCount(cell);\n  var result = [];\n  for (var i = 0; i < edgeCount; i++) {\n    var edge = this.getEdgeAt(cell, i);\n    var source = this.getTerminal(edge, true);\n    var target = this.getTerminal(edge, false);\n    if (includeLoops && source == target || source != target && (incoming && target == cell || outgoing && source == cell)) {\n      result.push(edge);\n    }\n  }\n  return result;\n};\n\n/**\r\n * Function: getEdgesBetween\r\n *\r\n * Returns all edges between the given source and target pair. If directed\r\n * is true, then only edges from the source to the target are returned,\r\n * otherwise, all edges between the two cells are returned.\r\n *\r\n * Parameters:\r\n *\r\n * source - <mxCell> that defines the source terminal of the edge to be\r\n * returned.\r\n * target - <mxCell> that defines the target terminal of the edge to be\r\n * returned.\r\n * directed - Optional boolean that specifies if the direction of the\r\n * edge should be taken into account. Default is false.\r\n */\nmxGraphModel.prototype.getEdgesBetween = function (source, target, directed) {\n  directed = directed != null ? directed : false;\n  var tmp1 = this.getEdgeCount(source);\n  var tmp2 = this.getEdgeCount(target);\n\n  // Assumes the source has less connected edges\n  var terminal = source;\n  var edgeCount = tmp1;\n\n  // Uses the smaller array of connected edges\n  // for searching the edge\n  if (tmp2 < tmp1) {\n    edgeCount = tmp2;\n    terminal = target;\n  }\n  var result = [];\n\n  // Checks if the edge is connected to the correct\n  // cell and returns the first match\n  for (var i = 0; i < edgeCount; i++) {\n    var edge = this.getEdgeAt(terminal, i);\n    var src = this.getTerminal(edge, true);\n    var trg = this.getTerminal(edge, false);\n    var directedMatch = src == source && trg == target;\n    var oppositeMatch = trg == source && src == target;\n    if (directedMatch || !directed && oppositeMatch) {\n      result.push(edge);\n    }\n  }\n  return result;\n};\n\n/**\r\n * Function: getOpposites\r\n *\r\n * Returns all opposite vertices wrt terminal for the given edges, only\r\n * returning sources and/or targets as specified. The result is returned\r\n * as an array of <mxCells>.\r\n *\r\n * Parameters:\r\n *\r\n * edges - Array of <mxCells> that contain the edges to be examined.\r\n * terminal - <mxCell> that specifies the known end of the edges.\r\n * sources - Boolean that specifies if source terminals should be contained\r\n * in the result. Default is true.\r\n * targets - Boolean that specifies if target terminals should be contained\r\n * in the result. Default is true.\r\n */\nmxGraphModel.prototype.getOpposites = function (edges, terminal, sources, targets) {\n  sources = sources != null ? sources : true;\n  targets = targets != null ? targets : true;\n  var terminals = [];\n  if (edges != null) {\n    for (var i = 0; i < edges.length; i++) {\n      var source = this.getTerminal(edges[i], true);\n      var target = this.getTerminal(edges[i], false);\n\n      // Checks if the terminal is the source of\n      // the edge and if the target should be\n      // stored in the result\n      if (source == terminal && target != null && target != terminal && targets) {\n        terminals.push(target);\n      }\n\n      // Checks if the terminal is the taget of\n      // the edge and if the source should be\n      // stored in the result\n      else if (target == terminal && source != null && source != terminal && sources) {\n        terminals.push(source);\n      }\n    }\n  }\n  return terminals;\n};\n\n/**\r\n * Function: getTopmostCells\r\n *\r\n * Returns the topmost cells of the hierarchy in an array that contains no\r\n * descendants for each <mxCell> that it contains. Duplicates should be\r\n * removed in the cells array to improve performance.\r\n *\r\n * Parameters:\r\n *\r\n * cells - Array of <mxCells> whose topmost ancestors should be returned.\r\n */\nmxGraphModel.prototype.getTopmostCells = function (cells) {\n  var dict = new _mxDictionary[\"default\"]();\n  var tmp = [];\n  for (var i = 0; i < cells.length; i++) {\n    dict.put(cells[i], true);\n  }\n  for (var i = 0; i < cells.length; i++) {\n    var cell = cells[i];\n    var topmost = true;\n    var parent = this.getParent(cell);\n    while (parent != null) {\n      if (dict.get(parent)) {\n        topmost = false;\n        break;\n      }\n      parent = this.getParent(parent);\n    }\n    if (topmost) {\n      tmp.push(cell);\n    }\n  }\n  return tmp;\n};\n\n/**\r\n * Function: isVertex\r\n *\r\n * Returns true if the given cell is a vertex.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> that represents the possible vertex.\r\n */\nmxGraphModel.prototype.isVertex = function (cell) {\n  return cell != null ? cell.isVertex() : false;\n};\n\n/**\r\n * Function: isEdge\r\n *\r\n * Returns true if the given cell is an edge.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> that represents the possible edge.\r\n */\nmxGraphModel.prototype.isEdge = function (cell) {\n  return cell != null ? cell.isEdge() : false;\n};\n\n/**\r\n * Function: isConnectable\r\n *\r\n * Returns true if the given <mxCell> is connectable. If <edgesConnectable>\r\n * is false, then this function returns false for all edges else it returns\r\n * the return value of <mxCell.isConnectable>.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose connectable state should be returned.\r\n */\nmxGraphModel.prototype.isConnectable = function (cell) {\n  return cell != null ? cell.isConnectable() : false;\n};\n\n/**\r\n * Function: getValue\r\n *\r\n * Returns the user object of the given <mxCell> using <mxCell.getValue>.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose user object should be returned.\r\n */\nmxGraphModel.prototype.getValue = function (cell) {\n  return cell != null ? cell.getValue() : null;\n};\n\n/**\r\n * Function: setValue\r\n *\r\n * Sets the user object of then given <mxCell> using <mxValueChange>\r\n * and adds the change to the current transaction.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose user object should be changed.\r\n * value - Object that defines the new user object.\r\n */\nmxGraphModel.prototype.setValue = function (cell, value) {\n  this.execute(new _mxValueChange[\"default\"](this, cell, value));\n  return value;\n};\n\n//由于之前的value比较复杂，因此增加 set/get Property方法单独设置\nmxGraphModel.prototype.setProperty = function (cell, group, property, value, reducer) {\n  if (!cell) {\n    return value;\n  }\n  if (property === \"name\") {\n    this.execute(new _mxPropertyChange[\"default\"](this, cell, group, property, value, reducer));\n    //更新剪切板中复制自此节点的名称\n    var cells = _mxClipboard[\"default\"].getCells();\n    if (cells && cells.length) {\n      var id = cell.getId();\n      var pageId = cell.getOriginPageId();\n      for (var i = 0; i < cells.length; i++) {\n        var c = cells[i];\n        if (id == c.getProperty('base', 'itemId') && pageId == c.getOriginPageId()) {\n          c.value = value;\n          break;\n        }\n      }\n    }\n  } else if (property === \"bindToPrevNode\" || property === \"bindToNextNode\") {\n    this.execute(new _mxPropertyChange[\"default\"](this, cell, group, property, value, reducer));\n  } else {\n    cell.setProperty(group, property, value, null);\n  }\n  return value;\n};\nmxGraphModel.prototype.getProperty = function (cell, group, property) {\n  return cell != null ? cell.getProperty(group, property) : null;\n};\n\n/**\r\n * Function: valueForCellChanged\r\n *\r\n * Inner callback to update the user object of the given <mxCell>\r\n * using <mxCell.valueChanged> and return the previous value,\r\n * that is, the return value of <mxCell.valueChanged>.\r\n *\r\n * To change a specific attribute in an XML node, the following code can be\r\n * used.\r\n *\r\n * (code)\r\n * graph.getModel().valueForCellChanged = function(cell, value)\r\n * {\r\n *   var previous = cell.value.getAttribute('label');\r\n *   cell.value.setAttribute('label', value);\r\n *\r\n *   return previous;\r\n * };\r\n * (end)\r\n */\nmxGraphModel.prototype.valueForCellChanged = function (cell, value) {\n  return cell.valueChanged(value);\n};\nmxGraphModel.prototype.propertyForCellChanged = function (cell, group, property, value, reducer) {\n  return cell && cell.propertyChanged(group, property, value, reducer);\n};\n\n/**\r\n * Function: getGeometry\r\n *\r\n * Returns the <mxGeometry> of the given <mxCell>.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose geometry should be returned.\r\n */\nmxGraphModel.prototype.getGeometry = function (cell) {\n  return cell != null ? cell.getGeometry() : null;\n};\n\n/**\r\n * Function: setGeometry\r\n *\r\n * Sets the <mxGeometry> of the given <mxCell>. The actual update\r\n * of the cell is carried out in <geometryForCellChanged>. The\r\n * <mxGeometryChange> action is used to encapsulate the change.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose geometry should be changed.\r\n * geometry - <mxGeometry> that defines the new geometry.\r\n */\nmxGraphModel.prototype.setGeometry = function (cell, geometry) {\n  if (geometry != this.getGeometry(cell)) {\n    this.execute(new _mxGeometryChange[\"default\"](this, cell, geometry));\n  }\n  return geometry;\n};\n\n/**\r\n * Function: geometryForCellChanged\r\n *\r\n * Inner callback to update the <mxGeometry> of the given <mxCell> using\r\n * <mxCell.setGeometry> and return the previous <mxGeometry>.\r\n */\nmxGraphModel.prototype.geometryForCellChanged = function (cell, geometry) {\n  var previous = this.getGeometry(cell);\n  cell.setGeometry(geometry);\n  return previous;\n};\n\n/**\r\n * Function: getStyle\r\n *\r\n * Returns the style of the given <mxCell>.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose style should be returned.\r\n */\nmxGraphModel.prototype.getStyle = function (cell) {\n  return cell != null ? cell.getStyle() : null;\n};\n\n/**\r\n * Function: setStyle\r\n *\r\n * Sets the style of the given <mxCell> using <mxStyleChange> and\r\n * adds the change to the current transaction.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose style should be changed.\r\n * style - String of the form [stylename;|key=value;] to specify\r\n * the new cell style.\r\n */\nmxGraphModel.prototype.setStyle = function (cell, style) {\n  if (style != this.getStyle(cell)) {\n    this.execute(new _mxStyleChange[\"default\"](this, cell, style));\n  }\n  return style;\n};\n\n/**\r\n * Function: styleForCellChanged\r\n *\r\n * Inner callback to update the style of the given <mxCell>\r\n * using <mxCell.setStyle> and return the previous style.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> that specifies the cell to be updated.\r\n * style - String of the form [stylename;|key=value;] to specify\r\n * the new cell style.\r\n */\nmxGraphModel.prototype.styleForCellChanged = function (cell, style) {\n  var previous = this.getStyle(cell);\n  cell.setStyle(style);\n  return previous;\n};\n\n/**\r\n * Function: isCollapsed\r\n *\r\n * Returns true if the given <mxCell> is collapsed.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose collapsed state should be returned.\r\n */\nmxGraphModel.prototype.isCollapsed = function (cell) {\n  return cell != null ? cell.isCollapsed() : false;\n};\n\n/**\r\n * Function: setCollapsed\r\n *\r\n * Sets the collapsed state of the given <mxCell> using <mxCollapseChange>\r\n * and adds the change to the current transaction.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose collapsed state should be changed.\r\n * collapsed - Boolean that specifies the new collpased state.\r\n */\nmxGraphModel.prototype.setCollapsed = function (cell, collapsed) {\n  if (collapsed != this.isCollapsed(cell)) {\n    this.execute(new _mxCollapseChange[\"default\"](this, cell, collapsed));\n  }\n  return collapsed;\n};\n\n/**\r\n * Function: collapsedStateForCellChanged\r\n *\r\n * Inner callback to update the collapsed state of the\r\n * given <mxCell> using <mxCell.setCollapsed> and return\r\n * the previous collapsed state.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> that specifies the cell to be updated.\r\n * collapsed - Boolean that specifies the new collpased state.\r\n */\nmxGraphModel.prototype.collapsedStateForCellChanged = function (cell, collapsed) {\n  var previous = this.isCollapsed(cell);\n  cell.setCollapsed(collapsed);\n  return previous;\n};\n\n/**\r\n * Function: isVisible\r\n *\r\n * Returns true if the given <mxCell> is visible.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose visible state should be returned.\r\n */\nmxGraphModel.prototype.isVisible = function (cell) {\n  return cell != null ? cell.isVisible() : false;\n};\n\n/**\r\n * Function: setVisible\r\n *\r\n * Sets the visible state of the given <mxCell> using <mxVisibleChange> and\r\n * adds the change to the current transaction.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose visible state should be changed.\r\n * visible - Boolean that specifies the new visible state.\r\n */\nmxGraphModel.prototype.setVisible = function (cell, visible) {\n  if (visible != this.isVisible(cell)) {\n    this.execute(new _mxVisibleChange[\"default\"](this, cell, visible));\n  }\n  return visible;\n};\n\n/**\r\n * Function: visibleStateForCellChanged\r\n *\r\n * Inner callback to update the visible state of the\r\n * given <mxCell> using <mxCell.setCollapsed> and return\r\n * the previous visible state.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> that specifies the cell to be updated.\r\n * visible - Boolean that specifies the new visible state.\r\n */\nmxGraphModel.prototype.visibleStateForCellChanged = function (cell, visible) {\n  var previous = this.isVisible(cell);\n  cell.setVisible(visible);\n  return previous;\n};\n\n/**\r\n * Function: execute\r\n *\r\n * Executes the given edit and fires events if required. The edit object\r\n * requires an execute function which is invoked. The edit is added to the\r\n * <currentEdit> between <beginUpdate> and <endUpdate> calls, so that\r\n * events will be fired if this execute is an individual transaction, that\r\n * is, if no previous <beginUpdate> calls have been made without calling\r\n * <endUpdate>. This implementation fires an <execute> event before\r\n * executing the given change.\r\n *\r\n * Parameters:\r\n *\r\n * change - Object that described the change.\r\n */\nmxGraphModel.prototype.execute = function (change) {\n  change.execute();\n  this.beginUpdate();\n  this.currentEdit.add(change);\n  this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].EXECUTE, 'change', change));\n  // New global executed event\n  this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].EXECUTED, 'change', change));\n  this.endUpdate();\n};\n\n/**\r\n * Function: beginUpdate\r\n *\r\n * Increments the <updateLevel> by one. The event notification\r\n * is queued until <updateLevel> reaches 0 by use of\r\n * <endUpdate>.\r\n *\r\n * All changes on <mxGraphModel> are transactional,\r\n * that is, they are executed in a single undoable change\r\n * on the model (without transaction isolation).\r\n * Therefore, if you want to combine any\r\n * number of changes into a single undoable change,\r\n * you should group any two or more API calls that\r\n * modify the graph model between <beginUpdate>\r\n * and <endUpdate> calls as shown here:\r\n *\r\n * (code)\r\n * var model = graph.getModel();\r\n * var parent = graph.getDefaultParent();\r\n * var index = model.getChildCount(parent);\r\n * model.beginUpdate();\r\n * try\r\n * {\r\n *   model.add(parent, v1, index);\r\n *   model.add(parent, v2, index+1);\r\n * }\r\n * finally\r\n * {\r\n *   model.endUpdate();\r\n * }\r\n * (end)\r\n *\r\n * Of course there is a shortcut for appending a\r\n * sequence of cells into the default parent:\r\n *\r\n * (code)\r\n * graph.addCells([v1, v2]).\r\n * (end)\r\n */\nmxGraphModel.prototype.beginUpdate = function () {\n  this.updateLevel++;\n  this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].BEGIN_UPDATE));\n  if (this.updateLevel == 1) {\n    this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].START_EDIT));\n  }\n};\n\n/**\r\n * Function: endUpdate\r\n *\r\n * Decrements the <updateLevel> by one and fires an <undo>\r\n * event if the <updateLevel> reaches 0. This function\r\n * indirectly fires a <change> event by invoking the notify\r\n * function on the <currentEdit> und then creates a new\r\n * <currentEdit> using <createUndoableEdit>.\r\n *\r\n * The <undo> event is fired only once per edit, whereas\r\n * the <change> event is fired whenever the notify\r\n * function is invoked, that is, on undo and redo of\r\n * the edit.\r\n */\nmxGraphModel.prototype.endUpdate = function () {\n  this.updateLevel--;\n  if (this.updateLevel == 0) {\n    this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].END_EDIT));\n  }\n  if (!this.endingUpdate) {\n    this.endingUpdate = this.updateLevel == 0;\n    this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].END_UPDATE, 'edit', this.currentEdit));\n    try {\n      if (this.endingUpdate && !this.currentEdit.isEmpty()) {\n        this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].BEFORE_UNDO, 'edit', this.currentEdit));\n        var tmp = this.currentEdit;\n        this.currentEdit = this.createUndoableEdit();\n        tmp.notify();\n        this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].UNDO, 'edit', tmp));\n      }\n    } finally {\n      this.endingUpdate = false;\n    }\n  }\n};\n\n/**\r\n * Function: createUndoableEdit\r\n *\r\n * Creates a new <mxUndoableEdit> that implements the\r\n * notify function to fire a <change> and <notify> event\r\n * through the <mxUndoableEdit>'s source.\r\n */\nmxGraphModel.prototype.createUndoableEdit = function () {\n  var edit = new _mxUndoableEdit[\"default\"](this, true);\n  edit.notify = function () {\n    // LATER: Remove changes property (deprecated)\n    edit.source.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].CHANGE, 'edit', edit, 'changes', edit.changes));\n    edit.source.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].NOTIFY, 'edit', edit, 'changes', edit.changes));\n  };\n  return edit;\n};\n\n/**\r\n * Function: mergeChildren\r\n *\r\n * Merges the children of the given cell into the given target cell inside\r\n * this model. All cells are cloned unless there is a corresponding cell in\r\n * the model with the same id, in which case the source cell is ignored and\r\n * all edges are connected to the corresponding cell in this model. Edges\r\n * are considered to have no identity and are always cloned unless the\r\n * cloneAllEdges flag is set to false, in which case edges with the same\r\n * id in the target model are reconnected to reflect the terminals of the\r\n * source edges.\r\n */\nmxGraphModel.prototype.mergeChildren = function (from, to, cloneAllEdges) {\n  cloneAllEdges = cloneAllEdges != null ? cloneAllEdges : true;\n  this.beginUpdate();\n  try {\n    var mapping = new Object();\n    this.mergeChildrenImpl(from, to, cloneAllEdges, mapping);\n\n    // Post-processes all edges in the mapping and\n    // reconnects the terminals to the corresponding\n    // cells in the target model\n    for (var key in mapping) {\n      var cell = mapping[key];\n      var terminal = this.getTerminal(cell, true);\n      if (terminal != null) {\n        terminal = mapping[_mxCellPath[\"default\"].create(terminal)];\n        this.setTerminal(cell, terminal, true);\n      }\n      terminal = this.getTerminal(cell, false);\n      if (terminal != null) {\n        terminal = mapping[_mxCellPath[\"default\"].create(terminal)];\n        this.setTerminal(cell, terminal, false);\n      }\n    }\n  } finally {\n    this.endUpdate();\n  }\n};\n\n/**\r\n * Function: mergeChildren\r\n *\r\n * Clones the children of the source cell into the given target cell in\r\n * this model and adds an entry to the mapping that maps from the source\r\n * cell to the target cell with the same id or the clone of the source cell\r\n * that was inserted into this model.\r\n */\nmxGraphModel.prototype.mergeChildrenImpl = function (from, to, cloneAllEdges, mapping) {\n  this.beginUpdate();\n  try {\n    var childCount = from.getChildCount();\n    for (var i = 0; i < childCount; i++) {\n      var cell = from.getChildAt(i);\n      if (typeof cell.getId == 'function') {\n        var id = cell.getId();\n        var target = id != null && (!this.isEdge(cell) || !cloneAllEdges) ? this.getCell(id) : null;\n\n        // Clones and adds the child if no cell exists for the id\n        if (target == null) {\n          var clone = cell.clone();\n          clone.setId(id);\n\n          // Sets the terminals from the original cell to the clone\n          // because the lookup uses strings not cells in JS\n          clone.setTerminal(cell.getTerminal(true), true);\n          clone.setTerminal(cell.getTerminal(false), false);\n\n          // Do *NOT* use model.add as this will move the edge away\n          // from the parent in updateEdgeParent if maintainEdgeParent\n          // is enabled in the target model\n          target = to.insert(clone);\n          this.cellAdded(target);\n        }\n\n        // Stores the mapping for later reconnecting edges\n        mapping[_mxCellPath[\"default\"].create(cell)] = target;\n\n        // Recurses\n        this.mergeChildrenImpl(cell, target, cloneAllEdges, mapping);\n      }\n    }\n  } finally {\n    this.endUpdate();\n  }\n};\n\n/**\r\n * Function: getParents\r\n *\r\n * Returns an array that represents the set (no duplicates) of all parents\r\n * for the given array of cells.\r\n *\r\n * Parameters:\r\n *\r\n * cells - Array of cells whose parents should be returned.\r\n */\nmxGraphModel.prototype.getParents = function (cells) {\n  var parents = [];\n  if (cells != null) {\n    var dict = new _mxDictionary[\"default\"]();\n    for (var i = 0; i < cells.length; i++) {\n      var parent = this.getParent(cells[i]);\n      if (parent != null && !dict.get(parent)) {\n        dict.put(parent, true);\n        parents.push(parent);\n      }\n    }\n  }\n  return parents;\n};\n\n//\n// Cell Cloning\n//\n\n/**\r\n * Function: cloneCell\r\n *\r\n * Returns a deep clone of the given <mxCell> (including\r\n * the children) which is created using <cloneCells>.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> to be cloned.\r\n */\nmxGraphModel.prototype.cloneCell = function (cell) {\n  if (cell != null) {\n    return this.cloneCells([cell], true)[0];\n  }\n  return null;\n};\n\n/**\r\n * Function: cloneCells\r\n *\r\n * Returns an array of clones for the given array of <mxCells>.\r\n * Depending on the value of includeChildren, a deep clone is created for\r\n * each cell. Connections are restored based if the corresponding\r\n * cell is contained in the passed in array.\r\n *\r\n * Parameters:\r\n *\r\n * cells - Array of <mxCell> to be cloned.\r\n * includeChildren - Boolean indicating if the cells should be cloned\r\n * with all descendants.\r\n * mapping - Optional mapping for existing clones.\r\n */\nmxGraphModel.prototype.cloneCells = function (cells, includeChildren, mapping) {\n  mapping = mapping != null ? mapping : new Object();\n  var clones = [];\n  for (var i = 0; i < cells.length; i++) {\n    if (cells[i] != null) {\n      clones.push(this.cloneCellImpl(cells[i], mapping, includeChildren));\n    } else {\n      clones.push(null);\n    }\n  }\n  for (var i = 0; i < clones.length; i++) {\n    if (clones[i] != null) {\n      this.restoreClone(clones[i], cells[i], mapping);\n    }\n  }\n  return clones;\n};\n\n/**\r\n * Function: cloneCellImpl\r\n *\r\n * Inner helper method for cloning cells recursively.\r\n */\nmxGraphModel.prototype.cloneCellImpl = function (cell, mapping, includeChildren) {\n  var clone = this.cellCloned(cell);\n\n  // Stores the clone in the lookup table\n  mapping[_mxObjectIdentity[\"default\"].get(cell)] = clone;\n  if (includeChildren) {\n    var childCount = this.getChildCount(cell);\n    for (var i = 0; i < childCount; i++) {\n      var cloneChild = this.cloneCellImpl(this.getChildAt(cell, i), mapping, true);\n      clone.insert(cloneChild);\n    }\n  }\n  return clone;\n};\n\n/**\r\n * Function: cellCloned\r\n *\r\n * Hook for cloning the cell. This returns cell.clone() or\r\n * any possible exceptions.\r\n */\nmxGraphModel.prototype.cellCloned = function (cell) {\n  return cell.clone();\n};\n\n/**\r\n * Function: restoreClone\r\n *\r\n * Inner helper method for restoring the connections in\r\n * a network of cloned cells.\r\n */\nmxGraphModel.prototype.restoreClone = function (clone, cell, mapping) {\n  var source = this.getTerminal(cell, true);\n  if (source != null) {\n    var tmp = mapping[_mxObjectIdentity[\"default\"].get(source)];\n    if (tmp != null) {\n      tmp.insertEdge(clone, true);\n    }\n  }\n  var target = this.getTerminal(cell, false);\n  if (target != null) {\n    var tmp = mapping[_mxObjectIdentity[\"default\"].get(target)];\n    if (tmp != null) {\n      tmp.insertEdge(clone, false);\n    }\n  }\n  var childCount = this.getChildCount(clone);\n  for (var i = 0; i < childCount; i++) {\n    this.restoreClone(this.getChildAt(clone, i), this.getChildAt(cell, i), mapping);\n  }\n};\n\n/**\r\n* 设置工作流模型元素Map\r\n*/\nmxGraphModel.prototype.setElementMap = function (elementMap) {\n  this.elementMap = elementMap;\n};\n/**\r\n* 按类型获取模型元素\r\n*/\nmxGraphModel.prototype.getElementByType = function (type) {\n  if (this.elementMap) {\n    return this.elementMap.get(type);\n  }\n  return null;\n};\n//只返回模型图形相关数据\nmxGraphModel.prototype.getModelGraph = function () {\n  var root = this.getBPMNRoot();\n  return {\n    resourceId: root.getId(),\n    childShapes: root.getCellGraph()\n    //bounds的值由graph填充，获取模型统一使用graph的获取模型JSON方法\n  };\n};\nmxGraphModel.prototype.toBpmnJSON = function () {\n  var root = this.getBPMNRoot();\n  return {\n    resourceId: root.getId(),\n    stencil: {\n      id: 'BPMNDiagram' //TODO 正确的类型\n    },\n    childShapes: root.toBpmnJSON(),\n    /*properties: Object.assign(root.properties, {\r\n    \tprocess_id: root.getProperty('base', 'process_id'),\r\n    \tdocumentation: root.getProperty('base', 'documentation'),\r\n    \tname: root.getProperty('base', 'name')\r\n    }),*/\n    //bounds的值由graph填充，获取模型统一使用graph的获取模型JSON方法\n    bounds: {\n      lowerRight: {},\n      upperLeft: {}\n    },\n    stencilset: {\n      url: \"stencilsets/bpmn2.0/bpmn2.0.json\",\n      namespace: \"http://b3mn.org/stencilset/bpmn2.0#\"\n    },\n    ssextensions: []\n  };\n};\n//TODO: 取正确的Root\nmxGraphModel.prototype.getBPMNRoot = function () {\n  //TODO:这样处理是否正确\n  var root = this.getRoot();\n  return root.children[0];\n};\nmxGraphModel.getName = function () {\n  return 'mxGraphModel';\n};\n//\n// Atomic changes\n//\n\n/**\r\n * Class: mxRootChange\r\n *\r\n * Action to change the root in a model.\r\n *\r\n * Constructor: mxRootChange\r\n *\r\n * Constructs a change of the root in the\r\n * specified model.\r\n */\nvar _default = exports[\"default\"] = mxGraphModel;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxGraphModel.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxGraphSelectionModel.js":
/*!********************************************************!*\
  !*** ./src/workflow/mxClient/mxGraphSelectionModel.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.index-of.js */ \"../../node_modules/core-js/modules/es.array.index-of.js\");\n__webpack_require__(/*! core-js/modules/es.array.splice.js */ \"../../node_modules/core-js/modules/es.array.splice.js\");\nvar _mxEventObject = _interopRequireDefault(__webpack_require__(/*! ./mxEventObject.js */ \"./src/workflow/mxClient/mxEventObject.js\"));\nvar _mxClient = _interopRequireDefault(__webpack_require__(/*! ./mxClient.js */ \"./src/workflow/mxClient/mxClient.js\"));\nvar _mxEvent = _interopRequireDefault(__webpack_require__(/*! ./mxEvent.js */ \"./src/workflow/mxClient/mxEvent.js\"));\nvar _mxSelectionChange = _interopRequireDefault(__webpack_require__(/*! ./mxSelectionChange.js */ \"./src/workflow/mxClient/mxSelectionChange.js\"));\nvar _mxEventSource = _interopRequireDefault(__webpack_require__(/*! ./mxEventSource.js */ \"./src/workflow/mxClient/mxEventSource.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxUndoableEdit = _interopRequireDefault(__webpack_require__(/*! ./mxUndoableEdit.js */ \"./src/workflow/mxClient/mxUndoableEdit.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxGraphSelectionModel(graph) {\n  this.graph = graph;\n  this.cells = [];\n}\n;\n\n/**\r\n * Extends mxEventSource.\r\n */\nmxGraphSelectionModel.prototype = new _mxEventSource[\"default\"]();\nmxGraphSelectionModel.prototype.constructor = mxGraphSelectionModel;\n\n/**\r\n * Variable: doneResource\r\n *\r\n * Specifies the resource key for the status message after a long operation.\r\n * If the resource for this key does not exist then the value is used as\r\n * the status message. Default is 'done'.\r\n */\nmxGraphSelectionModel.prototype.doneResource = _mxClient[\"default\"].language != 'none' ? 'done' : '';\n\n/**\r\n * Variable: updatingSelectionResource\r\n *\r\n * Specifies the resource key for the status message while the selection is\r\n * being updated. If the resource for this key does not exist then the\r\n * value is used as the status message. Default is 'updatingSelection'.\r\n */\nmxGraphSelectionModel.prototype.updatingSelectionResource = _mxClient[\"default\"].language != 'none' ? 'updatingSelection' : '';\n\n/**\r\n * Variable: graph\r\n *\r\n * Reference to the enclosing <mxGraph>.\r\n */\nmxGraphSelectionModel.prototype.graph = null;\n\n/**\r\n * Variable: singleSelection\r\n *\r\n * Specifies if only one selected item at a time is allowed.\r\n * Default is false.\r\n */\nmxGraphSelectionModel.prototype.singleSelection = false;\n\n/**\r\n * Function: isSingleSelection\r\n *\r\n * Returns <singleSelection> as a boolean.\r\n */\nmxGraphSelectionModel.prototype.isSingleSelection = function () {\n  return this.singleSelection;\n};\n\n/**\r\n * Function: setSingleSelection\r\n *\r\n * Sets the <singleSelection> flag.\r\n *\r\n * Parameters:\r\n *\r\n * singleSelection - Boolean that specifies the new value for\r\n * <singleSelection>.\r\n */\nmxGraphSelectionModel.prototype.setSingleSelection = function (singleSelection) {\n  this.singleSelection = singleSelection;\n};\n\n/**\r\n * Function: isSelected\r\n *\r\n * Returns true if the given <mxCell> is selected.\r\n */\nmxGraphSelectionModel.prototype.isSelected = function (cell) {\n  if (cell != null) {\n    return _mxGraphUtils[\"default\"].indexOf(this.cells, cell) >= 0;\n  }\n  return false;\n};\n\n/**\r\n * Function: isEmpty\r\n *\r\n * Returns true if no cells are currently selected.\r\n */\nmxGraphSelectionModel.prototype.isEmpty = function () {\n  return this.cells.length == 0;\n};\n\n/**\r\n * Function: clear\r\n *\r\n * Clears the selection and fires a <change> event if the selection was not\r\n * empty.\r\n */\nmxGraphSelectionModel.prototype.clear = function () {\n  this.changeSelection(null, this.cells);\n};\n\n/**\r\n * Function: setCell\r\n *\r\n * Selects the specified <mxCell> using <setCells>.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> to be selected.\r\n */\nmxGraphSelectionModel.prototype.setCell = function (cell) {\n  if (cell != null) {\n    this.setCells([cell]);\n  }\n};\n\n/**\r\n * Function: setCells\r\n *\r\n * Selects the given array of <mxCells> and fires a <change> event.\r\n *\r\n * Parameters:\r\n *\r\n * cells - Array of <mxCells> to be selected.\r\n */\nmxGraphSelectionModel.prototype.setCells = function (cells) {\n  if (cells != null) {\n    if (this.singleSelection) {\n      cells = [this.getFirstSelectableCell(cells)];\n    }\n    var tmp = [];\n    for (var i = 0; i < cells.length; i++) {\n      if (this.graph.isCellSelectable(cells[i])) {\n        tmp.push(cells[i]);\n      }\n    }\n    this.changeSelection(tmp, this.cells);\n  }\n};\n\n/**\r\n * Function: getFirstSelectableCell\r\n *\r\n * Returns the first selectable cell in the given array of cells.\r\n */\nmxGraphSelectionModel.prototype.getFirstSelectableCell = function (cells) {\n  if (cells != null) {\n    for (var i = 0; i < cells.length; i++) {\n      if (this.graph.isCellSelectable(cells[i])) {\n        return cells[i];\n      }\n    }\n  }\n  return null;\n};\n\n/**\r\n * Function: addCell\r\n *\r\n * Adds the given <mxCell> to the selection and fires a <select> event.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> to add to the selection.\r\n */\nmxGraphSelectionModel.prototype.addCell = function (cell) {\n  if (cell != null) {\n    this.addCells([cell]);\n  }\n};\n\n/**\r\n * Function: addCells\r\n *\r\n * Adds the given array of <mxCells> to the selection and fires a <select>\r\n * event.\r\n *\r\n * Parameters:\r\n *\r\n * cells - Array of <mxCells> to add to the selection.\r\n */\nmxGraphSelectionModel.prototype.addCells = function (cells) {\n  if (cells != null) {\n    var remove = null;\n    if (this.singleSelection) {\n      remove = this.cells;\n      cells = [this.getFirstSelectableCell(cells)];\n    }\n    var tmp = [];\n    for (var i = 0; i < cells.length; i++) {\n      if (!this.isSelected(cells[i]) && this.graph.isCellSelectable(cells[i])) {\n        tmp.push(cells[i]);\n      }\n    }\n    this.changeSelection(tmp, remove);\n  }\n};\n\n/**\r\n * Function: removeCell\r\n *\r\n * Removes the specified <mxCell> from the selection and fires a <select>\r\n * event for the remaining cells.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> to remove from the selection.\r\n */\nmxGraphSelectionModel.prototype.removeCell = function (cell) {\n  if (cell != null) {\n    this.removeCells([cell]);\n  }\n};\n\n/**\r\n * Function: removeCells\r\n */\nmxGraphSelectionModel.prototype.removeCells = function (cells) {\n  if (cells != null) {\n    var tmp = [];\n    for (var i = 0; i < cells.length; i++) {\n      if (this.isSelected(cells[i])) {\n        tmp.push(cells[i]);\n      }\n    }\n    this.changeSelection(null, tmp);\n  }\n};\n\n/**\r\n * Function: changeSelection\r\n *\r\n * Inner callback to add the specified <mxCell> to the selection. No event\r\n * is fired in this implementation.\r\n *\r\n * Paramters:\r\n *\r\n * cell - <mxCell> to add to the selection.\r\n */\nmxGraphSelectionModel.prototype.changeSelection = function (added, removed) {\n  if (added != null && added.length > 0 && added[0] != null || removed != null && removed.length > 0 && removed[0] != null) {\n    var change = new _mxSelectionChange[\"default\"](this, added, removed);\n    change.execute();\n    var edit = new _mxUndoableEdit[\"default\"](this, false);\n    edit.add(change);\n    this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].UNDO, 'edit', edit));\n  }\n};\n\n/**\r\n * Function: cellAdded\r\n *\r\n * Inner callback to add the specified <mxCell> to the selection. No event\r\n * is fired in this implementation.\r\n *\r\n * Paramters:\r\n *\r\n * cell - <mxCell> to add to the selection.\r\n */\nmxGraphSelectionModel.prototype.cellAdded = function (cell) {\n  if (cell != null && !this.isSelected(cell)) {\n    this.cells.push(cell);\n  }\n};\n\n/**\r\n * Function: cellRemoved\r\n *\r\n * Inner callback to remove the specified <mxCell> from the selection. No\r\n * event is fired in this implementation.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> to remove from the selection.\r\n */\nmxGraphSelectionModel.prototype.cellRemoved = function (cell) {\n  if (cell != null) {\n    var index = _mxGraphUtils[\"default\"].indexOf(this.cells, cell);\n    if (index >= 0) {\n      this.cells.splice(index, 1);\n    }\n  }\n};\n\n/**\r\n * Class: mxSelectionChange\r\n *\r\n * Action to change the current root in a view.\r\n *\r\n * Constructor: mxCurrentRootChange\r\n *\r\n * Constructs a change of the current root in the given view.\r\n */\nvar _default = exports[\"default\"] = mxGraphSelectionModel;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxGraphSelectionModel.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxGraphUtils.js":
/*!***********************************************!*\
  !*** ./src/workflow/mxClient/mxGraphUtils.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.symbol.js */ \"../../node_modules/core-js/modules/es.symbol.js\");\n__webpack_require__(/*! core-js/modules/es.symbol.description.js */ \"../../node_modules/core-js/modules/es.symbol.description.js\");\n__webpack_require__(/*! core-js/modules/es.symbol.iterator.js */ \"../../node_modules/core-js/modules/es.symbol.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.array.iterator.js */ \"../../node_modules/core-js/modules/es.array.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\n__webpack_require__(/*! core-js/modules/es.string.iterator.js */ \"../../node_modules/core-js/modules/es.string.iterator.js\");\n__webpack_require__(/*! core-js/modules/web.dom-collections.iterator.js */ \"../../node_modules/core-js/modules/web.dom-collections.iterator.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.filter.js */ \"../../node_modules/core-js/modules/es.array.filter.js\");\n__webpack_require__(/*! core-js/modules/es.array.index-of.js */ \"../../node_modules/core-js/modules/es.array.index-of.js\");\n__webpack_require__(/*! core-js/modules/es.array.join.js */ \"../../node_modules/core-js/modules/es.array.join.js\");\n__webpack_require__(/*! core-js/modules/es.date.to-string.js */ \"../../node_modules/core-js/modules/es.date.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.function.name.js */ \"../../node_modules/core-js/modules/es.function.name.js\");\n__webpack_require__(/*! core-js/modules/es.number.constructor.js */ \"../../node_modules/core-js/modules/es.number.constructor.js\");\n__webpack_require__(/*! core-js/modules/es.number.to-fixed.js */ \"../../node_modules/core-js/modules/es.number.to-fixed.js\");\n__webpack_require__(/*! core-js/modules/es.object.to-string.js */ \"../../node_modules/core-js/modules/es.object.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.parse-float.js */ \"../../node_modules/core-js/modules/es.parse-float.js\");\n__webpack_require__(/*! core-js/modules/es.parse-int.js */ \"../../node_modules/core-js/modules/es.parse-int.js\");\n__webpack_require__(/*! core-js/modules/es.regexp.constructor.js */ \"../../node_modules/core-js/modules/es.regexp.constructor.js\");\n__webpack_require__(/*! core-js/modules/es.regexp.exec.js */ \"../../node_modules/core-js/modules/es.regexp.exec.js\");\n__webpack_require__(/*! core-js/modules/es.regexp.to-string.js */ \"../../node_modules/core-js/modules/es.regexp.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.string.replace.js */ \"../../node_modules/core-js/modules/es.string.replace.js\");\n__webpack_require__(/*! core-js/modules/es.string.trim.js */ \"../../node_modules/core-js/modules/es.string.trim.js\");\nvar _mxGraphConstants = _interopRequireDefault(__webpack_require__(/*! ./mxGraphConstants.js */ \"./src/workflow/mxClient/mxGraphConstants.js\"));\nvar _mxClient = _interopRequireDefault(__webpack_require__(/*! ./mxClient.js */ \"./src/workflow/mxClient/mxClient.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nvar mxGraphUtils = {\n  clone: function clone(obj, transients, shallow) {\n    shallow = shallow != null ? shallow : false;\n    var clone = null;\n    if (obj != null && typeof obj.constructor == 'function') {\n      clone = new obj.constructor();\n      for (var i in obj) {\n        if (i != _mxGraphConstants[\"default\"].FIELD_NAME && (transients == null || mxGraphUtils.indexOf(transients, i) < 0)) {\n          if (!shallow && _typeof(obj[i]) == 'object') {\n            clone[i] = mxGraphUtils.clone(obj[i]);\n          } else {\n            clone[i] = obj[i];\n          }\n        }\n      }\n    }\n    return clone;\n  },\n  indexOf: function indexOf(array, obj) {\n    if (array != null && obj != null) {\n      for (var i = 0; i < array.length; i++) {\n        if (array[i] == obj) {\n          return i;\n        }\n      }\n    }\n    return -1;\n  },\n  extend: function extend(ctor, superCtor) {\n    var f = function f() {};\n    f.prototype = superCtor.prototype;\n    ctor.prototype = new f();\n    ctor.prototype.constructor = ctor;\n  },\n  isNode: function isNode(value, nodeName, attributeName, attributeValue) {\n    if (value != null && !isNaN(value.nodeType) && (nodeName == null || value.nodeName.toLowerCase() == nodeName.toLowerCase())) {\n      return attributeName == null || value.getAttribute(attributeName) == attributeValue;\n    }\n    return false;\n  },\n  htmlEntities: function htmlEntities(s, newline) {\n    s = s || '';\n    s = s.replace(/&/g, '&amp;'); // 38 26\n    s = s.replace(/\"/g, '&quot;'); // 34 22\n    s = s.replace(/\\'/g, '&#39;'); // 39 27\n    s = s.replace(/</g, '&lt;'); // 60 3C\n    s = s.replace(/>/g, '&gt;'); // 62 3E\n\n    if (newline == null || newline) {\n      s = s.replace(/\\n/g, '&#xa;');\n    }\n    return s;\n  },\n  replaceTrailingNewlines: function replaceTrailingNewlines(str, pattern) {\n    // LATER: Check is this can be done with a regular expression\n    var postfix = '';\n    while (str.length > 0 && str.charAt(str.length - 1) == '\\n') {\n      str = str.substring(0, str.length - 1);\n      postfix += pattern;\n    }\n    return str + postfix;\n  },\n  getValue: function getValue(array, key, defaultValue) {\n    var value = array != null ? array[key] : null;\n    if (value == null) {\n      value = defaultValue;\n    }\n    return value;\n  },\n  ltrim: function ltrim(str, chars) {\n    chars = chars || \"\\\\s\";\n    return str.replace(new RegExp(\"^[\" + chars + \"]+\", \"g\"), \"\");\n  },\n  rtrim: function rtrim(str, chars) {\n    chars = chars || \"\\\\s\";\n    return str.replace(new RegExp(\"[\" + chars + \"]+$\", \"g\"), \"\");\n  },\n  trim: function trim(str, chars) {\n    return mxGraphUtils.ltrim(mxGraphUtils.rtrim(str, chars), chars);\n  },\n  setPrefixedStyle: function () {\n    var prefix = null;\n    if (_mxClient[\"default\"].IS_OT) {\n      prefix = 'O';\n    } else if (_mxClient[\"default\"].IS_SF || _mxClient[\"default\"].IS_GC) {\n      prefix = 'Webkit';\n    } else if (_mxClient[\"default\"].IS_MT) {\n      prefix = 'Moz';\n    } else if (_mxClient[\"default\"].IS_IE && document.documentMode >= 9 && document.documentMode < 10) {\n      prefix = 'ms';\n    }\n    return function (style, name, value) {\n      style[name] = value;\n      if (prefix != null && name.length > 0) {\n        name = prefix + name.substring(0, 1).toUpperCase() + name.substring(1);\n        style[name] = value;\n      }\n    };\n  }(),\n  setOpacity: function setOpacity(node, value) {\n    if (mxGraphUtils.isVml(node)) {\n      if (value >= 100) {\n        node.style.filter = '';\n      } else {\n        // TODO: Why is the division by 5 needed in VML?\n        node.style.filter = 'alpha(opacity=' + value / 5 + ')';\n      }\n    } else if (_mxClient[\"default\"].IS_IE && (typeof document.documentMode === 'undefined' || document.documentMode < 9)) {\n      if (value >= 100) {\n        node.style.filter = '';\n      } else {\n        node.style.filter = 'alpha(opacity=' + value + ')';\n      }\n    } else {\n      node.style.opacity = value / 100;\n    }\n  },\n  isVml: function isVml(node) {\n    return node != null && node.tagUrn == 'urn:schemas-microsoft-com:vml';\n  },\n  getAlignmentAsPoint: function getAlignmentAsPoint(align, valign, pointFun) {\n    var dx = 0;\n    var dy = 0;\n\n    // Horizontal alignment\n    if (align == _mxGraphConstants[\"default\"].ALIGN_CENTER) {\n      dx = -0.5;\n    } else if (align == _mxGraphConstants[\"default\"].ALIGN_RIGHT) {\n      dx = -1;\n    }\n\n    // Vertical alignment\n    if (valign == _mxGraphConstants[\"default\"].ALIGN_MIDDLE) {\n      dy = -0.5;\n    } else if (valign == _mxGraphConstants[\"default\"].ALIGN_BOTTOM) {\n      dy = -1;\n    }\n    return new pointFun(dx, dy);\n  },\n  getNumber: function getNumber(array, key, defaultValue) {\n    var value = array != null ? array[key] : null;\n    if (value == null) {\n      value = defaultValue || 0;\n    }\n    return Number(value);\n  },\n  getColor: function getColor(array, key, defaultValue) {\n    var value = array != null ? array[key] : null;\n    if (value == null) {\n      value = defaultValue;\n    } else if (value == _mxGraphConstants[\"default\"].NONE) {\n      value = null;\n    }\n    return value;\n  },\n  mod: function mod(n, m) {\n    return (n % m + m) % m;\n  },\n  addTransparentBackgroundFilter: function addTransparentBackgroundFilter(node) {\n    node.style.filter += 'progid:DXImageTransform.Microsoft.AlphaImageLoader(src=\\'' + _mxClient[\"default\"].imageBasePath + '/transparent.gif\\', sizingMethod=\\'scale\\')';\n  },\n  getBoundingBox: function getBoundingBox(rect, rotation, cx, rectangleFun, pointFun) {\n    var result = null;\n    if (rect != null && rotation != null && rotation != 0) {\n      var rad = mxGraphUtils.toRadians(rotation);\n      var cos = Math.cos(rad);\n      var sin = Math.sin(rad);\n      cx = cx != null ? cx : new pointFun(rect.x + rect.width / 2, rect.y + rect.height / 2);\n      var p1 = new pointFun(rect.x, rect.y);\n      var p2 = new pointFun(rect.x + rect.width, rect.y);\n      var p3 = new pointFun(p2.x, rect.y + rect.height);\n      var p4 = new pointFun(rect.x, p3.y);\n      p1 = mxGraphUtils.getRotatedPoint(p1, cos, sin, cx, pointFun);\n      p2 = mxGraphUtils.getRotatedPoint(p2, cos, sin, cx, pointFun);\n      p3 = mxGraphUtils.getRotatedPoint(p3, cos, sin, cx, pointFun);\n      p4 = mxGraphUtils.getRotatedPoint(p4, cos, sin, cx, pointFun);\n      result = new rectangleFun(p1.x, p1.y, 0, 0);\n      result.add(new rectangleFun(p2.x, p2.y, 0, 0));\n      result.add(new rectangleFun(p3.x, p3.y, 0, 0));\n      result.add(new rectangleFun(p4.x, p4.y, 0, 0));\n    }\n    return result;\n  },\n  /**\r\n   * Function: getRotatedPoint\r\n   *\r\n   * Rotates the given point by the given cos and sin.\r\n   */\n  getRotatedPoint: function getRotatedPoint(pt, cos, sin, c, pointFun) {\n    c = c != null ? c : new pointFun();\n    var x = pt.x - c.x;\n    var y = pt.y - c.y;\n    var x1 = x * cos - y * sin;\n    var y1 = y * cos + x * sin;\n    return new pointFun(x1 + c.x, y1 + c.y);\n  },\n  toString: function toString(obj) {\n    var output = '';\n    for (var i in obj) {\n      try {\n        if (obj[i] == null) {\n          output += i + ' = [null]\\n';\n        } else if (typeof obj[i] == 'function') {\n          output += i + ' => [Function]\\n';\n        } else if (_typeof(obj[i]) == 'object') {\n          var ctor = mxGraphUtils.getFunctionName(obj[i].constructor);\n          output += i + ' => [' + ctor + ']\\n';\n        } else {\n          output += i + ' = ' + obj[i] + '\\n';\n        }\n      } catch (e) {\n        output += i + '=' + e.message;\n      }\n    }\n    return output;\n  },\n  getFunctionName: function getFunctionName(f) {\n    var str = null;\n    if (f != null) {\n      if (typeof f.getName === 'function') {\n        str = f.getName();\n      } else if (f.name != null) {\n        str = f.name;\n      } else {\n        str = mxGraphUtils.trim(f.toString());\n        if (/^function\\s/.test(str)) {\n          str = mxGraphUtils.ltrim(str.substring(9));\n          var idx2 = str.indexOf('(');\n          if (idx2 > 0) {\n            str = str.substring(0, idx2);\n          }\n        }\n      }\n    }\n    return str;\n  },\n  write: function write(parent, text) {\n    var doc = parent.ownerDocument;\n    var node = doc.createTextNode(text);\n    if (parent != null) {\n      parent.appendChild(node);\n    }\n    return node;\n  },\n  writeln: function writeln(parent, text) {\n    var doc = parent.ownerDocument;\n    var node = doc.createTextNode(text);\n    if (parent != null) {\n      parent.appendChild(node);\n      parent.appendChild(document.createElement('br'));\n    }\n    return node;\n  },\n  alert: function (_alert) {\n    function alert(_x) {\n      return _alert.apply(this, arguments);\n    }\n    alert.toString = function () {\n      return _alert.toString();\n    };\n    return alert;\n  }(function (message) {\n    alert(message);\n  }),\n  popup: function popup(content, isInternalWindow, windowFun) {\n    if (isInternalWindow) {\n      var div = document.createElement('div');\n      div.style.overflow = 'scroll';\n      div.style.width = '636px';\n      div.style.height = '460px';\n      var pre = document.createElement('pre');\n      pre.innerHTML = mxGraphUtils.htmlEntities(content, false).replace(/\\n/g, '<br>').replace(/ /g, '&nbsp;');\n      div.appendChild(pre);\n      var w = document.body.clientWidth;\n      var h = Math.max(document.body.clientHeight || 0, document.documentElement.clientHeight);\n      var wnd = new windowFun('Popup Window', div, w / 2 - 320, h / 2 - 240, 640, 480, false, true);\n      wnd.setClosable(true);\n      wnd.setVisible(true);\n    } else {\n      // Wraps up the XML content in a textarea\n      if (_mxClient[\"default\"].IS_NS) {\n        var wnd = window.open();\n        wnd.document.writeln('<pre>' + mxGraphUtils.htmlEntities(content) + '</pre');\n        wnd.document.close();\n      } else {\n        var wnd = window.open();\n        var pre = wnd.document.createElement('pre');\n        pre.innerHTML = mxGraphUtils.htmlEntities(content, false).replace(/\\n/g, '<br>').replace(/ /g, '&nbsp;');\n        wnd.document.body.appendChild(pre);\n      }\n    }\n  },\n  bind: function bind(scope, funct) {\n    return function () {\n      return funct.apply(scope, arguments);\n    };\n  },\n  getOffset: function getOffset(container, scrollOffset, pointFun) {\n    var offsetLeft = 0;\n    var offsetTop = 0;\n    if (scrollOffset != null && scrollOffset) {\n      var offset = mxGraphUtils.getDocumentScrollOrigin(container.ownerDocument);\n      offsetLeft += offset.x;\n      offsetTop += offset.y;\n    }\n    var r = container.getBoundingClientRect();\n    if (r != null) {\n      offsetLeft += r.left;\n      offsetTop += r.top;\n    }\n    return new pointFun(offsetLeft, offsetTop);\n  },\n  getDocumentScrollOrigin: function getDocumentScrollOrigin(doc, pointFun) {\n    if (_mxClient[\"default\"].IS_QUIRKS) {\n      return new pointFun(doc.body.scrollLeft, doc.body.scrollTop);\n    } else {\n      var wnd = doc.defaultView || doc.parentWindow;\n      var x = wnd != null && window.pageXOffset !== undefined ? window.pageXOffset : (document.documentElement || document.body.parentNode || document.body).scrollLeft;\n      var y = wnd != null && window.pageYOffset !== undefined ? window.pageYOffset : (document.documentElement || document.body.parentNode || document.body).scrollTop;\n      return new pointFun(x, y);\n    }\n  },\n  getScrollOrigin: function getScrollOrigin(node, pointFun) {\n    var b = document.body;\n    var d = document.documentElement;\n    var result = mxGraphUtils.getDocumentScrollOrigin(node != null ? node.ownerDocument : document, pointFun);\n    while (node != null && node != b && node != d) {\n      if (!isNaN(node.scrollLeft) && !isNaN(node.scrollTop)) {\n        result.x += node.scrollLeft;\n        result.y += node.scrollTop;\n      }\n      node = node.parentNode;\n    }\n    return result;\n  },\n  getCurrentStyle: function () {\n    if (_mxClient[\"default\"].IS_IE) {\n      return function (element) {\n        return element != null ? element.currentStyle : null;\n      };\n    } else {\n      return function (element) {\n        return element != null ? window.getComputedStyle(element, '') : null;\n      };\n    }\n  }(),\n  fit: function fit(node, pointFun) {\n    var left = parseInt(node.offsetLeft);\n    var width = parseInt(node.offsetWidth);\n    var offset = mxGraphUtils.getDocumentScrollOrigin(node.ownerDocument, pointFun);\n    var sl = offset.x;\n    var st = offset.y;\n    var b = document.body;\n    var d = document.documentElement;\n    var right = sl + (b.clientWidth || d.clientWidth);\n    if (left + width > right) {\n      node.style.left = Math.max(sl, right - width) + 'px';\n    }\n    var top = parseInt(node.offsetTop);\n    var height = parseInt(node.offsetHeight);\n    var bottom = st + Math.max(b.clientHeight || 0, d.clientHeight);\n    if (top + height > bottom) {\n      node.style.top = Math.max(st, bottom - height) + 'px';\n    }\n  },\n  parseXml: function () {\n    if (window.DOMParser) {\n      return function (xml) {\n        var parser = new DOMParser();\n        return parser.parseFromString(xml, 'text/xml');\n      };\n    } else\n      // IE<=9\n      {\n        return function (xml) {\n          var result = mxGraphUtils.createXmlDocument();\n          result.async = false;\n          // Workaround for parsing errors with SVG DTD\n          result.validateOnParse = false;\n          result.resolveExternals = false;\n          result.loadXML(xml);\n          return result;\n        };\n      }\n  }(),\n  createXmlDocument: function createXmlDocument() {\n    var doc = null;\n    if (document.implementation && document.implementation.createDocument) {\n      doc = document.implementation.createDocument('', '', null);\n    } else if (window.ActiveXObject) {\n      doc = new ActiveXObject('Microsoft.XMLDOM');\n    }\n    return doc;\n  },\n  getInnerHtml: function () {\n    if (_mxClient[\"default\"].IS_IE) {\n      return function (node) {\n        if (node != null) {\n          return node.innerHTML;\n        }\n        return '';\n      };\n    } else {\n      return function (node) {\n        if (node != null) {\n          var serializer = new XMLSerializer();\n          return serializer.serializeToString(node);\n        }\n        return '';\n      };\n    }\n  }(),\n  importNode: function importNode(doc, node, allChildren) {\n    if (_mxClient[\"default\"].IS_IE && (document.documentMode == null || document.documentMode < 10)) {\n      switch (node.nodeType) {\n        case 1:\n          /* element */\n          {\n            var newNode = doc.createElement(node.nodeName);\n            if (node.attributes && node.attributes.length > 0) {\n              for (var i = 0; i < node.attributes.length; i++) {\n                newNode.setAttribute(node.attributes[i].nodeName, node.getAttribute(node.attributes[i].nodeName));\n              }\n              if (allChildren && node.childNodes && node.childNodes.length > 0) {\n                for (var i = 0; i < node.childNodes.length; i++) {\n                  newNode.appendChild(mxGraphUtils.importNode(doc, node.childNodes[i], allChildren));\n                }\n              }\n            }\n            return newNode;\n          }\n        case 3: /* text */\n        case 4: /* cdata-section */\n        case 8:\n          /* comment */\n          {\n            return doc.createTextNode(node.value);\n          }\n      }\n      ;\n    } else {\n      return doc.importNode(node, allChildren);\n    }\n  },\n  /**\r\n   * Function: arcToCurves\r\n   *\r\n   * Converts the given arc to a series of curves.\r\n   */\n  arcToCurves: function arcToCurves(x0, y0, r1, r2, angle, largeArcFlag, sweepFlag, x, y) {\n    x -= x0;\n    y -= y0;\n    if (r1 === 0 || r2 === 0) {\n      return result;\n    }\n    var fS = sweepFlag;\n    var psai = angle;\n    r1 = Math.abs(r1);\n    r2 = Math.abs(r2);\n    var ctx = -x / 2;\n    var cty = -y / 2;\n    var cpsi = Math.cos(psai * Math.PI / 180);\n    var spsi = Math.sin(psai * Math.PI / 180);\n    var rxd = cpsi * ctx + spsi * cty;\n    var ryd = -1 * spsi * ctx + cpsi * cty;\n    var rxdd = rxd * rxd;\n    var rydd = ryd * ryd;\n    var r1x = r1 * r1;\n    var r2y = r2 * r2;\n    var lamda = rxdd / r1x + rydd / r2y;\n    var sds;\n    if (lamda > 1) {\n      r1 = Math.sqrt(lamda) * r1;\n      r2 = Math.sqrt(lamda) * r2;\n      sds = 0;\n    } else {\n      var seif = 1;\n      if (largeArcFlag === fS) {\n        seif = -1;\n      }\n      sds = seif * Math.sqrt((r1x * r2y - r1x * rydd - r2y * rxdd) / (r1x * rydd + r2y * rxdd));\n    }\n    var txd = sds * r1 * ryd / r2;\n    var tyd = -1 * sds * r2 * rxd / r1;\n    var tx = cpsi * txd - spsi * tyd + x / 2;\n    var ty = spsi * txd + cpsi * tyd + y / 2;\n    var rad = Math.atan2((ryd - tyd) / r2, (rxd - txd) / r1) - Math.atan2(0, 1);\n    var s1 = rad >= 0 ? rad : 2 * Math.PI + rad;\n    rad = Math.atan2((-ryd - tyd) / r2, (-rxd - txd) / r1) - Math.atan2((ryd - tyd) / r2, (rxd - txd) / r1);\n    var dr = rad >= 0 ? rad : 2 * Math.PI + rad;\n    if (fS == 0 && dr > 0) {\n      dr -= 2 * Math.PI;\n    } else if (fS != 0 && dr < 0) {\n      dr += 2 * Math.PI;\n    }\n    var sse = dr * 2 / Math.PI;\n    var seg = Math.ceil(sse < 0 ? -1 * sse : sse);\n    var segr = dr / seg;\n    var t = 8 / 3 * Math.sin(segr / 4) * Math.sin(segr / 4) / Math.sin(segr / 2);\n    var cpsir1 = cpsi * r1;\n    var cpsir2 = cpsi * r2;\n    var spsir1 = spsi * r1;\n    var spsir2 = spsi * r2;\n    var mc = Math.cos(s1);\n    var ms = Math.sin(s1);\n    var x2 = -t * (cpsir1 * ms + spsir2 * mc);\n    var y2 = -t * (spsir1 * ms - cpsir2 * mc);\n    var x3 = 0;\n    var y3 = 0;\n    var result = [];\n    for (var n = 0; n < seg; ++n) {\n      s1 += segr;\n      mc = Math.cos(s1);\n      ms = Math.sin(s1);\n      x3 = cpsir1 * mc - spsir2 * ms + tx;\n      y3 = spsir1 * mc + cpsir2 * ms + ty;\n      var dx = -t * (cpsir1 * ms + spsir2 * mc);\n      var dy = -t * (spsir1 * ms - cpsir2 * mc);\n\n      // CurveTo updates x0, y0 so need to restore it\n      var index = n * 6;\n      result[index] = Number(x2 + x0);\n      result[index + 1] = Number(y2 + y0);\n      result[index + 2] = Number(x3 - dx + x0);\n      result[index + 3] = Number(y3 - dy + y0);\n      result[index + 4] = Number(x3 + x0);\n      result[index + 5] = Number(y3 + y0);\n      x2 = x3 + dx;\n      y2 = y3 + dy;\n    }\n    return result;\n  },\n  /**\r\n   * Function: getOuterHtml\r\n   *\r\n   * Returns the outer HTML for the given node as a string or an empty\r\n   * string if no node was specified. The outer HTML is the text representing\r\n   * all children of the node including the node itself.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * node - DOM node to return the outer HTML for.\r\n   */\n  getOuterHtml: function () {\n    if (_mxClient[\"default\"].IS_IE) {\n      return function (node) {\n        if (node != null) {\n          if (node.outerHTML != null) {\n            return node.outerHTML;\n          } else {\n            var tmp = [];\n            tmp.push('<' + node.nodeName);\n            var attrs = node.attributes;\n            if (attrs != null) {\n              for (var i = 0; i < attrs.length; i++) {\n                var value = attrs[i].value;\n                if (value != null && value.length > 0) {\n                  tmp.push(' ');\n                  tmp.push(attrs[i].nodeName);\n                  tmp.push('=\"');\n                  tmp.push(value);\n                  tmp.push('\"');\n                }\n              }\n            }\n            if (node.innerHTML.length == 0) {\n              tmp.push('/>');\n            } else {\n              tmp.push('>');\n              tmp.push(node.innerHTML);\n              tmp.push('</' + node.nodeName + '>');\n            }\n            return tmp.join('');\n          }\n        }\n        return '';\n      };\n    } else {\n      return function (node) {\n        if (node != null) {\n          var serializer = new XMLSerializer();\n          return serializer.serializeToString(node);\n        }\n        return '';\n      };\n    }\n  }(),\n  isAncestorNode: function isAncestorNode(ancestor, child) {\n    var parent = child;\n    while (parent != null) {\n      if (parent == ancestor) {\n        return true;\n      }\n      parent = parent.parentNode;\n    }\n    return false;\n  },\n  intersects: function intersects(a, b) {\n    var tw = a.width;\n    var th = a.height;\n    var rw = b.width;\n    var rh = b.height;\n    if (rw <= 0 || rh <= 0 || tw <= 0 || th <= 0) {\n      return false;\n    }\n    var tx = a.x;\n    var ty = a.y;\n    var rx = b.x;\n    var ry = b.y;\n    rw += rx;\n    rh += ry;\n    tw += tx;\n    th += ty;\n    return (rw < rx || rw > tx) && (rh < ry || rh > ty) && (tw < tx || tw > rx) && (th < ty || th > ry);\n  },\n  getPortConstraints: function getPortConstraints(terminal, edge, source, defaultValue) {\n    var value = mxGraphUtils.getValue(terminal.style, _mxGraphConstants[\"default\"].STYLE_PORT_CONSTRAINT, null);\n    if (value == null) {\n      return defaultValue;\n    } else {\n      var directions = value.toString();\n      var returnValue = _mxGraphConstants[\"default\"].DIRECTION_MASK_NONE;\n      var constraintRotationEnabled = mxGraphUtils.getValue(terminal.style, _mxGraphConstants[\"default\"].STYLE_PORT_CONSTRAINT_ROTATION, 0);\n      var rotation = 0;\n      if (constraintRotationEnabled == 1) {\n        rotation = mxGraphUtils.getValue(terminal.style, _mxGraphConstants[\"default\"].STYLE_ROTATION, 0);\n      }\n      var quad = 0;\n      if (rotation > 45) {\n        quad = 1;\n        if (rotation >= 135) {\n          quad = 2;\n        }\n      } else if (rotation < -45) {\n        quad = 3;\n        if (rotation <= -135) {\n          quad = 2;\n        }\n      }\n      if (directions.indexOf(_mxGraphConstants[\"default\"].DIRECTION_NORTH) >= 0) {\n        switch (quad) {\n          case 0:\n            returnValue |= _mxGraphConstants[\"default\"].DIRECTION_MASK_NORTH;\n            break;\n          case 1:\n            returnValue |= _mxGraphConstants[\"default\"].DIRECTION_MASK_EAST;\n            break;\n          case 2:\n            returnValue |= _mxGraphConstants[\"default\"].DIRECTION_MASK_SOUTH;\n            break;\n          case 3:\n            returnValue |= _mxGraphConstants[\"default\"].DIRECTION_MASK_WEST;\n            break;\n        }\n      }\n      if (directions.indexOf(_mxGraphConstants[\"default\"].DIRECTION_WEST) >= 0) {\n        switch (quad) {\n          case 0:\n            returnValue |= _mxGraphConstants[\"default\"].DIRECTION_MASK_WEST;\n            break;\n          case 1:\n            returnValue |= _mxGraphConstants[\"default\"].DIRECTION_MASK_NORTH;\n            break;\n          case 2:\n            returnValue |= _mxGraphConstants[\"default\"].DIRECTION_MASK_EAST;\n            break;\n          case 3:\n            returnValue |= _mxGraphConstants[\"default\"].DIRECTION_MASK_SOUTH;\n            break;\n        }\n      }\n      if (directions.indexOf(_mxGraphConstants[\"default\"].DIRECTION_SOUTH) >= 0) {\n        switch (quad) {\n          case 0:\n            returnValue |= _mxGraphConstants[\"default\"].DIRECTION_MASK_SOUTH;\n            break;\n          case 1:\n            returnValue |= _mxGraphConstants[\"default\"].DIRECTION_MASK_WEST;\n            break;\n          case 2:\n            returnValue |= _mxGraphConstants[\"default\"].DIRECTION_MASK_NORTH;\n            break;\n          case 3:\n            returnValue |= _mxGraphConstants[\"default\"].DIRECTION_MASK_EAST;\n            break;\n        }\n      }\n      if (directions.indexOf(_mxGraphConstants[\"default\"].DIRECTION_EAST) >= 0) {\n        switch (quad) {\n          case 0:\n            returnValue |= _mxGraphConstants[\"default\"].DIRECTION_MASK_EAST;\n            break;\n          case 1:\n            returnValue |= _mxGraphConstants[\"default\"].DIRECTION_MASK_SOUTH;\n            break;\n          case 2:\n            returnValue |= _mxGraphConstants[\"default\"].DIRECTION_MASK_WEST;\n            break;\n          case 3:\n            returnValue |= _mxGraphConstants[\"default\"].DIRECTION_MASK_NORTH;\n            break;\n        }\n      }\n      return returnValue;\n    }\n  },\n  /**\r\n   * Function: reversePortConstraints\r\n   *\r\n   * Reverse the port constraint bitmask. For example, north | east\r\n   * becomes south | west\r\n   */\n  reversePortConstraints: function reversePortConstraints(constraint) {\n    var result = 0;\n    result = (constraint & _mxGraphConstants[\"default\"].DIRECTION_MASK_WEST) << 3;\n    result |= (constraint & _mxGraphConstants[\"default\"].DIRECTION_MASK_NORTH) << 1;\n    result |= (constraint & _mxGraphConstants[\"default\"].DIRECTION_MASK_SOUTH) >> 1;\n    result |= (constraint & _mxGraphConstants[\"default\"].DIRECTION_MASK_EAST) >> 3;\n    return result;\n  },\n  contains: function contains(bounds, x, y) {\n    return bounds.x <= x && bounds.x + bounds.width >= x && bounds.y <= y && bounds.y + bounds.height >= y;\n  },\n  ptSegDistSq: function ptSegDistSq(x1, y1, x2, y2, px, py) {\n    x2 -= x1;\n    y2 -= y1;\n    px -= x1;\n    py -= y1;\n    var dotprod = px * x2 + py * y2;\n    var projlenSq;\n    if (dotprod <= 0.0) {\n      projlenSq = 0.0;\n    } else {\n      px = x2 - px;\n      py = y2 - py;\n      dotprod = px * x2 + py * y2;\n      if (dotprod <= 0.0) {\n        projlenSq = 0.0;\n      } else {\n        projlenSq = dotprod * dotprod / (x2 * x2 + y2 * y2);\n      }\n    }\n    var lenSq = px * px + py * py - projlenSq;\n    if (lenSq < 0) {\n      lenSq = 0;\n    }\n    return lenSq;\n  },\n  convertPoint: function convertPoint(container, x, y, pointFun) {\n    var origin = mxGraphUtils.getScrollOrigin(container, pointFun);\n    var offset = mxGraphUtils.getOffset(container, null, pointFun);\n    offset.x -= origin.x;\n    offset.y -= origin.y;\n    return new pointFun(x - offset.x, y - offset.y);\n  },\n  findNearestSegment: function findNearestSegment(state, x, y) {\n    var index = -1;\n    if (state.absolutePoints.length > 0) {\n      var last = state.absolutePoints[0];\n      var min = null;\n      for (var i = 1; i < state.absolutePoints.length; i++) {\n        var current = state.absolutePoints[i];\n        var dist = mxGraphUtils.ptSegDistSq(last.x, last.y, current.x, current.y, x, y);\n        if (min == null || dist < min) {\n          min = dist;\n          index = i - 1;\n        }\n        last = current;\n      }\n    }\n    return index;\n  },\n  isNumeric: function isNumeric(n) {\n    return !isNaN(parseFloat(n)) && isFinite(n) && (typeof n != 'string' || n.toLowerCase().indexOf('0x') < 0);\n  },\n  isInteger: function isInteger(n) {\n    return String(parseInt(n)) === String(n);\n  },\n  eval: function _eval(expr) {\n    var result = null;\n    if (expr.indexOf('function') >= 0) {\n      try {\n        eval('var _mxJavaScriptExpression=' + expr);\n        result = _mxJavaScriptExpression;\n        // TODO: Use delete here?\n        _mxJavaScriptExpression = null;\n      } catch (e) {\n        console && console.warn(e.message + ' while evaluating ' + expr); //mxLog-->warn\n      }\n    } else {\n      try {\n        result = eval(expr);\n      } catch (e) {\n        console && console.warn(e.message + ' while evaluating ' + expr); //mxLog-->warn\n      }\n    }\n    return result;\n  },\n  getTextContent: function getTextContent(node) {\n    if (node.innerText !== undefined) {\n      return node.innerText;\n    } else {\n      return node[node.textContent === undefined ? 'text' : 'textContent'];\n    }\n  },\n  setTextContent: function setTextContent(node, text) {\n    if (node.innerText !== undefined) {\n      node.innerText = text;\n    } else {\n      node[node.textContent === undefined ? 'text' : 'textContent'] = text;\n    }\n  },\n  removeWhitespace: function removeWhitespace(node, before) {\n    var tmp = before ? node.previousSibling : node.nextSibling;\n    while (tmp != null && tmp.nodeType == _mxGraphConstants[\"default\"].NODETYPE_TEXT) {\n      var next = before ? tmp.previousSibling : tmp.nextSibling;\n      var text = mxGraphUtils.getTextContent(tmp);\n      if (mxGraphUtils.trim(text).length == 0) {\n        tmp.parentNode.removeChild(tmp);\n      }\n      tmp = next;\n    }\n  },\n  getChildNodes: function getChildNodes(node, nodeType) {\n    nodeType = nodeType || _mxGraphConstants[\"default\"].NODETYPE_ELEMENT;\n    var children = [];\n    var tmp = node.firstChild;\n    while (tmp != null) {\n      if (tmp.nodeType == nodeType) {\n        children.push(tmp);\n      }\n      tmp = tmp.nextSibling;\n    }\n    return children;\n  },\n  toRadians: function toRadians(deg) {\n    return Math.PI * deg / 180;\n  },\n  toDegree: function toDegree(rad) {\n    return rad * 180 / Math.PI;\n  },\n  getScalePercentage: function getScalePercentage(scale) {\n    var percentage = scale * 100;\n    return percentage.toFixed() + '%';\n  },\n  addClass: function addClass(elm, cls) {\n    if (!elm) {\n      return;\n    }\n    if (elm.classList) {\n      elm.classList.add(cls);\n    } else {\n      var clsAttr = elm.getAttribute('class') || '';\n      elm.setAttribute('class', clsAttr + ' ' + cls);\n    }\n  },\n  removeClass: function removeClass(elm, cls) {\n    if (!elm) {\n      return;\n    }\n    if (elm.classList) {\n      elm.classList.remove(cls);\n    } else {\n      var clsAttr = elm.getAttribute('class');\n      if (clsAttr && clsAttr.indexOf(cls) > -1) {\n        elm.setAttribute('class', clsAttr.replace(cls, ''));\n      }\n    }\n  },\n  hasClass: function hasClass(elm, cls) {\n    if (!elm) {\n      return false;\n    }\n    if (elm.classList) {\n      return elm.classList.contains(cls);\n    } else {\n      var clsAttr = elm.getAttribute('class');\n      return clsAttr && clsAttr.indexOf(cls) > -1;\n    }\n  },\n  isBillRelationCard: function isBillRelationCard(type) {\n    return /billCard|stackedCard/.test(type);\n  },\n  setBillRelationCardOpacity: function setBillRelationCardOpacity(graph, cardCells, value) {\n    //为了避免重新渲染影响事件触发，直接修改样式\n    var states = graph.getView().getCellStates(cardCells);\n    for (var i = 0; i < states.length; i++) {\n      var state = states[i];\n      var cardnode = state.shape.cardnode;\n      state.style.opacity = value;\n      cardnode.style.setProperty('opacity', \"\".concat(value / 100));\n    }\n  },\n  isBoundaryEvent: function isBoundaryEvent(type) {\n    return /Boundary[a-zA-Z]*Event/.test(type);\n  },\n  isGateway: function isGateway(type) {\n    return /[a-zA-Z]*Gateway/.test(type);\n  },\n  isStartEvent: function isStartEvent(type) {\n    return /Start[a-zA-Z]*Event/.test(type);\n  },\n  isEndEvent: function isEndEvent(type) {\n    return /End[a-zA-Z]*Event/.test(type);\n  }\n};\nvar _default = exports[\"default\"] = mxGraphUtils;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxGraphUtils.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxGraphView.js":
/*!**********************************************!*\
  !*** ./src/workflow/mxClient/mxGraphView.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.function.bind.js */ \"../../node_modules/core-js/modules/es.function.bind.js\");\n__webpack_require__(/*! core-js/modules/es.number.constructor.js */ \"../../node_modules/core-js/modules/es.number.constructor.js\");\n__webpack_require__(/*! core-js/modules/es.parse-float.js */ \"../../node_modules/core-js/modules/es.parse-float.js\");\nvar _mxEventObject = _interopRequireDefault(__webpack_require__(/*! ./mxEventObject.js */ \"./src/workflow/mxClient/mxEventObject.js\"));\nvar _mxCellState = _interopRequireDefault(__webpack_require__(/*! ./mxCellState.js */ \"./src/workflow/mxClient/mxCellState.js\"));\nvar _mxEvent = _interopRequireDefault(__webpack_require__(/*! ./mxEvent.js */ \"./src/workflow/mxClient/mxEvent.js\"));\nvar _mxMouseEvent = _interopRequireDefault(__webpack_require__(/*! ./mxMouseEvent.js */ \"./src/workflow/mxClient/mxMouseEvent.js\"));\nvar _mxDictionary = _interopRequireDefault(__webpack_require__(/*! ./mxDictionary.js */ \"./src/workflow/mxClient/mxDictionary.js\"));\nvar _mxRectangle = _interopRequireDefault(__webpack_require__(/*! ./mxRectangle.js */ \"./src/workflow/mxClient/mxRectangle.js\"));\nvar _mxRectangleShape = _interopRequireDefault(__webpack_require__(/*! ./mxRectangleShape.js */ \"./src/workflow/mxClient/mxRectangleShape.js\"));\nvar _mxCurrentRootChange = _interopRequireDefault(__webpack_require__(/*! ./mxCurrentRootChange.js */ \"./src/workflow/mxClient/mxCurrentRootChange.js\"));\nvar _mxStyleRegistry = _interopRequireDefault(__webpack_require__(/*! ./mxStyleRegistry.js */ \"./src/workflow/mxClient/mxStyleRegistry.js\"));\nvar _mxClient = _interopRequireDefault(__webpack_require__(/*! ./mxClient.js */ \"./src/workflow/mxClient/mxClient.js\"));\nvar _mxImageShape = _interopRequireDefault(__webpack_require__(/*! ./mxImageShape.js */ \"./src/workflow/mxClient/mxImageShape.js\"));\nvar _mxPoint = _interopRequireDefault(__webpack_require__(/*! ./mxPoint.js */ \"./src/workflow/mxClient/mxPoint.js\"));\nvar _mxResources = _interopRequireDefault(__webpack_require__(/*! ./mxResources.js */ \"./src/workflow/mxClient/mxResources.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxEventSource = _interopRequireDefault(__webpack_require__(/*! ./mxEventSource.js */ \"./src/workflow/mxClient/mxEventSource.js\"));\nvar _mxUndoableEdit = _interopRequireDefault(__webpack_require__(/*! ./mxUndoableEdit.js */ \"./src/workflow/mxClient/mxUndoableEdit.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ./mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nvar _mxUtils = _interopRequireDefault(__webpack_require__(/*! ./mxUtils.js */ \"./src/workflow/mxClient/mxUtils.js\"));\nvar _mxLog = _interopRequireDefault(__webpack_require__(/*! ./mxLog.js */ \"./src/workflow/mxClient/mxLog.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxGraphView(graph) {\n  this.graph = graph;\n  this.translate = new _mxPoint[\"default\"]();\n  this.graphBounds = new _mxRectangle[\"default\"]();\n  this.states = new _mxDictionary[\"default\"]();\n}\n;\n\n/**\r\n * Extends mxEventSource.\r\n */\nmxGraphView.prototype = new _mxEventSource[\"default\"]();\nmxGraphView.prototype.constructor = mxGraphView;\n\n/**\r\n *\r\n */\nmxGraphView.prototype.EMPTY_POINT = new _mxPoint[\"default\"]();\n\n/**\r\n * Variable: doneResource\r\n *\r\n * Specifies the resource key for the status message after a long operation.\r\n * If the resource for this key does not exist then the value is used as\r\n * the status message. Default is 'done'.\r\n */\nmxGraphView.prototype.doneResource = _mxClient[\"default\"].language != 'none' ? 'done' : '';\n\n/**\r\n * Function: updatingDocumentResource\r\n *\r\n * Specifies the resource key for the status message while the document is\r\n * being updated. If the resource for this key does not exist then the\r\n * value is used as the status message. Default is 'updatingDocument'.\r\n */\nmxGraphView.prototype.updatingDocumentResource = _mxClient[\"default\"].language != 'none' ? 'updatingDocument' : '';\n\n/**\r\n * Variable: allowEval\r\n *\r\n * Specifies if string values in cell styles should be evaluated using\r\n * <mxUtils.eval>. This will only be used if the string values can't be mapped\r\n * to objects using <mxStyleRegistry>. Default is false. NOTE: Enabling this\r\n * switch carries a possible security risk.\r\n */\nmxGraphView.prototype.allowEval = false;\n\n/**\r\n * Variable: captureDocumentGesture\r\n *\r\n * Specifies if a gesture should be captured when it goes outside of the\r\n * graph container. Default is true.\r\n */\nmxGraphView.prototype.captureDocumentGesture = true;\n\n/**\r\n * Variable: optimizeVmlReflows\r\n *\r\n * Specifies if the <canvas> should be hidden while rendering in IE8 standards\r\n * mode and quirks mode. This will significantly improve rendering performance.\r\n * Default is true.\r\n */\nmxGraphView.prototype.optimizeVmlReflows = true;\n\n/**\r\n * Variable: rendering\r\n *\r\n * Specifies if shapes should be created, updated and destroyed using the\r\n * methods of <mxCellRenderer> in <graph>. Default is true.\r\n */\nmxGraphView.prototype.rendering = true;\n\n/**\r\n * Variable: graph\r\n *\r\n * Reference to the enclosing <mxGraph>.\r\n */\nmxGraphView.prototype.graph = null;\n\n/**\r\n * Variable: currentRoot\r\n *\r\n * <mxCell> that acts as the root of the displayed cell hierarchy.\r\n */\nmxGraphView.prototype.currentRoot = null;\n\n/**\r\n * Variable: graphBounds\r\n *\r\n * <mxRectangle> that caches the scales, translated bounds of the current view.\r\n */\nmxGraphView.prototype.graphBounds = null;\n\n/**\r\n * Variable: scale\r\n *\r\n * Specifies the scale. Default is 1 (100%).\r\n */\nmxGraphView.prototype.scale = 1;\n\n/**\r\n * Variable: translate\r\n *\r\n * <mxPoint> that specifies the current translation. Default is a new\r\n * empty <mxPoint>.\r\n */\nmxGraphView.prototype.translate = null;\n\n/**\r\n * Variable: updateStyle\r\n *\r\n * Specifies if the style should be updated in each validation step. If this\r\n * is false then the style is only updated if the state is created or if the\r\n * style of the cell was changed. Default is false.\r\n */\nmxGraphView.prototype.updateStyle = false;\n\n/**\r\n * Variable: lastNode\r\n *\r\n * During validation, this contains the last DOM node that was processed.\r\n */\nmxGraphView.prototype.lastNode = null;\n\n/**\r\n * Variable: lastHtmlNode\r\n *\r\n * During validation, this contains the last HTML DOM node that was processed.\r\n */\nmxGraphView.prototype.lastHtmlNode = null;\n\n/**\r\n * Variable: lastForegroundNode\r\n *\r\n * During validation, this contains the last edge's DOM node that was processed.\r\n */\nmxGraphView.prototype.lastForegroundNode = null;\n\n/**\r\n * Variable: lastForegroundHtmlNode\r\n *\r\n * During validation, this contains the last edge HTML DOM node that was processed.\r\n */\nmxGraphView.prototype.lastForegroundHtmlNode = null;\n\n/**\r\n * Function: getGraphBounds\r\n *\r\n * Returns <graphBounds>.\r\n */\nmxGraphView.prototype.getGraphBounds = function () {\n  return this.graphBounds;\n};\n\n/**\r\n * Function: setGraphBounds\r\n *\r\n * Sets <graphBounds>.\r\n */\nmxGraphView.prototype.setGraphBounds = function (value) {\n  this.graphBounds = value;\n};\n\n/**\r\n * Function: getBounds\r\n *\r\n * Returns the union of all <mxCellStates> for the given array of <mxCells>.\r\n *\r\n * Parameters:\r\n *\r\n * cells - Array of <mxCells> whose bounds should be returned.\r\n */\nmxGraphView.prototype.getBounds = function (cells) {\n  var result = null;\n  if (cells != null && cells.length > 0) {\n    var model = this.graph.getModel();\n    for (var i = 0; i < cells.length; i++) {\n      if (model.isVertex(cells[i]) || model.isEdge(cells[i])) {\n        var state = this.getState(cells[i]);\n        if (state != null) {\n          if (result == null) {\n            result = _mxRectangle[\"default\"].fromRectangle(state);\n          } else {\n            result.add(state);\n          }\n        }\n      }\n    }\n  }\n  return result;\n};\n\n/**\r\n * Function: setCurrentRoot\r\n *\r\n * Sets and returns the current root and fires an <undo> event before\r\n * calling <mxGraph.sizeDidChange>.\r\n *\r\n * Parameters:\r\n *\r\n * root - <mxCell> that specifies the root of the displayed cell hierarchy.\r\n */\nmxGraphView.prototype.setCurrentRoot = function (root) {\n  if (this.currentRoot != root) {\n    var change = new _mxCurrentRootChange[\"default\"](this, root);\n    change.execute();\n    var edit = new _mxUndoableEdit[\"default\"](this, false);\n    edit.add(change);\n    this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].UNDO, 'edit', edit));\n    this.graph.sizeDidChange();\n  }\n  return root;\n};\n\n/**\r\n * Function: scaleAndTranslate\r\n *\r\n * Sets the scale and translation and fires a <scale> and <translate> event\r\n * before calling <revalidate> followed by <mxGraph.sizeDidChange>.\r\n *\r\n * Parameters:\r\n *\r\n * scale - Decimal value that specifies the new scale (1 is 100%).\r\n * dx - X-coordinate of the translation.\r\n * dy - Y-coordinate of the translation.\r\n */\nmxGraphView.prototype.scaleAndTranslate = function (scale, dx, dy) {\n  var previousScale = this.scale;\n  var previousTranslate = new _mxPoint[\"default\"](this.translate.x, this.translate.y);\n  if (this.scale != scale || this.translate.x != dx || this.translate.y != dy) {\n    this.scale = scale;\n    this.translate.x = dx;\n    this.translate.y = dy;\n    if (this.isEventsEnabled()) {\n      this.revalidate();\n      this.graph.sizeDidChange();\n    }\n  }\n  this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].SCALE_AND_TRANSLATE, 'scale', scale, 'previousScale', previousScale, 'translate', this.translate, 'previousTranslate', previousTranslate));\n};\n\n/**\r\n * Function: getScale\r\n *\r\n * Returns the <scale>.\r\n */\nmxGraphView.prototype.getScale = function () {\n  return this.scale;\n};\n\n/**\r\n * Function: setScale\r\n *\r\n * Sets the scale and fires a <scale> event before calling <revalidate> followed\r\n * by <mxGraph.sizeDidChange>.\r\n *\r\n * Parameters:\r\n *\r\n * value - Decimal value that specifies the new scale (1 is 100%).\r\n */\nmxGraphView.prototype.setScale = function (value) {\n  var previousScale = this.scale;\n  if (this.scale != value) {\n    this.scale = value;\n    if (this.isEventsEnabled()) {\n      this.revalidate();\n      this.graph.sizeDidChange();\n    }\n  }\n  this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].SCALE, 'scale', value, 'previousScale', previousScale));\n};\n\n/**\r\n * Function: getTranslate\r\n *\r\n * Returns the <translate>.\r\n */\nmxGraphView.prototype.getTranslate = function () {\n  return this.translate;\n};\n\n/**\r\n * Function: setTranslate\r\n *\r\n * Sets the translation and fires a <translate> event before calling\r\n * <revalidate> followed by <mxGraph.sizeDidChange>. The translation is the\r\n * negative of the origin.\r\n *\r\n * Parameters:\r\n *\r\n * dx - X-coordinate of the translation.\r\n * dy - Y-coordinate of the translation.\r\n */\nmxGraphView.prototype.setTranslate = function (dx, dy, validate) {\n  var previousTranslate = new _mxPoint[\"default\"](this.translate.x, this.translate.y);\n  if (this.translate.x != dx || this.translate.y != dy) {\n    this.translate.x = dx;\n    this.translate.y = dy;\n    if (this.isEventsEnabled() && validate !== false) {\n      this.revalidate();\n      this.graph.sizeDidChange();\n    }\n  }\n  this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].TRANSLATE, 'translate', this.translate, 'previousTranslate', previousTranslate));\n};\n\n/**\r\n * Function: refresh\r\n *\r\n * Clears the view if <currentRoot> is not null and revalidates.\r\n */\nmxGraphView.prototype.refresh = function () {\n  if (this.currentRoot != null) {\n    this.clear();\n  }\n  this.revalidate();\n};\n\n/**\r\n * Function: revalidate\r\n *\r\n * Revalidates the complete view with all cell states.\r\n */\nmxGraphView.prototype.revalidate = function () {\n  this.invalidate();\n  this.validate();\n};\n\n/**\r\n * Function: clear\r\n *\r\n * Removes the state of the given cell and all descendants if the given\r\n * cell is not the current root.\r\n *\r\n * Parameters:\r\n *\r\n * cell - Optional <mxCell> for which the state should be removed. Default\r\n * is the root of the model.\r\n * force - Boolean indicating if the current root should be ignored for\r\n * recursion.\r\n */\nmxGraphView.prototype.clear = function (cell, force, recurse) {\n  var model = this.graph.getModel();\n  cell = cell || model.getRoot();\n  force = force != null ? force : false;\n  recurse = recurse != null ? recurse : true;\n  this.removeState(cell);\n  if (recurse && (force || cell != this.currentRoot)) {\n    var childCount = model.getChildCount(cell);\n    for (var i = 0; i < childCount; i++) {\n      this.clear(model.getChildAt(cell, i), force);\n    }\n  } else {\n    this.invalidate(cell);\n  }\n};\n\n/**\r\n * Function: invalidate\r\n *\r\n * Invalidates the state of the given cell, all its descendants and\r\n * connected edges.\r\n *\r\n * Parameters:\r\n *\r\n * cell - Optional <mxCell> to be invalidated. Default is the root of the\r\n * model.\r\n */\nmxGraphView.prototype.invalidate = function (cell, recurse, includeEdges) {\n  var model = this.graph.getModel();\n  cell = cell || model.getRoot();\n  recurse = recurse != null ? recurse : true;\n  includeEdges = includeEdges != null ? includeEdges : true;\n  var state = this.getState(cell);\n  if (state != null) {\n    state.invalid = true;\n  }\n\n  // Avoids infinite loops for invalid graphs\n  if (!cell.invalidating) {\n    cell.invalidating = true;\n\n    // Recursively invalidates all descendants\n    if (recurse) {\n      var childCount = model.getChildCount(cell);\n      for (var i = 0; i < childCount; i++) {\n        var child = model.getChildAt(cell, i);\n        this.invalidate(child, recurse, includeEdges);\n      }\n    }\n\n    // Propagates invalidation to all connected edges\n    if (includeEdges) {\n      var edgeCount = model.getEdgeCount(cell);\n      for (var i = 0; i < edgeCount; i++) {\n        this.invalidate(model.getEdgeAt(cell, i), recurse, includeEdges);\n      }\n    }\n    delete cell.invalidating;\n  }\n};\n\n/**\r\n * Function: validate\r\n *\r\n * Calls <validateCell> and <validateCellState> and updates the <graphBounds>\r\n * using <getBoundingBox>. Finally the background is validated using\r\n * <validateBackground>.\r\n *\r\n * Parameters:\r\n *\r\n * cell - Optional <mxCell> to be used as the root of the validation.\r\n * Default is <currentRoot> or the root of the model.\r\n */\nmxGraphView.prototype.validate = function (cell) {\n  var t0 = _mxLog[\"default\"].enter('mxGraphView.validate');\n  window.status = _mxResources[\"default\"].get(this.updatingDocumentResource) || this.updatingDocumentResource;\n  this.resetValidationState();\n\n  // Improves IE rendering speed by minimizing reflows\n  var prevDisplay = null;\n  if (this.optimizeVmlReflows && this.canvas != null && this.textDiv == null && (document.documentMode == 8 && !_mxClient[\"default\"].IS_EM || _mxClient[\"default\"].IS_QUIRKS)) {\n    // Placeholder keeps scrollbar positions when canvas is hidden\n    this.placeholder = document.createElement('div');\n    this.placeholder.style.position = 'absolute';\n    this.placeholder.style.width = this.canvas.clientWidth + 'px';\n    this.placeholder.style.height = this.canvas.clientHeight + 'px';\n    this.canvas.parentNode.appendChild(this.placeholder);\n    prevDisplay = this.drawPane.style.display;\n    this.canvas.style.display = 'none';\n\n    // Creates temporary DIV used for text measuring in mxText.updateBoundingBox\n    this.textDiv = document.createElement('div');\n    this.textDiv.style.position = 'absolute';\n    this.textDiv.style.whiteSpace = 'nowrap';\n    this.textDiv.style.visibility = 'hidden';\n    this.textDiv.style.display = _mxClient[\"default\"].IS_QUIRKS ? 'inline' : 'inline-block';\n    this.textDiv.style.zoom = '1';\n    document.body.appendChild(this.textDiv);\n  }\n  var graphBounds = this.getBoundingBox(this.validateCellState(this.validateCell(cell || (this.currentRoot != null ? this.currentRoot : this.graph.getModel().getRoot()))));\n  this.setGraphBounds(graphBounds != null ? graphBounds : this.getEmptyBounds());\n  this.validateBackground();\n  if (prevDisplay != null) {\n    this.canvas.style.display = prevDisplay;\n    this.textDiv.parentNode.removeChild(this.textDiv);\n    if (this.placeholder != null) {\n      this.placeholder.parentNode.removeChild(this.placeholder);\n    }\n\n    // Textdiv cannot be reused\n    this.textDiv = null;\n  }\n  this.resetValidationState();\n  window.status = _mxResources[\"default\"].get(this.doneResource) || this.doneResource;\n  _mxLog[\"default\"].leave('mxGraphView.validate', t0);\n};\n\n/**\r\n * Function: getEmptyBounds\r\n *\r\n * Returns the bounds for an empty graph. This returns a rectangle at\r\n * <translate> with the size of 0 x 0.\r\n */\nmxGraphView.prototype.getEmptyBounds = function () {\n  return new _mxRectangle[\"default\"](this.translate.x * this.scale, this.translate.y * this.scale);\n};\n\n/**\r\n * Function: getBoundingBox\r\n *\r\n * Returns the bounding box of the shape and the label for the given\r\n * <mxCellState> and its children if recurse is true.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> whose bounding box should be returned.\r\n * recurse - Optional boolean indicating if the children should be included.\r\n * Default is true.\r\n */\nmxGraphView.prototype.getBoundingBox = function (state, recurse) {\n  recurse = recurse != null ? recurse : true;\n  var bbox = null;\n  if (state != null) {\n    if (state.shape != null && state.shape.boundingBox != null) {\n      bbox = state.shape.boundingBox.clone();\n    }\n\n    // Adds label bounding box to graph bounds\n    if (state.text != null && state.text.boundingBox != null) {\n      if (bbox != null) {\n        bbox.add(state.text.boundingBox);\n      } else {\n        bbox = state.text.boundingBox.clone();\n      }\n    }\n    if (recurse) {\n      var model = this.graph.getModel();\n      var childCount = model.getChildCount(state.cell);\n      for (var i = 0; i < childCount; i++) {\n        var bounds = this.getBoundingBox(this.getState(model.getChildAt(state.cell, i)));\n        if (bounds != null) {\n          if (bbox == null) {\n            bbox = bounds;\n          } else {\n            bbox.add(bounds);\n          }\n        }\n      }\n    }\n  }\n  return bbox;\n};\n\n/**\r\n * Function: createBackgroundPageShape\r\n *\r\n * Creates and returns the shape used as the background page.\r\n *\r\n * Parameters:\r\n *\r\n * bounds - <mxRectangle> that represents the bounds of the shape.\r\n */\nmxGraphView.prototype.createBackgroundPageShape = function (bounds) {\n  return new _mxRectangleShape[\"default\"](bounds, 'white', 'black');\n};\n\n/**\r\n * Function: validateBackground\r\n *\r\n * Calls <validateBackgroundImage> and <validateBackgroundPage>.\r\n */\nmxGraphView.prototype.validateBackground = function () {\n  this.validateBackgroundImage();\n  this.validateBackgroundPage();\n};\n\n/**\r\n * Function: validateBackgroundImage\r\n *\r\n * Validates the background image.\r\n */\nmxGraphView.prototype.validateBackgroundImage = function () {\n  var bg = this.graph.getBackgroundImage();\n  if (bg != null) {\n    if (this.backgroundImage == null || this.backgroundImage.image != bg.src) {\n      if (this.backgroundImage != null) {\n        this.backgroundImage.destroy();\n      }\n      var bounds = new _mxRectangle[\"default\"](0, 0, 1, 1);\n      this.backgroundImage = new _mxImageShape[\"default\"](bounds, bg.src);\n      this.backgroundImage.dialect = this.graph.dialect;\n      this.backgroundImage.init(this.backgroundPane);\n      this.backgroundImage.redraw();\n\n      // Workaround for ignored event on background in IE8 standards mode\n      if (document.documentMode == 8 && !_mxClient[\"default\"].IS_EM) {\n        _mxEvent[\"default\"].addGestureListeners(this.backgroundImage.node, _mxGraphUtils[\"default\"].bind(this, function (evt) {\n          this.graph.fireMouseEvent(_mxEvent[\"default\"].MOUSE_DOWN, new _mxMouseEvent[\"default\"](evt));\n        }), _mxGraphUtils[\"default\"].bind(this, function (evt) {\n          this.graph.fireMouseEvent(_mxEvent[\"default\"].MOUSE_MOVE, new _mxMouseEvent[\"default\"](evt));\n        }), _mxGraphUtils[\"default\"].bind(this, function (evt) {\n          this.graph.fireMouseEvent(_mxEvent[\"default\"].MOUSE_UP, new _mxMouseEvent[\"default\"](evt));\n        }));\n      }\n    }\n    this.redrawBackgroundImage(this.backgroundImage, bg);\n  } else if (this.backgroundImage != null) {\n    this.backgroundImage.destroy();\n    this.backgroundImage = null;\n  }\n};\n\n/**\r\n * Function: validateBackgroundPage\r\n *\r\n * Validates the background page.\r\n */\nmxGraphView.prototype.validateBackgroundPage = function () {\n  if (this.graph.pageVisible) {\n    var bounds = this.getBackgroundPageBounds();\n    if (this.backgroundPageShape == null) {\n      this.backgroundPageShape = this.createBackgroundPageShape(bounds);\n      this.backgroundPageShape.scale = this.scale;\n      this.backgroundPageShape.isShadow = true;\n      this.backgroundPageShape.dialect = this.graph.dialect;\n      this.backgroundPageShape.init(this.backgroundPane);\n      this.backgroundPageShape.redraw();\n\n      // Adds listener for double click handling on background\n      if (this.graph.nativeDblClickEnabled) {\n        _mxEvent[\"default\"].addListener(this.backgroundPageShape.node, 'dblclick', _mxGraphUtils[\"default\"].bind(this, function (evt) {\n          this.graph.dblClick(evt);\n        }));\n      }\n\n      // Adds basic listeners for graph event dispatching outside of the\n      // container and finishing the handling of a single gesture\n      _mxEvent[\"default\"].addGestureListeners(this.backgroundPageShape.node, _mxGraphUtils[\"default\"].bind(this, function (evt) {\n        this.graph.fireMouseEvent(_mxEvent[\"default\"].MOUSE_DOWN, new _mxMouseEvent[\"default\"](evt));\n      }), _mxGraphUtils[\"default\"].bind(this, function (evt) {\n        // Hides the tooltip if mouse is outside container\n        if (this.graph.tooltipHandler != null && this.graph.tooltipHandler.isHideOnHover()) {\n          this.graph.tooltipHandler.hide();\n        }\n        if (this.graph.isMouseDown && !_mxEvent[\"default\"].isConsumed(evt)) {\n          this.graph.fireMouseEvent(_mxEvent[\"default\"].MOUSE_MOVE, new _mxMouseEvent[\"default\"](evt));\n        }\n      }), _mxGraphUtils[\"default\"].bind(this, function (evt) {\n        this.graph.fireMouseEvent(_mxEvent[\"default\"].MOUSE_UP, new _mxMouseEvent[\"default\"](evt));\n      }));\n    } else {\n      this.backgroundPageShape.scale = this.scale;\n      this.backgroundPageShape.bounds = bounds;\n      this.backgroundPageShape.redraw();\n    }\n  } else if (this.backgroundPageShape != null) {\n    this.backgroundPageShape.destroy();\n    this.backgroundPageShape = null;\n  }\n};\n\n/**\r\n * Function: getBackgroundPageBounds\r\n *\r\n * Returns the bounds for the background page.\r\n */\nmxGraphView.prototype.getBackgroundPageBounds = function () {\n  var fmt = this.graph.pageFormat;\n  var ps = this.scale * this.graph.pageScale;\n  var bounds = new _mxRectangle[\"default\"](this.scale * this.translate.x, this.scale * this.translate.y, fmt.width * ps, fmt.height * ps);\n  return bounds;\n};\n\n/**\r\n * Function: redrawBackgroundImage\r\n *\r\n * Updates the bounds and redraws the background image.\r\n *\r\n * Example:\r\n *\r\n * If the background image should not be scaled, this can be replaced with\r\n * the following.\r\n *\r\n * (code)\r\n * mxGraphView.prototype.redrawBackground = function(backgroundImage, bg)\r\n * {\r\n *   backgroundImage.bounds.x = this.translate.x;\r\n *   backgroundImage.bounds.y = this.translate.y;\r\n *   backgroundImage.bounds.width = bg.width;\r\n *   backgroundImage.bounds.height = bg.height;\r\n *\r\n *   backgroundImage.redraw();\r\n * };\r\n * (end)\r\n *\r\n * Parameters:\r\n *\r\n * backgroundImage - <mxImageShape> that represents the background image.\r\n * bg - <mxImage> that specifies the image and its dimensions.\r\n */\nmxGraphView.prototype.redrawBackgroundImage = function (backgroundImage, bg) {\n  backgroundImage.scale = this.scale;\n  backgroundImage.bounds.x = this.scale * this.translate.x;\n  backgroundImage.bounds.y = this.scale * this.translate.y;\n  backgroundImage.bounds.width = this.scale * bg.width;\n  backgroundImage.bounds.height = this.scale * bg.height;\n  backgroundImage.redraw();\n};\n\n/**\r\n * Function: validateCell\r\n *\r\n * Recursively creates the cell state for the given cell if visible is true and\r\n * the given cell is visible. If the cell is not visible but the state exists\r\n * then it is removed using <removeState>.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose <mxCellState> should be created.\r\n * visible - Optional boolean indicating if the cell should be visible. Default\r\n * is true.\r\n */\nmxGraphView.prototype.validateCell = function (cell, visible) {\n  visible = visible != null ? visible : true;\n  if (cell != null) {\n    visible = visible && this.graph.isCellVisible(cell);\n    var state = this.getState(cell, visible);\n    if (state != null && !visible) {\n      this.removeState(cell);\n    } else {\n      var model = this.graph.getModel();\n      var childCount = model.getChildCount(cell);\n      for (var i = 0; i < childCount; i++) {\n        this.validateCell(model.getChildAt(cell, i), visible && (!this.isCellCollapsed(cell) || cell == this.currentRoot));\n      }\n    }\n  }\n  return cell;\n};\n\n/**\r\n * Function: validateCellState\r\n *\r\n * Validates and repaints the <mxCellState> for the given <mxCell>.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> whose <mxCellState> should be validated.\r\n * recurse - Optional boolean indicating if the children of the cell should be\r\n * validated. Default is true.\r\n */\nmxGraphView.prototype.validateCellState = function (cell, recurse) {\n  recurse = recurse != null ? recurse : true;\n  var state = null;\n  if (cell != null) {\n    state = this.getState(cell);\n    if (state != null) {\n      var model = this.graph.getModel();\n      if (state.invalid) {\n        state.invalid = false;\n        if (state.style == null) {\n          state.style = this.graph.getCellStyle(state.cell);\n        }\n        if (cell != this.currentRoot) {\n          this.validateCellState(model.getParent(cell), false);\n        }\n        state.setVisibleTerminalState(this.validateCellState(this.getVisibleTerminal(cell, true), false), true);\n        state.setVisibleTerminalState(this.validateCellState(this.getVisibleTerminal(cell, false), false), false);\n        this.updateCellState(state);\n\n        // Repaint happens immediately after the cell is validated\n        if (cell != this.currentRoot && !state.invalid) {\n          this.graph.cellRenderer.redraw(state, false, this.isRendering());\n        }\n      }\n      if (recurse && !state.invalid) {\n        // Updates order in DOM if recursively traversing\n        if (state.shape != null) {\n          this.stateValidated(state);\n        }\n        var childCount = model.getChildCount(cell);\n        for (var i = 0; i < childCount; i++) {\n          this.validateCellState(model.getChildAt(cell, i));\n        }\n      }\n    }\n  }\n  return state;\n};\n\n/**\r\n * Function: updateCellState\r\n *\r\n * Updates the given <mxCellState>.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> to be updated.\r\n */\nmxGraphView.prototype.updateCellState = function (state) {\n  state.absoluteOffset.x = 0;\n  state.absoluteOffset.y = 0;\n  state.origin.x = 0;\n  state.origin.y = 0;\n  state.length = 0;\n  if (state.cell != this.currentRoot) {\n    var model = this.graph.getModel();\n    var pState = this.getState(model.getParent(state.cell));\n    if (pState != null && pState.cell != this.currentRoot) {\n      state.origin.x += pState.origin.x;\n      state.origin.y += pState.origin.y;\n    }\n    var offset = this.graph.getChildOffsetForCell(state.cell);\n    if (offset != null) {\n      state.origin.x += offset.x;\n      state.origin.y += offset.y;\n    }\n    var geo = this.graph.getCellGeometry(state.cell);\n    if (geo != null) {\n      if (!model.isEdge(state.cell)) {\n        offset = geo.offset || this.EMPTY_POINT;\n        if (geo.relative && pState != null) {\n          if (model.isEdge(pState.cell)) {\n            var origin = this.getPoint(pState, geo);\n            if (origin != null) {\n              state.origin.x += origin.x / this.scale - pState.origin.x - this.translate.x;\n              state.origin.y += origin.y / this.scale - pState.origin.y - this.translate.y;\n            }\n          } else {\n            state.origin.x += geo.x * pState.width / this.scale + offset.x;\n            state.origin.y += geo.y * pState.height / this.scale + offset.y;\n          }\n        } else {\n          state.absoluteOffset.x = this.scale * offset.x;\n          state.absoluteOffset.y = this.scale * offset.y;\n          state.origin.x += geo.x;\n          state.origin.y += geo.y;\n        }\n      }\n      state.x = this.scale * (this.translate.x + state.origin.x);\n      state.y = this.scale * (this.translate.y + state.origin.y);\n      state.width = this.scale * geo.width;\n      state.unscaledWidth = geo.width;\n      state.height = this.scale * geo.height;\n      if (model.isVertex(state.cell)) {\n        this.updateVertexState(state, geo);\n      }\n      if (model.isEdge(state.cell)) {\n        this.updateEdgeState(state, geo);\n      }\n    }\n  }\n  state.updateCachedBounds();\n};\n\n/**\r\n * Function: isCellCollapsed\r\n *\r\n * Returns true if the children of the given cell should not be visible in the\r\n * view. This implementation uses <mxGraph.isCellVisible> but it can be\r\n * overidden to use a separate condition.\r\n */\nmxGraphView.prototype.isCellCollapsed = function (cell) {\n  return this.graph.isCellCollapsed(cell);\n};\n\n/**\r\n * Function: updateVertexState\r\n *\r\n * Validates the given cell state.\r\n */\nmxGraphView.prototype.updateVertexState = function (state, geo) {\n  var model = this.graph.getModel();\n  var pState = this.getState(model.getParent(state.cell));\n  if (geo.relative && pState != null && !model.isEdge(pState.cell)) {\n    var alpha = _mxUtils[\"default\"].toRadians(pState.style[_mxConstants[\"default\"].STYLE_ROTATION] || '0');\n    if (alpha != 0) {\n      var cos = Math.cos(alpha);\n      var sin = Math.sin(alpha);\n      var ct = new _mxPoint[\"default\"](state.getCenterX(), state.getCenterY());\n      var cx = new _mxPoint[\"default\"](pState.getCenterX(), pState.getCenterY());\n      var pt = _mxUtils[\"default\"].getRotatedPoint(ct, cos, sin, cx);\n      state.x = pt.x - state.width / 2;\n      state.y = pt.y - state.height / 2;\n    }\n  }\n  this.updateVertexLabelOffset(state);\n};\n\n/**\r\n * Function: updateEdgeState\r\n *\r\n * Validates the given cell state.\r\n */\nmxGraphView.prototype.updateEdgeState = function (state, geo) {\n  var source = state.getVisibleTerminalState(true);\n  var target = state.getVisibleTerminalState(false);\n\n  // This will remove edges with no terminals and no terminal points\n  // as such edges are invalid and produce NPEs in the edge styles.\n  // Also removes connected edges that have no visible terminals.\n  if (this.graph.model.getTerminal(state.cell, true) != null && source == null || source == null && geo.getTerminalPoint(true) == null || this.graph.model.getTerminal(state.cell, false) != null && target == null || target == null && geo.getTerminalPoint(false) == null) {\n    this.clear(state.cell, true);\n  } else {\n    this.updateFixedTerminalPoints(state, source, target);\n    this.updatePoints(state, geo.points, source, target);\n    this.updateFloatingTerminalPoints(state, source, target);\n    var pts = state.absolutePoints;\n    if (state.cell != this.currentRoot && (pts == null || pts.length < 2 || pts[0] == null || pts[pts.length - 1] == null)) {\n      // This will remove edges with invalid points from the list of states in the view.\n      // Happens if the one of the terminals and the corresponding terminal point is null.\n      this.clear(state.cell, true);\n    } else {\n      this.updateEdgeBounds(state);\n      this.updateEdgeLabelOffset(state);\n    }\n  }\n};\n\n/**\r\n * Function: updateVertexLabelOffset\r\n *\r\n * Updates the absoluteOffset of the given vertex cell state. This takes\r\n * into account the label position styles.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> whose absolute offset should be updated.\r\n */\nmxGraphView.prototype.updateVertexLabelOffset = function (state) {\n  var h = _mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_LABEL_POSITION, _mxConstants[\"default\"].ALIGN_CENTER);\n  if (h == _mxConstants[\"default\"].ALIGN_LEFT) {\n    var lw = _mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_LABEL_WIDTH, null);\n    if (lw != null) {\n      lw *= this.scale;\n    } else {\n      lw = state.width;\n    }\n    state.absoluteOffset.x -= lw;\n  } else if (h == _mxConstants[\"default\"].ALIGN_RIGHT) {\n    state.absoluteOffset.x += state.width;\n  } else if (h == _mxConstants[\"default\"].ALIGN_CENTER) {\n    var lw = _mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_LABEL_WIDTH, null);\n    if (lw != null) {\n      // Aligns text block with given width inside the vertex width\n      var align = _mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_ALIGN, _mxConstants[\"default\"].ALIGN_CENTER);\n      var dx = 0;\n      if (align == _mxConstants[\"default\"].ALIGN_CENTER) {\n        dx = 0.5;\n      } else if (align == _mxConstants[\"default\"].ALIGN_RIGHT) {\n        dx = 1;\n      }\n      if (dx != 0) {\n        state.absoluteOffset.x -= (lw * this.scale - state.width) * dx;\n      }\n    }\n  }\n  var v = _mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_VERTICAL_LABEL_POSITION, _mxConstants[\"default\"].ALIGN_MIDDLE);\n  if (v == _mxConstants[\"default\"].ALIGN_TOP) {\n    state.absoluteOffset.y -= state.height;\n  } else if (v == _mxConstants[\"default\"].ALIGN_BOTTOM) {\n    state.absoluteOffset.y += state.height;\n  }\n};\n\n/**\r\n * Function: resetValidationState\r\n *\r\n * Resets the current validation state.\r\n */\nmxGraphView.prototype.resetValidationState = function () {\n  this.lastNode = null;\n  this.lastHtmlNode = null;\n  this.lastForegroundNode = null;\n  this.lastForegroundHtmlNode = null;\n};\n\n/**\r\n * Function: stateValidated\r\n *\r\n * Invoked when a state has been processed in <validatePoints>. This is used\r\n * to update the order of the DOM nodes of the shape.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> that represents the cell state.\r\n */\nmxGraphView.prototype.stateValidated = function (state) {\n  var fg = this.graph.getModel().isEdge(state.cell) && this.graph.keepEdgesInForeground || this.graph.getModel().isVertex(state.cell) && this.graph.keepEdgesInBackground;\n  var htmlNode = fg ? this.lastForegroundHtmlNode || this.lastHtmlNode : this.lastHtmlNode;\n  var node = fg ? this.lastForegroundNode || this.lastNode : this.lastNode;\n  var result = this.graph.cellRenderer.insertStateAfter(state, node, htmlNode);\n  if (fg) {\n    this.lastForegroundHtmlNode = result[1];\n    this.lastForegroundNode = result[0];\n  } else {\n    this.lastHtmlNode = result[1];\n    this.lastNode = result[0];\n  }\n};\n\n/**\r\n * Function: updateFixedTerminalPoints\r\n *\r\n * Sets the initial absolute terminal points in the given state before the edge\r\n * style is computed.\r\n *\r\n * Parameters:\r\n *\r\n * edge - <mxCellState> whose initial terminal points should be updated.\r\n * source - <mxCellState> which represents the source terminal.\r\n * target - <mxCellState> which represents the target terminal.\r\n */\nmxGraphView.prototype.updateFixedTerminalPoints = function (edge, source, target) {\n  this.updateFixedTerminalPoint(edge, source, true, this.graph.getConnectionConstraint(edge, source, true));\n  this.updateFixedTerminalPoint(edge, target, false, this.graph.getConnectionConstraint(edge, target, false));\n};\n\n/**\r\n * Function: updateFixedTerminalPoint\r\n *\r\n * Sets the fixed source or target terminal point on the given edge.\r\n *\r\n * Parameters:\r\n *\r\n * edge - <mxCellState> whose terminal point should be updated.\r\n * terminal - <mxCellState> which represents the actual terminal.\r\n * source - Boolean that specifies if the terminal is the source.\r\n * constraint - <mxConnectionConstraint> that specifies the connection.\r\n */\nmxGraphView.prototype.updateFixedTerminalPoint = function (edge, terminal, source, constraint) {\n  edge.setAbsoluteTerminalPoint(this.getFixedTerminalPoint(edge, terminal, source, constraint), source);\n};\n\n/**\r\n * Function: getFixedTerminalPoint\r\n *\r\n * Returns the fixed source or target terminal point for the given edge.\r\n *\r\n * Parameters:\r\n *\r\n * edge - <mxCellState> whose terminal point should be returned.\r\n * terminal - <mxCellState> which represents the actual terminal.\r\n * source - Boolean that specifies if the terminal is the source.\r\n * constraint - <mxConnectionConstraint> that specifies the connection.\r\n */\nmxGraphView.prototype.getFixedTerminalPoint = function (edge, terminal, source, constraint) {\n  var pt = null;\n  if (constraint != null) {\n    pt = this.graph.getConnectionPoint(terminal, constraint);\n  }\n  if (pt == null && terminal == null) {\n    var s = this.scale;\n    var tr = this.translate;\n    var orig = edge.origin;\n    var geo = this.graph.getCellGeometry(edge.cell);\n    pt = geo.getTerminalPoint(source);\n    if (pt != null) {\n      pt = new _mxPoint[\"default\"](s * (tr.x + pt.x + orig.x), s * (tr.y + pt.y + orig.y));\n    }\n  }\n  return pt;\n};\n\n/**\r\n * Function: updateBoundsFromStencil\r\n *\r\n * Updates the bounds of the given cell state to reflect the bounds of the stencil\r\n * if it has a fixed aspect and returns the previous bounds as an <mxRectangle> if\r\n * the bounds have been modified or null otherwise.\r\n *\r\n * Parameters:\r\n *\r\n * edge - <mxCellState> whose bounds should be updated.\r\n */\nmxGraphView.prototype.updateBoundsFromStencil = function (state) {\n  var previous = null;\n  if (state != null && state.shape != null && state.shape.stencil != null && state.shape.stencil.aspect == 'fixed') {\n    previous = _mxRectangle[\"default\"].fromRectangle(state);\n    var asp = state.shape.stencil.computeAspect(state.style, state.x, state.y, state.width, state.height);\n    state.setRect(asp.x, asp.y, state.shape.stencil.w0 * asp.width, state.shape.stencil.h0 * asp.height);\n  }\n  return previous;\n};\n\n/**\r\n * Function: updatePoints\r\n *\r\n * Updates the absolute points in the given state using the specified array\r\n * of <mxPoints> as the relative points.\r\n *\r\n * Parameters:\r\n *\r\n * edge - <mxCellState> whose absolute points should be updated.\r\n * points - Array of <mxPoints> that constitute the relative points.\r\n * source - <mxCellState> that represents the source terminal.\r\n * target - <mxCellState> that represents the target terminal.\r\n */\nmxGraphView.prototype.updatePoints = function (edge, points, source, target) {\n  if (edge != null) {\n    var pts = [];\n    pts.push(edge.absolutePoints[0]);\n    var edgeStyle = this.getEdgeStyle(edge, points, source, target);\n    if (edgeStyle != null) {\n      var src = this.getTerminalPort(edge, source, true);\n      var trg = this.getTerminalPort(edge, target, false);\n\n      // Uses the stencil bounds for routing and restores after routing\n      var srcBounds = this.updateBoundsFromStencil(src);\n      var trgBounds = this.updateBoundsFromStencil(trg);\n      edgeStyle(edge, src, trg, points, pts);\n\n      // Restores previous bounds\n      if (srcBounds != null) {\n        src.setRect(srcBounds.x, srcBounds.y, srcBounds.width, srcBounds.height);\n      }\n      if (trgBounds != null) {\n        trg.setRect(trgBounds.x, trgBounds.y, trgBounds.width, trgBounds.height);\n      }\n    } else if (points != null) {\n      for (var i = 0; i < points.length; i++) {\n        if (points[i] != null) {\n          var pt = _mxGraphUtils[\"default\"].clone(points[i]);\n          pts.push(this.transformControlPoint(edge, pt));\n        }\n      }\n    }\n    var tmp = edge.absolutePoints;\n    pts.push(tmp[tmp.length - 1]);\n    edge.absolutePoints = pts;\n  }\n};\n\n/**\r\n * Function: transformControlPoint\r\n *\r\n * Transforms the given control point to an absolute point.\r\n */\nmxGraphView.prototype.transformControlPoint = function (state, pt) {\n  if (state != null && pt != null) {\n    var orig = state.origin;\n    return new _mxPoint[\"default\"](this.scale * (pt.x + this.translate.x + orig.x), this.scale * (pt.y + this.translate.y + orig.y));\n  }\n  return null;\n};\n\n/**\r\n * Function: isLoopStyleEnabled\r\n *\r\n * Returns true if the given edge should be routed with <mxGraph.defaultLoopStyle>\r\n * or the <mxConstants.STYLE_LOOP> defined for the given edge. This implementation\r\n * returns true if the given edge is a loop and does not\r\n */\nmxGraphView.prototype.isLoopStyleEnabled = function (edge, points, source, target) {\n  var sc = this.graph.getConnectionConstraint(edge, source, true);\n  var tc = this.graph.getConnectionConstraint(edge, target, false);\n  if (!_mxGraphUtils[\"default\"].getValue(edge.style, _mxConstants[\"default\"].STYLE_ORTHOGONAL_LOOP, false) || (sc == null || sc.point == null) && (tc == null || tc.point == null)) {\n    return source != null && source == target;\n  }\n  return false;\n};\n\n/**\r\n * Function: getEdgeStyle\r\n *\r\n * Returns the edge style function to be used to render the given edge state.\r\n */\nmxGraphView.prototype.getEdgeStyle = function (edge, points, source, target) {\n  var edgeStyle = this.isLoopStyleEnabled(edge, points, source, target) ? _mxGraphUtils[\"default\"].getValue(edge.style, _mxConstants[\"default\"].STYLE_LOOP, this.graph.defaultLoopStyle) : !_mxGraphUtils[\"default\"].getValue(edge.style, _mxConstants[\"default\"].STYLE_NOEDGESTYLE, false) ? edge.style[_mxConstants[\"default\"].STYLE_EDGE] : null;\n\n  // Converts string values to objects\n  if (typeof edgeStyle == \"string\") {\n    var tmp = _mxStyleRegistry[\"default\"].getValue(edgeStyle);\n    if (tmp == null && this.isAllowEval()) {\n      tmp = _mxUtils[\"default\"].eval(edgeStyle);\n    }\n    edgeStyle = tmp;\n  }\n  if (typeof edgeStyle == \"function\") {\n    return edgeStyle;\n  }\n  return null;\n};\n\n/**\r\n * Function: updateFloatingTerminalPoints\r\n *\r\n * Updates the terminal points in the given state after the edge style was\r\n * computed for the edge.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> whose terminal points should be updated.\r\n * source - <mxCellState> that represents the source terminal.\r\n * target - <mxCellState> that represents the target terminal.\r\n */\nmxGraphView.prototype.updateFloatingTerminalPoints = function (state, source, target) {\n  var pts = state.absolutePoints;\n  var p0 = pts[0];\n  var pe = pts[pts.length - 1];\n  if (pe == null && target != null) {\n    this.updateFloatingTerminalPoint(state, target, source, false);\n  }\n  if (p0 == null && source != null) {\n    this.updateFloatingTerminalPoint(state, source, target, true);\n  }\n};\n\n/**\r\n * Function: updateFloatingTerminalPoint\r\n *\r\n * Updates the absolute terminal point in the given state for the given\r\n * start and end state, where start is the source if source is true.\r\n *\r\n * Parameters:\r\n *\r\n * edge - <mxCellState> whose terminal point should be updated.\r\n * start - <mxCellState> for the terminal on \"this\" side of the edge.\r\n * end - <mxCellState> for the terminal on the other side of the edge.\r\n * source - Boolean indicating if start is the source terminal state.\r\n */\nmxGraphView.prototype.updateFloatingTerminalPoint = function (edge, start, end, source) {\n  edge.setAbsoluteTerminalPoint(this.getFloatingTerminalPoint(edge, start, end, source), source);\n};\n\n/**\r\n * Function: getFloatingTerminalPoint\r\n *\r\n * Returns the floating terminal point for the given edge, start and end\r\n * state, where start is the source if source is true.\r\n *\r\n * Parameters:\r\n *\r\n * edge - <mxCellState> whose terminal point should be returned.\r\n * start - <mxCellState> for the terminal on \"this\" side of the edge.\r\n * end - <mxCellState> for the terminal on the other side of the edge.\r\n * source - Boolean indicating if start is the source terminal state.\r\n */\nmxGraphView.prototype.getFloatingTerminalPoint = function (edge, start, end, source) {\n  start = this.getTerminalPort(edge, start, source);\n  var next = this.getNextPoint(edge, end, source);\n  var orth = this.graph.isOrthogonal(edge);\n  var alpha = _mxUtils[\"default\"].toRadians(Number(start.style[_mxConstants[\"default\"].STYLE_ROTATION] || '0'));\n  var center = new _mxPoint[\"default\"](start.getCenterX(), start.getCenterY());\n  if (alpha != 0) {\n    var cos = Math.cos(-alpha);\n    var sin = Math.sin(-alpha);\n    next = _mxUtils[\"default\"].getRotatedPoint(next, cos, sin, center);\n  }\n  var border = parseFloat(edge.style[_mxConstants[\"default\"].STYLE_PERIMETER_SPACING] || 0);\n  border += parseFloat(edge.style[source ? _mxConstants[\"default\"].STYLE_SOURCE_PERIMETER_SPACING : _mxConstants[\"default\"].STYLE_TARGET_PERIMETER_SPACING] || 0);\n  var pt = this.getPerimeterPoint(start, next, alpha == 0 && orth, border);\n  if (alpha != 0) {\n    var cos = Math.cos(alpha);\n    var sin = Math.sin(alpha);\n    pt = _mxUtils[\"default\"].getRotatedPoint(pt, cos, sin, center);\n  }\n  return pt;\n};\n\n/**\r\n * Function: getTerminalPort\r\n *\r\n * Returns an <mxCellState> that represents the source or target terminal or\r\n * port for the given edge.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> that represents the state of the edge.\r\n * terminal - <mxCellState> that represents the terminal.\r\n * source - Boolean indicating if the given terminal is the source terminal.\r\n */\nmxGraphView.prototype.getTerminalPort = function (state, terminal, source) {\n  var key = source ? _mxConstants[\"default\"].STYLE_SOURCE_PORT : _mxConstants[\"default\"].STYLE_TARGET_PORT;\n  var id = _mxGraphUtils[\"default\"].getValue(state.style, key);\n  if (id != null) {\n    var tmp = this.getState(this.graph.getModel().getCell(id));\n\n    // Only uses ports where a cell state exists\n    if (tmp != null) {\n      terminal = tmp;\n    }\n  }\n  return terminal;\n};\n\n/**\r\n * Function: getPerimeterPoint\r\n *\r\n * Returns an <mxPoint> that defines the location of the intersection point between\r\n * the perimeter and the line between the center of the shape and the given point.\r\n *\r\n * Parameters:\r\n *\r\n * terminal - <mxCellState> for the source or target terminal.\r\n * next - <mxPoint> that lies outside of the given terminal.\r\n * orthogonal - Boolean that specifies if the orthogonal projection onto\r\n * the perimeter should be returned. If this is false then the intersection\r\n * of the perimeter and the line between the next and the center point is\r\n * returned.\r\n * border - Optional border between the perimeter and the shape.\r\n */\nmxGraphView.prototype.getPerimeterPoint = function (terminal, next, orthogonal, border) {\n  var point = null;\n  if (terminal != null) {\n    var perimeter = this.getPerimeterFunction(terminal);\n    if (perimeter != null && next != null) {\n      var bounds = this.getPerimeterBounds(terminal, border);\n      if (bounds.width > 0 || bounds.height > 0) {\n        point = perimeter(bounds, terminal, next, orthogonal);\n      }\n    }\n    if (point == null) {\n      point = this.getPoint(terminal);\n    }\n  }\n  return point;\n};\n\n/**\r\n * Function: getRoutingCenterX\r\n *\r\n * Returns the x-coordinate of the center point for automatic routing.\r\n */\nmxGraphView.prototype.getRoutingCenterX = function (state) {\n  var f = state.style != null ? parseFloat(state.style[_mxConstants[\"default\"].STYLE_ROUTING_CENTER_X]) || 0 : 0;\n  return state.getCenterX() + f * state.width;\n};\n\n/**\r\n * Function: getRoutingCenterY\r\n *\r\n * Returns the y-coordinate of the center point for automatic routing.\r\n */\nmxGraphView.prototype.getRoutingCenterY = function (state) {\n  var f = state.style != null ? parseFloat(state.style[_mxConstants[\"default\"].STYLE_ROUTING_CENTER_Y]) || 0 : 0;\n  return state.getCenterY() + f * state.height;\n};\n\n/**\r\n * Function: getPerimeterBounds\r\n *\r\n * Returns the perimeter bounds for the given terminal, edge pair as an\r\n * <mxRectangle>.\r\n *\r\n * If you have a model where each terminal has a relative child that should\r\n * act as the graphical endpoint for a connection from/to the terminal, then\r\n * this method can be replaced as follows:\r\n *\r\n * (code)\r\n * var oldGetPerimeterBounds = mxGraphView.prototype.getPerimeterBounds;\r\n * mxGraphView.prototype.getPerimeterBounds = function(terminal, edge, isSource)\r\n * {\r\n *   var model = this.graph.getModel();\r\n *   var childCount = model.getChildCount(terminal.cell);\r\n *\r\n *   if (childCount > 0)\r\n *   {\r\n *     var child = model.getChildAt(terminal.cell, 0);\r\n *     var geo = model.getGeometry(child);\r\n *\r\n *     if (geo != null &&\r\n *         geo.relative)\r\n *     {\r\n *       var state = this.getState(child);\r\n *\r\n *       if (state != null)\r\n *       {\r\n *         terminal = state;\r\n *       }\r\n *     }\r\n *   }\r\n *\r\n *   return oldGetPerimeterBounds.apply(this, arguments);\r\n * };\r\n * (end)\r\n *\r\n * Parameters:\r\n *\r\n * terminal - <mxCellState> that represents the terminal.\r\n * border - Number that adds a border between the shape and the perimeter.\r\n */\nmxGraphView.prototype.getPerimeterBounds = function (terminal, border) {\n  border = border != null ? border : 0;\n  if (terminal != null) {\n    border += parseFloat(terminal.style[_mxConstants[\"default\"].STYLE_PERIMETER_SPACING] || 0);\n  }\n  return terminal && terminal.getPerimeterBounds(border * this.scale);\n};\n\n/**\r\n * Function: getPerimeterFunction\r\n *\r\n * Returns the perimeter function for the given state.\r\n */\nmxGraphView.prototype.getPerimeterFunction = function (state) {\n  var perimeter = state.style[_mxConstants[\"default\"].STYLE_PERIMETER];\n\n  // Converts string values to objects\n  if (typeof perimeter == \"string\") {\n    var tmp = _mxStyleRegistry[\"default\"].getValue(perimeter);\n    if (tmp == null && this.isAllowEval()) {\n      tmp = _mxUtils[\"default\"].eval(perimeter);\n    }\n    perimeter = tmp;\n  }\n  if (typeof perimeter == \"function\") {\n    return perimeter;\n  }\n  return null;\n};\n\n/**\r\n * Function: getNextPoint\r\n *\r\n * Returns the nearest point in the list of absolute points or the center\r\n * of the opposite terminal.\r\n *\r\n * Parameters:\r\n *\r\n * edge - <mxCellState> that represents the edge.\r\n * opposite - <mxCellState> that represents the opposite terminal.\r\n * source - Boolean indicating if the next point for the source or target\r\n * should be returned.\r\n */\nmxGraphView.prototype.getNextPoint = function (edge, opposite, source) {\n  var pts = edge.absolutePoints;\n  var point = null;\n  if (pts != null && pts.length >= 2) {\n    var count = pts.length;\n    point = pts[source ? Math.min(1, count - 1) : Math.max(0, count - 2)];\n  }\n  if (point == null && opposite != null) {\n    point = new _mxPoint[\"default\"](opposite.getCenterX(), opposite.getCenterY());\n  }\n  return point;\n};\n\n/**\r\n * Function: getVisibleTerminal\r\n *\r\n * Returns the nearest ancestor terminal that is visible. The edge appears\r\n * to be connected to this terminal on the display. The result of this method\r\n * is cached in <mxCellState.getVisibleTerminalState>.\r\n *\r\n * Parameters:\r\n *\r\n * edge - <mxCell> whose visible terminal should be returned.\r\n * source - Boolean that specifies if the source or target terminal\r\n * should be returned.\r\n */\nmxGraphView.prototype.getVisibleTerminal = function (edge, source) {\n  var model = this.graph.getModel();\n  var result = model.getTerminal(edge, source);\n  var best = result;\n  while (result != null && result != this.currentRoot) {\n    if (!this.graph.isCellVisible(best) || this.isCellCollapsed(result)) {\n      best = result;\n    }\n    result = model.getParent(result);\n  }\n\n  // Checks if the result is not a layer\n  if (model.getParent(best) == model.getRoot()) {\n    best = null;\n  }\n  return best;\n};\n\n/**\r\n * Function: updateEdgeBounds\r\n *\r\n * Updates the given state using the bounding box of t\r\n * he absolute points.\r\n * Also updates <mxCellState.terminalDistance>, <mxCellState.length> and\r\n * <mxCellState.segments>.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> whose bounds should be updated.\r\n */\nmxGraphView.prototype.updateEdgeBounds = function (state) {\n  var points = state.absolutePoints;\n  var p0 = points[0];\n  var pe = points[points.length - 1];\n  if (p0.x != pe.x || p0.y != pe.y) {\n    var dx = pe.x - p0.x;\n    var dy = pe.y - p0.y;\n    state.terminalDistance = Math.sqrt(dx * dx + dy * dy);\n  } else {\n    state.terminalDistance = 0;\n  }\n  var length = 0;\n  var segments = [];\n  var pt = p0;\n  if (pt != null) {\n    var minX = pt.x;\n    var minY = pt.y;\n    var maxX = minX;\n    var maxY = minY;\n    for (var i = 1; i < points.length; i++) {\n      var tmp = points[i];\n      if (tmp != null) {\n        var dx = pt.x - tmp.x;\n        var dy = pt.y - tmp.y;\n        var segment = Math.sqrt(dx * dx + dy * dy);\n        segments.push(segment);\n        length += segment;\n        pt = tmp;\n        minX = Math.min(pt.x, minX);\n        minY = Math.min(pt.y, minY);\n        maxX = Math.max(pt.x, maxX);\n        maxY = Math.max(pt.y, maxY);\n      }\n    }\n    state.length = length;\n    state.segments = segments;\n    var markerSize = 1; // TODO: include marker size\n\n    state.x = minX;\n    state.y = minY;\n    state.width = Math.max(markerSize, maxX - minX);\n    state.height = Math.max(markerSize, maxY - minY);\n  }\n};\n\n/**\r\n * Function: getPoint\r\n *\r\n * Returns the absolute point on the edge for the given relative\r\n * <mxGeometry> as an <mxPoint>. The edge is represented by the given\r\n * <mxCellState>.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> that represents the state of the parent edge.\r\n * geometry - <mxGeometry> that represents the relative location.\r\n */\nmxGraphView.prototype.getPoint = function (state, geometry) {\n  var x = state.getCenterX();\n  var y = state.getCenterY();\n  if (state.segments != null && (geometry == null || geometry.relative)) {\n    var gx = geometry != null ? geometry.x / 2 : 0;\n    var pointCount = state.absolutePoints.length;\n    var dist = Math.round((gx + 0.5) * state.length);\n    var segment = state.segments[0];\n    var length = 0;\n    var index = 1;\n    while (dist >= Math.round(length + segment) && index < pointCount - 1) {\n      length += segment;\n      segment = state.segments[index++];\n    }\n    var factor = segment == 0 ? 0 : (dist - length) / segment;\n    var p0 = state.absolutePoints[index - 1];\n    var pe = state.absolutePoints[index];\n    if (p0 != null && pe != null) {\n      var gy = 0;\n      var offsetX = 0;\n      var offsetY = 0;\n      if (geometry != null) {\n        gy = geometry.y;\n        var offset = geometry.offset;\n        if (offset != null) {\n          offsetX = offset.x;\n          offsetY = offset.y;\n        }\n      }\n      var dx = pe.x - p0.x;\n      var dy = pe.y - p0.y;\n      var nx = segment == 0 ? 0 : dy / segment;\n      var ny = segment == 0 ? 0 : dx / segment;\n      x = p0.x + dx * factor + (nx * gy + offsetX) * this.scale;\n      y = p0.y + dy * factor - (ny * gy - offsetY) * this.scale;\n    }\n  } else if (geometry != null) {\n    var offset = geometry.offset;\n    if (offset != null) {\n      x += offset.x;\n      y += offset.y;\n    }\n  }\n  return new _mxPoint[\"default\"](x, y);\n};\n\n/**\r\n * Function: getRelativePoint\r\n *\r\n * Gets the relative point that describes the given, absolute label\r\n * position for the given edge state.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> that represents the state of the parent edge.\r\n * x - Specifies the x-coordinate of the absolute label location.\r\n * y - Specifies the y-coordinate of the absolute label location.\r\n */\nmxGraphView.prototype.getRelativePoint = function (edgeState, x, y) {\n  var model = this.graph.getModel();\n  var geometry = model.getGeometry(edgeState.cell);\n  if (geometry != null) {\n    var pointCount = edgeState.absolutePoints.length;\n    if (geometry.relative && pointCount > 1) {\n      var totalLength = edgeState.length;\n      var segments = edgeState.segments;\n\n      // Works which line segment the point of the label is closest to\n      var p0 = edgeState.absolutePoints[0];\n      var pe = edgeState.absolutePoints[1];\n      var minDist = _mxUtils[\"default\"].ptSegDistSq(p0.x, p0.y, pe.x, pe.y, x, y);\n      var index = 0;\n      var tmp = 0;\n      var length = 0;\n      for (var i = 2; i < pointCount; i++) {\n        tmp += segments[i - 2];\n        pe = edgeState.absolutePoints[i];\n        var dist = _mxUtils[\"default\"].ptSegDistSq(p0.x, p0.y, pe.x, pe.y, x, y);\n        if (dist <= minDist) {\n          minDist = dist;\n          index = i - 1;\n          length = tmp;\n        }\n        p0 = pe;\n      }\n      var seg = segments[index];\n      p0 = edgeState.absolutePoints[index];\n      pe = edgeState.absolutePoints[index + 1];\n      var x2 = p0.x;\n      var y2 = p0.y;\n      var x1 = pe.x;\n      var y1 = pe.y;\n      var px = x;\n      var py = y;\n      var xSegment = x2 - x1;\n      var ySegment = y2 - y1;\n      px -= x1;\n      py -= y1;\n      var projlenSq = 0;\n      px = xSegment - px;\n      py = ySegment - py;\n      var dotprod = px * xSegment + py * ySegment;\n      if (dotprod <= 0.0) {\n        projlenSq = 0;\n      } else {\n        projlenSq = dotprod * dotprod / (xSegment * xSegment + ySegment * ySegment);\n      }\n      var projlen = Math.sqrt(projlenSq);\n      if (projlen > seg) {\n        projlen = seg;\n      }\n      var yDistance = Math.sqrt(_mxUtils[\"default\"].ptSegDistSq(p0.x, p0.y, pe.x, pe.y, x, y));\n      var direction = _mxUtils[\"default\"].relativeCcw(p0.x, p0.y, pe.x, pe.y, x, y);\n      if (direction == -1) {\n        yDistance = -yDistance;\n      }\n\n      // Constructs the relative point for the label\n      return new _mxPoint[\"default\"]((totalLength / 2 - length - projlen) / totalLength * -2, yDistance / this.scale);\n    }\n  }\n  return new _mxPoint[\"default\"]();\n};\n\n/**\r\n * Function: updateEdgeLabelOffset\r\n *\r\n * Updates <mxCellState.absoluteOffset> for the given state. The absolute\r\n * offset is normally used for the position of the edge label. Is is\r\n * calculated from the geometry as an absolute offset from the center\r\n * between the two endpoints if the geometry is absolute, or as the\r\n * relative distance between the center along the line and the absolute\r\n * orthogonal distance if the geometry is relative.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> whose absolute offset should be updated.\r\n */\nmxGraphView.prototype.updateEdgeLabelOffset = function (state) {\n  var points = state.absolutePoints;\n  state.absoluteOffset.x = state.getCenterX();\n  state.absoluteOffset.y = state.getCenterY();\n  if (points != null && points.length > 0 && state.segments != null) {\n    var geometry = this.graph.getCellGeometry(state.cell);\n    if (geometry.relative) {\n      var offset = this.getPoint(state, geometry);\n      if (offset != null) {\n        state.absoluteOffset = offset;\n      }\n    } else {\n      var p0 = points[0];\n      var pe = points[points.length - 1];\n      if (p0 != null && pe != null) {\n        var dx = pe.x - p0.x;\n        var dy = pe.y - p0.y;\n        var x0 = 0;\n        var y0 = 0;\n        var off = geometry.offset;\n        if (off != null) {\n          x0 = off.x;\n          y0 = off.y;\n        }\n        var x = p0.x + dx / 2 + x0 * this.scale;\n        var y = p0.y + dy / 2 + y0 * this.scale;\n        state.absoluteOffset.x = x;\n        state.absoluteOffset.y = y;\n      }\n    }\n  }\n};\n\n/**\r\n * Function: getState\r\n *\r\n * Returns the <mxCellState> for the given cell. If create is true, then\r\n * the state is created if it does not yet exist.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> for which the <mxCellState> should be returned.\r\n * create - Optional boolean indicating if a new state should be created\r\n * if it does not yet exist. Default is false.\r\n */\nmxGraphView.prototype.getState = function (cell, create) {\n  create = create || false;\n  var state = null;\n  if (cell != null) {\n    state = this.states.get(cell);\n    if (create && (state == null || this.updateStyle) && this.graph.isCellVisible(cell)) {\n      if (state == null) {\n        state = this.createState(cell);\n        this.states.put(cell, state);\n      } else {\n        state.style = this.graph.getCellStyle(cell);\n      }\n    }\n  }\n  return state;\n};\n\n/**\r\n * Function: isRendering\r\n *\r\n * Returns <rendering>.\r\n */\nmxGraphView.prototype.isRendering = function () {\n  return this.rendering;\n};\n\n/**\r\n * Function: setRendering\r\n *\r\n * Sets <rendering>.\r\n */\nmxGraphView.prototype.setRendering = function (value) {\n  this.rendering = value;\n};\n\n/**\r\n * Function: isAllowEval\r\n *\r\n * Returns <allowEval>.\r\n */\nmxGraphView.prototype.isAllowEval = function () {\n  return this.allowEval;\n};\n\n/**\r\n * Function: setAllowEval\r\n *\r\n * Sets <allowEval>.\r\n */\nmxGraphView.prototype.setAllowEval = function (value) {\n  this.allowEval = value;\n};\n\n/**\r\n * Function: getStates\r\n *\r\n * Returns <states>.\r\n */\nmxGraphView.prototype.getStates = function () {\n  return this.states;\n};\n\n/**\r\n * Function: setStates\r\n *\r\n * Sets <states>.\r\n */\nmxGraphView.prototype.setStates = function (value) {\n  this.states = value;\n};\n\n/**\r\n * Function: getCellStates\r\n *\r\n * Returns the <mxCellStates> for the given array of <mxCells>. The array\r\n * contains all states that are not null, that is, the returned array may\r\n * have less elements than the given array. If no argument is given, then\r\n * this returns <states>.\r\n */\nmxGraphView.prototype.getCellStates = function (cells) {\n  if (cells == null) {\n    return this.states;\n  } else {\n    var result = [];\n    for (var i = 0; i < cells.length; i++) {\n      var state = this.getState(cells[i]);\n      if (state != null) {\n        result.push(state);\n      }\n    }\n    return result;\n  }\n};\n\n/**\r\n * Function: removeState\r\n *\r\n * Removes and returns the <mxCellState> for the given cell.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> for which the <mxCellState> should be removed.\r\n */\nmxGraphView.prototype.removeState = function (cell) {\n  var state = null;\n  if (cell != null) {\n    state = this.states.remove(cell);\n    if (state != null) {\n      this.graph.cellRenderer.destroy(state);\n      state.invalid = true;\n      state.destroy();\n    }\n  }\n  return state;\n};\n\n/**\r\n * Function: createState\r\n *\r\n * Creates and returns an <mxCellState> for the given cell and initializes\r\n * it using <mxCellRenderer.initialize>.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> for which a new <mxCellState> should be created.\r\n */\nmxGraphView.prototype.createState = function (cell) {\n  return new _mxCellState[\"default\"](this, cell, this.graph.getCellStyle(cell));\n};\n\n/**\r\n * Function: getCanvas\r\n *\r\n * Returns the DOM node that contains the background-, draw- and\r\n * overlay- and decoratorpanes.\r\n */\nmxGraphView.prototype.getCanvas = function () {\n  return this.canvas;\n};\n\n/**\r\n * Function: getBackgroundPane\r\n *\r\n * Returns the DOM node that represents the background layer.\r\n */\nmxGraphView.prototype.getBackgroundPane = function () {\n  return this.backgroundPane;\n};\n\n/**\r\n * Function: getDrawPane\r\n *\r\n * Returns the DOM node that represents the main drawing layer.\r\n */\nmxGraphView.prototype.getDrawPane = function () {\n  return this.drawPane;\n};\n\n/**\r\n * Function: getOverlayPane\r\n *\r\n * Returns the DOM node that represents the layer above the drawing layer.\r\n */\nmxGraphView.prototype.getOverlayPane = function () {\n  return this.overlayPane;\n};\n\n/**\r\n * Function: getDecoratorPane\r\n *\r\n * Returns the DOM node that represents the topmost drawing layer.\r\n */\nmxGraphView.prototype.getDecoratorPane = function () {\n  return this.decoratorPane;\n};\n\n/**\r\n * Function: isContainerEvent\r\n *\r\n * Returns true if the event origin is one of the drawing panes or\r\n * containers of the view.\r\n */\nmxGraphView.prototype.isContainerEvent = function (evt) {\n  var source = _mxEvent[\"default\"].getSource(evt);\n  return source == this.graph.container || source.parentNode == this.backgroundPane || source.parentNode != null && source.parentNode.parentNode == this.backgroundPane || source == this.canvas.parentNode || source == this.canvas || source == this.backgroundPane || source == this.drawPane || source == this.overlayPane || source == this.decoratorPane;\n};\n\n/**\r\n * Function: isScrollEvent\r\n *\r\n * Returns true if the event origin is one of the scrollbars of the\r\n * container in IE. Such events are ignored.\r\n */\nmxGraphView.prototype.isScrollEvent = function (evt) {\n  var offset = _mxUtils[\"default\"].getOffset(this.graph.container);\n  var pt = new _mxPoint[\"default\"](evt.clientX - offset.x, evt.clientY - offset.y);\n  var outWidth = this.graph.container.offsetWidth;\n  var inWidth = this.graph.container.clientWidth;\n  if (outWidth > inWidth && pt.x > inWidth + 2 && pt.x <= outWidth) {\n    return true;\n  }\n  var outHeight = this.graph.container.offsetHeight;\n  var inHeight = this.graph.container.clientHeight;\n  if (outHeight > inHeight && pt.y > inHeight + 2 && pt.y <= outHeight) {\n    return true;\n  }\n  return false;\n};\n\n/**\r\n * Function: init\r\n *\r\n * Initializes the graph event dispatch loop for the specified container\r\n * and invokes <create> to create the required DOM nodes for the display.\r\n */\nmxGraphView.prototype.init = function () {\n  this.installListeners();\n\n  // Creates the DOM nodes for the respective display dialect\n  var graph = this.graph;\n  if (graph.dialect == _mxConstants[\"default\"].DIALECT_SVG) {\n    this.createSvg();\n  } else if (graph.dialect == _mxConstants[\"default\"].DIALECT_VML) {\n    this.createVml();\n  } else {\n    this.createHtml();\n  }\n};\n\n/**\r\n * Function: installListeners\r\n *\r\n * Installs the required listeners in the container.\r\n */\nmxGraphView.prototype.installListeners = function () {\n  var graph = this.graph;\n  var container = graph.container;\n  if (container != null) {\n    // Support for touch device gestures (eg. pinch to zoom)\n    // Double-tap handling is implemented in mxGraph.fireMouseEvent\n    if (_mxClient[\"default\"].IS_TOUCH) {\n      _mxEvent[\"default\"].addListener(container, 'gesturestart', _mxGraphUtils[\"default\"].bind(this, function (evt) {\n        graph.fireGestureEvent(evt);\n        _mxEvent[\"default\"].consume(evt);\n      }));\n      _mxEvent[\"default\"].addListener(container, 'gesturechange', _mxGraphUtils[\"default\"].bind(this, function (evt) {\n        graph.fireGestureEvent(evt);\n        _mxEvent[\"default\"].consume(evt);\n      }));\n      _mxEvent[\"default\"].addListener(container, 'gestureend', _mxGraphUtils[\"default\"].bind(this, function (evt) {\n        graph.fireGestureEvent(evt);\n        _mxEvent[\"default\"].consume(evt);\n      }));\n    }\n\n    // Adds basic listeners for graph event dispatching\n    _mxEvent[\"default\"].addGestureListeners(container, _mxGraphUtils[\"default\"].bind(this, function (evt) {\n      // Condition to avoid scrollbar events starting a rubberband selection\n      if (this.isContainerEvent(evt) && (!_mxClient[\"default\"].IS_IE && !_mxClient[\"default\"].IS_IE11 && !_mxClient[\"default\"].IS_GC && !_mxClient[\"default\"].IS_OP && !_mxClient[\"default\"].IS_SF || !this.isScrollEvent(evt))) {\n        graph.fireMouseEvent(_mxEvent[\"default\"].MOUSE_DOWN, new _mxMouseEvent[\"default\"](evt));\n      }\n    }), _mxGraphUtils[\"default\"].bind(this, function (evt) {\n      if (this.isContainerEvent(evt)) {\n        graph.fireMouseEvent(_mxEvent[\"default\"].MOUSE_MOVE, new _mxMouseEvent[\"default\"](evt));\n      }\n    }), _mxGraphUtils[\"default\"].bind(this, function (evt) {\n      if (this.isContainerEvent(evt)) {\n        graph.fireMouseEvent(_mxEvent[\"default\"].MOUSE_UP, new _mxMouseEvent[\"default\"](evt));\n      }\n    }));\n\n    // Adds listener for double click handling on background, this does always\n    // use native event handler, we assume that the DOM of the background\n    // does not change during the double click\n    _mxEvent[\"default\"].addListener(container, 'dblclick', _mxGraphUtils[\"default\"].bind(this, function (evt) {\n      if (this.isContainerEvent(evt)) {\n        graph.dblClick(evt);\n      }\n    }));\n\n    // Workaround for touch events which started on some DOM node\n    // on top of the container, in which case the cells under the\n    // mouse for the move and up events are not detected.\n    var getState = function getState(evt) {\n      var state = null;\n\n      // Workaround for touch events which started on some DOM node\n      // on top of the container, in which case the cells under the\n      // mouse for the move and up events are not detected.\n      if (_mxClient[\"default\"].IS_TOUCH) {\n        var x = _mxEvent[\"default\"].getClientX(evt);\n        var y = _mxEvent[\"default\"].getClientY(evt);\n\n        // Dispatches the drop event to the graph which\n        // consumes and executes the source function\n        var pt = _mxUtils[\"default\"].convertPoint(container, x, y);\n        state = graph.view.getState(graph.getCellAt(pt.x, pt.y));\n      }\n      return state;\n    };\n\n    // Adds basic listeners for graph event dispatching outside of the\n    // container and finishing the handling of a single gesture\n    // Implemented via graph event dispatch loop to avoid duplicate events\n    // in Firefox and Chrome\n    graph.addMouseListener({\n      mouseDown: function mouseDown(sender, me) {\n        graph.popupMenuHandler.hideMenu();\n      },\n      mouseMove: function mouseMove() {},\n      mouseUp: function mouseUp() {}\n    });\n    this.moveHandler = _mxGraphUtils[\"default\"].bind(this, function (evt) {\n      // Hides the tooltip if mouse is outside container\n      if (graph.tooltipHandler != null && graph.tooltipHandler.isHideOnHover()) {\n        graph.tooltipHandler.hide();\n      }\n      if (this.captureDocumentGesture && graph.isMouseDown && graph.container != null && !this.isContainerEvent(evt) && graph.container.style.display != 'none' && graph.container.style.visibility != 'hidden' && !_mxEvent[\"default\"].isConsumed(evt)) {\n        graph.fireMouseEvent(_mxEvent[\"default\"].MOUSE_MOVE, new _mxMouseEvent[\"default\"](evt, getState(evt)));\n      }\n    });\n    this.endHandler = _mxGraphUtils[\"default\"].bind(this, function (evt) {\n      if (this.captureDocumentGesture && graph.isMouseDown && graph.container != null && !this.isContainerEvent(evt) && graph.container.style.display != 'none' && graph.container.style.visibility != 'hidden') {\n        graph.fireMouseEvent(_mxEvent[\"default\"].MOUSE_UP, new _mxMouseEvent[\"default\"](evt));\n      }\n    });\n    _mxEvent[\"default\"].addGestureListeners(document, null, this.moveHandler, this.endHandler);\n  }\n};\n\n/**\r\n * Function: create\r\n *\r\n * Creates the DOM nodes for the HTML display.\r\n */\nmxGraphView.prototype.createHtml = function () {\n  var container = this.graph.container;\n  if (container != null) {\n    this.canvas = this.createHtmlPane('100%', '100%');\n\n    // Uses minimal size for inner DIVs on Canvas. This is required\n    // for correct event processing in IE. If we have an overlapping\n    // DIV then the events on the cells are only fired for labels.\n    this.backgroundPane = this.createHtmlPane('1px', '1px');\n    this.drawPane = this.createHtmlPane('1px', '1px');\n    this.overlayPane = this.createHtmlPane('1px', '1px');\n    this.decoratorPane = this.createHtmlPane('1px', '1px');\n    this.canvas.appendChild(this.backgroundPane);\n    this.canvas.appendChild(this.drawPane);\n    this.canvas.appendChild(this.overlayPane);\n    this.canvas.appendChild(this.decoratorPane);\n    container.appendChild(this.canvas);\n    this.updateContainerStyle(container);\n\n    // Implements minWidth/minHeight in quirks mode\n    if (_mxClient[\"default\"].IS_QUIRKS) {\n      var onResize = _mxGraphUtils[\"default\"].bind(this, function (evt) {\n        var bounds = this.getGraphBounds();\n        var width = bounds.x + bounds.width + this.graph.border;\n        var height = bounds.y + bounds.height + this.graph.border;\n        this.updateHtmlCanvasSize(width, height);\n      });\n      _mxEvent[\"default\"].addListener(window, 'resize', onResize);\n    }\n  }\n};\n\n/**\r\n * Function: updateHtmlCanvasSize\r\n *\r\n * Updates the size of the HTML canvas.\r\n */\nmxGraphView.prototype.updateHtmlCanvasSize = function (width, height) {\n  if (this.graph.container != null) {\n    var ow = this.graph.container.offsetWidth;\n    var oh = this.graph.container.offsetHeight;\n    if (ow < width) {\n      this.canvas.style.width = width + 'px';\n    } else {\n      this.canvas.style.width = '100%';\n    }\n    if (oh < height) {\n      this.canvas.style.height = height + 'px';\n    } else {\n      this.canvas.style.height = '100%';\n    }\n  }\n};\n\n/**\r\n * Function: createHtmlPane\r\n *\r\n * Creates and returns a drawing pane in HTML (DIV).\r\n */\nmxGraphView.prototype.createHtmlPane = function (width, height) {\n  var pane = document.createElement('DIV');\n  if (width != null && height != null) {\n    pane.style.position = 'absolute';\n    pane.style.left = '0px';\n    pane.style.top = '0px';\n    pane.style.width = width;\n    pane.style.height = height;\n  } else {\n    pane.style.position = 'relative';\n  }\n  return pane;\n};\n\n/**\r\n * Function: create\r\n *\r\n * Creates the DOM nodes for the VML display.\r\n */\nmxGraphView.prototype.createVml = function () {\n  var container = this.graph.container;\n  if (container != null) {\n    var width = container.offsetWidth;\n    var height = container.offsetHeight;\n    this.canvas = this.createVmlPane(width, height);\n    this.backgroundPane = this.createVmlPane(width, height);\n    this.drawPane = this.createVmlPane(width, height);\n    this.overlayPane = this.createVmlPane(width, height);\n    this.decoratorPane = this.createVmlPane(width, height);\n    this.canvas.appendChild(this.backgroundPane);\n    this.canvas.appendChild(this.drawPane);\n    this.canvas.appendChild(this.overlayPane);\n    this.canvas.appendChild(this.decoratorPane);\n    container.appendChild(this.canvas);\n  }\n};\n\n/**\r\n * Function: createVmlPane\r\n *\r\n * Creates a drawing pane in VML (group).\r\n */\nmxGraphView.prototype.createVmlPane = function (width, height) {\n  var pane = document.createElement(_mxClient[\"default\"].VML_PREFIX + ':group');\n\n  // At this point the width and height are potentially\n  // uninitialized. That's OK.\n  pane.style.position = 'absolute';\n  pane.style.left = '0px';\n  pane.style.top = '0px';\n  pane.style.width = width + 'px';\n  pane.style.height = height + 'px';\n  pane.setAttribute('coordsize', width + ',' + height);\n  pane.setAttribute('coordorigin', '0,0');\n  return pane;\n};\n\n/**\r\n * Function: create\r\n *\r\n * Creates and returns the DOM nodes for the SVG display.\r\n */\nmxGraphView.prototype.createSvg = function () {\n  var container = this.graph.container;\n  this.canvas = document.createElementNS(_mxConstants[\"default\"].NS_SVG, 'g');\n\n  // For background image\n  this.backgroundPane = document.createElementNS(_mxConstants[\"default\"].NS_SVG, 'g');\n  this.canvas.appendChild(this.backgroundPane);\n\n  // Adds two layers (background is early feature)\n  this.drawPane = document.createElementNS(_mxConstants[\"default\"].NS_SVG, 'g');\n  if (container.id === \"diagram\") {\n    this.drawPane.setAttribute('id', 'drawPane');\n  }\n  this.canvas.appendChild(this.drawPane);\n  this.overlayPane = document.createElementNS(_mxConstants[\"default\"].NS_SVG, 'g');\n  this.canvas.appendChild(this.overlayPane);\n  this.decoratorPane = document.createElementNS(_mxConstants[\"default\"].NS_SVG, 'g');\n  this.canvas.appendChild(this.decoratorPane);\n  var root = document.createElementNS(_mxConstants[\"default\"].NS_SVG, 'svg');\n  root.style.width = '100%';\n  root.style.height = '100%';\n\n  // NOTE: In standards mode, the SVG must have block layout\n  // in order for the container DIV to not show scrollbars.\n  root.style.display = 'block';\n\n  //svg中的defs中的元素统一放到一个svg中\n  var defSvg = document.querySelector('svg.defs');\n  if (!defSvg) {\n    defSvg = document.createElementNS(_mxConstants[\"default\"].NS_SVG, 'svg');\n    defSvg.setAttribute('class', 'defs');\n    defSvg.setAttribute('style', 'width: 0; height: 0; position: absolute;');\n    defSvg.appendChild(document.createElementNS(_mxConstants[\"default\"].NS_SVG, 'defs'));\n    document.body.appendChild(defSvg);\n  }\n  //var defs = document.createElementNS(mxConstants.NS_SVG, 'defs');\n  //root.appendChild(defs);\n\n  root.appendChild(this.canvas);\n  if (container != null) {\n    container.appendChild(root);\n    this.updateContainerStyle(container);\n  }\n};\n\n/**\r\n * Function: updateContainerStyle\r\n *\r\n * Updates the style of the container after installing the SVG DOM elements.\r\n */\nmxGraphView.prototype.updateContainerStyle = function (container) {\n  // Workaround for offset of container\n  var style = _mxGraphUtils[\"default\"].getCurrentStyle(container);\n  if (style != null && style.position == 'static') {\n    container.style.position = 'relative';\n  }\n\n  // Disables built-in pan and zoom in IE10 and later\n  if (_mxClient[\"default\"].IS_POINTER) {\n    container.style.touchAction = 'none';\n  }\n};\n\n/**\r\n * Function: destroy\r\n *\r\n * Destroys the view and all its resources.\r\n */\nmxGraphView.prototype.destroy = function () {\n  var root = this.canvas != null ? this.canvas.ownerSVGElement : null;\n  if (root == null) {\n    root = this.canvas;\n  }\n  if (root != null && root.parentNode != null) {\n    this.clear(this.currentRoot, true);\n    _mxEvent[\"default\"].removeGestureListeners(document, null, this.moveHandler, this.endHandler);\n    _mxEvent[\"default\"].release(this.graph.container);\n    root.parentNode.removeChild(root);\n    this.moveHandler = null;\n    this.endHandler = null;\n    this.canvas = null;\n    this.backgroundPane = null;\n    this.drawPane = null;\n    this.overlayPane = null;\n    this.decoratorPane = null;\n  }\n};\nmxGraphView.getName = function () {\n  return 'mxGraphView';\n};\n/**\r\n * Class: mxCurrentRootChange\r\n *\r\n * Action to change the current root in a view.\r\n *\r\n * Constructor: mxCurrentRootChange\r\n *\r\n * Constructs a change of the current root in the given view.\r\n */\nvar _default = exports[\"default\"] = mxGraphView;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxGraphView.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxGuide.js":
/*!******************************************!*\
  !*** ./src/workflow/mxClient/mxGuide.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _mxPolyline = _interopRequireDefault(__webpack_require__(/*! ./mxPolyline.js */ \"./src/workflow/mxClient/mxPolyline.js\"));\nvar _mxPoint = _interopRequireDefault(__webpack_require__(/*! ./mxPoint.js */ \"./src/workflow/mxClient/mxPoint.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ./mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxGuide(graph, states) {\n  this.graph = graph;\n  this.setStates(states);\n}\n;\n\n/**\r\n * Variable: graph\r\n *\r\n * Reference to the enclosing <mxGraph> instance.\r\n */\nmxGuide.prototype.graph = null;\n\n/**\r\n * Variable: states\r\n *\r\n * Contains the <mxCellStates> that are used for alignment.\r\n */\nmxGuide.prototype.states = null;\n\n/**\r\n * Variable: horizontal\r\n *\r\n * Specifies if horizontal guides are enabled. Default is true.\r\n */\nmxGuide.prototype.horizontal = true;\n\n/**\r\n * Variable: vertical\r\n *\r\n * Specifies if vertical guides are enabled. Default is true.\r\n */\nmxGuide.prototype.vertical = true;\n\n/**\r\n * Variable: vertical\r\n *\r\n * Holds the <mxShape> for the horizontal guide.\r\n */\nmxGuide.prototype.guideX = null;\n\n/**\r\n * Variable: vertical\r\n *\r\n * Holds the <mxShape> for the vertical guide.\r\n */\nmxGuide.prototype.guideY = null;\n\n/**\r\n * Function: setStates\r\n *\r\n * Sets the <mxCellStates> that should be used for alignment.\r\n */\nmxGuide.prototype.setStates = function (states) {\n  this.states = states;\n};\n\n/**\r\n * Function: isEnabledForEvent\r\n *\r\n * Returns true if the guide should be enabled for the given native event. This\r\n * implementation always returns true.\r\n */\nmxGuide.prototype.isEnabledForEvent = function (evt) {\n  return true;\n};\n\n/**\r\n * Function: getGuideTolerance\r\n *\r\n * Returns the tolerance for the guides. Default value is gridSize / 2.\r\n */\nmxGuide.prototype.getGuideTolerance = function () {\n  return this.graph.gridSize / 2;\n};\n\n/**\r\n * Function: createGuideShape\r\n *\r\n * Returns the mxShape to be used for painting the respective guide. This\r\n * implementation returns a new, dashed and crisp <mxPolyline> using\r\n * <mxConstants.GUIDE_COLOR> and <mxConstants.GUIDE_STROKEWIDTH> as the format.\r\n *\r\n * Parameters:\r\n *\r\n * horizontal - Boolean that specifies which guide should be created.\r\n */\nmxGuide.prototype.createGuideShape = function (horizontal) {\n  var guide = new _mxPolyline[\"default\"]([], _mxConstants[\"default\"].GUIDE_COLOR, _mxConstants[\"default\"].GUIDE_STROKEWIDTH);\n  guide.isDashed = true;\n  return guide;\n};\n\n/**\r\n * Function: move\r\n *\r\n * Moves the <bounds> by the given <mxPoint> and returnt the snapped point.\r\n */\nmxGuide.prototype.move = function (bounds, delta, gridEnabled) {\n  if (this.states != null && (this.horizontal || this.vertical) && bounds != null && delta != null) {\n    // Snaps the left, center and right to the given x-coordinate\n    var snapX = function snapX(x, state) {\n      x += this.graph.panDx;\n      var override = false;\n      if (Math.abs(x - center) < ttX) {\n        dx = x - bounds.getCenterX();\n        ttX = Math.abs(x - center);\n        override = true;\n      } else if (Math.abs(x - left) < ttX) {\n        dx = x - bounds.x;\n        ttX = Math.abs(x - left);\n        override = true;\n      } else if (Math.abs(x - right) < ttX) {\n        dx = x - bounds.x - bounds.width;\n        ttX = Math.abs(x - right);\n        override = true;\n      }\n      if (override) {\n        stateX = state;\n        valueX = Math.round(x - this.graph.panDx);\n        if (this.guideX == null) {\n          this.guideX = this.createGuideShape(true);\n\n          // Makes sure to use either VML or SVG shapes in order to implement\n          // event-transparency on the background area of the rectangle since\n          // HTML shapes do not let mouseevents through even when transparent\n          this.guideX.dialect = this.graph.dialect != _mxConstants[\"default\"].DIALECT_SVG ? _mxConstants[\"default\"].DIALECT_VML : _mxConstants[\"default\"].DIALECT_SVG;\n          this.guideX.pointerEvents = false;\n          this.guideX.init(this.graph.getView().getOverlayPane());\n        }\n      }\n      overrideX = overrideX || override;\n    };\n    // Snaps the top, middle or bottom to the given y-coordinate\n    var snapY = function snapY(y) {\n      y += this.graph.panDy;\n      var override = false;\n      if (Math.abs(y - middle) < ttY) {\n        dy = y - bounds.getCenterY();\n        ttY = Math.abs(y - middle);\n        override = true;\n      } else if (Math.abs(y - top) < ttY) {\n        dy = y - bounds.y;\n        ttY = Math.abs(y - top);\n        override = true;\n      } else if (Math.abs(y - bottom) < ttY) {\n        dy = y - bounds.y - bounds.height;\n        ttY = Math.abs(y - bottom);\n        override = true;\n      }\n      if (override) {\n        stateY = state;\n        valueY = Math.round(y - this.graph.panDy);\n        if (this.guideY == null) {\n          this.guideY = this.createGuideShape(false);\n\n          // Makes sure to use either VML or SVG shapes in order to implement\n          // event-transparency on the background area of the rectangle since\n          // HTML shapes do not let mouseevents through even when transparent\n          this.guideY.dialect = this.graph.dialect != _mxConstants[\"default\"].DIALECT_SVG ? _mxConstants[\"default\"].DIALECT_VML : _mxConstants[\"default\"].DIALECT_SVG;\n          this.guideY.pointerEvents = false;\n          this.guideY.init(this.graph.getView().getOverlayPane());\n        }\n      }\n      overrideY = overrideY || override;\n    };\n    var trx = this.graph.getView().translate;\n    var scale = this.graph.getView().scale;\n    var dx = delta.x;\n    var dy = delta.y;\n    var overrideX = false;\n    var stateX = null;\n    var valueX = null;\n    var overrideY = false;\n    var stateY = null;\n    var valueY = null;\n    var tt = this.getGuideTolerance();\n    var ttX = tt;\n    var ttY = tt;\n    var b = bounds.clone();\n    b.x += delta.x;\n    b.y += delta.y;\n    var left = b.x;\n    var right = b.x + b.width;\n    var center = b.getCenterX();\n    var top = b.y;\n    var bottom = b.y + b.height;\n    var middle = b.getCenterY();\n    ;\n    ;\n    for (var i = 0; i < this.states.length; i++) {\n      var state = this.states[i];\n      if (state != null) {\n        // Align x\n        if (this.horizontal) {\n          snapX.call(this, state.getCenterX(), state);\n          snapX.call(this, state.x, state);\n          snapX.call(this, state.x + state.width, state);\n        }\n\n        // Align y\n        if (this.vertical) {\n          snapY.call(this, state.getCenterY(), state);\n          snapY.call(this, state.y, state);\n          snapY.call(this, state.y + state.height, state);\n        }\n      }\n    }\n\n    // Moves cells that are off-grid back to the grid on move\n    if (gridEnabled) {\n      if (!overrideX) {\n        var tx = bounds.x - (this.graph.snap(bounds.x / scale - trx.x) + trx.x) * scale;\n        dx = this.graph.snap(dx / scale) * scale - tx;\n      }\n      if (!overrideY) {\n        var ty = bounds.y - (this.graph.snap(bounds.y / scale - trx.y) + trx.y) * scale;\n        dy = this.graph.snap(dy / scale) * scale - ty;\n      }\n    }\n\n    // Redraws the guides\n    var c = this.graph.container;\n    var minY, maxY, minX, maxX;\n    if (!overrideX && this.guideX != null) {\n      this.guideX.node.style.visibility = 'hidden';\n    } else if (this.guideX != null) {\n      if (stateX != null && bounds != null) {\n        minY = Math.min(bounds.y + dy - this.graph.panDy, stateX.y);\n        maxY = Math.max(bounds.y + bounds.height + dy - this.graph.panDy, stateX.y + stateX.height);\n      }\n      if (minY != null && maxY != null) {\n        this.guideX.points = [new _mxPoint[\"default\"](valueX, minY), new _mxPoint[\"default\"](valueX, maxY)];\n      } else {\n        this.guideX.points = [new _mxPoint[\"default\"](valueX, -this.graph.panDy), new _mxPoint[\"default\"](valueX, c.scrollHeight - 3 - this.graph.panDy)];\n      }\n      this.guideX.stroke = this.getGuideColor(stateX, true);\n      this.guideX.node.style.visibility = 'visible';\n      this.guideX.redraw();\n    }\n    if (!overrideY && this.guideY != null) {\n      this.guideY.node.style.visibility = 'hidden';\n    } else if (this.guideY != null) {\n      if (stateY != null && bounds != null) {\n        minX = Math.min(bounds.x + dx - this.graph.panDx, stateY.x);\n        maxX = Math.max(bounds.x + bounds.width + dx - this.graph.panDx, stateY.x + stateY.width);\n      }\n      if (minX != null && maxX != null) {\n        this.guideY.points = [new _mxPoint[\"default\"](minX, valueY), new _mxPoint[\"default\"](maxX, valueY)];\n      } else {\n        this.guideY.points = [new _mxPoint[\"default\"](-this.graph.panDx, valueY), new _mxPoint[\"default\"](c.scrollWidth - 3 - this.graph.panDx, valueY)];\n      }\n      this.guideY.stroke = this.getGuideColor(stateY, false);\n      this.guideY.node.style.visibility = 'visible';\n      this.guideY.redraw();\n    }\n    delta = new _mxPoint[\"default\"](dx, dy);\n  }\n  return delta;\n};\n\n/**\r\n * Function: hide\r\n *\r\n * Hides all current guides.\r\n */\nmxGuide.prototype.getGuideColor = function (state, horizontal) {\n  return _mxConstants[\"default\"].GUIDE_COLOR;\n};\n\n/**\r\n * Function: hide\r\n *\r\n * Hides all current guides.\r\n */\nmxGuide.prototype.hide = function () {\n  this.setVisible(false);\n};\n\n/**\r\n * Function: setVisible\r\n *\r\n * Shows or hides the current guides.\r\n */\nmxGuide.prototype.setVisible = function (visible) {\n  if (this.guideX != null) {\n    this.guideX.node.style.visibility = visible ? 'visible' : 'hidden';\n  }\n  if (this.guideY != null) {\n    this.guideY.node.style.visibility = visible ? 'visible' : 'hidden';\n  }\n};\n\n/**\r\n * Function: destroy\r\n *\r\n * Destroys all resources that this object uses.\r\n */\nmxGuide.prototype.destroy = function () {\n  if (this.guideX != null) {\n    this.guideX.destroy();\n    this.guideX = null;\n  }\n  if (this.guideY != null) {\n    this.guideY.destroy();\n    this.guideY = null;\n  }\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxStencil\r\n *\r\n * Implements a generic shape which is based on a XML node as a description.\r\n *\r\n * shape:\r\n *\r\n * The outer element is *shape*, that has attributes:\r\n *\r\n * - \"name\", string, required. The stencil name that uniquely identifies the shape.\r\n * - \"w\" and \"h\" are optional decimal view bounds. This defines your co-ordinate\r\n * system for the graphics operations in the shape. The default is 100,100.\r\n * - \"aspect\", optional string. Either \"variable\", the default, or \"fixed\". Fixed\r\n * means always render the shape with the aspect ratio defined by the ratio w/h.\r\n * Variable causes the ratio to match that of the geometry of the current vertex.\r\n * - \"strokewidth\", optional string. Either an integer or the string \"inherit\".\r\n * \"inherit\" indicates that the strokeWidth of the cell is only changed on scaling,\r\n * not on resizing.\r\n * If numeric values are used, the strokeWidth of the cell is changed on both\r\n * scaling and resizing and the value defines the multiple that is applied to\r\n * the width.\r\n *\r\n * connections:\r\n *\r\n * If you want to define specific fixed connection points on the shape use the\r\n * *connections* element. Each *constraint* element within connections defines\r\n * a fixed connection point on the shape. Constraints have attributes:\r\n *\r\n * - \"perimeter\", required. 1 or 0. 0 sets the connection point where specified\r\n * by x,y. 1 Causes the position of the connection point to be extrapolated from\r\n * the center of the shape, through x,y to the point of intersection with the\r\n * perimeter of the shape.\r\n * - \"x\" and \"y\" are the position of the fixed point relative to the bounds of\r\n * the shape. They can be automatically adjusted if perimeter=1. So, (0,0) is top\r\n * left, (0.5,0.5) the center, (1,0.5) the center of the right hand edge of the\r\n * bounds, etc. Values may be less than 0 or greater than 1 to be positioned\r\n * outside of the shape.\r\n * - \"name\", optional string. A unique identifier for the port on the shape.\r\n *\r\n * background and foreground:\r\n *\r\n * The path of the graphics drawing is split into two elements, *foreground* and\r\n * *background*. The split is to define which part any shadow applied to the shape\r\n * is derived from (the background). This, generally, means the background is the\r\n * line tracing of the outside of the shape, but not always.\r\n *\r\n * Any stroke, fill or fillstroke of a background must be the first element of the\r\n * foreground element, they must not used within *background*. If the background\r\n * is empty, this is not required.\r\n *\r\n * Because the background cannot have any fill or stroke, it can contain only one\r\n * *path*, *rect*, *roundrect* or *ellipse* element (or none). It can also not\r\n * include *image*, *text* or *include-shape*.\r\n *\r\n * Note that the state, styling and drawing in mxGraph stencils is very close in\r\n * design to that of HTML 5 canvas. Tutorials on this subject, if you're not\r\n * familiar with the topic, will give a good high-level introduction to the\r\n * concepts used.\r\n *\r\n * State:\r\n *\r\n * Rendering within the foreground and background elements has the concept of\r\n * state. There are two types of operations other than state save/load, styling\r\n * and drawing. The styling operations change the current state, so you can save\r\n * the current state with <save/> and pull the last saved state from the state\r\n * stack using <restore/>.\r\n *\r\n * Styling:\r\n *\r\n * The elements that change colors within the current state all take a hash\r\n * prefixed hex color code (\"#FFEA80\").\r\n *\r\n * - *strokecolor*, this sets the color that drawing paths will be rendered in\r\n * when a stroke or fillstroke command is issued.\r\n * - *fillcolor*, this sets the color that the inside of closed paths will be\r\n * rendered in when a fill or fillstroke command is issued.\r\n * - *fontcolor*, this sets the color that fonts are rendered in when text is drawn.\r\n *\r\n * *alpha* defines the degree of transparency used between 1.0 for fully opaque\r\n * and 0.0 for fully transparent.\r\n *\r\n * *strokewidth* defines the integer thickness of drawing elements rendered by\r\n * stroking.\r\n *\r\n * *dashed* is \"1\" for dashing enabled and \"0\" for disabled.\r\n *\r\n * When *dashed* is enabled the current dash pattern, defined by *dashpattern*,\r\n * is used on strokes. dashpattern is a sequence of space separated \"on, off\"\r\n * lengths that define what distance to paint the stroke for, then what distance\r\n * to paint nothing for, repeat... The default is \"3 3\". You could define a more\r\n * complex pattern with \"5 3 2 6\", for example. Generally, it makes sense to have\r\n * an even number of elements in the dashpattern, but that's not required.\r\n *\r\n * *linejoin*, *linecap* and *miterlimit* are best explained by the Mozilla page\r\n * on Canvas styling (about halfway down). The values are all the same except we\r\n * use \"flat\" for linecap, instead of Canvas' \"butt\".\r\n *\r\n * For font styling there are.\r\n *\r\n * - *fontsize*, an integer,\r\n * - *fontstyle*, an ORed bit pattern of bold (1), italic (2) and underline (4),\r\n * i.e bold underline is \"5\".\r\n * - *fontfamily*, is a string defining the typeface to be used.\r\n *\r\n * Drawing:\r\n *\r\n * Most drawing is contained within a *path* element. Again, the graphic\r\n * primitives are very similar to that of HTML 5 canvas.\r\n *\r\n * - *move* to attributes required decimals (x,y).\r\n * - *line* to attributes required decimals (x,y).\r\n * - *quad* to required decimals (x2,y2) via control point required decimals\r\n * (x1,y1).\r\n * - *curve* to required decimals (x3,y3), via control points required decimals\r\n * (x1,y1) and (x2,y2).\r\n * - *arc*, this doesn't follow the HTML Canvas signatures, instead it's a copy\r\n * of the SVG arc command. The SVG specification documentation gives the best\r\n * description of its behaviors. The attributes are named identically, they are\r\n * decimals and all required.\r\n * - *close* ends the current subpath and causes an automatic straight line to\r\n * be drawn from the current point to the initial point of the current subpath.\r\n *\r\n * Complex drawing:\r\n *\r\n * In addition to the graphics primitive operations there are non-primitive\r\n * operations. These provide an easy method to draw some basic shapes.\r\n *\r\n * - *rect*, attributes \"x\", \"y\", \"w\", \"h\", all required decimals\r\n * - *roundrect*, attributes \"x\", \"y\", \"w\", \"h\", all required decimals. Also\r\n * \"arcsize\" an optional decimal attribute defining how large, the corner curves\r\n * are.\r\n * - *ellipse*, attributes \"x\", \"y\", \"w\", \"h\", all required decimals.\r\n *\r\n * Note that these 3 shapes and all paths must be followed by either a fill,\r\n * stroke, or fillstroke.\r\n *\r\n * Text:\r\n *\r\n * *text* elements have the following attributes.\r\n *\r\n * - \"str\", the text string to display, required.\r\n * - \"x\" and \"y\", the decimal location (x,y) of the text element, required.\r\n * - \"align\", the horizontal alignment of the text element, either \"left\",\r\n * \"center\" or \"right\". Optional, default is \"left\".\r\n * - \"valign\", the vertical alignment of the text element, either \"top\", \"middle\"\r\n * or \"bottom\". Optional, default is \"top\".\r\n * - \"localized\", 0 or 1, if 1 then the \"str\" actually contains a key to use to\r\n * fetch the value out of mxResources. Optional, default is\r\n * <mxStencil.defaultLocalized>.\r\n * - \"vertical\", 0 or 1, if 1 the label is rendered vertically (rotated by 90\r\n * degrees). Optional, default is 0.\r\n * - \"rotation\", angle in degrees (0 to 360). The angle to rotate the text by.\r\n * Optional, default is 0.\r\n * - \"align-shape\", 0 or 1, if 0 ignore the rotation of the shape when setting\r\n * the text rotation. Optional, default is 1.\r\n *\r\n * If <allowEval> is true, then the text content of the this element can define\r\n * a function which is invoked with the shape as the only argument and returns\r\n * the value for the text element (ignored if the str attribute is not null).\r\n *\r\n * Images:\r\n *\r\n * *image* elements can either be external URLs, or data URIs, where supported\r\n * (not in IE 7-). Attributes are:\r\n *\r\n * - \"src\", required string. Either a data URI or URL.\r\n * - \"x\", \"y\", required decimals. The (x,y) position of the image.\r\n * - \"w\", \"h\", required decimals. The width and height of the image.\r\n * - \"flipH\" and \"flipV\", optional 0 or 1. Whether to flip the image along the\r\n * horizontal/vertical axis. Default is 0 for both.\r\n *\r\n * If <allowEval> is true, then the text content of the this element can define\r\n * a function which is invoked with the shape as the only argument and returns\r\n * the value for the image source (ignored if the src attribute is not null).\r\n *\r\n * Sub-shapes:\r\n *\r\n * *include-shape* allow stencils to be rendered within the current stencil by\r\n * referencing the sub-stencil by name. Attributes are:\r\n *\r\n * - \"name\", required string. The unique shape name of the stencil.\r\n * - \"x\", \"y\", \"w\", \"h\", required decimals. The (x,y) position of the sub-shape\r\n * and its width and height.\r\n *\r\n * Constructor: mxStencil\r\n *\r\n * Constructs a new generic shape by setting <desc> to the given XML node and\r\n * invoking <parseDescription> and <parseConstraints>.\r\n *\r\n * Parameters:\r\n *\r\n * desc - XML node that contains the stencil description.\r\n */\nvar _default = exports[\"default\"] = mxGuide;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxGuide.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxHexagon.js":
/*!********************************************!*\
  !*** ./src/workflow/mxClient/mxHexagon.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _mxPoint = _interopRequireDefault(__webpack_require__(/*! ./mxPoint.js */ \"./src/workflow/mxClient/mxPoint.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxActor = _interopRequireDefault(__webpack_require__(/*! ./mxActor.js */ \"./src/workflow/mxClient/mxActor.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ./mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxHexagon() {\n  _mxActor[\"default\"].call(this);\n}\n;\n\n/**\r\n * Extends mxActor.\r\n */\n_mxGraphUtils[\"default\"].extend(mxHexagon, _mxActor[\"default\"]);\n\n/**\r\n * Function: redrawPath\r\n *\r\n * Draws the path for this shape.\r\n */\nmxHexagon.prototype.redrawPath = function (c, x, y, w, h) {\n  var arcSize = _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_ARCSIZE, _mxConstants[\"default\"].LINE_ARCSIZE) / 2;\n  this.addPoints(c, [new _mxPoint[\"default\"](0.25 * w, 0), new _mxPoint[\"default\"](0.75 * w, 0), new _mxPoint[\"default\"](w, 0.5 * h), new _mxPoint[\"default\"](0.75 * w, h), new _mxPoint[\"default\"](0.25 * w, h), new _mxPoint[\"default\"](0, 0.5 * h)], this.isRounded, arcSize, true);\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxLine\r\n *\r\n * Extends <mxShape> to implement a horizontal line shape.\r\n * This shape is registered under <mxConstants.SHAPE_LINE> in\r\n * <mxCellRenderer>.\r\n *\r\n * Constructor: mxLine\r\n *\r\n * Constructs a new line shape.\r\n *\r\n * Parameters:\r\n *\r\n * bounds - <mxRectangle> that defines the bounds. This is stored in\r\n * <mxShape.bounds>.\r\n * stroke - String that defines the stroke color. Default is 'black'. This is\r\n * stored in <stroke>.\r\n * strokewidth - Optional integer that defines the stroke width. Default is\r\n * 1. This is stored in <strokewidth>.\r\n */\nvar _default = exports[\"default\"] = mxHexagon;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxHexagon.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxHierarchicalLayout.js":
/*!*******************************************************!*\
  !*** ./src/workflow/mxClient/mxHierarchicalLayout.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _mxGraphLayout = _interopRequireDefault(__webpack_require__(/*! ./mxGraphLayout.js */ \"./src/workflow/mxClient/mxGraphLayout.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ./mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxHierarchicalLayout(graph, orientation, deterministic) {\n  _mxGraphLayout[\"default\"].call(this, graph);\n  this.orientation = orientation != null ? orientation : _mxConstants[\"default\"].DIRECTION_NORTH;\n  this.deterministic = deterministic != null ? deterministic : true;\n}\n;\nvar _default = exports[\"default\"] = mxHierarchicalLayout;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxHierarchicalLayout.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxImage.js":
/*!******************************************!*\
  !*** ./src/workflow/mxClient/mxImage.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nfunction mxImage(src, width, height) {\n  this.src = src;\n  this.width = width;\n  this.height = height;\n}\n;\n\n/**\r\n * Variable: src\r\n *\r\n * String that specifies the URL of the image.\r\n */\nmxImage.prototype.src = null;\n\n/**\r\n * Variable: width\r\n *\r\n * Integer that specifies the width of the image.\r\n */\nmxImage.prototype.width = null;\n\n/**\r\n * Variable: height\r\n *\r\n * Integer that specifies the height of the image.\r\n */\nmxImage.prototype.height = null;\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxDivResizer\r\n *\r\n * Maintains the size of a div element in Internet Explorer. This is a\r\n * workaround for the right and bottom style being ignored in IE.\r\n *\r\n * If you need a div to cover the scrollwidth and -height of a document,\r\n * then you can use this class as follows:\r\n *\r\n * (code)\r\n * var resizer = new mxDivResizer(background);\r\n * resizer.getDocumentHeight = function()\r\n * {\r\n *   return document.body.scrollHeight;\r\n * }\r\n * resizer.getDocumentWidth = function()\r\n * {\r\n *   return document.body.scrollWidth;\r\n * }\r\n * resizer.resize();\r\n * (end)\r\n *\r\n * Constructor: mxDivResizer\r\n *\r\n * Constructs an object that maintains the size of a div\r\n * element when the window is being resized. This is only\r\n * required for Internet Explorer as it ignores the respective\r\n * stylesheet information for DIV elements.\r\n *\r\n * Parameters:\r\n *\r\n * div - Reference to the DOM node whose size should be maintained.\r\n * container - Optional Container that contains the div. Default is the\r\n * window.\r\n */\nvar _default = exports[\"default\"] = mxImage;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxImage.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxImageExport.js":
/*!************************************************!*\
  !*** ./src/workflow/mxClient/mxImageExport.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.function.bind.js */ \"../../node_modules/core-js/modules/es.function.bind.js\");\nvar _mxClient = _interopRequireDefault(__webpack_require__(/*! ./mxClient.js */ \"./src/workflow/mxClient/mxClient.js\"));\nvar _mxPoint = _interopRequireDefault(__webpack_require__(/*! ./mxPoint.js */ \"./src/workflow/mxClient/mxPoint.js\"));\nvar _mxUrlConverter = _interopRequireDefault(__webpack_require__(/*! ./mxUrlConverter.js */ \"./src/workflow/mxClient/mxUrlConverter.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxRectangle = _interopRequireDefault(__webpack_require__(/*! ./mxRectangle.js */ \"./src/workflow/mxClient/mxRectangle.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ./mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nvar _mxUtils = _interopRequireDefault(__webpack_require__(/*! ./mxUtils.js */ \"./src/workflow/mxClient/mxUtils.js\"));\nvar _mxVmlCanvas2D = _interopRequireDefault(__webpack_require__(/*! ./mxVmlCanvas2D.js */ \"./src/workflow/mxClient/mxVmlCanvas2D.js\"));\nvar _mxSvgCanvas2D = _interopRequireDefault(__webpack_require__(/*! ./mxSvgCanvas2D.js */ \"./src/workflow/mxClient/mxSvgCanvas2D.js\"));\nvar _mxXmlCanvas2D = _interopRequireDefault(__webpack_require__(/*! ./mxXmlCanvas2D.js */ \"./src/workflow/mxClient/mxXmlCanvas2D.js\"));\nvar _mxAbstractCanvas2D = _interopRequireDefault(__webpack_require__(/*! ./mxAbstractCanvas2D.js */ \"./src/workflow/mxClient/mxAbstractCanvas2D.js\"));\nvar _mxShape = _interopRequireDefault(__webpack_require__(/*! ./mxShape.js */ \"./src/workflow/mxClient/mxShape.js\"));\nvar _mxSvgStencil = _interopRequireDefault(__webpack_require__(/*! ./mxSvgStencil.js */ \"./src/workflow/mxClient/mxSvgStencil.js\"));\nvar _mxConnector = _interopRequireDefault(__webpack_require__(/*! ./mxConnector.js */ \"./src/workflow/mxClient/mxConnector.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxImageExport() {}\n;\n\n/**\r\n * Variable: includeOverlays\r\n *\r\n * Specifies if overlays should be included in the export. Default is false.\r\n */\nmxImageExport.prototype.includeOverlays = false;\n\n/**\r\n * Function: drawState\r\n *\r\n * Draws the given state and all its descendants to the given canvas.\r\n */\nmxImageExport.prototype.drawState = function (state, canvas) {\n  if (state != null) {\n    this.visitStatesRecursive(state, canvas, _mxGraphUtils[\"default\"].bind(this, function () {\n      this.drawCellState.apply(this, arguments);\n    }));\n\n    // Paints the overlays\n    if (this.includeOverlays) {\n      this.visitStatesRecursive(state, canvas, _mxGraphUtils[\"default\"].bind(this, function () {\n        this.drawOverlays.apply(this, arguments);\n      }));\n    }\n  }\n};\n\n/**\r\n * Function: drawState\r\n *\r\n * Draws the given state and all its descendants to the given canvas.\r\n */\nmxImageExport.prototype.visitStatesRecursive = function (state, canvas, visitor) {\n  if (state != null) {\n    visitor(state, canvas);\n    var graph = state.view.graph;\n    var childCount = graph.model.getChildCount(state.cell);\n    for (var i = 0; i < childCount; i++) {\n      var childState = graph.view.getState(graph.model.getChildAt(state.cell, i));\n      this.visitStatesRecursive(childState, canvas, visitor);\n    }\n  }\n};\n\n/**\r\n * Function: getLinkForCellState\r\n *\r\n * Returns the link for the given cell state and canvas. This returns null.\r\n */\nmxImageExport.prototype.getLinkForCellState = function (state, canvas) {\n  return null;\n};\n\n/**\r\n * Function: drawCellState\r\n *\r\n * Draws the given state to the given canvas.\r\n */\nmxImageExport.prototype.drawCellState = function (state, canvas) {\n  // Experimental feature\n  var link = this.getLinkForCellState(state, canvas);\n  if (link != null) {\n    canvas.setLink(link);\n  }\n\n  // Paints the shape and text\n  this.drawShape(state, canvas);\n  this.drawText(state, canvas);\n  if (link != null) {\n    canvas.setLink(null);\n  }\n};\n\n/**\r\n * Function: drawShape\r\n *\r\n * Draws the shape of the given state.\r\n */\nmxImageExport.prototype.drawShape = function (state, canvas) {\n  if (state.shape instanceof _mxShape[\"default\"] && state.shape.checkBounds()) {\n    canvas.save();\n    if (state.shape.stencil instanceof _mxSvgStencil[\"default\"]) {\n      var canvasRoot = canvas.root;\n      try {\n        var svgDoc = _mxUtils[\"default\"].createXmlDocument();\n        var group = svgDoc.createElementNS != null ? svgDoc.createElementNS(_mxConstants[\"default\"].NS_SVG, 'g') : svgDoc.createElement('g');\n        group.setAttribute('transform', canvasRoot.getAttribute('transform'));\n        canvas.root = group;\n        state.shape.paint(canvas);\n        canvasRoot.appendChild(group);\n      } finally {\n        canvas.root = canvasRoot;\n      }\n    } else {\n      state.shape.paint(canvas);\n    }\n    canvas.restore();\n  }\n};\n\n/**\r\n * Function: drawText\r\n *\r\n * Draws the text of the given state.\r\n */\nmxImageExport.prototype.drawText = function (state, canvas) {\n  if (state.text != null && state.text.checkBounds()) {\n    canvas.save();\n    state.text.paint(canvas);\n    if (state.shape instanceof _mxConnector[\"default\"]) {\n      state.shape.afterRedrawLabel(canvas.root.lastElementChild);\n    }\n    canvas.restore();\n  }\n};\n\n/**\r\n * Function: drawOverlays\r\n *\r\n * Draws the overlays for the given state. This is called if <includeOverlays>\r\n * is true.\r\n */\nmxImageExport.prototype.drawOverlays = function (state, canvas) {\n  if (state.overlays != null) {\n    state.overlays.visit(function (id, shape) {\n      if (shape instanceof _mxShape[\"default\"]) {\n        shape.paint(canvas);\n      }\n    });\n  }\n};\n\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxGuide\r\n *\r\n * Implements the alignment of selection cells to other cells in the graph.\r\n *\r\n * Constructor: mxGuide\r\n *\r\n * Constructs a new guide object.\r\n */\nvar _default = exports[\"default\"] = mxImageExport;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxImageExport.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxImageShape.js":
/*!***********************************************!*\
  !*** ./src/workflow/mxClient/mxImageShape.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.fill.js */ \"../../node_modules/core-js/modules/es.array.fill.js\");\n__webpack_require__(/*! core-js/modules/es.array.filter.js */ \"../../node_modules/core-js/modules/es.array.filter.js\");\n__webpack_require__(/*! core-js/modules/es.object.to-string.js */ \"../../node_modules/core-js/modules/es.object.to-string.js\");\nvar _mxClient = _interopRequireDefault(__webpack_require__(/*! ./mxClient.js */ \"./src/workflow/mxClient/mxClient.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxRectangleShape = _interopRequireDefault(__webpack_require__(/*! ./mxRectangleShape.js */ \"./src/workflow/mxClient/mxRectangleShape.js\"));\nvar _mxShape = _interopRequireDefault(__webpack_require__(/*! ./mxShape.js */ \"./src/workflow/mxClient/mxShape.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ./mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxImageShape(bounds, image, fill, stroke, strokewidth) {\n  _mxShape[\"default\"].call(this);\n  this.bounds = bounds;\n  this.image = image;\n  this.fill = fill;\n  this.stroke = stroke;\n  this.strokewidth = strokewidth != null ? strokewidth : 1;\n  this.shadow = false;\n}\n;\n\n/**\r\n * Extends mxShape.\r\n */\n_mxGraphUtils[\"default\"].extend(mxImageShape, _mxRectangleShape[\"default\"]);\n\n/**\r\n * Variable: preserveImageAspect\r\n *\r\n * Switch to preserve image aspect. Default is true.\r\n */\nmxImageShape.prototype.preserveImageAspect = true;\n\n/**\r\n * Function: getSvgScreenOffset\r\n *\r\n * Disables offset in IE9 for crisper image output.\r\n */\nmxImageShape.prototype.getSvgScreenOffset = function () {\n  return 0;\n};\n\n/**\r\n * Function: apply\r\n *\r\n * Overrides <mxShape.apply> to replace the fill and stroke colors with the\r\n * respective values from <mxConstants.STYLE_IMAGE_BACKGROUND> and\r\n * <mxConstants.STYLE_IMAGE_BORDER>.\r\n *\r\n * Applies the style of the given <mxCellState> to the shape. This\r\n * implementation assigns the following styles to local fields:\r\n *\r\n * - <mxConstants.STYLE_IMAGE_BACKGROUND> => fill\r\n * - <mxConstants.STYLE_IMAGE_BORDER> => stroke\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> of the corresponding cell.\r\n */\nmxImageShape.prototype.apply = function (state) {\n  _mxShape[\"default\"].prototype.apply.apply(this, arguments);\n  this.fill = null;\n  this.stroke = null;\n  this.gradient = null;\n  if (this.style != null) {\n    this.preserveImageAspect = _mxGraphUtils[\"default\"].getNumber(this.style, _mxConstants[\"default\"].STYLE_IMAGE_ASPECT, 1) == 1;\n\n    // Legacy support for imageFlipH/V\n    this.flipH = this.flipH || _mxGraphUtils[\"default\"].getValue(this.style, 'imageFlipH', 0) == 1;\n    this.flipV = this.flipV || _mxGraphUtils[\"default\"].getValue(this.style, 'imageFlipV', 0) == 1;\n  }\n};\n\n/**\r\n * Function: isHtmlAllowed\r\n *\r\n * Returns true if HTML is allowed for this shape. This implementation always\r\n * returns false.\r\n */\nmxImageShape.prototype.isHtmlAllowed = function () {\n  return !this.preserveImageAspect;\n};\n\n/**\r\n * Function: createHtml\r\n *\r\n * Creates and returns the HTML DOM node(s) to represent\r\n * this shape. This implementation falls back to <createVml>\r\n * so that the HTML creation is optional.\r\n */\nmxImageShape.prototype.createHtml = function () {\n  var node = document.createElement('div');\n  node.style.position = 'absolute';\n  return node;\n};\n\n/**\r\n * Function: paintVertexShape\r\n *\r\n * Generic background painting implementation.\r\n */\nmxImageShape.prototype.paintVertexShape = function (c, x, y, w, h) {\n  if (this.image != null) {\n    var fill = _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_IMAGE_BACKGROUND, null);\n    var stroke = _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_IMAGE_BORDER, null);\n    if (fill != null) {\n      // Stroke rendering required for shadow\n      c.setFillColor(fill);\n      c.setStrokeColor(stroke);\n      c.rect(x, y, w, h);\n      c.fillAndStroke();\n    }\n\n    // FlipH/V are implicit via mxShape.updateTransform\n    c.image(x, y, w, h, this.image, this.preserveImageAspect, false, false);\n    var stroke = _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_IMAGE_BORDER, null);\n    if (stroke != null) {\n      c.setShadow(false);\n      c.setStrokeColor(stroke);\n      c.rect(x, y, w, h);\n      c.stroke();\n    }\n  } else {\n    _mxRectangleShape[\"default\"].prototype.paintBackground.apply(this, arguments);\n  }\n};\n\n/**\r\n * Function: redraw\r\n *\r\n * Overrides <mxShape.redraw> to preserve the aspect ratio of images.\r\n */\nmxImageShape.prototype.redrawHtmlShape = function () {\n  this.node.style.left = Math.round(this.bounds.x) + 'px';\n  this.node.style.top = Math.round(this.bounds.y) + 'px';\n  this.node.style.width = Math.max(0, Math.round(this.bounds.width)) + 'px';\n  this.node.style.height = Math.max(0, Math.round(this.bounds.height)) + 'px';\n  this.node.innerHTML = '';\n  if (this.image != null) {\n    var fill = _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_IMAGE_BACKGROUND, '');\n    var stroke = _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_IMAGE_BORDER, '');\n    this.node.style.backgroundColor = fill;\n    this.node.style.borderColor = stroke;\n\n    // VML image supports PNG in IE6\n    var useVml = _mxClient[\"default\"].IS_IE6 || (document.documentMode == null || document.documentMode <= 8) && this.rotation != 0;\n    var img = document.createElement(useVml ? _mxClient[\"default\"].VML_PREFIX + ':image' : 'img');\n    img.setAttribute('border', '0');\n    img.style.position = 'absolute';\n    img.src = this.image;\n    var filter = this.opacity < 100 ? 'alpha(opacity=' + this.opacity + ')' : '';\n    this.node.style.filter = filter;\n    if (this.flipH && this.flipV) {\n      filter += 'progid:DXImageTransform.Microsoft.BasicImage(rotation=2)';\n    } else if (this.flipH) {\n      filter += 'progid:DXImageTransform.Microsoft.BasicImage(mirror=1)';\n    } else if (this.flipV) {\n      filter += 'progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)';\n    }\n    if (img.style.filter != filter) {\n      img.style.filter = filter;\n    }\n    if (img.nodeName == 'image') {\n      img.style.rotation = this.rotation;\n    } else if (this.rotation != 0) {\n      // LATER: Add flipV/H support\n      _mxGraphUtils[\"default\"].setPrefixedStyle(img.style, 'transform', 'rotate(' + this.rotation + 'deg)');\n    } else {\n      _mxGraphUtils[\"default\"].setPrefixedStyle(img.style, 'transform', '');\n    }\n\n    // Known problem: IE clips top line of image for certain angles\n    img.style.width = this.node.style.width;\n    img.style.height = this.node.style.height;\n    this.node.style.backgroundImage = '';\n    this.node.appendChild(img);\n  } else {\n    this.setTransparentBackgroundImage(this.node);\n  }\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxLabel\r\n *\r\n * Extends <mxShape> to implement an image shape with a label.\r\n * This shape is registered under <mxConstants.SHAPE_LABEL> in\r\n * <mxCellRenderer>.\r\n *\r\n * Constructor: mxLabel\r\n *\r\n * Constructs a new label shape.\r\n *\r\n * Parameters:\r\n *\r\n * bounds - <mxRectangle> that defines the bounds. This is stored in\r\n * <mxShape.bounds>.\r\n * fill - String that defines the fill color. This is stored in <fill>.\r\n * stroke - String that defines the stroke color. This is stored in <stroke>.\r\n * strokewidth - Optional integer that defines the stroke width. Default is\r\n * 1. This is stored in <strokewidth>.\r\n */\nvar _default = exports[\"default\"] = mxImageShape;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxImageShape.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxKeyHandler.js":
/*!***********************************************!*\
  !*** ./src/workflow/mxClient/mxKeyHandler.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.function.bind.js */ \"../../node_modules/core-js/modules/es.function.bind.js\");\nvar _mxClient = _interopRequireDefault(__webpack_require__(/*! ./mxClient.js */ \"./src/workflow/mxClient/mxClient.js\"));\nvar _mxEvent = _interopRequireDefault(__webpack_require__(/*! ./mxEvent.js */ \"./src/workflow/mxClient/mxEvent.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxUtils = _interopRequireDefault(__webpack_require__(/*! ./mxUtils.js */ \"./src/workflow/mxClient/mxUtils.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxKeyHandler(graph, target) {\n  if (graph != null) {\n    this.graph = graph;\n    this.target = target || document.documentElement;\n\n    // Creates the arrays to map from keycodes to functions\n    this.normalKeys = [];\n    this.shiftKeys = [];\n    this.controlKeys = [];\n    this.controlShiftKeys = [];\n    this.keydownHandler = _mxGraphUtils[\"default\"].bind(this, function (evt) {\n      this.keyDown(evt);\n    });\n\n    // Installs the keystroke listener in the target\n    _mxEvent[\"default\"].addListener(this.target, 'keydown', this.keydownHandler);\n\n    // Automatically deallocates memory in IE\n    if (_mxClient[\"default\"].IS_IE) {\n      _mxEvent[\"default\"].addListener(window, 'unload', _mxGraphUtils[\"default\"].bind(this, function () {\n        this.destroy();\n      }));\n    }\n  }\n}\n;\n\n/**\r\n * Variable: graph\r\n *\r\n * Reference to the <mxGraph> associated with this handler.\r\n */\nmxKeyHandler.prototype.graph = null;\n\n/**\r\n * Variable: target\r\n *\r\n * Reference to the target DOM, that is, the DOM node where the key event\r\n * listeners are installed.\r\n */\nmxKeyHandler.prototype.target = null;\n\n/**\r\n * Variable: normalKeys\r\n *\r\n * Maps from keycodes to functions for non-pressed control keys.\r\n */\nmxKeyHandler.prototype.normalKeys = null;\n\n/**\r\n * Variable: shiftKeys\r\n *\r\n * Maps from keycodes to functions for pressed shift keys.\r\n */\nmxKeyHandler.prototype.shiftKeys = null;\n\n/**\r\n * Variable: controlKeys\r\n *\r\n * Maps from keycodes to functions for pressed control keys.\r\n */\nmxKeyHandler.prototype.controlKeys = null;\n\n/**\r\n * Variable: controlShiftKeys\r\n *\r\n * Maps from keycodes to functions for pressed control and shift keys.\r\n */\nmxKeyHandler.prototype.controlShiftKeys = null;\n\n/**\r\n * Variable: enabled\r\n *\r\n * Specifies if events are handled. Default is true.\r\n */\nmxKeyHandler.prototype.enabled = true;\n\n/**\r\n * Function: isEnabled\r\n *\r\n * Returns true if events are handled. This implementation returns\r\n * <enabled>.\r\n */\nmxKeyHandler.prototype.isEnabled = function () {\n  return this.enabled;\n};\n\n/**\r\n * Function: setEnabled\r\n *\r\n * Enables or disables event handling by updating <enabled>.\r\n *\r\n * Parameters:\r\n *\r\n * enabled - Boolean that specifies the new enabled state.\r\n */\nmxKeyHandler.prototype.setEnabled = function (enabled) {\n  this.enabled = enabled;\n};\n\n/**\r\n * Function: bindKey\r\n *\r\n * Binds the specified keycode to the given function. This binding is used\r\n * if the control key is not pressed.\r\n *\r\n * Parameters:\r\n *\r\n * code - Integer that specifies the keycode.\r\n * funct - JavaScript function that takes the key event as an argument.\r\n */\nmxKeyHandler.prototype.bindKey = function (code, funct) {\n  this.normalKeys[code] = funct;\n};\n\n/**\r\n * Function: bindShiftKey\r\n *\r\n * Binds the specified keycode to the given function. This binding is used\r\n * if the shift key is pressed.\r\n *\r\n * Parameters:\r\n *\r\n * code - Integer that specifies the keycode.\r\n * funct - JavaScript function that takes the key event as an argument.\r\n */\nmxKeyHandler.prototype.bindShiftKey = function (code, funct) {\n  this.shiftKeys[code] = funct;\n};\n\n/**\r\n * Function: bindControlKey\r\n *\r\n * Binds the specified keycode to the given function. This binding is used\r\n * if the control key is pressed.\r\n *\r\n * Parameters:\r\n *\r\n * code - Integer that specifies the keycode.\r\n * funct - JavaScript function that takes the key event as an argument.\r\n */\nmxKeyHandler.prototype.bindControlKey = function (code, funct) {\n  this.controlKeys[code] = funct;\n};\n\n/**\r\n * Function: bindControlShiftKey\r\n *\r\n * Binds the specified keycode to the given function. This binding is used\r\n * if the control and shift key are pressed.\r\n *\r\n * Parameters:\r\n *\r\n * code - Integer that specifies the keycode.\r\n * funct - JavaScript function that takes the key event as an argument.\r\n */\nmxKeyHandler.prototype.bindControlShiftKey = function (code, funct) {\n  this.controlShiftKeys[code] = funct;\n};\n\n/**\r\n * Function: isControlDown\r\n *\r\n * Returns true if the control key is pressed. This uses <mxEvent.isControlDown>.\r\n *\r\n * Parameters:\r\n *\r\n * evt - Key event whose control key pressed state should be returned.\r\n */\nmxKeyHandler.prototype.isControlDown = function (evt) {\n  return _mxEvent[\"default\"].isControlDown(evt);\n};\n\n/**\r\n * Function: getFunction\r\n *\r\n * Returns the function associated with the given key event or null if no\r\n * function is associated with the given event.\r\n *\r\n * Parameters:\r\n *\r\n * evt - Key event whose associated function should be returned.\r\n */\nmxKeyHandler.prototype.getFunction = function (evt) {\n  if (evt != null && !_mxEvent[\"default\"].isAltDown(evt)) {\n    if (this.isControlDown(evt)) {\n      if (_mxEvent[\"default\"].isShiftDown(evt)) {\n        return this.controlShiftKeys[evt.keyCode];\n      } else {\n        return this.controlKeys[evt.keyCode];\n      }\n    } else {\n      if (_mxEvent[\"default\"].isShiftDown(evt)) {\n        return this.shiftKeys[evt.keyCode];\n      } else {\n        return this.normalKeys[evt.keyCode];\n      }\n    }\n  }\n  return null;\n};\n\n/**\r\n * Function: isGraphEvent\r\n *\r\n * Returns true if the event should be processed by this handler, that is,\r\n * if the event source is either the target, one of its direct children, a\r\n * descendant of the <mxGraph.container>, or the <mxGraph.cellEditor> of the\r\n * <graph>.\r\n *\r\n * Parameters:\r\n *\r\n * evt - Key event that represents the keystroke.\r\n */\nmxKeyHandler.prototype.isGraphEvent = function (evt) {\n  var source = _mxEvent[\"default\"].getSource(evt);\n\n  // Accepts events from the target object or\n  // in-place editing inside graph\n  if (source == this.target || source.parentNode == this.target || this.graph.cellEditor != null && this.graph.cellEditor.isEventSource(evt)) {\n    return true;\n  }\n\n  // Accepts events from inside the container\n  return _mxUtils[\"default\"].isAncestorNode(this.graph.container, source);\n};\n\n/**\r\n * Function: keyDown\r\n *\r\n * Handles the event by invoking the function bound to the respective keystroke\r\n * if <isEnabledForEvent> returns true for the given event and if\r\n * <isEventIgnored> returns false, except for escape for which\r\n * <isEventIgnored> is not invoked.\r\n *\r\n * Parameters:\r\n *\r\n * evt - Key event that represents the keystroke.\r\n */\nmxKeyHandler.prototype.keyDown = function (evt) {\n  if (this.isEnabledForEvent(evt)) {\n    // Cancels the editing if escape is pressed\n    if (evt.keyCode == 27 /* Escape */) {\n      this.escape(evt);\n    }\n\n    // Invokes the function for the keystroke\n    else if (!this.isEventIgnored(evt)) {\n      var boundFunction = this.getFunction(evt);\n      if (boundFunction != null) {\n        boundFunction(evt);\n        _mxEvent[\"default\"].consume(evt);\n      }\n    }\n  }\n};\n\n/**\r\n * Function: isEnabledForEvent\r\n *\r\n * Returns true if the given event should be handled. <isEventIgnored> is\r\n * called later if the event is not an escape key stroke, in which case\r\n * <escape> is called. This implementation returns true if <isEnabled>\r\n * returns true for both, this handler and <graph>, if the event is not\r\n * consumed and if <isGraphEvent> returns true.\r\n *\r\n * Parameters:\r\n *\r\n * evt - Key event that represents the keystroke.\r\n */\nmxKeyHandler.prototype.isEnabledForEvent = function (evt) {\n  return this.graph.isEnabled() && !_mxEvent[\"default\"].isConsumed(evt) && this.isGraphEvent(evt) && this.isEnabled();\n};\n\n/**\r\n * Function: isEventIgnored\r\n *\r\n * Returns true if the given keystroke should be ignored. This returns\r\n * graph.isEditing().\r\n *\r\n * Parameters:\r\n *\r\n * evt - Key event that represents the keystroke.\r\n */\nmxKeyHandler.prototype.isEventIgnored = function (evt) {\n  return this.graph.isEditing();\n};\n\n/**\r\n * Function: escape\r\n *\r\n * Hook to process ESCAPE keystrokes. This implementation invokes\r\n * <mxGraph.stopEditing> to cancel the current editing, connecting\r\n * and/or other ongoing modifications.\r\n *\r\n * Parameters:\r\n *\r\n * evt - Key event that represents the keystroke. Possible keycode in this\r\n * case is 27 (ESCAPE).\r\n */\nmxKeyHandler.prototype.escape = function (evt) {\n  if (this.graph.isEscapeEnabled()) {\n    this.graph.escape(evt);\n  }\n};\n\n/**\r\n * Function: destroy\r\n *\r\n * Destroys the handler and all its references into the DOM. This does\r\n * normally not need to be called, it is called automatically when the\r\n * window unloads (in IE).\r\n */\nmxKeyHandler.prototype.destroy = function () {\n  if (this.target != null && this.keydownHandler != null) {\n    _mxEvent[\"default\"].removeListener(this.target, 'keydown', this.keydownHandler);\n    this.keydownHandler = null;\n  }\n  this.target = null;\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxTooltipHandler\r\n *\r\n * Graph event handler that displays tooltips. <mxGraph.getTooltip> is used to\r\n * get the tooltip for a cell or handle. This handler is built-into\r\n * <mxGraph.tooltipHandler> and enabled using <mxGraph.setTooltips>.\r\n *\r\n * Example:\r\n *\r\n * (code>\r\n * new mxTooltipHandler(graph);\r\n * (end)\r\n *\r\n * Constructor: mxTooltipHandler\r\n *\r\n * Constructs an event handler that displays tooltips with the specified\r\n * delay (in milliseconds). If no delay is specified then a default delay\r\n * of 500 ms (0.5 sec) is used.\r\n *\r\n * Parameters:\r\n *\r\n * graph - Reference to the enclosing <mxGraph>.\r\n * delay - Optional delay in milliseconds.\r\n */\nvar _default = exports[\"default\"] = mxKeyHandler;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxKeyHandler.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxLabel.js":
/*!******************************************!*\
  !*** ./src/workflow/mxClient/mxLabel.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.fill.js */ \"../../node_modules/core-js/modules/es.array.fill.js\");\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxRectangle = _interopRequireDefault(__webpack_require__(/*! ./mxRectangle.js */ \"./src/workflow/mxClient/mxRectangle.js\"));\nvar _mxRectangleShape = _interopRequireDefault(__webpack_require__(/*! ./mxRectangleShape.js */ \"./src/workflow/mxClient/mxRectangleShape.js\"));\nvar _mxShape = _interopRequireDefault(__webpack_require__(/*! ./mxShape.js */ \"./src/workflow/mxClient/mxShape.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ./mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxLabel(bounds, fill, stroke, strokewidth) {\n  _mxRectangleShape[\"default\"].call(this, bounds, fill, stroke, strokewidth);\n}\n;\n\n/**\r\n * Extends mxShape.\r\n */\n_mxGraphUtils[\"default\"].extend(mxLabel, _mxRectangleShape[\"default\"]);\n\n/**\r\n * Variable: imageSize\r\n *\r\n * Default width and height for the image. Default is\r\n * <mxConstants.DEFAULT_IMAGESIZE>.\r\n */\nmxLabel.prototype.imageSize = _mxConstants[\"default\"].DEFAULT_IMAGESIZE;\n\n/**\r\n * Variable: spacing\r\n *\r\n * Default value for image spacing. Default is 2.\r\n */\nmxLabel.prototype.spacing = 2;\n\n/**\r\n * Variable: indicatorSize\r\n *\r\n * Default width and height for the indicicator. Default is 10.\r\n */\nmxLabel.prototype.indicatorSize = 10;\n\n/**\r\n * Variable: indicatorSpacing\r\n *\r\n * Default spacing between image and indicator. Default is 2.\r\n */\nmxLabel.prototype.indicatorSpacing = 2;\n\n/**\r\n * Function: init\r\n *\r\n * Initializes the shape and the <indicator>.\r\n */\nmxLabel.prototype.init = function (container) {\n  _mxShape[\"default\"].prototype.init.apply(this, arguments);\n  if (this.indicatorShape != null) {\n    this.indicator = new this.indicatorShape();\n    this.indicator.dialect = this.dialect;\n    this.indicator.init(this.node);\n  }\n};\n\n/**\r\n * Function: redraw\r\n *\r\n * Reconfigures this shape. This will update the colors of the indicator\r\n * and reconfigure it if required.\r\n */\nmxLabel.prototype.redraw = function () {\n  if (this.indicator != null) {\n    this.indicator.fill = this.indicatorColor;\n    this.indicator.stroke = this.indicatorStrokeColor;\n    this.indicator.gradient = this.indicatorGradientColor;\n    this.indicator.direction = this.indicatorDirection;\n  }\n  _mxShape[\"default\"].prototype.redraw.apply(this, arguments);\n};\n\n/**\r\n * Function: isHtmlAllowed\r\n *\r\n * Returns true for non-rounded, non-rotated shapes with no glass gradient and\r\n * no indicator shape.\r\n */\nmxLabel.prototype.isHtmlAllowed = function () {\n  return _mxRectangleShape[\"default\"].prototype.isHtmlAllowed.apply(this, arguments) && this.indicatorColor == null && this.indicatorShape == null;\n};\n\n/**\r\n * Function: paintForeground\r\n *\r\n * Generic background painting implementation.\r\n */\nmxLabel.prototype.paintForeground = function (c, x, y, w, h) {\n  this.paintImage(c, x, y, w, h);\n  this.paintIndicator(c, x, y, w, h);\n  _mxRectangleShape[\"default\"].prototype.paintForeground.apply(this, arguments);\n};\n\n/**\r\n * Function: paintImage\r\n *\r\n * Generic background painting implementation.\r\n */\nmxLabel.prototype.paintImage = function (c, x, y, w, h) {\n  if (this.image != null) {\n    var bounds = this.getImageBounds(x, y, w, h);\n    c.image(bounds.x, bounds.y, bounds.width, bounds.height, this.image, false, false, false);\n  }\n};\n\n/**\r\n * Function: getImageBounds\r\n *\r\n * Generic background painting implementation.\r\n */\nmxLabel.prototype.getImageBounds = function (x, y, w, h) {\n  var align = _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_IMAGE_ALIGN, _mxConstants[\"default\"].ALIGN_LEFT);\n  var valign = _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_IMAGE_VERTICAL_ALIGN, _mxConstants[\"default\"].ALIGN_MIDDLE);\n  var width = _mxGraphUtils[\"default\"].getNumber(this.style, _mxConstants[\"default\"].STYLE_IMAGE_WIDTH, _mxConstants[\"default\"].DEFAULT_IMAGESIZE);\n  var height = _mxGraphUtils[\"default\"].getNumber(this.style, _mxConstants[\"default\"].STYLE_IMAGE_HEIGHT, _mxConstants[\"default\"].DEFAULT_IMAGESIZE);\n  var spacing = _mxGraphUtils[\"default\"].getNumber(this.style, _mxConstants[\"default\"].STYLE_SPACING, this.spacing) + 5;\n  if (align == _mxConstants[\"default\"].ALIGN_CENTER) {\n    x += (w - width) / 2;\n  } else if (align == _mxConstants[\"default\"].ALIGN_RIGHT) {\n    x += w - width - spacing;\n  } else\n    // default is left\n    {\n      x += spacing;\n    }\n  if (valign == _mxConstants[\"default\"].ALIGN_TOP) {\n    y += spacing;\n  } else if (valign == _mxConstants[\"default\"].ALIGN_BOTTOM) {\n    y += h - height - spacing;\n  } else\n    // default is middle\n    {\n      y += (h - height) / 2;\n    }\n  return new _mxRectangle[\"default\"](x, y, width, height);\n};\n\n/**\r\n * Function: paintIndicator\r\n *\r\n * Generic background painting implementation.\r\n */\nmxLabel.prototype.paintIndicator = function (c, x, y, w, h) {\n  if (this.indicator != null) {\n    this.indicator.bounds = this.getIndicatorBounds(x, y, w, h);\n    this.indicator.paint(c);\n  } else if (this.indicatorImage != null) {\n    var bounds = this.getIndicatorBounds(x, y, w, h);\n    c.image(bounds.x, bounds.y, bounds.width, bounds.height, this.indicatorImage, false, false, false);\n  }\n};\n\n/**\r\n * Function: getIndicatorBounds\r\n *\r\n * Generic background painting implementation.\r\n */\nmxLabel.prototype.getIndicatorBounds = function (x, y, w, h) {\n  var align = _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_IMAGE_ALIGN, _mxConstants[\"default\"].ALIGN_LEFT);\n  var valign = _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_IMAGE_VERTICAL_ALIGN, _mxConstants[\"default\"].ALIGN_MIDDLE);\n  var width = _mxGraphUtils[\"default\"].getNumber(this.style, _mxConstants[\"default\"].STYLE_INDICATOR_WIDTH, this.indicatorSize);\n  var height = _mxGraphUtils[\"default\"].getNumber(this.style, _mxConstants[\"default\"].STYLE_INDICATOR_HEIGHT, this.indicatorSize);\n  var spacing = this.spacing + 5;\n  if (align == _mxConstants[\"default\"].ALIGN_RIGHT) {\n    x += w - width - spacing;\n  } else if (align == _mxConstants[\"default\"].ALIGN_CENTER) {\n    x += (w - width) / 2;\n  } else\n    // default is left\n    {\n      x += spacing;\n    }\n  if (valign == _mxConstants[\"default\"].ALIGN_BOTTOM) {\n    y += h - height - spacing;\n  } else if (valign == _mxConstants[\"default\"].ALIGN_TOP) {\n    y += spacing;\n  } else\n    // default is middle\n    {\n      y += (h - height) / 2;\n    }\n  return new _mxRectangle[\"default\"](x, y, width, height);\n};\n/**\r\n * Function: redrawHtmlShape\r\n *\r\n * Generic background painting implementation.\r\n */\nmxLabel.prototype.redrawHtmlShape = function () {\n  _mxRectangleShape[\"default\"].prototype.redrawHtmlShape.apply(this, arguments);\n\n  // Removes all children\n  while (this.node.hasChildNodes()) {\n    this.node.removeChild(this.node.lastChild);\n  }\n  if (this.image != null) {\n    var node = document.createElement('img');\n    node.style.position = 'relative';\n    node.setAttribute('border', '0');\n    var bounds = this.getImageBounds(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height);\n    bounds.x -= this.bounds.x;\n    bounds.y -= this.bounds.y;\n    node.style.left = Math.round(bounds.x) + 'px';\n    node.style.top = Math.round(bounds.y) + 'px';\n    node.style.width = Math.round(bounds.width) + 'px';\n    node.style.height = Math.round(bounds.height) + 'px';\n    node.src = this.image;\n    this.node.appendChild(node);\n  }\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxCylinder\r\n *\r\n * Extends <mxShape> to implement an cylinder shape. If a\r\n * custom shape with one filled area and an overlay path is\r\n * needed, then this shape's <redrawPath> should be overridden.\r\n * This shape is registered under <mxConstants.SHAPE_CYLINDER>\r\n * in <mxCellRenderer>.\r\n *\r\n * Constructor: mxCylinder\r\n *\r\n * Constructs a new cylinder shape.\r\n *\r\n * Parameters:\r\n *\r\n * bounds - <mxRectangle> that defines the bounds. This is stored in\r\n * <mxShape.bounds>.\r\n * fill - String that defines the fill color. This is stored in <fill>.\r\n * stroke - String that defines the stroke color. This is stored in <stroke>.\r\n * strokewidth - Optional integer that defines the stroke width. Default is\r\n * 1. This is stored in <strokewidth>.\r\n */\nvar _default = exports[\"default\"] = mxLabel;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxLabel.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxLayoutManager.js":
/*!**************************************************!*\
  !*** ./src/workflow/mxClient/mxLayoutManager.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.concat.js */ \"../../node_modules/core-js/modules/es.array.concat.js\");\n__webpack_require__(/*! core-js/modules/es.array.index-of.js */ \"../../node_modules/core-js/modules/es.array.index-of.js\");\n__webpack_require__(/*! core-js/modules/es.array.reverse.js */ \"../../node_modules/core-js/modules/es.array.reverse.js\");\n__webpack_require__(/*! core-js/modules/es.array.slice.js */ \"../../node_modules/core-js/modules/es.array.slice.js\");\n__webpack_require__(/*! core-js/modules/es.function.bind.js */ \"../../node_modules/core-js/modules/es.function.bind.js\");\nvar _mxEventObject = _interopRequireDefault(__webpack_require__(/*! ./mxEventObject.js */ \"./src/workflow/mxClient/mxEventObject.js\"));\nvar _mxEvent = _interopRequireDefault(__webpack_require__(/*! ./mxEvent.js */ \"./src/workflow/mxClient/mxEvent.js\"));\nvar _mxDictionary = _interopRequireDefault(__webpack_require__(/*! ./mxDictionary.js */ \"./src/workflow/mxClient/mxDictionary.js\"));\nvar _mxEventSource = _interopRequireDefault(__webpack_require__(/*! ./mxEventSource.js */ \"./src/workflow/mxClient/mxEventSource.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxUtils = _interopRequireDefault(__webpack_require__(/*! ./mxUtils.js */ \"./src/workflow/mxClient/mxUtils.js\"));\nvar _mxChildChange = _interopRequireDefault(__webpack_require__(/*! ./mxChildChange.js */ \"./src/workflow/mxClient/mxChildChange.js\"));\nvar _mxVisibleChange = _interopRequireDefault(__webpack_require__(/*! ./mxVisibleChange.js */ \"./src/workflow/mxClient/mxVisibleChange.js\"));\nvar _mxGeometryChange = _interopRequireDefault(__webpack_require__(/*! ./mxGeometryChange.js */ \"./src/workflow/mxClient/mxGeometryChange.js\"));\nvar _mxRootChange = _interopRequireDefault(__webpack_require__(/*! ./mxRootChange.js */ \"./src/workflow/mxClient/mxRootChange.js\"));\nvar _mxTerminalChange = _interopRequireDefault(__webpack_require__(/*! ./mxTerminalChange.js */ \"./src/workflow/mxClient/mxTerminalChange.js\"));\nvar _mxStyleChange = _interopRequireDefault(__webpack_require__(/*! ./mxStyleChange.js */ \"./src/workflow/mxClient/mxStyleChange.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxLayoutManager(graph) {\n  // Executes the layout before the changes are dispatched\n  this.undoHandler = _mxGraphUtils[\"default\"].bind(this, function (sender, evt) {\n    if (this.isEnabled()) {\n      this.beforeUndo(evt.getProperty('edit'));\n    }\n  });\n\n  // Notifies the layout of a move operation inside a parent\n  this.moveHandler = _mxGraphUtils[\"default\"].bind(this, function (sender, evt) {\n    if (this.isEnabled()) {\n      this.cellsMoved(evt.getProperty('cells'), evt.getProperty('event'));\n    }\n  });\n  this.setGraph(graph);\n}\n;\n\n/**\r\n * Extends mxEventSource.\r\n */\nmxLayoutManager.prototype = new _mxEventSource[\"default\"]();\nmxLayoutManager.prototype.constructor = mxLayoutManager;\n\n/**\r\n * Variable: graph\r\n *\r\n * Reference to the enclosing <mxGraph>.\r\n */\nmxLayoutManager.prototype.graph = null;\n\n/**\r\n * Variable: bubbling\r\n *\r\n * Specifies if the layout should bubble along\r\n * the cell hierarchy. Default is true.\r\n */\nmxLayoutManager.prototype.bubbling = true;\n\n/**\r\n * Variable: enabled\r\n *\r\n * Specifies if event handling is enabled. Default is true.\r\n */\nmxLayoutManager.prototype.enabled = true;\n\n/**\r\n * Variable: updateHandler\r\n *\r\n * Holds the function that handles the endUpdate event.\r\n */\nmxLayoutManager.prototype.updateHandler = null;\n\n/**\r\n * Variable: moveHandler\r\n *\r\n * Holds the function that handles the move event.\r\n */\nmxLayoutManager.prototype.moveHandler = null;\n\n/**\r\n * Function: isEnabled\r\n *\r\n * Returns true if events are handled. This implementation\r\n * returns <enabled>.\r\n */\nmxLayoutManager.prototype.isEnabled = function () {\n  return this.enabled;\n};\n\n/**\r\n * Function: setEnabled\r\n *\r\n * Enables or disables event handling. This implementation\r\n * updates <enabled>.\r\n *\r\n * Parameters:\r\n *\r\n * enabled - Boolean that specifies the new enabled state.\r\n */\nmxLayoutManager.prototype.setEnabled = function (enabled) {\n  this.enabled = enabled;\n};\n\n/**\r\n * Function: isBubbling\r\n *\r\n * Returns true if a layout should bubble, that is, if the parent layout\r\n * should be executed whenever a cell layout (layout of the children of\r\n * a cell) has been executed. This implementation returns <bubbling>.\r\n */\nmxLayoutManager.prototype.isBubbling = function () {\n  return this.bubbling;\n};\n\n/**\r\n * Function: setBubbling\r\n *\r\n * Sets <bubbling>.\r\n */\nmxLayoutManager.prototype.setBubbling = function (value) {\n  this.bubbling = value;\n};\n\n/**\r\n * Function: getGraph\r\n *\r\n * Returns the graph that this layout operates on.\r\n */\nmxLayoutManager.prototype.getGraph = function () {\n  return this.graph;\n};\n\n/**\r\n * Function: setGraph\r\n *\r\n * Sets the graph that the layouts operate on.\r\n */\nmxLayoutManager.prototype.setGraph = function (graph) {\n  if (this.graph != null) {\n    var model = this.graph.getModel();\n    model.removeListener(this.undoHandler);\n    this.graph.removeListener(this.moveHandler);\n  }\n  this.graph = graph;\n  if (this.graph != null) {\n    var model = this.graph.getModel();\n    model.addListener(_mxEvent[\"default\"].BEFORE_UNDO, this.undoHandler);\n    this.graph.addListener(_mxEvent[\"default\"].MOVE_CELLS, this.moveHandler);\n  }\n};\n\n/**\r\n * Function: getLayout\r\n *\r\n * Returns the layout to be executed for the given graph and parent.\r\n */\nmxLayoutManager.prototype.getLayout = function (parent) {\n  return null;\n};\n\n/**\r\n * Function: beforeUndo\r\n *\r\n * Called from the undoHandler.\r\n *\r\n * Parameters:\r\n *\r\n * cell - Array of <mxCells> that have been moved.\r\n * evt - Mouse event that represents the mousedown.\r\n */\nmxLayoutManager.prototype.beforeUndo = function (undoableEdit) {\n  var cells = this.getCellsForChanges(undoableEdit.changes);\n  var model = this.getGraph().getModel();\n\n  // Adds all descendants\n  var tmp = [];\n  for (var i = 0; i < cells.length; i++) {\n    tmp = tmp.concat(model.getDescendants(cells[i]));\n  }\n  cells = tmp;\n\n  // Adds all parent ancestors\n  if (this.isBubbling()) {\n    tmp = model.getParents(cells);\n    while (tmp.length > 0) {\n      cells = cells.concat(tmp);\n      tmp = model.getParents(tmp);\n    }\n  }\n  this.executeLayoutForCells(cells);\n};\n\n/**\r\n * Function: executeLayout\r\n *\r\n * Executes the given layout on the given parent.\r\n */\nmxLayoutManager.prototype.executeLayoutForCells = function (cells) {\n  // Adds reverse to this array to avoid duplicate execution of leafes\n  // Works like capture/bubble for events, first executes all layout\n  // from top to bottom and in reverse order and removes duplicates.\n  var sorted = _mxUtils[\"default\"].sortCells(cells, true);\n  sorted = sorted.concat(sorted.slice().reverse());\n  this.layoutCells(sorted);\n};\n\n/**\r\n * Function: cellsMoved\r\n *\r\n * Called from the moveHandler.\r\n *\r\n * Parameters:\r\n *\r\n * cell - Array of <mxCells> that have been moved.\r\n * evt - Mouse event that represents the mousedown.\r\n */\nmxLayoutManager.prototype.cellsMoved = function (cells, evt) {\n  if (cells != null && evt != null) {\n    var point = _mxUtils[\"default\"].convertPoint(this.getGraph().container, _mxEvent[\"default\"].getClientX(evt), _mxEvent[\"default\"].getClientY(evt));\n    var model = this.getGraph().getModel();\n\n    // Checks if a layout exists to take care of the moving if the\n    // parent itself is not being moved\n    for (var i = 0; i < cells.length; i++) {\n      var parent = model.getParent(cells[i]);\n      if (_mxGraphUtils[\"default\"].indexOf(cells, parent) < 0) {\n        var layout = this.getLayout(parent);\n        if (layout != null) {\n          layout.moveCell(cells[i], point.x, point.y);\n        }\n      }\n    }\n  }\n};\n\n/**\r\n * Function: getCellsForEdit\r\n *\r\n * Returns the cells to be layouted for the given sequence of changes.\r\n */\nmxLayoutManager.prototype.getCellsForChanges = function (changes) {\n  var dict = new _mxDictionary[\"default\"]();\n  var result = [];\n  for (var i = 0; i < changes.length; i++) {\n    var change = changes[i];\n    if (change instanceof _mxRootChange[\"default\"]) {\n      return [];\n    } else {\n      var cells = this.getCellsForChange(change);\n      for (var j = 0; j < cells.length; j++) {\n        if (cells[j] != null && !dict.get(cells[j])) {\n          dict.put(cells[j], true);\n          result.push(cells[j]);\n        }\n      }\n    }\n  }\n  return result;\n};\n\n/**\r\n * Function: getCellsForChange\r\n *\r\n * Executes all layouts which have been scheduled during the\r\n * changes.\r\n */\nmxLayoutManager.prototype.getCellsForChange = function (change) {\n  var model = this.getGraph().getModel();\n  if (change instanceof _mxChildChange[\"default\"]) {\n    return [change.child, change.previous, model.getParent(change.child)];\n  } else if (change instanceof _mxTerminalChange[\"default\"] || change instanceof _mxGeometryChange[\"default\"]) {\n    return [change.cell, model.getParent(change.cell)];\n  } else if (change instanceof _mxVisibleChange[\"default\"] || change instanceof _mxStyleChange[\"default\"]) {\n    return [change.cell];\n  }\n  return [];\n};\n\n/**\r\n * Function: layoutCells\r\n *\r\n * Executes all layouts which have been scheduled during the\r\n * changes.\r\n */\nmxLayoutManager.prototype.layoutCells = function (cells) {\n  if (cells.length > 0) {\n    // Invokes the layouts while removing duplicates\n    var model = this.getGraph().getModel();\n    model.beginUpdate();\n    try {\n      var last = null;\n      for (var i = 0; i < cells.length; i++) {\n        if (cells[i] != model.getRoot() && cells[i] != last) {\n          if (this.executeLayout(this.getLayout(cells[i]), cells[i])) {\n            last = cells[i];\n          }\n        }\n      }\n      this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].LAYOUT_CELLS, 'cells', cells));\n    } finally {\n      model.endUpdate();\n    }\n  }\n};\n\n/**\r\n * Function: executeLayout\r\n *\r\n * Executes the given layout on the given parent.\r\n */\nmxLayoutManager.prototype.executeLayout = function (layout, parent) {\n  var result = false;\n  if (layout != null && parent != null) {\n    layout.execute(parent);\n    result = true;\n  }\n  return result;\n};\n\n/**\r\n * Function: destroy\r\n *\r\n * Removes all handlers from the <graph> and deletes the reference to it.\r\n */\nmxLayoutManager.prototype.destroy = function () {\n  this.setGraph(null);\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxSwimlaneManager\r\n *\r\n * Manager for swimlanes and nested swimlanes that sets the size of newly added\r\n * swimlanes to that of their siblings, and propagates changes to the size of a\r\n * swimlane to its siblings, if <siblings> is true, and its ancestors, if\r\n * <bubbling> is true.\r\n *\r\n * Constructor: mxSwimlaneManager\r\n *\r\n * Constructs a new swimlane manager for the given graph.\r\n *\r\n * Arguments:\r\n *\r\n * graph - Reference to the enclosing graph.\r\n */\nvar _default = exports[\"default\"] = mxLayoutManager;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxLayoutManager.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxLine.js":
/*!*****************************************!*\
  !*** ./src/workflow/mxClient/mxLine.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxShape = _interopRequireDefault(__webpack_require__(/*! ./mxShape.js */ \"./src/workflow/mxClient/mxShape.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxLine(bounds, stroke, strokewidth) {\n  _mxShape[\"default\"].call(this);\n  this.bounds = bounds;\n  this.stroke = stroke;\n  this.strokewidth = strokewidth != null ? strokewidth : 1;\n}\n;\n\n/**\r\n * Extends mxShape.\r\n */\n_mxGraphUtils[\"default\"].extend(mxLine, _mxShape[\"default\"]);\n\n/**\r\n * Function: paintVertexShape\r\n *\r\n * Redirects to redrawPath for subclasses to work.\r\n */\nmxLine.prototype.paintVertexShape = function (c, x, y, w, h) {\n  var mid = y + h / 2;\n  c.begin();\n  c.moveTo(x, mid);\n  c.lineTo(x + w, mid);\n  c.stroke();\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxImageShape\r\n *\r\n * Extends <mxShape> to implement an image shape. This shape is registered\r\n * under <mxConstants.SHAPE_IMAGE> in <mxCellRenderer>.\r\n *\r\n * Constructor: mxImageShape\r\n *\r\n * Constructs a new image shape.\r\n *\r\n * Parameters:\r\n *\r\n * bounds - <mxRectangle> that defines the bounds. This is stored in\r\n * <mxShape.bounds>.\r\n * image - String that specifies the URL of the image. This is stored in\r\n * <image>.\r\n * fill - String that defines the fill color. This is stored in <fill>.\r\n * stroke - String that defines the stroke color. This is stored in <stroke>.\r\n * strokewidth - Optional integer that defines the stroke width. Default is\r\n * 0. This is stored in <strokewidth>.\r\n */\nvar _default = exports[\"default\"] = mxLine;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxLine.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxLog.js":
/*!****************************************!*\
  !*** ./src/workflow/mxClient/mxLog.js ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.index-of.js */ \"../../node_modules/core-js/modules/es.array.index-of.js\");\n__webpack_require__(/*! core-js/modules/es.date.to-string.js */ \"../../node_modules/core-js/modules/es.date.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.object.to-string.js */ \"../../node_modules/core-js/modules/es.object.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.regexp.to-string.js */ \"../../node_modules/core-js/modules/es.regexp.to-string.js\");\nvar _mxClient = _interopRequireDefault(__webpack_require__(/*! ./mxClient.js */ \"./src/workflow/mxClient/mxClient.js\"));\nvar _mxWindow = _interopRequireDefault(__webpack_require__(/*! ./mxWindow.js */ \"./src/workflow/mxClient/mxWindow.js\"));\nvar _mxEventUtils = _interopRequireDefault(__webpack_require__(/*! ./mxEventUtils.js */ \"./src/workflow/mxClient/mxEventUtils.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nvar mxLog = {\n  /**\r\n   * Class: mxLog\r\n   *\r\n   * A singleton class that implements a simple console.\r\n   *\r\n   * Variable: consoleName\r\n   *\r\n   * Specifies the name of the console window. Default is 'Console'.\r\n   */\n  consoleName: 'Console',\n  /**\r\n   * Variable: TRACE\r\n   *\r\n   * Specified if the output for <enter> and <leave> should be visible in the\r\n   * console. Default is false.\r\n   */\n  TRACE: false,\n  /**\r\n   * Variable: DEBUG\r\n   *\r\n   * Specifies if the output for <debug> should be visible in the console.\r\n   * Default is true.\r\n   */\n  DEBUG: true,\n  /**\r\n   * Variable: WARN\r\n   *\r\n   * Specifies if the output for <warn> should be visible in the console.\r\n   * Default is true.\r\n   */\n  WARN: true,\n  /**\r\n   * Variable: buffer\r\n   *\r\n   * Buffer for pre-initialized content.\r\n   */\n  buffer: '',\n  /**\r\n   * Function: init\r\n   *\r\n   * Initializes the DOM node for the console. This requires document.body to\r\n   * point to a non-null value. This is called from within <setVisible> if the\r\n   * log has not yet been initialized.\r\n   */\n  init: function init() {\n    if (mxLog.window == null && document.body != null) {\n      var title = mxLog.consoleName + ' - mxGraph ' + _mxClient[\"default\"].VERSION;\n\n      // Creates a table that maintains the layout\n      var table = document.createElement('table');\n      table.setAttribute('width', '100%');\n      table.setAttribute('height', '100%');\n      var tbody = document.createElement('tbody');\n      var tr = document.createElement('tr');\n      var td = document.createElement('td');\n      td.style.verticalAlign = 'top';\n\n      // Adds the actual console as a textarea\n      mxLog.textarea = document.createElement('textarea');\n      mxLog.textarea.setAttribute('readOnly', 'true');\n      mxLog.textarea.style.height = '100%';\n      mxLog.textarea.style.resize = 'none';\n      mxLog.textarea.value = mxLog.buffer;\n\n      // Workaround for wrong width in standards mode\n      if (_mxClient[\"default\"].IS_NS && document.compatMode != 'BackCompat') {\n        mxLog.textarea.style.width = '99%';\n      } else {\n        mxLog.textarea.style.width = '100%';\n      }\n      td.appendChild(mxLog.textarea);\n      tr.appendChild(td);\n      tbody.appendChild(tr);\n\n      // Creates the container div\n      tr = document.createElement('tr');\n      mxLog.td = document.createElement('td');\n      mxLog.td.style.verticalAlign = 'top';\n      mxLog.td.setAttribute('height', '30px');\n      tr.appendChild(mxLog.td);\n      tbody.appendChild(tr);\n      table.appendChild(tbody);\n\n      // Adds various debugging buttons\n      mxLog.addButton('Info', function (evt) {\n        mxLog.info();\n      });\n      mxLog.addButton('DOM', function (evt) {\n        var content = _mxGraphUtils[\"default\"].getInnerHtml(document.body);\n        mxLog.debug(content);\n      });\n      mxLog.addButton('Trace', function (evt) {\n        mxLog.TRACE = !mxLog.TRACE;\n        if (mxLog.TRACE) {\n          mxLog.debug('Tracing enabled');\n        } else {\n          mxLog.debug('Tracing disabled');\n        }\n      });\n\n      //mxUtils娌℃湁copy鏂规硶\n      /*mxLog.addButton('Copy', function (evt)\r\n      {\r\n      \ttry\r\n      \t{\r\n      \t\tmxGraphUtils.copy(mxLog.textarea.value);\r\n      \t}\r\n      \tcatch (err)\r\n      \t{\r\n      \t\tmxGraphUtils.alert(err);\r\n      \t}\r\n      });*/\n\n      mxLog.addButton('Show', function (evt) {\n        try {\n          _mxGraphUtils[\"default\"].popup(mxLog.textarea.value, null, _mxWindow[\"default\"]);\n        } catch (err) {\n          _mxGraphUtils[\"default\"].alert(err);\n        }\n      });\n      mxLog.addButton('Clear', function (evt) {\n        mxLog.textarea.value = '';\n      });\n\n      // Cross-browser code to get window size\n      var h = 0;\n      var w = 0;\n      if (typeof window.innerWidth === 'number') {\n        h = window.innerHeight;\n        w = window.innerWidth;\n      } else {\n        h = document.documentElement.clientHeight || document.body.clientHeight;\n        w = document.body.clientWidth;\n      }\n      mxLog.window = new _mxWindow[\"default\"](title, table, Math.max(0, w - 320), Math.max(0, h - 210), 300, 160);\n      mxLog.window.setMaximizable(true);\n      mxLog.window.setScrollable(false);\n      mxLog.window.setResizable(true);\n      mxLog.window.setClosable(true);\n      mxLog.window.destroyOnClose = false;\n\n      // Workaround for ignored textarea height in various setups\n      if ((_mxClient[\"default\"].IS_NS || _mxClient[\"default\"].IS_IE) && !_mxClient[\"default\"].IS_GC && !_mxClient[\"default\"].IS_SF && document.compatMode != 'BackCompat' || document.documentMode == 11) {\n        var elt = mxLog.window.getElement();\n        var resizeHandler = function resizeHandler(sender, evt) {\n          mxLog.textarea.style.height = Math.max(0, elt.offsetHeight - 70) + 'px';\n        };\n        mxLog.window.addListener(_mxEventUtils[\"default\"].RESIZE_END, resizeHandler);\n        mxLog.window.addListener(_mxEventUtils[\"default\"].MAXIMIZE, resizeHandler);\n        mxLog.window.addListener(_mxEventUtils[\"default\"].NORMALIZE, resizeHandler);\n        mxLog.textarea.style.height = '92px';\n      }\n    }\n  },\n  /**\r\n   * Function: info\r\n   *\r\n   * Writes the current navigator information to the console.\r\n   */\n  info: function info() {\n    mxLog.writeln(_mxGraphUtils[\"default\"].toString(navigator));\n  },\n  /**\r\n   * Function: addButton\r\n   *\r\n   * Adds a button to the console using the given label and function.\r\n   */\n  addButton: function addButton(lab, funct) {\n    var button = document.createElement('button');\n    _mxGraphUtils[\"default\"].write(button, lab);\n    _mxEventUtils[\"default\"].addListener(button, 'click', funct);\n    mxLog.td.appendChild(button);\n  },\n  /**\r\n   * Function: isVisible\r\n   *\r\n   * Returns true if the console is visible.\r\n   */\n  isVisible: function isVisible() {\n    if (mxLog.window != null) {\n      return mxLog.window.isVisible();\n    }\n    return false;\n  },\n  /**\r\n   * Function: show\r\n   *\r\n   * Shows the console.\r\n   */\n  show: function show() {\n    mxLog.setVisible(true);\n  },\n  /**\r\n   * Function: setVisible\r\n   *\r\n   * Shows or hides the console.\r\n   */\n  setVisible: function setVisible(visible) {\n    if (mxLog.window == null) {\n      mxLog.init();\n    }\n    if (mxLog.window != null) {\n      mxLog.window.setVisible(visible);\n    }\n  },\n  /**\r\n   * Function: enter\r\n   *\r\n   * Writes the specified string to the console\r\n   * if <TRACE> is true and returns the current\r\n   * time in milliseconds.\r\n   *\r\n   * Example:\r\n   *\r\n   * (code)\r\n   * mxLog.show();\r\n   * var t0 = mxLog.enter('Hello');\r\n   * // Do something\r\n   * mxLog.leave('World!', t0);\r\n   * (end)\r\n   */\n  enter: function enter(string) {\n    if (mxLog.TRACE) {\n      mxLog.writeln('Entering ' + string);\n      return new Date().getTime();\n    }\n  },\n  /**\r\n   * Function: leave\r\n   *\r\n   * Writes the specified string to the console\r\n   * if <TRACE> is true and computes the difference\r\n   * between the current time and t0 in milliseconds.\r\n   * See <enter> for an example.\r\n   */\n  leave: function leave(string, t0) {\n    if (mxLog.TRACE) {\n      var dt = t0 != 0 ? ' (' + (new Date().getTime() - t0) + ' ms)' : '';\n      mxLog.writeln('Leaving ' + string + dt);\n    }\n  },\n  /**\r\n   * Function: debug\r\n   *\r\n   * Adds all arguments to the console if <DEBUG> is enabled.\r\n   *\r\n   * Example:\r\n   *\r\n   * (code)\r\n   * mxLog.show();\r\n   * mxLog.debug('Hello, World!');\r\n   * (end)\r\n   */\n  debug: function debug() {\n    if (mxLog.DEBUG) {\n      mxLog.writeln.apply(this, arguments);\n    }\n  },\n  /**\r\n   * Function: warn\r\n   *\r\n   * Adds all arguments to the console if <WARN> is enabled.\r\n   *\r\n   * Example:\r\n   *\r\n   * (code)\r\n   * mxLog.show();\r\n   * mxLog.warn('Hello, World!');\r\n   * (end)\r\n   */\n  warn: function warn() {\n    if (mxLog.WARN) {\n      mxLog.writeln.apply(this, arguments);\n    }\n  },\n  /**\r\n   * Function: write\r\n   *\r\n   * Adds the specified strings to the console.\r\n   */\n  write: function write() {\n    var string = '';\n    for (var i = 0; i < arguments.length; i++) {\n      string += arguments[i];\n      if (i < arguments.length - 1) {\n        string += ' ';\n      }\n    }\n    if (mxLog.textarea != null) {\n      mxLog.textarea.value = mxLog.textarea.value + string;\n\n      // Workaround for no update in Presto 2.5.22 (Opera 10.5)\n      if (navigator.userAgent.indexOf('Presto/2.5') >= 0) {\n        mxLog.textarea.style.visibility = 'hidden';\n        mxLog.textarea.style.visibility = 'visible';\n      }\n      mxLog.textarea.scrollTop = mxLog.textarea.scrollHeight;\n    } else {\n      mxLog.buffer += string;\n    }\n  },\n  /**\r\n   * Function: writeln\r\n   *\r\n   * Adds the specified strings to the console, appending a linefeed at the\r\n   * end of each string.\r\n   */\n  writeln: function writeln() {\n    var string = '';\n    for (var i = 0; i < arguments.length; i++) {\n      string += arguments[i];\n      if (i < arguments.length - 1) {\n        string += ' ';\n      }\n    }\n    mxLog.write(string + '\\n');\n  }\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\nvar _default = exports[\"default\"] = mxLog;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxLog.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxMarker.js":
/*!*******************************************!*\
  !*** ./src/workflow/mxClient/mxMarker.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ./mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nvar mxMarker = {\n  /**\r\n   * Class: mxMarker\r\n   *\r\n   * A static class that implements all markers for VML and SVG using a\r\n   * registry. NOTE: The signatures in this class will change.\r\n   *\r\n   * Variable: markers\r\n   *\r\n   * Maps from markers names to functions to paint the markers.\r\n   */\n  markers: [],\n  /**\r\n   * Function: addMarker\r\n   *\r\n   * Adds a factory method that updates a given endpoint and returns a\r\n   * function to paint the marker onto the given canvas.\r\n   */\n  addMarker: function addMarker(type, funct) {\n    mxMarker.markers[type] = funct;\n  },\n  /**\r\n   * Function: createMarker\r\n   *\r\n   * Returns a function to paint the given marker.\r\n   */\n  createMarker: function createMarker(canvas, shape, type, pe, unitX, unitY, size, source, sw, filled) {\n    var funct = mxMarker.markers[type];\n    return funct != null ? funct(canvas, shape, type, pe, unitX, unitY, size, source, sw, filled) : null;\n  }\n};\n\n/**\r\n * Adds the classic and block marker factory method.\r\n */\n(function () {\n  function createArrow(widthFactor) {\n    widthFactor = widthFactor != null ? widthFactor : 2;\n    return function (canvas, shape, type, pe, unitX, unitY, size, source, sw, filled) {\n      // The angle of the forward facing arrow sides against the x axis is\n      // 26.565 degrees, 1/sin(26.565) = 2.236 / 2 = 1.118 ( / 2 allows for\n      // only half the strokewidth is processed ).\n      var endOffsetX = unitX * sw * 1.118;\n      var endOffsetY = unitY * sw * 1.118;\n      unitX = unitX * (size + sw);\n      unitY = unitY * (size + sw);\n      var pt = pe.clone();\n      pt.x -= endOffsetX;\n      pt.y -= endOffsetY;\n      var f = type != _mxConstants[\"default\"].ARROW_CLASSIC && type != _mxConstants[\"default\"].ARROW_CLASSIC_THIN ? 1 : 3 / 4;\n      pe.x += -unitX * f - endOffsetX;\n      pe.y += -unitY * f - endOffsetY;\n      return function () {\n        canvas.begin();\n        canvas.moveTo(pt.x, pt.y);\n        canvas.lineTo(pt.x - unitX - unitY / widthFactor, pt.y - unitY + unitX / widthFactor);\n        if (type == _mxConstants[\"default\"].ARROW_CLASSIC || type == _mxConstants[\"default\"].ARROW_CLASSIC_THIN) {\n          canvas.lineTo(pt.x - unitX * 3 / 4, pt.y - unitY * 3 / 4);\n        }\n        canvas.lineTo(pt.x + unitY / widthFactor - unitX, pt.y - unitY - unitX / widthFactor);\n        canvas.close();\n        if (filled) {\n          canvas.fillAndStroke();\n        } else {\n          canvas.stroke();\n        }\n      };\n    };\n  }\n  ;\n  mxMarker.addMarker('classic', createArrow(2));\n  mxMarker.addMarker('classicThin', createArrow(3));\n  mxMarker.addMarker('block', createArrow(2));\n  mxMarker.addMarker('blockThin', createArrow(3));\n  function createOpenArrow(widthFactor) {\n    widthFactor = widthFactor != null ? widthFactor : 2;\n    return function (canvas, shape, type, pe, unitX, unitY, size, source, sw, filled) {\n      // The angle of the forward facing arrow sides against the x axis is\n      // 26.565 degrees, 1/sin(26.565) = 2.236 / 2 = 1.118 ( / 2 allows for\n      // only half the strokewidth is processed ).\n      var endOffsetX = unitX * sw * 1.118;\n      var endOffsetY = unitY * sw * 1.118;\n      unitX = unitX * (size + sw);\n      unitY = unitY * (size + sw);\n      var pt = pe.clone();\n      pt.x -= endOffsetX;\n      pt.y -= endOffsetY;\n      pe.x += -endOffsetX * 2;\n      pe.y += -endOffsetY * 2;\n      return function () {\n        canvas.begin();\n        canvas.moveTo(pt.x - unitX - unitY / widthFactor, pt.y - unitY + unitX / widthFactor);\n        canvas.lineTo(pt.x, pt.y);\n        canvas.lineTo(pt.x + unitY / widthFactor - unitX, pt.y - unitY - unitX / widthFactor);\n        canvas.stroke();\n      };\n    };\n  }\n  ;\n  mxMarker.addMarker('open', createOpenArrow(2));\n  mxMarker.addMarker('openThin', createOpenArrow(3));\n  mxMarker.addMarker('oval', function (canvas, shape, type, pe, unitX, unitY, size, source, sw, filled) {\n    var a = size / 2;\n    var pt = pe.clone();\n    pe.x -= unitX * a;\n    pe.y -= unitY * a;\n    return function () {\n      canvas.ellipse(pt.x - a, pt.y - a, size, size);\n      if (filled) {\n        canvas.fillAndStroke();\n      } else {\n        canvas.stroke();\n      }\n    };\n  });\n  function diamond(canvas, shape, type, pe, unitX, unitY, size, source, sw, filled) {\n    // The angle of the forward facing arrow sides against the x axis is\n    // 45 degrees, 1/sin(45) = 1.4142 / 2 = 0.7071 ( / 2 allows for\n    // only half the strokewidth is processed ). Or 0.9862 for thin diamond.\n    // Note these values and the tk variable below are dependent, update\n    // both together (saves trig hard coding it).\n    var isTriangle = type === _mxConstants[\"default\"].ARROW_TRIANGLE;\n    var swFactor = type == _mxConstants[\"default\"].ARROW_DIAMOND || isTriangle ? 0.7071 : 0.9862;\n    var endOffsetX = unitX * sw * swFactor;\n    var endOffsetY = unitY * sw * swFactor;\n    unitX = unitX * (size + sw);\n    unitY = unitY * (size + sw);\n    var pt = pe.clone();\n    pt.x -= endOffsetX;\n    pt.y -= endOffsetY;\n    pe.x += (isTriangle ? 0 : -unitX) - endOffsetX;\n    pe.y += (isTriangle ? 0 : -unitY) - endOffsetY;\n\n    // thickness factor for diamond\n    var tk = type == _mxConstants[\"default\"].ARROW_DIAMOND || isTriangle ? 2 : 3.4;\n    return function () {\n      canvas.begin();\n      canvas.moveTo(pt.x, pt.y);\n      canvas.lineTo(pt.x - unitX / 2 - unitY / tk, pt.y + unitX / tk - unitY / 2);\n      !isTriangle && canvas.lineTo(pt.x - unitX, pt.y - unitY);\n      canvas.lineTo(pt.x - unitX / 2 + unitY / tk, pt.y - unitY / 2 - unitX / tk);\n      canvas.close();\n      if (filled) {\n        canvas.fillAndStroke();\n      } else {\n        canvas.stroke();\n      }\n    };\n  }\n  ;\n  mxMarker.addMarker('diamond', diamond);\n  mxMarker.addMarker('diamondThin', diamond);\n  mxMarker.addMarker(_mxConstants[\"default\"].ARROW_TRIANGLE, diamond);\n})();\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxActor\r\n *\r\n * Extends <mxShape> to implement an actor shape. If a custom shape with one\r\n * filled area is needed, then this shape's <redrawPath> should be overridden.\r\n *\r\n * Example:\r\n *\r\n * (code)\r\n\r\n * function SampleShape() { }\r\n *\r\n * SampleShape.prototype = new mxActor();\r\n * SampleShape.prototype.constructor = vsAseShape;\r\n *\r\n * mxCellRenderer.prototype.defaultShapes['sample'] = SampleShape;\r\n * SampleShape.prototype.redrawPath = function(path, x, y, w, h)\r\n * {\r\n *   path.moveTo(0, 0);\r\n *   path.lineTo(w, h);\r\n *   // ...\r\n *   path.close();\r\n * }\r\n * (end)\r\n *\r\n * This shape is registered under <mxConstants.SHAPE_ACTOR> in\r\n * <mxCellRenderer>.\r\n *\r\n * Constructor: mxActor\r\n *\r\n * Constructs a new actor shape.\r\n *\r\n * Parameters:\r\n *\r\n * bounds - <mxRectangle> that defines the bounds. This is stored in\r\n * <mxShape.bounds>.\r\n * fill - String that defines the fill color. This is stored in <fill>.\r\n * stroke - String that defines the stroke color. This is stored in <stroke>.\r\n * strokewidth - Optional integer that defines the stroke width. Default is\r\n * 1. This is stored in <strokewidth>.\r\n */\nvar _default = exports[\"default\"] = mxMarker;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxMarker.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxMorphing.js":
/*!*********************************************!*\
  !*** ./src/workflow/mxClient/mxMorphing.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _mxPoint = _interopRequireDefault(__webpack_require__(/*! ./mxPoint.js */ \"./src/workflow/mxClient/mxPoint.js\"));\nvar _mxCellStatePreview = _interopRequireDefault(__webpack_require__(/*! ./mxCellStatePreview.js */ \"./src/workflow/mxClient/mxCellStatePreview.js\"));\nvar _mxAnimation = _interopRequireDefault(__webpack_require__(/*! ./mxAnimation.js */ \"./src/workflow/mxClient/mxAnimation.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxMorphing(graph, steps, ease, delay) {\n  _mxAnimation[\"default\"].call(this, delay);\n  this.graph = graph;\n  this.steps = steps != null ? steps : 6;\n  this.ease = ease != null ? ease : 1.5;\n}\n;\n\n/**\r\n * Extends mxEventSource.\r\n */\nmxMorphing.prototype = new _mxAnimation[\"default\"]();\nmxMorphing.prototype.constructor = mxMorphing;\n\n/**\r\n * Variable: graph\r\n *\r\n * Specifies the delay between the animation steps. Defaul is 30ms.\r\n */\nmxMorphing.prototype.graph = null;\n\n/**\r\n * Variable: steps\r\n *\r\n * Specifies the maximum number of steps for the morphing.\r\n */\nmxMorphing.prototype.steps = null;\n\n/**\r\n * Variable: step\r\n *\r\n * Contains the current step.\r\n */\nmxMorphing.prototype.step = 0;\n\n/**\r\n * Variable: ease\r\n *\r\n * Ease-off for movement towards the given vector. Larger values are\r\n * slower and smoother. Default is 4.\r\n */\nmxMorphing.prototype.ease = null;\n\n/**\r\n * Variable: cells\r\n *\r\n * Optional array of cells to be animated. If this is not specified\r\n * then all cells are checked and animated if they have been moved\r\n * in the current transaction.\r\n */\nmxMorphing.prototype.cells = null;\n\n/**\r\n * Function: updateAnimation\r\n *\r\n * Animation step.\r\n */\nmxMorphing.prototype.updateAnimation = function () {\n  var move = new _mxCellStatePreview[\"default\"](this.graph);\n  if (this.cells != null) {\n    // Animates the given cells individually without recursion\n    for (var i = 0; i < this.cells.length; i++) {\n      this.animateCell(this.cells[i], move, false);\n    }\n  } else {\n    // Animates all changed cells by using recursion to find\n    // the changed cells but not for the animation itself\n    this.animateCell(this.graph.getModel().getRoot(), move, true);\n  }\n  this.show(move);\n  if (move.isEmpty() || this.step++ >= this.steps) {\n    this.stopAnimation();\n  }\n};\n\n/**\r\n * Function: show\r\n *\r\n * Shows the changes in the given <mxCellStatePreview>.\r\n */\nmxMorphing.prototype.show = function (move) {\n  move.show();\n};\n\n/**\r\n * Function: animateCell\r\n *\r\n * Animates the given cell state using <mxCellStatePreview.moveState>.\r\n */\nmxMorphing.prototype.animateCell = function (cell, move, recurse) {\n  var state = this.graph.getView().getState(cell);\n  var delta = null;\n  if (state != null) {\n    // Moves the animated state from where it will be after the model\n    // change by subtracting the given delta vector from that location\n    delta = this.getDelta(state);\n    if (this.graph.getModel().isVertex(cell) && (delta.x != 0 || delta.y != 0)) {\n      var translate = this.graph.view.getTranslate();\n      var scale = this.graph.view.getScale();\n      delta.x += translate.x * scale;\n      delta.y += translate.y * scale;\n      move.moveState(state, -delta.x / this.ease, -delta.y / this.ease);\n    }\n  }\n  if (recurse && !this.stopRecursion(state, delta)) {\n    var childCount = this.graph.getModel().getChildCount(cell);\n    for (var i = 0; i < childCount; i++) {\n      this.animateCell(this.graph.getModel().getChildAt(cell, i), move, recurse);\n    }\n  }\n};\n\n/**\r\n * Function: stopRecursion\r\n *\r\n * Returns true if the animation should not recursively find more\r\n * deltas for children if the given parent state has been animated.\r\n */\nmxMorphing.prototype.stopRecursion = function (state, delta) {\n  return delta != null && (delta.x != 0 || delta.y != 0);\n};\n\n/**\r\n * Function: getDelta\r\n *\r\n * Returns the vector between the current rendered state and the future\r\n * location of the state after the display will be updated.\r\n */\nmxMorphing.prototype.getDelta = function (state) {\n  var origin = this.getOriginForCell(state.cell);\n  var translate = this.graph.getView().getTranslate();\n  var scale = this.graph.getView().getScale();\n  var x = state.x / scale - translate.x;\n  var y = state.y / scale - translate.y;\n  return new _mxPoint[\"default\"]((origin.x - x) * scale, (origin.y - y) * scale);\n};\n\n/**\r\n * Function: getOriginForCell\r\n *\r\n * Returns the top, left corner of the given cell. TODO: Improve performance\r\n * by using caching inside this method as the result per cell never changes\r\n * during the lifecycle of this object.\r\n */\nmxMorphing.prototype.getOriginForCell = function (cell) {\n  var result = null;\n  if (cell != null) {\n    var parent = this.graph.getModel().getParent(cell);\n    var geo = this.graph.getCellGeometry(cell);\n    result = this.getOriginForCell(parent);\n\n    // TODO: Handle offsets\n    if (geo != null) {\n      if (geo.relative) {\n        var pgeo = this.graph.getCellGeometry(parent);\n        if (pgeo != null) {\n          result.x += geo.x * pgeo.width;\n          result.y += geo.y * pgeo.height;\n        }\n      } else {\n        result.x += geo.x;\n        result.y += geo.y;\n      }\n    }\n  }\n  if (result == null) {\n    var t = this.graph.view.getTranslate();\n    result = new _mxPoint[\"default\"](-t.x, -t.y);\n  }\n  return result;\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxImageBundle\r\n *\r\n * Maps from keys to base64 encoded images or file locations. All values must\r\n * be URLs or use the format data:image/format followed by a comma and the base64\r\n * encoded image data, eg. \"data:image/gif,XYZ\", where XYZ is the base64 encoded\r\n * image data.\r\n *\r\n * To add a new image bundle to an existing graph, the following code is used:\r\n *\r\n * (code)\r\n * var bundle = new mxImageBundle(alt);\r\n * bundle.putImage('myImage', 'data:image/gif,R0lGODlhEAAQAMIGAAAAAICAAICAgP' +\r\n *   '//AOzp2O3r2////////yH+FUNyZWF0ZWQgd2l0aCBUaGUgR0lNUAAh+QQBCgAHACwAAAAA' +\r\n *   'EAAQAAADTXi63AowynnAMDfjPUDlnAAJhmeBFxAEloliKltWmiYCQvfVr6lBPB1ggxN1hi' +\r\n *   'laSSASFQpIV5HJBDyHpqK2ejVRm2AAgZCdmCGO9CIBADs=', fallback);\r\n * bundle.putImage('mySvgImage', 'data:image/svg+xml,' + encodeURIComponent(\r\n *   '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100%\" height=\"100%\">' +\r\n *   '<linearGradient id=\"gradient\"><stop offset=\"10%\" stop-color=\"#F00\"/>' +\r\n *   '<stop offset=\"90%\" stop-color=\"#fcc\"/></linearGradient>' +\r\n *   '<rect fill=\"url(#gradient)\" width=\"100%\" height=\"100%\"/></svg>'), fallback);\r\n * graph.addImageBundle(bundle);\r\n * (end);\r\n *\r\n * Alt is an optional boolean (default is false) that specifies if the value\r\n * or the fallback should be returned in <getImage>.\r\n *\r\n * The image can then be referenced in any cell style using image=myImage.\r\n * If you are using mxOutline, you should use the same image bundles in the\r\n * graph that renders the outline.\r\n *\r\n * The keys for images are resolved in <mxGraph.postProcessCellStyle> and\r\n * turned into a data URI if the returned value has a short data URI format\r\n * as specified above.\r\n *\r\n * A typical value for the fallback is a MTHML link as defined in RFC 2557.\r\n * Note that this format requires a file to be dynamically created on the\r\n * server-side, or the page that contains the graph to be modified to contain\r\n * the resources, this can be done by adding a comment that contains the\r\n * resource in the HEAD section of the page after the title tag.\r\n *\r\n * This type of fallback mechanism should be used in IE6 and IE7. IE8 does\r\n * support data URIs, but the maximum size is limited to 32 KB, which means\r\n * all data URIs should be limited to 32 KB.\r\n */\nvar _default = exports[\"default\"] = mxMorphing;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxMorphing.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxMouseEvent.js":
/*!***********************************************!*\
  !*** ./src/workflow/mxClient/mxMouseEvent.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _mxClient = _interopRequireDefault(__webpack_require__(/*! ./mxClient.js */ \"./src/workflow/mxClient/mxClient.js\"));\nvar _mxEventUtils = _interopRequireDefault(__webpack_require__(/*! ./mxEventUtils.js */ \"./src/workflow/mxClient/mxEventUtils.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxMouseEvent(evt, state) {\n  this.evt = evt;\n  this.state = state;\n  this.sourceState = state;\n}\n;\n\n/**\r\n * Variable: consumed\r\n *\r\n * Holds the consumed state of this event.\r\n */\nmxMouseEvent.prototype.consumed = false;\n\n/**\r\n * Variable: evt\r\n *\r\n * Holds the inner event object.\r\n */\nmxMouseEvent.prototype.evt = null;\n\n/**\r\n * Variable: graphX\r\n *\r\n * Holds the x-coordinate of the event in the graph. This value is set in\r\n * <mxGraph.fireMouseEvent>.\r\n */\nmxMouseEvent.prototype.graphX = null;\n\n/**\r\n * Variable: graphY\r\n *\r\n * Holds the y-coordinate of the event in the graph. This value is set in\r\n * <mxGraph.fireMouseEvent>.\r\n */\nmxMouseEvent.prototype.graphY = null;\n\n/**\r\n * Variable: state\r\n *\r\n * Holds the optional <mxCellState> associated with this event.\r\n */\nmxMouseEvent.prototype.state = null;\n\n/**\r\n * Variable: sourceState\r\n *\r\n * Holds the <mxCellState> that was passed to the constructor. This can be\r\n * different from <state> depending on the result of <mxGraph.getEventState>.\r\n */\nmxMouseEvent.prototype.sourceState = null;\n\n/**\r\n * Function: getEvent\r\n *\r\n * Returns <evt>.\r\n */\nmxMouseEvent.prototype.getEvent = function () {\n  return this.evt;\n};\n\n/**\r\n * Function: getSource\r\n *\r\n * Returns the target DOM element using <mxEventUtils.getSource> for <evt>.\r\n */\nmxMouseEvent.prototype.getSource = function () {\n  return _mxEventUtils[\"default\"].getSource(this.evt);\n};\n\n/**\r\n * Function: isSource\r\n *\r\n * Returns true if the given <mxShape> is the source of <evt>.\r\n */\nmxMouseEvent.prototype.isSource = function (shape) {\n  if (shape != null) {\n    return _mxGraphUtils[\"default\"].isAncestorNode(shape.node, this.getSource());\n  }\n  return false;\n};\n\n/**\r\n * Function: getX\r\n *\r\n * Returns <evt.clientX>.\r\n */\nmxMouseEvent.prototype.getX = function () {\n  return _mxEventUtils[\"default\"].getClientX(this.getEvent());\n};\n\n/**\r\n * Function: getY\r\n *\r\n * Returns <evt.clientY>.\r\n */\nmxMouseEvent.prototype.getY = function () {\n  return _mxEventUtils[\"default\"].getClientY(this.getEvent());\n};\n\n/**\r\n * Function: getGraphX\r\n *\r\n * Returns <graphX>.\r\n */\nmxMouseEvent.prototype.getGraphX = function () {\n  return this.graphX;\n};\n\n/**\r\n * Function: getGraphY\r\n *\r\n * Returns <graphY>.\r\n */\nmxMouseEvent.prototype.getGraphY = function () {\n  return this.graphY;\n};\n\n/**\r\n * Function: getState\r\n *\r\n * Returns <state>.\r\n */\nmxMouseEvent.prototype.getState = function () {\n  return this.state;\n};\n\n/**\r\n * Function: getCell\r\n *\r\n * Returns the <mxCell> in <state> is not null.\r\n */\nmxMouseEvent.prototype.getCell = function () {\n  var state = this.getState();\n  if (state != null) {\n    return state.cell;\n  }\n  return null;\n};\n\n/**\r\n * Function: isPopupTrigger\r\n *\r\n * Returns true if the event is a popup trigger.\r\n */\nmxMouseEvent.prototype.isPopupTrigger = function () {\n  return _mxEventUtils[\"default\"].isPopupTrigger(this.getEvent());\n};\n\n/**\r\n * Function: isConsumed\r\n *\r\n * Returns <consumed>.\r\n */\nmxMouseEvent.prototype.isConsumed = function () {\n  return this.consumed;\n};\n\n/**\r\n * Function: consume\r\n *\r\n * Sets <consumed> to true and invokes preventDefault on the native event\r\n * if such a method is defined. This is used mainly to avoid the cursor from\r\n * being changed to a text cursor in Webkit. You can use the preventDefault\r\n * flag to disable this functionality.\r\n *\r\n * Parameters:\r\n *\r\n * preventDefault - Specifies if the native event should be canceled. Default\r\n * is true.\r\n */\nmxMouseEvent.prototype.consume = function (preventDefault) {\n  preventDefault = preventDefault != null ? preventDefault : true;\n  if (preventDefault && this.evt.preventDefault) {\n    this.evt.preventDefault();\n  }\n\n  // Workaround for images being dragged in IE\n  // Does not change returnValue in Opera\n  if (_mxClient[\"default\"].IS_IE) {\n    this.evt.returnValue = true;\n  }\n\n  // Sets local consumed state\n  this.consumed = true;\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxEventSource\r\n *\r\n * Base class for objects that dispatch named events. To create a subclass that\r\n * inherits from mxEventSource, the following code is used.\r\n *\r\n * (code)\r\n * function MyClass() { };\r\n *\r\n * MyClass.prototype = new mxEventSource();\r\n * MyClass.prototype.constructor = MyClass;\r\n * (end)\r\n *\r\n * Known Subclasses:\r\n *\r\n * <mxGraphModel>, <mxGraph>, <mxGraphView>, <mxEditor>, <mxCellOverlay>,\r\n * <mxToolbar>, <mxWindow>\r\n *\r\n * Constructor: mxEventSource\r\n *\r\n * Constructs a new event source.\r\n */\nvar _default = exports[\"default\"] = mxMouseEvent;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxMouseEvent.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxObjectCodec.js":
/*!************************************************!*\
  !*** ./src/workflow/mxClient/mxObjectCodec.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.symbol.js */ \"../../node_modules/core-js/modules/es.symbol.js\");\n__webpack_require__(/*! core-js/modules/es.symbol.description.js */ \"../../node_modules/core-js/modules/es.symbol.description.js\");\n__webpack_require__(/*! core-js/modules/es.symbol.iterator.js */ \"../../node_modules/core-js/modules/es.symbol.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.array.iterator.js */ \"../../node_modules/core-js/modules/es.array.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\n__webpack_require__(/*! core-js/modules/es.object.to-string.js */ \"../../node_modules/core-js/modules/es.object.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.string.iterator.js */ \"../../node_modules/core-js/modules/es.string.iterator.js\");\n__webpack_require__(/*! core-js/modules/web.dom-collections.iterator.js */ \"../../node_modules/core-js/modules/web.dom-collections.iterator.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.index-of.js */ \"../../node_modules/core-js/modules/es.array.index-of.js\");\n__webpack_require__(/*! core-js/modules/es.array.reverse.js */ \"../../node_modules/core-js/modules/es.array.reverse.js\");\n__webpack_require__(/*! core-js/modules/es.parse-float.js */ \"../../node_modules/core-js/modules/es.parse-float.js\");\nvar _mxCell = _interopRequireDefault(__webpack_require__(/*! ./mxCell.js */ \"./src/workflow/mxClient/mxCell.js\"));\nvar _mxChildChange = _interopRequireDefault(__webpack_require__(/*! ./mxChildChange.js */ \"./src/workflow/mxClient/mxChildChange.js\"));\nvar _mxRootChange = _interopRequireDefault(__webpack_require__(/*! ./mxRootChange.js */ \"./src/workflow/mxClient/mxRootChange.js\"));\nvar _mxGraphModel = _interopRequireDefault(__webpack_require__(/*! ./mxGraphModel.js */ \"./src/workflow/mxClient/mxGraphModel.js\"));\nvar _mxObjectIdentity = _interopRequireDefault(__webpack_require__(/*! ./mxObjectIdentity.js */ \"./src/workflow/mxClient/mxObjectIdentity.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxTerminalChange = _interopRequireDefault(__webpack_require__(/*! ./mxTerminalChange.js */ \"./src/workflow/mxClient/mxTerminalChange.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ./mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nvar _mxGeometry = _interopRequireDefault(__webpack_require__(/*! ./mxGeometry */ \"./src/workflow/mxClient/mxGeometry.js\"));\nvar _mxRequestUtils = _interopRequireDefault(__webpack_require__(/*! ./mxRequestUtils.js */ \"./src/workflow/mxClient/mxRequestUtils.js\"));\nvar _mxStencilRegistry = _interopRequireDefault(__webpack_require__(/*! ./mxStencilRegistry */ \"./src/workflow/mxClient/mxStencilRegistry.js\"));\nvar _mxLog = _interopRequireDefault(__webpack_require__(/*! ./mxLog.js */ \"./src/workflow/mxClient/mxLog.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction mxObjectCodec(template, exclude, idrefs, mapping) {\n  this.template = template;\n  this.exclude = exclude != null ? exclude : [];\n  this.idrefs = idrefs != null ? idrefs : [];\n  this.mapping = mapping != null ? mapping : [];\n  this.reverse = new Object();\n  for (var i in this.mapping) {\n    this.reverse[this.mapping[i]] = i;\n  }\n}\n;\n\n/**\r\n * Variable: allowEval\r\n *\r\n * Static global switch that specifies if expressions in arrays are allowed.\r\n * Default is false. NOTE: Enabling this carries a possible security risk.\r\n */\nmxObjectCodec.allowEval = false;\n\n/**\r\n * Variable: template\r\n *\r\n * Holds the template object associated with this codec.\r\n */\nmxObjectCodec.prototype.template = null;\n\n/**\r\n * Variable: exclude\r\n *\r\n * Array containing the variable names that should be\r\n * ignored by the codec.\r\n */\nmxObjectCodec.prototype.exclude = null;\n\n/**\r\n * Variable: idrefs\r\n *\r\n * Array containing the variable names that should be\r\n * turned into or converted from references. See\r\n * <mxCodec.getId> and <mxCodec.getObject>.\r\n */\nmxObjectCodec.prototype.idrefs = null;\n\n/**\r\n * Variable: mapping\r\n *\r\n * Maps from from fieldnames to XML attribute names.\r\n */\nmxObjectCodec.prototype.mapping = null;\n\n/**\r\n * Variable: reverse\r\n *\r\n * Maps from from XML attribute names to fieldnames.\r\n */\nmxObjectCodec.prototype.reverse = null;\n\n/**\r\n * Function: getName\r\n *\r\n * Returns the name used for the nodenames and lookup of the codec when\r\n * classes are encoded and nodes are decoded. For classes to work with\r\n * this the codec registry automatically adds an alias for the classname\r\n * if that is different than what this returns. The default implementation\r\n * returns the classname of the template class.\r\n */\nmxObjectCodec.prototype.getName = function () {\n  return _mxGraphUtils[\"default\"].getFunctionName(this.template.constructor);\n};\n\n/**\r\n * Function: cloneTemplate\r\n *\r\n * Returns a new instance of the template for this codec.\r\n */\nmxObjectCodec.prototype.cloneTemplate = function () {\n  return new this.template.constructor();\n};\n\n/**\r\n * Function: getFieldName\r\n *\r\n * Returns the fieldname for the given attributename.\r\n * Looks up the value in the <reverse> mapping or returns\r\n * the input if there is no reverse mapping for the\r\n * given name.\r\n */\nmxObjectCodec.prototype.getFieldName = function (attributename) {\n  if (attributename != null) {\n    var mapped = this.reverse[attributename];\n    if (mapped != null) {\n      attributename = mapped;\n    }\n  }\n  return attributename;\n};\n\n/**\r\n * Function: getAttributeName\r\n *\r\n * Returns the attributename for the given fieldname.\r\n * Looks up the value in the <mapping> or returns\r\n * the input if there is no mapping for the\r\n * given name.\r\n */\nmxObjectCodec.prototype.getAttributeName = function (fieldname) {\n  if (fieldname != null) {\n    var mapped = this.mapping[fieldname];\n    if (mapped != null) {\n      fieldname = mapped;\n    }\n  }\n  return fieldname;\n};\n\n/**\r\n * Function: isExcluded\r\n *\r\n * Returns true if the given attribute is to be ignored by the codec. This\r\n * implementation returns true if the given fieldname is in <exclude> or\r\n * if the fieldname equals <mxObjectIdentity.FIELD_NAME>.\r\n *\r\n * Parameters:\r\n *\r\n * obj - Object instance that contains the field.\r\n * attr - Fieldname of the field.\r\n * value - Value of the field.\r\n * write - Boolean indicating if the field is being encoded or decoded.\r\n * Write is true if the field is being encoded, else it is being decoded.\r\n */\nmxObjectCodec.prototype.isExcluded = function (obj, attr, value, write) {\n  return attr == _mxObjectIdentity[\"default\"].FIELD_NAME || _mxGraphUtils[\"default\"].indexOf(this.exclude, attr) >= 0;\n};\n\n/**\r\n * Function: isReference\r\n *\r\n * Returns true if the given fieldname is to be treated\r\n * as a textual reference (ID). This implementation returns\r\n * true if the given fieldname is in <idrefs>.\r\n *\r\n * Parameters:\r\n *\r\n * obj - Object instance that contains the field.\r\n * attr - Fieldname of the field.\r\n * value - Value of the field.\r\n * write - Boolean indicating if the field is being encoded or decoded.\r\n * Write is true if the field is being encoded, else it is being decoded.\r\n */\nmxObjectCodec.prototype.isReference = function (obj, attr, value, write) {\n  return _mxGraphUtils[\"default\"].indexOf(this.idrefs, attr) >= 0;\n};\n\n/**\r\n * Function: encode\r\n *\r\n * Encodes the specified object and returns a node\r\n * representing then given object. Calls <beforeEncode>\r\n * after creating the node and <afterEncode> with the\r\n * resulting node after processing.\r\n *\r\n * Enc is a reference to the calling encoder. It is used\r\n * to encode complex objects and create references.\r\n *\r\n * This implementation encodes all variables of an\r\n * object according to the following rules:\r\n *\r\n * - If the variable name is in <exclude> then it is ignored.\r\n * - If the variable name is in <idrefs> then <mxCodec.getId>\r\n * is used to replace the object with its ID.\r\n * - The variable name is mapped using <mapping>.\r\n * - If obj is an array and the variable name is numeric\r\n * (ie. an index) then it is not encoded.\r\n * - If the value is an object, then the codec is used to\r\n * create a child node with the variable name encoded into\r\n * the \"as\" attribute.\r\n * - Else, if <encodeDefaults> is true or the value differs\r\n * from the template value, then ...\r\n * - ... if obj is not an array, then the value is mapped to\r\n * an attribute.\r\n * - ... else if obj is an array, the value is mapped to an\r\n * add child with a value attribute or a text child node,\r\n * if the value is a function.\r\n *\r\n * If no ID exists for a variable in <idrefs> or if an object\r\n * cannot be encoded, a warning is issued using <mxLog.warn>.\r\n *\r\n * Returns the resulting XML node that represents the given\r\n * object.\r\n *\r\n * Parameters:\r\n *\r\n * enc - <mxCodec> that controls the encoding process.\r\n * obj - Object to be encoded.\r\n */\nmxObjectCodec.prototype.encode = function (enc, obj) {\n  var node = enc.document.createElement(this.getName());\n  obj = this.beforeEncode(enc, obj, node);\n  this.encodeObject(enc, obj, node);\n  return this.afterEncode(enc, obj, node);\n};\n\n/**\r\n * Function: encodeObject\r\n *\r\n * Encodes the value of each member in then given obj into the given node using\r\n * <encodeValue>.\r\n *\r\n * Parameters:\r\n *\r\n * enc - <mxCodec> that controls the encoding process.\r\n * obj - Object to be encoded.\r\n * node - XML node that contains the encoded object.\r\n */\nmxObjectCodec.prototype.encodeObject = function (enc, obj, node) {\n  enc.setAttribute(node, 'id', enc.getId(obj));\n  for (var i in obj) {\n    var name = i;\n    var value = obj[name];\n    if (value != null && !this.isExcluded(obj, name, value, true)) {\n      if (_mxGraphUtils[\"default\"].isInteger(name)) {\n        name = null;\n      } else if (typeof obj.isContainable === 'function' && obj.isContainable()) {\n        if (i === 'collapsed') {\n          //container类型的cell需要将collapsed属性设置为true，否则下次加载后是展开的没有内容\n          value = true;\n        } else if (i === 'geometry') {\n          var stencil = _mxStencilRegistry[\"default\"].getStencil(obj.getShape(true));\n          value = value.clone();\n          value.width = stencil.w0;\n          value.height = stencil.h0;\n        }\n      }\n      this.encodeValue(enc, obj, name, value, node);\n    }\n  }\n};\n\n/**\r\n * Function: encodeValue\r\n *\r\n * Converts the given value according to the mappings\r\n * and id-refs in this codec and uses <writeAttribute>\r\n * to write the attribute into the given node.\r\n *\r\n * Parameters:\r\n *\r\n * enc - <mxCodec> that controls the encoding process.\r\n * obj - Object whose property is going to be encoded.\r\n * name - XML node that contains the encoded object.\r\n * value - Value of the property to be encoded.\r\n * node - XML node that contains the encoded object.\r\n */\nmxObjectCodec.prototype.encodeValue = function (enc, obj, name, value, node) {\n  if (value != null) {\n    if (this.isReference(obj, name, value, true)) {\n      var tmp = enc.getId(value);\n      if (tmp == null) {\n        _mxLog[\"default\"].warn('mxObjectCodec.encode: No ID for ' + this.getName() + '.' + name + '=' + value);\n        return; // exit\n      }\n      value = tmp;\n    }\n    var defaultValue = this.template[name];\n\n    // Checks if the value is a default value and\n    // the name is correct\n    if (name == null || enc.encodeDefaults || defaultValue != value) {\n      name = this.getAttributeName(name);\n      this.writeAttribute(enc, obj, name, value, node);\n    }\n  }\n};\n\n/**\r\n * Function: writeAttribute\r\n *\r\n * Writes the given value into node using <writePrimitiveAttribute>\r\n * or <writeComplexAttribute> depending on the type of the value.\r\n */\nmxObjectCodec.prototype.writeAttribute = function (enc, obj, name, value, node) {\n  if (_typeof(value) != 'object' /* primitive type */) {\n    this.writePrimitiveAttribute(enc, obj, name, value, node);\n  } else /* complex type */\n    {\n      this.writeComplexAttribute(enc, obj, name, value, node);\n    }\n};\n\n/**\r\n * Function: writePrimitiveAttribute\r\n *\r\n * Writes the given value as an attribute of the given node.\r\n */\nmxObjectCodec.prototype.writePrimitiveAttribute = function (enc, obj, name, value, node) {\n  value = this.convertAttributeToXml(enc, obj, name, value, node);\n  if (name == null) {\n    var child = enc.document.createElement('add');\n    if (typeof value == 'function') {\n      child.appendChild(enc.document.createTextNode(value));\n    } else {\n      enc.setAttribute(child, 'value', value);\n    }\n    node.appendChild(child);\n  } else if (typeof value != 'function') {\n    enc.setAttribute(node, name, value);\n  }\n};\n\n/**\r\n * Function: writeComplexAttribute\r\n *\r\n * Writes the given value as a child node of the given node.\r\n */\nmxObjectCodec.prototype.writeComplexAttribute = function (enc, obj, name, value, node) {\n  var child = enc.encode(value);\n  if (child != null) {\n    if (name != null) {\n      child.setAttribute('as', name);\n    }\n    node.appendChild(child);\n  } else {\n    _mxLog[\"default\"].warn('mxObjectCodec.encode: No node for ' + this.getName() + '.' + name + ': ' + value);\n  }\n};\n\n/**\r\n * Function: convertAttributeToXml\r\n *\r\n * Converts true to \"1\" and false to \"0\" is <isBooleanAttribute> returns true.\r\n * All other values are not converted.\r\n *\r\n * Parameters:\r\n *\r\n * enc - <mxCodec> that controls the encoding process.\r\n * obj - Objec to convert the attribute for.\r\n * name - Name of the attribute to be converted.\r\n * value - Value to be converted.\r\n */\nmxObjectCodec.prototype.convertAttributeToXml = function (enc, obj, name, value) {\n  // Makes sure to encode boolean values as numeric values\n  /*if (this.isBooleanAttribute(enc, obj, name, value))\r\n  {\r\n  \t// Checks if the value is true (do not use the value as is, because\r\n  \t// this would check if the value is not null, so 0 would be true)\r\n  \tvalue = (value == true) ? '1' : '0';\r\n  }*/\n\n  return value;\n};\n\n/**\r\n * Function: isBooleanAttribute\r\n *\r\n * Returns true if the given object attribute is a boolean value.\r\n *\r\n * Parameters:\r\n *\r\n * enc - <mxCodec> that controls the encoding process.\r\n * obj - Objec to convert the attribute for.\r\n * name - Name of the attribute to be converted.\r\n * value - Value of the attribute to be converted.\r\n */\n/*mxObjectCodec.prototype.isBooleanAttribute = function(enc, obj, name, value)\r\n{\r\n\treturn (typeof(value.length) == 'undefined' && (value == true || value == false));\r\n};*/\nmxObjectCodec.prototype.isBooleanAttribute = function (dec, attr, obj) {\n  var value = attr.value;\n  return value === 'true' || value === 'false';\n};\n\n/**\r\n * Function: convertAttributeFromXml\r\n *\r\n * Converts booleans and numeric values to the respective types. Values are\r\n * numeric if <isNumericAttribute> returns true.\r\n *\r\n * Parameters:\r\n *\r\n * dec - <mxCodec> that controls the decoding process.\r\n * attr - XML attribute to be converted.\r\n * obj - Objec to convert the attribute for.\r\n * inProperties - 如果模型的属性(cell.properties)中的属性，不需要做数字的转换\r\n */\nmxObjectCodec.prototype.convertAttributeFromXml = function (dec, attr, obj, inProperties) {\n  var value = attr.value;\n  if (!inProperties && this.isNumericAttribute(dec, attr, obj)) {\n    value = parseFloat(value);\n  }\n  if (this.isBooleanAttribute(dec, attr, obj)) {\n    value = value === 'true' ? true : false;\n  }\n  return value;\n};\n\n/**\r\n * Function: isNumericAttribute\r\n *\r\n * Returns true if the given XML attribute is a numeric value.\r\n *\r\n * Parameters:\r\n *\r\n * dec - <mxCodec> that controls the decoding process.\r\n * attr - XML attribute to be converted.\r\n * obj - Objec to convert the attribute for.\r\n */\nmxObjectCodec.prototype.isNumericAttribute = function (dec, attr, obj) {\n  return _mxGraphUtils[\"default\"].isNumeric(attr.value);\n};\n\n/**\r\n * Function: beforeEncode\r\n *\r\n * Hook for subclassers to pre-process the object before\r\n * encoding. This returns the input object. The return\r\n * value of this function is used in <encode> to perform\r\n * the default encoding into the given node.\r\n *\r\n * Parameters:\r\n *\r\n * enc - <mxCodec> that controls the encoding process.\r\n * obj - Object to be encoded.\r\n * node - XML node to encode the object into.\r\n */\nmxObjectCodec.prototype.beforeEncode = function (enc, obj, node) {\n  return obj;\n};\n\n/**\r\n * Function: afterEncode\r\n *\r\n * Hook for subclassers to post-process the node\r\n * for the given object after encoding and return the\r\n * post-processed node. This implementation returns\r\n * the input node. The return value of this method\r\n * is returned to the encoder from <encode>.\r\n *\r\n * Parameters:\r\n *\r\n * enc - <mxCodec> that controls the encoding process.\r\n * obj - Object to be encoded.\r\n * node - XML node that represents the default encoding.\r\n */\nmxObjectCodec.prototype.afterEncode = function (enc, obj, node) {\n  return node;\n};\n\n/**\r\n * Function: decode\r\n *\r\n * Parses the given node into the object or returns a new object\r\n * representing the given node.\r\n *\r\n * Dec is a reference to the calling decoder. It is used to decode\r\n * complex objects and resolve references.\r\n *\r\n * If a node has an id attribute then the object cache is checked for the\r\n * object. If the object is not yet in the cache then it is constructed\r\n * using the constructor of <template> and cached in <mxCodec.objects>.\r\n *\r\n * This implementation decodes all attributes and childs of a node\r\n * according to the following rules:\r\n *\r\n * - If the variable name is in <exclude> or if the attribute name is \"id\"\r\n * or \"as\" then it is ignored.\r\n * - If the variable name is in <idrefs> then <mxCodec.getObject> is used\r\n * to replace the reference with an object.\r\n * - The variable name is mapped using a reverse <mapping>.\r\n * - If the value has a child node, then the codec is used to create a\r\n * child object with the variable name taken from the \"as\" attribute.\r\n * - If the object is an array and the variable name is empty then the\r\n * value or child object is appended to the array.\r\n * - If an add child has no value or the object is not an array then\r\n * the child text content is evaluated using <mxGraphUtils.eval>.\r\n *\r\n * For add nodes where the object is not an array and the variable name\r\n * is defined, the default mechanism is used, allowing to override/add\r\n * methods as follows:\r\n *\r\n * (code)\r\n * <Object>\r\n *   <add as=\"hello\"><![CDATA[\r\n *     function(arg1) {\r\n *       mxGraphUtils.alert('Hello '+arg1);\r\n *     }\r\n *   ]]></add>\r\n * </Object>\r\n * (end)\r\n *\r\n * If no object exists for an ID in <idrefs> a warning is issued\r\n * using <mxLog.warn>.\r\n *\r\n * Returns the resulting object that represents the given XML node\r\n * or the object given to the method as the into parameter.\r\n *\r\n * Parameters:\r\n *\r\n * dec - <mxCodec> that controls the decoding process.\r\n * node - XML node to be decoded.\r\n * into - Optional objec to encode the node into.\r\n */\nmxObjectCodec.prototype.decode = function (dec, node, into) {\n  var id = node.getAttribute('id');\n  var obj = dec.objects[id];\n  if (obj == null) {\n    obj = into || this.cloneTemplate();\n    if (id != null) {\n      dec.putObject(id, obj);\n    }\n  }\n  node = this.beforeDecode(dec, node, obj);\n  this.decodeNode(dec, node, obj);\n  return this.afterDecode(dec, node, obj);\n};\n\n/**\r\n * Function: decodeNode\r\n *\r\n * Calls <decodeAttributes> and <decodeChildren> for the given node.\r\n *\r\n * Parameters:\r\n *\r\n * dec - <mxCodec> that controls the decoding process.\r\n * node - XML node to be decoded.\r\n * obj - Objec to encode the node into.\r\n */\nmxObjectCodec.prototype.decodeNode = function (dec, node, obj) {\n  if (node != null) {\n    this.decodeAttributes(dec, node, obj);\n    this.decodeChildren(dec, node, obj);\n  }\n};\n\n/**\r\n * Function: decodeAttributes\r\n *\r\n * Decodes all attributes of the given node using <decodeAttribute>.\r\n *\r\n * Parameters:\r\n *\r\n * dec - <mxCodec> that controls the decoding process.\r\n * node - XML node to be decoded.\r\n * obj - Objec to encode the node into.\r\n */\nmxObjectCodec.prototype.decodeAttributes = function (dec, node, obj) {\n  var attrs = node.attributes;\n  //由于js整数范围有限，超出后计算有问题，所以对工作流加的propertie中的属性中的全数字字符串不做处理\n  var isInProperties = this.isBelongToAttribute(node, 'properties');\n  if (attrs != null) {\n    for (var i = 0; i < attrs.length; i++) {\n      this.decodeAttribute(dec, attrs[i], obj, isInProperties);\n    }\n  }\n};\n\n/**\r\n * 判断node是否是parentNode的attrName中的属性\r\n */\nmxObjectCodec.prototype.isBelongToAttribute = function (node, attrName) {\n  var parentNode = node;\n  var filterOutNames = ['mxCell', 'mxGeometry', 'mxGraphModel', 'mxPoint', 'mxRectangle'];\n  while (parentNode != null && filterOutNames.indexOf(parentNode.nodeName) === -1) {\n    if (parentNode.getAttribute('as') === attrName) {\n      return true;\n    }\n    parentNode = parentNode.parentNode;\n  }\n  return false;\n};\n\n/**\r\n * Function: isIgnoredAttribute\r\n *\r\n * Returns true if the given attribute should be ignored. This implementation\r\n * returns true if the attribute name is \"as\" or \"id\".\r\n *\r\n * Parameters:\r\n *\r\n * dec - <mxCodec> that controls the decoding process.\r\n * attr - XML attribute to be decoded.\r\n * obj - Objec to encode the attribute into.\r\n */\nmxObjectCodec.prototype.isIgnoredAttribute = function (dec, attr, obj) {\n  return attr.nodeName == 'as'; // || attr.nodeName == 'id';\n};\n\n/**\r\n * Function: decodeAttribute\r\n *\r\n * Reads the given attribute into the specified object.\r\n *\r\n * Parameters:\r\n *\r\n * dec - <mxCodec> that controls the decoding process.\r\n * attr - XML attribute to be decoded.\r\n * obj - Objec to encode the attribute into.\r\n */\nmxObjectCodec.prototype.decodeAttribute = function (dec, attr, obj, inProperties) {\n  if (!this.isIgnoredAttribute(dec, attr, obj)) {\n    var name = attr.nodeName;\n\n    // Converts the string true and false to their boolean values.\n    // This may require an additional check on the obj to see if\n    // the existing field is a boolean value or uninitialized, in\n    // which case we may want to convert true and false to a string.\n    var value = this.convertAttributeFromXml(dec, attr, obj, inProperties);\n    var fieldname = this.getFieldName(name);\n    if (this.isReference(obj, fieldname, value, false)) {\n      var tmp = dec.getObject(value);\n      if (tmp == null) {\n        _mxLog[\"default\"].warn('mxObjectCodec.decode: No object for ' + this.getName() + '.' + name + '=' + value);\n        return; // exit\n      }\n      value = tmp;\n    }\n    if (!this.isExcluded(obj, name, value, false)) {\n      //mxLog.debug(mxGraphUtils.getFunctionName(obj.constructor)+'.'+name+'='+value);\n      obj[name] = value;\n    }\n  }\n};\n\n/**\r\n * Function: decodeChildren\r\n *\r\n * Decodec all children of the given node using <decodeChild>.\r\n *\r\n * Parameters:\r\n *\r\n * dec - <mxCodec> that controls the decoding process.\r\n * node - XML node to be decoded.\r\n * obj - Objec to encode the node into.\r\n */\nmxObjectCodec.prototype.decodeChildren = function (dec, node, obj) {\n  var child = node.firstChild;\n  while (child != null) {\n    var tmp = child.nextSibling;\n    if (child.nodeType == _mxConstants[\"default\"].NODETYPE_ELEMENT && !this.processInclude(dec, child, obj)) {\n      this.decodeChild(dec, child, obj);\n    }\n    child = tmp;\n  }\n};\n\n/**\r\n * Function: decodeChild\r\n *\r\n * Reads the specified child into the given object.\r\n *\r\n * Parameters:\r\n *\r\n * dec - <mxCodec> that controls the decoding process.\r\n * child - XML child element to be decoded.\r\n * obj - Objec to encode the node into.\r\n */\nmxObjectCodec.prototype.decodeChild = function (dec, child, obj) {\n  var fieldname = this.getFieldName(child.getAttribute('as'));\n  if (fieldname == null || !this.isExcluded(obj, fieldname, child, false)) {\n    var template = this.getFieldTemplate(obj, fieldname, child);\n    var value = null;\n    if (child.nodeName == 'add') {\n      value = child.getAttribute('value');\n      if (value == null && mxObjectCodec.allowEval) {\n        value = _mxGraphUtils[\"default\"].eval(_mxGraphUtils[\"default\"].getTextContent(child));\n      }\n    } else {\n      value = dec.decode(child, template);\n    }\n    this.addObjectValue(obj, fieldname, value, template);\n  }\n};\n\n/**\r\n * Function: getFieldTemplate\r\n *\r\n * Returns the template instance for the given field. This returns the\r\n * value of the field, null if the value is an array or an empty collection\r\n * if the value is a collection. The value is then used to populate the\r\n * field for a new instance. For strongly typed languages it may be\r\n * required to override this to return the correct collection instance\r\n * based on the encoded child.\r\n */\nmxObjectCodec.prototype.getFieldTemplate = function (obj, fieldname, child) {\n  var template = obj[fieldname];\n\n  // Non-empty arrays are replaced completely\n  if (template instanceof Array && template.length > 0) {\n    template = null;\n  }\n  return template;\n};\n\n/**\r\n * Function: addObjectValue\r\n *\r\n * Sets the decoded child node as a value of the given object. If the\r\n * object is a map, then the value is added with the given fieldname as a\r\n * key. If the fieldname is not empty, then setFieldValue is called or\r\n * else, if the object is a collection, the value is added to the\r\n * collection. For strongly typed languages it may be required to\r\n * override this with the correct code to add an entry to an object.\r\n */\nmxObjectCodec.prototype.addObjectValue = function (obj, fieldname, value, template) {\n  if (value != null && value != template) {\n    if (fieldname != null && fieldname.length > 0) {\n      obj[fieldname] = value;\n    } else {\n      obj.push(value);\n    }\n    //mxLog.debug('Decoded '+mxGraphUtils.getFunctionName(obj.constructor)+'.'+fieldname+': '+value);\n  }\n};\n\n/**\r\n * Function: processInclude\r\n *\r\n * Returns true if the given node is an include directive and\r\n * executes the include by decoding the XML document. Returns\r\n * false if the given node is not an include directive.\r\n *\r\n * Parameters:\r\n *\r\n * dec - <mxCodec> that controls the encoding/decoding process.\r\n * node - XML node to be checked.\r\n * into - Optional object to pass-thru to the codec.\r\n */\nmxObjectCodec.prototype.processInclude = function (dec, node, into) {\n  if (node.nodeName == 'include') {\n    var name = node.getAttribute('name');\n    if (name != null) {\n      try {\n        var xml = _mxRequestUtils[\"default\"].load(name).getDocumentElement();\n        if (xml != null) {\n          dec.decode(xml, into);\n        }\n      } catch (e) {\n        // ignore\n      }\n    }\n    return true;\n  }\n  return false;\n};\n\n/**\r\n * Function: beforeDecode\r\n *\r\n * Hook for subclassers to pre-process the node for\r\n * the specified object and return the node to be\r\n * used for further processing by <decode>.\r\n * The object is created based on the template in the\r\n * calling method and is never null. This implementation\r\n * returns the input node. The return value of this\r\n * function is used in <decode> to perform\r\n * the default decoding into the given object.\r\n *\r\n * Parameters:\r\n *\r\n * dec - <mxCodec> that controls the decoding process.\r\n * node - XML node to be decoded.\r\n * obj - Object to encode the node into.\r\n */\nmxObjectCodec.prototype.beforeDecode = function (dec, node, obj) {\n  return node;\n};\n\n/**\r\n * Function: afterDecode\r\n *\r\n * Hook for subclassers to post-process the object after\r\n * decoding. This implementation returns the given object\r\n * without any changes. The return value of this method\r\n * is returned to the decoder from <decode>.\r\n *\r\n * Parameters:\r\n *\r\n * enc - <mxCodec> that controls the encoding process.\r\n * node - XML node to be decoded.\r\n * obj - Object that represents the default decoding.\r\n */\nmxObjectCodec.prototype.afterDecode = function (dec, node, obj) {\n  return obj;\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxGenericChangeCodec\r\n *\r\n * Codec for <mxValueChange>s, <mxStyleChange>s, <mxGeometryChange>s,\r\n * <mxCollapseChange>s and <mxVisibleChange>s. This class is created\r\n * and registered dynamically at load time and used implicitely\r\n * via <mxCodec> and the <mxCodecRegistry>.\r\n *\r\n * Transient Fields:\r\n *\r\n * - model\r\n * - previous\r\n *\r\n * Reference Fields:\r\n *\r\n * - cell\r\n *\r\n * Constructor: mxGenericChangeCodec\r\n *\r\n * Factory function that creates a <mxObjectCodec> for\r\n * the specified change and fieldname.\r\n *\r\n * Parameters:\r\n *\r\n * obj - An instance of the change object.\r\n * variable - The fieldname for the change data.\r\n */\nvar _default = exports[\"default\"] = mxObjectCodec;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxObjectCodec.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxObjectIdentity.js":
/*!***************************************************!*\
  !*** ./src/workflow/mxClient/mxObjectIdentity.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.symbol.js */ \"../../node_modules/core-js/modules/es.symbol.js\");\n__webpack_require__(/*! core-js/modules/es.symbol.description.js */ \"../../node_modules/core-js/modules/es.symbol.description.js\");\n__webpack_require__(/*! core-js/modules/es.symbol.iterator.js */ \"../../node_modules/core-js/modules/es.symbol.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.array.concat.js */ \"../../node_modules/core-js/modules/es.array.concat.js\");\n__webpack_require__(/*! core-js/modules/es.array.iterator.js */ \"../../node_modules/core-js/modules/es.array.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.date.to-string.js */ \"../../node_modules/core-js/modules/es.date.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.object.to-string.js */ \"../../node_modules/core-js/modules/es.object.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.string.iterator.js */ \"../../node_modules/core-js/modules/es.string.iterator.js\");\n__webpack_require__(/*! core-js/modules/web.dom-collections.iterator.js */ \"../../node_modules/core-js/modules/web.dom-collections.iterator.js\");\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxGraphConstants = _interopRequireDefault(__webpack_require__(/*! ./mxGraphConstants.js */ \"./src/workflow/mxClient/mxGraphConstants.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nvar mxObjectIdentity = {\n  /**\r\n   * Class: mxObjectIdentity\r\n   *\r\n   * Identity for JavaScript objects and functions. This is implemented using\r\n   * a simple incrementing counter which is stored in each object under\r\n   * <FIELD_NAME>.\r\n   *\r\n   * The identity for an object does not change during its lifecycle.\r\n   *\r\n   * Variable: FIELD_NAME\r\n   *\r\n   * Name of the field to be used to store the object ID. Default is\r\n   * <code>mxObjectId</code>.\r\n   */\n  FIELD_NAME: _mxGraphConstants[\"default\"].FIELD_NAME,\n  /**\r\n   * Variable: counter\r\n   *\r\n   * Current counter.\r\n   */\n  counter: 0,\n  /**\r\n   * Function: get\r\n   *\r\n   * Returns the ID for the given object or function or null if no object\r\n   * is specified.\r\n   */\n  get: function get(obj) {\n    if (obj != null) {\n      if (obj[mxObjectIdentity.FIELD_NAME] == null) {\n        if (_typeof(obj) === 'object') {\n          var ctor = _mxGraphUtils[\"default\"].getFunctionName(obj.constructor);\n          //#改成_是因为 后台deploy的时候会有检查\n          obj[mxObjectIdentity.FIELD_NAME] = \"\".concat(ctor, \"_\").concat(new Date().getTime(), \"_\").concat(mxObjectIdentity.counter++);\n        } else if (typeof obj === 'function') {\n          obj[mxObjectIdentity.FIELD_NAME] = \"Function_\".concat(new Date().getTime(), \"_\").concat(mxObjectIdentity.counter++);\n        }\n      }\n      return obj[mxObjectIdentity.FIELD_NAME];\n    }\n    return null;\n  },\n  /**\r\n   * Function: clear\r\n   *\r\n   * Deletes the ID from the given object or function.\r\n   */\n  clear: function clear(obj) {\n    if (_typeof(obj) === 'object' || typeof obj === 'function') {\n      delete obj[mxObjectIdentity.FIELD_NAME];\n    }\n  }\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxDictionary\r\n *\r\n * A wrapper class for an associative array with object keys. Note: This\r\n * implementation uses <mxObjectIdentitiy> to turn object keys into strings.\r\n *\r\n * Constructor: mxEventSource\r\n *\r\n * Constructs a new dictionary which allows object to be used as keys.\r\n */\nvar _default = exports[\"default\"] = mxObjectIdentity;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxObjectIdentity.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxOutline.js":
/*!********************************************!*\
  !*** ./src/workflow/mxClient/mxOutline.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.function.bind.js */ \"../../node_modules/core-js/modules/es.function.bind.js\");\nvar _mxClient = _interopRequireDefault(__webpack_require__(/*! ./mxClient.js */ \"./src/workflow/mxClient/mxClient.js\"));\nvar _mxGraph = _interopRequireDefault(__webpack_require__(/*! ./mxGraph.js */ \"./src/workflow/mxClient/mxGraph.js\"));\nvar _mxEvent = _interopRequireDefault(__webpack_require__(/*! ./mxEvent.js */ \"./src/workflow/mxClient/mxEvent.js\"));\nvar _mxPoint = _interopRequireDefault(__webpack_require__(/*! ./mxPoint.js */ \"./src/workflow/mxClient/mxPoint.js\"));\nvar _mxMouseEvent = _interopRequireDefault(__webpack_require__(/*! ./mxMouseEvent.js */ \"./src/workflow/mxClient/mxMouseEvent.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxRectangle = _interopRequireDefault(__webpack_require__(/*! ./mxRectangle.js */ \"./src/workflow/mxClient/mxRectangle.js\"));\nvar _mxRectangleShape = _interopRequireDefault(__webpack_require__(/*! ./mxRectangleShape.js */ \"./src/workflow/mxClient/mxRectangleShape.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ./mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nvar _mxUtils = _interopRequireDefault(__webpack_require__(/*! ./mxUtils.js */ \"./src/workflow/mxClient/mxUtils.js\"));\nvar _mxImageShape = _interopRequireDefault(__webpack_require__(/*! ./mxImageShape.js */ \"./src/workflow/mxClient/mxImageShape.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxOutline(source, container) {\n  this.source = source;\n  if (container != null) {\n    this.init(container);\n  }\n}\n;\n\n/**\r\n * Function: source\r\n *\r\n * Reference to the source <mxGraph>.\r\n */\nmxOutline.prototype.source = null;\n\n/**\r\n * Function: outline\r\n *\r\n * Reference to the <mxGraph> that renders the outline.\r\n */\nmxOutline.prototype.outline = null;\n\n/**\r\n * Function: graphRenderHint\r\n *\r\n * Renderhint to be used for the outline graph. Default is faster.\r\n */\nmxOutline.prototype.graphRenderHint = _mxConstants[\"default\"].RENDERING_HINT_FASTER;\n\n/**\r\n * Variable: enabled\r\n *\r\n * Specifies if events are handled. Default is true.\r\n */\nmxOutline.prototype.enabled = true;\n\n/**\r\n * Variable: showViewport\r\n *\r\n * Specifies a viewport rectangle should be shown. Default is true.\r\n */\nmxOutline.prototype.showViewport = true;\n\n/**\r\n * Variable: border\r\n *\r\n * Border to be added at the bottom and right. Default is 10.\r\n */\nmxOutline.prototype.border = 10;\n\n/**\r\n * Variable: enabled\r\n *\r\n * Specifies the size of the sizer handler. Default is 8.\r\n */\nmxOutline.prototype.sizerSize = 8;\n\n/**\r\n * Variable: labelsVisible\r\n *\r\n * Specifies if labels should be visible in the outline. Default is false.\r\n */\nmxOutline.prototype.labelsVisible = false;\n\n/**\r\n * Variable: updateOnPan\r\n *\r\n * Specifies if <update> should be called for <mxEvent.PAN> in the source\r\n * graph. Default is false.\r\n */\nmxOutline.prototype.updateOnPan = false;\n\n/**\r\n * Variable: sizerImage\r\n *\r\n * Optional <mxImage> to be used for the sizer. Default is null.\r\n */\nmxOutline.prototype.sizerImage = null;\n\n/**\r\n * Variable: minScale\r\n *\r\n * Minimum scale to be used. Default is 0.001.\r\n */\nmxOutline.prototype.minScale = 0.0001;\n\n/**\r\n * Variable: suspended\r\n *\r\n * Optional boolean flag to suspend updates. Default is false. This flag will\r\n * also suspend repaints of the outline. To toggle this switch, use the\r\n * following code.\r\n *\r\n * (code)\r\n * nav.suspended = !nav.suspended;\r\n *\r\n * if (!nav.suspended)\r\n * {\r\n *   nav.update(true);\r\n * }\r\n * (end)\r\n */\nmxOutline.prototype.suspended = false;\n\n/**\r\n * Variable: forceVmlHandles\r\n *\r\n * Specifies if VML should be used to render the handles in this control. This\r\n * is true for IE8 standards mode and false for all other browsers and modes.\r\n * This is a workaround for rendering issues of HTML elements over elements\r\n * with filters in IE 8 standards mode.\r\n */\nmxOutline.prototype.forceVmlHandles = document.documentMode == 8;\n\n/**\r\n * Function: createGraph\r\n *\r\n * Creates the <mxGraph> used in the outline.\r\n */\nmxOutline.prototype.createGraph = function (container) {\n  var graph = new _mxGraph[\"default\"](container, this.source.getModel(), this.graphRenderHint, this.source.getStylesheet());\n  graph.foldingEnabled = false;\n  graph.autoScroll = false;\n  return graph;\n};\n\n/**\r\n * Function: init\r\n *\r\n * Initializes the outline inside the given container.\r\n */\nmxOutline.prototype.init = function (container) {\n  this.outline = this.createGraph(container);\n\n  // Do not repaint when suspended\n  var outlineGraphModelChanged = this.outline.graphModelChanged;\n  this.outline.graphModelChanged = _mxGraphUtils[\"default\"].bind(this, function (changes) {\n    if (!this.suspended && this.outline != null) {\n      outlineGraphModelChanged.apply(this.outline, arguments);\n    }\n  });\n\n  // Enables faster painting in SVG\n  if (_mxClient[\"default\"].IS_SVG) {\n    var node = this.outline.getView().getCanvas().parentNode;\n    node.setAttribute('shape-rendering', 'optimizeSpeed');\n    node.setAttribute('image-rendering', 'optimizeSpeed');\n  }\n\n  // Hides cursors and labels\n  this.outline.labelsVisible = this.labelsVisible;\n  this.outline.setEnabled(false);\n  this.updateHandler = _mxGraphUtils[\"default\"].bind(this, function (sender, evt) {\n    if (!this.suspended && !this.active) {\n      this.update();\n    }\n  });\n\n  // Updates the scale of the outline after a change of the main graph\n  this.source.getModel().addListener(_mxEvent[\"default\"].CHANGE, this.updateHandler);\n  this.outline.addMouseListener(this);\n\n  // Adds listeners to keep the outline in sync with the source graph\n  var view = this.source.getView();\n  view.addListener(_mxEvent[\"default\"].SCALE, this.updateHandler);\n  view.addListener(_mxEvent[\"default\"].TRANSLATE, this.updateHandler);\n  view.addListener(_mxEvent[\"default\"].SCALE_AND_TRANSLATE, this.updateHandler);\n  view.addListener(_mxEvent[\"default\"].DOWN, this.updateHandler);\n  view.addListener(_mxEvent[\"default\"].UP, this.updateHandler);\n\n  // Updates blue rectangle on scroll\n  _mxEvent[\"default\"].addListener(this.source.container, 'scroll', this.updateHandler);\n  this.panHandler = _mxGraphUtils[\"default\"].bind(this, function (sender) {\n    if (this.updateOnPan) {\n      this.updateHandler.apply(this, arguments);\n    }\n  });\n  this.source.addListener(_mxEvent[\"default\"].PAN, this.panHandler);\n\n  // Refreshes the graph in the outline after a refresh of the main graph\n  this.refreshHandler = _mxGraphUtils[\"default\"].bind(this, function (sender) {\n    this.outline.setStylesheet(this.source.getStylesheet());\n    this.outline.refresh();\n  });\n  this.source.addListener(_mxEvent[\"default\"].REFRESH, this.refreshHandler);\n\n  // Creates the blue rectangle for the viewport\n  this.bounds = new _mxRectangle[\"default\"](0, 0, 0, 0);\n  this.selectionBorder = new _mxRectangleShape[\"default\"](this.bounds, null, _mxConstants[\"default\"].OUTLINE_COLOR, _mxConstants[\"default\"].OUTLINE_STROKEWIDTH);\n  this.selectionBorder.dialect = this.outline.dialect;\n  if (this.forceVmlHandles) {\n    this.selectionBorder.isHtmlAllowed = function () {\n      return false;\n    };\n  }\n  this.selectionBorder.init(this.outline.getView().getOverlayPane());\n\n  // Handles event by catching the initial pointer start and then listening to the\n  // complete gesture on the event target. This is needed because all the events\n  // are routed via the initial element even if that element is removed from the\n  // DOM, which happens when we repaint the selection border and zoom handles.\n  var handler = _mxGraphUtils[\"default\"].bind(this, function (evt) {\n    var t = _mxEvent[\"default\"].getSource(evt);\n    var redirect = _mxGraphUtils[\"default\"].bind(this, function (evt) {\n      this.outline.fireMouseEvent(_mxEvent[\"default\"].MOUSE_MOVE, new _mxMouseEvent[\"default\"](evt));\n    });\n    var redirect2 = _mxGraphUtils[\"default\"].bind(this, function (evt) {\n      _mxEvent[\"default\"].removeGestureListeners(t, null, redirect, redirect2);\n      this.outline.fireMouseEvent(_mxEvent[\"default\"].MOUSE_UP, new _mxMouseEvent[\"default\"](evt));\n    });\n    _mxEvent[\"default\"].addGestureListeners(t, null, redirect, redirect2);\n    this.outline.fireMouseEvent(_mxEvent[\"default\"].MOUSE_DOWN, new _mxMouseEvent[\"default\"](evt));\n  });\n  _mxEvent[\"default\"].addGestureListeners(this.selectionBorder.node, handler);\n\n  // Creates a small blue rectangle for sizing (sizer handle)\n  this.sizer = this.createSizer();\n  if (this.forceVmlHandles) {\n    this.sizer.isHtmlAllowed = function () {\n      return false;\n    };\n  }\n  this.sizer.init(this.outline.getView().getOverlayPane());\n  if (this.enabled) {\n    this.sizer.node.style.cursor = 'nwse-resize';\n  }\n  _mxEvent[\"default\"].addGestureListeners(this.sizer.node, handler);\n  this.selectionBorder.node.style.display = this.showViewport ? '' : 'none';\n  this.sizer.node.style.display = this.selectionBorder.node.style.display;\n  this.selectionBorder.node.style.cursor = 'move';\n  this.update(false);\n};\n\n/**\r\n * Function: isEnabled\r\n *\r\n * Returns true if events are handled. This implementation\r\n * returns <enabled>.\r\n */\nmxOutline.prototype.isEnabled = function () {\n  return this.enabled;\n};\n\n/**\r\n * Function: setEnabled\r\n *\r\n * Enables or disables event handling. This implementation\r\n * updates <enabled>.\r\n *\r\n * Parameters:\r\n *\r\n * value - Boolean that specifies the new enabled state.\r\n */\nmxOutline.prototype.setEnabled = function (value) {\n  this.enabled = value;\n};\n\n/**\r\n * Function: setZoomEnabled\r\n *\r\n * Enables or disables the zoom handling by showing or hiding the respective\r\n * handle.\r\n *\r\n * Parameters:\r\n *\r\n * value - Boolean that specifies the new enabled state.\r\n */\nmxOutline.prototype.setZoomEnabled = function (value) {\n  this.sizer.node.style.visibility = value ? 'visible' : 'hidden';\n};\n\n/**\r\n * Function: refresh\r\n *\r\n * Invokes <update> and revalidate the outline. This method is deprecated.\r\n */\nmxOutline.prototype.refresh = function () {\n  this.update(true);\n};\n\n/**\r\n * Function: createSizer\r\n *\r\n * Creates the shape used as the sizer.\r\n */\nmxOutline.prototype.createSizer = function () {\n  if (this.sizerImage != null) {\n    var sizer = new _mxImageShape[\"default\"](new _mxRectangle[\"default\"](0, 0, this.sizerImage.width, this.sizerImage.height), this.sizerImage.src);\n    sizer.dialect = this.outline.dialect;\n    return sizer;\n  } else {\n    var sizer = new _mxRectangleShape[\"default\"](new _mxRectangle[\"default\"](0, 0, this.sizerSize, this.sizerSize), _mxConstants[\"default\"].OUTLINE_HANDLE_FILLCOLOR, _mxConstants[\"default\"].OUTLINE_HANDLE_STROKECOLOR);\n    sizer.dialect = this.outline.dialect;\n    return sizer;\n  }\n};\n\n/**\r\n * Function: getSourceContainerSize\r\n *\r\n * Returns the size of the source container.\r\n */\nmxOutline.prototype.getSourceContainerSize = function () {\n  return new _mxRectangle[\"default\"](0, 0, this.source.container.scrollWidth, this.source.container.scrollHeight);\n};\n\n/**\r\n * Function: getOutlineOffset\r\n *\r\n * Returns the offset for drawing the outline graph.\r\n */\nmxOutline.prototype.getOutlineOffset = function (scale) {\n  return null;\n};\n\n/**\r\n * Function: getOutlineOffset\r\n *\r\n * Returns the offset for drawing the outline graph.\r\n */\nmxOutline.prototype.getSourceGraphBounds = function () {\n  return this.source.getGraphBounds();\n};\n\n/**\r\n * Function: update\r\n *\r\n * Updates the outline.\r\n */\nmxOutline.prototype.update = function (revalidate) {\n  if (this.source != null && this.outline != null) {\n    var sourceScale = this.source.view.scale;\n    var scaledGraphBounds = this.getSourceGraphBounds();\n    var unscaledGraphBounds = new _mxRectangle[\"default\"](scaledGraphBounds.x / sourceScale + this.source.panDx, scaledGraphBounds.y / sourceScale + this.source.panDy, scaledGraphBounds.width / sourceScale, scaledGraphBounds.height / sourceScale);\n    var unscaledFinderBounds = new _mxRectangle[\"default\"](0, 0, this.source.container.clientWidth / sourceScale, this.source.container.clientHeight / sourceScale);\n    var union = unscaledGraphBounds.clone();\n    union.add(unscaledFinderBounds);\n\n    // Zooms to the scrollable area if that is bigger than the graph\n    var size = this.getSourceContainerSize();\n    var completeWidth = Math.max(size.width / sourceScale, union.width);\n    var completeHeight = Math.max(size.height / sourceScale, union.height);\n    var availableWidth = Math.max(0, this.outline.container.clientWidth - this.border);\n    var availableHeight = Math.max(0, this.outline.container.clientHeight - this.border);\n    var outlineScale = Math.min(availableWidth / completeWidth, availableHeight / completeHeight);\n    var scale = isNaN(outlineScale) ? this.minScale : Math.max(this.minScale, outlineScale);\n    if (scale > 0) {\n      if (this.outline.getView().scale != scale) {\n        this.outline.getView().scale = scale;\n        revalidate = true;\n      }\n      var navView = this.outline.getView();\n      if (navView.currentRoot != this.source.getView().currentRoot) {\n        navView.setCurrentRoot(this.source.getView().currentRoot);\n      }\n      var t = this.source.view.translate;\n      var tx = t.x + this.source.panDx;\n      var ty = t.y + this.source.panDy;\n      var off = this.getOutlineOffset(scale);\n      if (off != null) {\n        tx += off.x;\n        ty += off.y;\n      }\n      if (unscaledGraphBounds.x < 0) {\n        tx = tx - unscaledGraphBounds.x;\n      }\n      if (unscaledGraphBounds.y < 0) {\n        ty = ty - unscaledGraphBounds.y;\n      }\n      if (navView.translate.x != tx || navView.translate.y != ty) {\n        navView.translate.x = tx;\n        navView.translate.y = ty;\n        revalidate = true;\n      }\n\n      // Prepares local variables for computations\n      var t2 = navView.translate;\n      scale = this.source.getView().scale;\n      var scale2 = scale / navView.scale;\n      var scale3 = 1.0 / navView.scale;\n      var container = this.source.container;\n\n      // Updates the bounds of the viewrect in the navigation\n      this.bounds = new _mxRectangle[\"default\"]((t2.x - t.x - this.source.panDx) / scale3, (t2.y - t.y - this.source.panDy) / scale3, container.clientWidth / scale2, container.clientHeight / scale2);\n\n      // Adds the scrollbar offset to the finder\n      this.bounds.x += this.source.container.scrollLeft * navView.scale / scale;\n      this.bounds.y += this.source.container.scrollTop * navView.scale / scale;\n      var b = this.selectionBorder.bounds;\n      if (b.x != this.bounds.x || b.y != this.bounds.y || b.width != this.bounds.width || b.height != this.bounds.height) {\n        this.selectionBorder.bounds = this.bounds;\n        this.selectionBorder.redraw();\n      }\n\n      // Updates the bounds of the zoom handle at the bottom right\n      var b = this.sizer.bounds;\n      var b2 = new _mxRectangle[\"default\"](this.bounds.x + this.bounds.width - b.width / 2, this.bounds.y + this.bounds.height - b.height / 2, b.width, b.height);\n      if (b.x != b2.x || b.y != b2.y || b.width != b2.width || b.height != b2.height) {\n        this.sizer.bounds = b2;\n\n        // Avoids update of visibility in redraw for VML\n        if (this.sizer.node.style.visibility != 'hidden') {\n          this.sizer.redraw();\n        }\n      }\n      if (revalidate) {\n        this.outline.view.revalidate();\n      }\n    }\n  }\n};\n\n/**\r\n * Function: mouseDown\r\n *\r\n * Handles the event by starting a translation or zoom.\r\n */\nmxOutline.prototype.mouseDown = function (sender, me) {\n  if (this.enabled && this.showViewport) {\n    var tol = !_mxEvent[\"default\"].isMouseEvent(me.getEvent()) ? this.source.tolerance : 0;\n    var hit = this.source.allowHandleBoundsCheck && (_mxClient[\"default\"].IS_IE || tol > 0) ? new _mxRectangle[\"default\"](me.getGraphX() - tol, me.getGraphY() - tol, 2 * tol, 2 * tol) : null;\n    this.zoom = me.isSource(this.sizer) || hit != null && _mxUtils[\"default\"].intersects(shape.bounds, hit);\n    this.startX = me.getX();\n    this.startY = me.getY();\n    this.active = true;\n    if (this.source.useScrollbarsForPanning && _mxUtils[\"default\"].hasScrollbars(this.source.container)) {\n      this.dx0 = this.source.container.scrollLeft;\n      this.dy0 = this.source.container.scrollTop;\n    } else {\n      this.dx0 = 0;\n      this.dy0 = 0;\n    }\n  }\n  me.consume();\n};\n\n/**\r\n * Function: mouseMove\r\n *\r\n * Handles the event by previewing the viewrect in <graph> and updating the\r\n * rectangle that represents the viewrect in the outline.\r\n */\nmxOutline.prototype.mouseMove = function (sender, me) {\n  if (this.active) {\n    this.selectionBorder.node.style.display = this.showViewport ? '' : 'none';\n    this.sizer.node.style.display = this.selectionBorder.node.style.display;\n    var delta = this.getTranslateForEvent(me);\n    var dx = delta.x;\n    var dy = delta.y;\n    var bounds = null;\n    if (!this.zoom) {\n      // Previews the panning on the source graph\n      var scale = this.outline.getView().scale;\n      bounds = new _mxRectangle[\"default\"](this.bounds.x + dx, this.bounds.y + dy, this.bounds.width, this.bounds.height);\n      this.selectionBorder.bounds = bounds;\n      this.selectionBorder.redraw();\n      dx /= scale;\n      dx *= this.source.getView().scale;\n      dy /= scale;\n      dy *= this.source.getView().scale;\n      this.source.panGraph(-dx - this.dx0, -dy - this.dy0);\n    } else {\n      // Does *not* preview zooming on the source graph\n      var container = this.source.container;\n      var viewRatio = container.clientWidth / container.clientHeight;\n      dy = dx / viewRatio;\n      bounds = new _mxRectangle[\"default\"](this.bounds.x, this.bounds.y, Math.max(1, this.bounds.width + dx), Math.max(1, this.bounds.height + dy));\n      this.selectionBorder.bounds = bounds;\n      this.selectionBorder.redraw();\n    }\n\n    // Updates the zoom handle\n    var b = this.sizer.bounds;\n    this.sizer.bounds = new _mxRectangle[\"default\"](bounds.x + bounds.width - b.width / 2, bounds.y + bounds.height - b.height / 2, b.width, b.height);\n\n    // Avoids update of visibility in redraw for VML\n    if (this.sizer.node.style.visibility != 'hidden') {\n      this.sizer.redraw();\n    }\n    me.consume();\n  }\n};\n\n/**\r\n * Function: getTranslateForEvent\r\n *\r\n * Gets the translate for the given mouse event. Here is an example to limit\r\n * the outline to stay within positive coordinates:\r\n *\r\n * (code)\r\n * outline.getTranslateForEvent = function(me)\r\n * {\r\n *   var pt = new mxPoint(me.getX() - this.startX, me.getY() - this.startY);\r\n *\r\n *   if (!this.zoom)\r\n *   {\r\n *     var tr = this.source.view.translate;\r\n *     pt.x = Math.max(tr.x * this.outline.view.scale, pt.x);\r\n *     pt.y = Math.max(tr.y * this.outline.view.scale, pt.y);\r\n *   }\r\n *\r\n *   return pt;\r\n * };\r\n * (end)\r\n */\nmxOutline.prototype.getTranslateForEvent = function (me) {\n  return new _mxPoint[\"default\"](me.getX() - this.startX, me.getY() - this.startY);\n};\n\n/**\r\n * Function: mouseUp\r\n *\r\n * Handles the event by applying the translation or zoom to <graph>.\r\n */\nmxOutline.prototype.mouseUp = function (sender, me) {\n  if (this.active) {\n    var delta = this.getTranslateForEvent(me);\n    var dx = delta.x;\n    var dy = delta.y;\n    if (Math.abs(dx) > 0 || Math.abs(dy) > 0) {\n      if (!this.zoom) {\n        // Applies the new translation if the source\n        // has no scrollbars\n        if (!this.source.useScrollbarsForPanning || !_mxUtils[\"default\"].hasScrollbars(this.source.container)) {\n          this.source.panGraph(0, 0);\n          dx /= this.outline.getView().scale;\n          dy /= this.outline.getView().scale;\n          var t = this.source.getView().translate;\n          this.source.getView().setTranslate(t.x - dx, t.y - dy);\n        }\n      } else {\n        // Applies the new zoom\n        var w = this.selectionBorder.bounds.width;\n        var scale = this.source.getView().scale;\n        this.source.zoomTo(Math.max(this.minScale, scale - dx * scale / w), false);\n      }\n      this.update();\n      me.consume();\n    }\n\n    // Resets the state of the handler\n    this.index = null;\n    this.active = false;\n  }\n};\n\n/**\r\n * Function: destroy\r\n *\r\n * Destroy this outline and removes all listeners from <source>.\r\n */\nmxOutline.prototype.destroy = function () {\n  if (this.source != null) {\n    this.source.removeListener(this.panHandler);\n    this.source.removeListener(this.refreshHandler);\n    this.source.getModel().removeListener(this.updateHandler);\n    this.source.getView().removeListener(this.updateHandler);\n    _mxEvent[\"default\"].addListener(this.source.container, 'scroll', this.updateHandler);\n    this.source = null;\n  }\n  if (this.outline != null) {\n    this.outline.removeMouseListener(this);\n    this.outline.destroy();\n    this.outline = null;\n  }\n  if (this.selectionBorder != null) {\n    this.selectionBorder.destroy();\n    this.selectionBorder = null;\n  }\n  if (this.sizer != null) {\n    this.sizer.destroy();\n    this.sizer = null;\n  }\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxMultiplicity\r\n *\r\n * Defines invalid connections along with the error messages that they produce.\r\n * To add or remove rules on a graph, you must add/remove instances of this\r\n * class to <mxGraph.multiplicities>.\r\n *\r\n * Example:\r\n *\r\n * (code)\r\n * graph.multiplicities.push(new mxMultiplicity(\r\n *   true, 'rectangle', null, null, 0, 2, ['circle'],\r\n *   'Only 2 targets allowed',\r\n *   'Only circle targets allowed'));\r\n * (end)\r\n *\r\n * Defines a rule where each rectangle must be connected to no more than 2\r\n * circles and no other types of targets are allowed.\r\n *\r\n * Constructor: mxMultiplicity\r\n *\r\n * Instantiate class mxMultiplicity in order to describe allowed\r\n * connections in a graph. Not all constraints can be enforced while\r\n * editing, some must be checked at validation time. The <countError> and\r\n * <typeError> are treated as resource keys in <mxResources>.\r\n *\r\n * Parameters:\r\n *\r\n * source - Boolean indicating if this rule applies to the source or target\r\n * terminal.\r\n * type - Type of the source or target terminal that this rule applies to.\r\n * See <type> for more information.\r\n * attr - Optional attribute name to match the source or target terminal.\r\n * value - Optional attribute value to match the source or target terminal.\r\n * min - Minimum number of edges for this rule. Default is 1.\r\n * max - Maximum number of edges for this rule. n means infinite. Default\r\n * is n.\r\n * validNeighbors - Array of types of the opposite terminal for which this\r\n * rule applies.\r\n * countError - Error to be displayed for invalid number of edges.\r\n * typeError - Error to be displayed for invalid opposite terminals.\r\n * validNeighborsAllowed - Optional boolean indicating if the array of\r\n * opposite types should be valid or invalid.\r\n */\nvar _default = exports[\"default\"] = mxOutline;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxOutline.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxPanningHandler.js":
/*!***************************************************!*\
  !*** ./src/workflow/mxClient/mxPanningHandler.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.function.bind.js */ \"../../node_modules/core-js/modules/es.function.bind.js\");\nvar _mxEventObject = _interopRequireDefault(__webpack_require__(/*! ./mxEventObject.js */ \"./src/workflow/mxClient/mxEventObject.js\"));\nvar _mxEvent = _interopRequireDefault(__webpack_require__(/*! ./mxEvent.js */ \"./src/workflow/mxClient/mxEvent.js\"));\nvar _mxEventSource = _interopRequireDefault(__webpack_require__(/*! ./mxEventSource.js */ \"./src/workflow/mxClient/mxEventSource.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxUtils = _interopRequireDefault(__webpack_require__(/*! ./mxUtils.js */ \"./src/workflow/mxClient/mxUtils.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxPanningHandler(graph) {\n  if (graph != null) {\n    this.graph = graph;\n    this.graph.addMouseListener(this);\n\n    // Handles force panning event\n    this.forcePanningHandler = _mxGraphUtils[\"default\"].bind(this, function (sender, evt) {\n      var evtName = evt.getProperty('eventName');\n      var me = evt.getProperty('event');\n      if (evtName == _mxEvent[\"default\"].MOUSE_DOWN && this.isForcePanningEvent(me)) {\n        this.start(me);\n        this.active = true;\n        this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].PAN_START, 'event', me));\n        me.consume();\n      }\n    });\n    this.graph.addListener(_mxEvent[\"default\"].FIRE_MOUSE_EVENT, this.forcePanningHandler);\n\n    // Handles pinch gestures\n    this.gestureHandler = _mxGraphUtils[\"default\"].bind(this, function (sender, eo) {\n      if (this.isPinchEnabled()) {\n        var evt = eo.getProperty('event');\n        if (!_mxEvent[\"default\"].isConsumed(evt) && evt.type == 'gesturestart') {\n          this.initialScale = this.graph.view.scale;\n\n          // Forces start of panning when pinch gesture starts\n          if (!this.active && this.mouseDownEvent != null) {\n            this.start(this.mouseDownEvent);\n            this.mouseDownEvent = null;\n          }\n        } else if (evt.type == 'gestureend' && this.initialScale == null) {\n          this.initialScale = null;\n        }\n        if (this.initialScale != null) {\n          var value = Math.round(this.initialScale * evt.scale * 100) / 100;\n          if (this.minScale != null) {\n            value = Math.max(this.minScale, value);\n          }\n          if (this.maxScale != null) {\n            value = Math.min(this.maxScale, value);\n          }\n          if (this.graph.view.scale != value) {\n            this.graph.zoomTo(value);\n            _mxEvent[\"default\"].consume(evt);\n          }\n        }\n      }\n    });\n    this.graph.addListener(_mxEvent[\"default\"].GESTURE, this.gestureHandler);\n  }\n}\n;\n\n/**\r\n * Extends mxEventSource.\r\n */\nmxPanningHandler.prototype = new _mxEventSource[\"default\"]();\nmxPanningHandler.prototype.constructor = mxPanningHandler;\n\n/**\r\n * Variable: graph\r\n *\r\n * Reference to the enclosing <mxGraph>.\r\n */\nmxPanningHandler.prototype.graph = null;\n\n/**\r\n * Variable: useLeftButtonForPanning\r\n *\r\n * Specifies if panning should be active for the left mouse button.\r\n * Setting this to true may conflict with <mxRubberband>. Default is false.\r\n */\nmxPanningHandler.prototype.useLeftButtonForPanning = false;\n\n/**\r\n * Variable: usePopupTrigger\r\n *\r\n * Specifies if <mxEvent.isPopupTrigger> should also be used for panning.\r\n */\nmxPanningHandler.prototype.usePopupTrigger = true;\n\n/**\r\n * Variable: ignoreCell\r\n *\r\n * Specifies if panning should be active even if there is a cell under the\r\n * mousepointer. Default is false.\r\n */\nmxPanningHandler.prototype.ignoreCell = false;\n\n/**\r\n * Variable: previewEnabled\r\n *\r\n * Specifies if the panning should be previewed. Default is true.\r\n */\nmxPanningHandler.prototype.previewEnabled = true;\n\n/**\r\n * Variable: useGrid\r\n *\r\n * Specifies if the panning steps should be aligned to the grid size.\r\n * Default is false.\r\n */\nmxPanningHandler.prototype.useGrid = false;\n\n/**\r\n * Variable: panningEnabled\r\n *\r\n * Specifies if panning should be enabled. Default is true.\r\n */\nmxPanningHandler.prototype.panningEnabled = true;\n\n/**\r\n * Variable: pinchEnabled\r\n *\r\n * Specifies if pinch gestures should be handled as zoom. Default is true.\r\n */\nmxPanningHandler.prototype.pinchEnabled = true;\n\n/**\r\n * Variable: maxScale\r\n *\r\n * Specifies the maximum scale. Default is 8.\r\n */\nmxPanningHandler.prototype.maxScale = 8;\n\n/**\r\n * Variable: minScale\r\n *\r\n * Specifies the minimum scale. Default is 0.01.\r\n */\nmxPanningHandler.prototype.minScale = 0.01;\n\n/**\r\n * Variable: dx\r\n *\r\n * Holds the current horizontal offset.\r\n */\nmxPanningHandler.prototype.dx = null;\n\n/**\r\n * Variable: dy\r\n *\r\n * Holds the current vertical offset.\r\n */\nmxPanningHandler.prototype.dy = null;\n\n/**\r\n * Variable: startX\r\n *\r\n * Holds the x-coordinate of the start point.\r\n */\nmxPanningHandler.prototype.startX = 0;\n\n/**\r\n * Variable: startY\r\n *\r\n * Holds the y-coordinate of the start point.\r\n */\nmxPanningHandler.prototype.startY = 0;\n\n/**\r\n * Function: isActive\r\n *\r\n * Returns true if the handler is currently active.\r\n */\nmxPanningHandler.prototype.isActive = function () {\n  return this.active || this.initialScale != null;\n};\n\n/**\r\n * Function: isPanningEnabled\r\n *\r\n * Returns <panningEnabled>.\r\n */\nmxPanningHandler.prototype.isPanningEnabled = function () {\n  return this.panningEnabled;\n};\n\n/**\r\n * Function: setPanningEnabled\r\n *\r\n * Sets <panningEnabled>.\r\n */\nmxPanningHandler.prototype.setPanningEnabled = function (value) {\n  this.panningEnabled = value;\n};\n\n/**\r\n * Function: isPinchEnabled\r\n *\r\n * Returns <pinchEnabled>.\r\n */\nmxPanningHandler.prototype.isPinchEnabled = function () {\n  return this.pinchEnabled;\n};\n\n/**\r\n * Function: setPinchEnabled\r\n *\r\n * Sets <pinchEnabled>.\r\n */\nmxPanningHandler.prototype.setPinchEnabled = function (value) {\n  this.pinchEnabled = value;\n};\n\n/**\r\n * Function: isPanningTrigger\r\n *\r\n * Returns true if the given event is a panning trigger for the optional\r\n * given cell. This returns true if control-shift is pressed or if\r\n * <usePopupTrigger> is true and the event is a popup trigger.\r\n */\nmxPanningHandler.prototype.isPanningTrigger = function (me) {\n  var evt = me.getEvent();\n  return this.useLeftButtonForPanning && me.getState() == null && _mxEvent[\"default\"].isLeftMouseButton(evt) || _mxEvent[\"default\"].isControlDown(evt) && _mxEvent[\"default\"].isShiftDown(evt) || this.usePopupTrigger && _mxEvent[\"default\"].isPopupTrigger(evt);\n};\n\n/**\r\n * Function: isForcePanningEvent\r\n *\r\n * Returns true if the given <mxMouseEvent> should start panning. This\r\n * implementation always returns true if <ignoreCell> is true or for\r\n * multi touch events.\r\n */\nmxPanningHandler.prototype.isForcePanningEvent = function (me) {\n  return this.ignoreCell || _mxEvent[\"default\"].isMultiTouchEvent(me.getEvent());\n};\n\n/**\r\n * Function: mouseDown\r\n *\r\n * Handles the event by initiating the panning. By consuming the event all\r\n * subsequent events of the gesture are redirected to this handler.\r\n */\nmxPanningHandler.prototype.mouseDown = function (sender, me) {\n  this.mouseDownEvent = me;\n  if (!me.isConsumed() && this.isPanningEnabled() && !this.active && this.isPanningTrigger(me)) {\n    this.start(me);\n    this.consumePanningTrigger(me);\n  }\n};\n\n/**\r\n * Function: start\r\n *\r\n * Starts panning at the given event.\r\n */\nmxPanningHandler.prototype.start = function (me) {\n  this.dx0 = -this.graph.container.scrollLeft;\n  this.dy0 = -this.graph.container.scrollTop;\n\n  // Stores the location of the trigger event\n  this.startX = me.getX();\n  this.startY = me.getY();\n  this.dx = null;\n  this.dy = null;\n  this.panningTrigger = true;\n};\n\n/**\r\n * Function: consumePanningTrigger\r\n *\r\n * Consumes the given <mxMouseEvent> if it was a panning trigger in\r\n * <mouseDown>. The default is to invoke <mxMouseEvent.consume>. Note that this\r\n * will block any further event processing. If you haven't disabled built-in\r\n * context menus and require immediate selection of the cell on mouseDown in\r\n * Safari and/or on the Mac, then use the following code:\r\n *\r\n * (code)\r\n * mxPanningHandler.prototype.consumePanningTrigger = function(me)\r\n * {\r\n *   if (me.evt.preventDefault)\r\n *   {\r\n *     me.evt.preventDefault();\r\n *   }\r\n *\r\n *   // Stops event processing in IE\r\n *   me.evt.returnValue = false;\r\n *\r\n *   // Sets local consumed state\r\n *   if (!mxClient.IS_SF && !mxClient.IS_MAC)\r\n *   {\r\n *     me.consumed = true;\r\n *   }\r\n * };\r\n * (end)\r\n */\nmxPanningHandler.prototype.consumePanningTrigger = function (me) {\n  me.consume();\n};\n\n/**\r\n * Function: mouseMove\r\n *\r\n * Handles the event by updating the panning on the graph.\r\n */\nmxPanningHandler.prototype.mouseMove = function (sender, me) {\n  this.dx = me.getX() - this.startX;\n  this.dy = me.getY() - this.startY;\n  if (this.active) {\n    if (this.previewEnabled) {\n      // Applies the grid to the panning steps\n      if (this.useGrid) {\n        this.dx = this.graph.snap(this.dx);\n        this.dy = this.graph.snap(this.dy);\n      }\n      this.graph.panGraph(this.dx + this.dx0, this.dy + this.dy0);\n    }\n    this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].PAN, 'event', me));\n  } else if (this.panningTrigger) {\n    var tmp = this.active;\n\n    // Panning is activated only if the mouse is moved\n    // beyond the graph tolerance\n    this.active = Math.abs(this.dx) > this.graph.tolerance || Math.abs(this.dy) > this.graph.tolerance;\n    if (!tmp && this.active) {\n      this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].PAN_START, 'event', me));\n    }\n  }\n  if (this.active || this.panningTrigger) {\n    me.consume();\n  }\n};\n\n/**\r\n * Function: mouseUp\r\n *\r\n * Handles the event by setting the translation on the view or showing the\r\n * popupmenu.\r\n */\nmxPanningHandler.prototype.mouseUp = function (sender, me) {\n  if (this.active) {\n    if (this.dx != null && this.dy != null) {\n      // Ignores if scrollbars have been used for panning\n      if (!this.graph.useScrollbarsForPanning || !_mxUtils[\"default\"].hasScrollbars(this.graph.container)) {\n        var scale = this.graph.getView().scale;\n        var t = this.graph.getView().translate;\n        this.graph.panGraph(0, 0);\n        this.panGraph(t.x + this.dx / scale, t.y + this.dy / scale);\n      }\n      me.consume();\n    }\n    this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].PAN_END, 'event', me));\n  }\n  this.panningTrigger = false;\n  this.mouseDownEvent = null;\n  this.active = false;\n  this.dx = null;\n  this.dy = null;\n};\n\n/**\r\n * Function: panGraph\r\n *\r\n * Pans <graph> by the given amount.\r\n */\nmxPanningHandler.prototype.panGraph = function (dx, dy) {\n  this.graph.getView().setTranslate(dx, dy);\n};\n\n/**\r\n * Function: destroy\r\n *\r\n * Destroys the handler and all its resources and DOM nodes.\r\n */\nmxPanningHandler.prototype.destroy = function () {\n  this.graph.removeMouseListener(this);\n  this.graph.removeListener(this.forcePanningHandler);\n  this.graph.removeListener(this.gestureHandler);\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxPopupMenuHandler\r\n *\r\n * Event handler that creates popupmenus.\r\n *\r\n * Constructor: mxPopupMenuHandler\r\n *\r\n * Constructs an event handler that creates a <mxPopupMenu>.\r\n */\nvar _default = exports[\"default\"] = mxPanningHandler;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxPanningHandler.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxPanningManager.js":
/*!***************************************************!*\
  !*** ./src/workflow/mxClient/mxPanningManager.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.function.bind.js */ \"../../node_modules/core-js/modules/es.function.bind.js\");\n__webpack_require__(/*! core-js/modules/web.timers.js */ \"../../node_modules/core-js/modules/web.timers.js\");\nvar _mxEventObject = _interopRequireDefault(__webpack_require__(/*! ./mxEventObject.js */ \"./src/workflow/mxClient/mxEventObject.js\"));\nvar _mxEvent = _interopRequireDefault(__webpack_require__(/*! ./mxEvent.js */ \"./src/workflow/mxClient/mxEvent.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxUtils = _interopRequireDefault(__webpack_require__(/*! ./mxUtils.js */ \"./src/workflow/mxClient/mxUtils.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxPanningManager(graph) {\n  this.thread = null;\n  this.active = false;\n  this.tdx = 0;\n  this.tdy = 0;\n  this.t0x = 0;\n  this.t0y = 0;\n  this.dx = 0;\n  this.dy = 0;\n  this.scrollbars = false;\n  this.scrollLeft = 0;\n  this.scrollTop = 0;\n  this.mouseListener = {\n    mouseDown: function mouseDown(sender, me) {},\n    mouseMove: function mouseMove(sender, me) {},\n    mouseUp: _mxGraphUtils[\"default\"].bind(this, function (sender, me) {\n      if (this.active) {\n        this.stop();\n      }\n    })\n  };\n  graph.addMouseListener(this.mouseListener);\n\n  // Stops scrolling on every mouseup anywhere in the document\n  _mxEvent[\"default\"].addListener(document, 'mouseup', _mxGraphUtils[\"default\"].bind(this, function () {\n    if (this.active) {\n      this.stop();\n    }\n  }));\n  var createThread = _mxGraphUtils[\"default\"].bind(this, function () {\n    this.scrollbars = _mxUtils[\"default\"].hasScrollbars(graph.container);\n    this.scrollLeft = graph.container.scrollLeft;\n    this.scrollTop = graph.container.scrollTop;\n    return window.setInterval(_mxGraphUtils[\"default\"].bind(this, function () {\n      this.tdx -= this.dx;\n      this.tdy -= this.dy;\n      if (this.scrollbars) {\n        var left = -graph.container.scrollLeft - Math.ceil(this.dx);\n        var top = -graph.container.scrollTop - Math.ceil(this.dy);\n        graph.panGraph(left, top);\n        graph.panDx = this.scrollLeft - graph.container.scrollLeft;\n        graph.panDy = this.scrollTop - graph.container.scrollTop;\n        graph.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].PAN));\n        // TODO: Implement graph.autoExtend\n      } else {\n        graph.panGraph(this.getDx(), this.getDy());\n      }\n    }), this.delay);\n  });\n  this.isActive = function () {\n    return active;\n  };\n  this.getDx = function () {\n    return Math.round(this.tdx);\n  };\n  this.getDy = function () {\n    return Math.round(this.tdy);\n  };\n  this.start = function () {\n    this.t0x = graph.view.translate.x;\n    this.t0y = graph.view.translate.y;\n    this.active = true;\n  };\n  this.panTo = function (x, y, w, h) {\n    if (!this.active) {\n      this.start();\n    }\n    this.scrollLeft = graph.container.scrollLeft;\n    this.scrollTop = graph.container.scrollTop;\n    w = w != null ? w : 0;\n    h = h != null ? h : 0;\n    var c = graph.container;\n    this.dx = x + w - c.scrollLeft - c.clientWidth;\n    if (this.dx < 0 && Math.abs(this.dx) < this.border) {\n      this.dx = this.border + this.dx;\n    } else if (this.handleMouseOut) {\n      this.dx = Math.max(this.dx, 0);\n    } else {\n      this.dx = 0;\n    }\n    if (this.dx == 0) {\n      this.dx = x - c.scrollLeft;\n      if (this.dx > 0 && this.dx < this.border) {\n        this.dx = this.dx - this.border;\n      } else if (this.handleMouseOut) {\n        this.dx = Math.min(0, this.dx);\n      } else {\n        this.dx = 0;\n      }\n    }\n    this.dy = y + h - c.scrollTop - c.clientHeight;\n    if (this.dy < 0 && Math.abs(this.dy) < this.border) {\n      this.dy = this.border + this.dy;\n    } else if (this.handleMouseOut) {\n      this.dy = Math.max(this.dy, 0);\n    } else {\n      this.dy = 0;\n    }\n    if (this.dy == 0) {\n      this.dy = y - c.scrollTop;\n      if (this.dy > 0 && this.dy < this.border) {\n        this.dy = this.dy - this.border;\n      } else if (this.handleMouseOut) {\n        this.dy = Math.min(0, this.dy);\n      } else {\n        this.dy = 0;\n      }\n    }\n    if (this.dx != 0 || this.dy != 0) {\n      this.dx *= this.damper;\n      this.dy *= this.damper;\n      if (this.thread == null) {\n        this.thread = createThread();\n      }\n    } else if (this.thread != null) {\n      window.clearInterval(this.thread);\n      this.thread = null;\n    }\n  };\n  this.stop = function () {\n    if (this.active) {\n      this.active = false;\n      if (this.thread != null) {\n        window.clearInterval(this.thread);\n        this.thread = null;\n      }\n      this.tdx = 0;\n      this.tdy = 0;\n      if (!this.scrollbars) {\n        var px = graph.panDx;\n        var py = graph.panDy;\n        if (px != 0 || py != 0) {\n          graph.panGraph(0, 0);\n          graph.view.setTranslate(this.t0x + px / graph.view.scale, this.t0y + py / graph.view.scale);\n        }\n      } else {\n        graph.panDx = 0;\n        graph.panDy = 0;\n        graph.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].PAN));\n      }\n    }\n  };\n  this.destroy = function () {\n    graph.removeMouseListener(this.mouseListener);\n  };\n}\n;\n\n/**\r\n * Variable: damper\r\n *\r\n * Damper value for the panning. Default is 1/6.\r\n */\nmxPanningManager.prototype.damper = 1 / 6;\n\n/**\r\n * Variable: delay\r\n *\r\n * Delay in milliseconds for the panning. Default is 10.\r\n */\nmxPanningManager.prototype.delay = 10;\n\n/**\r\n * Variable: handleMouseOut\r\n *\r\n * Specifies if mouse events outside of the component should be handled. Default is true.\r\n */\nmxPanningManager.prototype.handleMouseOut = true;\n\n/**\r\n * Variable: border\r\n *\r\n * Border to handle automatic panning inside the component. Default is 0 (disabled).\r\n */\nmxPanningManager.prototype.border = 0;\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxPopupMenu\r\n *\r\n * Basic popup menu. To add a vertical scrollbar to a given submenu, the\r\n * following code can be used.\r\n *\r\n * (code)\r\n * var mxPopupMenuShowMenu = mxPopupMenu.prototype.showMenu;\r\n * mxPopupMenu.prototype.showMenu = function()\r\n * {\r\n *   mxPopupMenuShowMenu.apply(this, arguments);\r\n *\r\n *   this.div.style.overflowY = 'auto';\r\n *   this.div.style.overflowX = 'hidden';\r\n *   this.div.style.maxHeight = '160px';\r\n * };\r\n * (end)\r\n *\r\n * Constructor: mxPopupMenu\r\n *\r\n * Constructs a popupmenu.\r\n *\r\n * Event: mxEvent.SHOW\r\n *\r\n * Fires after the menu has been shown in <popup>.\r\n */\nvar _default = exports[\"default\"] = mxPanningManager;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxPanningManager.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxPerimeter.js":
/*!**********************************************!*\
  !*** ./src/workflow/mxClient/mxPerimeter.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.parse-int.js */ \"../../node_modules/core-js/modules/es.parse-int.js\");\nvar _mxPoint = _interopRequireDefault(__webpack_require__(/*! ./mxPoint.js */ \"./src/workflow/mxClient/mxPoint.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ./mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nvar _mxUtils = _interopRequireDefault(__webpack_require__(/*! ./mxUtils.js */ \"./src/workflow/mxClient/mxUtils.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nvar mxPerimeter = {\n  /**\r\n   * Class: mxPerimeter\r\n   *\r\n   * Provides various perimeter functions to be used in a style\r\n   * as the value of <mxConstants.STYLE_PERIMETER>. Perimeters for\r\n   * rectangle, circle, rhombus and triangle are available.\r\n   *\r\n   * Example:\r\n   *\r\n   * (code)\r\n   * <add as=\"perimeter\">mxPerimeter.RectanglePerimeter</add>\r\n   * (end)\r\n   *\r\n   * Or programmatically:\r\n   *\r\n   * (code)\r\n   * style[mxConstants.STYLE_PERIMETER] = mxPerimeter.RectanglePerimeter;\r\n   * (end)\r\n   *\r\n   * When adding new perimeter functions, it is recommended to use the\r\n   * mxPerimeter-namespace as follows:\r\n   *\r\n   * (code)\r\n   * mxPerimeter.CustomPerimeter = function (bounds, vertex, next, orthogonal)\r\n   * {\r\n   *   var x = 0; // Calculate x-coordinate\r\n   *   var y = 0; // Calculate y-coordainte\r\n   *\r\n   *   return new mxPoint(x, y);\r\n   * }\r\n   * (end)\r\n   *\r\n   * The new perimeter should then be registered in the <mxStyleRegistry> as follows:\r\n   * (code)\r\n   * mxStyleRegistry.putValue('customPerimeter', mxPerimeter.CustomPerimeter);\r\n   * (end)\r\n   *\r\n   * The custom perimeter above can now be used in a specific vertex as follows:\r\n   *\r\n   * (code)\r\n   * model.setStyle(vertex, 'perimeter=customPerimeter');\r\n   * (end)\r\n   *\r\n   * Note that the key of the <mxStyleRegistry> entry for the function should\r\n   * be used in string values, unless <mxGraphView.allowEval> is true, in\r\n   * which case you can also use mxPerimeter.CustomPerimeter for the value in\r\n   * the cell style above.\r\n   *\r\n   * Or it can be used for all vertices in the graph as follows:\r\n   *\r\n   * (code)\r\n   * var style = graph.getStylesheet().getDefaultVertexStyle();\r\n   * style[mxConstants.STYLE_PERIMETER] = mxPerimeter.CustomPerimeter;\r\n   * (end)\r\n   *\r\n   * Note that the object can be used directly when programmatically setting\r\n   * the value, but the key in the <mxStyleRegistry> should be used when\r\n   * setting the value via a key, value pair in a cell style.\r\n   *\r\n   * The parameters are explained in <RectanglePerimeter>.\r\n   *\r\n   * Function: RectanglePerimeter\r\n   *\r\n   * Describes a rectangular perimeter for the given bounds.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * bounds - <mxRectangle> that represents the absolute bounds of the\r\n   * vertex.\r\n   * vertex - <mxCellState> that represents the vertex.\r\n   * next - <mxPoint> that represents the nearest neighbour point on the\r\n   * given edge.\r\n   * orthogonal - Boolean that specifies if the orthogonal projection onto\r\n   * the perimeter should be returned. If this is false then the intersection\r\n   * of the perimeter and the line between the next and the center point is\r\n   * returned.\r\n   */\n  RectanglePerimeter: function RectanglePerimeter(bounds, vertex, next, orthogonal) {\n    var cx = bounds.getCenterX();\n    var cy = bounds.getCenterY();\n    var dx = next.x - cx;\n    var dy = next.y - cy;\n    var alpha = Math.atan2(dy, dx);\n    var p = new _mxPoint[\"default\"](0, 0);\n    var pi = Math.PI;\n    var pi2 = Math.PI / 2;\n    var beta = pi2 - alpha;\n    var t = Math.atan2(bounds.height, bounds.width);\n    if (alpha < -pi + t || alpha > pi - t) {\n      // Left edge\n      p.x = bounds.x;\n      p.y = cy - bounds.width * Math.tan(alpha) / 2;\n    } else if (alpha < -t) {\n      // Top Edge\n      p.y = bounds.y;\n      p.x = cx - bounds.height * Math.tan(beta) / 2;\n    } else if (alpha < t) {\n      // Right Edge\n      p.x = bounds.x + bounds.width;\n      p.y = cy + bounds.width * Math.tan(alpha) / 2;\n    } else {\n      // Bottom Edge\n      p.y = bounds.y + bounds.height;\n      p.x = cx + bounds.height * Math.tan(beta) / 2;\n    }\n    if (orthogonal) {\n      if (next.x >= bounds.x && next.x <= bounds.x + bounds.width) {\n        p.x = next.x;\n      } else if (next.y >= bounds.y && next.y <= bounds.y + bounds.height) {\n        p.y = next.y;\n      }\n      if (next.x < bounds.x) {\n        p.x = bounds.x;\n      } else if (next.x > bounds.x + bounds.width) {\n        p.x = bounds.x + bounds.width;\n      }\n      if (next.y < bounds.y) {\n        p.y = bounds.y;\n      } else if (next.y > bounds.y + bounds.height) {\n        p.y = bounds.y + bounds.height;\n      }\n    }\n    return p;\n  },\n  /**\r\n   * Function: EllipsePerimeter\r\n   *\r\n   * Describes an elliptic perimeter. See <RectanglePerimeter>\r\n   * for a description of the parameters.\r\n   */\n  EllipsePerimeter: function EllipsePerimeter(bounds, vertex, next, orthogonal) {\n    var x = bounds.x;\n    var y = bounds.y;\n    var a = bounds.width / 2;\n    var b = bounds.height / 2;\n    var cx = x + a;\n    var cy = y + b;\n    var px = next.x;\n    var py = next.y;\n\n    // Calculates straight line equation through\n    // point and ellipse center y = d * x + h\n    var dx = parseInt(px - cx);\n    var dy = parseInt(py - cy);\n    if (dx == 0 && dy != 0) {\n      return new _mxPoint[\"default\"](cx, cy + b * dy / Math.abs(dy));\n    } else if (dx == 0 && dy == 0) {\n      return new _mxPoint[\"default\"](px, py);\n    }\n    if (orthogonal) {\n      if (py >= y && py <= y + bounds.height) {\n        var ty = py - cy;\n        var tx = Math.sqrt(a * a * (1 - ty * ty / (b * b))) || 0;\n        if (px <= x) {\n          tx = -tx;\n        }\n        return new _mxPoint[\"default\"](cx + tx, py);\n      }\n      if (px >= x && px <= x + bounds.width) {\n        var tx = px - cx;\n        var ty = Math.sqrt(b * b * (1 - tx * tx / (a * a))) || 0;\n        if (py <= y) {\n          ty = -ty;\n        }\n        return new _mxPoint[\"default\"](px, cy + ty);\n      }\n    }\n\n    // Calculates intersection\n    var d = dy / dx;\n    var h = cy - d * cx;\n    var e = a * a * d * d + b * b;\n    var f = -2 * cx * e;\n    var g = a * a * d * d * cx * cx + b * b * cx * cx - a * a * b * b;\n    var det = Math.sqrt(f * f - 4 * e * g);\n\n    // Two solutions (perimeter points)\n    var xout1 = (-f + det) / (2 * e);\n    var xout2 = (-f - det) / (2 * e);\n    var yout1 = d * xout1 + h;\n    var yout2 = d * xout2 + h;\n    var dist1 = Math.sqrt(Math.pow(xout1 - px, 2) + Math.pow(yout1 - py, 2));\n    var dist2 = Math.sqrt(Math.pow(xout2 - px, 2) + Math.pow(yout2 - py, 2));\n\n    // Correct solution\n    var xout = 0;\n    var yout = 0;\n    if (dist1 < dist2) {\n      xout = xout1;\n      yout = yout1;\n    } else {\n      xout = xout2;\n      yout = yout2;\n    }\n    return new _mxPoint[\"default\"](xout, yout);\n  },\n  /**\r\n   * Function: RhombusPerimeter\r\n   *\r\n   * Describes a rhombus (aka diamond) perimeter. See <RectanglePerimeter>\r\n   * for a description of the parameters.\r\n   */\n  RhombusPerimeter: function RhombusPerimeter(bounds, vertex, next, orthogonal) {\n    var x = bounds.x;\n    var y = bounds.y;\n    var w = bounds.width;\n    var h = bounds.height;\n    var cx = x + w / 2;\n    var cy = y + h / 2;\n    var px = next.x;\n    var py = next.y;\n\n    // Special case for intersecting the diamond's corners\n    if (cx == px) {\n      if (cy > py) {\n        return new _mxPoint[\"default\"](cx, y); // top\n      } else {\n        return new _mxPoint[\"default\"](cx, y + h); // bottom\n      }\n    } else if (cy == py) {\n      if (cx > px) {\n        return new _mxPoint[\"default\"](x, cy); // left\n      } else {\n        return new _mxPoint[\"default\"](x + w, cy); // right\n      }\n    }\n    var tx = cx;\n    var ty = cy;\n    if (orthogonal) {\n      if (px >= x && px <= x + w) {\n        tx = px;\n      } else if (py >= y && py <= y + h) {\n        ty = py;\n      }\n    }\n\n    // In which quadrant will the intersection be?\n    // set the slope and offset of the border line accordingly\n    if (px < cx) {\n      if (py < cy) {\n        return _mxUtils[\"default\"].intersection(px, py, tx, ty, cx, y, x, cy);\n      } else {\n        return _mxUtils[\"default\"].intersection(px, py, tx, ty, cx, y + h, x, cy);\n      }\n    } else if (py < cy) {\n      return _mxUtils[\"default\"].intersection(px, py, tx, ty, cx, y, x + w, cy);\n    } else {\n      return _mxUtils[\"default\"].intersection(px, py, tx, ty, cx, y + h, x + w, cy);\n    }\n  },\n  /**\r\n   * Function: TrianglePerimeter\r\n   *\r\n   * Describes a triangle perimeter. See <RectanglePerimeter>\r\n   * for a description of the parameters.\r\n   */\n  TrianglePerimeter: function TrianglePerimeter(bounds, vertex, next, orthogonal) {\n    var direction = vertex != null ? vertex.style[_mxConstants[\"default\"].STYLE_DIRECTION] : null;\n    var vertical = direction == _mxConstants[\"default\"].DIRECTION_NORTH || direction == _mxConstants[\"default\"].DIRECTION_SOUTH;\n    var x = bounds.x;\n    var y = bounds.y;\n    var w = bounds.width;\n    var h = bounds.height;\n    var cx = x + w / 2;\n    var cy = y + h / 2;\n    var start = new _mxPoint[\"default\"](x, y);\n    var corner = new _mxPoint[\"default\"](x + w, cy);\n    var end = new _mxPoint[\"default\"](x, y + h);\n    if (direction == _mxConstants[\"default\"].DIRECTION_NORTH) {\n      start = end;\n      corner = new _mxPoint[\"default\"](cx, y);\n      end = new _mxPoint[\"default\"](x + w, y + h);\n    } else if (direction == _mxConstants[\"default\"].DIRECTION_SOUTH) {\n      corner = new _mxPoint[\"default\"](cx, y + h);\n      end = new _mxPoint[\"default\"](x + w, y);\n    } else if (direction == _mxConstants[\"default\"].DIRECTION_WEST) {\n      start = new _mxPoint[\"default\"](x + w, y);\n      corner = new _mxPoint[\"default\"](x, cy);\n      end = new _mxPoint[\"default\"](x + w, y + h);\n    }\n    var dx = next.x - cx;\n    var dy = next.y - cy;\n    var alpha = vertical ? Math.atan2(dx, dy) : Math.atan2(dy, dx);\n    var t = vertical ? Math.atan2(w, h) : Math.atan2(h, w);\n    var base = false;\n    if (direction == _mxConstants[\"default\"].DIRECTION_NORTH || direction == _mxConstants[\"default\"].DIRECTION_WEST) {\n      base = alpha > -t && alpha < t;\n    } else {\n      base = alpha < -Math.PI + t || alpha > Math.PI - t;\n    }\n    var result = null;\n    if (base) {\n      if (orthogonal && (vertical && next.x >= start.x && next.x <= end.x || !vertical && next.y >= start.y && next.y <= end.y)) {\n        if (vertical) {\n          result = new _mxPoint[\"default\"](next.x, start.y);\n        } else {\n          result = new _mxPoint[\"default\"](start.x, next.y);\n        }\n      } else {\n        if (direction == _mxConstants[\"default\"].DIRECTION_NORTH) {\n          result = new _mxPoint[\"default\"](x + w / 2 + h * Math.tan(alpha) / 2, y + h);\n        } else if (direction == _mxConstants[\"default\"].DIRECTION_SOUTH) {\n          result = new _mxPoint[\"default\"](x + w / 2 - h * Math.tan(alpha) / 2, y);\n        } else if (direction == _mxConstants[\"default\"].DIRECTION_WEST) {\n          result = new _mxPoint[\"default\"](x + w, y + h / 2 + w * Math.tan(alpha) / 2);\n        } else {\n          result = new _mxPoint[\"default\"](x, y + h / 2 - w * Math.tan(alpha) / 2);\n        }\n      }\n    } else {\n      if (orthogonal) {\n        var pt = new _mxPoint[\"default\"](cx, cy);\n        if (next.y >= y && next.y <= y + h) {\n          pt.x = vertical ? cx : direction == _mxConstants[\"default\"].DIRECTION_WEST ? x + w : x;\n          pt.y = next.y;\n        } else if (next.x >= x && next.x <= x + w) {\n          pt.x = next.x;\n          pt.y = !vertical ? cy : direction == _mxConstants[\"default\"].DIRECTION_NORTH ? y + h : y;\n        }\n\n        // Compute angle\n        dx = next.x - pt.x;\n        dy = next.y - pt.y;\n        cx = pt.x;\n        cy = pt.y;\n      }\n      if (vertical && next.x <= x + w / 2 || !vertical && next.y <= y + h / 2) {\n        result = _mxUtils[\"default\"].intersection(next.x, next.y, cx, cy, start.x, start.y, corner.x, corner.y);\n      } else {\n        result = _mxUtils[\"default\"].intersection(next.x, next.y, cx, cy, corner.x, corner.y, end.x, end.y);\n      }\n    }\n    if (result == null) {\n      result = new _mxPoint[\"default\"](cx, cy);\n    }\n    return result;\n  },\n  /**\r\n   * Function: HexagonPerimeter\r\n   *\r\n   * Describes a hexagon perimeter. See <RectanglePerimeter>\r\n   * for a description of the parameters.\r\n   */\n  HexagonPerimeter: function HexagonPerimeter(bounds, vertex, next, orthogonal) {\n    var x = bounds.x;\n    var y = bounds.y;\n    var w = bounds.width;\n    var h = bounds.height;\n    var cx = bounds.getCenterX();\n    var cy = bounds.getCenterY();\n    var px = next.x;\n    var py = next.y;\n    var dx = px - cx;\n    var dy = py - cy;\n    var alpha = -Math.atan2(dy, dx);\n    var pi = Math.PI;\n    var pi2 = Math.PI / 2;\n    var result = new _mxPoint[\"default\"](cx, cy);\n    var direction = vertex != null ? _mxGraphUtils[\"default\"].getValue(vertex.style, _mxConstants[\"default\"].STYLE_DIRECTION, _mxConstants[\"default\"].DIRECTION_EAST) : _mxConstants[\"default\"].DIRECTION_EAST;\n    var vertical = direction == _mxConstants[\"default\"].DIRECTION_NORTH || direction == _mxConstants[\"default\"].DIRECTION_SOUTH;\n    var a = new _mxPoint[\"default\"]();\n    var b = new _mxPoint[\"default\"]();\n\n    //Only consider corrects quadrants for the orthogonal case.\n    if (px < x && py < y || px < x && py > y + h || px > x + w && py < y || px > x + w && py > y + h) {\n      orthogonal = false;\n    }\n    if (orthogonal) {\n      if (vertical) {\n        //Special cases where intersects with hexagon corners\n        if (px == cx) {\n          if (py <= y) {\n            return new _mxPoint[\"default\"](cx, y);\n          } else if (py >= y + h) {\n            return new _mxPoint[\"default\"](cx, y + h);\n          }\n        } else if (px < x) {\n          if (py == y + h / 4) {\n            return new _mxPoint[\"default\"](x, y + h / 4);\n          } else if (py == y + 3 * h / 4) {\n            return new _mxPoint[\"default\"](x, y + 3 * h / 4);\n          }\n        } else if (px > x + w) {\n          if (py == y + h / 4) {\n            return new _mxPoint[\"default\"](x + w, y + h / 4);\n          } else if (py == y + 3 * h / 4) {\n            return new _mxPoint[\"default\"](x + w, y + 3 * h / 4);\n          }\n        } else if (px == x) {\n          if (py < cy) {\n            return new _mxPoint[\"default\"](x, y + h / 4);\n          } else if (py > cy) {\n            return new _mxPoint[\"default\"](x, y + 3 * h / 4);\n          }\n        } else if (px == x + w) {\n          if (py < cy) {\n            return new _mxPoint[\"default\"](x + w, y + h / 4);\n          } else if (py > cy) {\n            return new _mxPoint[\"default\"](x + w, y + 3 * h / 4);\n          }\n        }\n        if (py == y) {\n          return new _mxPoint[\"default\"](cx, y);\n        } else if (py == y + h) {\n          return new _mxPoint[\"default\"](cx, y + h);\n        }\n        if (px < cx) {\n          if (py > y + h / 4 && py < y + 3 * h / 4) {\n            a = new _mxPoint[\"default\"](x, y);\n            b = new _mxPoint[\"default\"](x, y + h);\n          } else if (py < y + h / 4) {\n            a = new _mxPoint[\"default\"](x - Math.floor(0.5 * w), y + Math.floor(0.5 * h));\n            b = new _mxPoint[\"default\"](x + w, y - Math.floor(0.25 * h));\n          } else if (py > y + 3 * h / 4) {\n            a = new _mxPoint[\"default\"](x - Math.floor(0.5 * w), y + Math.floor(0.5 * h));\n            b = new _mxPoint[\"default\"](x + w, y + Math.floor(1.25 * h));\n          }\n        } else if (px > cx) {\n          if (py > y + h / 4 && py < y + 3 * h / 4) {\n            a = new _mxPoint[\"default\"](x + w, y);\n            b = new _mxPoint[\"default\"](x + w, y + h);\n          } else if (py < y + h / 4) {\n            a = new _mxPoint[\"default\"](x, y - Math.floor(0.25 * h));\n            b = new _mxPoint[\"default\"](x + Math.floor(1.5 * w), y + Math.floor(0.5 * h));\n          } else if (py > y + 3 * h / 4) {\n            a = new _mxPoint[\"default\"](x + Math.floor(1.5 * w), y + Math.floor(0.5 * h));\n            b = new _mxPoint[\"default\"](x, y + Math.floor(1.25 * h));\n          }\n        }\n      } else {\n        //Special cases where intersects with hexagon corners\n        if (py == cy) {\n          if (px <= x) {\n            return new _mxPoint[\"default\"](x, y + h / 2);\n          } else if (px >= x + w) {\n            return new _mxPoint[\"default\"](x + w, y + h / 2);\n          }\n        } else if (py < y) {\n          if (px == x + w / 4) {\n            return new _mxPoint[\"default\"](x + w / 4, y);\n          } else if (px == x + 3 * w / 4) {\n            return new _mxPoint[\"default\"](x + 3 * w / 4, y);\n          }\n        } else if (py > y + h) {\n          if (px == x + w / 4) {\n            return new _mxPoint[\"default\"](x + w / 4, y + h);\n          } else if (px == x + 3 * w / 4) {\n            return new _mxPoint[\"default\"](x + 3 * w / 4, y + h);\n          }\n        } else if (py == y) {\n          if (px < cx) {\n            return new _mxPoint[\"default\"](x + w / 4, y);\n          } else if (px > cx) {\n            return new _mxPoint[\"default\"](x + 3 * w / 4, y);\n          }\n        } else if (py == y + h) {\n          if (px < cx) {\n            return new _mxPoint[\"default\"](x + w / 4, y + h);\n          } else if (py > cy) {\n            return new _mxPoint[\"default\"](x + 3 * w / 4, y + h);\n          }\n        }\n        if (px == x) {\n          return new _mxPoint[\"default\"](x, cy);\n        } else if (px == x + w) {\n          return new _mxPoint[\"default\"](x + w, cy);\n        }\n        if (py < cy) {\n          if (px > x + w / 4 && px < x + 3 * w / 4) {\n            a = new _mxPoint[\"default\"](x, y);\n            b = new _mxPoint[\"default\"](x + w, y);\n          } else if (px < x + w / 4) {\n            a = new _mxPoint[\"default\"](x - Math.floor(0.25 * w), y + h);\n            b = new _mxPoint[\"default\"](x + Math.floor(0.5 * w), y - Math.floor(0.5 * h));\n          } else if (px > x + 3 * w / 4) {\n            a = new _mxPoint[\"default\"](x + Math.floor(0.5 * w), y - Math.floor(0.5 * h));\n            b = new _mxPoint[\"default\"](x + Math.floor(1.25 * w), y + h);\n          }\n        } else if (py > cy) {\n          if (px > x + w / 4 && px < x + 3 * w / 4) {\n            a = new _mxPoint[\"default\"](x, y + h);\n            b = new _mxPoint[\"default\"](x + w, y + h);\n          } else if (px < x + w / 4) {\n            a = new _mxPoint[\"default\"](x - Math.floor(0.25 * w), y);\n            b = new _mxPoint[\"default\"](x + Math.floor(0.5 * w), y + Math.floor(1.5 * h));\n          } else if (px > x + 3 * w / 4) {\n            a = new _mxPoint[\"default\"](x + Math.floor(0.5 * w), y + Math.floor(1.5 * h));\n            b = new _mxPoint[\"default\"](x + Math.floor(1.25 * w), y);\n          }\n        }\n      }\n      var tx = cx;\n      var ty = cy;\n      if (px >= x && px <= x + w) {\n        tx = px;\n        if (py < cy) {\n          ty = y + h;\n        } else {\n          ty = y;\n        }\n      } else if (py >= y && py <= y + h) {\n        ty = py;\n        if (px < cx) {\n          tx = x + w;\n        } else {\n          tx = x;\n        }\n      }\n      result = _mxUtils[\"default\"].intersection(tx, ty, next.x, next.y, a.x, a.y, b.x, b.y);\n    } else {\n      if (vertical) {\n        var beta = Math.atan2(h / 4, w / 2);\n\n        //Special cases where intersects with hexagon corners\n        if (alpha == beta) {\n          return new _mxPoint[\"default\"](x + w, y + Math.floor(0.25 * h));\n        } else if (alpha == pi2) {\n          return new _mxPoint[\"default\"](x + Math.floor(0.5 * w), y);\n        } else if (alpha == pi - beta) {\n          return new _mxPoint[\"default\"](x, y + Math.floor(0.25 * h));\n        } else if (alpha == -beta) {\n          return new _mxPoint[\"default\"](x + w, y + Math.floor(0.75 * h));\n        } else if (alpha == -pi2) {\n          return new _mxPoint[\"default\"](x + Math.floor(0.5 * w), y + h);\n        } else if (alpha == -pi + beta) {\n          return new _mxPoint[\"default\"](x, y + Math.floor(0.75 * h));\n        }\n        if (alpha < beta && alpha > -beta) {\n          a = new _mxPoint[\"default\"](x + w, y);\n          b = new _mxPoint[\"default\"](x + w, y + h);\n        } else if (alpha > beta && alpha < pi2) {\n          a = new _mxPoint[\"default\"](x, y - Math.floor(0.25 * h));\n          b = new _mxPoint[\"default\"](x + Math.floor(1.5 * w), y + Math.floor(0.5 * h));\n        } else if (alpha > pi2 && alpha < pi - beta) {\n          a = new _mxPoint[\"default\"](x - Math.floor(0.5 * w), y + Math.floor(0.5 * h));\n          b = new _mxPoint[\"default\"](x + w, y - Math.floor(0.25 * h));\n        } else if (alpha > pi - beta && alpha <= pi || alpha < -pi + beta && alpha >= -pi) {\n          a = new _mxPoint[\"default\"](x, y);\n          b = new _mxPoint[\"default\"](x, y + h);\n        } else if (alpha < -beta && alpha > -pi2) {\n          a = new _mxPoint[\"default\"](x + Math.floor(1.5 * w), y + Math.floor(0.5 * h));\n          b = new _mxPoint[\"default\"](x, y + Math.floor(1.25 * h));\n        } else if (alpha < -pi2 && alpha > -pi + beta) {\n          a = new _mxPoint[\"default\"](x - Math.floor(0.5 * w), y + Math.floor(0.5 * h));\n          b = new _mxPoint[\"default\"](x + w, y + Math.floor(1.25 * h));\n        }\n      } else {\n        var beta = Math.atan2(h / 2, w / 4);\n\n        //Special cases where intersects with hexagon corners\n        if (alpha == beta) {\n          return new _mxPoint[\"default\"](x + Math.floor(0.75 * w), y);\n        } else if (alpha == pi - beta) {\n          return new _mxPoint[\"default\"](x + Math.floor(0.25 * w), y);\n        } else if (alpha == pi || alpha == -pi) {\n          return new _mxPoint[\"default\"](x, y + Math.floor(0.5 * h));\n        } else if (alpha == 0) {\n          return new _mxPoint[\"default\"](x + w, y + Math.floor(0.5 * h));\n        } else if (alpha == -beta) {\n          return new _mxPoint[\"default\"](x + Math.floor(0.75 * w), y + h);\n        } else if (alpha == -pi + beta) {\n          return new _mxPoint[\"default\"](x + Math.floor(0.25 * w), y + h);\n        }\n        if (alpha > 0 && alpha < beta) {\n          a = new _mxPoint[\"default\"](x + Math.floor(0.5 * w), y - Math.floor(0.5 * h));\n          b = new _mxPoint[\"default\"](x + Math.floor(1.25 * w), y + h);\n        } else if (alpha > beta && alpha < pi - beta) {\n          a = new _mxPoint[\"default\"](x, y);\n          b = new _mxPoint[\"default\"](x + w, y);\n        } else if (alpha > pi - beta && alpha < pi) {\n          a = new _mxPoint[\"default\"](x - Math.floor(0.25 * w), y + h);\n          b = new _mxPoint[\"default\"](x + Math.floor(0.5 * w), y - Math.floor(0.5 * h));\n        } else if (alpha < 0 && alpha > -beta) {\n          a = new _mxPoint[\"default\"](x + Math.floor(0.5 * w), y + Math.floor(1.5 * h));\n          b = new _mxPoint[\"default\"](x + Math.floor(1.25 * w), y);\n        } else if (alpha < -beta && alpha > -pi + beta) {\n          a = new _mxPoint[\"default\"](x, y + h);\n          b = new _mxPoint[\"default\"](x + w, y + h);\n        } else if (alpha < -pi + beta && alpha > -pi) {\n          a = new _mxPoint[\"default\"](x - Math.floor(0.25 * w), y);\n          b = new _mxPoint[\"default\"](x + Math.floor(0.5 * w), y + Math.floor(1.5 * h));\n        }\n      }\n      result = _mxUtils[\"default\"].intersection(cx, cy, next.x, next.y, a.x, a.y, b.x, b.y);\n    }\n    if (result == null) {\n      return new _mxPoint[\"default\"](cx, cy);\n    }\n    return result;\n  }\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxPrintPreview\r\n *\r\n * Implements printing of a diagram across multiple pages. The following opens\r\n * a print preview for an existing graph:\r\n *\r\n * (code)\r\n * var preview = new mxPrintPreview(graph);\r\n * preview.open();\r\n * (end)\r\n *\r\n * Use <mxUtils.getScaleForPageCount> as follows in order to print the graph\r\n * across a given number of pages:\r\n *\r\n * (code)\r\n * var pageCount = mxUtils.prompt('Enter page count', '1');\r\n *\r\n * if (pageCount != null)\r\n * {\r\n *   var scale = mxUtils.getScaleForPageCount(pageCount, graph);\r\n *   var preview = new mxPrintPreview(graph, scale);\r\n *   preview.open();\r\n * }\r\n * (end)\r\n *\r\n * Additional pages:\r\n *\r\n * To add additional pages before and after the output, <getCoverPages> and\r\n * <getAppendices> can be used, respectively.\r\n *\r\n * (code)\r\n * var preview = new mxPrintPreview(graph, 1);\r\n *\r\n * preview.getCoverPages = function(w, h)\r\n * {\r\n *   return [this.renderPage(w, h, mxGraphUtils.bind(this, function(div)\r\n *   {\r\n *     div.innerHTML = '<div style=\"position:relative;margin:4px;\">Cover Page</p>'\r\n *   }))];\r\n * }\r\n *\r\n * preview.getAppendices = function(w, h)\r\n * {\r\n *   return [this.renderPage(w, h, mxGraphUtils.bind(this, function(div)\r\n *   {\r\n *     div.innerHTML = '<div style=\"position:relative;margin:4px;\">Appendix</p>'\r\n *   }))];\r\n * }\r\n *\r\n * preview.open();\r\n * (end)\r\n *\r\n * CSS:\r\n *\r\n * The CSS from the original page is not carried over to the print preview.\r\n * To add CSS to the page, use the css argument in the <open> function or\r\n * override <writeHead> to add the respective link tags as follows:\r\n *\r\n * (code)\r\n * var writeHead = preview.writeHead;\r\n * preview.writeHead = function(doc, css)\r\n * {\r\n *   writeHead.apply(this, arguments);\r\n *   doc.writeln('<link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\">');\r\n * };\r\n * (end)\r\n *\r\n * Padding:\r\n *\r\n * To add a padding to the page in the preview (but not the print output), use\r\n * the following code:\r\n *\r\n * (code)\r\n * preview.writeHead = function(doc)\r\n * {\r\n *   writeHead.apply(this, arguments);\r\n *\r\n *   doc.writeln('<style type=\"text/css\">');\r\n *   doc.writeln('@media screen {');\r\n *   doc.writeln('  body > div { padding-top:30px;padding-left:40px;box-sizing:content-box; }');\r\n *   doc.writeln('}');\r\n *   doc.writeln('</style>');\r\n * };\r\n * (end)\r\n *\r\n * Headers:\r\n *\r\n * Apart from setting the title argument in the mxPrintPreview constructor you\r\n * can override <renderPage> as follows to add a header to any page:\r\n *\r\n * (code)\r\n * var oldRenderPage = mxPrintPreview.prototype.renderPage;\r\n * mxPrintPreview.prototype.renderPage = function(w, h, x, y, content, pageNumber)\r\n * {\r\n *   var div = oldRenderPage.apply(this, arguments);\r\n *\r\n *   var header = document.createElement('div');\r\n *   header.style.position = 'absolute';\r\n *   header.style.top = '0px';\r\n *   header.style.width = '100%';\r\n *   header.style.textAlign = 'right';\r\n *   mxGraphUtils.write(header, 'Your header here');\r\n *   div.firstChild.appendChild(header);\r\n *\r\n *   return div;\r\n * };\r\n * (end)\r\n *\r\n * The pageNumber argument contains the number of the current page, starting at\r\n * 1. To display a header on the first page only, check pageNumber and add a\r\n * vertical offset in the constructor call for the height of the header.\r\n *\r\n * Page Format:\r\n *\r\n * For landscape printing, use <mxConstants.PAGE_FORMAT_A4_LANDSCAPE> as\r\n * the pageFormat in <mxUtils.getScaleForPageCount> and <mxPrintPreview>.\r\n * Keep in mind that one can not set the defaults for the print dialog\r\n * of the operating system from JavaScript so the user must manually choose\r\n * a page format that matches this setting.\r\n *\r\n * You can try passing the following CSS directive to <open> to set the\r\n * page format in the print dialog to landscape. However, this CSS\r\n * directive seems to be ignored in most major browsers, including IE.\r\n *\r\n * (code)\r\n * @page {\r\n *   size: landscape;\r\n * }\r\n * (end)\r\n *\r\n * Note that the print preview behaves differently in IE when used from the\r\n * filesystem or via HTTP so printing should always be tested via HTTP.\r\n *\r\n * If you are using a DOCTYPE in the source page you can override <getDoctype>\r\n * and provide the same DOCTYPE for the print preview if required. Here is\r\n * an example for IE8 standards mode.\r\n *\r\n * (code)\r\n * var preview = new mxPrintPreview(graph);\r\n * preview.getDoctype = function()\r\n * {\r\n *   return '<!--[if IE]><meta http-equiv=\"X-UA-Compatible\" content=\"IE=5,IE=8\" ><![endif]-->';\r\n * };\r\n * preview.open();\r\n * (end)\r\n *\r\n * Constructor: mxPrintPreview\r\n *\r\n * Constructs a new print preview for the given parameters.\r\n *\r\n * Parameters:\r\n *\r\n * graph - <mxGraph> to be previewed.\r\n * scale - Optional scale of the output. Default is 1 / <mxGraph.pageScale>.\r\n * border - Border in pixels along each side of every page. Note that the\r\n * actual print function in the browser will add another border for\r\n * printing.\r\n * pageFormat - <mxRectangle> that specifies the page format (in pixels).\r\n * This should match the page format of the printer. Default uses the\r\n * <mxGraph.pageFormat> of the given graph.\r\n * x0 - Optional left offset of the output. Default is 0.\r\n * y0 - Optional top offset of the output. Default is 0.\r\n * borderColor - Optional color of the page border. Default is no border.\r\n * Note that a border is sometimes useful to highlight the printed page\r\n * border in the print preview of the browser.\r\n * title - Optional string that is used for the window title. Default\r\n * is 'Printer-friendly version'.\r\n * pageSelector - Optional boolean that specifies if the page selector\r\n * should appear in the window with the print preview. Default is true.\r\n */\nvar _default = exports[\"default\"] = mxPerimeter;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxPerimeter.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxPoint.js":
/*!******************************************!*\
  !*** ./src/workflow/mxClient/mxPoint.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxPoint(x, y) {\n  this.x = x != null ? x : 0;\n  this.y = y != null ? y : 0;\n}\n;\n\n/**\r\n * Variable: x\r\n *\r\n * Holds the x-coordinate of the point. Default is 0.\r\n */\nmxPoint.prototype.x = null;\n\n/**\r\n * Variable: y\r\n *\r\n * Holds the y-coordinate of the point. Default is 0.\r\n */\nmxPoint.prototype.y = null;\n\n/**\r\n * Function: equals\r\n *\r\n * Returns true if the given object equals this point.\r\n */\nmxPoint.prototype.equals = function (obj) {\n  return obj != null && obj.x == this.x && obj.y == this.y;\n};\n\n/**\r\n * Function: clone\r\n *\r\n * Returns a clone of this <mxPoint>.\r\n */\nmxPoint.prototype.clone = function () {\n  // Handles subclasses as well\n  return _mxGraphUtils[\"default\"].clone(this);\n};\nmxPoint.getName = function () {\n  return 'mxPoint';\n};\n\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxRectangle\r\n *\r\n * Extends <mxPoint> to implement a 2-dimensional rectangle with double\r\n * precision coordinates.\r\n *\r\n * Constructor: mxRectangle\r\n *\r\n * Constructs a new rectangle for the optional parameters. If no parameters\r\n * are given then the respective default values are used.\r\n */\nvar _default = exports[\"default\"] = mxPoint;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxPoint.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxPolyline.js":
/*!*********************************************!*\
  !*** ./src/workflow/mxClient/mxPolyline.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxShape = _interopRequireDefault(__webpack_require__(/*! ./mxShape.js */ \"./src/workflow/mxClient/mxShape.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ./mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxPolyline(points, stroke, strokewidth) {\n  _mxShape[\"default\"].call(this);\n  this.points = points;\n  this.stroke = stroke;\n  this.strokewidth = strokewidth != null ? strokewidth : 1;\n}\n;\n\n/**\r\n * Extends mxShape.\r\n */\n_mxGraphUtils[\"default\"].extend(mxPolyline, _mxShape[\"default\"]);\n\n/**\r\n * Function: getRotation\r\n *\r\n * Returns 0.\r\n */\nmxPolyline.prototype.getRotation = function () {\n  return 0;\n};\n\n/**\r\n * Function: getShapeRotation\r\n *\r\n * Returns 0.\r\n */\nmxPolyline.prototype.getShapeRotation = function () {\n  return 0;\n};\n\n/**\r\n * Function: isPaintBoundsInverted\r\n *\r\n * Returns false.\r\n */\nmxPolyline.prototype.isPaintBoundsInverted = function () {\n  return false;\n};\n\n/**\r\n * Function: paintEdgeShape\r\n *\r\n * Paints the line shape.\r\n */\nmxPolyline.prototype.paintEdgeShape = function (c, pts) {\n  if (this.style == null || this.style[_mxConstants[\"default\"].STYLE_CURVED] != 1) {\n    this.paintLine(c, pts, this.isRounded);\n  } else {\n    this.paintCurvedLine(c, pts);\n  }\n};\n\n/**\r\n * Function: paintLine\r\n *\r\n * Paints the line shape.\r\n */\nmxPolyline.prototype.paintLine = function (c, pts, rounded) {\n  var arcSize = _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_ARCSIZE, _mxConstants[\"default\"].LINE_ARCSIZE) / 2;\n  c.begin();\n  this.addPoints(c, pts, rounded, arcSize, false);\n  c.stroke();\n};\n\n/**\r\n * Function: paintLine\r\n *\r\n * Paints the line shape.\r\n */\nmxPolyline.prototype.paintCurvedLine = function (c, pts) {\n  c.begin();\n  var pt = pts[0];\n  var n = pts.length;\n  c.moveTo(pt.x, pt.y);\n  for (var i = 1; i < n - 2; i++) {\n    var p0 = pts[i];\n    var p1 = pts[i + 1];\n    var ix = (p0.x + p1.x) / 2;\n    var iy = (p0.y + p1.y) / 2;\n    c.quadTo(p0.x, p0.y, ix, iy);\n  }\n  var p0 = pts[n - 2];\n  var p1 = pts[n - 1];\n  c.quadTo(p0.x, p0.y, p1.x, p1.y);\n  c.stroke();\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxArrow\r\n *\r\n * Extends <mxShape> to implement an arrow shape. (The shape\r\n * is used to represent edges, not vertices.)\r\n * This shape is registered under <mxConstants.SHAPE_ARROW>\r\n * in <mxCellRenderer>.\r\n *\r\n * Constructor: mxArrow\r\n *\r\n * Constructs a new arrow shape.\r\n *\r\n * Parameters:\r\n *\r\n * points - Array of <mxPoints> that define the points. This is stored in\r\n * <mxShape.points>.\r\n * fill - String that defines the fill color. This is stored in <fill>.\r\n * stroke - String that defines the stroke color. This is stored in <stroke>.\r\n * strokewidth - Optional integer that defines the stroke width. Default is\r\n * 1. This is stored in <strokewidth>.\r\n * arrowWidth - Optional integer that defines the arrow width. Default is\r\n * <mxConstants.ARROW_WIDTH>. This is stored in <arrowWidth>.\r\n * spacing - Optional integer that defines the spacing between the arrow shape\r\n * and its endpoints. Default is <mxConstants.ARROW_SPACING>. This is stored in\r\n * <spacing>.\r\n * endSize - Optional integer that defines the size of the arrowhead. Default\r\n * is <mxConstants.ARROW_SIZE>. This is stored in <endSize>.\r\n */\nvar _default = exports[\"default\"] = mxPolyline;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxPolyline.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxPopupMenu.js":
/*!**********************************************!*\
  !*** ./src/workflow/mxClient/mxPopupMenu.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.filter.js */ \"../../node_modules/core-js/modules/es.array.filter.js\");\n__webpack_require__(/*! core-js/modules/es.function.bind.js */ \"../../node_modules/core-js/modules/es.function.bind.js\");\n__webpack_require__(/*! core-js/modules/es.object.to-string.js */ \"../../node_modules/core-js/modules/es.object.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.parse-int.js */ \"../../node_modules/core-js/modules/es.parse-int.js\");\nvar _mxEventObject = _interopRequireDefault(__webpack_require__(/*! ./mxEventObject.js */ \"./src/workflow/mxClient/mxEventObject.js\"));\nvar _mxClient = _interopRequireDefault(__webpack_require__(/*! ./mxClient.js */ \"./src/workflow/mxClient/mxClient.js\"));\nvar _mxEvent = _interopRequireDefault(__webpack_require__(/*! ./mxEvent.js */ \"./src/workflow/mxClient/mxEvent.js\"));\nvar _mxEventSource = _interopRequireDefault(__webpack_require__(/*! ./mxEventSource.js */ \"./src/workflow/mxClient/mxEventSource.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxUtils = _interopRequireDefault(__webpack_require__(/*! ./mxUtils.js */ \"./src/workflow/mxClient/mxUtils.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxPopupMenu(factoryMethod) {\n  this.factoryMethod = factoryMethod;\n  if (factoryMethod != null) {\n    this.init();\n  }\n}\n;\n\n/**\r\n * Extends mxEventSource.\r\n */\nmxPopupMenu.prototype = new _mxEventSource[\"default\"]();\nmxPopupMenu.prototype.constructor = mxPopupMenu;\n\n/**\r\n * Variable: submenuImage\r\n *\r\n * URL of the image to be used for the submenu icon.\r\n */\nmxPopupMenu.prototype.submenuImage = _mxClient[\"default\"].imageBasePath + '/submenu.gif';\n\n/**\r\n * Variable: zIndex\r\n *\r\n * Specifies the zIndex for the popupmenu and its shadow. Default is 1006.\r\n */\nmxPopupMenu.prototype.zIndex = 10006;\n\n/**\r\n * Variable: factoryMethod\r\n *\r\n * Function that is used to create the popup menu. The function takes the\r\n * current panning handler, the <mxCell> under the mouse and the mouse\r\n * event that triggered the call as arguments.\r\n */\nmxPopupMenu.prototype.factoryMethod = null;\n\n/**\r\n * Variable: useLeftButtonForPopup\r\n *\r\n * Specifies if popupmenus should be activated by clicking the left mouse\r\n * button. Default is false.\r\n */\nmxPopupMenu.prototype.useLeftButtonForPopup = false;\n\n/**\r\n * Variable: enabled\r\n *\r\n * Specifies if events are handled. Default is true.\r\n */\nmxPopupMenu.prototype.enabled = true;\n\n/**\r\n * Variable: itemCount\r\n *\r\n * Contains the number of times <addItem> has been called for a new menu.\r\n */\nmxPopupMenu.prototype.itemCount = 0;\n\n/**\r\n * Variable: autoExpand\r\n *\r\n * Specifies if submenus should be expanded on mouseover. Default is false.\r\n */\nmxPopupMenu.prototype.autoExpand = false;\n\n/**\r\n * Variable: smartSeparators\r\n *\r\n * Specifies if separators should only be added if a menu item follows them.\r\n * Default is false.\r\n */\nmxPopupMenu.prototype.smartSeparators = false;\n\n/**\r\n * Variable: labels\r\n *\r\n * Specifies if any labels should be visible. Default is true.\r\n */\nmxPopupMenu.prototype.labels = true;\n\n/**\r\n * Function: init\r\n *\r\n * Initializes the shapes required for this vertex handler.\r\n */\nmxPopupMenu.prototype.init = function () {\n  // Adds the inner table\n  this.table = document.createElement('table');\n  this.table.className = 'mxPopupMenu';\n  this.tbody = document.createElement('tbody');\n  this.table.appendChild(this.tbody);\n\n  // Adds the outer div\n  this.div = document.createElement('div');\n  this.div.className = 'mxPopupMenu';\n  this.div.style.display = 'inline';\n  this.div.style.zIndex = this.zIndex;\n  this.div.appendChild(this.table);\n\n  // Disables the context menu on the outer div\n  _mxEvent[\"default\"].disableContextMenu(this.div);\n};\n\n/**\r\n * Function: isEnabled\r\n *\r\n * Returns true if events are handled. This implementation\r\n * returns <enabled>.\r\n */\nmxPopupMenu.prototype.isEnabled = function () {\n  return this.enabled;\n};\n\n/**\r\n * Function: setEnabled\r\n *\r\n * Enables or disables event handling. This implementation\r\n * updates <enabled>.\r\n */\nmxPopupMenu.prototype.setEnabled = function (enabled) {\n  this.enabled = enabled;\n};\n\n/**\r\n * Function: isPopupTrigger\r\n *\r\n * Returns true if the given event is a popupmenu trigger for the optional\r\n * given cell.\r\n *\r\n * Parameters:\r\n *\r\n * me - <mxMouseEvent> that represents the mouse event.\r\n */\nmxPopupMenu.prototype.isPopupTrigger = function (me) {\n  return me.isPopupTrigger() || this.useLeftButtonForPopup && _mxEvent[\"default\"].isLeftMouseButton(me.getEvent());\n};\n\n/**\r\n * Function: addItem\r\n *\r\n * Adds the given item to the given parent item. If no parent item is specified\r\n * then the item is added to the top-level menu. The return value may be used\r\n * as the parent argument, ie. as a submenu item. The return value is the table\r\n * row that represents the item.\r\n *\r\n * Paramters:\r\n *\r\n * title - String that represents the title of the menu item.\r\n * image - Optional URL for the image icon.\r\n * funct - Function associated that takes a mouseup or touchend event.\r\n * parent - Optional item returned by <addItem>.\r\n * iconCls - Optional string that represents the CSS class for the image icon.\r\n * IconsCls is ignored if image is given.\r\n * enabled - Optional boolean indicating if the item is enabled. Default is true.\r\n * active - Optional boolean indicating if the menu should implement any event handling.\r\n * Default is true.\r\n */\nmxPopupMenu.prototype.addItem = function (title, image, funct, parent, iconCls, enabled, active) {\n  parent = parent || this;\n  this.itemCount++;\n\n  // Smart separators only added if element contains items\n  if (parent.willAddSeparator) {\n    if (parent.containsItems) {\n      this.addSeparator(parent, true);\n    }\n    parent.willAddSeparator = false;\n  }\n  parent.containsItems = true;\n  var tr = document.createElement('tr');\n  tr.className = 'mxPopupMenuItem';\n  var col1 = document.createElement('td');\n  col1.className = 'mxPopupMenuIcon';\n\n  // Adds the given image into the first column\n  if (image != null) {\n    var img = document.createElement('img');\n    img.src = image;\n    col1.appendChild(img);\n  } else if (iconCls != null) {\n    var div = document.createElement('div');\n    div.className = iconCls;\n    col1.appendChild(div);\n  }\n  tr.appendChild(col1);\n  if (this.labels) {\n    var col2 = document.createElement('td');\n    col2.className = 'mxPopupMenuItem' + (enabled != null && !enabled ? ' mxDisabled' : '');\n    _mxGraphUtils[\"default\"].write(col2, title);\n    col2.align = 'left';\n    tr.appendChild(col2);\n    var col3 = document.createElement('td');\n    col3.className = 'mxPopupMenuItem' + (enabled != null && !enabled ? ' mxDisabled' : '');\n    col3.style.paddingRight = '6px';\n    col3.style.textAlign = 'right';\n    tr.appendChild(col3);\n    if (parent.div == null) {\n      this.createSubmenu(parent);\n    }\n  }\n  parent.tbody.appendChild(tr);\n  if (active != false && enabled != false) {\n    var currentSelection = null;\n    _mxEvent[\"default\"].addGestureListeners(tr, _mxGraphUtils[\"default\"].bind(this, function (evt) {\n      this.eventReceiver = tr;\n      if (parent.activeRow != tr && parent.activeRow != parent) {\n        if (parent.activeRow != null && parent.activeRow.div.parentNode != null) {\n          this.hideSubmenu(parent);\n        }\n        if (tr.div != null) {\n          this.showSubmenu(parent, tr);\n          parent.activeRow = tr;\n        }\n      }\n\n      // Workaround for lost current selection in page because of focus in IE\n      if (_mxClient[\"default\"].IS_QUIRKS || document.documentMode == 8) {\n        currentSelection = document.selection.createRange();\n      }\n      _mxEvent[\"default\"].consume(evt);\n    }), _mxGraphUtils[\"default\"].bind(this, function (evt) {\n      if (parent.activeRow != tr && parent.activeRow != parent) {\n        if (parent.activeRow != null && parent.activeRow.div.parentNode != null) {\n          this.hideSubmenu(parent);\n        }\n        if (this.autoExpand && tr.div != null) {\n          this.showSubmenu(parent, tr);\n          parent.activeRow = tr;\n        }\n      }\n\n      // Sets hover style because TR in IE doesn't have hover\n      tr.className = 'mxPopupMenuItemHover';\n    }), _mxGraphUtils[\"default\"].bind(this, function (evt) {\n      // EventReceiver avoids clicks on a submenu item\n      // which has just been shown in the mousedown\n      if (this.eventReceiver == tr) {\n        if (parent.activeRow != tr) {\n          this.hideMenu();\n        }\n\n        // Workaround for lost current selection in page because of focus in IE\n        if (currentSelection != null) {\n          // Workaround for \"unspecified error\" in IE8 standards\n          try {\n            currentSelection.select();\n          } catch (e) {\n            // ignore\n          }\n          currentSelection = null;\n        }\n        if (funct != null) {\n          funct(evt);\n        }\n      }\n      this.eventReceiver = null;\n      _mxEvent[\"default\"].consume(evt);\n    }));\n\n    // Resets hover style because TR in IE doesn't have hover\n    _mxEvent[\"default\"].addListener(tr, 'mouseout', _mxGraphUtils[\"default\"].bind(this, function (evt) {\n      tr.className = 'mxPopupMenuItem';\n    }));\n  }\n  return tr;\n};\n\n/**\r\n * Adds a checkmark to the given menuitem.\r\n */\nmxPopupMenu.prototype.addCheckmark = function (item, img) {\n  var td = item.firstChild.nextSibling;\n  td.style.backgroundImage = 'url(\\'' + img + '\\')';\n  td.style.backgroundRepeat = 'no-repeat';\n  td.style.backgroundPosition = '2px 50%';\n};\n\n/**\r\n * Function: createSubmenu\r\n *\r\n * Creates the nodes required to add submenu items inside the given parent\r\n * item. This is called in <addItem> if a parent item is used for the first\r\n * time. This adds various DOM nodes and a <submenuImage> to the parent.\r\n *\r\n * Parameters:\r\n *\r\n * parent - An item returned by <addItem>.\r\n */\nmxPopupMenu.prototype.createSubmenu = function (parent) {\n  parent.table = document.createElement('table');\n  parent.table.className = 'mxPopupMenu';\n  parent.tbody = document.createElement('tbody');\n  parent.table.appendChild(parent.tbody);\n  parent.div = document.createElement('div');\n  parent.div.className = 'mxPopupMenu';\n  parent.div.style.position = 'absolute';\n  parent.div.style.display = 'inline';\n  parent.div.style.zIndex = this.zIndex;\n  parent.div.appendChild(parent.table);\n  var img = document.createElement('img');\n  img.setAttribute('src', this.submenuImage);\n\n  // Last column of the submenu item in the parent menu\n  td = parent.firstChild.nextSibling.nextSibling;\n  td.appendChild(img);\n};\n\n/**\r\n * Function: showSubmenu\r\n *\r\n * Shows the submenu inside the given parent row.\r\n */\nmxPopupMenu.prototype.showSubmenu = function (parent, row) {\n  if (row.div != null) {\n    row.div.style.left = parent.div.offsetLeft + row.offsetLeft + row.offsetWidth - 1 + 'px';\n    row.div.style.top = parent.div.offsetTop + row.offsetTop + 'px';\n    document.body.appendChild(row.div);\n\n    // Moves the submenu to the left side if there is no space\n    var left = parseInt(row.div.offsetLeft);\n    var width = parseInt(row.div.offsetWidth);\n    var offset = _mxUtils[\"default\"].getDocumentScrollOrigin(document);\n    var b = document.body;\n    var d = document.documentElement;\n    var right = offset.x + (b.clientWidth || d.clientWidth);\n    if (left + width > right) {\n      row.div.style.left = parent.div.offsetLeft - width + (_mxClient[\"default\"].IS_IE ? 6 : -6) + 'px';\n    }\n    _mxUtils[\"default\"].fit(row.div);\n  }\n};\n\n/**\r\n * Function: addSeparator\r\n *\r\n * Adds a horizontal separator in the given parent item or the top-level menu\r\n * if no parent is specified.\r\n *\r\n * Parameters:\r\n *\r\n * parent - Optional item returned by <addItem>.\r\n * force - Optional boolean to ignore <smartSeparators>. Default is false.\r\n */\nmxPopupMenu.prototype.addSeparator = function (parent, force) {\n  parent = parent || this;\n  if (this.smartSeparators && !force) {\n    parent.willAddSeparator = true;\n  } else if (parent.tbody != null) {\n    parent.willAddSeparator = false;\n    var tr = document.createElement('tr');\n    var col1 = document.createElement('td');\n    col1.className = 'mxPopupMenuIcon';\n    col1.style.padding = '0 0 0 0px';\n    tr.appendChild(col1);\n    var col2 = document.createElement('td');\n    col2.style.padding = '0 0 0 0px';\n    col2.setAttribute('colSpan', '2');\n    var hr = document.createElement('hr');\n    hr.setAttribute('size', '1');\n    col2.appendChild(hr);\n    tr.appendChild(col2);\n    parent.tbody.appendChild(tr);\n  }\n};\n\n/**\r\n * Function: popup\r\n *\r\n * Shows the popup menu for the given event and cell.\r\n *\r\n * Example:\r\n *\r\n * (code)\r\n * graph.panningHandler.popup = function(x, y, cell, evt)\r\n * {\r\n *   mxUtils.alert('Hello, World!');\r\n * }\r\n * (end)\r\n */\nmxPopupMenu.prototype.popup = function (x, y, cell, evt) {\n  if (this.div != null && this.tbody != null && this.factoryMethod != null) {\n    this.div.style.left = x + 'px';\n    this.div.style.top = y + 'px';\n\n    // Removes all child nodes from the existing menu\n    while (this.tbody.firstChild != null) {\n      _mxEvent[\"default\"].release(this.tbody.firstChild);\n      this.tbody.removeChild(this.tbody.firstChild);\n    }\n    this.itemCount = 0;\n    this.factoryMethod(this, cell, evt);\n    if (this.itemCount > 0) {\n      this.showMenu();\n      this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].SHOW));\n    }\n  }\n};\n\n/**\r\n * Function: isMenuShowing\r\n *\r\n * Returns true if the menu is showing.\r\n */\nmxPopupMenu.prototype.isMenuShowing = function () {\n  return this.div != null && this.div.parentNode == document.body;\n};\n\n/**\r\n * Function: showMenu\r\n *\r\n * Shows the menu.\r\n */\nmxPopupMenu.prototype.showMenu = function () {\n  // Disables filter-based shadow in IE9 standards mode\n  if (document.documentMode >= 9) {\n    this.div.style.filter = 'none';\n  }\n\n  // Fits the div inside the viewport\n  document.body.appendChild(this.div);\n  _mxUtils[\"default\"].fit(this.div);\n};\n\n/**\r\n * Function: hideMenu\r\n *\r\n * Removes the menu and all submenus.\r\n */\nmxPopupMenu.prototype.hideMenu = function () {\n  if (this.div != null) {\n    if (this.div.parentNode != null) {\n      this.div.parentNode.removeChild(this.div);\n    }\n    this.hideSubmenu(this);\n    this.containsItems = false;\n    this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].HIDE));\n  }\n};\n\n/**\r\n * Function: hideSubmenu\r\n *\r\n * Removes all submenus inside the given parent.\r\n *\r\n * Parameters:\r\n *\r\n * parent - An item returned by <addItem>.\r\n */\nmxPopupMenu.prototype.hideSubmenu = function (parent) {\n  if (parent.activeRow != null) {\n    this.hideSubmenu(parent.activeRow);\n    if (parent.activeRow.div.parentNode != null) {\n      parent.activeRow.div.parentNode.removeChild(parent.activeRow.div);\n    }\n    parent.activeRow = null;\n  }\n};\n\n/**\r\n * Function: destroy\r\n *\r\n * Destroys the handler and all its resources and DOM nodes.\r\n */\nmxPopupMenu.prototype.destroy = function () {\n  if (this.div != null) {\n    _mxEvent[\"default\"].release(this.div);\n    if (this.div.parentNode != null) {\n      this.div.parentNode.removeChild(this.div);\n    }\n    this.div = null;\n  }\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxAutoSaveManager\r\n *\r\n * Manager for automatically saving diagrams. The <save> hook must be\r\n * implemented.\r\n *\r\n * Example:\r\n *\r\n * (code)\r\n * var mgr = new mxAutoSaveManager(editor.graph);\r\n * mgr.save = function()\r\n * {\r\n *   mxLog.show();\r\n *   mxLog.debug('save');\r\n * };\r\n * (end)\r\n *\r\n * Constructor: mxAutoSaveManager\r\n *\r\n * Constructs a new automatic layout for the given graph.\r\n *\r\n * Arguments:\r\n *\r\n * graph - Reference to the enclosing graph.\r\n */\nvar _default = exports[\"default\"] = mxPopupMenu;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxPopupMenu.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxPopupMenuHandler.js":
/*!*****************************************************!*\
  !*** ./src/workflow/mxClient/mxPopupMenuHandler.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.function.bind.js */ \"../../node_modules/core-js/modules/es.function.bind.js\");\nvar _mxEvent = _interopRequireDefault(__webpack_require__(/*! ./mxEvent.js */ \"./src/workflow/mxClient/mxEvent.js\"));\nvar _mxPopupMenu = _interopRequireDefault(__webpack_require__(/*! ./mxPopupMenu.js */ \"./src/workflow/mxClient/mxPopupMenu.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxUtils = _interopRequireDefault(__webpack_require__(/*! ./mxUtils.js */ \"./src/workflow/mxClient/mxUtils.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxPopupMenuHandler(graph, factoryMethod) {\n  if (graph != null) {\n    this.graph = graph;\n    this.factoryMethod = factoryMethod;\n    this.graph.addMouseListener(this);\n\n    // Does not show menu if any touch gestures take place after the trigger\n    this.gestureHandler = _mxGraphUtils[\"default\"].bind(this, function (sender, eo) {\n      this.inTolerance = false;\n    });\n    this.graph.addListener(_mxEvent[\"default\"].GESTURE, this.gestureHandler);\n    this.init();\n  }\n}\n;\n\n/**\r\n * Extends mxPopupMenu.\r\n */\nmxPopupMenuHandler.prototype = new _mxPopupMenu[\"default\"]();\nmxPopupMenuHandler.prototype.constructor = mxPopupMenuHandler;\n\n/**\r\n * Variable: graph\r\n *\r\n * Reference to the enclosing <mxGraph>.\r\n */\nmxPopupMenuHandler.prototype.graph = null;\n\n/**\r\n * Variable: selectOnPopup\r\n *\r\n * Specifies if cells should be selected if a popupmenu is displayed for\r\n * them. Default is true.\r\n */\nmxPopupMenuHandler.prototype.selectOnPopup = true;\n\n/**\r\n * Variable: clearSelectionOnBackground\r\n *\r\n * Specifies if cells should be deselected if a popupmenu is displayed for\r\n * the diagram background. Default is true.\r\n */\nmxPopupMenuHandler.prototype.clearSelectionOnBackground = true;\n\n/**\r\n * Variable: triggerX\r\n *\r\n * X-coordinate of the mouse down event.\r\n */\nmxPopupMenuHandler.prototype.triggerX = null;\n\n/**\r\n * Variable: triggerY\r\n *\r\n * Y-coordinate of the mouse down event.\r\n */\nmxPopupMenuHandler.prototype.triggerY = null;\n\n/**\r\n * Variable: screenX\r\n *\r\n * Screen X-coordinate of the mouse down event.\r\n */\nmxPopupMenuHandler.prototype.screenX = null;\n\n/**\r\n * Variable: screenY\r\n *\r\n * Screen Y-coordinate of the mouse down event.\r\n */\nmxPopupMenuHandler.prototype.screenY = null;\n\n/**\r\n * Function: init\r\n *\r\n * Initializes the shapes required for this vertex handler.\r\n */\nmxPopupMenuHandler.prototype.init = function () {\n  // Supercall\n  _mxPopupMenu[\"default\"].prototype.init.apply(this);\n\n  // Hides the tooltip if the mouse is over\n  // the context menu\n  _mxEvent[\"default\"].addGestureListeners(this.div, _mxGraphUtils[\"default\"].bind(this, function (evt) {\n    this.graph.tooltipHandler.hide();\n  }));\n};\n\n/**\r\n * Function: isSelectOnPopup\r\n *\r\n * Hook for returning if a cell should be selected for a given <mxMouseEvent>.\r\n * This implementation returns <selectOnPopup>.\r\n */\nmxPopupMenuHandler.prototype.isSelectOnPopup = function (me) {\n  return this.selectOnPopup;\n};\n\n/**\r\n * Function: mouseDown\r\n *\r\n * Handles the event by initiating the panning. By consuming the event all\r\n * subsequent events of the gesture are redirected to this handler.\r\n */\nmxPopupMenuHandler.prototype.mouseDown = function (sender, me) {\n  if (this.isEnabled() && !_mxEvent[\"default\"].isMultiTouchEvent(me.getEvent())) {\n    // Hides the popupmenu if is is being displayed\n    this.hideMenu();\n    this.triggerX = me.getGraphX();\n    this.triggerY = me.getGraphY();\n    this.screenX = _mxEvent[\"default\"].getMainEvent(me.getEvent()).screenX;\n    this.screenY = _mxEvent[\"default\"].getMainEvent(me.getEvent()).screenY;\n    this.popupTrigger = this.isPopupTrigger(me);\n    this.inTolerance = true;\n  }\n};\n\n/**\r\n * Function: mouseMove\r\n *\r\n * Handles the event by updating the panning on the graph.\r\n */\nmxPopupMenuHandler.prototype.mouseMove = function (sender, me) {\n  // Popup trigger may change on mouseUp so ignore it\n  if (this.inTolerance && this.screenX != null && this.screenY != null) {\n    if (Math.abs(_mxEvent[\"default\"].getMainEvent(me.getEvent()).screenX - this.screenX) > this.graph.tolerance || Math.abs(_mxEvent[\"default\"].getMainEvent(me.getEvent()).screenY - this.screenY) > this.graph.tolerance) {\n      this.inTolerance = false;\n    }\n  }\n};\n\n/**\r\n * Function: mouseUp\r\n *\r\n * Handles the event by setting the translation on the view or showing the\r\n * popupmenu.\r\n */\nmxPopupMenuHandler.prototype.mouseUp = function (sender, me) {\n  if (this.popupTrigger && this.inTolerance && this.triggerX != null && this.triggerY != null) {\n    var cell = this.getCellForPopupEvent(me);\n\n    // Selects the cell for which the context menu is being displayed\n    if (this.graph.isEnabled() && this.isSelectOnPopup(me) && cell != null && !this.graph.isCellSelected(cell)) {\n      this.graph.setSelectionCell(cell);\n    } else if (this.clearSelectionOnBackground && cell == null) {\n      this.graph.clearSelection();\n    }\n\n    // Hides the tooltip if there is one\n    this.graph.tooltipHandler.hide();\n\n    // Menu is shifted by 1 pixel so that the mouse up event\n    // is routed via the underlying shape instead of the DIV\n    var origin = _mxUtils[\"default\"].getScrollOrigin();\n    this.popup(me.getX() + origin.x + 1, me.getY() + origin.y + 1, cell, me.getEvent());\n    me.consume();\n  }\n  this.popupTrigger = false;\n  this.inTolerance = false;\n};\n\n/**\r\n * Function: getCellForPopupEvent\r\n *\r\n * Hook to return the cell for the mouse up popup trigger handling.\r\n */\nmxPopupMenuHandler.prototype.getCellForPopupEvent = function (me) {\n  return me.getCell();\n};\n\n/**\r\n * Function: destroy\r\n *\r\n * Destroys the handler and all its resources and DOM nodes.\r\n */\nmxPopupMenuHandler.prototype.destroy = function () {\n  this.graph.removeMouseListener(this);\n  this.graph.removeListener(this.gestureHandler);\n\n  // Supercall\n  _mxPopupMenu[\"default\"].prototype.destroy.apply(this);\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxCellMarker\r\n *\r\n * A helper class to process mouse locations and highlight cells.\r\n *\r\n * Helper class to highlight cells. To add a cell marker to an existing graph\r\n * for highlighting all cells, the following code is used:\r\n *\r\n * (code)\r\n * var marker = new mxCellMarker(graph);\r\n * graph.addMouseListener({\r\n *   mouseDown: function() {},\r\n *   mouseMove: function(sender, me)\r\n *   {\r\n *     marker.process(me);\r\n *   },\r\n *   mouseUp: function() {}\r\n * });\r\n * (end)\r\n *\r\n * Event: mxEvent.MARK\r\n *\r\n * Fires after a cell has been marked or unmarked. The <code>state</code>\r\n * property contains the marked <mxCellState> or null if no state is marked.\r\n *\r\n * Constructor: mxCellMarker\r\n *\r\n * Constructs a new cell marker.\r\n *\r\n * Parameters:\r\n *\r\n * graph - Reference to the enclosing <mxGraph>.\r\n * validColor - Optional marker color for valid states. Default is\r\n * <mxConstants.DEFAULT_VALID_COLOR>.\r\n * invalidColor - Optional marker color for invalid states. Default is\r\n * <mxConstants.DEFAULT_INVALID_COLOR>.\r\n * hotspot - Portion of the width and hight where a state intersects a\r\n * given coordinate pair. A value of 0 means always highlight. Default is\r\n * <mxConstants.DEFAULT_HOTSPOT>.\r\n */\nvar _default = exports[\"default\"] = mxPopupMenuHandler;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxPopupMenuHandler.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxPrintPreview.js":
/*!*************************************************!*\
  !*** ./src/workflow/mxClient/mxPrintPreview.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.function.bind.js */ \"../../node_modules/core-js/modules/es.function.bind.js\");\n__webpack_require__(/*! core-js/modules/es.string.link.js */ \"../../node_modules/core-js/modules/es.string.link.js\");\nvar _mxClient = _interopRequireDefault(__webpack_require__(/*! ./mxClient.js */ \"./src/workflow/mxClient/mxClient.js\"));\nvar _mxEvent = _interopRequireDefault(__webpack_require__(/*! ./mxEvent.js */ \"./src/workflow/mxClient/mxEvent.js\"));\nvar _mxTemporaryCellStates = _interopRequireDefault(__webpack_require__(/*! ./mxTemporaryCellStates.js */ \"./src/workflow/mxClient/mxTemporaryCellStates.js\"));\nvar _mxPoint = _interopRequireDefault(__webpack_require__(/*! ./mxPoint.js */ \"./src/workflow/mxClient/mxPoint.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxRectangle = _interopRequireDefault(__webpack_require__(/*! ./mxRectangle.js */ \"./src/workflow/mxClient/mxRectangle.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ./mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nvar _mxUtils = _interopRequireDefault(__webpack_require__(/*! ./mxUtils.js */ \"./src/workflow/mxClient/mxUtils.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxPrintPreview(graph, scale, pageFormat, border, x0, y0, borderColor, title, pageSelector) {\n  this.graph = graph;\n  this.scale = scale != null ? scale : 1 / graph.pageScale;\n  this.border = border != null ? border : 0;\n  this.pageFormat = pageFormat != null ? pageFormat : graph.pageFormat;\n  this.title = title != null ? title : 'Printer-friendly version';\n  this.x0 = x0 != null ? x0 : 0;\n  this.y0 = y0 != null ? y0 : 0;\n  this.borderColor = borderColor;\n  this.pageSelector = pageSelector != null ? pageSelector : true;\n}\n;\n\n/**\r\n * Variable: graph\r\n *\r\n * Reference to the <mxGraph> that should be previewed.\r\n */\nmxPrintPreview.prototype.graph = null;\n\n/**\r\n * Variable: pageFormat\r\n *\r\n * Holds the <mxRectangle> that defines the page format.\r\n */\nmxPrintPreview.prototype.pageFormat = null;\n\n/**\r\n * Variable: scale\r\n *\r\n * Holds the scale of the print preview.\r\n */\nmxPrintPreview.prototype.scale = null;\n\n/**\r\n * Variable: border\r\n *\r\n * The border inset around each side of every page in the preview. This is set\r\n * to 0 if autoOrigin is false.\r\n */\nmxPrintPreview.prototype.border = 0;\n\n/**\r\n * Variable: marginTop\r\n *\r\n * The margin at the top of the page (number). Default is 0.\r\n */\nmxPrintPreview.prototype.marginTop = 0;\n\n/**\r\n * Variable: marginBottom\r\n *\r\n * The margin at the bottom of the page (number). Default is 0.\r\n */\nmxPrintPreview.prototype.marginBottom = 0;\n\n/**\r\n * Variable: x0\r\n *\r\n * Holds the horizontal offset of the output.\r\n */\nmxPrintPreview.prototype.x0 = 0;\n\n/**\r\n * Variable: y0\r\n *\r\n * Holds the vertical offset of the output.\r\n */\nmxPrintPreview.prototype.y0 = 0;\n\n/**\r\n * Variable: autoOrigin\r\n *\r\n * Specifies if the origin should be automatically computed based on the top,\r\n * left corner of the actual diagram contents. The required offset will be added\r\n * to <x0> and <y0> in <open>. Default is true.\r\n */\nmxPrintPreview.prototype.autoOrigin = true;\n\n/**\r\n * Variable: printOverlays\r\n *\r\n * Specifies if overlays should be printed. Default is false.\r\n */\nmxPrintPreview.prototype.printOverlays = false;\n\n/**\r\n * Variable: printControls\r\n *\r\n * Specifies if controls (such as folding icons) should be printed. Default is\r\n * false.\r\n */\nmxPrintPreview.prototype.printControls = false;\n\n/**\r\n * Variable: printBackgroundImage\r\n *\r\n * Specifies if the background image should be printed. Default is false.\r\n */\nmxPrintPreview.prototype.printBackgroundImage = false;\n\n/**\r\n * Variable: backgroundColor\r\n *\r\n * Holds the color value for the page background color. Default is #ffffff.\r\n */\nmxPrintPreview.prototype.backgroundColor = '#ffffff';\n\n/**\r\n * Variable: borderColor\r\n *\r\n * Holds the color value for the page border.\r\n */\nmxPrintPreview.prototype.borderColor = null;\n\n/**\r\n * Variable: title\r\n *\r\n * Holds the title of the preview window.\r\n */\nmxPrintPreview.prototype.title = null;\n\n/**\r\n * Variable: pageSelector\r\n *\r\n * Boolean that specifies if the page selector should be\r\n * displayed. Default is true.\r\n */\nmxPrintPreview.prototype.pageSelector = null;\n\n/**\r\n * Variable: wnd\r\n *\r\n * Reference to the preview window.\r\n */\nmxPrintPreview.prototype.wnd = null;\n\n/**\r\n * Variable: targetWindow\r\n *\r\n * Assign any window here to redirect the rendering in <open>.\r\n */\nmxPrintPreview.prototype.targetWindow = null;\n\n/**\r\n * Variable: pageCount\r\n *\r\n * Holds the actual number of pages in the preview.\r\n */\nmxPrintPreview.prototype.pageCount = 0;\n\n/**\r\n * Variable: clipping\r\n *\r\n * Specifies is clipping should be used to avoid creating too many cell states\r\n * in large diagrams. The bounding box of the cells in the original diagram is\r\n * used if this is enabled. Default is true.\r\n */\nmxPrintPreview.prototype.clipping = true;\n\n/**\r\n * Function: getWindow\r\n *\r\n * Returns <wnd>.\r\n */\nmxPrintPreview.prototype.getWindow = function () {\n  return this.wnd;\n};\n\n/**\r\n * Function: getDocType\r\n *\r\n * Returns the string that should go before the HTML tag in the print preview\r\n * page. This implementation returns an X-UA meta tag for IE5 in quirks mode,\r\n * IE8 in IE8 standards mode and edge in IE9 standards mode.\r\n */\nmxPrintPreview.prototype.getDoctype = function () {\n  var dt = '';\n  if (document.documentMode == 5) {\n    dt = '<meta http-equiv=\"X-UA-Compatible\" content=\"IE=5\">';\n  } else if (document.documentMode == 8) {\n    dt = '<meta http-equiv=\"X-UA-Compatible\" content=\"IE=8\">';\n  } else if (document.documentMode > 8) {\n    // Comment needed to make standards doctype apply in IE\n    dt = '<!--[if IE]><meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"><![endif]-->';\n  }\n  return dt;\n};\n\n/**\r\n * Function: open\r\n *\r\n * Shows the print preview window. The window is created here if it does\r\n * not exist.\r\n *\r\n * Parameters:\r\n *\r\n * css - Optional CSS string to be used in the head section.\r\n * targetWindow - Optional window that should be used for rendering. If\r\n * this is specified then no HEAD tag, CSS and BODY tag will be written.\r\n */\nmxPrintPreview.prototype.open = function (css, targetWindow) {\n  // Closing the window while the page is being rendered may cause an\n  // exception in IE. This and any other exceptions are simply ignored.\n  var previousInitializeOverlay = this.graph.cellRenderer.initializeOverlay;\n  var div = null;\n  try {\n    // Temporarily overrides the method to redirect rendering of overlays\n    // to the draw pane so that they are visible in the printout\n    if (this.printOverlays) {\n      this.graph.cellRenderer.initializeOverlay = function (state, overlay) {\n        overlay.init(state.view.getDrawPane());\n      };\n    }\n    if (this.printControls) {\n      this.graph.cellRenderer.initControl = function (state, control, handleEvents, clickHandler) {\n        control.dialect = state.view.graph.dialect;\n        control.init(state.view.getDrawPane());\n      };\n    }\n    if (this.wnd == null) {\n      this.wnd = targetWindow != null ? targetWindow : window.open();\n      var doc = this.wnd.document;\n      if (targetWindow == null) {\n        var dt = this.getDoctype();\n        if (dt != null && dt.length > 0) {\n          doc.writeln(dt);\n        }\n        if (_mxClient[\"default\"].IS_VML) {\n          doc.writeln('<html xmlns:v=\"urn:schemas-microsoft-com:vml\" xmlns:o=\"urn:schemas-microsoft-com:office:office\">');\n        } else {\n          if (document.compatMode === 'CSS1Compat') {\n            doc.writeln('<!DOCTYPE html>');\n          }\n          doc.writeln('<html>');\n        }\n        doc.writeln('<head>');\n        this.writeHead(doc, css);\n        doc.writeln('</head>');\n        doc.writeln('<body class=\"mxPage\">');\n      }\n\n      // Computes the horizontal and vertical page count\n      var bounds = this.graph.getGraphBounds().clone();\n      var currentScale = this.graph.getView().getScale();\n      var sc = currentScale / this.scale;\n      var tr = this.graph.getView().getTranslate();\n\n      // Uses the absolute origin with no offset for all printing\n      if (!this.autoOrigin) {\n        this.x0 -= tr.x * this.scale;\n        this.y0 -= tr.y * this.scale;\n        bounds.width += bounds.x;\n        bounds.height += bounds.y;\n        bounds.x = 0;\n        bounds.y = 0;\n        this.border = 0;\n      }\n\n      // Store the available page area\n      var availableWidth = this.pageFormat.width - this.border * 2;\n      var availableHeight = this.pageFormat.height - this.border * 2;\n\n      // Adds margins to page format\n      this.pageFormat.height += this.marginTop + this.marginBottom;\n\n      // Compute the unscaled, untranslated bounds to find\n      // the number of vertical and horizontal pages\n      bounds.width /= sc;\n      bounds.height /= sc;\n      var hpages = Math.max(1, Math.ceil((bounds.width + this.x0) / availableWidth));\n      var vpages = Math.max(1, Math.ceil((bounds.height + this.y0) / availableHeight));\n      this.pageCount = hpages * vpages;\n      var writePageSelector = _mxGraphUtils[\"default\"].bind(this, function () {\n        if (this.pageSelector && (vpages > 1 || hpages > 1)) {\n          var table = this.createPageSelector(vpages, hpages);\n          doc.body.appendChild(table);\n\n          // Implements position: fixed in IE quirks mode\n          if (_mxClient[\"default\"].IS_IE && doc.documentMode == null || doc.documentMode == 5 || doc.documentMode == 8 || doc.documentMode == 7) {\n            table.style.position = 'absolute';\n            var update = function update() {\n              table.style.top = (doc.body.scrollTop || doc.documentElement.scrollTop) + 10 + 'px';\n            };\n            _mxEvent[\"default\"].addListener(this.wnd, 'scroll', function (evt) {\n              update();\n            });\n            _mxEvent[\"default\"].addListener(this.wnd, 'resize', function (evt) {\n              update();\n            });\n          }\n        }\n      });\n      var addPage = _mxGraphUtils[\"default\"].bind(this, function (div, addBreak) {\n        // Border of the DIV (aka page) inside the document\n        if (this.borderColor != null) {\n          div.style.borderColor = this.borderColor;\n          div.style.borderStyle = 'solid';\n          div.style.borderWidth = '1px';\n        }\n\n        // Needs to be assigned directly because IE doesn't support\n        // child selectors, eg. body > div { background: white; }\n        div.style.background = this.backgroundColor;\n        if (addBreak) {\n          div.style.pageBreakAfter = 'always';\n        }\n\n        // NOTE: We are dealing with cross-window DOM here, which\n        // is a problem in IE, so we copy the HTML markup instead.\n        // The underlying problem is that the graph display markup\n        // creation (in mxShape, mxGraphView) is hardwired to using\n        // document.createElement and hence we must use this document\n        // to create the complete page and then copy it over to the\n        // new window.document. This can be fixed later by using the\n        // ownerDocument of the container in mxShape and mxGraphView.\n        if (_mxClient[\"default\"].IS_IE || document.documentMode >= 11 || _mxClient[\"default\"].IS_EDGE) {\n          // For some obscure reason, removing the DIV from the\n          // parent before fetching its outerHTML has missing\n          // fillcolor properties and fill children, so the div\n          // must be removed afterwards to keep the fillcolors.\n          doc.writeln(div.outerHTML);\n          div.parentNode.removeChild(div);\n        } else {\n          div.parentNode.removeChild(div);\n          doc.body.appendChild(div);\n        }\n        if (addBreak && targetWindow == null) {\n          var hr = doc.createElement('hr');\n          hr.className = 'mxPageBreak';\n          doc.body.appendChild(hr);\n        }\n      });\n      var cov = this.getCoverPages(this.pageFormat.width, this.pageFormat.height);\n      if (cov != null) {\n        for (var i = 0; i < cov.length; i++) {\n          addPage(cov[i], true);\n        }\n      }\n      var apx = this.getAppendices(this.pageFormat.width, this.pageFormat.height);\n\n      // Appends each page to the page output for printing, making\n      // sure there will be a page break after each page (ie. div)\n      for (var i = 0; i < vpages; i++) {\n        var dy = i * availableHeight / this.scale - this.y0 / this.scale + (bounds.y - tr.y * currentScale) / currentScale;\n        for (var j = 0; j < hpages; j++) {\n          if (this.wnd == null) {\n            return null;\n          }\n          var dx = j * availableWidth / this.scale - this.x0 / this.scale + (bounds.x - tr.x * currentScale) / currentScale;\n          var pageNum = i * hpages + j + 1;\n          var clip = new _mxRectangle[\"default\"](dx, dy, availableWidth, availableHeight);\n          div = this.renderPage(this.pageFormat.width, this.pageFormat.height, 0, 0, _mxGraphUtils[\"default\"].bind(this, function (div) {\n            this.addGraphFragment(-dx, -dy, this.scale, pageNum, div, clip);\n            if (this.printBackgroundImage) {\n              this.insertBackgroundImage(div, -dx, -dy);\n            }\n          }), pageNum);\n\n          // Gives the page a unique ID for later accessing the page\n          div.setAttribute('id', 'mxPage-' + pageNum);\n          addPage(div, apx != null || i < vpages - 1 || j < hpages - 1);\n        }\n      }\n      if (apx != null) {\n        for (var i = 0; i < apx.length; i++) {\n          addPage(apx[i], i < apx.length);\n        }\n      }\n      if (targetWindow == null) {\n        this.writePostfix(doc);\n        doc.writeln('</body>');\n        doc.writeln('</html>');\n        doc.close();\n\n        // Marks the printing complete for async handling\n        writePageSelector();\n\n        // Removes all event handlers in the print output\n        _mxEvent[\"default\"].release(doc.body);\n      }\n    }\n    this.wnd.focus();\n  } catch (e) {\n    // Removes the DIV from the document in case of an error\n    if (div != null && div.parentNode != null) {\n      div.parentNode.removeChild(div);\n    }\n    console.log('e', e);\n  } finally {\n    this.graph.cellRenderer.initializeOverlay = previousInitializeOverlay;\n  }\n  return this.wnd;\n};\n\n/**\r\n * Function: writeHead\r\n *\r\n * Writes the HEAD section into the given document, without the opening\r\n * and closing HEAD tags.\r\n */\nmxPrintPreview.prototype.writeHead = function (doc, css) {\n  if (this.title != null) {\n    doc.writeln('<title>' + this.title + '</title>');\n  }\n\n  // Adds required namespaces\n  if (_mxClient[\"default\"].IS_VML) {\n    doc.writeln('<style type=\"text/css\">v\\\\:*{behavior:url(#default#VML)}o\\\\:*{behavior:url(#default#VML)}</style>');\n  }\n\n  // Adds all required stylesheets\n  _mxClient[\"default\"].link('stylesheet', _mxClient[\"default\"].basePath + '/css/common.css', doc);\n\n  // Removes horizontal rules and page selector from print output\n  doc.writeln('<style type=\"text/css\">');\n  doc.writeln('@media print {');\n  doc.writeln('  table.mxPageSelector { display: none; }');\n  doc.writeln('  hr.mxPageBreak { display: none; }');\n  doc.writeln('}');\n  doc.writeln('@media screen {');\n\n  // NOTE: position: fixed is not supported in IE, so the page selector\n  // position (absolute) needs to be updated in IE (see below)\n  doc.writeln('  table.mxPageSelector { position: fixed; right: 10px; top: 10px;' + 'font-family: Arial; font-size:10pt; border: solid 1px darkgray;' + 'background: white; border-collapse:collapse; }');\n  doc.writeln('  table.mxPageSelector td { border: solid 1px gray; padding:4px; }');\n  doc.writeln('  body.mxPage { background: gray; }');\n  doc.writeln('}');\n  if (css != null) {\n    doc.writeln(css);\n  }\n  doc.writeln('</style>');\n};\n\n/**\r\n * Function: writePostfix\r\n *\r\n * Called before closing the body of the page. This implementation is empty.\r\n */\nmxPrintPreview.prototype.writePostfix = function (doc) {\n  // empty\n};\n\n/**\r\n * Function: createPageSelector\r\n *\r\n * Creates the page selector table.\r\n */\nmxPrintPreview.prototype.createPageSelector = function (vpages, hpages) {\n  var doc = this.wnd.document;\n  var table = doc.createElement('table');\n  table.className = 'mxPageSelector';\n  table.setAttribute('border', '0');\n  var tbody = doc.createElement('tbody');\n  for (var i = 0; i < vpages; i++) {\n    var row = doc.createElement('tr');\n    for (var j = 0; j < hpages; j++) {\n      var pageNum = i * hpages + j + 1;\n      var cell = doc.createElement('td');\n      var a = doc.createElement('a');\n      a.setAttribute('href', '#mxPage-' + pageNum);\n\n      // Workaround for FF where the anchor is appended to the URL of the original document\n      if (_mxClient[\"default\"].IS_NS && !_mxClient[\"default\"].IS_SF && !_mxClient[\"default\"].IS_GC) {\n        var js = 'var page = document.getElementById(\\'mxPage-' + pageNum + '\\');page.scrollIntoView(true);event.preventDefault();';\n        a.setAttribute('onclick', js);\n      }\n      _mxGraphUtils[\"default\"].write(a, pageNum, doc);\n      cell.appendChild(a);\n      row.appendChild(cell);\n    }\n    tbody.appendChild(row);\n  }\n  table.appendChild(tbody);\n  return table;\n};\n\n/**\r\n * Function: renderPage\r\n *\r\n * Creates a DIV that prints a single page of the given\r\n * graph using the given scale and returns the DIV that\r\n * represents the page.\r\n *\r\n * Parameters:\r\n *\r\n * w - Width of the page in pixels.\r\n * h - Height of the page in pixels.\r\n * dx - Optional horizontal page offset in pixels (used internally).\r\n * dy - Optional vertical page offset in pixels (used internally).\r\n * content - Callback that adds the HTML content to the inner div of a page.\r\n * Takes the inner div as the argument.\r\n * pageNumber - Integer representing the page number.\r\n */\nmxPrintPreview.prototype.renderPage = function (w, h, dx, dy, content, pageNumber) {\n  var doc = this.wnd.document;\n  var div = document.createElement('div');\n  var arg = null;\n  try {\n    // Workaround for ignored clipping in IE 9 standards\n    // when printing with page breaks and HTML labels.\n    if (dx != 0 || dy != 0) {\n      div.style.position = 'relative';\n      div.style.width = w + 'px';\n      div.style.height = h + 'px';\n      div.style.pageBreakInside = 'avoid';\n      var innerDiv = document.createElement('div');\n      innerDiv.style.position = 'relative';\n      innerDiv.style.top = this.border + 'px';\n      innerDiv.style.left = this.border + 'px';\n      innerDiv.style.width = w - 2 * this.border + 'px';\n      innerDiv.style.height = h - 2 * this.border + 'px';\n      innerDiv.style.overflow = 'hidden';\n      var viewport = document.createElement('div');\n      viewport.style.position = 'relative';\n      viewport.style.marginLeft = dx + 'px';\n      viewport.style.marginTop = dy + 'px';\n\n      // FIXME: IE8 standards output problems\n      if (doc.documentMode == 8) {\n        innerDiv.style.position = 'absolute';\n        viewport.style.position = 'absolute';\n      }\n      if (doc.documentMode == 10) {\n        viewport.style.width = '100%';\n        viewport.style.height = '100%';\n      }\n      innerDiv.appendChild(viewport);\n      div.appendChild(innerDiv);\n      document.body.appendChild(div);\n      arg = viewport;\n    }\n    // FIXME: IE10/11 too many pages\n    else {\n      div.style.width = w + 'px';\n      div.style.height = h + 'px';\n      div.style.overflow = 'hidden';\n      div.style.pageBreakInside = 'avoid';\n\n      // IE8 uses above branch currently\n      if (doc.documentMode == 8) {\n        div.style.position = 'relative';\n      }\n      var innerDiv = document.createElement('div');\n      innerDiv.style.width = w - 2 * this.border + 'px';\n      innerDiv.style.height = h - 2 * this.border + 'px';\n      innerDiv.style.overflow = 'hidden';\n      if (_mxClient[\"default\"].IS_IE && (doc.documentMode == null || doc.documentMode == 5 || doc.documentMode == 8 || doc.documentMode == 7)) {\n        innerDiv.style.marginTop = this.border + 'px';\n        innerDiv.style.marginLeft = this.border + 'px';\n      } else {\n        innerDiv.style.top = this.border + 'px';\n        innerDiv.style.left = this.border + 'px';\n      }\n      if (this.graph.dialect == _mxConstants[\"default\"].DIALECT_VML) {\n        innerDiv.style.position = 'absolute';\n      }\n      div.appendChild(innerDiv);\n      document.body.appendChild(div);\n      arg = innerDiv;\n    }\n  } catch (e) {\n    div.parentNode.removeChild(div);\n    div = null;\n    throw e;\n  }\n  content(arg);\n  return div;\n};\n\n/**\r\n * Function: getRoot\r\n *\r\n * Returns the root cell for painting the graph.\r\n */\nmxPrintPreview.prototype.getRoot = function () {\n  var root = this.graph.view.currentRoot;\n  if (root == null) {\n    root = this.graph.getModel().getRoot();\n  }\n  return root;\n};\n\n/**\r\n * Function: addGraphFragment\r\n *\r\n * Adds a graph fragment to the given div.\r\n *\r\n * Parameters:\r\n *\r\n * dx - Horizontal translation for the diagram.\r\n * dy - Vertical translation for the diagram.\r\n * scale - Scale for the diagram.\r\n * pageNumber - Number of the page to be rendered.\r\n * div - Div that contains the output.\r\n * clip - Contains the clipping rectangle as an <mxRectangle>.\r\n */\nmxPrintPreview.prototype.addGraphFragment = function (dx, dy, scale, pageNumber, div, clip) {\n  var view = this.graph.getView();\n  var previousContainer = this.graph.container;\n  this.graph.container = div;\n  var canvas = view.getCanvas();\n  var backgroundPane = view.getBackgroundPane();\n  var drawPane = view.getDrawPane();\n  var overlayPane = view.getOverlayPane();\n  if (this.graph.dialect == _mxConstants[\"default\"].DIALECT_SVG) {\n    view.createSvg();\n  } else if (this.graph.dialect == _mxConstants[\"default\"].DIALECT_VML) {\n    view.createVml();\n  } else {\n    view.createHtml();\n  }\n\n  // Disables events on the view\n  var eventsEnabled = view.isEventsEnabled();\n  view.setEventsEnabled(false);\n\n  // Disables the graph to avoid cursors\n  var graphEnabled = this.graph.isEnabled();\n  this.graph.setEnabled(false);\n\n  // Resets the translation\n  var translate = view.getTranslate();\n  view.translate = new _mxPoint[\"default\"](dx, dy);\n\n  // Redraws only states that intersect the clip\n  var redraw = this.graph.cellRenderer.redraw;\n  var states = view.states;\n  var s = view.scale;\n\n  // Gets the transformed clip for intersection check below\n  if (this.clipping) {\n    var tempClip = new _mxRectangle[\"default\"]((clip.x + translate.x) * s, (clip.y + translate.y) * s, clip.width * s / scale, clip.height * s / scale);\n\n    // Checks clipping rectangle for speedup\n    // Must create terminal states for edge clipping even if terminal outside of clip\n    this.graph.cellRenderer.redraw = function (state, force, rendering) {\n      if (state != null) {\n        // Gets original state from graph to find bounding box\n        var orig = states.get(state.cell);\n        if (orig != null) {\n          var bbox = view.getBoundingBox(orig, false);\n\n          // Stops rendering if outside clip for speedup\n          if (bbox != null && !_mxUtils[\"default\"].intersects(tempClip, bbox)) {\n            return;\n          }\n        }\n      }\n      redraw.apply(this, arguments);\n    };\n  }\n  var temp = null;\n  try {\n    // Creates the temporary cell states in the view and\n    // draws them onto the temporary DOM nodes in the view\n    var cells = [this.getRoot()];\n    temp = new _mxTemporaryCellStates[\"default\"](view, scale, cells);\n  } finally {\n    // Removes overlay pane with selection handles\n    // controls and icons from the print output\n    if (_mxClient[\"default\"].IS_IE) {\n      view.overlayPane.innerHTML = '';\n      view.canvas.style.overflow = 'hidden';\n      view.canvas.style.position = 'relative';\n      view.canvas.style.top = this.marginTop + 'px';\n      view.canvas.style.width = clip.width + 'px';\n      view.canvas.style.height = clip.height + 'px';\n    } else {\n      // Removes everything but the SVG node\n      var tmp = div.firstChild;\n      while (tmp != null) {\n        var next = tmp.nextSibling;\n        var name = tmp.nodeName.toLowerCase();\n\n        // Note: Width and height are required in FF 11\n        if (name == 'svg') {\n          tmp.style.overflow = 'hidden';\n          tmp.style.position = 'relative';\n          tmp.style.top = this.marginTop + 'px';\n          tmp.setAttribute('width', clip.width);\n          tmp.setAttribute('height', clip.height);\n          tmp.style.width = '';\n          tmp.style.height = '';\n        }\n        // Tries to fetch all text labels and only text labels\n        else if (tmp.style.cursor != 'default' && name != 'div') {\n          tmp.parentNode.removeChild(tmp);\n        }\n        tmp = next;\n      }\n    }\n\n    // Puts background image behind SVG output\n    if (this.printBackgroundImage) {\n      var svgs = div.getElementsByTagName('svg');\n      if (svgs.length > 0) {\n        svgs[0].style.position = 'absolute';\n      }\n    }\n\n    // Completely removes the overlay pane to remove more handles\n    view.overlayPane.parentNode.removeChild(view.overlayPane);\n\n    // Restores the state of the view\n    this.graph.setEnabled(graphEnabled);\n    this.graph.container = previousContainer;\n    this.graph.cellRenderer.redraw = redraw;\n    view.canvas = canvas;\n    view.backgroundPane = backgroundPane;\n    view.drawPane = drawPane;\n    view.overlayPane = overlayPane;\n    view.translate = translate;\n    temp.destroy();\n    view.setEventsEnabled(eventsEnabled);\n  }\n};\n\n/**\r\n * Function: insertBackgroundImage\r\n *\r\n * Inserts the background image into the given div.\r\n */\nmxPrintPreview.prototype.insertBackgroundImage = function (div, dx, dy) {\n  var bg = this.graph.backgroundImage;\n  if (bg != null) {\n    var img = document.createElement('img');\n    img.style.position = 'absolute';\n    img.style.marginLeft = Math.round(dx * this.scale) + 'px';\n    img.style.marginTop = Math.round(dy * this.scale) + 'px';\n    img.setAttribute('width', Math.round(this.scale * bg.width));\n    img.setAttribute('height', Math.round(this.scale * bg.height));\n    img.src = bg.src;\n    div.insertBefore(img, div.firstChild);\n  }\n};\n\n/**\r\n * Function: getCoverPages\r\n *\r\n * Returns the pages to be added before the print output. This returns null.\r\n */\nmxPrintPreview.prototype.getCoverPages = function () {\n  return null;\n};\n\n/**\r\n * Function: getAppendices\r\n *\r\n * Returns the pages to be added after the print output. This returns null.\r\n */\nmxPrintPreview.prototype.getAppendices = function () {\n  return null;\n};\n\n/**\r\n * Function: print\r\n *\r\n * Opens the print preview and shows the print dialog.\r\n *\r\n * Parameters:\r\n *\r\n * css - Optional CSS string to be used in the head section.\r\n */\nmxPrintPreview.prototype.print = function (css) {\n  var wnd = this.open(css);\n  if (wnd != null) {\n    wnd.print();\n  }\n};\n\n/**\r\n * Function: close\r\n *\r\n * Closes the print preview window.\r\n */\nmxPrintPreview.prototype.close = function () {\n  if (this.wnd != null) {\n    this.wnd.close();\n    this.wnd = null;\n  }\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxStylesheet\r\n *\r\n * Defines the appearance of the cells in a graph. See <putCellStyle> for an\r\n * example of creating a new cell style. It is recommended to use objects, not\r\n * arrays for holding cell styles. Existing styles can be cloned using\r\n * <mxGraphUtils.clone> and turned into a string for debugging using\r\n * <mxGraphUtils.toString>.\r\n *\r\n * Default Styles:\r\n *\r\n * The stylesheet contains two built-in styles, which are used if no style is\r\n * defined for a cell:\r\n *\r\n *   defaultVertex - Default style for vertices\r\n *   defaultEdge - Default style for edges\r\n *\r\n * Example:\r\n *\r\n * (code)\r\n * var vertexStyle = stylesheet.getDefaultVertexStyle();\r\n * vertexStyle[mxConstants.ROUNDED] = true;\r\n * var edgeStyle = stylesheet.getDefaultEdgeStyle();\r\n * edgeStyle[mxConstants.STYLE_EDGE] = mxEdgeStyle.EntityRelation;\r\n * (end)\r\n *\r\n * Modifies the built-in default styles.\r\n *\r\n * To avoid the default style for a cell, add a leading semicolon\r\n * to the style definition, eg.\r\n *\r\n * (code)\r\n * ;shadow=1\r\n * (end)\r\n *\r\n * Removing keys:\r\n *\r\n * For removing a key in a cell style of the form [stylename;|key=value;] the\r\n * special value none can be used, eg. highlight;fillColor=none\r\n *\r\n * See also the helper methods in mxUtils to modify strings of this format,\r\n * namely <mxUtils.setStyle>, <mxGraphUtils.indexOfStylename>,\r\n * <mxUtils.addStylename>, <mxUtils.removeStylename>,\r\n * <mxUtils.removeAllStylenames> and <mxUtils.setStyleFlag>.\r\n *\r\n * Constructor: mxStylesheet\r\n *\r\n * Constructs a new stylesheet and assigns default styles.\r\n */\nvar _default = exports[\"default\"] = mxPrintPreview;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxPrintPreview.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxPropertyChange.js":
/*!***************************************************!*\
  !*** ./src/workflow/mxClient/mxPropertyChange.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _mxValueChange = _interopRequireDefault(__webpack_require__(/*! ./mxValueChange.js */ \"./src/workflow/mxClient/mxValueChange.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxPropertyChange(model, cell, group, property, value, reducer) {\n  this.model = model;\n  this.cell = cell;\n  this.group = group;\n  this.property = property;\n  this.value = value;\n  this.previous = value;\n  this.reducer = reducer;\n}\n;\n\n/**\r\n * Function: execute\r\n *\r\n * Changes the value of <cell> to <previous> using\r\n * <mxGraphModel.valueForCellChanged>.\r\n */\nmxPropertyChange.prototype.execute = function () {\n  //此处特殊处理name属性，如果是name属性，使用原有的setValue方法更新节点显示的值\n  if (this.property === 'name') {\n    this.model.execute(new _mxValueChange[\"default\"](this.model, this.cell, this.previous));\n  }\n  this.value = this.previous;\n  this.previous = this.model.propertyForCellChanged(this.cell, this.group, this.property, this.previous, this.reducer);\n};\n\n/**\r\n * Class: mxStyleChange\r\n *\r\n * Action to change a cell's style in a model.\r\n *\r\n * Constructor: mxStyleChange\r\n *\r\n * Constructs a change of a style in the\r\n * specified model.\r\n */\nvar _default = exports[\"default\"] = mxPropertyChange;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxPropertyChange.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxRadialTreeLayout.js":
/*!*****************************************************!*\
  !*** ./src/workflow/mxClient/mxRadialTreeLayout.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _mxGraphLayout = _interopRequireDefault(__webpack_require__(/*! ./mxGraphLayout.js */ \"./src/workflow/mxClient/mxGraphLayout.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxCompactTreeLayout = _interopRequireDefault(__webpack_require__(/*! ./mxCompactTreeLayout.js */ \"./src/workflow/mxClient/mxCompactTreeLayout.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxRadialTreeLayout(graph) {\n  _mxCompactTreeLayout[\"default\"].call(this, graph, false);\n}\n;\n\n/**\r\n * Extends mxGraphLayout.\r\n */\n_mxGraphUtils[\"default\"].extend(mxRadialTreeLayout, _mxCompactTreeLayout[\"default\"]);\n\n/**\r\n * Variable: angleOffset\r\n *\r\n * The initial offset to compute the angle position.\r\n */\nmxRadialTreeLayout.prototype.angleOffset = 0.5;\n\n/**\r\n * Variable: rootx\r\n *\r\n * The X co-ordinate of the root cell\r\n */\nmxRadialTreeLayout.prototype.rootx = 0;\n\n/**\r\n * Variable: rooty\r\n *\r\n * The Y co-ordinate of the root cell\r\n */\nmxRadialTreeLayout.prototype.rooty = 0;\n\n/**\r\n * Variable: levelDistance\r\n *\r\n * Holds the levelDistance. Default is 120.\r\n */\nmxRadialTreeLayout.prototype.levelDistance = 120;\n\n/**\r\n * Variable: nodeDistance\r\n *\r\n * Holds the nodeDistance. Default is 10.\r\n */\nmxRadialTreeLayout.prototype.nodeDistance = 10;\n\n/**\r\n * Variable: autoRadius\r\n *\r\n * Specifies if the radios should be computed automatically\r\n */\nmxRadialTreeLayout.prototype.autoRadius = false;\n\n/**\r\n * Variable: sortEdges\r\n *\r\n * Specifies if edges should be sorted according to the order of their\r\n * opposite terminal cell in the model.\r\n */\nmxRadialTreeLayout.prototype.sortEdges = false;\n\n/**\r\n * Variable: rowMinX\r\n *\r\n * Array of leftmost x coordinate of each row\r\n */\nmxRadialTreeLayout.prototype.rowMinX = [];\n\n/**\r\n * Variable: rowMaxX\r\n *\r\n * Array of rightmost x coordinate of each row\r\n */\nmxRadialTreeLayout.prototype.rowMaxX = [];\n\n/**\r\n * Variable: rowMinCenX\r\n *\r\n * Array of x coordinate of leftmost vertex of each row\r\n */\nmxRadialTreeLayout.prototype.rowMinCenX = [];\n\n/**\r\n * Variable: rowMaxCenX\r\n *\r\n * Array of x coordinate of rightmost vertex of each row\r\n */\nmxRadialTreeLayout.prototype.rowMaxCenX = [];\n\n/**\r\n * Variable: rowRadi\r\n *\r\n * Array of y deltas of each row behind root vertex, also the radius in the tree\r\n */\nmxRadialTreeLayout.prototype.rowRadi = [];\n\n/**\r\n * Variable: row\r\n *\r\n * Array of vertices on each row\r\n */\nmxRadialTreeLayout.prototype.row = [];\n\n/**\r\n * Function: isVertexIgnored\r\n *\r\n * Returns a boolean indicating if the given <mxCell> should be ignored as a\r\n * vertex. This returns true if the cell has no connections.\r\n *\r\n * Parameters:\r\n *\r\n * vertex - <mxCell> whose ignored state should be returned.\r\n */\nmxRadialTreeLayout.prototype.isVertexIgnored = function (vertex) {\n  return _mxGraphLayout[\"default\"].prototype.isVertexIgnored.apply(this, arguments) || this.graph.getConnections(vertex).length == 0;\n};\n\n/**\r\n * Function: execute\r\n *\r\n * Implements <mxGraphLayout.execute>.\r\n *\r\n * If the parent has any connected edges, then it is used as the root of\r\n * the tree. Else, <mxGraph.findTreeRoots> will be used to find a suitable\r\n * root node within the set of children of the given parent.\r\n *\r\n * Parameters:\r\n *\r\n * parent - <mxCell> whose children should be laid out.\r\n * root - Optional <mxCell> that will be used as the root of the tree.\r\n */\nmxRadialTreeLayout.prototype.execute = function (parent, root) {\n  this.parent = parent;\n  this.useBoundingBox = false;\n  this.edgeRouting = false;\n  //this.horizontal = false;\n\n  _mxCompactTreeLayout[\"default\"].prototype.execute.apply(this, arguments);\n  var bounds = null;\n  var rootBounds = this.getVertexBounds(this.root);\n  this.centerX = rootBounds.x + rootBounds.width / 2;\n  this.centerY = rootBounds.y + rootBounds.height / 2;\n\n  // Calculate the bounds of the involved vertices directly from the values set in the compact tree\n  for (var vertex in this.visited) {\n    var vertexBounds = this.getVertexBounds(this.visited[vertex]);\n    bounds = bounds != null ? bounds : vertexBounds.clone();\n    bounds.add(vertexBounds);\n  }\n  this.calcRowDims([this.node], 0);\n  var maxLeftGrad = 0;\n  var maxRightGrad = 0;\n\n  // Find the steepest left and right gradients\n  for (var i = 0; i < this.row.length; i++) {\n    var leftGrad = (this.centerX - this.rowMinX[i] - this.nodeDistance) / this.rowRadi[i];\n    var rightGrad = (this.rowMaxX[i] - this.centerX - this.nodeDistance) / this.rowRadi[i];\n    maxLeftGrad = Math.max(maxLeftGrad, leftGrad);\n    maxRightGrad = Math.max(maxRightGrad, rightGrad);\n  }\n\n  // Extend out row so they meet the maximum gradient and convert to polar co-ords\n  for (var i = 0; i < this.row.length; i++) {\n    var xLeftLimit = this.centerX - this.nodeDistance - maxLeftGrad * this.rowRadi[i];\n    var xRightLimit = this.centerX + this.nodeDistance + maxRightGrad * this.rowRadi[i];\n    var fullWidth = xRightLimit - xLeftLimit;\n    for (var j = 0; j < this.row[i].length; j++) {\n      var row = this.row[i];\n      var node = row[j];\n      var vertexBounds = this.getVertexBounds(node.cell);\n      var xProportion = (vertexBounds.x + vertexBounds.width / 2 - xLeftLimit) / fullWidth;\n      var theta = 2 * Math.PI * xProportion;\n      node.theta = theta;\n    }\n  }\n\n  // Post-process from outside inwards to try to align parents with children\n  for (var i = this.row.length - 2; i >= 0; i--) {\n    var row = this.row[i];\n    for (var j = 0; j < row.length; j++) {\n      var node = row[j];\n      var child = node.child;\n      var counter = 0;\n      var totalTheta = 0;\n      while (child != null) {\n        totalTheta += child.theta;\n        counter++;\n        child = child.next;\n      }\n      if (counter > 0) {\n        var averTheta = totalTheta / counter;\n        if (averTheta > node.theta && j < row.length - 1) {\n          var nextTheta = row[j + 1].theta;\n          node.theta = Math.min(averTheta, nextTheta - Math.PI / 10);\n        } else if (averTheta < node.theta && j > 0) {\n          var lastTheta = row[j - 1].theta;\n          node.theta = Math.max(averTheta, lastTheta + Math.PI / 10);\n        }\n      }\n    }\n  }\n\n  // Set locations\n  for (var i = 0; i < this.row.length; i++) {\n    for (var j = 0; j < this.row[i].length; j++) {\n      var row = this.row[i];\n      var node = row[j];\n      var vertexBounds = this.getVertexBounds(node.cell);\n      this.setVertexLocation(node.cell, this.centerX - vertexBounds.width / 2 + this.rowRadi[i] * Math.cos(node.theta), this.centerY - vertexBounds.height / 2 + this.rowRadi[i] * Math.sin(node.theta));\n    }\n  }\n};\n\n/**\r\n * Function: calcRowDims\r\n *\r\n * Recursive function to calculate the dimensions of each row\r\n *\r\n * Parameters:\r\n *\r\n * row - Array of internal nodes, the children of which are to be processed.\r\n * rowNum - Integer indicating which row is being processed.\r\n */\nmxRadialTreeLayout.prototype.calcRowDims = function (row, rowNum) {\n  if (row == null || row.length == 0) {\n    return;\n  }\n\n  // Place root's children proportionally around the first level\n  this.rowMinX[rowNum] = this.centerX;\n  this.rowMaxX[rowNum] = this.centerX;\n  this.rowMinCenX[rowNum] = this.centerX;\n  this.rowMaxCenX[rowNum] = this.centerX;\n  this.row[rowNum] = [];\n  var rowHasChildren = false;\n  for (var i = 0; i < row.length; i++) {\n    var child = row[i].child;\n    while (child != null) {\n      var cell = child.cell;\n      vertexBounds = this.getVertexBounds(cell);\n      this.rowMinX[rowNum] = Math.min(vertexBounds.x, this.rowMinX[rowNum]);\n      this.rowMaxX[rowNum] = Math.max(vertexBounds.x + vertexBounds.width, this.rowMaxX[rowNum]);\n      this.rowMinCenX[rowNum] = Math.min(vertexBounds.x + vertexBounds.width / 2, this.rowMinCenX[rowNum]);\n      this.rowMaxCenX[rowNum] = Math.max(vertexBounds.x + vertexBounds.width / 2, this.rowMaxCenX[rowNum]);\n      this.rowRadi[rowNum] = vertexBounds.y - this.getVertexBounds(this.root).y;\n      if (child.child != null) {\n        rowHasChildren = true;\n      }\n      this.row[rowNum].push(child);\n      child = child.next;\n    }\n  }\n  if (rowHasChildren) {\n    this.calcRowDims(this.row[rowNum], rowNum + 1);\n  }\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxFastOrganicLayout\r\n *\r\n * Extends <mxGraphLayout> to implement a fast organic layout algorithm.\r\n * The vertices need to be connected for this layout to work, vertices\r\n * with no connections are ignored.\r\n *\r\n * Example:\r\n *\r\n * (code)\r\n * var layout = new mxFastOrganicLayout(graph);\r\n * layout.execute(graph.getDefaultParent());\r\n * (end)\r\n *\r\n * Constructor: mxCompactTreeLayout\r\n *\r\n * Constructs a new fast organic layout for the specified graph.\r\n */\nvar _default = exports[\"default\"] = mxRadialTreeLayout;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxRadialTreeLayout.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxRectangle.js":
/*!**********************************************!*\
  !*** ./src/workflow/mxClient/mxRectangle.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _mxPoint = _interopRequireDefault(__webpack_require__(/*! ./mxPoint.js */ \"./src/workflow/mxClient/mxPoint.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxRectangle(x, y, width, height) {\n  _mxPoint[\"default\"].call(this, x, y);\n  this.width = width != null ? width : 0;\n  this.height = height != null ? height : 0;\n}\n;\n\n/**\r\n * Extends mxPoint.\r\n */\nmxRectangle.prototype = new _mxPoint[\"default\"]();\nmxRectangle.prototype.constructor = mxRectangle;\n\n/**\r\n * Variable: width\r\n *\r\n * Holds the width of the rectangle. Default is 0.\r\n */\nmxRectangle.prototype.width = null;\n\n/**\r\n * Variable: height\r\n *\r\n * Holds the height of the rectangle. Default is 0.\r\n */\nmxRectangle.prototype.height = null;\n\n/**\r\n * Function: setRect\r\n *\r\n * Sets this rectangle to the specified values\r\n */\nmxRectangle.prototype.setRect = function (x, y, w, h) {\n  this.x = x;\n  this.y = y;\n  this.width = w;\n  this.height = h;\n};\n\n/**\r\n * Function: getCenterX\r\n *\r\n * Returns the x-coordinate of the center point.\r\n */\nmxRectangle.prototype.getCenterX = function () {\n  return this.x + this.width / 2;\n};\n\n/**\r\n * Function: getCenterY\r\n *\r\n * Returns the y-coordinate of the center point.\r\n */\nmxRectangle.prototype.getCenterY = function () {\n  return this.y + this.height / 2;\n};\n\n/**\r\n * Function: add\r\n *\r\n * Adds the given rectangle to this rectangle.\r\n */\nmxRectangle.prototype.add = function (rect) {\n  if (rect != null) {\n    var minX = Math.min(this.x, rect.x);\n    var minY = Math.min(this.y, rect.y);\n    var maxX = Math.max(this.x + this.width, rect.x + rect.width);\n    var maxY = Math.max(this.y + this.height, rect.y + rect.height);\n    this.x = minX;\n    this.y = minY;\n    this.width = maxX - minX;\n    this.height = maxY - minY;\n  }\n};\n\n/**\r\n * Function: intersect\r\n *\r\n * Changes this rectangle to where it overlaps with the given rectangle.\r\n */\nmxRectangle.prototype.intersect = function (rect) {\n  if (rect != null) {\n    var r1 = this.x + this.width;\n    var r2 = rect.x + rect.width;\n    var b1 = this.y + this.height;\n    var b2 = rect.y + rect.height;\n    this.x = Math.max(this.x, rect.x);\n    this.y = Math.max(this.y, rect.y);\n    this.width = Math.min(r1, r2) - this.x;\n    this.height = Math.min(b1, b2) - this.y;\n  }\n};\n\n/**\r\n * Function: grow\r\n *\r\n * Grows the rectangle by the given amount, that is, this method subtracts\r\n * the given amount from the x- and y-coordinates and adds twice the amount\r\n * to the width and height.\r\n */\nmxRectangle.prototype.grow = function (amount) {\n  this.x -= amount;\n  this.y -= amount;\n  this.width += 2 * amount;\n  this.height += 2 * amount;\n};\n\n/**\r\n * Function: getPoint\r\n *\r\n * Returns the top, left corner as a new <mxPoint>.\r\n */\nmxRectangle.prototype.getPoint = function () {\n  return new _mxPoint[\"default\"](this.x, this.y);\n};\n\n/**\r\n * Function: rotate90\r\n *\r\n * Rotates this rectangle by 90 degree around its center point.\r\n */\nmxRectangle.prototype.rotate90 = function () {\n  var t = (this.width - this.height) / 2;\n  this.x += t;\n  this.y -= t;\n  var tmp = this.width;\n  this.width = this.height;\n  this.height = tmp;\n};\n\n/**\r\n * Function: equals\r\n *\r\n * Returns true if the given object equals this rectangle.\r\n */\nmxRectangle.prototype.equals = function (obj) {\n  return obj != null && obj.x == this.x && obj.y == this.y && obj.width == this.width && obj.height == this.height;\n};\n\n/**\r\n * Function: fromRectangle\r\n *\r\n * Returns a new <mxRectangle> which is a copy of the given rectangle.\r\n */\nmxRectangle.fromRectangle = function (rect) {\n  return new mxRectangle(rect.x, rect.y, rect.width, rect.height);\n};\nmxRectangle.getName = function () {\n  return 'mxRectangle';\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\nvar _default = exports[\"default\"] = mxRectangle;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxRectangle.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxRectangleShape.js":
/*!***************************************************!*\
  !*** ./src/workflow/mxClient/mxRectangleShape.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.fill.js */ \"../../node_modules/core-js/modules/es.array.fill.js\");\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxShape = _interopRequireDefault(__webpack_require__(/*! ./mxShape.js */ \"./src/workflow/mxClient/mxShape.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ./mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxRectangleShape(bounds, fill, stroke, strokewidth) {\n  _mxShape[\"default\"].call(this);\n  this.bounds = bounds;\n  this.fill = fill;\n  this.stroke = stroke;\n  this.strokewidth = strokewidth != null ? strokewidth : 1;\n}\n;\n\n/**\r\n * Extends mxShape.\r\n */\n_mxGraphUtils[\"default\"].extend(mxRectangleShape, _mxShape[\"default\"]);\n\n/**\r\n * Function: isHtmlAllowed\r\n *\r\n * Returns true for non-rounded, non-rotated shapes with no glass gradient.\r\n */\nmxRectangleShape.prototype.isHtmlAllowed = function () {\n  var events = true;\n  if (this.style != null) {\n    events = _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_POINTER_EVENTS, '1') == '1';\n  }\n  return !this.isRounded && !this.glass && this.rotation == 0 && (events || this.fill != null && this.fill != _mxConstants[\"default\"].NONE);\n};\n\n/**\r\n * Function: paintBackground\r\n *\r\n * Generic background painting implementation.\r\n */\nmxRectangleShape.prototype.paintBackground = function (c, x, y, w, h) {\n  var events = true;\n  if (this.style != null) {\n    events = _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_POINTER_EVENTS, '1') == '1';\n  }\n  if (events || this.fill != null && this.fill != _mxConstants[\"default\"].NONE || this.stroke != null && this.stroke != _mxConstants[\"default\"].NONE) {\n    if (!events && (this.fill == null || this.fill == _mxConstants[\"default\"].NONE)) {\n      c.pointerEvents = false;\n    }\n    if (this.isRounded) {\n      var f = _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_ARCSIZE, _mxConstants[\"default\"].RECTANGLE_ROUNDING_FACTOR * 100) / 100;\n      var r = Math.min(w * f, h * f);\n      c.roundrect(x, y, w, h, r, r);\n    } else {\n      c.rect(x, y, w, h);\n    }\n    c.fillAndStroke();\n  }\n};\n\n/**\r\n * Function: paintForeground\r\n *\r\n * Generic background painting implementation.\r\n */\nmxRectangleShape.prototype.paintForeground = function (c, x, y, w, h) {\n  if (this.glass && !this.outline && this.fill != null && this.fill != _mxConstants[\"default\"].NONE) {\n    this.paintGlassEffect(c, x, y, w, h, this.getArcSize(w + this.strokewidth, h + this.strokewidth));\n  }\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxEllipse\r\n *\r\n * Extends <mxShape> to implement an ellipse shape.\r\n * This shape is registered under <mxConstants.SHAPE_ELLIPSE>\r\n * in <mxCellRenderer>.\r\n *\r\n * Constructor: mxEllipse\r\n *\r\n * Constructs a new ellipse shape.\r\n *\r\n * Parameters:\r\n *\r\n * bounds - <mxRectangle> that defines the bounds. This is stored in\r\n * <mxShape.bounds>.\r\n * fill - String that defines the fill color. This is stored in <fill>.\r\n * stroke - String that defines the stroke color. This is stored in <stroke>.\r\n * strokewidth - Optional integer that defines the stroke width. Default is\r\n * 1. This is stored in <strokewidth>.\r\n */\nvar _default = exports[\"default\"] = mxRectangleShape;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxRectangleShape.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxRequestUtils.js":
/*!*************************************************!*\
  !*** ./src/workflow/mxClient/mxRequestUtils.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _mxXmlRequest = _interopRequireDefault(__webpack_require__(/*! ./mxXmlRequest.js */ \"./src/workflow/mxClient/mxXmlRequest.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nvar mxRequestUtils = {\n  get: function get(url, onload, onerror, binary, timeout, ontimeout) {\n    var req = new _mxXmlRequest[\"default\"](url, null, 'GET');\n    if (binary != null) {\n      req.setBinary(binary);\n    }\n    req.send(onload, onerror, timeout, ontimeout);\n    return req;\n  },\n  load: function load(url) {\n    var req = new _mxXmlRequest[\"default\"](url, null, 'GET', false);\n    req.send();\n    return req;\n  }\n};\nvar _default = exports[\"default\"] = mxRequestUtils;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxRequestUtils.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxResources.js":
/*!**********************************************!*\
  !*** ./src/workflow/mxClient/mxResources.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.index-of.js */ \"../../node_modules/core-js/modules/es.array.index-of.js\");\n__webpack_require__(/*! core-js/modules/es.array.join.js */ \"../../node_modules/core-js/modules/es.array.join.js\");\n__webpack_require__(/*! core-js/modules/es.parse-int.js */ \"../../node_modules/core-js/modules/es.parse-int.js\");\n__webpack_require__(/*! core-js/modules/es.regexp.exec.js */ \"../../node_modules/core-js/modules/es.regexp.exec.js\");\n__webpack_require__(/*! core-js/modules/es.string.replace.js */ \"../../node_modules/core-js/modules/es.string.replace.js\");\nvar _mxClient = _interopRequireDefault(__webpack_require__(/*! ./mxClient.js */ \"./src/workflow/mxClient/mxClient.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ./mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxRequestUtils = _interopRequireDefault(__webpack_require__(/*! ./mxRequestUtils.js */ \"./src/workflow/mxClient/mxRequestUtils.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nvar mxResources = {\n  /**\r\n   * Class: mxResources\r\n   *\r\n   * Implements internationalization. You can provide any number of\r\n   * resource files on the server using the following format for the\r\n   * filename: name[-en].properties. The en stands for any lowercase\r\n   * 2-character language shortcut (eg. de for german, fr for french).\r\n   *\r\n   * If the optional language extension is omitted, then the file is used as a\r\n   * default resource which is loaded in all cases. If a properties file for a\r\n   * specific language exists, then it is used to override the settings in the\r\n   * default resource. All entries in the file are of the form key=value. The\r\n   * values may then be accessed in code via <get>. Lines without\r\n   * equal signs in the properties files are ignored.\r\n   *\r\n   * Resource files may either be added programmatically using\r\n   * <add> or via a resource tag in the UI section of the\r\n   * editor configuration file, eg:\r\n   *\r\n   * (code)\r\n   * <mxEditor>\r\n   *   <ui>\r\n   *     <resource basename=\"examples/resources/mxWorkflow\"/>\r\n   * (end)\r\n   *\r\n   * The above element will load examples/resources/mxWorkflow.properties as well\r\n   * as the language specific file for the current language, if it exists.\r\n   *\r\n   * Values may contain placeholders of the form {1}...{n} where each placeholder\r\n   * is replaced with the value of the corresponding array element in the params\r\n   * argument passed to <mxResources.get>. The placeholder {1} maps to the first\r\n   * element in the array (at index 0).\r\n   *\r\n   * See <mxClient.language> for more information on specifying the default\r\n   * language or disabling all loading of resources.\r\n   *\r\n   * Lines that start with a # sign will be ignored.\r\n   *\r\n   * Special characters\r\n   *\r\n   * To use unicode characters, use the standard notation (eg. \\u8fd1) or %u as a\r\n   * prefix (eg. %u20AC will display a Euro sign). For normal hex encoded strings,\r\n   * use % as a prefix, eg. %F6 will display a \"o umlaut\" (&ouml;).\r\n   *\r\n   * See <resourcesEncoded> to disable this. If you disable this, make sure that\r\n   * your files are UTF-8 encoded.\r\n   *\r\n   * Asynchronous loading\r\n   *\r\n   * By default, the core adds two resource files synchronously at load time.\r\n   * To load these files asynchronously, set <mxLoadResources> to false\r\n   * before loading mxClient.js and use <mxResources.loadResources> instead.\r\n   *\r\n   * Variable: resources\r\n   *\r\n   * Associative array that maps from keys to values.\r\n   */\n  resources: [],\n  /**\r\n   * Variable: extension\r\n   *\r\n   * Specifies the extension used for language files. Default is <mxResourceExtension>.\r\n   */\n  extension: mxResourceExtension,\n  /**\r\n   * Variable: resourcesEncoded\r\n   *\r\n   * Specifies whether or not values in resource files are encoded with \\u or\r\n   * percentage. Default is false.\r\n   */\n  resourcesEncoded: false,\n  /**\r\n   * Variable: loadDefaultBundle\r\n   *\r\n   * Specifies if the default file for a given basename should be loaded.\r\n   * Default is true.\r\n   */\n  loadDefaultBundle: true,\n  /**\r\n   * Variable: loadDefaultBundle\r\n   *\r\n   * Specifies if the specific language file file for a given basename should\r\n   * be loaded. Default is true.\r\n   */\n  loadSpecialBundle: true,\n  /**\r\n   * Function: isLanguageSupported\r\n   *\r\n   * Hook for subclassers to disable support for a given language. This\r\n   * implementation returns true if lan is in <mxClient.languages>.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * lan - The current language.\r\n   */\n  isLanguageSupported: function isLanguageSupported(lan) {\n    if (_mxClient[\"default\"].languages != null) {\n      return _mxGraphUtils[\"default\"].indexOf(_mxClient[\"default\"].languages, lan) >= 0;\n    }\n    return true;\n  },\n  /**\r\n   * Function: getDefaultBundle\r\n   *\r\n   * Hook for subclassers to return the URL for the special bundle. This\r\n   * implementation returns basename + <extension> or null if\r\n   * <loadDefaultBundle> is false.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * basename - The basename for which the file should be loaded.\r\n   * lan - The current language.\r\n   */\n  getDefaultBundle: function getDefaultBundle(basename, lan) {\n    if (mxResources.loadDefaultBundle || !mxResources.isLanguageSupported(lan)) {\n      return basename + mxResources.extension;\n    } else {\n      return null;\n    }\n  },\n  /**\r\n   * Function: getSpecialBundle\r\n   *\r\n   * Hook for subclassers to return the URL for the special bundle. This\r\n   * implementation returns basename + '_' + lan + <extension> or null if\r\n   * <loadSpecialBundle> is false or lan equals <mxClient.defaultLanguage>.\r\n   *\r\n   * If <mxResources.languages> is not null and <mxClient.language> contains\r\n   * a dash, then this method checks if <isLanguageSupported> returns true\r\n   * for the full language (including the dash). If that returns false the\r\n   * first part of the language (up to the dash) will be tried as an extension.\r\n   *\r\n   * If <mxResources.language> is null then the first part of the language is\r\n   * used to maintain backwards compatibility.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * basename - The basename for which the file should be loaded.\r\n   * lan - The language for which the file should be loaded.\r\n   */\n  getSpecialBundle: function getSpecialBundle(basename, lan) {\n    if (_mxClient[\"default\"].languages == null || !this.isLanguageSupported(lan)) {\n      var dash = lan.indexOf('-');\n      if (dash > 0) {\n        lan = lan.substring(0, dash);\n      }\n    }\n    if (mxResources.loadSpecialBundle && mxResources.isLanguageSupported(lan) && lan != _mxClient[\"default\"].defaultLanguage) {\n      return basename + '_' + lan + mxResources.extension;\n    } else {\n      return null;\n    }\n  },\n  /**\r\n   * Function: add\r\n   *\r\n   * Adds the default and current language properties file for the specified\r\n   * basename. Existing keys are overridden as new files are added. If no\r\n   * callback is used then the request is synchronous.\r\n   *\r\n   * Example:\r\n   *\r\n   * At application startup, additional resources may be\r\n   * added using the following code:\r\n   *\r\n   * (code)\r\n   * mxResources.add('resources/editor');\r\n   * (end)\r\n   *\r\n   * Parameters:\r\n   *\r\n   * basename - The basename for which the file should be loaded.\r\n   * lan - The language for which the file should be loaded.\r\n   * callback - Optional callback for asynchronous loading.\r\n   */\n  add: function add(basename, lan, callback) {\n    lan = lan != null ? lan : _mxClient[\"default\"].language != null ? _mxClient[\"default\"].language.toLowerCase() : _mxConstants[\"default\"].NONE;\n    if (lan != _mxConstants[\"default\"].NONE) {\n      var defaultBundle = mxResources.getDefaultBundle(basename, lan);\n      var specialBundle = mxResources.getSpecialBundle(basename, lan);\n      var loadSpecialBundle = function loadSpecialBundle() {\n        if (specialBundle != null) {\n          if (callback) {\n            _mxRequestUtils[\"default\"].get(specialBundle, function (req) {\n              mxResources.parse(req.getText());\n              callback();\n            }, function () {\n              callback();\n            });\n          } else {\n            try {\n              var req = _mxRequestUtils[\"default\"].load(specialBundle);\n              if (req.isReady()) {\n                mxResources.parse(req.getText());\n              }\n            } catch (e) {\n              // ignore\n            }\n          }\n        } else if (callback != null) {\n          callback();\n        }\n      };\n      if (defaultBundle != null) {\n        if (callback) {\n          _mxRequestUtils[\"default\"].get(defaultBundle, function (req) {\n            mxResources.parse(req.getText());\n            loadSpecialBundle();\n          }, function () {\n            loadSpecialBundle();\n          });\n        } else {\n          try {\n            var req = _mxRequestUtils[\"default\"].load(defaultBundle);\n            if (req.isReady()) {\n              mxResources.parse(req.getText());\n            }\n            loadSpecialBundle();\n          } catch (e) {\n            // ignore\n          }\n        }\n      } else {\n        // Overlays the language specific file (_lan-extension)\n        loadSpecialBundle();\n      }\n    }\n  },\n  /**\r\n   * Function: parse\r\n   *\r\n   * Parses the key, value pairs in the specified\r\n   * text and stores them as local resources.\r\n   */\n  parse: function parse(text) {\n    if (text != null) {\n      var lines = text.split('\\n');\n      for (var i = 0; i < lines.length; i++) {\n        if (lines[i].charAt(0) != '#') {\n          var index = lines[i].indexOf('=');\n          if (index > 0) {\n            var key = lines[i].substring(0, index);\n            var idx = lines[i].length;\n            if (lines[i].charCodeAt(idx - 1) == 13) {\n              idx--;\n            }\n            var value = lines[i].substring(index + 1, idx);\n            if (this.resourcesEncoded) {\n              value = value.replace(/\\\\(?=u[a-fA-F\\d]{4})/g, \"%\");\n              mxResources.resources[key] = unescape(value);\n            } else {\n              mxResources.resources[key] = value;\n            }\n          }\n        }\n      }\n    }\n  },\n  /**\r\n   * Function: get\r\n   *\r\n   * Returns the value for the specified resource key.\r\n   *\r\n   * Example:\r\n   * To read the value for 'welomeMessage', use the following:\r\n   * (code)\r\n   * var result = mxResources.get('welcomeMessage') || '';\r\n   * (end)\r\n   *\r\n   * This would require an entry of the following form in\r\n   * one of the English language resource files:\r\n   * (code)\r\n   * welcomeMessage=Welcome to mxGraph!\r\n   * (end)\r\n   *\r\n   * The part behind the || is the string value to be used if the given\r\n   * resource is not available.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * key - String that represents the key of the resource to be returned.\r\n   * params - Array of the values for the placeholders of the form {1}...{n}\r\n   * to be replaced with in the resulting string.\r\n   * defaultValue - Optional string that specifies the default return value.\r\n   */\n  get: function get(key, params, defaultValue) {\n    var value = mxResources.resources[key];\n\n    // Applies the default value if no resource was found\n    if (value == null) {\n      value = defaultValue;\n    }\n\n    // Replaces the placeholders with the values in the array\n    if (value != null && params != null) {\n      value = mxResources.replacePlaceholders(value, params);\n    }\n    return value;\n  },\n  /**\r\n   * Function: replacePlaceholders\r\n   *\r\n   * Replaces the given placeholders with the given parameters.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * value - String that contains the placeholders.\r\n   * params - Array of the values for the placeholders of the form {1}...{n}\r\n   * to be replaced with in the resulting string.\r\n   */\n  replacePlaceholders: function replacePlaceholders(value, params) {\n    var result = [];\n    var index = null;\n    for (var i = 0; i < value.length; i++) {\n      var c = value.charAt(i);\n      if (c == '{') {\n        index = '';\n      } else if (index != null && c == '}') {\n        index = parseInt(index) - 1;\n        if (index >= 0 && index < params.length) {\n          result.push(params[index]);\n        }\n        index = null;\n      } else if (index != null) {\n        index += c;\n      } else {\n        result.push(c);\n      }\n    }\n    return result.join('');\n  },\n  /**\r\n   * Function: loadResources\r\n   *\r\n   * Loads all required resources asynchronously. Use this to load the graph and\r\n   * editor resources if <mxLoadResources> is false.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * callback - Callback function for asynchronous loading.\r\n   */\n  loadResources: function loadResources(callback) {\n    mxResources.add(_mxClient[\"default\"].basePath + '/resources/editor', null, function () {\n      mxResources.add(_mxClient[\"default\"].basePath + '/resources/graph', null, callback);\n    });\n  }\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxPoint\r\n *\r\n * Implements a 2-dimensional vector with double precision coordinates.\r\n *\r\n * Constructor: mxPoint\r\n *\r\n * Constructs a new point for the optional x and y coordinates. If no\r\n * coordinates are given, then the default values for <x> and <y> are used.\r\n */\nvar _default = exports[\"default\"] = mxResources;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxResources.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxRhombus.js":
/*!********************************************!*\
  !*** ./src/workflow/mxClient/mxRhombus.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.fill.js */ \"../../node_modules/core-js/modules/es.array.fill.js\");\nvar _mxPoint = _interopRequireDefault(__webpack_require__(/*! ./mxPoint.js */ \"./src/workflow/mxClient/mxPoint.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxShape = _interopRequireDefault(__webpack_require__(/*! ./mxShape.js */ \"./src/workflow/mxClient/mxShape.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ./mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxRhombus(bounds, fill, stroke, strokewidth) {\n  _mxShape[\"default\"].call(this);\n  this.bounds = bounds;\n  this.fill = fill;\n  this.stroke = stroke;\n  this.strokewidth = strokewidth != null ? strokewidth : 1;\n}\n;\n\n/**\r\n * Extends mxShape.\r\n */\n_mxGraphUtils[\"default\"].extend(mxRhombus, _mxShape[\"default\"]);\n\n/**\r\n * Function: paintVertexShape\r\n *\r\n * Generic painting implementation.\r\n */\nmxRhombus.prototype.paintVertexShape = function (c, x, y, w, h) {\n  var hw = w / 2;\n  var hh = h / 2;\n  var arcSize = _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_ARCSIZE, _mxConstants[\"default\"].LINE_ARCSIZE) / 2;\n  c.begin();\n  this.addPoints(c, [new _mxPoint[\"default\"](x + hw, y), new _mxPoint[\"default\"](x + w, y + hh), new _mxPoint[\"default\"](x + hw, y + h), new _mxPoint[\"default\"](x, y + hh)], this.isRounded, arcSize, true);\n  c.fillAndStroke();\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxPolyline\r\n *\r\n * Extends <mxShape> to implement a polyline (a line with multiple points).\r\n * This shape is registered under <mxConstants.SHAPE_POLYLINE> in\r\n * <mxCellRenderer>.\r\n *\r\n * Constructor: mxPolyline\r\n *\r\n * Constructs a new polyline shape.\r\n *\r\n * Parameters:\r\n *\r\n * points - Array of <mxPoints> that define the points. This is stored in\r\n * <mxShape.points>.\r\n * stroke - String that defines the stroke color. Default is 'black'. This is\r\n * stored in <stroke>.\r\n * strokewidth - Optional integer that defines the stroke width. Default is\r\n * 1. This is stored in <strokewidth>.\r\n */\nvar _default = exports[\"default\"] = mxRhombus;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxRhombus.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxRootChange.js":
/*!***********************************************!*\
  !*** ./src/workflow/mxClient/mxRootChange.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nfunction mxRootChange(model, root) {\n  this.model = model;\n  this.root = root;\n  this.previous = root;\n}\n;\n\n/**\r\n * Function: execute\r\n *\r\n * Carries out a change of the root using\r\n * <mxGraphModel.rootChanged>.\r\n */\nmxRootChange.prototype.execute = function () {\n  this.root = this.previous;\n  this.previous = this.model.rootChanged(this.previous);\n};\nmxRootChange.getName = function () {\n  return 'mxRootChange';\n};\n/**\r\n * Class: mxChildChange\r\n *\r\n * Action to add or remove a child in a model.\r\n *\r\n * Constructor: mxChildChange\r\n *\r\n * Constructs a change of a child in the\r\n * specified model.\r\n */\nvar _default = exports[\"default\"] = mxRootChange;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxRootChange.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxRubberband.js":
/*!***********************************************!*\
  !*** ./src/workflow/mxClient/mxRubberband.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.function.bind.js */ \"../../node_modules/core-js/modules/es.function.bind.js\");\nvar _mxClient = _interopRequireDefault(__webpack_require__(/*! ./mxClient.js */ \"./src/workflow/mxClient/mxClient.js\"));\nvar _mxEvent = _interopRequireDefault(__webpack_require__(/*! ./mxEvent.js */ \"./src/workflow/mxClient/mxEvent.js\"));\nvar _mxMouseEvent = _interopRequireDefault(__webpack_require__(/*! ./mxMouseEvent.js */ \"./src/workflow/mxClient/mxMouseEvent.js\"));\nvar _mxPoint = _interopRequireDefault(__webpack_require__(/*! ./mxPoint.js */ \"./src/workflow/mxClient/mxPoint.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxRectangle = _interopRequireDefault(__webpack_require__(/*! ./mxRectangle.js */ \"./src/workflow/mxClient/mxRectangle.js\"));\nvar _mxUtils = _interopRequireDefault(__webpack_require__(/*! ./mxUtils.js */ \"./src/workflow/mxClient/mxUtils.js\"));\nvar _Diagram = _interopRequireDefault(__webpack_require__(/*! ../css/Diagram.less */ \"./src/workflow/css/Diagram.less\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxRubberband(graph) {\n  if (graph != null) {\n    this.graph = graph;\n    this.graph.addMouseListener(this);\n\n    // Handles force rubberband event\n    this.forceRubberbandHandler = _mxGraphUtils[\"default\"].bind(this, function (sender, evt) {\n      var evtName = evt.getProperty('eventName');\n      var me = evt.getProperty('event');\n      if (evtName == _mxEvent[\"default\"].MOUSE_DOWN && this.isForceRubberbandEvent(me)) {\n        var offset = _mxUtils[\"default\"].getOffset(this.graph.container);\n        var origin = _mxUtils[\"default\"].getScrollOrigin(this.graph.container);\n        origin.x -= offset.x;\n        origin.y -= offset.y;\n        this.start(me.getX() + origin.x, me.getY() + origin.y);\n        me.consume(false);\n      }\n    });\n    this.graph.addListener(_mxEvent[\"default\"].FIRE_MOUSE_EVENT, this.forceRubberbandHandler);\n\n    // Repaints the marquee after autoscroll\n    this.panHandler = _mxGraphUtils[\"default\"].bind(this, function () {\n      this.repaint();\n    });\n    this.graph.addListener(_mxEvent[\"default\"].PAN, this.panHandler);\n\n    // Does not show menu if any touch gestures take place after the trigger\n    this.gestureHandler = _mxGraphUtils[\"default\"].bind(this, function (sender, eo) {\n      if (this.first != null) {\n        this.reset();\n      }\n    });\n    this.graph.addListener(_mxEvent[\"default\"].GESTURE, this.gestureHandler);\n\n    // Automatic deallocation of memory\n    if (_mxClient[\"default\"].IS_IE) {\n      _mxEvent[\"default\"].addListener(window, 'unload', _mxGraphUtils[\"default\"].bind(this, function () {\n        this.destroy();\n      }));\n    }\n  }\n}\n;\n\n/**\r\n * Variable: defaultOpacity\r\n *\r\n * Specifies the default opacity to be used for the rubberband div. Default\r\n * is 20.\r\n */\nmxRubberband.prototype.defaultOpacity = 20;\n\n/**\r\n * Variable: enabled\r\n *\r\n * Specifies if events are handled. Default is true.\r\n */\nmxRubberband.prototype.enabled = true;\n\n/**\r\n * Variable: div\r\n *\r\n * Holds the DIV element which is currently visible.\r\n */\nmxRubberband.prototype.div = null;\n\n/**\r\n * Variable: sharedDiv\r\n *\r\n * Holds the DIV element which is used to display the rubberband.\r\n */\nmxRubberband.prototype.sharedDiv = null;\n\n/**\r\n * Variable: currentX\r\n *\r\n * Holds the value of the x argument in the last call to <update>.\r\n */\nmxRubberband.prototype.currentX = 0;\n\n/**\r\n * Variable: currentY\r\n *\r\n * Holds the value of the y argument in the last call to <update>.\r\n */\nmxRubberband.prototype.currentY = 0;\n\n/**\r\n * Function: isEnabled\r\n *\r\n * Returns true if events are handled. This implementation returns\r\n * <enabled>.\r\n */\nmxRubberband.prototype.isEnabled = function () {\n  return this.enabled;\n};\n\n/**\r\n * Function: setEnabled\r\n *\r\n * Enables or disables event handling. This implementation updates\r\n * <enabled>.\r\n */\nmxRubberband.prototype.setEnabled = function (enabled) {\n  this.enabled = enabled;\n};\n\n/**\r\n * Function: isForceRubberbandEvent\r\n *\r\n * Returns true if the given <mxMouseEvent> should start rubberband selection.\r\n * This implementation returns true if the alt key is pressed.\r\n */\nmxRubberband.prototype.isForceRubberbandEvent = function (me) {\n  return _mxEvent[\"default\"].isAltDown(me.getEvent());\n};\n\n/**\r\n * Function: mouseDown\r\n *\r\n * Handles the event by initiating a rubberband selection. By consuming the\r\n * event all subsequent events of the gesture are redirected to this\r\n * handler.\r\n */\nmxRubberband.prototype.mouseDown = function (sender, me) {\n  if (!me.isConsumed() && this.isEnabled() && this.graph.isEnabled() && me.getState() == null && !_mxEvent[\"default\"].isMultiTouchEvent(me.getEvent())) {\n    var offset = _mxUtils[\"default\"].getOffset(this.graph.container);\n    var origin = _mxUtils[\"default\"].getScrollOrigin(this.graph.container);\n    origin.x -= offset.x;\n    origin.y -= offset.y;\n    this.start(me.getX() + origin.x, me.getY() + origin.y);\n\n    // Does not prevent the default for this event so that the\n    // event processing chain is still executed even if we start\n    // rubberbanding. This is required eg. in ExtJs to hide the\n    // current context menu. In mouseMove we'll make sure we're\n    // not selecting anything while we're rubberbanding.\n    me.consume(false);\n  }\n};\n\n/**\r\n * Function: start\r\n *\r\n * Sets the start point for the rubberband selection.\r\n */\nmxRubberband.prototype.start = function (x, y) {\n  this.first = new _mxPoint[\"default\"](x, y);\n  var container = this.graph.container;\n  function createMouseEvent(evt) {\n    var me = new _mxMouseEvent[\"default\"](evt);\n    var pt = _mxUtils[\"default\"].convertPoint(container, me.getX(), me.getY());\n    me.graphX = pt.x;\n    me.graphY = pt.y;\n    return me;\n  }\n  ;\n  this.dragHandler = _mxGraphUtils[\"default\"].bind(this, function (evt) {\n    this.mouseMove(this.graph, createMouseEvent(evt));\n  });\n  this.dropHandler = _mxGraphUtils[\"default\"].bind(this, function (evt) {\n    this.mouseUp(this.graph, createMouseEvent(evt));\n  });\n\n  // Workaround for rubberband stopping if the mouse leaves the container in Firefox\n  if (_mxClient[\"default\"].IS_FF) {\n    _mxEvent[\"default\"].addGestureListeners(document, null, this.dragHandler, this.dropHandler);\n  }\n};\n\n/**\r\n * Function: mouseMove\r\n *\r\n * Handles the event by updating therubberband selection.\r\n */\nmxRubberband.prototype.mouseMove = function (sender, me) {\n  if (!me.isConsumed() && this.first != null) {\n    var origin = _mxUtils[\"default\"].getScrollOrigin(this.graph.container);\n    var offset = _mxUtils[\"default\"].getOffset(this.graph.container);\n    origin.x -= offset.x;\n    origin.y -= offset.y;\n    var x = me.getX() + origin.x;\n    var y = me.getY() + origin.y;\n    var dx = this.first.x - x;\n    var dy = this.first.y - y;\n    var tol = this.graph.tolerance;\n    if (this.div != null || Math.abs(dx) > tol || Math.abs(dy) > tol) {\n      if (this.div == null) {\n        this.div = this.createShape();\n      }\n\n      // Clears selection while rubberbanding. This is required because\n      // the event is not consumed in mouseDown.\n      _mxUtils[\"default\"].clearSelection();\n      this.update(x, y);\n      me.consume();\n    }\n  }\n};\n\n/**\r\n * Function: createShape\r\n *\r\n * Creates the rubberband selection shape.\r\n */\nmxRubberband.prototype.createShape = function () {\n  if (this.sharedDiv == null) {\n    this.sharedDiv = document.createElement('div');\n    this.sharedDiv.className = _Diagram[\"default\"].rubberband;\n    _mxGraphUtils[\"default\"].setOpacity(this.sharedDiv, this.defaultOpacity);\n  }\n  this.graph.container.appendChild(this.sharedDiv);\n  return this.sharedDiv;\n};\n\n/**\r\n * Function: mouseUp\r\n *\r\n * Handles the event by selecting the region of the rubberband using\r\n * <mxGraph.selectRegion>.\r\n */\nmxRubberband.prototype.mouseUp = function (sender, me) {\n  var execute = this.div != null && this.div.style.display != 'none';\n  this.reset();\n  if (execute) {\n    var rect = new _mxRectangle[\"default\"](this.x, this.y, this.width, this.height);\n    this.graph.selectRegion(rect, me.getEvent());\n    me.consume();\n  }\n};\n\n/**\r\n * Function: reset\r\n *\r\n * Resets the state of the rubberband selection.\r\n */\nmxRubberband.prototype.reset = function () {\n  if (this.div != null) {\n    this.div.parentNode.removeChild(this.div);\n  }\n  _mxEvent[\"default\"].removeGestureListeners(document, null, this.dragHandler, this.dropHandler);\n  this.dragHandler = null;\n  this.dropHandler = null;\n  this.currentX = 0;\n  this.currentY = 0;\n  this.first = null;\n  this.div = null;\n};\n\n/**\r\n * Function: update\r\n *\r\n * Sets <currentX> and <currentY> and calls <repaint>.\r\n */\nmxRubberband.prototype.update = function (x, y) {\n  this.currentX = x;\n  this.currentY = y;\n  this.repaint();\n};\n\n/**\r\n * Function: repaint\r\n *\r\n * Computes the bounding box and updates the style of the <div>.\r\n */\nmxRubberband.prototype.repaint = function () {\n  if (this.div != null) {\n    var x = this.currentX - this.graph.panDx;\n    var y = this.currentY - this.graph.panDy;\n    this.x = Math.min(this.first.x, x);\n    this.y = Math.min(this.first.y, y);\n    this.width = Math.max(this.first.x, x) - this.x;\n    this.height = Math.max(this.first.y, y) - this.y;\n    var dx = _mxClient[\"default\"].IS_VML ? this.graph.panDx : 0;\n    var dy = _mxClient[\"default\"].IS_VML ? this.graph.panDy : 0;\n    this.div.style.left = this.x + dx + 'px';\n    this.div.style.top = this.y + dy + 'px';\n    this.div.style.width = Math.max(1, this.width) + 'px';\n    this.div.style.height = Math.max(1, this.height) + 'px';\n  }\n};\n\n/**\r\n * Function: destroy\r\n *\r\n * Destroys the handler and all its resources and DOM nodes. This does\r\n * normally not need to be called, it is called automatically when the\r\n * window unloads.\r\n */\nmxRubberband.prototype.destroy = function () {\n  if (!this.destroyed) {\n    this.destroyed = true;\n    this.graph.removeMouseListener(this);\n    this.graph.removeListener(this.forceRubberbandHandler);\n    this.graph.removeListener(this.panHandler);\n    this.reset();\n    if (this.sharedDiv != null) {\n      this.sharedDiv = null;\n    }\n  }\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxHandle\r\n *\r\n * Implements a single custom handle for vertices.\r\n *\r\n * Constructor: mxHandle\r\n *\r\n * Constructs a new handle for the given state.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> of the cell to be handled.\r\n */\nvar _default = exports[\"default\"] = mxRubberband;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxRubberband.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxSelectionCellsHandler.js":
/*!**********************************************************!*\
  !*** ./src/workflow/mxClient/mxSelectionCellsHandler.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.function.bind.js */ \"../../node_modules/core-js/modules/es.function.bind.js\");\nvar _mxEventObject = _interopRequireDefault(__webpack_require__(/*! ./mxEventObject.js */ \"./src/workflow/mxClient/mxEventObject.js\"));\nvar _mxEvent = _interopRequireDefault(__webpack_require__(/*! ./mxEvent.js */ \"./src/workflow/mxClient/mxEvent.js\"));\nvar _mxDictionary = _interopRequireDefault(__webpack_require__(/*! ./mxDictionary.js */ \"./src/workflow/mxClient/mxDictionary.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxEventSource = _interopRequireDefault(__webpack_require__(/*! ./mxEventSource.js */ \"./src/workflow/mxClient/mxEventSource.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxSelectionCellsHandler(graph) {\n  _mxEventSource[\"default\"].call(this);\n  this.graph = graph;\n  this.handlers = new _mxDictionary[\"default\"]();\n  this.graph.addMouseListener(this);\n  this.refreshHandler = _mxGraphUtils[\"default\"].bind(this, function (sender, evt) {\n    if (this.isEnabled()) {\n      this.refresh();\n    }\n  });\n  this.graph.getSelectionModel().addListener(_mxEvent[\"default\"].CHANGE, this.refreshHandler);\n  this.graph.getModel().addListener(_mxEvent[\"default\"].CHANGE, this.refreshHandler);\n  this.graph.getView().addListener(_mxEvent[\"default\"].SCALE, this.refreshHandler);\n  this.graph.getView().addListener(_mxEvent[\"default\"].TRANSLATE, this.refreshHandler);\n  this.graph.getView().addListener(_mxEvent[\"default\"].SCALE_AND_TRANSLATE, this.refreshHandler);\n  this.graph.getView().addListener(_mxEvent[\"default\"].DOWN, this.refreshHandler);\n  this.graph.getView().addListener(_mxEvent[\"default\"].UP, this.refreshHandler);\n}\n;\n\n/**\r\n * Extends mxEventSource.\r\n */\n_mxGraphUtils[\"default\"].extend(mxSelectionCellsHandler, _mxEventSource[\"default\"]);\n\n/**\r\n * Variable: graph\r\n *\r\n * Reference to the enclosing <mxGraph>.\r\n */\nmxSelectionCellsHandler.prototype.graph = null;\n\n/**\r\n * Variable: enabled\r\n *\r\n * Specifies if events are handled. Default is true.\r\n */\nmxSelectionCellsHandler.prototype.enabled = true;\n\n/**\r\n * Variable: refreshHandler\r\n *\r\n * Keeps a reference to an event listener for later removal.\r\n */\nmxSelectionCellsHandler.prototype.refreshHandler = null;\n\n/**\r\n * Variable: maxHandlers\r\n *\r\n * Defines the maximum number of handlers to paint individually. Default is 100.\r\n */\nmxSelectionCellsHandler.prototype.maxHandlers = 100;\n\n/**\r\n * Variable: handlers\r\n *\r\n * <mxDictionary> that maps from cells to handlers.\r\n */\nmxSelectionCellsHandler.prototype.handlers = null;\n\n/**\r\n * Function: isEnabled\r\n *\r\n * Returns <enabled>.\r\n */\nmxSelectionCellsHandler.prototype.isEnabled = function () {\n  return this.enabled;\n};\n\n/**\r\n * Function: setEnabled\r\n *\r\n * Sets <enabled>.\r\n */\nmxSelectionCellsHandler.prototype.setEnabled = function (value) {\n  this.enabled = value;\n};\n\n/**\r\n * Function: getHandler\r\n *\r\n * Returns the handler for the given cell.\r\n */\nmxSelectionCellsHandler.prototype.getHandler = function (cell) {\n  return this.handlers.get(cell);\n};\n\n/**\r\n * Function: reset\r\n *\r\n * Resets all handlers.\r\n */\nmxSelectionCellsHandler.prototype.reset = function () {\n  this.handlers.visit(function (key, handler) {\n    handler.reset.apply(handler);\n  });\n};\n\n/**\r\n * Function: refresh\r\n *\r\n * Reloads or updates all handlers.\r\n */\nmxSelectionCellsHandler.prototype.refresh = function () {\n  // Removes all existing handlers\n  var oldHandlers = this.handlers;\n  this.handlers = new _mxDictionary[\"default\"]();\n\n  // Creates handles for all selection cells\n  var tmp = this.graph.getSelectionCells();\n  for (var i = 0; i < tmp.length; i++) {\n    var state = this.graph.view.getState(tmp[i]);\n    if (state != null) {\n      var handler = oldHandlers.remove(tmp[i]);\n      if (handler != null) {\n        if (handler.state != state) {\n          handler.destroy();\n          handler = null;\n        } else {\n          if (handler.refresh != null) {\n            handler.refresh();\n          }\n          handler.redraw();\n        }\n      }\n      if (handler == null) {\n        handler = this.graph.createHandler(state);\n        this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].ADD, 'state', state));\n      }\n      if (handler != null) {\n        this.handlers.put(tmp[i], handler);\n      }\n    }\n  }\n\n  // Destroys all unused handlers\n  oldHandlers.visit(_mxGraphUtils[\"default\"].bind(this, function (key, handler) {\n    this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].REMOVE, 'state', handler.state));\n    handler.destroy();\n  }));\n};\n\n/**\r\n * Function: updateHandler\r\n *\r\n * Updates the handler for the given shape if one exists.\r\n */\nmxSelectionCellsHandler.prototype.updateHandler = function (state) {\n  var handler = this.handlers.remove(state.cell);\n  if (handler != null) {\n    handler.destroy();\n    handler = this.graph.createHandler(state);\n    if (handler != null) {\n      this.handlers.put(state.cell, handler);\n    }\n  }\n};\n\n/**\r\n * Function: mouseDown\r\n *\r\n * Redirects the given event to the handlers.\r\n */\nmxSelectionCellsHandler.prototype.mouseDown = function (sender, me) {\n  if (this.graph.isEnabled() && this.isEnabled()) {\n    var args = [sender, me];\n    this.handlers.visit(function (key, handler) {\n      handler.mouseDown.apply(handler, args);\n    });\n  }\n};\n\n/**\r\n * Function: mouseMove\r\n *\r\n * Redirects the given event to the handlers.\r\n */\nmxSelectionCellsHandler.prototype.mouseMove = function (sender, me) {\n  if (this.graph.isEnabled() && this.isEnabled()) {\n    var args = [sender, me];\n    this.handlers.visit(function (key, handler) {\n      handler.mouseMove.apply(handler, args);\n    });\n  }\n};\n\n/**\r\n * Function: mouseUp\r\n *\r\n * Redirects the given event to the handlers.\r\n */\nmxSelectionCellsHandler.prototype.mouseUp = function (sender, me) {\n  if (this.graph.isEnabled() && this.isEnabled()) {\n    var args = [sender, me];\n    this.handlers.visit(function (key, handler) {\n      handler.mouseUp.apply(handler, args);\n    });\n  }\n};\n\n/**\r\n * Function: destroy\r\n *\r\n * Destroys the handler and all its resources and DOM nodes.\r\n */\nmxSelectionCellsHandler.prototype.destroy = function () {\n  this.graph.removeMouseListener(this);\n  if (this.refreshHandler != null) {\n    this.graph.getSelectionModel().removeListener(this.refreshHandler);\n    this.graph.getModel().removeListener(this.refreshHandler);\n    this.graph.getView().removeListener(this.refreshHandler);\n    this.refreshHandler = null;\n  }\n};\n/**\r\n * Copyright (c) 2006-2016, JGraph Ltd\r\n * Copyright (c) 2006-2016, Gaudenz Alder\r\n */\n/**\r\n * Class: mxConnectionHandler\r\n *\r\n * Graph event handler that creates new connections. Uses <mxTerminalMarker>\r\n * for finding and highlighting the source and target vertices and\r\n * <factoryMethod> to create the edge instance. This handler is built-into\r\n * <mxGraph.connectionHandler> and enabled using <mxGraph.setConnectable>.\r\n *\r\n * Example:\r\n *\r\n * (code)\r\n * new mxConnectionHandler(graph, function(source, target, style)\r\n * {\r\n *   edge = new mxCell('', new mxGeometry());\r\n *   edge.setEdge(true);\r\n *   edge.setStyle(style);\r\n *   edge.geometry.relative = true;\r\n *   return edge;\r\n * });\r\n * (end)\r\n *\r\n * Here is an alternative solution that just sets a specific user object for\r\n * new edges by overriding <insertEdge>.\r\n *\r\n * (code)\r\n * mxConnectionHandlerInsertEdge = mxConnectionHandler.prototype.insertEdge;\r\n * mxConnectionHandler.prototype.insertEdge = function(parent, id, value, source, target, style)\r\n * {\r\n *   value = 'Test';\r\n *\r\n *   return mxConnectionHandlerInsertEdge.apply(this, arguments);\r\n * };\r\n * (end)\r\n *\r\n * Using images to trigger connections:\r\n *\r\n * This handler uses mxTerminalMarker to find the source and target cell for\r\n * the new connection and creates a new edge using <connect>. The new edge is\r\n * created using <createEdge> which in turn uses <factoryMethod> or creates a\r\n * new default edge.\r\n *\r\n * The handler uses a \"highlight-paradigm\" for indicating if a cell is being\r\n * used as a source or target terminal, as seen in other diagramming products.\r\n * In order to allow both, moving and connecting cells at the same time,\r\n * <mxConstants.DEFAULT_HOTSPOT> is used in the handler to determine the hotspot\r\n * of a cell, that is, the region of the cell which is used to trigger a new\r\n * connection. The constant is a value between 0 and 1 that specifies the\r\n * amount of the width and height around the center to be used for the hotspot\r\n * of a cell and its default value is 0.5. In addition,\r\n * <mxConstants.MIN_HOTSPOT_SIZE> defines the minimum number of pixels for the\r\n * width and height of the hotspot.\r\n *\r\n * This solution, while standards compliant, may be somewhat confusing because\r\n * there is no visual indicator for the hotspot and the highlight is seen to\r\n * switch on and off while the mouse is being moved in and out. Furthermore,\r\n * this paradigm does not allow to create different connections depending on\r\n * the highlighted hotspot as there is only one hotspot per cell and it\r\n * normally does not allow cells to be moved and connected at the same time as\r\n * there is no clear indication of the connectable area of the cell.\r\n *\r\n * To come across these issues, the handle has an additional <createIcons> hook\r\n * with a default implementation that allows to create one icon to be used to\r\n * trigger new connections. If this icon is specified, then new connections can\r\n * only be created if the image is clicked while the cell is being highlighted.\r\n * The <createIcons> hook may be overridden to create more than one\r\n * <mxImageShape> for creating new connections, but the default implementation\r\n * supports one image and is used as follows:\r\n *\r\n * In order to display the \"connect image\" whenever the mouse is over the cell,\r\n * an DEFAULT_HOTSPOT of 1 should be used:\r\n *\r\n * (code)\r\n * mxConstants.DEFAULT_HOTSPOT = 1;\r\n * (end)\r\n *\r\n * In order to avoid confusion with the highlighting, the highlight color\r\n * should not be used with a connect image:\r\n *\r\n * (code)\r\n * mxConstants.HIGHLIGHT_COLOR = null;\r\n * (end)\r\n *\r\n * To install the image, the connectImage field of the mxConnectionHandler must\r\n * be assigned a new <mxImage> instance:\r\n *\r\n * (code)\r\n * mxConnectionHandler.prototype.connectImage = new mxImage('images/green-dot.gif', 14, 14);\r\n * (end)\r\n *\r\n * This will use the green-dot.gif with a width and height of 14 pixels as the\r\n * image to trigger new connections. In createIcons the icon field of the\r\n * handler will be set in order to remember the icon that has been clicked for\r\n * creating the new connection. This field will be available under selectedIcon\r\n * in the connect method, which may be overridden to take the icon that\r\n * triggered the new connection into account. This is useful if more than one\r\n * icon may be used to create a connection.\r\n *\r\n * Group: Events\r\n *\r\n * Event: mxEvent.START\r\n *\r\n * Fires when a new connection is being created by the user. The <code>state</code>\r\n * property contains the state of the source cell.\r\n *\r\n * Event: mxEvent.CONNECT\r\n *\r\n * Fires between begin- and endUpdate in <connect>. The <code>cell</code>\r\n * property contains the inserted edge, the <code>event</code> and <code>target</code>\r\n * properties contain the respective arguments that were passed to <connect> (where\r\n * target corresponds to the dropTarget argument). Finally, the <code>terminal</code>\r\n * property corresponds to the target argument in <connect> or the clone of the source\r\n * terminal if <createTarget> is enabled.\r\n *\r\n * Note that the target is the cell under the mouse where the mouse button was released.\r\n * Depending on the logic in the handler, this doesn't necessarily have to be the target\r\n * of the inserted edge. To print the source, target or any optional ports IDs that the\r\n * edge is connected to, the following code can be used. To get more details about the\r\n * actual connection point, <mxGraph.getConnectionConstraint> can be used. To resolve\r\n * the port IDs, use <mxGraphModel.getCell>.\r\n *\r\n * (code)\r\n * graph.connectionHandler.addListener(mxEvent.CONNECT, function(sender, evt)\r\n * {\r\n *   var edge = evt.getProperty('cell');\r\n *   var source = graph.getModel().getTerminal(edge, true);\r\n *   var target = graph.getModel().getTerminal(edge, false);\r\n *\r\n *   var style = graph.getCellStyle(edge);\r\n *   var sourcePortId = style[mxConstants.STYLE_SOURCE_PORT];\r\n *   var targetPortId = style[mxConstants.STYLE_TARGET_PORT];\r\n *\r\n *   mxLog.show();\r\n *   mxLog.debug('connect', edge, source.id, target.id, sourcePortId, targetPortId);\r\n * });\r\n * (end)\r\n *\r\n * Event: mxEvent.RESET\r\n *\r\n * Fires when the <reset> method is invoked.\r\n *\r\n * Constructor: mxConnectionHandler\r\n *\r\n * Constructs an event handler that connects vertices using the specified\r\n * factory method to create the new edges. Modify\r\n * <mxConstants.ACTIVE_REGION> to setup the region on a cell which triggers\r\n * the creation of a new connection or use connect icons as explained\r\n * above.\r\n *\r\n * Parameters:\r\n *\r\n * graph - Reference to the enclosing <mxGraph>.\r\n * factoryMethod - Optional function to create the edge. The function takes\r\n * the source and target <mxCell> as the first and second argument and an\r\n * optional cell style from the preview as the third argument. It returns\r\n * the <mxCell> that represents the new edge.\r\n */\nvar _default = exports[\"default\"] = mxSelectionCellsHandler;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxSelectionCellsHandler.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxSelectionChange.js":
/*!****************************************************!*\
  !*** ./src/workflow/mxClient/mxSelectionChange.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.slice.js */ \"../../node_modules/core-js/modules/es.array.slice.js\");\nvar _mxEventObject = _interopRequireDefault(__webpack_require__(/*! ./mxEventObject.js */ \"./src/workflow/mxClient/mxEventObject.js\"));\nvar _mxEvent = _interopRequireDefault(__webpack_require__(/*! ./mxEvent.js */ \"./src/workflow/mxClient/mxEvent.js\"));\nvar _mxResources = _interopRequireDefault(__webpack_require__(/*! ./mxResources.js */ \"./src/workflow/mxClient/mxResources.js\"));\nvar _mxLog = _interopRequireDefault(__webpack_require__(/*! ./mxLog.js */ \"./src/workflow/mxClient/mxLog.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxSelectionChange(selectionModel, added, removed) {\n  this.selectionModel = selectionModel;\n  this.added = added != null ? added.slice() : null;\n  this.removed = removed != null ? removed.slice() : null;\n}\n;\n\n/**\r\n * Function: execute\r\n *\r\n * Changes the current root of the view.\r\n */\nmxSelectionChange.prototype.execute = function () {\n  var t0 = _mxLog[\"default\"].enter('mxSelectionChange.execute');\n  window.status = _mxResources[\"default\"].get(this.selectionModel.updatingSelectionResource) || this.selectionModel.updatingSelectionResource;\n  if (this.removed != null) {\n    for (var i = 0; i < this.removed.length; i++) {\n      this.selectionModel.cellRemoved(this.removed[i]);\n    }\n  }\n  if (this.added != null) {\n    for (var i = 0; i < this.added.length; i++) {\n      this.selectionModel.cellAdded(this.added[i]);\n    }\n  }\n  var tmp = this.added;\n  this.added = this.removed;\n  this.removed = tmp;\n  window.status = _mxResources[\"default\"].get(this.selectionModel.doneResource) || this.selectionModel.doneResource;\n  _mxLog[\"default\"].leave('mxSelectionChange.execute', t0);\n  this.selectionModel.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].CHANGE, 'added', this.removed, 'removed', this.added));\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxCellEditor\r\n *\r\n * In-place editor for the graph. To control this editor, use\r\n * <mxGraph.invokesStopCellEditing>, <mxGraph.enterStopsCellEditing> and\r\n * <mxGraph.escapeEnabled>. If <mxGraph.enterStopsCellEditing> is true then\r\n * ctrl-enter or shift-enter can be used to create a linefeed. The F2 and\r\n * escape keys can always be used to stop editing.\r\n *\r\n * To customize the location of the textbox in the graph, override\r\n * <getEditorBounds> as follows:\r\n *\r\n * (code)\r\n * graph.cellEditor.getEditorBounds = function(state)\r\n * {\r\n *   var result = mxCellEditor.prototype.getEditorBounds.apply(this, arguments);\r\n *\r\n *   if (this.graph.getModel().isEdge(state.cell))\r\n *   {\r\n *     result.x = state.getCenterX() - result.width / 2;\r\n *     result.y = state.getCenterY() - result.height / 2;\r\n *   }\r\n *\r\n *   return result;\r\n * };\r\n * (end)\r\n *\r\n * Note that this hook is only called if <autoSize> is false. If <autoSize> is true,\r\n * then <mxShape.getLabelBounds> is used to compute the current bounds of the textbox.\r\n *\r\n * The textarea uses the mxCellEditor CSS class. You can modify this class in\r\n * your custom CSS. Note: You should modify the CSS after loading the client\r\n * in the page.\r\n *\r\n * Example:\r\n *\r\n * To only allow numeric input in the in-place editor, use the following code.\r\n *\r\n * (code)\r\n * var text = graph.cellEditor.textarea;\r\n *\r\n * mxEvent.addListener(text, 'keydown', function (evt)\r\n * {\r\n *   if (!(evt.keyCode >= 48 && evt.keyCode <= 57) &&\r\n *       !(evt.keyCode >= 96 && evt.keyCode <= 105))\r\n *   {\r\n *     mxEvent.consume(evt);\r\n *   }\r\n * });\r\n * (end)\r\n *\r\n * Placeholder:\r\n *\r\n * To implement a placeholder for cells without a label, use the\r\n * <emptyLabelText> variable.\r\n *\r\n * Resize in Chrome:\r\n *\r\n * Resize of the textarea is disabled by default. If you want to enable\r\n * this feature extend <init> and set this.textarea.style.resize = ''.\r\n *\r\n * To start editing on a key press event, the container of the graph\r\n * should have focus or a focusable parent should be used to add the\r\n * key press handler as follows.\r\n *\r\n * (code)\r\n * mxEvent.addListener(graph.container, 'keypress', mxGraphUtils.bind(this, function(evt)\r\n * {\r\n *   if (!graph.isEditing() && !graph.isSelectionEmpty() && evt.which !== 0 &&\r\n *       !mxEvent.isAltDown(evt) && !mxEvent.isControlDown(evt) && !mxEvent.isMetaDown(evt))\r\n *   {\r\n *     graph.startEditing();\r\n *\r\n *     if (mxClient.IS_FF)\r\n *     {\r\n *       graph.cellEditor.textarea.value = String.fromCharCode(evt.which);\r\n *     }\r\n *   }\r\n * }));\r\n * (end)\r\n *\r\n * To allow focus for a DIV, and hence to receive key press events, some browsers\r\n * require it to have a valid tabindex attribute. In this case the following\r\n * code may be used to keep the container focused.\r\n *\r\n * (code)\r\n * var graphFireMouseEvent = graph.fireMouseEvent;\r\n * graph.fireMouseEvent = function(evtName, me, sender)\r\n * {\r\n *   if (evtName == mxEvent.MOUSE_DOWN)\r\n *   {\r\n *     this.container.focus();\r\n *   }\r\n *\r\n *   graphFireMouseEvent.apply(this, arguments);\r\n * };\r\n * (end)\r\n *\r\n * Constructor: mxCellEditor\r\n *\r\n * Constructs a new in-place editor for the specified graph.\r\n *\r\n * Parameters:\r\n *\r\n * graph - Reference to the enclosing <mxGraph>.\r\n */\nvar _default = exports[\"default\"] = mxSelectionChange;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxSelectionChange.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxShape.js":
/*!******************************************!*\
  !*** ./src/workflow/mxClient/mxShape.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.fill.js */ \"../../node_modules/core-js/modules/es.array.fill.js\");\n__webpack_require__(/*! core-js/modules/es.array.filter.js */ \"../../node_modules/core-js/modules/es.array.filter.js\");\n__webpack_require__(/*! core-js/modules/es.array.slice.js */ \"../../node_modules/core-js/modules/es.array.slice.js\");\n__webpack_require__(/*! core-js/modules/es.array.splice.js */ \"../../node_modules/core-js/modules/es.array.splice.js\");\n__webpack_require__(/*! core-js/modules/es.number.constructor.js */ \"../../node_modules/core-js/modules/es.number.constructor.js\");\n__webpack_require__(/*! core-js/modules/es.object.to-string.js */ \"../../node_modules/core-js/modules/es.object.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.parse-float.js */ \"../../node_modules/core-js/modules/es.parse-float.js\");\nvar _mxClient = _interopRequireDefault(__webpack_require__(/*! ./mxClient.js */ \"./src/workflow/mxClient/mxClient.js\"));\nvar _mxPoint = _interopRequireDefault(__webpack_require__(/*! ./mxPoint.js */ \"./src/workflow/mxClient/mxPoint.js\"));\nvar _mxEventUtils = _interopRequireDefault(__webpack_require__(/*! ./mxEventUtils.js */ \"./src/workflow/mxClient/mxEventUtils.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxRectangle = _interopRequireDefault(__webpack_require__(/*! ./mxRectangle.js */ \"./src/workflow/mxClient/mxRectangle.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ./mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nvar _mxVmlCanvas2D = _interopRequireDefault(__webpack_require__(/*! ./mxVmlCanvas2D.js */ \"./src/workflow/mxClient/mxVmlCanvas2D.js\"));\nvar _mxSvgCanvas2D = _interopRequireDefault(__webpack_require__(/*! ./mxSvgCanvas2D.js */ \"./src/workflow/mxClient/mxSvgCanvas2D.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxShape(stencil) {\n  this.stencil = stencil;\n  this.initStyles();\n}\n;\n\n/**\r\n * Variable: dialect\r\n *\r\n * Holds the dialect in which the shape is to be painted.\r\n * This can be one of the DIALECT constants in <mxConstants>.\r\n */\nmxShape.prototype.dialect = null;\n\n/**\r\n * Variable: scale\r\n *\r\n * Holds the scale in which the shape is being painted.\r\n */\nmxShape.prototype.scale = 1;\n\n/**\r\n * Variable: antiAlias\r\n *\r\n * Rendering hint for configuring the canvas.\r\n */\nmxShape.prototype.antiAlias = true;\n\n/**\r\n * Variable: bounds\r\n *\r\n * Holds the <mxRectangle> that specifies the bounds of this shape.\r\n */\nmxShape.prototype.bounds = null;\n\n/**\r\n * Variable: points\r\n *\r\n * Holds the array of <mxPoints> that specify the points of this shape.\r\n */\nmxShape.prototype.points = null;\n\n/**\r\n * Variable: node\r\n *\r\n * Holds the outermost DOM node that represents this shape.\r\n */\nmxShape.prototype.node = null;\n\n/**\r\n * Variable: state\r\n *\r\n * Optional reference to the corresponding <mxCellState>.\r\n */\nmxShape.prototype.state = null;\n\n/**\r\n * Variable: style\r\n *\r\n * Optional reference to the style of the corresponding <mxCellState>.\r\n */\nmxShape.prototype.style = null;\n\n/**\r\n * Variable: boundingBox\r\n *\r\n * Contains the bounding box of the shape, that is, the smallest rectangle\r\n * that includes all pixels of the shape.\r\n */\nmxShape.prototype.boundingBox = null;\n\n/**\r\n * Variable: stencil\r\n *\r\n * Holds the <mxStencil> that defines the shape.\r\n */\nmxShape.prototype.stencil = null;\n\n/**\r\n * Variable: svgStrokeTolerance\r\n *\r\n * Event-tolerance for SVG strokes (in px). Default is 8. This is only passed\r\n * to the canvas in <createSvgCanvas> if <pointerEvents> is true.\r\n */\nmxShape.prototype.svgStrokeTolerance = 8;\n\n/**\r\n * Variable: pointerEvents\r\n *\r\n * Specifies if pointer events should be handled. Default is true.\r\n */\nmxShape.prototype.pointerEvents = true;\n\n/**\r\n * Variable: svgPointerEvents\r\n *\r\n * Specifies if pointer events should be handled. Default is true.\r\n */\nmxShape.prototype.svgPointerEvents = 'all';\n\n/**\r\n * Variable: shapePointerEvents\r\n *\r\n * Specifies if pointer events outside of shape should be handled. Default\r\n * is false.\r\n */\nmxShape.prototype.shapePointerEvents = false;\n\n/**\r\n * Variable: stencilPointerEvents\r\n *\r\n * Specifies if pointer events outside of stencils should be handled. Default\r\n * is false. Set this to true for backwards compatibility with the 1.x branch.\r\n */\nmxShape.prototype.stencilPointerEvents = false;\n\n/**\r\n * Variable: vmlScale\r\n *\r\n * Scale for improving the precision of VML rendering. Default is 1.\r\n */\nmxShape.prototype.vmlScale = 1;\n\n/**\r\n * Variable: outline\r\n *\r\n * Specifies if the shape should be drawn as an outline. This disables all\r\n * fill colors and can be used to disable other drawing states that should\r\n * not be painted for outlines. Default is false. This should be set before\r\n * calling <apply>.\r\n */\nmxShape.prototype.outline = false;\n\n/**\r\n * Variable: visible\r\n *\r\n * Specifies if the shape is visible. Default is true.\r\n */\nmxShape.prototype.visible = true;\n\n/**\r\n * Variable: useSvgBoundingBox\r\n *\r\n * Allows to use the SVG bounding box in SVG. Default is false for performance\r\n * reasons.\r\n */\nmxShape.prototype.useSvgBoundingBox = false;\n\n/**\r\n * Function: init\r\n *\r\n * Initializes the shape by creaing the DOM node using <create>\r\n * and adding it into the given container.\r\n *\r\n * Parameters:\r\n *\r\n * container - DOM node that will contain the shape.\r\n */\nmxShape.prototype.init = function (container) {\n  if (this.node == null) {\n    this.node = this.create(container);\n    if (container != null) {\n      container.appendChild(this.node);\n    }\n  }\n};\n\n/**\r\n * Function: initStyles\r\n *\r\n * Sets the styles to their default values.\r\n */\nmxShape.prototype.initStyles = function (container) {\n  this.strokewidth = 1;\n  this.rotation = 0;\n  this.opacity = 100;\n  this.fillOpacity = 100;\n  this.strokeOpacity = 100;\n  this.flipH = false;\n  this.flipV = false;\n};\n\n/**\r\n * Function: isParseVml\r\n *\r\n * Specifies if any VML should be added via insertAdjacentHtml to the DOM. This\r\n * is only needed in IE8 and only if the shape contains VML markup. This method\r\n * returns true.\r\n */\nmxShape.prototype.isParseVml = function () {\n  return true;\n};\n\n/**\r\n * Function: isHtmlAllowed\r\n *\r\n * Returns true if HTML is allowed for this shape. This implementation always\r\n * returns false.\r\n */\nmxShape.prototype.isHtmlAllowed = function () {\n  return false;\n};\n\n/**\r\n * Function: getSvgScreenOffset\r\n *\r\n * Returns 0, or 0.5 if <strokewidth> % 2 == 1.\r\n */\nmxShape.prototype.getSvgScreenOffset = function () {\n  var sw = this.stencil && this.stencil.strokewidth != 'inherit' ? Number(this.stencil.strokewidth) : this.strokewidth;\n  return _mxGraphUtils[\"default\"].mod(Math.max(1, Math.round(sw * this.scale)), 2) == 1 ? 0.5 : 0;\n};\n\n/**\r\n * Function: create\r\n *\r\n * Creates and returns the DOM node(s) for the shape in\r\n * the given container. This implementation invokes\r\n * <createSvg>, <createHtml> or <createVml> depending\r\n * on the <dialect> and style settings.\r\n *\r\n * Parameters:\r\n *\r\n * container - DOM node that will contain the shape.\r\n */\nmxShape.prototype.create = function (container) {\n  var node = null;\n  if (container != null && container.ownerSVGElement != null) {\n    node = this.createSvg(container);\n  } else if (document.documentMode == 8 || !_mxClient[\"default\"].IS_VML || this.dialect != _mxConstants[\"default\"].DIALECT_VML && this.isHtmlAllowed()) {\n    node = this.createHtml(container);\n  } else {\n    node = this.createVml(container);\n  }\n  return node;\n};\n\n/**\r\n * Function: createSvg\r\n *\r\n * Creates and returns the SVG node(s) to represent this shape.\r\n */\nmxShape.prototype.createSvg = function () {\n  return document.createElementNS(_mxConstants[\"default\"].NS_SVG, 'g');\n};\n\n/**\r\n * Function: createVml\r\n *\r\n * Creates and returns the VML node to represent this shape.\r\n */\nmxShape.prototype.createVml = function () {\n  var node = document.createElement(_mxClient[\"default\"].VML_PREFIX + ':group');\n  node.style.position = 'absolute';\n  return node;\n};\n\n/**\r\n * Function: createHtml\r\n *\r\n * Creates and returns the HTML DOM node(s) to represent\r\n * this shape. This implementation falls back to <createVml>\r\n * so that the HTML creation is optional.\r\n */\nmxShape.prototype.createHtml = function () {\n  var node = document.createElement('div');\n  node.style.position = 'absolute';\n  return node;\n};\n\n/**\r\n * Function: reconfigure\r\n *\r\n * Reconfigures this shape. This will update the colors etc in\r\n * addition to the bounds or points.\r\n */\nmxShape.prototype.reconfigure = function () {\n  this.redraw();\n};\n\n/**\r\n * Function: redraw\r\n *\r\n * Creates and returns the SVG node(s) to represent this shape.\r\n */\nmxShape.prototype.redraw = function () {\n  this.updateBoundsFromPoints();\n  if (this.visible && this.checkBounds()) {\n    this.node.style.visibility = 'visible';\n    this.clear();\n    if (this.node.nodeName == 'DIV' && (this.isHtmlAllowed() || !_mxClient[\"default\"].IS_VML)) {\n      //ie 浏览器加title\n      if (this.state && this.state.cell && this.state.cell.value) {\n        this.node.title = this.state.cell.value;\n      }\n      this.redrawHtmlShape();\n    } else {\n      this.redrawShape();\n    }\n    this.updateBoundingBox();\n  } else {\n    this.node.style.visibility = 'hidden';\n    this.boundingBox = null;\n  }\n};\n\n/**\r\n * Function: clear\r\n *\r\n * Removes all child nodes and resets all CSS.\r\n */\nmxShape.prototype.clear = function () {\n  if (this.node.ownerSVGElement != null) {\n    while (this.node.lastChild != null) {\n      this.node.removeChild(this.node.lastChild);\n    }\n  } else {\n    this.node.style.cssText = 'position:absolute;' + (this.cursor != null ? 'cursor:' + this.cursor + ';' : '');\n    this.node.innerHTML = '';\n  }\n};\n\n/**\r\n * Function: updateBoundsFromPoints\r\n *\r\n * Updates the bounds based on the points.\r\n */\nmxShape.prototype.updateBoundsFromPoints = function () {\n  var pts = this.points;\n  if (pts != null && pts.length > 0 && pts[0] != null) {\n    this.bounds = new _mxRectangle[\"default\"](Number(pts[0].x), Number(pts[0].y), 1, 1);\n    for (var i = 1; i < this.points.length; i++) {\n      if (pts[i] != null) {\n        this.bounds.add(new _mxRectangle[\"default\"](Number(pts[i].x), Number(pts[i].y), 1, 1));\n      }\n    }\n  }\n};\n\n/**\r\n * Function: getLabelBounds\r\n *\r\n * Returns the <mxRectangle> for the label bounds of this shape, based on the\r\n * given scaled and translated bounds of the shape. This method should not\r\n * change the rectangle in-place. This implementation returns the given rect.\r\n */\nmxShape.prototype.getLabelBounds = function (rect) {\n  return rect;\n};\n\n/**\r\n * Function: checkBounds\r\n *\r\n * Returns true if the bounds are not null and all of its variables are numeric.\r\n */\nmxShape.prototype.checkBounds = function () {\n  return !isNaN(this.scale) && isFinite(this.scale) && this.scale > 0 && this.bounds != null && !isNaN(this.bounds.x) && !isNaN(this.bounds.y) && !isNaN(this.bounds.width) && !isNaN(this.bounds.height) && this.bounds.width > 0 && this.bounds.height > 0;\n};\n\n/**\r\n * Function: createVmlGroup\r\n *\r\n * Returns the temporary element used for rendering in IE8 standards mode.\r\n */\nmxShape.prototype.createVmlGroup = function () {\n  var node = document.createElement(_mxClient[\"default\"].VML_PREFIX + ':group');\n  node.style.position = 'absolute';\n  node.style.width = this.node.style.width;\n  node.style.height = this.node.style.height;\n  return node;\n};\n\n/**\r\n * Function: redrawShape\r\n *\r\n * Updates the SVG or VML shape.\r\n */\nmxShape.prototype.redrawShape = function () {\n  var canvas = this.createCanvas();\n  if (canvas != null) {\n    // Specifies if events should be handled\n    canvas.pointerEvents = this.pointerEvents;\n    this.paint(canvas);\n    if (this.node != canvas.root) {\n      // Forces parsing in IE8 standards mode - slow! avoid\n      this.node.insertAdjacentHTML('beforeend', canvas.root.outerHTML);\n    }\n    if (this.node.nodeName == 'DIV' && document.documentMode == 8) {\n      // Makes DIV transparent to events for IE8 in IE8 standards\n      // mode (Note: Does not work for IE9 in IE8 standards mode\n      // and not for IE11 in enterprise mode)\n      this.node.style.filter = '';\n\n      // Adds event transparency in IE8 standards\n      _mxGraphUtils[\"default\"].addTransparentBackgroundFilter(this.node);\n    }\n    this.destroyCanvas(canvas);\n  }\n};\n\n/**\r\n * Function: createCanvas\r\n *\r\n * Destroys the given canvas which was used for drawing. This implementation\r\n * increments the reference counts on all shared gradients used in the canvas.\r\n */\nmxShape.prototype.createCanvas = function () {\n  var canvas = null;\n\n  // LATER: Check if reusing existing DOM nodes improves performance\n  if (this.node.ownerSVGElement != null) {\n    canvas = this.createSvgCanvas();\n  } else if (_mxClient[\"default\"].IS_VML) {\n    this.updateVmlContainer();\n    canvas = this.createVmlCanvas();\n  }\n  if (this.outline && canvas) {\n    canvas.setStrokeWidth(this.strokewidth);\n    canvas.setStrokeColor(this.stroke);\n    if (this.isDashed != null) {\n      canvas.setDashed(this.isDashed);\n    }\n    canvas.setStrokeWidth = function () {};\n    canvas.setStrokeColor = function () {};\n    canvas.setFillColor = function () {};\n    canvas.setGradient = function () {};\n    canvas.setDashed = function () {};\n  }\n  return canvas;\n};\n\n/**\r\n * Function: createSvgCanvas\r\n *\r\n * Creates and returns an <mxSvgCanvas2D> for rendering this shape.\r\n */\nmxShape.prototype.createSvgCanvas = function () {\n  var canvas = new _mxSvgCanvas2D[\"default\"](this.node, false);\n  canvas.strokeTolerance = this.pointerEvents ? this.svgStrokeTolerance : 0;\n  canvas.pointerEventsValue = this.svgPointerEvents;\n  canvas.blockImagePointerEvents = _mxClient[\"default\"].IS_FF;\n  var off = this.getSvgScreenOffset();\n  if (off != 0) {\n    this.node.setAttribute('transform', 'translate(' + off + ',' + off + ')');\n  } else {\n    this.node.removeAttribute('transform');\n  }\n  if (!this.antiAlias) {\n    // Rounds all numbers in the SVG output to integers\n    canvas.format = function (value) {\n      return Math.round(parseFloat(value));\n    };\n  }\n  return canvas;\n};\n\n/**\r\n * Function: createVmlCanvas\r\n *\r\n * Creates and returns an <mxVmlCanvas2D> for rendering this shape.\r\n */\nmxShape.prototype.createVmlCanvas = function () {\n  // Workaround for VML rendering bug in IE8 standards mode\n  var node = document.documentMode == 8 && this.isParseVml() ? this.createVmlGroup() : this.node;\n  var canvas = new _mxVmlCanvas2D[\"default\"](node, false);\n  if (node.tagUrn != '') {\n    var w = Math.max(1, Math.round(this.bounds.width));\n    var h = Math.max(1, Math.round(this.bounds.height));\n    node.coordsize = w * this.vmlScale + ',' + h * this.vmlScale;\n    canvas.scale(this.vmlScale);\n    canvas.vmlScale = this.vmlScale;\n  }\n\n  // Painting relative to top, left shape corner\n  var s = this.scale;\n  canvas.translate(-Math.round(this.bounds.x / s), -Math.round(this.bounds.y / s));\n  return canvas;\n};\n\n/**\r\n * Function: updateVmlContainer\r\n *\r\n * Updates the bounds of the VML container.\r\n */\nmxShape.prototype.updateVmlContainer = function () {\n  this.node.style.left = Math.round(this.bounds.x) + 'px';\n  this.node.style.top = Math.round(this.bounds.y) + 'px';\n  var w = Math.max(1, Math.round(this.bounds.width));\n  var h = Math.max(1, Math.round(this.bounds.height));\n  this.node.style.width = w + 'px';\n  this.node.style.height = h + 'px';\n  this.node.style.overflow = 'visible';\n};\n\n/**\r\n * Function: redrawHtml\r\n *\r\n * Allow optimization by replacing VML with HTML.\r\n */\nmxShape.prototype.redrawHtmlShape = function () {\n  // LATER: Refactor methods\n  this.updateHtmlBounds(this.node);\n  this.updateHtmlFilters(this.node);\n  this.updateHtmlColors(this.node);\n};\n\n/**\r\n * Function: updateHtmlFilters\r\n *\r\n * Allow optimization by replacing VML with HTML.\r\n */\nmxShape.prototype.updateHtmlFilters = function (node) {\n  var f = '';\n  if (this.opacity < 100) {\n    f += 'alpha(opacity=' + this.opacity + ')';\n  }\n  if (this.isShadow) {\n    // FIXME: Cannot implement shadow transparency with filter\n    f += 'progid:DXImageTransform.Microsoft.dropShadow (' + 'OffX=\\'' + Math.round(_mxConstants[\"default\"].SHADOW_OFFSET_X * this.scale) + '\\', ' + 'OffY=\\'' + Math.round(_mxConstants[\"default\"].SHADOW_OFFSET_Y * this.scale) + '\\', ' + 'Color=\\'' + _mxConstants[\"default\"].VML_SHADOWCOLOR + '\\')';\n  }\n  if (this.fill != null && this.fill != _mxConstants[\"default\"].NONE && this.gradient && this.gradient != _mxConstants[\"default\"].NONE) {\n    var start = this.fill;\n    var end = this.gradient;\n    var type = '0';\n    var lookup = {\n      east: 0,\n      south: 1,\n      west: 2,\n      north: 3\n    };\n    var dir = this.direction != null ? lookup[this.direction] : 0;\n    if (this.gradientDirection != null) {\n      dir = _mxGraphUtils[\"default\"].mod(dir + lookup[this.gradientDirection] - 1, 4);\n    }\n    if (dir == 1) {\n      type = '1';\n      var tmp = start;\n      start = end;\n      end = tmp;\n    } else if (dir == 2) {\n      var tmp = start;\n      start = end;\n      end = tmp;\n    } else if (dir == 3) {\n      type = '1';\n    }\n    f += 'progid:DXImageTransform.Microsoft.gradient(' + 'startColorStr=\\'' + start + '\\', endColorStr=\\'' + end + '\\', gradientType=\\'' + type + '\\')';\n  }\n  node.style.filter = f;\n};\n\n/**\r\n * Function: mixedModeHtml\r\n *\r\n * Allow optimization by replacing VML with HTML.\r\n */\nmxShape.prototype.updateHtmlColors = function (node) {\n  var color = this.stroke;\n  if (color != null && color != _mxConstants[\"default\"].NONE) {\n    node.style.borderColor = color;\n    if (this.isDashed) {\n      node.style.borderStyle = 'dashed';\n    } else if (this.strokewidth > 0) {\n      node.style.borderStyle = 'solid';\n    }\n    node.style.borderWidth = Math.max(1, Math.ceil(this.strokewidth * this.scale)) + 'px';\n  } else {\n    node.style.borderWidth = '0px';\n  }\n  color = this.outline ? null : this.fill;\n  if (color != null && color != _mxConstants[\"default\"].NONE) {\n    node.style.backgroundColor = color;\n    node.style.backgroundImage = 'none';\n  } else if (this.pointerEvents) {\n    node.style.backgroundColor = 'transparent';\n  } else if (document.documentMode == 8) {\n    _mxGraphUtils[\"default\"].addTransparentBackgroundFilter(node);\n  } else {\n    this.setTransparentBackgroundImage(node);\n  }\n};\n\n/**\r\n * Function: mixedModeHtml\r\n *\r\n * Allow optimization by replacing VML with HTML.\r\n */\nmxShape.prototype.updateHtmlBounds = function (node) {\n  var sw = document.documentMode >= 9 ? 0 : Math.ceil(this.strokewidth * this.scale);\n  node.style.borderWidth = Math.max(1, sw) + 'px';\n  node.style.overflow = 'hidden';\n  node.style.left = Math.round(this.bounds.x - sw / 2) + 'px';\n  node.style.top = Math.round(this.bounds.y - sw / 2) + 'px';\n  if (document.compatMode == 'CSS1Compat') {\n    sw = -sw;\n  }\n  node.style.width = Math.round(Math.max(0, this.bounds.width + sw)) + 'px';\n  node.style.height = Math.round(Math.max(0, this.bounds.height + sw)) + 'px';\n};\n\n/**\r\n * Function: destroyCanvas\r\n *\r\n * Destroys the given canvas which was used for drawing. This implementation\r\n * increments the reference counts on all shared gradients used in the canvas.\r\n */\nmxShape.prototype.destroyCanvas = function (canvas) {\n  // Manages reference counts\n  if (canvas instanceof _mxSvgCanvas2D[\"default\"]) {\n    // Increments ref counts\n    for (var key in canvas.gradients) {\n      var gradient = canvas.gradients[key];\n      if (gradient != null) {\n        gradient.mxRefCount = (gradient.mxRefCount || 0) + 1;\n      }\n    }\n    this.releaseSvgGradients(this.oldGradients);\n    this.oldGradients = canvas.gradients;\n  }\n};\n\n/**\r\n * Function: paint\r\n *\r\n * Generic rendering code.\r\n */\nmxShape.prototype.paint = function (c) {\n  // Scale is passed-through to canvas\n  var s = this.scale;\n  var x = this.bounds.x / s;\n  var y = this.bounds.y / s;\n  var w = this.bounds.width / s;\n  var h = this.bounds.height / s;\n  if (this.isPaintBoundsInverted()) {\n    var t = (w - h) / 2;\n    x += t;\n    y -= t;\n    var tmp = w;\n    w = h;\n    h = tmp;\n  }\n  this.updateTransform(c, x, y, w, h);\n  this.configureCanvas(c, x, y, w, h);\n\n  // Adds background rectangle to capture events\n  var bg = null;\n  if (this.stencil == null && this.points == null && this.shapePointerEvents || this.stencil != null && this.stencilPointerEvents) {\n    var bb = this.createBoundingBox();\n    if (this.dialect == _mxConstants[\"default\"].DIALECT_SVG) {\n      bg = this.createTransparentSvgRectangle(bb.x, bb.y, bb.width, bb.height);\n      this.node.appendChild(bg);\n    } else {\n      var rect = c.createRect('rect', bb.x / s, bb.y / s, bb.width / s, bb.height / s);\n      rect.appendChild(c.createTransparentFill());\n      rect.stroked = 'false';\n      c.root.appendChild(rect);\n    }\n  }\n  if (this.stencil != null) {\n    this.stencil.drawShape(c, this, x, y, w, h);\n  } else {\n    // Stencils have separate strokewidth\n    c.setStrokeWidth(this.strokewidth);\n    if (this.points != null) {\n      // Paints edge shape\n      var pts = [];\n      for (var i = 0; i < this.points.length; i++) {\n        if (this.points[i] != null) {\n          pts.push(new _mxPoint[\"default\"](this.points[i].x / s, this.points[i].y / s));\n        }\n      }\n      this.paintEdgeShape(c, pts);\n    } else {\n      // Paints vertex shape\n      this.paintVertexShape(c, x, y, w, h, this);\n    }\n  }\n  if (bg != null && c.state != null && c.state.transform != null) {\n    bg.setAttribute('transform', c.state.transform);\n  }\n};\n\n/**\r\n * Function: configureCanvas\r\n *\r\n * Sets the state of the canvas for drawing the shape.\r\n */\nmxShape.prototype.configureCanvas = function (c, x, y, w, h) {\n  var dash = null;\n  if (this.style != null) {\n    dash = this.style['dashPattern'];\n  }\n  c.setAlpha(this.opacity / 100);\n  c.setFillAlpha(this.fillOpacity / 100);\n  c.setStrokeAlpha(this.strokeOpacity / 100);\n\n  // Sets alpha, colors and gradients\n  if (this.isShadow != null) {\n    c.setShadow(this.isShadow);\n  }\n\n  // Dash pattern\n  if (this.isDashed != null) {\n    c.setDashed(this.isDashed);\n  }\n  if (dash != null) {\n    c.setDashPattern(dash);\n  }\n  if (this.fill != null && this.fill != _mxConstants[\"default\"].NONE && this.gradient && this.gradient != _mxConstants[\"default\"].NONE) {\n    var b = this.getGradientBounds(c, x, y, w, h);\n    c.setGradient(this.fill, this.gradient, b.x, b.y, b.width, b.height, this.gradientDirection);\n  } else {\n    c.setFillColor(this.fill);\n  }\n  c.setStrokeColor(this.stroke);\n};\n\n/**\r\n * Function: getGradientBounds\r\n *\r\n * Returns the bounding box for the gradient box for this shape.\r\n */\nmxShape.prototype.getGradientBounds = function (c, x, y, w, h) {\n  return new _mxRectangle[\"default\"](x, y, w, h);\n};\n\n/**\r\n * Function: updateTransform\r\n *\r\n * Sets the scale and rotation on the given canvas.\r\n */\nmxShape.prototype.updateTransform = function (c, x, y, w, h) {\n  // NOTE: Currently, scale is implemented in state and canvas. This will\n  // move to canvas in a later version, so that the states are unscaled\n  // and untranslated and do not need an update after zooming or panning.\n  //TODO: Canvas2D对扩展方式图形的处理\n  var desc = this.stencil && this.stencil.desc,\n    isPureSvg = desc && desc.getAttribute(\"type\") === \"svg\";\n  c.scale(this.scale, isPureSvg);\n  c.rotate(this.getShapeRotation(), this.flipH, this.flipV, x + w / 2, y + h / 2, isPureSvg);\n};\n\n/**\r\n * Function: paintVertexShape\r\n *\r\n * Paints the vertex shape.\r\n */\nmxShape.prototype.paintVertexShape = function (c, x, y, w, h) {\n  this.paintBackground(c, x, y, w, h);\n  c.setShadow(false);\n  this.paintForeground(c, x, y, w, h);\n};\n\n/**\r\n * Function: paintBackground\r\n *\r\n * Hook for subclassers. This implementation is empty.\r\n */\nmxShape.prototype.paintBackground = function (c, x, y, w, h) {};\n\n/**\r\n * Function: paintForeground\r\n *\r\n * Hook for subclassers. This implementation is empty.\r\n */\nmxShape.prototype.paintForeground = function (c, x, y, w, h) {};\n\n/**\r\n * Function: paintEdgeShape\r\n *\r\n * Hook for subclassers. This implementation is empty.\r\n */\nmxShape.prototype.paintEdgeShape = function (c, pts) {};\n\n/**\r\n * Function: getArcSize\r\n *\r\n * Returns the arc size for the given dimension.\r\n */\nmxShape.prototype.getArcSize = function (w, h) {\n  var f = _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_ARCSIZE, _mxConstants[\"default\"].RECTANGLE_ROUNDING_FACTOR * 100) / 100;\n  return Math.min(w * f, h * f);\n};\n\n/**\r\n * Function: paintGlassEffect\r\n *\r\n * Paints the glass gradient effect.\r\n */\nmxShape.prototype.paintGlassEffect = function (c, x, y, w, h, arc) {\n  var sw = Math.ceil(this.strokewidth / 2);\n  var size = 0.4;\n  c.setGradient('#ffffff', '#ffffff', x, y, w, h * 0.6, 'south', 0.9, 0.1);\n  c.begin();\n  arc += 2 * sw;\n  if (this.isRounded) {\n    c.moveTo(x - sw + arc, y - sw);\n    c.quadTo(x - sw, y - sw, x - sw, y - sw + arc);\n    c.lineTo(x - sw, y + h * size);\n    c.quadTo(x + w * 0.5, y + h * 0.7, x + w + sw, y + h * size);\n    c.lineTo(x + w + sw, y - sw + arc);\n    c.quadTo(x + w + sw, y - sw, x + w + sw - arc, y - sw);\n  } else {\n    c.moveTo(x - sw, y - sw);\n    c.lineTo(x - sw, y + h * size);\n    c.quadTo(x + w * 0.5, y + h * 0.7, x + w + sw, y + h * size);\n    c.lineTo(x + w + sw, y - sw);\n  }\n  c.close();\n  c.fill();\n};\n\n/**\r\n * Function: addPoints\r\n *\r\n * Paints the given points with rounded corners.\r\n */\nmxShape.prototype.addPoints = function (c, pts, rounded, arcSize, close) {\n  var pe = pts[pts.length - 1];\n\n  // Adds virtual waypoint in the center between start and end point\n  if (close && rounded) {\n    pts = pts.slice();\n    var p0 = pts[0];\n    var wp = new _mxPoint[\"default\"](pe.x + (p0.x - pe.x) / 2, pe.y + (p0.y - pe.y) / 2);\n    pts.splice(0, 0, wp);\n  }\n  var pt = pts[0];\n  var i = 1;\n\n  // Draws the line segments\n  c.moveTo(pt.x, pt.y);\n  while (i < (close ? pts.length : pts.length - 1)) {\n    var tmp = pts[_mxGraphUtils[\"default\"].mod(i, pts.length)];\n    var dx = pt.x - tmp.x;\n    var dy = pt.y - tmp.y;\n    if (rounded && (dx != 0 || dy != 0)) {\n      // Draws a line from the last point to the current\n      // point with a spacing of size off the current point\n      // into direction of the last point\n      var dist = Math.sqrt(dx * dx + dy * dy);\n      var nx1 = dx * Math.min(arcSize, dist / 2) / dist;\n      var ny1 = dy * Math.min(arcSize, dist / 2) / dist;\n      var x1 = tmp.x + nx1;\n      var y1 = tmp.y + ny1;\n      c.lineTo(x1, y1);\n\n      // Draws a curve from the last point to the current\n      // point with a spacing of size off the current point\n      // into direction of the next point\n      var next = pts[_mxGraphUtils[\"default\"].mod(i + 1, pts.length)];\n\n      // Uses next non-overlapping point\n      while (i < pts.length - 2 && Math.round(next.x - tmp.x) == 0 && Math.round(next.y - tmp.y) == 0) {\n        next = pts[_mxGraphUtils[\"default\"].mod(i + 2, pts.length)];\n        i++;\n      }\n      dx = next.x - tmp.x;\n      dy = next.y - tmp.y;\n      dist = Math.max(1, Math.sqrt(dx * dx + dy * dy));\n      var nx2 = dx * Math.min(arcSize, dist / 2) / dist;\n      var ny2 = dy * Math.min(arcSize, dist / 2) / dist;\n      var x2 = tmp.x + nx2;\n      var y2 = tmp.y + ny2;\n      c.quadTo(tmp.x, tmp.y, x2, y2);\n      tmp = new _mxPoint[\"default\"](x2, y2);\n    } else {\n      c.lineTo(tmp.x, tmp.y);\n    }\n    pt = tmp;\n    i++;\n  }\n  if (close) {\n    c.close();\n  } else {\n    c.lineTo(pe.x, pe.y);\n  }\n};\n\n/**\r\n * Function: resetStyles\r\n *\r\n * Resets all styles.\r\n */\nmxShape.prototype.resetStyles = function () {\n  this.initStyles();\n  this.spacing = 0;\n  delete this.fill;\n  delete this.gradient;\n  delete this.gradientDirection;\n  delete this.stroke;\n  delete this.startSize;\n  delete this.endSize;\n  delete this.startArrow;\n  delete this.endArrow;\n  delete this.direction;\n  delete this.isShadow;\n  delete this.isDashed;\n  delete this.isRounded;\n  delete this.glass;\n};\n\n/**\r\n * Function: apply\r\n *\r\n * Applies the style of the given <mxCellState> to the shape. This\r\n * implementation assigns the following styles to local fields:\r\n *\r\n * - <mxConstants.STYLE_FILLCOLOR> => fill\r\n * - <mxConstants.STYLE_GRADIENTCOLOR> => gradient\r\n * - <mxConstants.STYLE_GRADIENT_DIRECTION> => gradientDirection\r\n * - <mxConstants.STYLE_OPACITY> => opacity\r\n * - <mxConstants.STYLE_FILL_OPACITY> => fillOpacity\r\n * - <mxConstants.STYLE_STROKE_OPACITY> => strokeOpacity\r\n * - <mxConstants.STYLE_STROKECOLOR> => stroke\r\n * - <mxConstants.STYLE_STROKEWIDTH> => strokewidth\r\n * - <mxConstants.STYLE_SHADOW> => isShadow\r\n * - <mxConstants.STYLE_DASHED> => isDashed\r\n * - <mxConstants.STYLE_SPACING> => spacing\r\n * - <mxConstants.STYLE_STARTSIZE> => startSize\r\n * - <mxConstants.STYLE_ENDSIZE> => endSize\r\n * - <mxConstants.STYLE_ROUNDED> => isRounded\r\n * - <mxConstants.STYLE_STARTARROW> => startArrow\r\n * - <mxConstants.STYLE_ENDARROW> => endArrow\r\n * - <mxConstants.STYLE_ROTATION> => rotation\r\n * - <mxConstants.STYLE_DIRECTION> => direction\r\n * - <mxConstants.STYLE_GLASS> => glass\r\n *\r\n * This keeps a reference to the <style>. If you need to keep a reference to\r\n * the cell, you can override this method and store a local reference to\r\n * state.cell or the <mxCellState> itself. If <outline> should be true, make\r\n * sure to set it before calling this method.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> of the corresponding cell.\r\n */\nmxShape.prototype.apply = function (state) {\n  this.state = state;\n  this.style = state.style;\n  if (this.style != null) {\n    this.fill = _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_FILLCOLOR, this.fill);\n    this.gradient = _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_GRADIENTCOLOR, this.gradient);\n    this.gradientDirection = _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_GRADIENT_DIRECTION, this.gradientDirection);\n    this.opacity = _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_OPACITY, this.opacity);\n    this.fillOpacity = _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_FILL_OPACITY, this.fillOpacity);\n    this.strokeOpacity = _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_STROKE_OPACITY, this.strokeOpacity);\n    this.stroke = _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_STROKECOLOR, this.stroke);\n    this.strokewidth = _mxGraphUtils[\"default\"].getNumber(this.style, _mxConstants[\"default\"].STYLE_STROKEWIDTH, this.strokewidth);\n    // Arrow stroke width is used to compute the arrow heads size in mxConnector\n    this.arrowStrokewidth = _mxGraphUtils[\"default\"].getNumber(this.style, _mxConstants[\"default\"].STYLE_STROKEWIDTH, this.strokewidth);\n    this.spacing = _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_SPACING, this.spacing);\n    this.startSize = _mxGraphUtils[\"default\"].getNumber(this.style, _mxConstants[\"default\"].STYLE_STARTSIZE, this.startSize);\n    this.endSize = _mxGraphUtils[\"default\"].getNumber(this.style, _mxConstants[\"default\"].STYLE_ENDSIZE, this.endSize);\n    this.startArrow = _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_STARTARROW, this.startArrow);\n    this.endArrow = _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_ENDARROW, this.endArrow);\n    this.rotation = _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_ROTATION, this.rotation);\n    this.direction = _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_DIRECTION, this.direction);\n    this.flipH = _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_FLIPH, 0) == 1;\n    this.flipV = _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_FLIPV, 0) == 1;\n\n    // Legacy support for stencilFlipH/V\n    if (this.stencil != null) {\n      this.flipH = _mxGraphUtils[\"default\"].getValue(this.style, 'stencilFlipH', 0) == 1 || this.flipH;\n      this.flipV = _mxGraphUtils[\"default\"].getValue(this.style, 'stencilFlipV', 0) == 1 || this.flipV;\n    }\n    if (this.direction == _mxConstants[\"default\"].DIRECTION_NORTH || this.direction == _mxConstants[\"default\"].DIRECTION_SOUTH) {\n      var tmp = this.flipH;\n      this.flipH = this.flipV;\n      this.flipV = tmp;\n    }\n    this.isShadow = _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_SHADOW, this.isShadow) == 1;\n    this.isDashed = _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_DASHED, this.isDashed) == 1;\n    this.isRounded = _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_ROUNDED, this.isRounded) == 1;\n    this.glass = _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_GLASS, this.glass) == 1;\n    if (this.fill == _mxConstants[\"default\"].NONE) {\n      this.fill = null;\n    }\n    if (this.gradient == _mxConstants[\"default\"].NONE) {\n      this.gradient = null;\n    }\n    if (this.stroke == _mxConstants[\"default\"].NONE) {\n      this.stroke = null;\n    }\n  }\n};\n\n/**\r\n * Function: setCursor\r\n *\r\n * Sets the cursor on the given shape.\r\n *\r\n * Parameters:\r\n *\r\n * cursor - The cursor to be used.\r\n */\nmxShape.prototype.setCursor = function (cursor) {\n  if (cursor == null) {\n    cursor = '';\n  }\n  this.cursor = cursor;\n  if (this.node != null) {\n    this.node.style.cursor = cursor;\n  }\n};\n\n/**\r\n * Function: getCursor\r\n *\r\n * Returns the current cursor.\r\n */\nmxShape.prototype.getCursor = function () {\n  return this.cursor;\n};\n\n/**\r\n * Function: updateBoundingBox\r\n *\r\n * Updates the <boundingBox> for this shape using <createBoundingBox> and\r\n * <augmentBoundingBox> and stores the result in <boundingBox>.\r\n */\nmxShape.prototype.updateBoundingBox = function () {\n  // Tries to get bounding box from SVG subsystem\n  // LATER: Use getBoundingClientRect for fallback in VML\n  if (this.useSvgBoundingBox && this.node != null && this.node.ownerSVGElement != null) {\n    try {\n      var b = this.node.getBBox();\n      if (b.width > 0 && b.height > 0) {\n        this.boundingBox = new _mxRectangle[\"default\"](b.x, b.y, b.width, b.height);\n\n        // Adds strokeWidth\n        this.boundingBox.grow(this.strokewidth * this.scale / 2);\n        return;\n      }\n    } catch (e) {\n      // fallback to code below\n    }\n  }\n  if (this.bounds != null) {\n    var bbox = this.createBoundingBox();\n    if (bbox != null) {\n      this.augmentBoundingBox(bbox);\n      var rot = this.getShapeRotation();\n      if (rot != 0) {\n        bbox = _mxGraphUtils[\"default\"].getBoundingBox(bbox, rot, null, _mxRectangle[\"default\"], _mxPoint[\"default\"]);\n      }\n    }\n    this.boundingBox = bbox;\n  }\n};\n\n/**\r\n * Function: createBoundingBox\r\n *\r\n * Returns a new rectangle that represents the bounding box of the bare shape\r\n * with no shadows or strokewidths.\r\n */\nmxShape.prototype.createBoundingBox = function () {\n  var bb = this.bounds.clone();\n  if (this.stencil != null && (this.direction == _mxConstants[\"default\"].DIRECTION_NORTH || this.direction == _mxConstants[\"default\"].DIRECTION_SOUTH) || this.isPaintBoundsInverted()) {\n    bb.rotate90();\n  }\n  return bb;\n};\n\n/**\r\n * Function: augmentBoundingBox\r\n *\r\n * Augments the bounding box with the strokewidth and shadow offsets.\r\n */\nmxShape.prototype.augmentBoundingBox = function (bbox) {\n  if (this.isShadow) {\n    bbox.width += Math.ceil(_mxConstants[\"default\"].SHADOW_OFFSET_X * this.scale);\n    bbox.height += Math.ceil(_mxConstants[\"default\"].SHADOW_OFFSET_Y * this.scale);\n  }\n\n  // Adds strokeWidth\n  bbox.grow(this.strokewidth * this.scale / 2);\n};\n\n/**\r\n * Function: isPaintBoundsInverted\r\n *\r\n * Returns true if the bounds should be inverted.\r\n */\nmxShape.prototype.isPaintBoundsInverted = function () {\n  // Stencil implements inversion via aspect\n  return this.stencil == null && (this.direction == _mxConstants[\"default\"].DIRECTION_NORTH || this.direction == _mxConstants[\"default\"].DIRECTION_SOUTH);\n};\n\n/**\r\n * Function: getRotation\r\n *\r\n * Returns the rotation from the style.\r\n */\nmxShape.prototype.getRotation = function () {\n  return this.rotation != null ? this.rotation : 0;\n};\n\n/**\r\n * Function: getTextRotation\r\n *\r\n * Returns the rotation for the text label.\r\n */\nmxShape.prototype.getTextRotation = function () {\n  var rot = this.getRotation();\n  if (_mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_HORIZONTAL, 1) != 1) {\n    rot += -90; //mxText--prototype--verticalTextRotation;\n  }\n  return rot;\n};\n\n/**\r\n * Function: getShapeRotation\r\n *\r\n * Returns the actual rotation of the shape.\r\n */\nmxShape.prototype.getShapeRotation = function () {\n  var rot = this.getRotation();\n  if (this.direction != null) {\n    if (this.direction == _mxConstants[\"default\"].DIRECTION_NORTH) {\n      rot += 270;\n    } else if (this.direction == _mxConstants[\"default\"].DIRECTION_WEST) {\n      rot += 180;\n    } else if (this.direction == _mxConstants[\"default\"].DIRECTION_SOUTH) {\n      rot += 90;\n    }\n  }\n  return rot;\n};\n\n/**\r\n * Function: createTransparentSvgRectangle\r\n *\r\n * Adds a transparent rectangle that catches all events.\r\n */\nmxShape.prototype.createTransparentSvgRectangle = function (x, y, w, h) {\n  var rect = document.createElementNS(_mxConstants[\"default\"].NS_SVG, 'rect');\n  rect.setAttribute('x', x);\n  rect.setAttribute('y', y);\n  rect.setAttribute('width', w);\n  rect.setAttribute('height', h);\n  rect.setAttribute('fill', 'none');\n  rect.setAttribute('stroke', 'none');\n  rect.setAttribute('pointer-events', 'all');\n  return rect;\n};\n\n/**\r\n * Function: setTransparentBackgroundImage\r\n *\r\n * Sets a transparent background CSS style to catch all events.\r\n *\r\n * Paints the line shape.\r\n */\nmxShape.prototype.setTransparentBackgroundImage = function (node) {\n  node.style.backgroundImage = 'url(\\'' + _mxClient[\"default\"].imageBasePath + '/transparent.gif\\')';\n};\n\n/**\r\n * Function: releaseSvgGradients\r\n *\r\n * Paints the line shape.\r\n */\nmxShape.prototype.releaseSvgGradients = function (grads) {\n  if (grads != null) {\n    for (var key in grads) {\n      var gradient = grads[key];\n      if (gradient != null) {\n        gradient.mxRefCount = (gradient.mxRefCount || 0) - 1;\n        if (gradient.mxRefCount == 0 && gradient.parentNode != null) {\n          gradient.parentNode.removeChild(gradient);\n        }\n      }\n    }\n  }\n};\n\n/**\r\n * Function: destroy\r\n *\r\n * Destroys the shape by removing it from the DOM and releasing the DOM\r\n * node associated with the shape using <mxEventUtils.release>.\r\n */\nmxShape.prototype.destroy = function () {\n  if (this.node != null) {\n    _mxEventUtils[\"default\"].release(this.node);\n    if (this.node.parentNode != null) {\n      this.node.parentNode.removeChild(this.node);\n    }\n    this.node = null;\n  }\n\n  // Decrements refCount and removes unused\n  this.releaseSvgGradients(this.oldGradients);\n  this.oldGradients = null;\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n *\r\n * Code to add stencils.\r\n *\r\n * (code)\r\n * var req = mxRequestUtils.load('test/stencils.xml');\r\n * var root = req.getDocumentElement();\r\n * var shape = root.firstChild;\r\n *\r\n * while (shape != null)\r\n * {\r\n * \t if (shape.nodeType == mxConstants.NODETYPE_ELEMENT)\r\n *   {\r\n *     mxStencilRegistry.addStencil(shape.getAttribute('name'), new mxStencil(shape));\r\n *   }\r\n *\r\n *   shape = shape.nextSibling;\r\n * }\r\n * (end)\r\n */\nvar _default = exports[\"default\"] = mxShape;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxShape.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxStackLayout.js":
/*!************************************************!*\
  !*** ./src/workflow/mxClient/mxStackLayout.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.fill.js */ \"../../node_modules/core-js/modules/es.array.fill.js\");\nvar _mxGraphLayout = _interopRequireDefault(__webpack_require__(/*! ./mxGraphLayout.js */ \"./src/workflow/mxClient/mxGraphLayout.js\"));\nvar _mxRectangle = _interopRequireDefault(__webpack_require__(/*! ./mxRectangle.js */ \"./src/workflow/mxClient/mxRectangle.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ./mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxStackLayout(graph, horizontal, spacing, x0, y0, border) {\n  _mxGraphLayout[\"default\"].call(this, graph);\n  this.horizontal = horizontal != null ? horizontal : true;\n  this.spacing = spacing != null ? spacing : 0;\n  this.x0 = x0 != null ? x0 : 0;\n  this.y0 = y0 != null ? y0 : 0;\n  this.border = border != null ? border : 0;\n}\n;\n\n/**\r\n * Extends mxGraphLayout.\r\n */\nmxStackLayout.prototype = new _mxGraphLayout[\"default\"]();\nmxStackLayout.prototype.constructor = mxStackLayout;\n\n/**\r\n * Variable: horizontal\r\n *\r\n * Specifies the orientation of the layout. Default is true.\r\n */\nmxStackLayout.prototype.horizontal = null;\n\n/**\r\n * Variable: spacing\r\n *\r\n * Specifies the spacing between the cells. Default is 0.\r\n */\nmxStackLayout.prototype.spacing = null;\n\n/**\r\n * Variable: x0\r\n *\r\n * Specifies the horizontal origin of the layout. Default is 0.\r\n */\nmxStackLayout.prototype.x0 = null;\n\n/**\r\n * Variable: y0\r\n *\r\n * Specifies the vertical origin of the layout. Default is 0.\r\n */\nmxStackLayout.prototype.y0 = null;\n\n/**\r\n * Variable: border\r\n *\r\n * Border to be added if fill is true. Default is 0.\r\n */\nmxStackLayout.prototype.border = 0;\n\n/**\r\n * Variable: marginTop\r\n *\r\n * Top margin for the child area. Default is 0.\r\n */\nmxStackLayout.prototype.marginTop = 0;\n\n/**\r\n * Variable: marginLeft\r\n *\r\n * Top margin for the child area. Default is 0.\r\n */\nmxStackLayout.prototype.marginLeft = 0;\n\n/**\r\n * Variable: marginRight\r\n *\r\n * Top margin for the child area. Default is 0.\r\n */\nmxStackLayout.prototype.marginRight = 0;\n\n/**\r\n * Variable: marginBottom\r\n *\r\n * Top margin for the child area. Default is 0.\r\n */\nmxStackLayout.prototype.marginBottom = 0;\n\n/**\r\n * Variable: keepFirstLocation\r\n *\r\n * Boolean indicating if the location of the first cell should be\r\n * kept, that is, it will not be moved to x0 or y0.\r\n */\nmxStackLayout.prototype.keepFirstLocation = false;\n\n/**\r\n * Variable: fill\r\n *\r\n * Boolean indicating if dimension should be changed to fill out the parent\r\n * cell. Default is false.\r\n */\nmxStackLayout.prototype.fill = false;\n\n/**\r\n * Variable: resizeParent\r\n *\r\n * If the parent should be resized to match the width/height of the\r\n * stack. Default is false.\r\n */\nmxStackLayout.prototype.resizeParent = false;\n\n/**\r\n * Variable: resizeParentMax\r\n *\r\n * Use maximum of existing value and new value for resize of parent.\r\n * Default is false.\r\n */\nmxStackLayout.prototype.resizeParentMax = false;\n\n/**\r\n * Variable: resizeLast\r\n *\r\n * If the last element should be resized to fill out the parent. Default is\r\n * false. If <resizeParent> is true then this is ignored.\r\n */\nmxStackLayout.prototype.resizeLast = false;\n\n/**\r\n * Variable: wrap\r\n *\r\n * Value at which a new column or row should be created. Default is null.\r\n */\nmxStackLayout.prototype.wrap = null;\n\n/**\r\n * Variable: borderCollapse\r\n *\r\n * If the strokeWidth should be ignored. Default is true.\r\n */\nmxStackLayout.prototype.borderCollapse = true;\n\n/**\r\n * Function: isHorizontal\r\n *\r\n * Returns <horizontal>.\r\n */\nmxStackLayout.prototype.isHorizontal = function () {\n  return this.horizontal;\n};\n\n/**\r\n * Function: moveCell\r\n *\r\n * Implements <mxGraphLayout.moveCell>.\r\n */\nmxStackLayout.prototype.moveCell = function (cell, x, y) {\n  var model = this.graph.getModel();\n  var parent = model.getParent(cell);\n  var horizontal = this.isHorizontal();\n  if (cell != null && parent != null) {\n    var i = 0;\n    var last = 0;\n    var childCount = model.getChildCount(parent);\n    var value = horizontal ? x : y;\n    var pstate = this.graph.getView().getState(parent);\n    if (pstate != null) {\n      value -= horizontal ? pstate.x : pstate.y;\n    }\n    value /= this.graph.view.scale;\n    for (i = 0; i < childCount; i++) {\n      var child = model.getChildAt(parent, i);\n      if (child != cell) {\n        var bounds = model.getGeometry(child);\n        if (bounds != null) {\n          var tmp = horizontal ? bounds.x + bounds.width / 2 : bounds.y + bounds.height / 2;\n          if (last <= value && tmp > value) {\n            break;\n          }\n          last = tmp;\n        }\n      }\n    }\n\n    // Changes child order in parent\n    var idx = parent.getIndex(cell);\n    idx = Math.max(0, i - (i > idx ? 1 : 0));\n    model.add(parent, cell, idx);\n  }\n};\n\n/**\r\n * Function: getParentSize\r\n *\r\n * Returns the size for the parent container or the size of the graph\r\n * container if the parent is a layer or the root of the model.\r\n */\nmxStackLayout.prototype.getParentSize = function (parent) {\n  var model = this.graph.getModel();\n  var pgeo = model.getGeometry(parent);\n\n  // Handles special case where the parent is either a layer with no\n  // geometry or the current root of the view in which case the size\n  // of the graph's container will be used.\n  if (this.graph.container != null && (pgeo == null && model.isLayer(parent) || parent == this.graph.getView().currentRoot)) {\n    var width = this.graph.container.offsetWidth - 1;\n    var height = this.graph.container.offsetHeight - 1;\n    pgeo = new _mxRectangle[\"default\"](0, 0, width, height);\n  }\n  return pgeo;\n};\n\n/**\r\n * Function: execute\r\n *\r\n * Implements <mxGraphLayout.execute>.\r\n *\r\n * Only children where <isVertexIgnored> returns false are taken into\r\n * account.\r\n */\nmxStackLayout.prototype.execute = function (parent) {\n  if (parent != null) {\n    var pgeo = this.getParentSize(parent);\n    var horizontal = this.isHorizontal();\n    var model = this.graph.getModel();\n    var fillValue = null;\n    if (pgeo != null) {\n      fillValue = horizontal ? pgeo.height - this.marginTop - this.marginBottom : pgeo.width - this.marginLeft - this.marginRight;\n    }\n    fillValue -= 2 * this.spacing + 2 * this.border;\n    var x0 = this.x0 + this.border + this.marginLeft;\n    var y0 = this.y0 + this.border + this.marginTop;\n\n    // Handles swimlane start size\n    if (this.graph.isSwimlane(parent)) {\n      // Uses computed style to get latest\n      var style = this.graph.getCellStyle(parent);\n      var start = _mxGraphUtils[\"default\"].getNumber(style, _mxConstants[\"default\"].STYLE_STARTSIZE, _mxConstants[\"default\"].DEFAULT_STARTSIZE);\n      var horz = _mxGraphUtils[\"default\"].getValue(style, _mxConstants[\"default\"].STYLE_HORIZONTAL, true) == 1;\n      if (pgeo != null) {\n        if (horz) {\n          start = Math.min(start, pgeo.height);\n        } else {\n          start = Math.min(start, pgeo.width);\n        }\n      }\n      if (horizontal == horz) {\n        fillValue -= start;\n      }\n      if (horz) {\n        y0 += start;\n      } else {\n        x0 += start;\n      }\n    }\n    model.beginUpdate();\n    try {\n      var tmp = 0;\n      var last = null;\n      var lastValue = 0;\n      var lastChild = null;\n      var childCount = model.getChildCount(parent);\n      for (var i = 0; i < childCount; i++) {\n        var child = model.getChildAt(parent, i);\n        if (!this.isVertexIgnored(child) && this.isVertexMovable(child)) {\n          var geo = model.getGeometry(child);\n          if (geo != null) {\n            geo = geo.clone();\n            if (this.wrap != null && last != null) {\n              if (horizontal && last.x + last.width + geo.width + 2 * this.spacing > this.wrap || !horizontal && last.y + last.height + geo.height + 2 * this.spacing > this.wrap) {\n                last = null;\n                if (horizontal) {\n                  y0 += tmp + this.spacing;\n                } else {\n                  x0 += tmp + this.spacing;\n                }\n                tmp = 0;\n              }\n            }\n            tmp = Math.max(tmp, horizontal ? geo.height : geo.width);\n            var sw = 0;\n            if (!this.borderCollapse) {\n              var childStyle = this.graph.getCellStyle(child);\n              sw = _mxGraphUtils[\"default\"].getNumber(childStyle, _mxConstants[\"default\"].STYLE_STROKEWIDTH, 1);\n            }\n            if (last != null) {\n              if (horizontal) {\n                geo.x = lastValue + this.spacing + Math.floor(sw / 2);\n              } else {\n                geo.y = lastValue + this.spacing + Math.floor(sw / 2);\n              }\n            } else if (!this.keepFirstLocation) {\n              if (horizontal) {\n                geo.x = x0;\n              } else {\n                geo.y = y0;\n              }\n            }\n            if (horizontal) {\n              geo.y = y0;\n            } else {\n              geo.x = x0;\n            }\n            if (this.fill && fillValue != null) {\n              if (horizontal) {\n                geo.height = fillValue;\n              } else {\n                geo.width = fillValue;\n              }\n            }\n            this.setChildGeometry(child, geo);\n            lastChild = child;\n            last = geo;\n            if (horizontal) {\n              lastValue = last.x + last.width + Math.floor(sw / 2);\n            } else {\n              lastValue = last.y + last.height + Math.floor(sw / 2);\n            }\n          }\n        }\n      }\n      if (this.resizeParent && pgeo != null && last != null && !this.graph.isCellCollapsed(parent)) {\n        this.updateParentGeometry(parent, pgeo, last);\n      } else if (this.resizeLast && pgeo != null && last != null && lastChild != null) {\n        if (horizontal) {\n          last.width = pgeo.width - last.x - this.spacing - this.marginRight - this.marginLeft;\n        } else {\n          last.height = pgeo.height - last.y - this.spacing - this.marginBottom;\n        }\n        this.setChildGeometry(lastChild, last);\n      }\n    } finally {\n      model.endUpdate();\n    }\n  }\n};\n\n/**\r\n * Function: execute\r\n *\r\n * Implements <mxGraphLayout.execute>.\r\n *\r\n * Only children where <isVertexIgnored> returns false are taken into\r\n * account.\r\n */\nmxStackLayout.prototype.setChildGeometry = function (child, geo) {\n  var geo2 = this.graph.getCellGeometry(child);\n  if (geo2 == null || geo.x != geo2.x || geo.y != geo2.y || geo.width != geo2.width || geo.height != geo2.height) {\n    this.graph.getModel().setGeometry(child, geo);\n  }\n};\n\n/**\r\n * Function: execute\r\n *\r\n * Implements <mxGraphLayout.execute>.\r\n *\r\n * Only children where <isVertexIgnored> returns false are taken into\r\n * account.\r\n */\nmxStackLayout.prototype.updateParentGeometry = function (parent, pgeo, last) {\n  var horizontal = this.isHorizontal();\n  var model = this.graph.getModel();\n  var pgeo2 = pgeo.clone();\n  if (horizontal) {\n    var tmp = last.x + last.width + this.spacing + this.marginRight;\n    if (this.resizeParentMax) {\n      pgeo2.width = Math.max(pgeo2.width, tmp);\n    } else {\n      pgeo2.width = tmp;\n    }\n  } else {\n    var tmp = last.y + last.height + this.spacing + this.marginBottom;\n    if (this.resizeParentMax) {\n      pgeo2.height = Math.max(pgeo2.height, tmp);\n    } else {\n      pgeo2.height = tmp;\n    }\n  }\n  if (pgeo.x != pgeo2.x || pgeo.y != pgeo2.y || pgeo.width != pgeo2.width || pgeo.height != pgeo2.height) {\n    model.setGeometry(parent, pgeo2);\n  }\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxPartitionLayout\r\n *\r\n * Extends <mxGraphLayout> for partitioning the parent cell vertically or\r\n * horizontally by filling the complete area with the child cells. A horizontal\r\n * layout partitions the height of the given parent whereas a a non-horizontal\r\n * layout partitions the width. If the parent is a layer (that is, a child of\r\n * the root node), then the current graph size is partitioned. The children do\r\n * not need to be connected for this layout to work.\r\n *\r\n * Example:\r\n *\r\n * (code)\r\n * var layout = new mxPartitionLayout(graph, true, 10, 20);\r\n * layout.execute(graph.getDefaultParent());\r\n * (end)\r\n *\r\n * Constructor: mxPartitionLayout\r\n *\r\n * Constructs a new stack layout layout for the specified graph,\r\n * spacing, orientation and offset.\r\n */\nvar _default = exports[\"default\"] = mxStackLayout;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxStackLayout.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxStencil.js":
/*!********************************************!*\
  !*** ./src/workflow/mxClient/mxStencil.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.fill.js */ \"../../node_modules/core-js/modules/es.array.fill.js\");\n__webpack_require__(/*! core-js/modules/es.array.join.js */ \"../../node_modules/core-js/modules/es.array.join.js\");\n__webpack_require__(/*! core-js/modules/es.number.constructor.js */ \"../../node_modules/core-js/modules/es.number.constructor.js\");\nvar _mxPoint = _interopRequireDefault(__webpack_require__(/*! ./mxPoint.js */ \"./src/workflow/mxClient/mxPoint.js\"));\nvar _mxResources = _interopRequireDefault(__webpack_require__(/*! ./mxResources.js */ \"./src/workflow/mxClient/mxResources.js\"));\nvar _mxRectangle = _interopRequireDefault(__webpack_require__(/*! ./mxRectangle.js */ \"./src/workflow/mxClient/mxRectangle.js\"));\nvar _mxStencilRegistry = _interopRequireDefault(__webpack_require__(/*! ./mxStencilRegistry.js */ \"./src/workflow/mxClient/mxStencilRegistry.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ./mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxConnectionConstraint = _interopRequireDefault(__webpack_require__(/*! ./mxConnectionConstraint.js */ \"./src/workflow/mxClient/mxConnectionConstraint.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxStencil(desc) {\n  this.desc = desc;\n  this.parseDescription();\n  this.parseConstraints();\n}\n;\n\n/**\r\n * Variable: defaultLocalized\r\n *\r\n * Static global variable that specifies the default value for the localized\r\n * attribute of the text element. Default is false.\r\n */\nmxStencil.defaultLocalized = false;\n\n/**\r\n * Function: allowEval\r\n *\r\n * Static global switch that specifies if the use of eval is allowed for\r\n * evaluating text content and images. Default is false. Set this to true\r\n * if stencils can not contain user input.\r\n */\nmxStencil.allowEval = false;\n\n/**\r\n * Variable: desc\r\n *\r\n * Holds the XML node with the stencil description.\r\n */\nmxStencil.prototype.desc = null;\n\n/**\r\n * Variable: constraints\r\n *\r\n * Holds an array of <mxConnectionConstraints> as defined in the shape.\r\n */\nmxStencil.prototype.constraints = null;\n\n/**\r\n * Variable: aspect\r\n *\r\n * Holds the aspect of the shape. Default is 'auto'.\r\n */\nmxStencil.prototype.aspect = null;\n\n/**\r\n * Variable: w0\r\n *\r\n * Holds the width of the shape. Default is 100.\r\n */\nmxStencil.prototype.w0 = null;\n\n/**\r\n * Variable: h0\r\n *\r\n * Holds the height of the shape. Default is 100.\r\n */\nmxStencil.prototype.h0 = null;\n\n/**\r\n * Variable: bgNodes\r\n *\r\n * Holds the XML node with the stencil description.\r\n */\nmxStencil.prototype.bgNode = null;\n\n/**\r\n * Variable: fgNodes\r\n *\r\n * Holds the XML node with the stencil description.\r\n */\nmxStencil.prototype.fgNode = null;\n\n/**\r\n * Variable: strokewidth\r\n *\r\n * Holds the strokewidth direction from the description.\r\n */\nmxStencil.prototype.strokewidth = null;\n\n/**\r\n * Function: parseDescription\r\n *\r\n * Reads <w0>, <h0>, <aspect>, <bgNodes> and <fgNodes> from <desc>.\r\n */\nmxStencil.prototype.parseDescription = function () {\n  // LATER: Preprocess nodes for faster painting\n  this.fgNode = this.desc.getElementsByTagName('foreground')[0];\n  this.bgNode = this.desc.getElementsByTagName('background')[0];\n  this.w0 = Number(this.desc.getAttribute('w') || 100);\n  this.h0 = Number(this.desc.getAttribute('h') || 100);\n\n  // Possible values for aspect are: variable and fixed where\n  // variable means fill the available space and fixed means\n  // use w0 and h0 to compute the aspect.\n  var aspect = this.desc.getAttribute('aspect');\n  this.aspect = aspect != null ? aspect : 'variable';\n\n  // Possible values for strokewidth are all numbers and \"inherit\"\n  // where the inherit means take the value from the style (ie. the\n  // user-defined stroke-width). Note that the strokewidth is scaled\n  // by the minimum scaling that is used to draw the shape (sx, sy).\n  var sw = this.desc.getAttribute('strokewidth');\n  this.strokewidth = sw != null ? sw : '1';\n};\n\n/**\r\n * Function: parseConstraints\r\n *\r\n * Reads the constraints from <desc> into <constraints> using\r\n * <parseConstraint>.\r\n */\nmxStencil.prototype.parseConstraints = function () {\n  var conns = this.desc.getElementsByTagName('connections')[0];\n  if (conns != null) {\n    var tmp = _mxGraphUtils[\"default\"].getChildNodes(conns);\n    if (tmp != null && tmp.length > 0) {\n      this.constraints = [];\n      for (var i = 0; i < tmp.length; i++) {\n        this.constraints.push(this.parseConstraint(tmp[i]));\n      }\n    }\n  }\n};\n\n/**\r\n * Function: parseConstraint\r\n *\r\n * Parses the given XML node and returns its <mxConnectionConstraint>.\r\n */\nmxStencil.prototype.parseConstraint = function (node) {\n  var x = Number(node.getAttribute('x'));\n  var y = Number(node.getAttribute('y'));\n  var perimeter = node.getAttribute('perimeter') == '1';\n  return new _mxConnectionConstraint[\"default\"](new _mxPoint[\"default\"](x, y), perimeter);\n};\n\n/**\r\n * Function: evaluateTextAttribute\r\n *\r\n * Gets the given attribute as a text. The return value from <evaluateAttribute>\r\n * is used as a key to <mxResources.get> if the localized attribute in the text\r\n * node is 1 or if <defaultLocalized> is true.\r\n */\nmxStencil.prototype.evaluateTextAttribute = function (node, attribute, shape) {\n  var result = this.evaluateAttribute(node, attribute, shape);\n  var loc = node.getAttribute('localized');\n  if (mxStencil.defaultLocalized && loc == null || loc == '1') {\n    result = _mxResources[\"default\"].get(result);\n  }\n  return result;\n};\n\n/**\r\n * Function: evaluateAttribute\r\n *\r\n * Gets the attribute for the given name from the given node. If the attribute\r\n * does not exist then the text content of the node is evaluated and if it is\r\n * a function it is invoked with <shape> as the only argument and the return\r\n * value is used as the attribute value to be returned.\r\n */\nmxStencil.prototype.evaluateAttribute = function (node, attribute, shape) {\n  var result = node.getAttribute(attribute);\n  if (result == null) {\n    var text = _mxGraphUtils[\"default\"].getTextContent(node);\n    if (text != null && mxStencil.allowEval) {\n      var funct = _mxGraphUtils[\"default\"].eval(text);\n      if (typeof funct == 'function') {\n        result = funct(shape);\n      }\n    }\n  }\n  return result;\n};\n\n/**\r\n * Function: drawShape\r\n *\r\n * Draws this stencil inside the given bounds.\r\n */\nmxStencil.prototype.drawShape = function (canvas, shape, x, y, w, h) {\n  // TODO: Internal structure (array of special structs?), relative and absolute\n  // coordinates (eg. note shape, process vs star, actor etc.), text rendering\n  // and non-proportional scaling, how to implement pluggable edge shapes\n  // (start, segment, end blocks), pluggable markers, how to implement\n  // swimlanes (title area) with this API, add icon, horizontal/vertical\n  // label, indicator for all shapes, rotation\n  var direction = _mxGraphUtils[\"default\"].getValue(shape.style, _mxConstants[\"default\"].STYLE_DIRECTION, null);\n  var aspect = this.computeAspect(shape.style, x, y, w, h, direction);\n  var minScale = Math.min(aspect.width, aspect.height);\n  var sw = this.strokewidth == 'inherit' ? Number(_mxGraphUtils[\"default\"].getNumber(shape.style, _mxConstants[\"default\"].STYLE_STROKEWIDTH, 1)) : Number(this.strokewidth) * minScale;\n  canvas.setStrokeWidth(sw);\n  this.drawChildren(canvas, shape, x, y, w, h, this.bgNode, aspect, false);\n  this.drawChildren(canvas, shape, x, y, w, h, this.fgNode, aspect, true);\n};\n\n/**\r\n * Function: drawChildren\r\n *\r\n * Draws this stencil inside the given bounds.\r\n */\nmxStencil.prototype.drawChildren = function (canvas, shape, x, y, w, h, node, aspect, disableShadow) {\n  if (node != null && w > 0 && h > 0) {\n    var tmp = node.firstChild;\n    while (tmp != null) {\n      if (tmp.nodeType == _mxConstants[\"default\"].NODETYPE_ELEMENT) {\n        this.drawNode(canvas, shape, tmp, aspect, disableShadow);\n      }\n      tmp = tmp.nextSibling;\n    }\n  }\n};\n\n/**\r\n * Function: computeAspect\r\n *\r\n * Returns a rectangle that contains the offset in x and y and the horizontal\r\n * and vertical scale in width and height used to draw this shape inside the\r\n * given <mxRectangle>.\r\n *\r\n * Parameters:\r\n *\r\n * shape - <mxShape> to be drawn.\r\n * bounds - <mxRectangle> that should contain the stencil.\r\n * direction - Optional direction of the shape to be darwn.\r\n */\nmxStencil.prototype.computeAspect = function (shape, x, y, w, h, direction) {\n  var x0 = x;\n  var y0 = y;\n  var sx = w / this.w0;\n  var sy = h / this.h0;\n  var inverse = direction == _mxConstants[\"default\"].DIRECTION_NORTH || direction == _mxConstants[\"default\"].DIRECTION_SOUTH;\n  if (inverse) {\n    sy = w / this.h0;\n    sx = h / this.w0;\n    var delta = (w - h) / 2;\n    x0 += delta;\n    y0 -= delta;\n  }\n  if (this.aspect == 'fixed') {\n    sy = Math.min(sx, sy);\n    sx = sy;\n\n    // Centers the shape inside the available space\n    if (inverse) {\n      x0 += (h - this.w0 * sx) / 2;\n      y0 += (w - this.h0 * sy) / 2;\n    } else {\n      x0 += (w - this.w0 * sx) / 2;\n      y0 += (h - this.h0 * sy) / 2;\n    }\n  }\n  return new _mxRectangle[\"default\"](x0, y0, sx, sy);\n};\n\n/**\r\n * Function: drawNode\r\n *\r\n * Draws this stencil inside the given bounds.\r\n */\nmxStencil.prototype.drawNode = function (canvas, shape, node, aspect, disableShadow) {\n  var name = node.nodeName;\n  var x0 = aspect.x;\n  var y0 = aspect.y;\n  var sx = aspect.width;\n  var sy = aspect.height;\n  var minScale = Math.min(sx, sy);\n  if (name == 'save') {\n    canvas.save();\n  } else if (name == 'restore') {\n    canvas.restore();\n  } else if (name == 'path') {\n    canvas.begin();\n\n    // Renders the elements inside the given path\n    var childNode = node.firstChild;\n    while (childNode != null) {\n      if (childNode.nodeType == _mxConstants[\"default\"].NODETYPE_ELEMENT) {\n        this.drawNode(canvas, shape, childNode, aspect, disableShadow);\n      }\n      childNode = childNode.nextSibling;\n    }\n  } else if (name == 'close') {\n    canvas.close();\n  } else if (name == 'move') {\n    canvas.moveTo(x0 + Number(node.getAttribute('x')) * sx, y0 + Number(node.getAttribute('y')) * sy);\n  } else if (name == 'line') {\n    canvas.lineTo(x0 + Number(node.getAttribute('x')) * sx, y0 + Number(node.getAttribute('y')) * sy);\n  } else if (name == 'quad') {\n    canvas.quadTo(x0 + Number(node.getAttribute('x1')) * sx, y0 + Number(node.getAttribute('y1')) * sy, x0 + Number(node.getAttribute('x2')) * sx, y0 + Number(node.getAttribute('y2')) * sy);\n  } else if (name == 'curve') {\n    canvas.curveTo(x0 + Number(node.getAttribute('x1')) * sx, y0 + Number(node.getAttribute('y1')) * sy, x0 + Number(node.getAttribute('x2')) * sx, y0 + Number(node.getAttribute('y2')) * sy, x0 + Number(node.getAttribute('x3')) * sx, y0 + Number(node.getAttribute('y3')) * sy);\n  } else if (name == 'arc') {\n    canvas.arcTo(Number(node.getAttribute('rx')) * sx, Number(node.getAttribute('ry')) * sy, Number(node.getAttribute('x-axis-rotation')), Number(node.getAttribute('large-arc-flag')), Number(node.getAttribute('sweep-flag')), x0 + Number(node.getAttribute('x')) * sx, y0 + Number(node.getAttribute('y')) * sy);\n  } else if (name == 'rect') {\n    canvas.rect(x0 + Number(node.getAttribute('x')) * sx, y0 + Number(node.getAttribute('y')) * sy, Number(node.getAttribute('w')) * sx, Number(node.getAttribute('h')) * sy, Number(node.getAttribute('rx')) * sx, Number(node.getAttribute('ry')) * sy);\n  } else if (name == 'roundrect') {\n    var arcsize = Number(node.getAttribute('arcsize'));\n    if (arcsize == 0) {\n      arcsize = _mxConstants[\"default\"].RECTANGLE_ROUNDING_FACTOR * 100;\n    }\n    var w = Number(node.getAttribute('w')) * sx;\n    var h = Number(node.getAttribute('h')) * sy;\n    var factor = Number(arcsize) / 100;\n    var r = Math.min(w * factor, h * factor);\n    canvas.roundrect(x0 + Number(node.getAttribute('x')) * sx, y0 + Number(node.getAttribute('y')) * sy, w, h, r, r);\n  } else if (name == 'ellipse') {\n    canvas.ellipse(x0 + Number(node.getAttribute('x')) * sx, y0 + Number(node.getAttribute('y')) * sy, Number(node.getAttribute('w')) * sx, Number(node.getAttribute('h')) * sy);\n  } else if (name == 'image') {\n    if (!shape.outline) {\n      var src = this.evaluateAttribute(node, 'src', shape);\n      canvas.image(x0 + Number(node.getAttribute('x')) * sx, y0 + Number(node.getAttribute('y')) * sy, Number(node.getAttribute('w')) * sx, Number(node.getAttribute('h')) * sy, src, false, node.getAttribute('flipH') == '1', node.getAttribute('flipV') == '1');\n    }\n  } else if (name == 'text') {\n    if (!shape.outline) {\n      var str = this.evaluateTextAttribute(node, 'str', shape);\n      var rotation = node.getAttribute('vertical') == '1' ? -90 : 0;\n      if (node.getAttribute('align-shape') == '0') {\n        var dr = shape.rotation;\n\n        // Depends on flipping\n        var flipH = _mxGraphUtils[\"default\"].getValue(shape.style, _mxConstants[\"default\"].STYLE_FLIPH, 0) == 1;\n        var flipV = _mxGraphUtils[\"default\"].getValue(shape.style, _mxConstants[\"default\"].STYLE_FLIPV, 0) == 1;\n        if (flipH && flipV) {\n          rotation -= dr;\n        } else if (flipH || flipV) {\n          rotation += dr;\n        } else {\n          rotation -= dr;\n        }\n      }\n      rotation -= node.getAttribute('rotation');\n      canvas.text(x0 + Number(node.getAttribute('x')) * sx, y0 + Number(node.getAttribute('y')) * sy, 0, 0, str, node.getAttribute('align') || 'left', node.getAttribute('valign') || 'top', false, '', null, false, rotation);\n    }\n  } else if (name == 'include-shape') {\n    var stencil = _mxStencilRegistry[\"default\"].getStencil(node.getAttribute('name'));\n    if (stencil != null) {\n      var x = x0 + Number(node.getAttribute('x')) * sx;\n      var y = y0 + Number(node.getAttribute('y')) * sy;\n      var w = Number(node.getAttribute('w')) * sx;\n      var h = Number(node.getAttribute('h')) * sy;\n      stencil.drawShape(canvas, shape, x, y, w, h);\n    }\n  } else if (name == 'fillstroke') {\n    canvas.fillAndStroke();\n  } else if (name == 'fill') {\n    canvas.fill();\n  } else if (name == 'stroke') {\n    canvas.stroke();\n  } else if (name == 'strokewidth') {\n    var s = node.getAttribute('fixed') == '1' ? 1 : minScale;\n    canvas.setStrokeWidth(Number(node.getAttribute('width')) * s);\n  } else if (name == 'dashed') {\n    canvas.setDashed(node.getAttribute('dashed') == '1');\n  } else if (name == 'dashpattern') {\n    var value = node.getAttribute('pattern');\n    if (value != null) {\n      var tmp = value.split(' ');\n      var pat = [];\n      for (var i = 0; i < tmp.length; i++) {\n        if (tmp[i].length > 0) {\n          pat.push(Number(tmp[i]) * minScale);\n        }\n      }\n      value = pat.join(' ');\n      canvas.setDashPattern(value);\n    }\n  } else if (name == 'strokecolor') {\n    var impVal = shape.style[\"strokeColor_important\"];\n    canvas.setStrokeColor(impVal ? impVal : node.getAttribute('color'));\n  } else if (name == 'linecap') {\n    canvas.setLineCap(node.getAttribute('cap'));\n  } else if (name == 'linejoin') {\n    canvas.setLineJoin(node.getAttribute('join'));\n  } else if (name == 'miterlimit') {\n    canvas.setMiterLimit(Number(node.getAttribute('limit')));\n  } else if (name == 'fillcolor') {\n    canvas.setFillColor(node.getAttribute('color'));\n  } else if (name == 'alpha') {\n    canvas.setAlpha(node.getAttribute('alpha'));\n  } else if (name == 'fontcolor') {\n    canvas.setFontColor(node.getAttribute('color'));\n  } else if (name == 'fontstyle') {\n    canvas.setFontStyle(node.getAttribute('style'));\n  } else if (name == 'fontfamily') {\n    canvas.setFontFamily(node.getAttribute('family'));\n  } else if (name == 'fontsize') {\n    canvas.setFontSize(Number(node.getAttribute('size')) * minScale);\n  } else if (name === 'transform') {\n    canvas.setTransform(node.getAttribute('value'));\n  }\n  if (disableShadow && (name == 'fillstroke' || name == 'fill' || name == 'stroke')) {\n    disableShadow = false;\n    canvas.setShadow(false);\n  }\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxShape\r\n *\r\n * Base class for all shapes. A shape in mxGraph is a\r\n * separate implementation for SVG, VML and HTML. Which\r\n * implementation to use is controlled by the <dialect>\r\n * property which is assigned from within the <mxCellRenderer>\r\n * when the shape is created. The dialect must be assigned\r\n * for a shape, and it does normally depend on the browser and\r\n * the confiuration of the graph (see <mxGraph> rendering hint).\r\n *\r\n * For each supported shape in SVG and VML, a corresponding\r\n * shape exists in mxGraph, namely for text, image, rectangle,\r\n * rhombus, ellipse and polyline. The other shapes are a\r\n * combination of these shapes (eg. label and swimlane)\r\n * or they consist of one or more (filled) path objects\r\n * (eg. actor and cylinder). The HTML implementation is\r\n * optional but may be required for a HTML-only view of\r\n * the graph.\r\n *\r\n * Custom Shapes:\r\n *\r\n * To extend from this class, the basic code looks as follows.\r\n * In the special case where the custom shape consists only of\r\n * one filled region or one filled region and an additional stroke\r\n * the <mxActor> and <mxCylinder> should be subclassed,\r\n * respectively.\r\n *\r\n * (code)\r\n * function CustomShape() { }\r\n *\r\n * CustomShape.prototype = new mxShape();\r\n * CustomShape.prototype.constructor = CustomShape;\r\n * (end)\r\n *\r\n * To register a custom shape in an existing graph instance,\r\n * one must register the shape under a new name in the graph's\r\n * cell renderer as follows:\r\n *\r\n * (code)\r\n * mxCellRenderer.registerShape('customShape', CustomShape);\r\n * (end)\r\n *\r\n * The second argument is the name of the constructor.\r\n *\r\n * In order to use the shape you can refer to the given name above\r\n * in a stylesheet. For example, to change the shape for the default\r\n * vertex style, the following code is used:\r\n *\r\n * (code)\r\n * var style = graph.getStylesheet().getDefaultVertexStyle();\r\n * style[mxConstants.STYLE_SHAPE] = 'customShape';\r\n * (end)\r\n *\r\n * Constructor: mxShape\r\n *\r\n * Constructs a new shape.\r\n */\nvar _default = exports[\"default\"] = mxStencil;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxStencil.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxStencilRegistry.js":
/*!****************************************************!*\
  !*** ./src/workflow/mxClient/mxStencilRegistry.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _mxStencil = _interopRequireDefault(__webpack_require__(/*! ./mxStencil */ \"./src/workflow/mxClient/mxStencil.js\"));\nvar _mxSvgStencil = _interopRequireDefault(__webpack_require__(/*! ./mxSvgStencil */ \"./src/workflow/mxClient/mxSvgStencil.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nvar mxStencilRegistry = {\n  /**\r\n   * Class: mxStencilRegistry\r\n   * \r\n   * A singleton class that provides a registry for stencils and the methods\r\n   * for painting those stencils onto a canvas or into a DOM.\r\n   */\n  stencils: {},\n  /**\r\n   * Function: addStencil\r\n   * \r\n   * Adds the given <shape>.\r\n   */\n  addStencil: function addStencil(name, shape) {\n    mxStencilRegistry.stencils[name] = this.createStencil(shape);\n  },\n  /**\r\n   * Function: getStencil\r\n   * \r\n   * Returns the <mxStencil> for the given name.\r\n   */\n  getStencil: function getStencil(name) {\n    return mxStencilRegistry.stencils[name];\n  },\n  createStencil: function createStencil(shape) {\n    if (shape.getAttribute('type') === 'svg') {\n      return new _mxSvgStencil[\"default\"](shape);\n    }\n    return new _mxStencil[\"default\"](shape);\n  }\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\nvar _default = exports[\"default\"] = mxStencilRegistry;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxStencilRegistry.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxStyleChange.js":
/*!************************************************!*\
  !*** ./src/workflow/mxClient/mxStyleChange.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nfunction mxStyleChange(model, cell, style) {\n  this.model = model;\n  this.cell = cell;\n  this.style = style;\n  this.previous = style;\n}\n;\n\n/**\r\n * Function: execute\r\n *\r\n * Changes the style of <cell> to <previous> using\r\n * <mxGraphModel.styleForCellChanged>.\r\n */\nmxStyleChange.prototype.execute = function () {\n  this.style = this.previous;\n  this.previous = this.model.styleForCellChanged(this.cell, this.previous);\n};\nmxStyleChange.getName = function () {\n  return 'mxStyleChange';\n};\n/**\r\n * Class: mxGeometryChange\r\n *\r\n * Action to change a cell's geometry in a model.\r\n *\r\n * Constructor: mxGeometryChange\r\n *\r\n * Constructs a change of a geometry in the\r\n * specified model.\r\n */\nvar _default = exports[\"default\"] = mxStyleChange;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxStyleChange.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxStyleRegistry.js":
/*!**************************************************!*\
  !*** ./src/workflow/mxClient/mxStyleRegistry.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.iterator.js */ \"../../node_modules/core-js/modules/es.array.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.object.to-string.js */ \"../../node_modules/core-js/modules/es.object.to-string.js\");\n__webpack_require__(/*! core-js/modules/web.dom-collections.iterator.js */ \"../../node_modules/core-js/modules/web.dom-collections.iterator.js\");\nvar _mxPerimeter = _interopRequireDefault(__webpack_require__(/*! ./mxPerimeter.js */ \"./src/workflow/mxClient/mxPerimeter.js\"));\nvar _mxEdgeStyle = _interopRequireDefault(__webpack_require__(/*! ./mxEdgeStyle.js */ \"./src/workflow/mxClient/mxEdgeStyle.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ./mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nvar mxStyleRegistry = {\n  /**\r\n   * Class: mxStyleRegistry\r\n   *\r\n   * Singleton class that acts as a global converter from string to object values\r\n   * in a style. This is currently only used to perimeters and edge styles.\r\n   *\r\n   * Variable: values\r\n   *\r\n   * Maps from strings to objects.\r\n   */\n  values: [],\n  /**\r\n   * Function: putValue\r\n   *\r\n   * Puts the given object into the registry under the given name.\r\n   */\n  putValue: function putValue(name, obj) {\n    mxStyleRegistry.values[name] = obj;\n  },\n  /**\r\n   * Function: getValue\r\n   *\r\n   * Returns the value associated with the given name.\r\n   */\n  getValue: function getValue(name) {\n    return mxStyleRegistry.values[name];\n  },\n  /**\r\n   * Function: getName\r\n   *\r\n   * Returns the name for the given value.\r\n   */\n  getName: function getName(value) {\n    for (var key in mxStyleRegistry.values) {\n      if (mxStyleRegistry.values[key] == value) {\n        return key;\n      }\n    }\n    return null;\n  }\n};\nmxStyleRegistry.putValue(_mxConstants[\"default\"].EDGESTYLE_ELBOW, _mxEdgeStyle[\"default\"].ElbowConnector);\nmxStyleRegistry.putValue(_mxConstants[\"default\"].EDGESTYLE_ENTITY_RELATION, _mxEdgeStyle[\"default\"].EntityRelation);\nmxStyleRegistry.putValue(_mxConstants[\"default\"].EDGESTYLE_LOOP, _mxEdgeStyle[\"default\"].Loop);\nmxStyleRegistry.putValue(_mxConstants[\"default\"].EDGESTYLE_SIDETOSIDE, _mxEdgeStyle[\"default\"].SideToSide);\nmxStyleRegistry.putValue(_mxConstants[\"default\"].EDGESTYLE_TOPTOBOTTOM, _mxEdgeStyle[\"default\"].TopToBottom);\nmxStyleRegistry.putValue(_mxConstants[\"default\"].EDGESTYLE_ORTHOGONAL, _mxEdgeStyle[\"default\"].OrthConnector);\nmxStyleRegistry.putValue(_mxConstants[\"default\"].EDGESTYLE_SEGMENT, _mxEdgeStyle[\"default\"].SegmentConnector);\nmxStyleRegistry.putValue(_mxConstants[\"default\"].PERIMETER_ELLIPSE, _mxPerimeter[\"default\"].EllipsePerimeter);\nmxStyleRegistry.putValue(_mxConstants[\"default\"].PERIMETER_RECTANGLE, _mxPerimeter[\"default\"].RectanglePerimeter);\nmxStyleRegistry.putValue(_mxConstants[\"default\"].PERIMETER_RHOMBUS, _mxPerimeter[\"default\"].RhombusPerimeter);\nmxStyleRegistry.putValue(_mxConstants[\"default\"].PERIMETER_TRIANGLE, _mxPerimeter[\"default\"].TrianglePerimeter);\nmxStyleRegistry.putValue(_mxConstants[\"default\"].PERIMETER_HEXAGON, _mxPerimeter[\"default\"].HexagonPerimeter);\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxGraphView\r\n *\r\n * Extends <mxEventSource> to implement a view for a graph. This class is in\r\n * charge of computing the absolute coordinates for the relative child\r\n * geometries, the points for perimeters and edge styles and keeping them\r\n * cached in <mxCellStates> for faster retrieval. The states are updated\r\n * whenever the model or the view state (translate, scale) changes. The scale\r\n * and translate are honoured in the bounds.\r\n *\r\n * Event: mxEvent.UNDO\r\n *\r\n * Fires after the root was changed in <setCurrentRoot>. The <code>edit</code>\r\n * property contains the <mxUndoableEdit> which contains the\r\n * <mxCurrentRootChange>.\r\n *\r\n * Event: mxEvent.SCALE_AND_TRANSLATE\r\n *\r\n * Fires after the scale and translate have been changed in <scaleAndTranslate>.\r\n * The <code>scale</code>, <code>previousScale</code>, <code>translate</code>\r\n * and <code>previousTranslate</code> properties contain the new and previous\r\n * scale and translate, respectively.\r\n *\r\n * Event: mxEvent.SCALE\r\n *\r\n * Fires after the scale was changed in <setScale>. The <code>scale</code> and\r\n * <code>previousScale</code> properties contain the new and previous scale.\r\n *\r\n * Event: mxEvent.TRANSLATE\r\n *\r\n * Fires after the translate was changed in <setTranslate>. The\r\n * <code>translate</code> and <code>previousTranslate</code> properties contain\r\n * the new and previous value for translate.\r\n *\r\n * Event: mxEvent.DOWN and mxEvent.UP\r\n *\r\n * Fire if the current root is changed by executing an <mxCurrentRootChange>.\r\n * The event name depends on the location of the root in the cell hierarchy\r\n * with respect to the current root. The <code>root</code> and\r\n * <code>previous</code> properties contain the new and previous root,\r\n * respectively.\r\n *\r\n * Constructor: mxGraphView\r\n *\r\n * Constructs a new view for the given <mxGraph>.\r\n *\r\n * Parameters:\r\n *\r\n * graph - Reference to the enclosing <mxGraph>.\r\n */\nvar _default = exports[\"default\"] = mxStyleRegistry;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxStyleRegistry.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxStylesheet.js":
/*!***********************************************!*\
  !*** ./src/workflow/mxClient/mxStylesheet.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.index-of.js */ \"../../node_modules/core-js/modules/es.array.index-of.js\");\n__webpack_require__(/*! core-js/modules/es.parse-float.js */ \"../../node_modules/core-js/modules/es.parse-float.js\");\nvar _mxPerimeter = _interopRequireDefault(__webpack_require__(/*! ./mxPerimeter.js */ \"./src/workflow/mxClient/mxPerimeter.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ./mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nvar _mxUtils = _interopRequireDefault(__webpack_require__(/*! ./mxUtils.js */ \"./src/workflow/mxClient/mxUtils.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxStylesheet() {\n  this.styles = new Object();\n  this.putDefaultVertexStyle(this.createDefaultVertexStyle());\n  this.putDefaultEdgeStyle(this.createDefaultEdgeStyle());\n}\n;\n\n/**\r\n * Function: styles\r\n *\r\n * Maps from names to cell styles. Each cell style is a map of key,\r\n * value pairs.\r\n */\nmxStylesheet.prototype.styles = {};\n\n/**\r\n * Function: createDefaultVertexStyle\r\n *\r\n * Creates and returns the default vertex style.\r\n */\nmxStylesheet.prototype.createDefaultVertexStyle = function () {\n  var style = new Object();\n  style[_mxConstants[\"default\"].STYLE_SHAPE] = _mxConstants[\"default\"].SHAPE_RECTANGLE;\n  style[_mxConstants[\"default\"].STYLE_PERIMETER] = _mxPerimeter[\"default\"].RectanglePerimeter;\n  style[_mxConstants[\"default\"].STYLE_VERTICAL_ALIGN] = _mxConstants[\"default\"].ALIGN_MIDDLE;\n  style[_mxConstants[\"default\"].STYLE_ALIGN] = _mxConstants[\"default\"].ALIGN_LEFT;\n  //style[mxConstants.STYLE_FILLCOLOR] = '#C3D9FF';\n  //style[mxConstants.STYLE_STROKECOLOR] = '#6482B9';\n  style[_mxConstants[\"default\"].STYLE_FONTCOLOR] = '#666666';\n  //style[mxConstants.STYLE_SPACING_LEFT] = '50';\n  //style[mxConstants.STYLE_WHITE_SPACE] = 'wrap';\n\n  return style;\n};\n\n/**\r\n * Function: createDefaultEdgeStyle\r\n *\r\n * Creates and returns the default edge style.\r\n */\nmxStylesheet.prototype.createDefaultEdgeStyle = function () {\n  var style = new Object();\n  style[_mxConstants[\"default\"].STYLE_SHAPE] = _mxConstants[\"default\"].SHAPE_CONNECTOR;\n  style[_mxConstants[\"default\"].STYLE_ENDARROW] = _mxConstants[\"default\"].ARROW_TRIANGLE;\n  style[_mxConstants[\"default\"].STYLE_VERTICAL_ALIGN] = _mxConstants[\"default\"].ALIGN_MIDDLE;\n  style[_mxConstants[\"default\"].STYLE_ALIGN] = _mxConstants[\"default\"].ALIGN_CENTER;\n  style[_mxConstants[\"default\"].STYLE_STROKECOLOR] = '#D8D8D8';\n  style[_mxConstants[\"default\"].STYLE_FONTCOLOR] = '#BBBBBB';\n  style[_mxConstants[\"default\"].STYLE_LABEL_BACKGROUNDCOLOR] = '#FFF';\n  style[_mxConstants[\"default\"].STYLE_STROKEWIDTH] = 2;\n  style[_mxConstants[\"default\"].STYLE_ROUNDED] = 1;\n  //style[mxConstants.STYLE_TARGET_PERIMETER_SPACING] = 5;\n  //style[mxConstants.STYLE_SOURCE_PERIMETER_SPACING] = 5;\n  return style;\n};\n\n/**\r\n * Function: putDefaultVertexStyle\r\n *\r\n * Sets the default style for vertices using defaultVertex as the\r\n * stylename.\r\n *\r\n * Parameters:\r\n * style - Key, value pairs that define the style.\r\n */\nmxStylesheet.prototype.putDefaultVertexStyle = function (style) {\n  this.putCellStyle('defaultVertex', style);\n};\n\n/**\r\n * Function: putDefaultEdgeStyle\r\n *\r\n * Sets the default style for edges using defaultEdge as the stylename.\r\n */\nmxStylesheet.prototype.putDefaultEdgeStyle = function (style) {\n  this.putCellStyle('defaultEdge', style);\n};\n\n/**\r\n * Function: getDefaultVertexStyle\r\n *\r\n * Returns the default style for vertices.\r\n */\nmxStylesheet.prototype.getDefaultVertexStyle = function () {\n  return this.styles['defaultVertex'];\n};\n\n/**\r\n * Function: getDefaultEdgeStyle\r\n *\r\n * Sets the default style for edges.\r\n */\nmxStylesheet.prototype.getDefaultEdgeStyle = function () {\n  return this.styles['defaultEdge'];\n};\n\n/**\r\n * Function: putCellStyle\r\n *\r\n * Stores the given map of key, value pairs under the given name in\r\n * <styles>.\r\n *\r\n * Example:\r\n *\r\n * The following example adds a new style called 'rounded' into an\r\n * existing stylesheet:\r\n *\r\n * (code)\r\n * var style = new Object();\r\n * style[mxConstants.STYLE_SHAPE] = mxConstants.SHAPE_RECTANGLE;\r\n * style[mxConstants.STYLE_PERIMETER] = mxPerimeter.RectanglePerimeter;\r\n * style[mxConstants.STYLE_ROUNDED] = true;\r\n * graph.getStylesheet().putCellStyle('rounded', style);\r\n * (end)\r\n *\r\n * In the above example, the new style is an object. The possible keys of\r\n * the object are all the constants in <mxConstants> that start with STYLE\r\n * and the values are either JavaScript objects, such as\r\n * <mxPerimeter.RightAngleRectanglePerimeter> (which is in fact a function)\r\n * or expressions, such as true. Note that not all keys will be\r\n * interpreted by all shapes (eg. the line shape ignores the fill color).\r\n * The final call to this method associates the style with a name in the\r\n * stylesheet. The style is used in a cell with the following code:\r\n *\r\n * (code)\r\n * model.setStyle(cell, 'rounded');\r\n * (end)\r\n *\r\n * Parameters:\r\n *\r\n * name - Name for the style to be stored.\r\n * style - Key, value pairs that define the style.\r\n */\nmxStylesheet.prototype.putCellStyle = function (name, style) {\n  this.styles[name] = style;\n};\n\n/**\r\n * Function: getCellStyle\r\n *\r\n * Returns the cell style for the specified stylename or the given\r\n * defaultStyle if no style can be found for the given stylename.\r\n *\r\n * Parameters:\r\n *\r\n * name - String of the form [(stylename|key=value);] that represents the\r\n * style.\r\n * defaultStyle - Default style to be returned if no style can be found.\r\n */\nmxStylesheet.prototype.getCellStyle = function (name, defaultStyle) {\n  var style = defaultStyle;\n  if (name != null && name.length > 0) {\n    var pairs = name.split(';');\n    if (style != null && name.charAt(0) != ';') {\n      style = _mxGraphUtils[\"default\"].clone(style);\n    } else {\n      style = new Object();\n    }\n\n    // Parses each key, value pair into the existing style\n    for (var i = 0; i < pairs.length; i++) {\n      var tmp = pairs[i];\n      var pos = tmp.indexOf('=');\n      if (pos >= 0) {\n        var key = tmp.substring(0, pos);\n        var value = tmp.substring(pos + 1);\n        if (value == _mxConstants[\"default\"].NONE) {\n          delete style[key];\n        } else if (_mxUtils[\"default\"].isNumeric(value)) {\n          style[key] = parseFloat(value);\n        } else {\n          style[key] = value;\n          var index = value.indexOf(\"!important\");\n          //查看流程图时要覆盖bpmn.xml中的样式\n          if (index > -1) {\n            style[key] = style[key + \"_important\"] = value.substring(0, index);\n          }\n        }\n      } else {\n        // Merges the entries from a named style\n        var tmpStyle = this.styles[tmp];\n        if (tmpStyle != null) {\n          for (var key in tmpStyle) {\n            style[key] = tmpStyle[key];\n          }\n        }\n      }\n    }\n  }\n  return style;\n};\nmxStylesheet.getName = function () {\n  return 'mxStylesheet';\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxCellState\r\n *\r\n * Represents the current state of a cell in a given <mxGraphView>.\r\n *\r\n * For edges, the edge label position is stored in <absoluteOffset>.\r\n *\r\n * The size for oversize labels can be retrieved using the boundingBox property\r\n * of the <text> field as shown below.\r\n *\r\n * (code)\r\n * var bbox = (state.text != null) ? state.text.boundingBox : null;\r\n * (end)\r\n *\r\n * Constructor: mxCellState\r\n *\r\n * Constructs a new object that represents the current state of the given\r\n * cell in the specified view.\r\n *\r\n * Parameters:\r\n *\r\n * view - <mxGraphView> that contains the state.\r\n * cell - <mxCell> that this state represents.\r\n * style - Array of key, value pairs that constitute the style.\r\n */\nvar _default = exports[\"default\"] = mxStylesheet;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxStylesheet.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxSvgCanvas2D.js":
/*!************************************************!*\
  !*** ./src/workflow/mxClient/mxSvgCanvas2D.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.fill.js */ \"../../node_modules/core-js/modules/es.array.fill.js\");\n__webpack_require__(/*! core-js/modules/es.array.index-of.js */ \"../../node_modules/core-js/modules/es.array.index-of.js\");\n__webpack_require__(/*! core-js/modules/es.array.join.js */ \"../../node_modules/core-js/modules/es.array.join.js\");\n__webpack_require__(/*! core-js/modules/es.array.last-index-of.js */ \"../../node_modules/core-js/modules/es.array.last-index-of.js\");\n__webpack_require__(/*! core-js/modules/es.number.constructor.js */ \"../../node_modules/core-js/modules/es.number.constructor.js\");\n__webpack_require__(/*! core-js/modules/es.number.to-fixed.js */ \"../../node_modules/core-js/modules/es.number.to-fixed.js\");\n__webpack_require__(/*! core-js/modules/es.parse-float.js */ \"../../node_modules/core-js/modules/es.parse-float.js\");\n__webpack_require__(/*! core-js/modules/es.regexp.exec.js */ \"../../node_modules/core-js/modules/es.regexp.exec.js\");\n__webpack_require__(/*! core-js/modules/es.string.replace.js */ \"../../node_modules/core-js/modules/es.string.replace.js\");\n__webpack_require__(/*! core-js/modules/es.string.trim.js */ \"../../node_modules/core-js/modules/es.string.trim.js\");\n__webpack_require__(/*! core-js/modules/esnext.string.replace-all.js */ \"../../node_modules/core-js/modules/esnext.string.replace-all.js\");\nvar _mxClient = _interopRequireDefault(__webpack_require__(/*! ./mxClient.js */ \"./src/workflow/mxClient/mxClient.js\"));\nvar _mxRectangle = _interopRequireDefault(__webpack_require__(/*! ./mxRectangle.js */ \"./src/workflow/mxClient/mxRectangle.js\"));\nvar _mxAbstractCanvas2D = _interopRequireDefault(__webpack_require__(/*! ./mxAbstractCanvas2D.js */ \"./src/workflow/mxClient/mxAbstractCanvas2D.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ./mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxSvgCanvas2D(root, styleEnabled) {\n  _mxAbstractCanvas2D[\"default\"].call(this);\n\n  /**\r\n   * Variable: root\r\n   *\r\n   * Reference to the container for the SVG content.\r\n   */\n  this.root = root;\n\n  /**\r\n   * Variable: gradients\r\n   *\r\n   * Local cache of gradients for quick lookups.\r\n   */\n  this.gradients = [];\n\n  /**\r\n   * Variable: defs\r\n   *\r\n   * Reference to the defs section of the SVG document. Only for export.\r\n   */\n  this.defs = document.querySelector('svg.defs defs'); //null\n\n  /**\r\n   * Variable: styleEnabled\r\n   *\r\n   * Stores the value of styleEnabled passed to the constructor.\r\n   */\n  this.styleEnabled = styleEnabled != null ? styleEnabled : false;\n  var svg = null;\n\n  // Adds optional defs section for export\n  if (root.ownerDocument != document) {\n    var node = root;\n\n    // Finds owner SVG element in XML DOM\n    while (node != null && node.nodeName != 'svg') {\n      node = node.parentNode;\n    }\n    svg = node;\n  }\n  if (svg != null) {\n    // Tries to get existing defs section\n    var tmp = svg.getElementsByTagName('defs');\n    if (tmp.length > 0) {\n      this.defs = svg.getElementsByTagName('defs')[0];\n    }\n\n    // Adds defs section if none exists\n    if (this.defs == null) {\n      this.defs = this.createElement('defs');\n      if (svg.firstChild != null) {\n        svg.insertBefore(this.defs, svg.firstChild);\n      } else {\n        svg.appendChild(this.defs);\n      }\n    }\n\n    // Adds stylesheet\n    if (this.styleEnabled) {\n      this.defs.appendChild(this.createStyle());\n    }\n  }\n}\n;\n\n/**\r\n * Extends mxAbstractCanvas2D\r\n */\n_mxGraphUtils[\"default\"].extend(mxSvgCanvas2D, _mxAbstractCanvas2D[\"default\"]);\n\n/**\r\n * Capability check for DOM parser.\r\n */\n(function () {\n  mxSvgCanvas2D.prototype.useDomParser = !_mxClient[\"default\"].IS_IE && typeof DOMParser === 'function' && typeof XMLSerializer === 'function';\n  if (mxSvgCanvas2D.prototype.useDomParser) {\n    // Checks using a generic test text if the parsing actually works. This is a workaround\n    // for older browsers where the capability check returns true but the parsing fails.\n    try {\n      var doc = new DOMParser().parseFromString('test text', 'text/html');\n      mxSvgCanvas2D.prototype.useDomParser = doc != null;\n    } catch (e) {\n      mxSvgCanvas2D.prototype.useDomParser = false;\n    }\n  }\n})();\n\n/**\r\n * Variable: path\r\n *\r\n * Holds the current DOM node.\r\n */\nmxSvgCanvas2D.prototype.node = null;\n\n/**\r\n * Variable: matchHtmlAlignment\r\n *\r\n * Specifies if plain text output should match the vertical HTML alignment.\r\n * Defaul is true.\r\n */\nmxSvgCanvas2D.prototype.matchHtmlAlignment = true;\n\n/**\r\n * Variable: textEnabled\r\n *\r\n * Specifies if text output should be enabled. Default is true.\r\n */\nmxSvgCanvas2D.prototype.textEnabled = true;\n\n/**\r\n * Variable: foEnabled\r\n *\r\n * Specifies if use of foreignObject for HTML markup is allowed. Default is true.\r\n */\nmxSvgCanvas2D.prototype.foEnabled = true;\n\n/**\r\n * Variable: foAltText\r\n *\r\n * Specifies the fallback text for unsupported foreignObjects in exported\r\n * documents. Default is '[Object]'. If this is set to null then no fallback\r\n * text is added to the exported document.\r\n */\nmxSvgCanvas2D.prototype.foAltText = '[Object]';\n\n/**\r\n * Variable: foOffset\r\n *\r\n * Offset to be used for foreignObjects.\r\n */\nmxSvgCanvas2D.prototype.foOffset = 0;\n\n/**\r\n * Variable: textOffset\r\n *\r\n * Offset to be used for text elements.\r\n */\nmxSvgCanvas2D.prototype.textOffset = 0;\n\n/**\r\n * Variable: strokeTolerance\r\n *\r\n * Adds transparent paths for strokes.\r\n */\nmxSvgCanvas2D.prototype.strokeTolerance = 0;\n\n/**\r\n * Variable: refCount\r\n *\r\n * Local counter for references in SVG export.\r\n */\nmxSvgCanvas2D.prototype.refCount = 0;\n\n/**\r\n * Variable: blockImagePointerEvents\r\n *\r\n * Specifies if a transparent rectangle should be added on top of images to absorb\r\n * all pointer events. Default is false. This is only needed in Firefox to disable\r\n * control-clicks on images.\r\n */\nmxSvgCanvas2D.prototype.blockImagePointerEvents = false;\n\n/**\r\n * Variable: lineHeightCorrection\r\n *\r\n * Correction factor for <mxConstants.LINE_HEIGHT> in HTML output. Default is 1.\r\n */\nmxSvgCanvas2D.prototype.lineHeightCorrection = 1;\n\n/**\r\n * Variable: pointerEventsValue\r\n *\r\n * Default value for active pointer events. Default is all.\r\n */\nmxSvgCanvas2D.prototype.pointerEventsValue = 'all';\n\n/**\r\n * Variable: fontMetricsPadding\r\n *\r\n * Padding to be added for text that is not wrapped to account for differences\r\n * in font metrics on different platforms in pixels. Default is 10.\r\n */\nmxSvgCanvas2D.prototype.fontMetricsPadding = 10;\n\n/**\r\n * Variable: cacheOffsetSize\r\n *\r\n * Specifies if offsetWidth and offsetHeight should be cached. Default is true.\r\n * This is used to speed up repaint of text in <updateText>.\r\n */\nmxSvgCanvas2D.prototype.cacheOffsetSize = true;\n\n/**\r\n * Function: format\r\n *\r\n * Rounds all numbers to 2 decimal points.\r\n */\nmxSvgCanvas2D.prototype.format = function (value) {\n  return parseFloat(parseFloat(value).toFixed(2));\n};\n\n/**\r\n * Function: getBaseUrl\r\n *\r\n * Returns the URL of the page without the hash part. This needs to use href to\r\n * include any search part with no params (ie question mark alone). This is a\r\n * workaround for the fact that window.location.search is empty if there is\r\n * no search string behind the question mark.\r\n */\nmxSvgCanvas2D.prototype.getBaseUrl = function () {\n  var href = window.location.href;\n  var hash = href.lastIndexOf('#');\n  if (hash > 0) {\n    href = href.substring(0, hash);\n  }\n  return href;\n};\n\n/**\r\n * Function: reset\r\n *\r\n * Returns any offsets for rendering pixels.\r\n */\nmxSvgCanvas2D.prototype.reset = function () {\n  _mxAbstractCanvas2D[\"default\"].prototype.reset.apply(this, arguments);\n  this.gradients = [];\n};\n\n/**\r\n * Function: createStyle\r\n *\r\n * Creates the optional style section.\r\n */\nmxSvgCanvas2D.prototype.createStyle = function (x) {\n  var style = this.createElement('style');\n  style.setAttribute('type', 'text/css');\n  _mxGraphUtils[\"default\"].write(style, 'svg{font-family:' + _mxConstants[\"default\"].DEFAULT_FONTFAMILY + ';font-size:' + _mxConstants[\"default\"].DEFAULT_FONTSIZE + ';fill:none;stroke-miterlimit:10}');\n  return style;\n};\n\n/**\r\n * Function: createElement\r\n *\r\n * Private helper function to create SVG elements\r\n */\nmxSvgCanvas2D.prototype.createElement = function (tagName, namespace) {\n  if (this.root.ownerDocument.createElementNS != null) {\n    return this.root.ownerDocument.createElementNS(namespace || _mxConstants[\"default\"].NS_SVG, tagName);\n  } else {\n    var elt = this.root.ownerDocument.createElement(tagName);\n    if (namespace != null) {\n      elt.setAttribute('xmlns', namespace);\n    }\n    return elt;\n  }\n};\n\n/**\r\n * Function: getAlternateContent\r\n *\r\n * Returns the alternate content for the given foreignObject.\r\n */\nmxSvgCanvas2D.prototype.createAlternateContent = function (fo, x, y, w, h, str, align, valign, wrap, format, overflow, clip, rotation) {\n  if (this.foAltText != null) {\n    var s = this.state;\n    var alt = this.createElement('text');\n    alt.setAttribute('x', Math.round(w / 2));\n    alt.setAttribute('y', Math.round((h + s.fontSize) / 2));\n    alt.setAttribute('fill', s.fontColor || 'black');\n    alt.setAttribute('text-anchor', 'middle');\n    alt.setAttribute('font-size', s.fontSize + 'px');\n    alt.setAttribute('font-family', s.fontFamily);\n    if ((s.fontStyle & _mxConstants[\"default\"].FONT_BOLD) == _mxConstants[\"default\"].FONT_BOLD) {\n      alt.setAttribute('font-weight', 'bold');\n    }\n    if ((s.fontStyle & _mxConstants[\"default\"].FONT_ITALIC) == _mxConstants[\"default\"].FONT_ITALIC) {\n      alt.setAttribute('font-style', 'italic');\n    }\n    if ((s.fontStyle & _mxConstants[\"default\"].FONT_UNDERLINE) == _mxConstants[\"default\"].FONT_UNDERLINE) {\n      alt.setAttribute('text-decoration', 'underline');\n    }\n    _mxGraphUtils[\"default\"].write(alt, this.foAltText);\n    return alt;\n  } else {\n    return null;\n  }\n};\n\n/**\r\n * Function: createGradientId\r\n *\r\n * Private helper function to create SVG elements\r\n */\nmxSvgCanvas2D.prototype.createGradientId = function (start, end, alpha1, alpha2, direction) {\n  // Removes illegal characters from gradient ID\n  if (start.charAt(0) == '#') {\n    start = start.substring(1);\n  }\n  if (end.charAt(0) == '#') {\n    end = end.substring(1);\n  }\n\n  // Workaround for gradient IDs not working in Safari 5 / Chrome 6\n  // if they contain uppercase characters\n  start = start.toLowerCase() + '-' + alpha1;\n  end = end.toLowerCase() + '-' + alpha2;\n\n  // Wrong gradient directions possible?\n  var dir = null;\n  if (direction == null || direction == _mxConstants[\"default\"].DIRECTION_SOUTH) {\n    dir = 's';\n  } else if (direction == _mxConstants[\"default\"].DIRECTION_EAST) {\n    dir = 'e';\n  } else {\n    var tmp = start;\n    start = end;\n    end = tmp;\n    if (direction == _mxConstants[\"default\"].DIRECTION_NORTH) {\n      dir = 's';\n    } else if (direction == _mxConstants[\"default\"].DIRECTION_WEST) {\n      dir = 'e';\n    }\n  }\n  return 'mx-gradient-' + start + '-' + end + '-' + dir;\n};\n\n/**\r\n * Function: getSvgGradient\r\n *\r\n * Private helper function to create SVG elements\r\n */\nmxSvgCanvas2D.prototype.getSvgGradient = function (start, end, alpha1, alpha2, direction) {\n  var id = this.createGradientId(start, end, alpha1, alpha2, direction);\n  var gradient = this.gradients[id];\n  if (gradient == null) {\n    var svg = this.root.ownerSVGElement;\n    var counter = 0;\n    var tmpId = id + '-' + counter;\n    if (svg != null) {\n      gradient = svg.ownerDocument.getElementById(tmpId);\n      while (gradient != null && gradient.ownerSVGElement != svg) {\n        tmpId = id + '-' + counter++;\n        gradient = svg.ownerDocument.getElementById(tmpId);\n      }\n    } else {\n      // Uses shorter IDs for export\n      tmpId = 'id' + ++this.refCount;\n    }\n    if (gradient == null) {\n      gradient = this.createSvgGradient(start, end, alpha1, alpha2, direction);\n      gradient.setAttribute('id', tmpId);\n      if (this.defs != null) {\n        this.defs.appendChild(gradient);\n      } else {\n        svg && svg.appendChild(gradient);\n      }\n    }\n    this.gradients[id] = gradient;\n  }\n  return gradient.getAttribute('id');\n};\n\n/**\r\n * Function: createSvgGradient\r\n *\r\n * Creates the given SVG gradient.\r\n */\nmxSvgCanvas2D.prototype.createSvgGradient = function (start, end, alpha1, alpha2, direction) {\n  var gradient = this.createElement('linearGradient');\n  gradient.setAttribute('x1', '0%');\n  gradient.setAttribute('y1', '0%');\n  gradient.setAttribute('x2', '0%');\n  gradient.setAttribute('y2', '0%');\n  if (direction == null || direction == _mxConstants[\"default\"].DIRECTION_SOUTH) {\n    gradient.setAttribute('y2', '100%');\n  } else if (direction == _mxConstants[\"default\"].DIRECTION_EAST) {\n    gradient.setAttribute('x2', '100%');\n  } else if (direction == _mxConstants[\"default\"].DIRECTION_NORTH) {\n    gradient.setAttribute('y1', '100%');\n  } else if (direction == _mxConstants[\"default\"].DIRECTION_WEST) {\n    gradient.setAttribute('x1', '100%');\n  }\n  var op = alpha1 < 1 ? ';stop-opacity:' + alpha1 : '';\n  var stop = this.createElement('stop');\n  stop.setAttribute('offset', '0%');\n  stop.setAttribute('style', 'stop-color:' + start + op);\n  gradient.appendChild(stop);\n  op = alpha2 < 1 ? ';stop-opacity:' + alpha2 : '';\n  stop = this.createElement('stop');\n  stop.setAttribute('offset', '100%');\n  stop.setAttribute('style', 'stop-color:' + end + op);\n  gradient.appendChild(stop);\n  return gradient;\n};\n\n/**\r\n * Function: addNode\r\n *\r\n * Private helper function to create SVG elements\r\n */\nmxSvgCanvas2D.prototype.addNode = function (filled, stroked) {\n  var node = this.node;\n  var s = this.state;\n  if (node != null) {\n    if (node.nodeName == 'path') {\n      // Checks if the path is not empty\n      if (this.path != null && this.path.length > 0) {\n        node.setAttribute('d', this.path.join(' '));\n      } else {\n        return;\n      }\n    }\n    if (filled && s.fillColor != null) {\n      this.updateFill();\n    } else if (!this.styleEnabled) {\n      // Workaround for https://bugzilla.mozilla.org/show_bug.cgi?id=814952\n      if (node.nodeName == 'ellipse' && _mxClient[\"default\"].IS_FF) {\n        node.setAttribute('fill', 'transparent');\n      } else {\n        node.setAttribute('fill', 'none');\n      }\n\n      // Sets the actual filled state for stroke tolerance\n      filled = false;\n    }\n    if (stroked && s.strokeColor != null) {\n      this.updateStroke();\n    } else if (!this.styleEnabled) {\n      node.setAttribute('stroke', 'none');\n    }\n    if (s.transform != null && s.transform.length > 0) {\n      node.setAttribute('transform', s.transform);\n    }\n    if (s.shadow) {\n      this.root.appendChild(this.createShadow(node));\n    }\n\n    // Adds stroke tolerance\n    if (this.strokeTolerance > 0 && !filled) {\n      this.root.appendChild(this.createTolerance(node));\n    }\n\n    // Adds pointer events\n    if (this.pointerEvents && (node.nodeName != 'path' || this.path[this.path.length - 1] == this.closeOp)) {\n      node.setAttribute('pointer-events', this.pointerEventsValue);\n    }\n    // Enables clicks for nodes inside a link element\n    else if (!this.pointerEvents && this.originalRoot == null) {\n      node.setAttribute('pointer-events', 'none');\n    }\n\n    // Removes invisible nodes from output if they don't handle events\n    if (node.nodeName != 'rect' && node.nodeName != 'path' && node.nodeName != 'ellipse' || node.getAttribute('fill') != 'none' && node.getAttribute('fill') != 'transparent' || node.getAttribute('stroke') != 'none' || node.getAttribute('pointer-events') != 'none') {\n      // LATER: Update existing DOM for performance\n      this.root.appendChild(node);\n    }\n    this.node = null;\n  }\n};\n\n/**\r\n * Function: updateFill\r\n *\r\n * Transfers the stroke attributes from <state> to <node>.\r\n */\nmxSvgCanvas2D.prototype.updateFill = function () {\n  var s = this.state;\n  if (s.alpha < 1 || s.fillAlpha < 1) {\n    this.node.setAttribute('fill-opacity', s.alpha * s.fillAlpha);\n  }\n  if (s.fillColor != null) {\n    if (s.gradientColor != null) {\n      var id = this.getSvgGradient(s.fillColor, s.gradientColor, s.gradientFillAlpha, s.gradientAlpha, s.gradientDirection);\n      if (!_mxClient[\"default\"].IS_CHROME_APP && !_mxClient[\"default\"].IS_IE && !_mxClient[\"default\"].IS_IE11 && !_mxClient[\"default\"].IS_EDGE && this.root.ownerDocument == document) {\n        // Workaround for potential base tag and brackets must be escaped\n        var base = this.getBaseUrl().replace(/([\\(\\)])/g, '\\\\$1');\n        this.node.setAttribute('fill', 'url(' + base + '#' + id + ')');\n      } else {\n        this.node.setAttribute('fill', 'url(#' + id + ')');\n      }\n    } else {\n      this.node.setAttribute('fill', s.fillColor.toLowerCase());\n    }\n  }\n};\n\n/**\r\n * Function: getCurrentStrokeWidth\r\n *\r\n * Returns the current stroke width (>= 1), ie. max(1, this.format(this.state.strokeWidth * this.state.scale)).\r\n */\nmxSvgCanvas2D.prototype.getCurrentStrokeWidth = function () {\n  return Math.max(1, this.format(this.state.strokeWidth * this.state.scale));\n};\n\n/**\r\n * Function: updateStroke\r\n *\r\n * Transfers the stroke attributes from <state> to <node>.\r\n */\nmxSvgCanvas2D.prototype.updateStroke = function () {\n  var s = this.state;\n  this.node.setAttribute('stroke', s.strokeColor.toLowerCase());\n  if (s.alpha < 1 || s.strokeAlpha < 1) {\n    this.node.setAttribute('stroke-opacity', s.alpha * s.strokeAlpha);\n  }\n  var sw = this.getCurrentStrokeWidth();\n  if (sw != 1) {\n    this.node.setAttribute('stroke-width', sw);\n  }\n  if (this.node.nodeName == 'path') {\n    this.updateStrokeAttributes();\n  }\n  if (s.dashed) {\n    this.node.setAttribute('stroke-dasharray', this.createDashPattern(s.strokeWidth * s.scale));\n  }\n};\n\n/**\r\n * Function: updateStrokeAttributes\r\n *\r\n * Transfers the stroke attributes from <state> to <node>.\r\n */\nmxSvgCanvas2D.prototype.updateStrokeAttributes = function () {\n  var s = this.state;\n\n  // Linejoin miter is default in SVG\n  if (s.lineJoin != null && s.lineJoin != 'miter') {\n    this.node.setAttribute('stroke-linejoin', s.lineJoin);\n  }\n  if (s.lineCap != null) {\n    // flat is called butt in SVG\n    var value = s.lineCap;\n    if (value == 'flat') {\n      value = 'butt';\n    }\n\n    // Linecap butt is default in SVG\n    if (value != 'butt') {\n      this.node.setAttribute('stroke-linecap', value);\n    }\n  }\n\n  // Miterlimit 10 is default in our document\n  if (s.miterLimit != null && (!this.styleEnabled || s.miterLimit != 10)) {\n    this.node.setAttribute('stroke-miterlimit', s.miterLimit);\n  }\n};\n\n/**\r\n * Function: createDashPattern\r\n *\r\n * Creates the SVG dash pattern for the given state.\r\n */\nmxSvgCanvas2D.prototype.createDashPattern = function (scale) {\n  var pat = [];\n  if (typeof this.state.dashPattern === 'string') {\n    var dash = this.state.dashPattern.split(' ');\n    if (dash.length > 0) {\n      for (var i = 0; i < dash.length; i++) {\n        pat[i] = Number(dash[i]) * scale;\n      }\n    }\n  }\n  return pat.join(' ');\n};\n\n/**\r\n * Function: createTolerance\r\n *\r\n * Creates a hit detection tolerance shape for the given node.\r\n */\nmxSvgCanvas2D.prototype.createTolerance = function (node) {\n  var tol = node.cloneNode(true);\n  var sw = parseFloat(tol.getAttribute('stroke-width') || 1) + this.strokeTolerance;\n  tol.setAttribute('pointer-events', 'stroke');\n  tol.setAttribute('visibility', 'hidden');\n  tol.removeAttribute('stroke-dasharray');\n  tol.setAttribute('stroke-width', sw);\n  tol.setAttribute('fill', 'none');\n\n  // Workaround for Opera ignoring the visiblity attribute above while\n  // other browsers need a stroke color to perform the hit-detection but\n  // do not ignore the visibility attribute. Side-effect is that Opera's\n  // hit detection for horizontal/vertical edges seems to ignore the tol.\n  tol.setAttribute('stroke', _mxClient[\"default\"].IS_OT ? 'none' : 'white');\n  return tol;\n};\n\n/**\r\n * Function: createShadow\r\n *\r\n * Creates a shadow for the given node.\r\n */\nmxSvgCanvas2D.prototype.createShadow = function (node) {\n  var shadow = node.cloneNode(true);\n  var s = this.state;\n\n  // Firefox uses transparent for no fill in ellipses\n  if (shadow.getAttribute('fill') != 'none' && (!_mxClient[\"default\"].IS_FF || shadow.getAttribute('fill') != 'transparent')) {\n    shadow.setAttribute('fill', s.shadowColor);\n  }\n  if (shadow.getAttribute('stroke') != 'none') {\n    shadow.setAttribute('stroke', s.shadowColor);\n  }\n  shadow.setAttribute('transform', 'translate(' + this.format(s.shadowDx * s.scale) + ',' + this.format(s.shadowDy * s.scale) + ')' + (s.transform || ''));\n  shadow.setAttribute('opacity', s.shadowAlpha);\n  return shadow;\n};\n\n/**\r\n * Function: setLink\r\n *\r\n * Experimental implementation for hyperlinks.\r\n */\nmxSvgCanvas2D.prototype.setLink = function (link) {\n  if (link == null) {\n    this.root = this.originalRoot;\n  } else {\n    this.originalRoot = this.root;\n    var node = this.createElement('a');\n\n    // Workaround for implicit namespace handling in HTML5 export, IE adds NS1 namespace so use code below\n    // in all IE versions except quirks mode. KNOWN: Adds xlink namespace to each image tag in output.\n    if (node.setAttributeNS == null || this.root.ownerDocument != document && document.documentMode == null) {\n      node.setAttribute('xlink:href', link);\n    } else {\n      node.setAttributeNS(_mxConstants[\"default\"].NS_XLINK, 'xlink:href', link);\n    }\n    this.root.appendChild(node);\n    this.root = node;\n  }\n};\n\n/**\r\n * Function: rotate\r\n *\r\n * Sets the rotation of the canvas. Note that rotation cannot be concatenated.\r\n */\nmxSvgCanvas2D.prototype.rotate = function (theta, flipH, flipV, cx, cy) {\n  if (theta != 0 || flipH || flipV) {\n    var s = this.state;\n    cx += s.dx;\n    cy += s.dy;\n    cx *= s.scale;\n    cy *= s.scale;\n    s.transform = s.transform || '';\n\n    // This implementation uses custom scale/translate and built-in rotation\n    // Rotation state is part of the AffineTransform in state.transform\n    if (flipH && flipV) {\n      theta += 180;\n    } else if (flipH != flipV) {\n      var tx = flipH ? cx : 0;\n      var sx = flipH ? -1 : 1;\n      var ty = flipV ? cy : 0;\n      var sy = flipV ? -1 : 1;\n      s.transform += 'translate(' + this.format(tx) + ',' + this.format(ty) + ')' + 'scale(' + this.format(sx) + ',' + this.format(sy) + ')' + 'translate(' + this.format(-tx) + ',' + this.format(-ty) + ')';\n    }\n    if (flipH ? !flipV : flipV) {\n      theta *= -1;\n    }\n    if (theta != 0) {\n      s.transform += 'rotate(' + this.format(theta) + ',' + this.format(cx) + ',' + this.format(cy) + ')';\n    }\n    s.rotation = s.rotation + theta;\n    s.rotationCx = cx;\n    s.rotationCy = cy;\n  }\n};\n\n/**\r\n * Function: begin\r\n *\r\n * Extends superclass to create path.\r\n */\nmxSvgCanvas2D.prototype.begin = function () {\n  _mxAbstractCanvas2D[\"default\"].prototype.begin.apply(this, arguments);\n  this.node = this.createElement('path');\n};\n\n/**\r\n * Function: rect\r\n *\r\n * Private helper function to create SVG elements\r\n */\nmxSvgCanvas2D.prototype.rect = function (x, y, w, h, rx, ry) {\n  rx = rx || 0;\n  ry = ry || 0;\n  var s = this.state;\n  var n = this.createElement('rect');\n  n.setAttribute('x', this.format((x + s.dx) * s.scale));\n  n.setAttribute('y', this.format((y + s.dy) * s.scale));\n  n.setAttribute('width', this.format(w * s.scale));\n  n.setAttribute('height', this.format(h * s.scale));\n  n.setAttribute('rx', this.format(rx * s.scale));\n  n.setAttribute('ry', this.format(ry * s.scale));\n  this.node = n;\n};\n\n/**\r\n * Function: roundrect\r\n *\r\n * Private helper function to create SVG elements\r\n */\nmxSvgCanvas2D.prototype.roundrect = function (x, y, w, h, dx, dy) {\n  this.rect(x, y, w, h);\n  if (dx > 0) {\n    this.node.setAttribute('rx', this.format(dx * this.state.scale));\n  }\n  if (dy > 0) {\n    this.node.setAttribute('ry', this.format(dy * this.state.scale));\n  }\n};\n\n/**\r\n * Function: ellipse\r\n *\r\n * Private helper function to create SVG elements\r\n */\nmxSvgCanvas2D.prototype.ellipse = function (x, y, w, h) {\n  var s = this.state;\n  var n = this.createElement('ellipse');\n  // No rounding for consistent output with 1.x\n  n.setAttribute('cx', Math.round((x + w / 2 + s.dx) * s.scale));\n  n.setAttribute('cy', Math.round((y + h / 2 + s.dy) * s.scale));\n  n.setAttribute('rx', w / 2 * s.scale);\n  n.setAttribute('ry', h / 2 * s.scale);\n  this.node = n;\n};\n\n/**\r\n * Function: image\r\n *\r\n * Private helper function to create SVG elements\r\n */\nmxSvgCanvas2D.prototype.image = function (x, y, w, h, src, aspect, flipH, flipV) {\n  src = this.converter.convert(src);\n\n  // LATER: Add option for embedding images as base64.\n  aspect = aspect != null ? aspect : true;\n  flipH = flipH != null ? flipH : false;\n  flipV = flipV != null ? flipV : false;\n  var s = this.state;\n  x += s.dx;\n  y += s.dy;\n  var node = this.createElement('image');\n  node.setAttribute('x', this.format(x * s.scale));\n  node.setAttribute('y', this.format(y * s.scale));\n  node.setAttribute('width', this.format(w * s.scale));\n  node.setAttribute('height', this.format(h * s.scale));\n\n  // Workaround for missing namespace support\n  if (node.setAttributeNS == null) {\n    node.setAttribute('xlink:href', src);\n  } else {\n    node.setAttributeNS(_mxConstants[\"default\"].NS_XLINK, 'xlink:href', src);\n  }\n  if (!aspect) {\n    node.setAttribute('preserveAspectRatio', 'none');\n  }\n  if (s.alpha < 1 || s.fillAlpha < 1) {\n    node.setAttribute('opacity', s.alpha * s.fillAlpha);\n  }\n  var tr = this.state.transform || '';\n  if (flipH || flipV) {\n    var sx = 1;\n    var sy = 1;\n    var dx = 0;\n    var dy = 0;\n    if (flipH) {\n      sx = -1;\n      dx = -w - 2 * x;\n    }\n    if (flipV) {\n      sy = -1;\n      dy = -h - 2 * y;\n    }\n\n    // Adds image tansformation to existing transform\n    tr += 'scale(' + sx + ',' + sy + ')translate(' + dx * s.scale + ',' + dy * s.scale + ')';\n  }\n  if (tr.length > 0) {\n    node.setAttribute('transform', tr);\n  }\n  if (!this.pointerEvents) {\n    node.setAttribute('pointer-events', 'none');\n  }\n  this.root.appendChild(node);\n\n  // Disables control-clicks on images in Firefox to open in new tab\n  // by putting a rect in the foreground that absorbs all events and\n  // disabling all pointer-events on the original image tag.\n  if (this.blockImagePointerEvents) {\n    node.setAttribute('style', 'pointer-events:none');\n    node = this.createElement('rect');\n    node.setAttribute('visibility', 'hidden');\n    node.setAttribute('pointer-events', 'fill');\n    node.setAttribute('x', this.format(x * s.scale));\n    node.setAttribute('y', this.format(y * s.scale));\n    node.setAttribute('width', this.format(w * s.scale));\n    node.setAttribute('height', this.format(h * s.scale));\n    this.root.appendChild(node);\n  }\n};\n\n/**\r\n * Function: convertHtml\r\n *\r\n * Converts the given HTML string to XHTML.\r\n */\nmxSvgCanvas2D.prototype.convertHtml = function (val) {\n  if (this.useDomParser) {\n    var doc = new DOMParser().parseFromString(val, 'text/html');\n    if (doc != null) {\n      val = new XMLSerializer().serializeToString(doc.body);\n\n      // Extracts body content from DOM\n      if (val.substring(0, 5) == '<body') {\n        val = val.substring(val.indexOf('>', 5) + 1);\n      }\n      if (val.substring(val.length - 7, val.length) == '</body>') {\n        val = val.substring(0, val.length - 7);\n      }\n    }\n  } else if (document.implementation != null && document.implementation.createDocument != null) {\n    var xd = document.implementation.createDocument('http://www.w3.org/1999/xhtml', 'html', null);\n    var xb = xd.createElement('body');\n    xd.documentElement.appendChild(xb);\n    var div = document.createElement('div');\n    div.innerHTML = val;\n    var child = div.firstChild;\n    while (child != null) {\n      var next = child.nextSibling;\n      xb.appendChild(xd.adoptNode(child));\n      child = next;\n    }\n    return xb.innerHTML;\n  } else {\n    var ta = document.createElement('textarea');\n\n    // Handles special HTML entities < and > and double escaping\n    // and converts unclosed br, hr and img tags to XHTML\n    // LATER: Convert all unclosed tags\n    ta.innerHTML = val.replace(/&amp;/g, '&amp;amp;').replace(/&#60;/g, '&amp;lt;').replace(/&#62;/g, '&amp;gt;').replace(/&lt;/g, '&amp;lt;').replace(/&gt;/g, '&amp;gt;').replace(/</g, '&lt;').replace(/>/g, '&gt;');\n    val = ta.value.replace(/&/g, '&amp;').replace(/&amp;lt;/g, '&lt;').replace(/&amp;gt;/g, '&gt;').replace(/&amp;amp;/g, '&amp;').replace(/<br>/g, '<br />').replace(/<hr>/g, '<hr />').replace(/(<img[^>]+)>/gm, \"$1 />\");\n  }\n  return val;\n};\n\n/**\r\n * Function: createDiv\r\n *\r\n * Private helper function to create SVG elements\r\n */\nmxSvgCanvas2D.prototype.createDiv = function (str, align, valign, style, overflow, lh) {\n  var s = this.state;\n\n  // Inline block for rendering HTML background over SVG in Safari\n\n  style = 'display:inline-block;font-size:' + s.fontSize + 'px;font-family:' + s.fontFamily + ';color:' + s.fontColor + ';line-height:' + lh + ';' + style;\n  if ((s.fontStyle & _mxConstants[\"default\"].FONT_BOLD) == _mxConstants[\"default\"].FONT_BOLD) {\n    style += 'font-weight:bold;';\n  }\n  if ((s.fontStyle & _mxConstants[\"default\"].FONT_ITALIC) == _mxConstants[\"default\"].FONT_ITALIC) {\n    style += 'font-style:italic;';\n  }\n  if ((s.fontStyle & _mxConstants[\"default\"].FONT_UNDERLINE) == _mxConstants[\"default\"].FONT_UNDERLINE) {\n    style += 'text-decoration:underline;';\n  }\n  if (align == _mxConstants[\"default\"].ALIGN_CENTER) {\n    style += 'text-align:center;';\n  } else if (align == _mxConstants[\"default\"].ALIGN_RIGHT) {\n    style += 'text-align:right;';\n  }\n  var css = '';\n  if (s.fontBackgroundColor != null) {\n    css += 'background-color:' + s.fontBackgroundColor + ';';\n  }\n  if (s.fontBorderColor != null) {\n    css += 'border:1px solid ' + s.fontBorderColor + ';';\n  }\n  var val = str;\n  if (!_mxGraphUtils[\"default\"].isNode(val)) {\n    val = this.convertHtml(val);\n    if (overflow != 'fill' && overflow != 'width') {\n      var valTitle = val && val.replaceAll('\"', \"'\");\n      // Inner div always needed to measure wrapped text\n      val = '<div xmlns=\"http://www.w3.org/1999/xhtml\" class=\"text\" title=\"' + valTitle + '\" style=\"display:inline-block;text-align:inherit;text-decoration:inherit;' + css + '\">' + val + '</div>';\n    } else {\n      style += css;\n    }\n  }\n\n  // Uses DOM API where available. This cannot be used in IE to avoid\n  // an opening and two (!) closing TBODY tags being added to tables.\n  if (!_mxClient[\"default\"].IS_IE && document.createElementNS) {\n    var div = document.createElementNS('http://www.w3.org/1999/xhtml', 'div');\n    div.setAttribute('style', style);\n    if (_mxGraphUtils[\"default\"].isNode(val)) {\n      // Creates a copy for export\n      if (this.root.ownerDocument != document) {\n        div.appendChild(val.cloneNode(true));\n      } else {\n        div.appendChild(val);\n      }\n    } else {\n      div.innerHTML = val;\n    }\n    return div;\n  } else {\n    // Serializes for export\n    if (_mxGraphUtils[\"default\"].isNode(val) && this.root.ownerDocument != document) {\n      val = val.outerHTML;\n    }\n\n    // NOTE: FF 3.6 crashes if content CSS contains \"height:100%\"\n    return _mxGraphUtils[\"default\"].parseXml('<div xmlns=\"http://www.w3.org/1999/xhtml\" style=\"' + style + '\">' + val + '</div>').documentElement;\n  }\n};\n\n/**\r\n * Invalidates the cached offset size for the given node.\r\n */\nmxSvgCanvas2D.prototype.invalidateCachedOffsetSize = function (node) {\n  delete node.firstChild.mxCachedOffsetWidth;\n  delete node.firstChild.mxCachedFinalOffsetWidth;\n  delete node.firstChild.mxCachedFinalOffsetHeight;\n};\n\n/**\r\n * Updates existing DOM nodes for text rendering. LATER: Merge common parts with text function below.\r\n */\nmxSvgCanvas2D.prototype.updateText = function (x, y, w, h, align, valign, wrap, overflow, clip, rotation, node) {\n  if (node != null && node.firstChild != null && node.firstChild.firstChild != null && node.firstChild.firstChild.firstChild != null) {\n    // Uses outer group for opacity and transforms to\n    // fix rendering order in Chrome\n    var group = node.firstChild;\n    var fo = group.firstChild;\n    var div = fo.firstChild;\n    rotation = rotation != null ? rotation : 0;\n    var s = this.state;\n    x += s.dx;\n    y += s.dy;\n    if (clip) {\n      div.style.maxHeight = Math.round(h) + 'px';\n      div.style.maxWidth = Math.round(w) + 'px';\n    } else if (overflow == 'fill') {\n      div.style.width = Math.round(w + 1) + 'px';\n      div.style.height = Math.round(h + 1) + 'px';\n    } else if (overflow == 'width') {\n      div.style.width = Math.round(w + 1) + 'px';\n      if (h > 0) {\n        div.style.maxHeight = Math.round(h) + 'px';\n      }\n    }\n    if (wrap && w > 0) {\n      div.style.width = Math.round(w + 1) + 'px';\n    }\n\n    // Code that depends on the size which is computed after\n    // the element was added to the DOM.\n    var ow = 0;\n    var oh = 0;\n\n    // Padding avoids clipping on border and wrapping for differing font metrics on platforms\n    var padX = 2;\n    var sizeDiv = div;\n    if (sizeDiv.firstChild != null && sizeDiv.firstChild.nodeName == 'DIV') {\n      sizeDiv = sizeDiv.firstChild;\n    }\n    var tmp = group.mxCachedOffsetWidth != null ? group.mxCachedOffsetWidth : sizeDiv.offsetWidth;\n    ow = tmp + padX;\n\n    // Recomputes the height of the element for wrapped width\n    if (wrap && overflow != 'fill') {\n      if (clip) {\n        ow = Math.min(ow, w);\n      }\n      div.style.width = ow + 'px';\n    }\n    ow = (group.mxCachedFinalOffsetWidth != null ? group.mxCachedFinalOffsetWidth : sizeDiv.offsetWidth) + padX;\n    oh = (group.mxCachedFinalOffsetHeight != null ? group.mxCachedFinalOffsetHeight : sizeDiv.offsetHeight) - 2;\n    if (clip) {\n      oh = Math.min(oh, h);\n      ow = Math.min(ow, w);\n    }\n    if (overflow == 'width') {\n      h = oh;\n    } else if (overflow != 'fill') {\n      w = ow;\n      h = oh;\n    }\n    var dx = 0;\n    var dy = 0;\n    if (align == _mxConstants[\"default\"].ALIGN_CENTER) {\n      dx -= w / 2;\n    } else if (align == _mxConstants[\"default\"].ALIGN_RIGHT) {\n      dx -= w;\n    }\n    x += dx;\n\n    // FIXME: LINE_HEIGHT not ideal for all text sizes, fix for export\n    if (valign == _mxConstants[\"default\"].ALIGN_MIDDLE) {\n      dy -= h / 2;\n    } else if (valign == _mxConstants[\"default\"].ALIGN_BOTTOM) {\n      dy -= h;\n    }\n\n    // Workaround for rendering offsets\n    // TODO: Check if export needs these fixes, too\n    if (overflow != 'fill' && _mxClient[\"default\"].IS_FF && _mxClient[\"default\"].IS_WIN) {\n      dy -= 2;\n    }\n    y += dy;\n    var tr = s.scale != 1 ? 'scale(' + s.scale + ')' : '';\n    if (s.rotation != 0 && this.rotateHtml) {\n      tr += 'rotate(' + s.rotation + ',' + w / 2 + ',' + h / 2 + ')';\n      var pt = this.rotatePoint((x + w / 2) * s.scale, (y + h / 2) * s.scale, s.rotation, s.rotationCx, s.rotationCy);\n      x = pt.x - w * s.scale / 2;\n      y = pt.y - h * s.scale / 2;\n    } else {\n      x *= s.scale;\n      y *= s.scale;\n    }\n    if (rotation != 0) {\n      tr += 'rotate(' + rotation + ',' + -dx + ',' + -dy + ')';\n    }\n    group.setAttribute('transform', 'translate(' + Math.round(x) + ',' + Math.round(y) + ')' + tr);\n    fo.setAttribute('width', Math.round(Math.max(1, w)));\n    fo.setAttribute('height', Math.round(Math.max(1, h)));\n  }\n};\n\n/**\r\n * Function: text\r\n *\r\n * Paints the given text. Possible values for format are empty string for plain\r\n * text and html for HTML markup. Note that HTML markup is only supported if\r\n * foreignObject is supported and <foEnabled> is true. (This means IE9 and later\r\n * does currently not support HTML text as part of shapes.)\r\n */\nmxSvgCanvas2D.prototype.text = function (x, y, w, h, str, align, valign, wrap, format, overflow, clip, rotation, dir) {\n  if (this.textEnabled && str != null) {\n    rotation = rotation != null ? rotation : 0;\n    var line = 3;\n    var s = this.state,\n      maxH = Math.round(h),\n      maxW = Math.round(w);\n    var lh = _mxConstants[\"default\"].ABSOLUTE_LINE_HEIGHT ? s.fontSize * _mxConstants[\"default\"].LINE_HEIGHT + 'px' : _mxConstants[\"default\"].LINE_HEIGHT * this.lineHeightCorrection;\n    x += s.dx;\n    y += s.dy;\n    if (this.foEnabled && format == 'html') {\n      var style = 'vertical-align:top;';\n      if (clip) {\n        style += 'overflow:hidden;max-height:' + maxH + 'px;max-width:' + maxW + 'px;';\n        if (wrap) {\n          line = Math.floor(maxH / (s.fontSize * lh)) || 1;\n          lh = (maxH / (line * s.fontSize)).toFixed(2);\n        }\n      } else if (overflow == 'fill') {\n        style += 'width:' + Math.round(w + 1) + 'px;height:' + Math.round(h + 1) + 'px;overflow:hidden;';\n      } else if (overflow == 'width') {\n        style += 'width:' + Math.round(w + 1) + 'px;';\n        if (h > 0) {\n          style += 'max-height:' + Math.round(h) + 'px;overflow:hidden;';\n        }\n      }\n      if (wrap && w > 0) {\n        style += 'width:' + Math.round(w + 1) + 'px;white-space:normal;word-wrap:' + _mxConstants[\"default\"].WORD_WRAP + ';word-break:break-all;';\n      } else {\n        style += 'white-space:nowrap;';\n      }\n\n      // Uses outer group for opacity and transforms to\n      // fix rendering order in Chrome\n      var group = this.createElement('g');\n      if (s.alpha < 1) {\n        group.setAttribute('opacity', s.alpha);\n      }\n      var fo = document.createElementNS(_mxConstants[\"default\"].NS_SVG, 'foreignObject');\n      fo.setAttribute('style', 'overflow:visible;');\n      fo.setAttribute('pointer-events', 'all');\n      var div = this.createDiv(str, align, valign, style, overflow, lh);\n\n      // Ignores invalid XHTML labels\n      if (div == null) {\n        return;\n      } else if (dir != null) {\n        div.setAttribute('dir', dir);\n      }\n      group.appendChild(fo);\n      this.root.appendChild(group);\n\n      // Code that depends on the size which is computed after\n      // the element was added to the DOM.\n      var ow = 0;\n      var oh = 0;\n\n      // Padding avoids clipping on border and wrapping for differing font metrics on platforms\n      var padX = 2;\n      var padY = 2;\n\n      // NOTE: IE is always export as it does not support foreign objects\n      if (_mxClient[\"default\"].IS_IE && (document.documentMode == 9 || !_mxClient[\"default\"].IS_SVG)) {\n        // Handles non-standard namespace for getting size in IE\n        var clone = document.createElement('div');\n        clone.style.cssText = div.getAttribute('style');\n        clone.style.display = _mxClient[\"default\"].IS_QUIRKS ? 'inline' : 'inline-block';\n        clone.style.position = 'absolute';\n        clone.style.visibility = 'hidden';\n\n        // Inner DIV is needed for text measuring\n        var div2 = document.createElement('div');\n        div2.style.display = _mxClient[\"default\"].IS_QUIRKS ? 'inline' : 'inline-block';\n        div2.style.wordWrap = _mxConstants[\"default\"].WORD_WRAP;\n        div2.innerHTML = mxUtils.isNode(str) ? str.outerHTML : str;\n        clone.appendChild(div2);\n        document.body.appendChild(clone);\n\n        // Workaround for different box models\n        if (document.documentMode != 8 && document.documentMode != 9 && s.fontBorderColor != null) {\n          padX += 2;\n          padY += 2;\n        }\n        if (wrap && w > 0) {\n          var tmp = div2.offsetWidth;\n\n          // Workaround for adding padding twice in IE8/IE9 standards mode if label is wrapped\n          var padDx = 0;\n\n          // For export, if no wrapping occurs, we add a large padding to make\n          // sure there is no wrapping even if the text metrics are different.\n          // This adds support for text metrics on different operating systems.\n          // Disables wrapping if text is not wrapped for given width\n          if (!clip && w > 0 && this.root.ownerDocument != document && overflow != 'fill') {\n            var ws = clone.style.whiteSpace;\n            div2.style.whiteSpace = 'nowrap';\n            if (tmp < div2.offsetWidth) {\n              clone.style.whiteSpace = ws;\n            }\n          }\n          if (clip) {\n            tmp = Math.min(tmp, w);\n          }\n          clone.style.width = tmp + 'px';\n\n          // Padding avoids clipping on border\n          ow = div2.offsetWidth + padX + padDx;\n          oh = div2.offsetHeight + padY;\n\n          // Overrides the width of the DIV via XML DOM by using the\n          // clone DOM style, getting the CSS text for that and\n          // then setting that on the DIV via setAttribute\n          clone.style.display = 'inline-block';\n          clone.style.position = '';\n          clone.style.visibility = '';\n          clone.style.width = ow + 'px';\n          div.setAttribute('style', clone.style.cssText);\n        } else {\n          // Padding avoids clipping on border\n          ow = div2.offsetWidth + padX;\n          oh = div2.offsetHeight + padY;\n        }\n        clone.parentNode.removeChild(clone);\n        fo.appendChild(div);\n      } else {\n        // Uses document for text measuring during export\n        if (this.root.ownerDocument != document) {\n          div.style.visibility = 'hidden';\n          document.body.appendChild(div);\n        } else {\n          fo.appendChild(div);\n        }\n        var sizeDiv = div;\n        if (sizeDiv.firstChild != null && sizeDiv.firstChild.nodeName == 'DIV') {\n          sizeDiv = sizeDiv.firstChild;\n          if (wrap && div.style.wordWrap == 'break-word') {\n            sizeDiv.style.width = '100%';\n          }\n        }\n        var tmp = sizeDiv.offsetWidth;\n\n        // Workaround for text measuring in hidden containers\n        if (tmp == 0 && div.parentNode == fo) {\n          div.style.visibility = 'hidden';\n          document.body.appendChild(div);\n          tmp = sizeDiv.offsetWidth;\n        }\n        if (this.cacheOffsetSize) {\n          group.mxCachedOffsetWidth = tmp;\n        }\n\n        // Disables wrapping if text is not wrapped for given width\n        if (!clip && wrap && w > 0 && this.root.ownerDocument != document && overflow != 'fill' && overflow != 'width') {\n          var ws = div.style.whiteSpace;\n          div.style.whiteSpace = 'nowrap';\n          if (tmp < sizeDiv.offsetWidth) {\n            div.style.whiteSpace = ws;\n          }\n        }\n        ow = tmp + padX - 1;\n\n        // Recomputes the height of the element for wrapped width\n        if (wrap && overflow != 'fill' && overflow != 'width') {\n          if (clip) {\n            ow = Math.min(ow, w);\n          }\n          div.style.width = ow + 'px';\n        }\n        ow = sizeDiv.offsetWidth;\n        oh = sizeDiv.offsetHeight;\n        if (this.cacheOffsetSize) {\n          group.mxCachedFinalOffsetWidth = ow;\n          group.mxCachedFinalOffsetHeight = oh;\n        }\n        oh -= padY;\n        var textDiv = div.firstElementChild;\n        if (clip && wrap && oh > maxH && textDiv) {\n          textDiv.style.display = '-webkit-box';\n          textDiv.style['-webkit-box-orient'] = 'vertical';\n          textDiv.style['-webkit-line-clamp'] = line;\n          textDiv.style.overflow = 'hidden';\n        }\n        if (div.parentNode != fo) {\n          fo.appendChild(div);\n          div.style.visibility = '';\n        }\n      }\n      if (clip) {\n        oh = Math.min(oh, h);\n        ow = Math.min(ow, w);\n      }\n      if (overflow == 'width') {\n        h = oh;\n      } else if (overflow != 'fill') {\n        w = ow;\n        h = oh;\n      }\n      if (s.alpha < 1) {\n        group.setAttribute('opacity', s.alpha);\n      }\n      var dx = 0;\n      var dy = 0;\n      if (align == _mxConstants[\"default\"].ALIGN_CENTER) {\n        dx -= w / 2;\n      } else if (align == _mxConstants[\"default\"].ALIGN_RIGHT) {\n        dx -= w;\n      }\n      x += dx;\n\n      // FIXME: LINE_HEIGHT not ideal for all text sizes, fix for export\n      if (valign == _mxConstants[\"default\"].ALIGN_MIDDLE) {\n        dy -= h / 2;\n      } else if (valign == _mxConstants[\"default\"].ALIGN_BOTTOM) {\n        dy -= h;\n      }\n\n      // Workaround for rendering offsets\n      // TODO: Check if export needs these fixes, too\n      //if (this.root.ownerDocument == document)\n      if (overflow != 'fill' && _mxClient[\"default\"].IS_FF && _mxClient[\"default\"].IS_WIN) {\n        dy -= 2;\n      }\n      y += dy;\n      var tr = s.scale != 1 ? 'scale(' + s.scale + ')' : '';\n      if (s.rotation != 0 && this.rotateHtml) {\n        tr += 'rotate(' + s.rotation + ',' + w / 2 + ',' + h / 2 + ')';\n        var pt = this.rotatePoint((x + w / 2) * s.scale, (y + h / 2) * s.scale, s.rotation, s.rotationCx, s.rotationCy);\n        x = pt.x - w * s.scale / 2;\n        y = pt.y - h * s.scale / 2;\n      } else {\n        x *= s.scale;\n        y *= s.scale;\n      }\n      if (rotation != 0) {\n        tr += 'rotate(' + rotation + ',' + -dx + ',' + -dy + ')';\n      }\n      group.setAttribute('transform', 'translate(' + (Math.round(x) + this.foOffset) + ',' + (Math.round(y) + this.foOffset) + ')' + tr);\n      fo.setAttribute('width', Math.round(Math.max(1, w)));\n      fo.setAttribute('height', Math.round(Math.max(1, h)));\n\n      // Adds alternate content if foreignObject not supported in viewer\n      if (this.root.ownerDocument != document) {\n        var alt = this.createAlternateContent(fo, x, y, w, h, str, align, valign, wrap, format, overflow, clip, rotation);\n        if (alt != null) {\n          fo.setAttribute('requiredFeatures', 'http://www.w3.org/TR/SVG11/feature#Extensibility');\n          var sw = this.createElement('switch');\n          sw.appendChild(fo);\n          sw.appendChild(alt);\n          group.appendChild(sw);\n        }\n      }\n    } else {\n      this.plainText(x, y, w, h, str, align, valign, wrap, overflow, clip, rotation, dir);\n    }\n  }\n};\n\n/**\r\n * Function: createClip\r\n *\r\n * Creates a clip for the given coordinates.\r\n */\nmxSvgCanvas2D.prototype.createClip = function (x, y, w, h) {\n  x = Math.round(x);\n  y = Math.round(y);\n  w = Math.round(w);\n  h = Math.round(h);\n  var id = 'mx-clip-' + x + '-' + y + '-' + w + '-' + h;\n  var counter = 0;\n  var tmp = id + '-' + counter;\n\n  // Resolves ID conflicts\n  while (document.getElementById(tmp) != null) {\n    tmp = id + '-' + ++counter;\n  }\n  clip = this.createElement('clipPath');\n  clip.setAttribute('id', tmp);\n  var rect = this.createElement('rect');\n  rect.setAttribute('x', x);\n  rect.setAttribute('y', y);\n  rect.setAttribute('width', w);\n  rect.setAttribute('height', h);\n  clip.appendChild(rect);\n  return clip;\n};\n\n/**\r\n * Function: text\r\n *\r\n * Paints the given text. Possible values for format are empty string for\r\n * plain text and html for HTML markup.\r\n */\nmxSvgCanvas2D.prototype.plainText = function (x, y, w, h, str, align, valign, wrap, overflow, clip, rotation, dir) {\n  rotation = rotation != null ? rotation : 0;\n  var s = this.state;\n  var size = s.fontSize;\n  var node = this.createElement('g');\n  var tr = s.transform || '';\n  this.updateFont(node);\n\n  // Non-rotated text\n  if (rotation != 0) {\n    tr += 'rotate(' + rotation + ',' + this.format(x * s.scale) + ',' + this.format(y * s.scale) + ')';\n  }\n  if (dir != null) {\n    node.setAttribute('direction', dir);\n  }\n  if (clip && w > 0 && h > 0) {\n    var cx = x;\n    var cy = y;\n    if (align == _mxConstants[\"default\"].ALIGN_CENTER) {\n      cx -= w / 2;\n    } else if (align == _mxConstants[\"default\"].ALIGN_RIGHT) {\n      cx -= w;\n    }\n    if (overflow != 'fill') {\n      if (valign == _mxConstants[\"default\"].ALIGN_MIDDLE) {\n        cy -= h / 2;\n      } else if (valign == _mxConstants[\"default\"].ALIGN_BOTTOM) {\n        cy -= h;\n      }\n    }\n\n    // LATER: Remove spacing from clip rectangle\n    var c = this.createClip(cx * s.scale - 2, cy * s.scale - 2, w * s.scale + 4, h * s.scale + 4);\n    if (this.defs != null) {\n      this.defs.appendChild(c);\n    } else {\n      // Makes sure clip is removed with referencing node\n      this.root.appendChild(c);\n    }\n    if (!_mxClient[\"default\"].IS_CHROME_APP && !_mxClient[\"default\"].IS_IE && !_mxClient[\"default\"].IS_IE11 && !_mxClient[\"default\"].IS_EDGE && this.root.ownerDocument == document) {\n      // Workaround for potential base tag\n      var base = this.getBaseUrl().replace(/([\\(\\)])/g, '\\\\$1');\n      node.setAttribute('clip-path', 'url(' + base + '#' + c.getAttribute('id') + ')');\n    } else {\n      node.setAttribute('clip-path', 'url(#' + c.getAttribute('id') + ')');\n    }\n  }\n\n  // Default is left\n  var anchor = align == _mxConstants[\"default\"].ALIGN_RIGHT ? 'end' : align == _mxConstants[\"default\"].ALIGN_CENTER ? 'middle' : 'start';\n\n  // Text-anchor start is default in SVG\n  if (anchor != 'start') {\n    node.setAttribute('text-anchor', anchor);\n  }\n  if (!this.styleEnabled || size != _mxConstants[\"default\"].DEFAULT_FONTSIZE) {\n    node.setAttribute('font-size', size * s.scale + 'px');\n  }\n  if (tr.length > 0) {\n    node.setAttribute('transform', tr);\n  }\n  if (s.alpha < 1) {\n    node.setAttribute('opacity', s.alpha);\n  }\n  var lines = str.split('\\n');\n  var lh = Math.round(size * _mxConstants[\"default\"].LINE_HEIGHT);\n  var textHeight = size + (lines.length - 1) * lh;\n  var cy = y + size - 1;\n  if (valign == _mxConstants[\"default\"].ALIGN_MIDDLE) {\n    if (overflow == 'fill') {\n      cy -= h / 2;\n    } else {\n      var dy = (this.matchHtmlAlignment && clip && h > 0 ? Math.min(textHeight, h) : textHeight) / 2;\n      cy -= dy + 1;\n    }\n  } else if (valign == _mxConstants[\"default\"].ALIGN_BOTTOM) {\n    if (overflow == 'fill') {\n      cy -= h;\n    } else {\n      var dy = this.matchHtmlAlignment && clip && h > 0 ? Math.min(textHeight, h) : textHeight;\n      cy -= dy + 2;\n    }\n  }\n  for (var i = 0; i < lines.length; i++) {\n    // Workaround for bounding box of empty lines and spaces\n    if (lines[i].length > 0 && _mxGraphUtils[\"default\"].trim(lines[i]).length > 0) {\n      var text = this.createElement('text');\n      // LATER: Match horizontal HTML alignment\n      text.setAttribute('x', this.format(x * s.scale) + this.textOffset);\n      text.setAttribute('y', this.format(cy * s.scale) + this.textOffset);\n      _mxGraphUtils[\"default\"].write(text, lines[i]);\n      node.appendChild(text);\n    }\n    cy += lh;\n  }\n  this.root.appendChild(node);\n  this.addTextBackground(node, str, x, y, w, overflow == 'fill' ? h : textHeight, align, valign, overflow);\n};\n\n/**\r\n * Function: updateFont\r\n *\r\n * Updates the text properties for the given node. (NOTE: For this to work in\r\n * IE, the given node must be a text or tspan element.)\r\n */\nmxSvgCanvas2D.prototype.updateFont = function (node) {\n  var s = this.state;\n  node.setAttribute('fill', s.fontColor);\n  if (!this.styleEnabled || s.fontFamily != _mxConstants[\"default\"].DEFAULT_FONTFAMILY) {\n    node.setAttribute('font-family', s.fontFamily);\n  }\n  if ((s.fontStyle & _mxConstants[\"default\"].FONT_BOLD) == _mxConstants[\"default\"].FONT_BOLD) {\n    node.setAttribute('font-weight', 'bold');\n  }\n  if ((s.fontStyle & _mxConstants[\"default\"].FONT_ITALIC) == _mxConstants[\"default\"].FONT_ITALIC) {\n    node.setAttribute('font-style', 'italic');\n  }\n  if ((s.fontStyle & _mxConstants[\"default\"].FONT_UNDERLINE) == _mxConstants[\"default\"].FONT_UNDERLINE) {\n    node.setAttribute('text-decoration', 'underline');\n  }\n};\n\n/**\r\n * Function: addTextBackground\r\n *\r\n * Background color and border\r\n */\nmxSvgCanvas2D.prototype.addTextBackground = function (node, str, x, y, w, h, align, valign, overflow) {\n  var s = this.state;\n  if (s.fontBackgroundColor != null || s.fontBorderColor != null) {\n    var bbox = null;\n    if (overflow == 'fill' || overflow == 'width') {\n      if (align == _mxConstants[\"default\"].ALIGN_CENTER) {\n        x -= w / 2;\n      } else if (align == _mxConstants[\"default\"].ALIGN_RIGHT) {\n        x -= w;\n      }\n      if (valign == _mxConstants[\"default\"].ALIGN_MIDDLE) {\n        y -= h / 2;\n      } else if (valign == _mxConstants[\"default\"].ALIGN_BOTTOM) {\n        y -= h;\n      }\n      bbox = new _mxRectangle[\"default\"]((x + 1) * s.scale, y * s.scale, (w - 2) * s.scale, (h + 2) * s.scale);\n    } else if (node.getBBox != null && this.root.ownerDocument == document) {\n      // Uses getBBox only if inside document for correct size\n      try {\n        bbox = node.getBBox();\n        var ie = _mxClient[\"default\"].IS_IE && _mxClient[\"default\"].IS_SVG;\n        bbox = new _mxRectangle[\"default\"](bbox.x, bbox.y + (ie ? 0 : 1), bbox.width, bbox.height + (ie ? 1 : 0));\n      } catch (e) {\n        // Ignores NS_ERROR_FAILURE in FF if container display is none.\n      }\n    } else {\n      // Computes size if not in document or no getBBox available\n      var div = document.createElement('div');\n\n      // Wrapping and clipping can be ignored here\n      div.style.lineHeight = _mxConstants[\"default\"].ABSOLUTE_LINE_HEIGHT ? s.fontSize * _mxConstants[\"default\"].LINE_HEIGHT + 'px' : _mxConstants[\"default\"].LINE_HEIGHT;\n      div.style.fontSize = s.fontSize + 'px';\n      div.style.fontFamily = s.fontFamily;\n      div.style.whiteSpace = 'nowrap';\n      div.style.position = 'absolute';\n      div.style.visibility = 'hidden';\n      div.style.display = _mxClient[\"default\"].IS_QUIRKS ? 'inline' : 'inline-block';\n      div.style.zoom = '1';\n      if ((s.fontStyle & _mxConstants[\"default\"].FONT_BOLD) == _mxConstants[\"default\"].FONT_BOLD) {\n        div.style.fontWeight = 'bold';\n      }\n      if ((s.fontStyle & _mxConstants[\"default\"].FONT_ITALIC) == _mxConstants[\"default\"].FONT_ITALIC) {\n        div.style.fontStyle = 'italic';\n      }\n      str = _mxGraphUtils[\"default\"].htmlEntities(str, false);\n      div.innerHTML = str.replace(/\\n/g, '<br/>');\n      document.body.appendChild(div);\n      var w = div.offsetWidth;\n      var h = div.offsetHeight;\n      div.parentNode.removeChild(div);\n      if (align == _mxConstants[\"default\"].ALIGN_CENTER) {\n        x -= w / 2;\n      } else if (align == _mxConstants[\"default\"].ALIGN_RIGHT) {\n        x -= w;\n      }\n      if (valign == _mxConstants[\"default\"].ALIGN_MIDDLE) {\n        y -= h / 2;\n      } else if (valign == _mxConstants[\"default\"].ALIGN_BOTTOM) {\n        y -= h;\n      }\n      bbox = new _mxRectangle[\"default\"]((x + 1) * s.scale, (y + 2) * s.scale, w * s.scale, (h + 1) * s.scale);\n    }\n    if (bbox != null) {\n      var n = this.createElement('rect');\n      n.setAttribute('fill', s.fontBackgroundColor || 'none');\n      n.setAttribute('stroke', s.fontBorderColor || 'none');\n      n.setAttribute('x', Math.floor(bbox.x - 1));\n      n.setAttribute('y', Math.floor(bbox.y - 1));\n      n.setAttribute('width', Math.ceil(bbox.width + 2));\n      n.setAttribute('height', Math.ceil(bbox.height));\n      var sw = s.fontBorderColor != null ? Math.max(1, this.format(s.scale)) : 0;\n      n.setAttribute('stroke-width', sw);\n\n      // Workaround for crisp rendering - only required if not exporting\n      if (this.root.ownerDocument == document && _mxGraphUtils[\"default\"].mod(sw, 2) == 1) {\n        n.setAttribute('transform', 'translate(0.5, 0.5)');\n      }\n      node.insertBefore(n, node.firstChild);\n    }\n  }\n};\n\n/**\r\n * Function: stroke\r\n *\r\n * Paints the outline of the current path.\r\n */\nmxSvgCanvas2D.prototype.stroke = function () {\n  this.addNode(false, true);\n};\n\n/**\r\n * Function: fill\r\n *\r\n * Fills the current path.\r\n */\nmxSvgCanvas2D.prototype.fill = function () {\n  this.addNode(true, false);\n};\n\n/**\r\n * Function: fillAndStroke\r\n *\r\n * Fills and paints the outline of the current path.\r\n */\nmxSvgCanvas2D.prototype.fillAndStroke = function () {\n  this.addNode(true, true);\n};\nmxSvgCanvas2D.prototype.setTransform = function (value) {\n  this.state.transform = value;\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n *\r\n * Class: mxVmlCanvas2D\r\n *\r\n * Implements a canvas to be used for rendering VML. Here is an example of implementing a\r\n * fallback for SVG images which are not supported in VML-based browsers.\r\n *\r\n * (code)\r\n * var mxVmlCanvas2DImage = mxVmlCanvas2D.prototype.image;\r\n * mxVmlCanvas2D.prototype.image = function(x, y, w, h, src, aspect, flipH, flipV)\r\n * {\r\n *   if (src.substring(src.length - 4, src.length) == '.svg')\r\n *   {\r\n *     src = 'http://www.jgraph.com/images/mxgraph.gif';\r\n *   }\r\n *\r\n *   mxVmlCanvas2DImage.apply(this, arguments);\r\n * };\r\n * (end)\r\n *\r\n * To disable anti-aliasing in the output, use the following code.\r\n *\r\n * (code)\r\n * document.createStyleSheet().cssText = mxClient.VML_PREFIX + '\\\\:*{antialias:false;)}';\r\n * (end)\r\n *\r\n * A description of the public API is available in <mxXmlCanvas2D>. Note that\r\n * there is a known issue in VML where gradients are painted using the outer\r\n * bounding box of rotated shapes, not the actual bounds of the shape. See\r\n * also <text> for plain text label restrictions in shapes for VML.\r\n */\nvar _default = exports[\"default\"] = mxSvgCanvas2D;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxSvgCanvas2D.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxSvgStencil.js":
/*!***********************************************!*\
  !*** ./src/workflow/mxClient/mxSvgStencil.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.concat.js */ \"../../node_modules/core-js/modules/es.array.concat.js\");\n__webpack_require__(/*! core-js/modules/es.array.fill.js */ \"../../node_modules/core-js/modules/es.array.fill.js\");\n__webpack_require__(/*! core-js/modules/es.array.for-each.js */ \"../../node_modules/core-js/modules/es.array.for-each.js\");\n__webpack_require__(/*! core-js/modules/es.number.constructor.js */ \"../../node_modules/core-js/modules/es.number.constructor.js\");\n__webpack_require__(/*! core-js/modules/es.number.to-fixed.js */ \"../../node_modules/core-js/modules/es.number.to-fixed.js\");\n__webpack_require__(/*! core-js/modules/es.object.to-string.js */ \"../../node_modules/core-js/modules/es.object.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.regexp.exec.js */ \"../../node_modules/core-js/modules/es.regexp.exec.js\");\n__webpack_require__(/*! core-js/modules/es.string.replace.js */ \"../../node_modules/core-js/modules/es.string.replace.js\");\nvar _mxStencil = _interopRequireDefault(__webpack_require__(/*! ./mxStencil */ \"./src/workflow/mxClient/mxStencil.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ./mxConstants */ \"./src/workflow/mxClient/mxConstants.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxSvgStencil(desc) {\n  _mxStencil[\"default\"].call(this, desc);\n}\n_mxGraphUtils[\"default\"].extend(mxSvgStencil, _mxStencil[\"default\"]);\nmxSvgStencil.prototype.defs = null;\nmxSvgStencil.prototype.node = null;\nmxSvgStencil.prototype.width = null;\nmxSvgStencil.prototype.height = null;\nmxSvgStencil.prototype.parseDescription = function () {\n  var desc = this.desc;\n  this.defs = desc.querySelector(\"defs\");\n  this.node = desc.querySelector(\"g\");\n  //w、h对应显示的宽高\n  this.w0 = Number(this.desc.getAttribute('w') || 100);\n  this.h0 = Number(this.desc.getAttribute('h') || 100);\n  //width、height对应实际图形的宽高\n  this.width = Number(this.desc.getAttribute('width') || 100);\n  this.height = Number(this.desc.getAttribute('height') || 100);\n  //inwidth、inheight对应嵌入到父节点中的宽高\n  this.inwidth = Number(this.desc.getAttribute('inwidth') || 100);\n  this.inheight = Number(this.desc.getAttribute('inheight') || 100);\n  //对应的图形,例如Lane和Pool对应的都是swimlane\n  this.shape = this.desc.getAttribute('shape');\n};\nmxSvgStencil.prototype.drawShape = function (canvas, shape, x, y, w, h) {\n  var s = canvas.state || {\n      dx: 0,\n      dy: 0\n    },\n    sx = (w / this.width).toFixed(2),\n    sy = (h / this.height).toFixed(2),\n    node = null;\n  x += s.dx;\n  y += s.dy;\n  if (s.transform) {\n    var transform = canvas.root.getAttribute(\"transform\") || \"\";\n    canvas.root.setAttribute(\"transform\", \"\".concat(transform, \" \").concat(s.transform));\n  }\n  var isCompleteIcon = shape.style && shape.style.shape == \"ierp.billrelation.IconComplete\";\n  if (s.alpha != null && s.alpha != undefined && !isCompleteIcon) {\n    var style = canvas.root.getAttribute(\"style\") || \"\";\n    style = style.replace(/\\s*opacity:\\s*\\d(\\.\\d)?;?/, '');\n    canvas.root.setAttribute(\"style\", \"\".concat(style, \" opacity:\").concat(s.alpha, \";\"));\n  }\n  this.node.setAttribute(\"transform\", \"translate(\".concat(x, \", \").concat(y, \") scale(\").concat(sx, \", \").concat(sy, \")\"));\n  this.node.setAttribute(\"id\", shape.state.cell.mxObjectId);\n  this.addDefsElement(canvas);\n  node = this.node.cloneNode(true);\n  if (isCompleteIcon) {\n    //单据关系图线上图标特殊处理透明度\n    var opacity = shape.opacity || 100;\n    var circle = node.querySelector(\"path[fill='#1BA854']\");\n    var tick = node.querySelector(\"polygon[fill='#1BA854']\");\n    _mxGraphUtils[\"default\"].setOpacity(circle, opacity);\n    _mxGraphUtils[\"default\"].setOpacity(tick, opacity);\n  }\n  this.mergeProperties(node, shape);\n  canvas.root.appendChild(node);\n};\nmxSvgStencil.prototype.addDefsElement = function (canvas) {\n  var defs = this.defs;\n  if (!defs) {\n    return;\n  }\n  var children = defs.children || defs.childNodes,\n    rootDefs = document.querySelector('svg.defs defs');\n  Array.prototype.forEach.call(children, function (child) {\n    //Node.ELEMENT_NODE\n    if (child.nodeType === 1 && !rootDefs.querySelector('[id=\"' + child.getAttribute('id') + '\"]')) {\n      rootDefs.appendChild(child.cloneNode(true));\n    }\n  });\n};\nmxSvgStencil.prototype.mergeProperties = function (node, shape) {\n  var outerElt = null,\n    strokeColor = shape.stroke;\n  node.setAttribute(\"fill\", shape.fill || 'none');\n  if (strokeColor) {\n    outerElt = node.querySelector('.outer');\n    (outerElt ? outerElt : node).setAttribute(\"stroke\", strokeColor);\n  }\n  //TODO: 其他属性\n  /*node.setAttribute(\"fill-opacity\", shape.fillOpacity);\n  node.setAttribute(\"opacity\", shape.opacity);\n  node.setAttribute(\"stroke-width\", shape.strokewidth);\n  node.setAttribute(\"stroke-opacity\", shape.strokeOpacity);*/\n};\nvar _default = exports[\"default\"] = mxSvgStencil;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxSvgStencil.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxSwimlane.js":
/*!*********************************************!*\
  !*** ./src/workflow/mxClient/mxSwimlane.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.fill.js */ \"../../node_modules/core-js/modules/es.array.fill.js\");\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxRectangle = _interopRequireDefault(__webpack_require__(/*! ./mxRectangle.js */ \"./src/workflow/mxClient/mxRectangle.js\"));\nvar _mxShape = _interopRequireDefault(__webpack_require__(/*! ./mxShape.js */ \"./src/workflow/mxClient/mxShape.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ./mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxSwimlane(bounds, fill, stroke, strokewidth) {\n  _mxShape[\"default\"].call(this);\n  this.bounds = bounds;\n  this.fill = fill;\n  this.stroke = stroke;\n  this.strokewidth = strokewidth != null ? strokewidth : 1;\n}\n;\n\n/**\r\n * Extends mxShape.\r\n */\n_mxGraphUtils[\"default\"].extend(mxSwimlane, _mxShape[\"default\"]);\n\n/**\r\n * Variable: imageSize\r\n *\r\n * Default imagewidth and imageheight if an image but no imagewidth\r\n * and imageheight are defined in the style. Value is 16.\r\n */\nmxSwimlane.prototype.imageSize = 16;\n\n/**\r\n * Function: getGradientBounds\r\n *\r\n * Returns the bounding box for the gradient box for this shape.\r\n */\nmxSwimlane.prototype.getTitleSize = function () {\n  return Math.max(0, _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_STARTSIZE, _mxConstants[\"default\"].DEFAULT_STARTSIZE));\n};\n\n/**\r\n * Function: getGradientBounds\r\n *\r\n * Returns the bounding box for the gradient box for this shape.\r\n */\nmxSwimlane.prototype.getLabelBounds = function (rect) {\n  var start = this.getTitleSize();\n  var bounds = new _mxRectangle[\"default\"](rect.x, rect.y, rect.width, rect.height);\n  var horizontal = this.isHorizontal();\n  var flipH = _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_FLIPH, 0) == 1;\n  var flipV = _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_FLIPV, 0) == 1;\n\n  // East is default\n  var shapeVertical = this.direction == _mxConstants[\"default\"].DIRECTION_NORTH || this.direction == _mxConstants[\"default\"].DIRECTION_SOUTH;\n  var realHorizontal = horizontal == !shapeVertical;\n  var realFlipH = !realHorizontal && flipH != (this.direction == _mxConstants[\"default\"].DIRECTION_SOUTH || this.direction == _mxConstants[\"default\"].DIRECTION_WEST);\n  var realFlipV = realHorizontal && flipV != (this.direction == _mxConstants[\"default\"].DIRECTION_SOUTH || this.direction == _mxConstants[\"default\"].DIRECTION_WEST);\n\n  // Shape is horizontal\n  if (!shapeVertical) {\n    var tmp = Math.min(bounds.height, start * this.scale);\n    if (realFlipH || realFlipV) {\n      bounds.y += bounds.height - tmp;\n    }\n    bounds.height = tmp;\n  } else {\n    var tmp = Math.min(bounds.width, start * this.scale);\n    if (realFlipH || realFlipV) {\n      bounds.x += bounds.width - tmp;\n    }\n    bounds.width = tmp;\n  }\n  return bounds;\n};\n\n/**\r\n * Function: getGradientBounds\r\n *\r\n * Returns the bounding box for the gradient box for this shape.\r\n */\nmxSwimlane.prototype.getGradientBounds = function (c, x, y, w, h) {\n  var start = this.getTitleSize();\n  if (this.isHorizontal()) {\n    start = Math.min(start, h);\n    return new _mxRectangle[\"default\"](x, y, w, start);\n  } else {\n    start = Math.min(start, w);\n    return new _mxRectangle[\"default\"](x, y, start, h);\n  }\n};\n\n/**\r\n * Function: getArcSize\r\n *\r\n * Returns the arcsize for the swimlane.\r\n */\nmxSwimlane.prototype.getArcSize = function (w, h, start) {\n  var f = _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_ARCSIZE, _mxConstants[\"default\"].RECTANGLE_ROUNDING_FACTOR * 100) / 100;\n  return start * f * 3;\n};\n\n/**\r\n * Function: paintVertexShape\r\n *\r\n * Paints the swimlane vertex shape.\r\n */\nmxSwimlane.prototype.isHorizontal = function () {\n  return _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_HORIZONTAL, 1) == 1;\n};\n\n/**\r\n * Function: paintVertexShape\r\n *\r\n * Paints the swimlane vertex shape.\r\n */\nmxSwimlane.prototype.paintVertexShape = function (c, x, y, w, h, shape) {\n  var start = this.getTitleSize();\n  var fill = _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_SWIMLANE_FILLCOLOR, _mxConstants[\"default\"].NONE);\n  var swimlaneLine = _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_SWIMLANE_LINE, 1) == 1;\n  var r = 0;\n  if (this.isHorizontal()) {\n    start = Math.min(start, h);\n  } else {\n    start = Math.min(start, w);\n  }\n  c.translate(x, y);\n  if (!this.isRounded) {\n    this.paintSwimlane(c, x, y, w, h, start, fill, swimlaneLine);\n  } else {\n    r = this.getArcSize(w, h, start);\n    this.paintRoundedSwimlane(c, x, y, w, h, start, r, fill, swimlaneLine);\n  }\n  var sep = _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_SEPARATORCOLOR, _mxConstants[\"default\"].NONE);\n  this.paintSeparator(c, x, y, w, h, start, sep);\n  if (this.image != null) {\n    var bounds = this.getImageBounds(x, y, w, h);\n    c.image(bounds.x - x, bounds.y - y, bounds.width, bounds.height, this.image, false, false, false);\n  }\n  if (this.glass) {\n    c.setShadow(false);\n    this.paintGlassEffect(c, 0, 0, w, start, r);\n  }\n\n  //同mxSvgStencil的drawShape\n  this.node.setAttribute(\"id\", shape.state.cell.mxObjectId);\n};\n\n/**\r\n * Function: paintSwimlane\r\n *\r\n * Paints the swimlane vertex shape.\r\n */\nmxSwimlane.prototype.paintSwimlane = function (c, x, y, w, h, start, fill, swimlaneLine) {\n  if (fill != _mxConstants[\"default\"].NONE) {\n    c.save();\n    c.setFillColor(fill);\n    c.rect(0, 0, w, h);\n    c.fillAndStroke();\n    c.restore();\n    c.setShadow(false);\n  }\n  c.begin();\n  if (this.isHorizontal()) {\n    c.moveTo(0, start);\n    c.lineTo(0, 0);\n    c.lineTo(w, 0);\n    c.lineTo(w, start);\n    if (swimlaneLine || start >= h) {\n      c.close();\n    }\n    c.fillAndStroke();\n\n    // Transparent content area\n    if (start < h && fill == _mxConstants[\"default\"].NONE) {\n      c.pointerEvents = false;\n      c.begin();\n      c.moveTo(0, start);\n      c.lineTo(0, h);\n      c.lineTo(w, h);\n      c.lineTo(w, start);\n      c.stroke();\n    }\n  } else {\n    c.moveTo(start, 0);\n    c.lineTo(0, 0);\n    c.lineTo(0, h);\n    c.lineTo(start, h);\n    if (swimlaneLine || start >= w) {\n      c.close();\n    }\n    c.fillAndStroke();\n\n    // Transparent content area\n    if (start < w && fill == _mxConstants[\"default\"].NONE) {\n      c.pointerEvents = false;\n      c.begin();\n      c.moveTo(start, 0);\n      c.lineTo(w, 0);\n      c.lineTo(w, h);\n      c.lineTo(start, h);\n      c.stroke();\n    }\n  }\n};\n\n/**\r\n * Function: paintRoundedSwimlane\r\n *\r\n * Paints the swimlane vertex shape.\r\n */\nmxSwimlane.prototype.paintRoundedSwimlane = function (c, x, y, w, h, start, r, fill, swimlaneLine) {\n  if (fill != _mxConstants[\"default\"].NONE) {\n    c.save();\n    c.setFillColor(fill);\n    c.roundrect(0, 0, w, h, r, r);\n    c.fillAndStroke();\n    c.restore();\n    c.setShadow(false);\n  }\n  c.begin();\n  if (this.isHorizontal()) {\n    c.moveTo(w, start);\n    c.lineTo(w, r);\n    c.quadTo(w, 0, w - Math.min(w / 2, r), 0);\n    c.lineTo(Math.min(w / 2, r), 0);\n    c.quadTo(0, 0, 0, r);\n    c.lineTo(0, start);\n    if (swimlaneLine || start >= h) {\n      c.close();\n    }\n    c.fillAndStroke();\n\n    // Transparent content area\n    if (start < h && fill == _mxConstants[\"default\"].NONE) {\n      c.pointerEvents = false;\n      c.begin();\n      c.moveTo(0, start);\n      c.lineTo(0, h - r);\n      c.quadTo(0, h, Math.min(w / 2, r), h);\n      c.lineTo(w - Math.min(w / 2, r), h);\n      c.quadTo(w, h, w, h - r);\n      c.lineTo(w, start);\n      c.stroke();\n    }\n  } else {\n    c.moveTo(start, 0);\n    c.lineTo(r, 0);\n    c.quadTo(0, 0, 0, Math.min(h / 2, r));\n    c.lineTo(0, h - Math.min(h / 2, r));\n    c.quadTo(0, h, r, h);\n    c.lineTo(start, h);\n    if (swimlaneLine || start >= w) {\n      c.close();\n    }\n    c.fillAndStroke();\n\n    // Transparent content area\n    if (start < w && fill == _mxConstants[\"default\"].NONE) {\n      c.pointerEvents = false;\n      c.begin();\n      c.moveTo(start, h);\n      c.lineTo(w - r, h);\n      c.quadTo(w, h, w, h - Math.min(h / 2, r));\n      c.lineTo(w, Math.min(h / 2, r));\n      c.quadTo(w, 0, w - r, 0);\n      c.lineTo(start, 0);\n      c.stroke();\n    }\n  }\n};\n\n/**\r\n * Function: paintSwimlane\r\n *\r\n * Paints the swimlane vertex shape.\r\n */\nmxSwimlane.prototype.paintSeparator = function (c, x, y, w, h, start, color) {\n  if (color != _mxConstants[\"default\"].NONE) {\n    c.setStrokeColor(color);\n    c.setDashed(true);\n    c.begin();\n    if (this.isHorizontal()) {\n      c.moveTo(w, start);\n      c.lineTo(w, h);\n    } else {\n      c.moveTo(start, 0);\n      c.lineTo(w, 0);\n    }\n    c.stroke();\n    c.setDashed(false);\n  }\n};\n\n/**\r\n * Function: getImageBounds\r\n *\r\n * Paints the swimlane vertex shape.\r\n */\nmxSwimlane.prototype.getImageBounds = function (x, y, w, h) {\n  if (this.isHorizontal()) {\n    return new _mxRectangle[\"default\"](x + w - this.imageSize, y, this.imageSize, this.imageSize);\n  } else {\n    return new _mxRectangle[\"default\"](x, y, this.imageSize, this.imageSize);\n  }\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxGraphLayout\r\n *\r\n * Base class for all layout algorithms in mxGraph. Main public functions are\r\n * <move> for handling a moved cell within a layouted parent, and <execute> for\r\n * running the layout on a given parent cell.\r\n *\r\n * Known Subclasses:\r\n *\r\n * <mxCircleLayout>, <mxCompactTreeLayout>, <mxCompositeLayout>,\r\n * <mxFastOrganicLayout>, <mxParallelEdgeLayout>, <mxPartitionLayout>,\r\n * <mxStackLayout>\r\n *\r\n * Constructor: mxGraphLayout\r\n *\r\n * Constructs a new layout using the given layouts.\r\n *\r\n * Arguments:\r\n *\r\n * graph - Enclosing\r\n */\nvar _default = exports[\"default\"] = mxSwimlane;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxSwimlane.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxSwimlaneManager.js":
/*!****************************************************!*\
  !*** ./src/workflow/mxClient/mxSwimlaneManager.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.function.bind.js */ \"../../node_modules/core-js/modules/es.function.bind.js\");\nvar _mxEvent = _interopRequireDefault(__webpack_require__(/*! ./mxEvent.js */ \"./src/workflow/mxClient/mxEvent.js\"));\nvar _mxEventSource = _interopRequireDefault(__webpack_require__(/*! ./mxEventSource.js */ \"./src/workflow/mxClient/mxEventSource.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxRectangle = _interopRequireDefault(__webpack_require__(/*! ./mxRectangle.js */ \"./src/workflow/mxClient/mxRectangle.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ./mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxSwimlaneManager(graph, horizontal, addEnabled, resizeEnabled) {\n  this.horizontal = horizontal != null ? horizontal : true;\n  this.addEnabled = addEnabled != null ? addEnabled : true;\n  this.resizeEnabled = resizeEnabled != null ? resizeEnabled : true;\n  this.addHandler = _mxGraphUtils[\"default\"].bind(this, function (sender, evt) {\n    if (this.isEnabled() && this.isAddEnabled()) {\n      this.cellsAdded(evt.getProperty('cells'));\n    }\n  });\n  this.resizeHandler = _mxGraphUtils[\"default\"].bind(this, function (sender, evt) {\n    if (this.isEnabled() && this.isResizeEnabled()) {\n      this.cellsResized(evt.getProperty('cells'));\n    }\n  });\n  this.setGraph(graph);\n}\n;\n\n/**\r\n * Extends mxEventSource.\r\n */\nmxSwimlaneManager.prototype = new _mxEventSource[\"default\"]();\nmxSwimlaneManager.prototype.constructor = mxSwimlaneManager;\n\n/**\r\n * Variable: graph\r\n *\r\n * Reference to the enclosing <mxGraph>.\r\n */\nmxSwimlaneManager.prototype.graph = null;\n\n/**\r\n * Variable: enabled\r\n *\r\n * Specifies if event handling is enabled. Default is true.\r\n */\nmxSwimlaneManager.prototype.enabled = true;\n\n/**\r\n * Variable: horizontal\r\n *\r\n * Specifies the orientation of the swimlanes. Default is true.\r\n */\nmxSwimlaneManager.prototype.horizontal = true;\n\n/**\r\n * Variable: addEnabled\r\n *\r\n * Specifies if newly added cells should be resized to match the size of their\r\n * existing siblings. Default is true.\r\n */\nmxSwimlaneManager.prototype.addEnabled = true;\n\n/**\r\n * Variable: resizeEnabled\r\n *\r\n * Specifies if resizing of swimlanes should be handled. Default is true.\r\n */\nmxSwimlaneManager.prototype.resizeEnabled = true;\n\n/**\r\n * Variable: moveHandler\r\n *\r\n * Holds the function that handles the move event.\r\n */\nmxSwimlaneManager.prototype.addHandler = null;\n\n/**\r\n * Variable: moveHandler\r\n *\r\n * Holds the function that handles the move event.\r\n */\nmxSwimlaneManager.prototype.resizeHandler = null;\n\n/**\r\n * Function: isEnabled\r\n *\r\n * Returns true if events are handled. This implementation\r\n * returns <enabled>.\r\n */\nmxSwimlaneManager.prototype.isEnabled = function () {\n  return this.enabled;\n};\n\n/**\r\n * Function: setEnabled\r\n *\r\n * Enables or disables event handling. This implementation\r\n * updates <enabled>.\r\n *\r\n * Parameters:\r\n *\r\n * enabled - Boolean that specifies the new enabled state.\r\n */\nmxSwimlaneManager.prototype.setEnabled = function (value) {\n  this.enabled = value;\n};\n\n/**\r\n * Function: isHorizontal\r\n *\r\n * Returns <horizontal>.\r\n */\nmxSwimlaneManager.prototype.isHorizontal = function () {\n  return this.horizontal;\n};\n\n/**\r\n * Function: setHorizontal\r\n *\r\n * Sets <horizontal>.\r\n */\nmxSwimlaneManager.prototype.setHorizontal = function (value) {\n  this.horizontal = value;\n};\n\n/**\r\n * Function: isAddEnabled\r\n *\r\n * Returns <addEnabled>.\r\n */\nmxSwimlaneManager.prototype.isAddEnabled = function () {\n  return this.addEnabled;\n};\n\n/**\r\n * Function: setAddEnabled\r\n *\r\n * Sets <addEnabled>.\r\n */\nmxSwimlaneManager.prototype.setAddEnabled = function (value) {\n  this.addEnabled = value;\n};\n\n/**\r\n * Function: isResizeEnabled\r\n *\r\n * Returns <resizeEnabled>.\r\n */\nmxSwimlaneManager.prototype.isResizeEnabled = function () {\n  return this.resizeEnabled;\n};\n\n/**\r\n * Function: setResizeEnabled\r\n *\r\n * Sets <resizeEnabled>.\r\n */\nmxSwimlaneManager.prototype.setResizeEnabled = function (value) {\n  this.resizeEnabled = value;\n};\n\n/**\r\n * Function: getGraph\r\n *\r\n * Returns the graph that this manager operates on.\r\n */\nmxSwimlaneManager.prototype.getGraph = function () {\n  return this.graph;\n};\n\n/**\r\n * Function: setGraph\r\n *\r\n * Sets the graph that the manager operates on.\r\n */\nmxSwimlaneManager.prototype.setGraph = function (graph) {\n  if (this.graph != null) {\n    this.graph.removeListener(this.addHandler);\n    this.graph.removeListener(this.resizeHandler);\n  }\n  this.graph = graph;\n  if (this.graph != null) {\n    this.graph.addListener(_mxEvent[\"default\"].ADD_CELLS, this.addHandler);\n    this.graph.addListener(_mxEvent[\"default\"].CELLS_RESIZED, this.resizeHandler);\n  }\n};\n\n/**\r\n * Function: isSwimlaneIgnored\r\n *\r\n * Returns true if the given swimlane should be ignored.\r\n */\nmxSwimlaneManager.prototype.isSwimlaneIgnored = function (swimlane) {\n  return !this.getGraph().isSwimlane(swimlane);\n};\n\n/**\r\n * Function: isCellHorizontal\r\n *\r\n * Returns true if the given cell is horizontal. If the given cell is not a\r\n * swimlane, then the global orientation is returned.\r\n */\nmxSwimlaneManager.prototype.isCellHorizontal = function (cell) {\n  if (this.graph.isSwimlane(cell)) {\n    var style = this.graph.getCellStyle(cell);\n    return _mxGraphUtils[\"default\"].getValue(style, _mxConstants[\"default\"].STYLE_HORIZONTAL, 1) == 1;\n  }\n  return !this.isHorizontal();\n};\n\n/**\r\n * Function: cellsAdded\r\n *\r\n * Called if any cells have been added.\r\n *\r\n * Parameters:\r\n *\r\n * cell - Array of <mxCells> that have been added.\r\n */\nmxSwimlaneManager.prototype.cellsAdded = function (cells) {\n  if (cells != null) {\n    var model = this.getGraph().getModel();\n    model.beginUpdate();\n    try {\n      for (var i = 0; i < cells.length; i++) {\n        if (!this.isSwimlaneIgnored(cells[i])) {\n          this.swimlaneAdded(cells[i]);\n        }\n      }\n    } finally {\n      model.endUpdate();\n    }\n  }\n};\n\n/**\r\n * Function: swimlaneAdded\r\n *\r\n * Updates the size of the given swimlane to match that of any existing\r\n * siblings swimlanes.\r\n *\r\n * Parameters:\r\n *\r\n * swimlane - <mxCell> that represents the new swimlane.\r\n */\nmxSwimlaneManager.prototype.swimlaneAdded = function (swimlane) {\n  var model = this.getGraph().getModel();\n  var parent = model.getParent(swimlane);\n  var childCount = model.getChildCount(parent);\n  var geo = null;\n\n  // Finds the first valid sibling swimlane as reference\n  for (var i = 0; i < childCount; i++) {\n    var child = model.getChildAt(parent, i);\n    if (child != swimlane && !this.isSwimlaneIgnored(child)) {\n      geo = model.getGeometry(child);\n      if (geo != null) {\n        break;\n      }\n    }\n  }\n\n  // Applies the size of the refernece to the newly added swimlane\n  if (geo != null) {\n    var parentHorizontal = parent != null ? this.isCellHorizontal(parent) : this.horizontal;\n    this.resizeSwimlane(swimlane, geo.width, geo.height, parentHorizontal);\n  }\n};\n\n/**\r\n * Function: cellsResized\r\n *\r\n * Called if any cells have been resizes. Calls <swimlaneResized> for all\r\n * swimlanes where <isSwimlaneIgnored> returns false.\r\n *\r\n * Parameters:\r\n *\r\n * cells - Array of <mxCells> whose size was changed.\r\n */\nmxSwimlaneManager.prototype.cellsResized = function (cells) {\n  if (cells != null) {\n    var model = this.getGraph().getModel();\n    model.beginUpdate();\n    try {\n      // Finds the top-level swimlanes and adds offsets\n      for (var i = 0; i < cells.length; i++) {\n        if (!this.isSwimlaneIgnored(cells[i])) {\n          var geo = model.getGeometry(cells[i]);\n          if (geo != null) {\n            var size = new _mxRectangle[\"default\"](0, 0, geo.width, geo.height);\n            var top = cells[i];\n            var current = top;\n            while (current != null) {\n              top = current;\n              current = model.getParent(current);\n              var tmp = this.graph.isSwimlane(current) ? this.graph.getStartSize(current) : new _mxRectangle[\"default\"]();\n              size.width += tmp.width;\n              size.height += tmp.height;\n            }\n            var parentHorizontal = current != null ? this.isCellHorizontal(current) : this.horizontal;\n            this.resizeSwimlane(top, size.width, size.height, parentHorizontal);\n          }\n        }\n      }\n    } finally {\n      model.endUpdate();\n    }\n  }\n};\n\n/**\r\n * Function: resizeSwimlane\r\n *\r\n * Called from <cellsResized> for all swimlanes that are not ignored to update\r\n * the size of the siblings and the size of the parent swimlanes, recursively,\r\n * if <bubbling> is true.\r\n *\r\n * Parameters:\r\n *\r\n * swimlane - <mxCell> whose size has changed.\r\n */\nmxSwimlaneManager.prototype.resizeSwimlane = function (swimlane, w, h, parentHorizontal) {\n  var model = this.getGraph().getModel();\n  model.beginUpdate();\n  try {\n    var horizontal = this.isCellHorizontal(swimlane);\n    if (!this.isSwimlaneIgnored(swimlane)) {\n      var geo = model.getGeometry(swimlane);\n      if (geo != null) {\n        if (parentHorizontal && geo.height != h || !parentHorizontal && geo.width != w) {\n          geo = geo.clone();\n          if (parentHorizontal) {\n            geo.height = h;\n          } else {\n            geo.width = w;\n          }\n          model.setGeometry(swimlane, geo);\n        }\n      }\n    }\n    var tmp = this.graph.isSwimlane(swimlane) ? this.graph.getStartSize(swimlane) : new _mxRectangle[\"default\"]();\n    w -= tmp.width;\n    h -= tmp.height;\n    var childCount = model.getChildCount(swimlane);\n    for (var i = 0; i < childCount; i++) {\n      var child = model.getChildAt(swimlane, i);\n      this.resizeSwimlane(child, w, h, horizontal);\n    }\n  } finally {\n    model.endUpdate();\n  }\n};\n\n/**\r\n * Function: destroy\r\n *\r\n * Removes all handlers from the <graph> and deletes the reference to it.\r\n */\nmxSwimlaneManager.prototype.destroy = function () {\n  this.setGraph(null);\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxTemporaryCellStates\r\n *\r\n * Extends <mxPoint> to implement a 2-dimensional rectangle with double\r\n * precision coordinates.\r\n *\r\n * Constructor: mxRectangle\r\n *\r\n * Constructs a new rectangle for the optional parameters. If no parameters\r\n * are given then the respective default values are used.\r\n */\nvar _default = exports[\"default\"] = mxSwimlaneManager;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxSwimlaneManager.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxTemporaryCellStates.js":
/*!********************************************************!*\
  !*** ./src/workflow/mxClient/mxTemporaryCellStates.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _mxDictionary = _interopRequireDefault(__webpack_require__(/*! ./mxDictionary.js */ \"./src/workflow/mxClient/mxDictionary.js\"));\nvar _mxRectangle = _interopRequireDefault(__webpack_require__(/*! ./mxRectangle.js */ \"./src/workflow/mxClient/mxRectangle.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxTemporaryCellStates(view, scale, cells, isCellVisibleFn) {\n  scale = scale != null ? scale : 1;\n  this.view = view;\n\n  // Stores the previous state\n  this.oldValidateCellState = view.validateCellState;\n  this.oldBounds = view.getGraphBounds();\n  this.oldStates = view.getStates();\n  this.oldScale = view.getScale();\n\n  // Overrides validateCellState to ignore invisible cells\n  var self = this;\n  view.validateCellState = function (cell, resurse) {\n    if (cell == null || isCellVisibleFn == null || isCellVisibleFn(cell)) {\n      return self.oldValidateCellState.apply(view, arguments);\n    }\n    return null;\n  };\n\n  // Creates space for new states\n  view.setStates(new _mxDictionary[\"default\"]());\n  view.setScale(scale);\n  if (cells != null) {\n    view.resetValidationState();\n    var bbox = null;\n\n    // Validates the vertices and edges without adding them to\n    // the model so that the original cells are not modified\n    for (var i = 0; i < cells.length; i++) {\n      var bounds = view.getBoundingBox(view.validateCellState(view.validateCell(cells[i])));\n      if (bbox == null) {\n        bbox = bounds;\n      } else {\n        bbox.add(bounds);\n      }\n    }\n    view.setGraphBounds(bbox || new _mxRectangle[\"default\"]());\n  }\n}\n;\n\n/**\r\n * Variable: view\r\n *\r\n * Holds the width of the rectangle. Default is 0.\r\n */\nmxTemporaryCellStates.prototype.view = null;\n\n/**\r\n * Variable: oldStates\r\n *\r\n * Holds the height of the rectangle. Default is 0.\r\n */\nmxTemporaryCellStates.prototype.oldStates = null;\n\n/**\r\n * Variable: oldBounds\r\n *\r\n * Holds the height of the rectangle. Default is 0.\r\n */\nmxTemporaryCellStates.prototype.oldBounds = null;\n\n/**\r\n * Variable: oldScale\r\n *\r\n * Holds the height of the rectangle. Default is 0.\r\n */\nmxTemporaryCellStates.prototype.oldScale = null;\n\n/**\r\n * Function: destroy\r\n *\r\n * Returns the top, left corner as a new <mxPoint>.\r\n */\nmxTemporaryCellStates.prototype.destroy = function () {\n  this.view.setScale(this.oldScale);\n  this.view.setStates(this.oldStates);\n  this.view.setGraphBounds(this.oldBounds);\n  this.view.validateCellState = this.oldValidateCellState;\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n *\r\n * Class: mxCellStatePreview\r\n *\r\n * Implements a live preview for moving cells.\r\n *\r\n * Constructor: mxCellStatePreview\r\n *\r\n * Constructs a move preview for the given graph.\r\n *\r\n * Parameters:\r\n *\r\n * graph - Reference to the enclosing <mxGraph>.\r\n */\nvar _default = exports[\"default\"] = mxTemporaryCellStates;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxTemporaryCellStates.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxTerminalChange.js":
/*!***************************************************!*\
  !*** ./src/workflow/mxClient/mxTerminalChange.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nfunction mxTerminalChange(model, cell, terminal, source) {\n  this.model = model;\n  this.cell = cell;\n  this.terminal = terminal;\n  this.previous = terminal;\n  this.source = source;\n}\n;\n\n/**\r\n * Function: execute\r\n *\r\n * Changes the terminal of <cell> to <previous> using\r\n * <mxGraphModel.terminalForCellChanged>.\r\n */\nmxTerminalChange.prototype.execute = function () {\n  this.terminal = this.previous;\n  this.previous = this.model.terminalForCellChanged(this.cell, this.previous, this.source);\n};\nmxTerminalChange.getName = function () {\n  return 'mxTerminalChange';\n};\n/**\r\n * Class: mxValueChange\r\n *\r\n * Action to change a user object in a model.\r\n *\r\n * Constructor: mxValueChange\r\n *\r\n * Constructs a change of a user object in the\r\n * specified model.\r\n */\nvar _default = exports[\"default\"] = mxTerminalChange;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxTerminalChange.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxText.js":
/*!*****************************************!*\
  !*** ./src/workflow/mxClient/mxText.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.filter.js */ \"../../node_modules/core-js/modules/es.array.filter.js\");\n__webpack_require__(/*! core-js/modules/es.number.to-fixed.js */ \"../../node_modules/core-js/modules/es.number.to-fixed.js\");\n__webpack_require__(/*! core-js/modules/es.object.to-string.js */ \"../../node_modules/core-js/modules/es.object.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.parse-float.js */ \"../../node_modules/core-js/modules/es.parse-float.js\");\n__webpack_require__(/*! core-js/modules/es.parse-int.js */ \"../../node_modules/core-js/modules/es.parse-int.js\");\n__webpack_require__(/*! core-js/modules/es.regexp.exec.js */ \"../../node_modules/core-js/modules/es.regexp.exec.js\");\n__webpack_require__(/*! core-js/modules/es.string.replace.js */ \"../../node_modules/core-js/modules/es.string.replace.js\");\n__webpack_require__(/*! core-js/modules/es.string.trim.js */ \"../../node_modules/core-js/modules/es.string.trim.js\");\nvar _mxClient = _interopRequireDefault(__webpack_require__(/*! ./mxClient.js */ \"./src/workflow/mxClient/mxClient.js\"));\nvar _mxPoint = _interopRequireDefault(__webpack_require__(/*! ./mxPoint.js */ \"./src/workflow/mxClient/mxPoint.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxRectangle = _interopRequireDefault(__webpack_require__(/*! ./mxRectangle.js */ \"./src/workflow/mxClient/mxRectangle.js\"));\nvar _mxShape = _interopRequireDefault(__webpack_require__(/*! ./mxShape.js */ \"./src/workflow/mxClient/mxShape.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ./mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nvar _mxVmlCanvas2D = _interopRequireDefault(__webpack_require__(/*! ./mxVmlCanvas2D.js */ \"./src/workflow/mxClient/mxVmlCanvas2D.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxText(value, bounds, align, valign, color, family, size, fontStyle, spacing, spacingTop, spacingRight, spacingBottom, spacingLeft, horizontal, background, border, wrap, clipped, overflow, labelPadding, textDirection, ellipsisBackground) {\n  _mxShape[\"default\"].call(this);\n  this.value = value;\n  this.bounds = bounds;\n  this.color = color != null ? color : 'black';\n  this.align = align != null ? align : '';\n  this.valign = valign != null ? valign : '';\n  this.family = family != null ? family : _mxConstants[\"default\"].DEFAULT_FONTFAMILY;\n  this.size = size != null ? size : _mxConstants[\"default\"].DEFAULT_FONTSIZE;\n  this.fontStyle = fontStyle != null ? fontStyle : _mxConstants[\"default\"].DEFAULT_FONTSTYLE;\n  this.spacing = parseInt(spacing || 2);\n  this.spacingTop = this.spacing + parseInt(spacingTop || 0);\n  this.spacingRight = this.spacing + parseInt(spacingRight || 0);\n  this.spacingBottom = this.spacing + parseInt(spacingBottom || 0);\n  this.spacingLeft = this.spacing + parseInt(spacingLeft || 0);\n  this.horizontal = horizontal != null ? horizontal : true;\n  this.background = background;\n  this.ellipsisBackground = ellipsisBackground;\n  this.border = border;\n  this.wrap = wrap != null ? wrap : false;\n  this.clipped = clipped != null ? clipped : false;\n  this.overflow = overflow != null ? overflow : 'visible';\n  this.labelPadding = labelPadding != null ? labelPadding : 0;\n  this.textDirection = textDirection;\n  this.rotation = 0;\n  this.updateMargin();\n}\n;\n\n/**\r\n * Extends mxShape.\r\n */\n_mxGraphUtils[\"default\"].extend(mxText, _mxShape[\"default\"]);\n\n/**\r\n * Variable: baseSpacingTop\r\n *\r\n * Specifies the spacing to be added to the top spacing. Default is 0. Use the\r\n * value 5 here to get the same label positions as in mxGraph 1.x.\r\n */\nmxText.prototype.baseSpacingTop = 0;\n\n/**\r\n * Variable: baseSpacingBottom\r\n *\r\n * Specifies the spacing to be added to the bottom spacing. Default is 0. Use the\r\n * value 1 here to get the same label positions as in mxGraph 1.x.\r\n */\nmxText.prototype.baseSpacingBottom = 0;\n\n/**\r\n * Variable: baseSpacingLeft\r\n *\r\n * Specifies the spacing to be added to the left spacing. Default is 0.\r\n */\nmxText.prototype.baseSpacingLeft = 0;\n\n/**\r\n * Variable: baseSpacingRight\r\n *\r\n * Specifies the spacing to be added to the right spacing. Default is 0.\r\n */\nmxText.prototype.baseSpacingRight = 0;\n\n/**\r\n * Variable: replaceLinefeeds\r\n *\r\n * Specifies if linefeeds in HTML labels should be replaced with BR tags.\r\n * Default is true.\r\n */\nmxText.prototype.replaceLinefeeds = true;\n\n/**\r\n * Variable: verticalTextRotation\r\n *\r\n * Rotation for vertical text. Default is -90 (bottom to top).\r\n */\nmxText.prototype.verticalTextRotation = -90;\n\n/**\r\n * Variable: ignoreClippedStringSize\r\n *\r\n * Specifies if the string size should be measured in <updateBoundingBox> if\r\n * the label is clipped and the label position is center and middle. If this is\r\n * true, then the bounding box will be set to <bounds>. Default is true.\r\n * <ignoreStringSize> has precedence over this switch.\r\n */\nmxText.prototype.ignoreClippedStringSize = true;\n\n/**\r\n * Variable: ignoreStringSize\r\n *\r\n * Specifies if the actual string size should be measured. If disabled the\r\n * boundingBox will not ignore the actual size of the string, otherwise\r\n * <bounds> will be used instead. Default is false.\r\n */\nmxText.prototype.ignoreStringSize = false;\n\n/**\r\n * Variable: textWidthPadding\r\n *\r\n * Specifies the padding to be added to the text width for the bounding box.\r\n * This is needed to make sure no clipping is applied to borders. Default is 4\r\n * for IE 8 standards mode and 3 for all others.\r\n */\nmxText.prototype.textWidthPadding = document.documentMode == 8 && !_mxClient[\"default\"].IS_EM ? 4 : 3;\n\n/**\r\n * Variable: lastValue\r\n *\r\n * Contains the last rendered text value. Used for caching.\r\n */\nmxText.prototype.lastValue = null;\n\n/**\r\n * Variable: cacheEnabled\r\n *\r\n * Specifies if caching for HTML labels should be enabled. Default is true.\r\n */\nmxText.prototype.cacheEnabled = true;\n\n/**\r\n * Function: isParseVml\r\n *\r\n * Text shapes do not contain VML markup and do not need to be parsed. This\r\n * method returns false to speed up rendering in IE8.\r\n */\nmxText.prototype.isParseVml = function () {\n  return false;\n};\n\n/**\r\n * Function: isHtmlAllowed\r\n *\r\n * Returns true if HTML is allowed for this shape. This implementation returns\r\n * true if the browser is not in IE8 standards mode.\r\n */\nmxText.prototype.isHtmlAllowed = function () {\n  return document.documentMode != 8 || _mxClient[\"default\"].IS_EM;\n};\n\n/**\r\n * Function: getSvgScreenOffset\r\n *\r\n * Disables offset in IE9 for crisper image output.\r\n */\nmxText.prototype.getSvgScreenOffset = function () {\n  return 0;\n};\n\n/**\r\n * Function: checkBounds\r\n *\r\n * Returns true if the bounds are not null and all of its variables are numeric.\r\n */\nmxText.prototype.checkBounds = function () {\n  return !isNaN(this.scale) && isFinite(this.scale) && this.scale > 0 && this.bounds != null && !isNaN(this.bounds.x) && !isNaN(this.bounds.y) && !isNaN(this.bounds.width) && !isNaN(this.bounds.height);\n};\n\n/**\r\n * Function: paint\r\n *\r\n * Generic rendering code.\r\n */\nmxText.prototype.paint = function (c, update) {\n  // Scale is passed-through to canvas\n  var s = this.scale;\n  var x = this.bounds.x / s;\n  var y = this.bounds.y / s;\n  var w = this.bounds.width / s;\n  var h = this.bounds.height / s;\n  this.updateTransform(c, x, y, w, h);\n  this.configureCanvas(c, x, y, w, h);\n  if (update) {\n    var unscaledWidth = this.state != null ? this.state.unscaledWidth : null;\n    if (this.node.firstChild != null && this.lastUnscaledWidth != unscaledWidth) {\n      c.invalidateCachedOffsetSize(this.node);\n    }\n    c.updateText(x, y, w, h, this.align, this.valign, this.wrap, this.overflow, this.clipped, this.getTextRotation(), this.node);\n  } else {\n    // Checks if text contains HTML markup\n    var realHtml = _mxGraphUtils[\"default\"].isNode(this.value) || this.dialect == _mxConstants[\"default\"].DIALECT_STRICTHTML;\n\n    // Always renders labels as HTML in VML\n    var fmt = realHtml || c instanceof _mxVmlCanvas2D[\"default\"] ? 'html' : '';\n    var val = this.value;\n    if (!realHtml && fmt == 'html') {\n      val = _mxGraphUtils[\"default\"].htmlEntities(val, false);\n    }\n    if (fmt == 'html' && !_mxGraphUtils[\"default\"].isNode(this.value)) {\n      val = _mxGraphUtils[\"default\"].replaceTrailingNewlines(val, '<div><br></div>');\n    }\n\n    // Handles trailing newlines to make sure they are visible in rendering output\n    val = !_mxGraphUtils[\"default\"].isNode(this.value) && this.replaceLinefeeds && fmt == 'html' ? val.replace(/\\\\n/g, '<br/>') : val;\n    var dir = this.textDirection;\n    if (dir == _mxConstants[\"default\"].TEXT_DIRECTION_AUTO && !realHtml) {\n      dir = this.getAutoDirection();\n    }\n    if (dir != _mxConstants[\"default\"].TEXT_DIRECTION_LTR && dir != _mxConstants[\"default\"].TEXT_DIRECTION_RTL) {\n      dir = null;\n    }\n    c.text(x, y, w, h, val, this.align, this.valign, this.wrap, fmt, this.overflow, this.clipped, this.getTextRotation(), dir);\n  }\n\n  // Needs to invalidate the cached offset widths if the geometry changes\n  this.lastUnscaledWidth = this.state != null ? this.state.unscaledWidth : null;\n};\n\n/**\r\n * Function: redraw\r\n *\r\n * Renders the text using the given DOM nodes.\r\n */\nmxText.prototype.redraw = function () {\n  if (this.visible && this.checkBounds() && this.cacheEnabled && this.lastValue == this.value && (_mxGraphUtils[\"default\"].isNode(this.value) || this.dialect == _mxConstants[\"default\"].DIALECT_STRICTHTML)) {\n    if (this.node.nodeName == 'DIV' && (this.isHtmlAllowed() || !_mxClient[\"default\"].IS_VML)) {\n      this.updateSize(this.node, this.state == null || this.state.view.textDiv == null);\n      if (_mxClient[\"default\"].IS_IE && (document.documentMode == null || document.documentMode <= 8)) {\n        this.updateHtmlFilter();\n      } else {\n        this.updateHtmlTransform();\n      }\n      this.updateBoundingBox();\n    } else {\n      var canvas = this.createCanvas();\n      if (canvas != null && canvas.updateText != null && canvas.invalidateCachedOffsetSize != null) {\n        this.paint(canvas, true);\n        this.destroyCanvas(canvas);\n        this.updateBoundingBox();\n      } else {\n        // Fallback if canvas does not support updateText (VML)\n        _mxShape[\"default\"].prototype.redraw.apply(this, arguments);\n      }\n    }\n  } else {\n    _mxShape[\"default\"].prototype.redraw.apply(this, arguments);\n    if (_mxGraphUtils[\"default\"].isNode(this.value) || this.dialect == _mxConstants[\"default\"].DIALECT_STRICTHTML) {\n      this.lastValue = this.value;\n    } else {\n      this.lastValue = null;\n    }\n  }\n};\n\n/**\r\n * Function: resetStyles\r\n *\r\n * Resets all styles.\r\n */\nmxText.prototype.resetStyles = function () {\n  _mxShape[\"default\"].prototype.resetStyles.apply(this, arguments);\n  this.color = 'black';\n  this.align = '';\n  this.valign = '';\n  this.family = _mxConstants[\"default\"].DEFAULT_FONTFAMILY;\n  this.size = _mxConstants[\"default\"].DEFAULT_FONTSIZE;\n  this.fontStyle = _mxConstants[\"default\"].DEFAULT_FONTSTYLE;\n  this.spacing = 2;\n  this.spacingTop = 0;\n  this.spacingRight = 0;\n  this.spacingBottom = 0;\n  this.spacingLeft = 0;\n  this.horizontal = true;\n  delete this.background;\n  delete this.border;\n  this.textDirection = _mxConstants[\"default\"].DEFAULT_TEXT_DIRECTION;\n  delete this.margin;\n};\n\n/**\r\n * Function: apply\r\n *\r\n * Extends mxShape to update the text styles.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> of the corresponding cell.\r\n */\nmxText.prototype.apply = function (state) {\n  _mxShape[\"default\"].prototype.apply.apply(this, arguments);\n  if (this.style != null) {\n    this.fontStyle = _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_FONTSTYLE, this.fontStyle);\n    this.family = _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_FONTFAMILY, this.family);\n    this.size = _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_FONTSIZE, this.size);\n    this.color = _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_FONTCOLOR, this.color);\n    this.align = _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_ALIGN, this.align);\n    this.valign = _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_VERTICAL_ALIGN, this.valign);\n    this.spacing = _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_SPACING, this.spacing);\n    this.spacingTop = _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_SPACING_TOP, this.spacingTop) + this.spacing;\n    this.spacingRight = _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_SPACING_RIGHT, this.spacingRight) + this.spacing;\n    this.spacingBottom = _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_SPACING_BOTTOM, this.spacingBottom) + this.spacing;\n    this.spacingLeft = _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_SPACING_LEFT, this.spacingLeft) + this.spacing;\n    this.horizontal = _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_HORIZONTAL, this.horizontal);\n    this.background = _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_LABEL_BACKGROUNDCOLOR, this.background);\n    this.border = _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_LABEL_BORDERCOLOR, this.border);\n    this.textDirection = _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_TEXT_DIRECTION, _mxConstants[\"default\"].DEFAULT_TEXT_DIRECTION);\n    this.updateMargin();\n  }\n  this.flipV = null;\n  this.flipH = null;\n};\n\n/**\r\n * Function: getAutoDirection\r\n *\r\n * Used to determine the automatic text direction. Returns\r\n * <mxConstants.TEXT_DIRECTION_LTR> or <mxConstants.TEXT_DIRECTION_RTL>\r\n * depending on the contents of <value>. This is not invoked for HTML, wrapped\r\n * content or if <value> is a DOM node.\r\n */\nmxText.prototype.getAutoDirection = function () {\n  // Looks for strong (directional) characters\n  var tmp = /[A-Za-z\\u05d0-\\u065f\\u066a-\\u06ef\\u06fa-\\u07ff\\ufb1d-\\ufdff\\ufe70-\\ufefc]/.exec(this.value);\n\n  // Returns the direction defined by the character\n  return tmp != null && tmp.length > 0 && tmp[0] > 'z' ? _mxConstants[\"default\"].TEXT_DIRECTION_RTL : _mxConstants[\"default\"].TEXT_DIRECTION_LTR;\n};\n\n/**\r\n * Function: updateBoundingBox\r\n *\r\n * Updates the <boundingBox> for this shape using the given node and position.\r\n */\nmxText.prototype.updateBoundingBox = function () {\n  var node = this.node;\n  this.boundingBox = this.bounds.clone();\n  var rot = this.getTextRotation();\n  var h = this.style != null ? _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_LABEL_POSITION, _mxConstants[\"default\"].ALIGN_CENTER) : null;\n  var v = this.style != null ? _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_VERTICAL_LABEL_POSITION, _mxConstants[\"default\"].ALIGN_MIDDLE) : null;\n  if (!this.ignoreStringSize && node != null && this.overflow != 'fill' && (!this.clipped || !this.ignoreClippedStringSize || h != _mxConstants[\"default\"].ALIGN_CENTER || v != _mxConstants[\"default\"].ALIGN_MIDDLE)) {\n    var ow = null;\n    var oh = null;\n    if (node.ownerSVGElement != null) {\n      if (node.firstChild != null && node.firstChild.firstChild != null && node.firstChild.firstChild.nodeName == 'foreignObject') {\n        node = node.firstChild.firstChild;\n        ow = parseInt(node.getAttribute('width')) * this.scale;\n        oh = parseInt(node.getAttribute('height')) * this.scale;\n      } else {\n        try {\n          var b = node.getBBox();\n\n          // Workaround for bounding box of empty string\n          if (typeof this.value == 'string' && _mxGraphUtils[\"default\"].trim(this.value) == 0) {\n            this.boundingBox = null;\n            return;\n          }\n          if (b.width == 0 && b.height == 0) {\n            this.boundingBox = null;\n            return;\n          }\n          this.boundingBox = new _mxRectangle[\"default\"](b.x, b.y, b.width, b.height);\n          rot = 0;\n        } catch (e) {\n          // Ignores NS_ERROR_FAILURE in FF if container display is none.\n        }\n      }\n    } else {\n      var td = this.state != null ? this.state.view.textDiv : null;\n\n      // Use cached offset size\n      if (this.offsetWidth != null && this.offsetHeight != null) {\n        ow = this.offsetWidth * this.scale;\n        oh = this.offsetHeight * this.scale;\n      } else {\n        // Cannot get node size while container hidden so a\n        // shared temporary DIV is used for text measuring\n        if (td != null) {\n          this.updateFont(td);\n          this.updateSize(td, false);\n          this.updateInnerHtml(td);\n          node = td;\n        }\n        var sizeDiv = node;\n        if (document.documentMode == 8 && !_mxClient[\"default\"].IS_EM) {\n          var w = Math.round(this.bounds.width / this.scale);\n          if (this.wrap && w > 0) {\n            node.style.wordWrap = _mxConstants[\"default\"].WORD_WRAP;\n            node.style.whiteSpace = 'normal';\n            if (node.style.wordWrap != 'break-word') {\n              // Innermost DIV is used for measuring text\n              var divs = sizeDiv.getElementsByTagName('div');\n              if (divs.length > 0) {\n                sizeDiv = divs[divs.length - 1];\n              }\n              ow = sizeDiv.offsetWidth + 2;\n              divs = this.node.getElementsByTagName('div');\n              if (this.clipped) {\n                ow = Math.min(w, ow);\n              }\n\n              // Second last DIV width must be updated in DOM tree\n              if (divs.length > 1) {\n                divs[divs.length - 2].style.width = ow + 'px';\n              }\n            }\n          } else {\n            node.style.whiteSpace = 'nowrap';\n          }\n        } else if (sizeDiv.firstChild != null && sizeDiv.firstChild.nodeName == 'DIV') {\n          sizeDiv = sizeDiv.firstChild;\n        }\n        this.offsetWidth = sizeDiv.offsetWidth + this.textWidthPadding;\n        this.offsetHeight = sizeDiv.offsetHeight;\n        ow = this.offsetWidth * this.scale;\n        oh = this.offsetHeight * this.scale;\n      }\n    }\n    if (ow != null && oh != null) {\n      var x0 = this.bounds.x + this.margin.x * ow;\n      var y0 = this.bounds.y + this.margin.y * oh;\n      this.boundingBox = new _mxRectangle[\"default\"](x0, y0, ow, oh);\n    }\n  } else {\n    this.boundingBox.x += this.margin.x * this.boundingBox.width;\n    this.boundingBox.y += this.margin.y * this.boundingBox.height;\n  }\n  if (this.boundingBox != null) {\n    if (rot != 0) {\n      this.unrotatedBoundingBox = _mxRectangle[\"default\"].fromRectangle(this.boundingBox);\n      var bbox = _mxGraphUtils[\"default\"].getBoundingBox(this.boundingBox, rot, null, _mxRectangle[\"default\"], _mxPoint[\"default\"]);\n      this.boundingBox.x = bbox.x;\n      this.boundingBox.y = bbox.y;\n      if (!_mxClient[\"default\"].IS_QUIRKS) {\n        this.boundingBox.width = bbox.width;\n        this.boundingBox.height = bbox.height;\n      }\n    } else {\n      this.unrotatedBoundingBox = null;\n    }\n  }\n};\n\n/**\r\n * Function: getShapeRotation\r\n *\r\n * Returns 0 to avoid using rotation in the canvas via updateTransform.\r\n */\nmxText.prototype.getShapeRotation = function () {\n  return 0;\n};\n\n/**\r\n * Function: getTextRotation\r\n *\r\n * Returns the rotation for the text label of the corresponding shape.\r\n */\nmxText.prototype.getTextRotation = function () {\n  return this.state != null && this.state.shape != null ? this.state.shape.getTextRotation() : 0;\n};\n\n/**\r\n * Function: isPaintBoundsInverted\r\n *\r\n * Inverts the bounds if <mxShape.isBoundsInverted> returns true or if the\r\n * horizontal style is false.\r\n */\nmxText.prototype.isPaintBoundsInverted = function () {\n  return !this.horizontal && this.state != null && this.state.view.graph.model.isVertex(this.state.cell);\n};\n\n/**\r\n * Function: configureCanvas\r\n *\r\n * Sets the state of the canvas for drawing the shape.\r\n */\nmxText.prototype.configureCanvas = function (c, x, y, w, h) {\n  _mxShape[\"default\"].prototype.configureCanvas.apply(this, arguments);\n  c.setFontColor(this.color);\n  c.setFontBackgroundColor(this.background);\n  c.setEllipsisBackgroundColor(this.ellipsisBackground);\n  c.setFontBorderColor(this.border);\n  c.setFontFamily(this.family);\n  c.setFontSize(this.size);\n  c.setFontStyle(this.fontStyle);\n};\n\n/**\r\n * Function: updateVmlContainer\r\n *\r\n * Sets the width and height of the container to 1px.\r\n */\nmxText.prototype.updateVmlContainer = function () {\n  this.node.style.left = Math.round(this.bounds.x) + 'px';\n  this.node.style.top = Math.round(this.bounds.y) + 'px';\n  this.node.style.width = '1px';\n  this.node.style.height = '1px';\n  this.node.style.overflow = 'visible';\n};\n\n/**\r\n * Function: redrawHtmlShape\r\n *\r\n * Updates the HTML node(s) to reflect the latest bounds and scale.\r\n */\nmxText.prototype.redrawHtmlShape = function () {\n  var style = this.node.style;\n\n  // Resets CSS styles\n  style.whiteSpace = 'normal';\n  style.overflow = '';\n  style.width = '';\n  style.height = '';\n  this.updateValue();\n  this.updateFont(this.node);\n  this.updateSize(this.node, this.state == null || this.state.view.textDiv == null);\n  this.wrap && this.addEllipsis(this.node);\n  this.offsetWidth = null;\n  this.offsetHeight = null;\n  if (_mxClient[\"default\"].IS_IE && (document.documentMode == null || document.documentMode <= 8)) {\n    this.updateHtmlFilter();\n  } else {\n    this.updateHtmlTransform();\n  }\n};\n\n/**\r\n * Function: updateHtmlTransform\r\n *\r\n * Returns the spacing as an <mxPoint>.\r\n */\nmxText.prototype.updateHtmlTransform = function () {\n  var theta = this.getTextRotation();\n  var style = this.node.style;\n  var dx = this.margin.x;\n  var dy = this.margin.y;\n  if (theta != 0) {\n    _mxGraphUtils[\"default\"].setPrefixedStyle(style, 'transformOrigin', -dx * 100 + '%' + ' ' + -dy * 100 + '%');\n    _mxGraphUtils[\"default\"].setPrefixedStyle(style, 'transform', 'translate(' + dx * 100 + '%' + ',' + dy * 100 + '%)' + 'scale(' + this.scale + ') rotate(' + theta + 'deg)');\n  } else {\n    _mxGraphUtils[\"default\"].setPrefixedStyle(style, 'transformOrigin', '0% 0%');\n    _mxGraphUtils[\"default\"].setPrefixedStyle(style, 'transform', 'scale(' + this.scale + ')' + 'translate(' + dx * 100 + '%' + ',' + dy * 100 + '%)');\n  }\n  style.left = Math.round(this.bounds.x - Math.ceil(dx * (this.overflow != 'fill' && this.overflow != 'width' ? 3 : 1))) + 'px';\n  style.top = Math.round(this.bounds.y - dy * (this.overflow != 'fill' ? 3 : 1)) + 'px';\n  if (this.opacity < 100) {\n    style.opacity = this.opacity / 100;\n  } else {\n    style.opacity = '';\n  }\n};\n\n/**\r\n * Function: setInnerHtml\r\n *\r\n * Sets the inner HTML of the given element to the <value>.\r\n */\nmxText.prototype.updateInnerHtml = function (elt) {\n  if (_mxGraphUtils[\"default\"].isNode(this.value)) {\n    elt.innerHTML = this.value.outerHTML;\n  } else {\n    var val = this.value;\n    if (this.dialect != _mxConstants[\"default\"].DIALECT_STRICTHTML) {\n      // LATER: Can be cached in updateValue\n      val = _mxGraphUtils[\"default\"].htmlEntities(val, false);\n    }\n\n    // Handles trailing newlines to make sure they are visible in rendering output\n    val = _mxGraphUtils[\"default\"].replaceTrailingNewlines(val, '<div>&nbsp;</div>');\n    val = this.replaceLinefeeds ? val.replace(/\\n/g, '<br/>') : val;\n    val = '<div style=\"display:inline-block;_display:inline;\">' + val + '</div>';\n    elt.innerHTML = val;\n  }\n};\n\n/**\r\n * Function: updateHtmlFilter\r\n *\r\n * Rotated text rendering quality is bad for IE9 quirks/IE8 standards\r\n */\nmxText.prototype.updateHtmlFilter = function () {\n  var style = this.node.style;\n  var dx = this.margin.x;\n  var dy = this.margin.y;\n  var s = this.scale;\n\n  // Resets filter before getting offsetWidth\n  _mxGraphUtils[\"default\"].setOpacity(this.node, this.opacity);\n\n  // Adds 1 to match table height in 1.x\n  var ow = 0;\n  var oh = 0;\n  var td = this.state != null ? this.state.view.textDiv : null;\n  var sizeDiv = this.node;\n\n  // Fallback for hidden text rendering in IE quirks mode\n  if (td != null) {\n    td.style.overflow = '';\n    td.style.height = '';\n    td.style.width = '';\n    this.updateFont(td);\n    this.updateSize(td, false);\n    this.updateInnerHtml(td);\n    var w = Math.round(this.bounds.width / this.scale);\n    if (this.wrap && w > 0) {\n      td.style.whiteSpace = 'normal';\n      td.style.wordWrap = _mxConstants[\"default\"].WORD_WRAP;\n      ow = w;\n      if (this.clipped) {\n        ow = Math.min(ow, this.bounds.width);\n      }\n      td.style.width = ow + 'px';\n    } else {\n      td.style.whiteSpace = 'nowrap';\n    }\n    sizeDiv = td;\n    if (sizeDiv.firstChild != null && sizeDiv.firstChild.nodeName == 'DIV') {\n      sizeDiv = sizeDiv.firstChild;\n      if (this.wrap && td.style.wordWrap == 'break-word') {\n        sizeDiv.style.width = '100%';\n      }\n    }\n\n    // Required to update the height of the text box after wrapping width is known\n    if (!this.clipped && this.wrap && w > 0) {\n      ow = sizeDiv.offsetWidth + this.textWidthPadding;\n      td.style.width = ow + 'px';\n    }\n    oh = sizeDiv.offsetHeight + 2;\n    if (_mxClient[\"default\"].IS_QUIRKS && this.border != null && this.border != _mxConstants[\"default\"].NONE) {\n      oh += 3;\n    }\n  } else if (sizeDiv.firstChild != null && sizeDiv.firstChild.nodeName == 'DIV') {\n    sizeDiv = sizeDiv.firstChild;\n    oh = sizeDiv.offsetHeight;\n  }\n  ow = sizeDiv.offsetWidth + this.textWidthPadding;\n  if (this.clipped) {\n    oh = Math.min(oh, this.bounds.height);\n  }\n  var w = this.bounds.width / s;\n  var h = this.bounds.height / s;\n\n  // Handles special case for live preview with no wrapper DIV and no textDiv\n  if (this.overflow == 'fill') {\n    oh = h;\n    ow = w;\n  } else if (this.overflow == 'width') {\n    oh = sizeDiv.scrollHeight;\n    ow = w;\n  }\n\n  // Stores for later use\n  this.offsetWidth = ow;\n  this.offsetHeight = oh;\n\n  // Simulates max-height CSS in quirks mode\n  if (_mxClient[\"default\"].IS_QUIRKS && (this.clipped || this.overflow == 'width' && h > 0)) {\n    h = Math.min(h, oh);\n    style.height = Math.round(h) + 'px';\n  } else {\n    h = oh;\n  }\n  if (this.overflow != 'fill' && this.overflow != 'width') {\n    if (this.clipped) {\n      ow = Math.min(w, ow);\n    }\n    w = ow;\n\n    // Simulates max-width CSS in quirks mode\n    if (_mxClient[\"default\"].IS_QUIRKS && this.clipped || this.wrap) {\n      style.width = Math.round(w) + 'px';\n    }\n  }\n  h *= s;\n  w *= s;\n\n  // Rotation case is handled via VML canvas\n  var rad = this.getTextRotation() * (Math.PI / 180);\n\n  // Precalculate cos and sin for the rotation\n  var real_cos = parseFloat(parseFloat(Math.cos(rad)).toFixed(8));\n  var real_sin = parseFloat(parseFloat(Math.sin(-rad)).toFixed(8));\n  rad %= 2 * Math.PI;\n  if (rad < 0) {\n    rad += 2 * Math.PI;\n  }\n  rad %= Math.PI;\n  if (rad > Math.PI / 2) {\n    rad = Math.PI - rad;\n  }\n  var cos = Math.cos(rad);\n  var sin = Math.sin(-rad);\n  var tx = w * -(dx + 0.5);\n  var ty = h * -(dy + 0.5);\n  var top_fix = (h - h * cos + w * sin) / 2 + real_sin * tx - real_cos * ty;\n  var left_fix = (w - w * cos + h * sin) / 2 - real_cos * tx - real_sin * ty;\n  if (rad != 0) {\n    var f = 'progid:DXImageTransform.Microsoft.Matrix(M11=' + real_cos + ', M12=' + real_sin + ', M21=' + -real_sin + ', M22=' + real_cos + ', sizingMethod=\\'auto expand\\')';\n    if (style.filter != null && style.filter.length > 0) {\n      style.filter += ' ' + f;\n    } else {\n      style.filter = f;\n    }\n  }\n\n  // Workaround for rendering offsets\n  var dy = 0;\n  if (this.overflow != 'fill' && _mxClient[\"default\"].IS_QUIRKS) {\n    if (this.valign == _mxConstants[\"default\"].ALIGN_TOP) {\n      dy -= 1;\n    } else if (this.valign == _mxConstants[\"default\"].ALIGN_BOTTOM) {\n      dy += 2;\n    } else {\n      dy += 1;\n    }\n  }\n  style.zoom = s;\n  style.left = Math.round(this.bounds.x + left_fix - w / 2) + 'px';\n  style.top = Math.round(this.bounds.y + top_fix - h / 2 + dy) + 'px';\n};\n\n/**\r\n * Function: updateValue\r\n *\r\n * Updates the HTML node(s) to reflect the latest bounds and scale.\r\n */\nmxText.prototype.updateValue = function () {\n  if (_mxGraphUtils[\"default\"].isNode(this.value)) {\n    this.node.innerHTML = '';\n    this.node.appendChild(this.value);\n  } else {\n    var val = this.value;\n    if (this.dialect != _mxConstants[\"default\"].DIALECT_STRICTHTML) {\n      val = _mxGraphUtils[\"default\"].htmlEntities(val, false);\n    }\n\n    // Handles trailing newlines to make sure they are visible in rendering output\n    val = _mxGraphUtils[\"default\"].replaceTrailingNewlines(val, '<div><br></div>');\n    val = this.replaceLinefeeds ? val.replace(/\\n/g, '<br/>') : val;\n    var bg = this.background != null && this.background != _mxConstants[\"default\"].NONE ? this.background : null;\n    var bd = this.border != null && this.border != _mxConstants[\"default\"].NONE ? this.border : null;\n    if (this.overflow == 'fill' || this.overflow == 'width') {\n      if (bg != null) {\n        this.node.style.backgroundColor = bg;\n      }\n      if (bd != null) {\n        this.node.style.border = '1px solid ' + bd;\n      }\n    } else {\n      var css = '';\n      if (bg != null) {\n        css += 'background-color:' + bg + ';';\n      }\n      if (bd != null) {\n        css += 'border:1px solid ' + bd + ';';\n      }\n\n      // Wrapper DIV for background, zoom needed for inline in quirks\n      // and to measure wrapped font sizes in all browsers\n      // FIXME: Background size in quirks mode for wrapped text\n      var lh = _mxConstants[\"default\"].ABSOLUTE_LINE_HEIGHT ? this.size * _mxConstants[\"default\"].LINE_HEIGHT + 'px' : _mxConstants[\"default\"].LINE_HEIGHT;\n      val = '<div class=\"text\" style=\"zoom:1;' + css + 'display:inline-block;_display:inline;text-decoration:inherit;' + 'padding-bottom:1px;padding-right:1px;line-height:' + lh + '\">' + val + '</div>';\n    }\n    this.node.innerHTML = val;\n\n    // Sets text direction\n    var divs = this.node.getElementsByTagName('div');\n    if (divs.length > 0) {\n      var dir = this.textDirection;\n      if (dir == _mxConstants[\"default\"].TEXT_DIRECTION_AUTO && this.dialect != _mxConstants[\"default\"].DIALECT_STRICTHTML) {\n        dir = this.getAutoDirection();\n      }\n      if (dir == _mxConstants[\"default\"].TEXT_DIRECTION_LTR || dir == _mxConstants[\"default\"].TEXT_DIRECTION_RTL) {\n        divs[divs.length - 1].setAttribute('dir', dir);\n      } else {\n        divs[divs.length - 1].removeAttribute('dir');\n      }\n    }\n  }\n};\n\n/**\r\n * Function: updateFont\r\n *\r\n * Updates the HTML node(s) to reflect the latest bounds and scale.\r\n */\nmxText.prototype.updateFont = function (node) {\n  var style = node.style;\n  style.lineHeight = _mxConstants[\"default\"].ABSOLUTE_LINE_HEIGHT ? this.size * _mxConstants[\"default\"].LINE_HEIGHT + 'px' : _mxConstants[\"default\"].LINE_HEIGHT;\n  style.fontSize = this.size + 'px';\n  style.fontFamily = this.family;\n  style.verticalAlign = 'top';\n  style.color = this.color;\n  if ((this.fontStyle & _mxConstants[\"default\"].FONT_BOLD) == _mxConstants[\"default\"].FONT_BOLD) {\n    style.fontWeight = 'bold';\n  } else {\n    style.fontWeight = '';\n  }\n  if ((this.fontStyle & _mxConstants[\"default\"].FONT_ITALIC) == _mxConstants[\"default\"].FONT_ITALIC) {\n    style.fontStyle = 'italic';\n  } else {\n    style.fontStyle = '';\n  }\n  if ((this.fontStyle & _mxConstants[\"default\"].FONT_UNDERLINE) == _mxConstants[\"default\"].FONT_UNDERLINE) {\n    style.textDecoration = 'underline';\n  } else {\n    style.textDecoration = '';\n  }\n  if (this.align == _mxConstants[\"default\"].ALIGN_CENTER) {\n    style.textAlign = 'center';\n  } else if (this.align == _mxConstants[\"default\"].ALIGN_RIGHT) {\n    style.textAlign = 'right';\n  } else {\n    style.textAlign = 'left';\n  }\n};\n\n/**\r\n * Function: updateSize\r\n *\r\n * Updates the HTML node(s) to reflect the latest bounds and scale.\r\n */\nmxText.prototype.updateSize = function (node, enableWrap) {\n  var w = Math.max(0, Math.round(this.bounds.width / this.scale));\n  var h = Math.max(0, Math.round(this.bounds.height / this.scale));\n  var style = node.style;\n\n  // NOTE: Do not use maxWidth here because wrapping will\n  // go wrong if the cell is outside of the viewable area\n  if (this.clipped) {\n    style.overflow = 'hidden';\n    if (!_mxClient[\"default\"].IS_QUIRKS) {\n      style.maxHeight = h + 'px';\n      style.maxWidth = w + 'px';\n    } else {\n      style.width = w + 'px';\n    }\n  } else if (this.overflow == 'fill') {\n    style.width = w + 1 + 'px';\n    style.height = h + 1 + 'px';\n    style.overflow = 'hidden';\n  } else if (this.overflow == 'width') {\n    style.width = w + 1 + 'px';\n    style.maxHeight = h + 1 + 'px';\n    style.overflow = 'hidden';\n  }\n  if (this.wrap && w > 0) {\n    style.wordWrap = _mxConstants[\"default\"].WORD_WRAP;\n    style.whiteSpace = 'normal';\n    style.width = w + 'px';\n    if (enableWrap && this.overflow != 'fill' && this.overflow != 'width') {\n      var sizeDiv = node;\n      if (sizeDiv.firstChild != null && sizeDiv.firstChild.nodeName == 'DIV') {\n        sizeDiv = sizeDiv.firstChild;\n        if (node.style.wordWrap == 'break-word') {\n          sizeDiv.style.width = '100%';\n        }\n      }\n      var tmp = sizeDiv.offsetWidth;\n\n      // Workaround for text measuring in hidden containers\n      if (tmp == 0) {\n        var prev = node.parentNode;\n        node.style.visibility = 'hidden';\n        document.body.appendChild(node);\n        tmp = sizeDiv.offsetWidth;\n        node.style.visibility = '';\n        prev.appendChild(node);\n      }\n      tmp += 3;\n      if (this.clipped) {\n        tmp = Math.min(tmp, w);\n      }\n      style.width = tmp + 'px';\n    }\n  } else {\n    style.whiteSpace = 'nowrap';\n  }\n};\nmxText.prototype.addEllipsis = function (node) {\n  var s = this.scale;\n  var fontSize = this.size;\n  var textDiv = node.querySelector('div.text');\n  var maxH = Math.round(this.bounds.height / s);\n  var line = Math.floor(maxH / (fontSize * textDiv.style.lineHeight)) || 1;\n  var lh = (maxH / (line * fontSize)).toFixed(2);\n  if (textDiv && textDiv.offsetHeight > maxH) {\n    //省略号\n    var dotDiv = document.createElement('div');\n    dotDiv.appendChild(document.createTextNode('...'));\n    dotDiv.style.position = 'absolute';\n    dotDiv.style.bottom = '1px';\n    dotDiv.style.right = 0;\n    dotDiv.style.borderRadius = '5px';\n    dotDiv.style.backgroundColor = this.ellipsisBackground;\n    dotDiv.style.color = this.node.style.color || '#000';\n    dotDiv.style.fontSize = fontSize + 'px';\n    dotDiv.style.letterSpacing = '1.5px';\n    textDiv.style.lineHeight = lh;\n    node.appendChild(dotDiv);\n  }\n};\n\n/**\r\n * Function: getMargin\r\n *\r\n * Returns the spacing as an <mxPoint>.\r\n */\nmxText.prototype.updateMargin = function () {\n  this.margin = _mxGraphUtils[\"default\"].getAlignmentAsPoint(this.align, this.valign, _mxPoint[\"default\"]);\n};\n\n/**\r\n * Function: getSpacing\r\n *\r\n * Returns the spacing as an <mxPoint>.\r\n */\nmxText.prototype.getSpacing = function () {\n  var dx = 0;\n  var dy = 0;\n  if (this.align == _mxConstants[\"default\"].ALIGN_CENTER) {\n    dx = (this.spacingLeft - this.spacingRight) / 2;\n  } else if (this.align == _mxConstants[\"default\"].ALIGN_RIGHT) {\n    dx = -this.spacingRight - this.baseSpacingRight;\n  } else {\n    dx = this.spacingLeft + this.baseSpacingLeft;\n  }\n  if (this.valign == _mxConstants[\"default\"].ALIGN_MIDDLE) {\n    dy = (this.spacingTop - this.spacingBottom) / 2;\n  } else if (this.valign == _mxConstants[\"default\"].ALIGN_BOTTOM) {\n    dy = -this.spacingBottom - this.baseSpacingBottom;\n    ;\n  } else {\n    dy = this.spacingTop + this.baseSpacingTop;\n  }\n  return new _mxPoint[\"default\"](dx, dy);\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxTriangle\r\n *\r\n * Implementation of the triangle shape.\r\n *\r\n * Constructor: mxTriangle\r\n *\r\n * Constructs a new triangle shape.\r\n */\nvar _default = exports[\"default\"] = mxText;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxText.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxToolbar.js":
/*!********************************************!*\
  !*** ./src/workflow/mxClient/mxToolbar.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.function.bind.js */ \"../../node_modules/core-js/modules/es.function.bind.js\");\nvar _mxEventObject = _interopRequireDefault(__webpack_require__(/*! ./mxEventObject.js */ \"./src/workflow/mxClient/mxEventObject.js\"));\nvar _mxClient = _interopRequireDefault(__webpack_require__(/*! ./mxClient.js */ \"./src/workflow/mxClient/mxClient.js\"));\nvar _mxEvent = _interopRequireDefault(__webpack_require__(/*! ./mxEvent.js */ \"./src/workflow/mxClient/mxEvent.js\"));\nvar _mxPoint = _interopRequireDefault(__webpack_require__(/*! ./mxPoint.js */ \"./src/workflow/mxClient/mxPoint.js\"));\nvar _mxPopupMenu = _interopRequireDefault(__webpack_require__(/*! ./mxPopupMenu.js */ \"./src/workflow/mxClient/mxPopupMenu.js\"));\nvar _mxEventSource = _interopRequireDefault(__webpack_require__(/*! ./mxEventSource.js */ \"./src/workflow/mxClient/mxEventSource.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxUtils = _interopRequireDefault(__webpack_require__(/*! ./mxUtils.js */ \"./src/workflow/mxClient/mxUtils.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxToolbar(container) {\n  this.container = container;\n}\n;\n\n/**\r\n * Extends mxEventSource.\r\n */\nmxToolbar.prototype = new _mxEventSource[\"default\"]();\nmxToolbar.prototype.constructor = mxToolbar;\n\n/**\r\n * Variable: container\r\n *\r\n * Reference to the DOM nodes that contains the toolbar.\r\n */\nmxToolbar.prototype.container = null;\n\n/**\r\n * Variable: enabled\r\n *\r\n * Specifies if events are handled. Default is true.\r\n */\nmxToolbar.prototype.enabled = true;\n\n/**\r\n * Variable: noReset\r\n *\r\n * Specifies if <resetMode> requires a forced flag of true for resetting\r\n * the current mode in the toolbar. Default is false. This is set to true\r\n * if the toolbar item is double clicked to avoid a reset after a single\r\n * use of the item.\r\n */\nmxToolbar.prototype.noReset = false;\n\n/**\r\n * Variable: updateDefaultMode\r\n *\r\n * Boolean indicating if the default mode should be the last selected\r\n * switch mode or the first inserted switch mode. Default is true, that\r\n * is the last selected switch mode is the default mode. The default mode\r\n * is the mode to be selected after a reset of the toolbar. If this is\r\n * false, then the default mode is the first inserted mode item regardless\r\n * of what was last selected. Otherwise, the selected item after a reset is\r\n * the previously selected item.\r\n */\nmxToolbar.prototype.updateDefaultMode = true;\n\n/**\r\n * Function: addItem\r\n *\r\n * Adds the given function as an image with the specified title and icon\r\n * and returns the new image node.\r\n *\r\n * Parameters:\r\n *\r\n * title - Optional string that is used as the tooltip.\r\n * icon - Optional URL of the image to be used. If no URL is given, then a\r\n * button is created.\r\n * funct - Function to execute on a mouse click.\r\n * pressedIcon - Optional URL of the pressed image. Default is a gray\r\n * background.\r\n * style - Optional style classname. Default is mxToolbarItem.\r\n * factoryMethod - Optional factory method for popup menu, eg.\r\n * function(menu, evt, cell) { menu.addItem('Hello, World!'); }\r\n */\nmxToolbar.prototype.addItem = function (title, icon, funct, pressedIcon, style, factoryMethod) {\n  var img = document.createElement(icon != null ? 'img' : 'button');\n  var initialClassName = style || (factoryMethod != null ? 'mxToolbarMode' : 'mxToolbarItem');\n  img.className = initialClassName;\n  img.setAttribute('src', icon);\n  if (title != null) {\n    if (icon != null) {\n      img.setAttribute('title', title);\n    } else {\n      _mxGraphUtils[\"default\"].write(img, title);\n    }\n  }\n  this.container.appendChild(img);\n\n  // Invokes the function on a click on the toolbar item\n  if (funct != null) {\n    _mxEvent[\"default\"].addListener(img, 'click', funct);\n    if (_mxClient[\"default\"].IS_TOUCH) {\n      _mxEvent[\"default\"].addListener(img, 'touchend', funct);\n    }\n  }\n  var mouseHandler = _mxGraphUtils[\"default\"].bind(this, function (evt) {\n    if (pressedIcon != null) {\n      img.setAttribute('src', icon);\n    } else {\n      img.style.backgroundColor = '';\n    }\n  });\n\n  // Highlights the toolbar item with a gray background\n  // while it is being clicked with the mouse\n  _mxEvent[\"default\"].addGestureListeners(img, _mxGraphUtils[\"default\"].bind(this, function (evt) {\n    if (pressedIcon != null) {\n      img.setAttribute('src', pressedIcon);\n    } else {\n      img.style.backgroundColor = 'gray';\n    }\n\n    // Popup Menu\n    if (factoryMethod != null) {\n      if (this.menu == null) {\n        this.menu = new _mxPopupMenu[\"default\"]();\n        this.menu.init();\n      }\n      var last = this.currentImg;\n      if (this.menu.isMenuShowing()) {\n        this.menu.hideMenu();\n      }\n      if (last != img) {\n        // Redirects factory method to local factory method\n        this.currentImg = img;\n        this.menu.factoryMethod = factoryMethod;\n        var point = new _mxPoint[\"default\"](img.offsetLeft, img.offsetTop + img.offsetHeight);\n        this.menu.popup(point.x, point.y, null, evt);\n\n        // Sets and overrides to restore classname\n        if (this.menu.isMenuShowing()) {\n          img.className = initialClassName + 'Selected';\n          this.menu.hideMenu = function () {\n            _mxPopupMenu[\"default\"].prototype.hideMenu.apply(this);\n            img.className = initialClassName;\n            this.currentImg = null;\n          };\n        }\n      }\n    }\n  }), null, mouseHandler);\n  _mxEvent[\"default\"].addListener(img, 'mouseout', mouseHandler);\n  return img;\n};\n\n/**\r\n * Function: addCombo\r\n *\r\n * Adds and returns a new SELECT element using the given style. The element\r\n * is placed inside a DIV with the mxToolbarComboContainer style classname.\r\n *\r\n * Parameters:\r\n *\r\n * style - Optional style classname. Default is mxToolbarCombo.\r\n */\nmxToolbar.prototype.addCombo = function (style) {\n  var div = document.createElement('div');\n  div.style.display = 'inline';\n  div.className = 'mxToolbarComboContainer';\n  var select = document.createElement('select');\n  select.className = style || 'mxToolbarCombo';\n  div.appendChild(select);\n  this.container.appendChild(div);\n  return select;\n};\n\n/**\r\n * Function: addCombo\r\n *\r\n * Adds and returns a new SELECT element using the given title as the\r\n * default element. The selection is reset to this element after each\r\n * change.\r\n *\r\n * Parameters:\r\n *\r\n * title - String that specifies the title of the default element.\r\n * style - Optional style classname. Default is mxToolbarCombo.\r\n */\nmxToolbar.prototype.addActionCombo = function (title, style) {\n  var select = document.createElement('select');\n  select.className = style || 'mxToolbarCombo';\n  this.addOption(select, title, null);\n  _mxEvent[\"default\"].addListener(select, 'change', function (evt) {\n    var value = select.options[select.selectedIndex];\n    select.selectedIndex = 0;\n    if (value.funct != null) {\n      value.funct(evt);\n    }\n  });\n  this.container.appendChild(select);\n  return select;\n};\n\n/**\r\n * Function: addOption\r\n *\r\n * Adds and returns a new OPTION element inside the given SELECT element.\r\n * If the given value is a function then it is stored in the option's funct\r\n * field.\r\n *\r\n * Parameters:\r\n *\r\n * combo - SELECT element that will contain the new entry.\r\n * title - String that specifies the title of the option.\r\n * value - Specifies the value associated with this option.\r\n */\nmxToolbar.prototype.addOption = function (combo, title, value) {\n  var option = document.createElement('option');\n  _mxUtils[\"default\"].writeln(option, title);\n  if (typeof value == 'function') {\n    option.funct = value;\n  } else {\n    option.setAttribute('value', value);\n  }\n  combo.appendChild(option);\n  return option;\n};\n\n/**\r\n * Function: addSwitchMode\r\n *\r\n * Adds a new selectable item to the toolbar. Only one switch mode item may\r\n * be selected at a time. The currently selected item is the default item\r\n * after a reset of the toolbar.\r\n */\nmxToolbar.prototype.addSwitchMode = function (title, icon, funct, pressedIcon, style) {\n  var img = document.createElement('img');\n  img.initialClassName = style || 'mxToolbarMode';\n  img.className = img.initialClassName;\n  img.setAttribute('src', icon);\n  img.altIcon = pressedIcon;\n  if (title != null) {\n    img.setAttribute('title', title);\n  }\n  _mxEvent[\"default\"].addListener(img, 'click', _mxGraphUtils[\"default\"].bind(this, function (evt) {\n    var tmp = this.selectedMode.altIcon;\n    if (tmp != null) {\n      this.selectedMode.altIcon = this.selectedMode.getAttribute('src');\n      this.selectedMode.setAttribute('src', tmp);\n    } else {\n      this.selectedMode.className = this.selectedMode.initialClassName;\n    }\n    if (this.updateDefaultMode) {\n      this.defaultMode = img;\n    }\n    this.selectedMode = img;\n    var tmp = img.altIcon;\n    if (tmp != null) {\n      img.altIcon = img.getAttribute('src');\n      img.setAttribute('src', tmp);\n    } else {\n      img.className = img.initialClassName + 'Selected';\n    }\n    this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].SELECT));\n    funct();\n  }));\n  this.container.appendChild(img);\n  if (this.defaultMode == null) {\n    this.defaultMode = img;\n\n    // Function should fire only once so\n    // do not pass it with the select event\n    this.selectMode(img);\n    funct();\n  }\n  return img;\n};\n\n/**\r\n * Function: addMode\r\n *\r\n * Adds a new item to the toolbar. The selection is typically reset after\r\n * the item has been consumed, for example by adding a new vertex to the\r\n * graph. The reset is not carried out if the item is double clicked.\r\n *\r\n * The function argument uses the following signature: funct(evt, cell) where\r\n * evt is the native mouse event and cell is the cell under the mouse.\r\n */\nmxToolbar.prototype.addMode = function (title, icon, funct, pressedIcon, style, toggle) {\n  toggle = toggle != null ? toggle : true;\n  var img = document.createElement(icon != null ? 'img' : 'button');\n  img.initialClassName = style || 'mxToolbarMode';\n  img.className = img.initialClassName;\n  img.setAttribute('src', icon);\n  img.altIcon = pressedIcon;\n  if (title != null) {\n    img.setAttribute('title', title);\n  }\n  if (this.enabled && toggle) {\n    _mxEvent[\"default\"].addListener(img, 'click', _mxGraphUtils[\"default\"].bind(this, function (evt) {\n      this.selectMode(img, funct);\n      this.noReset = false;\n    }));\n    _mxEvent[\"default\"].addListener(img, 'dblclick', _mxGraphUtils[\"default\"].bind(this, function (evt) {\n      this.selectMode(img, funct);\n      this.noReset = true;\n    }));\n    if (this.defaultMode == null) {\n      this.defaultMode = img;\n      this.defaultFunction = funct;\n      this.selectMode(img, funct);\n    }\n  }\n  this.container.appendChild(img);\n  return img;\n};\n\n/**\r\n * Function: selectMode\r\n *\r\n * Resets the state of the previously selected mode and displays the given\r\n * DOM node as selected. This function fires a select event with the given\r\n * function as a parameter.\r\n */\nmxToolbar.prototype.selectMode = function (domNode, funct) {\n  if (this.selectedMode != domNode) {\n    if (this.selectedMode != null) {\n      var tmp = this.selectedMode.altIcon;\n      if (tmp != null) {\n        this.selectedMode.altIcon = this.selectedMode.getAttribute('src');\n        this.selectedMode.setAttribute('src', tmp);\n      } else {\n        this.selectedMode.className = this.selectedMode.initialClassName;\n      }\n    }\n    this.selectedMode = domNode;\n    var tmp = this.selectedMode.altIcon;\n    if (tmp != null) {\n      this.selectedMode.altIcon = this.selectedMode.getAttribute('src');\n      this.selectedMode.setAttribute('src', tmp);\n    } else {\n      this.selectedMode.className = this.selectedMode.initialClassName + 'Selected';\n    }\n    this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].SELECT, \"function\", funct));\n  }\n};\n\n/**\r\n * Function: resetMode\r\n *\r\n * Selects the default mode and resets the state of the previously selected\r\n * mode.\r\n */\nmxToolbar.prototype.resetMode = function (forced) {\n  if ((forced || !this.noReset) && this.selectedMode != this.defaultMode) {\n    // The last selected switch mode will be activated\n    // so the function was already executed and is\n    // no longer required here\n    this.selectMode(this.defaultMode, this.defaultFunction);\n  }\n};\n\n/**\r\n * Function: addSeparator\r\n *\r\n * Adds the specifies image as a separator.\r\n *\r\n * Parameters:\r\n *\r\n * icon - URL of the separator icon.\r\n */\nmxToolbar.prototype.addSeparator = function (icon) {\n  return this.addItem(null, icon, null);\n};\n\n/**\r\n * Function: addBreak\r\n *\r\n * Adds a break to the container.\r\n */\nmxToolbar.prototype.addBreak = function () {\n  _mxUtils[\"default\"].br(this.container);\n};\n\n/**\r\n * Function: addLine\r\n *\r\n * Adds a horizontal line to the container.\r\n */\nmxToolbar.prototype.addLine = function () {\n  var hr = document.createElement('hr');\n  hr.style.marginRight = '6px';\n  hr.setAttribute('size', '1');\n  this.container.appendChild(hr);\n};\n\n/**\r\n * Function: destroy\r\n *\r\n * Removes the toolbar and all its associated resources.\r\n */\nmxToolbar.prototype.destroy = function () {\n  _mxEvent[\"default\"].release(this.container);\n  this.container = null;\n  this.defaultMode = null;\n  this.defaultFunction = null;\n  this.selectedMode = null;\n  if (this.menu != null) {\n    this.menu.destroy();\n  }\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxUndoableEdit\r\n *\r\n * Implements a composite undoable edit. Here is an example for a custom change\r\n * which gets executed via the model:\r\n *\r\n * (code)\r\n * function CustomChange(model, name)\r\n * {\r\n *   this.model = model;\r\n *   this.name = name;\r\n *   this.previous = name;\r\n * };\r\n *\r\n * CustomChange.prototype.execute = function()\r\n * {\r\n *   var tmp = this.model.name;\r\n *   this.model.name = this.previous;\r\n *   this.previous = tmp;\r\n * };\r\n *\r\n * var name = prompt('Enter name');\r\n * graph.model.execute(new CustomChange(graph.model, name));\r\n * (end)\r\n *\r\n * Event: mxEvent.EXECUTED\r\n *\r\n * Fires between START_EDIT and END_EDIT after an atomic change was executed.\r\n * The <code>change</code> property contains the change that was executed.\r\n *\r\n * Event: mxEvent.START_EDIT\r\n *\r\n * Fires before a set of changes will be executed in <undo> or <redo>.\r\n * This event contains no properties.\r\n *\r\n * Event: mxEvent.END_EDIT\r\n *\r\n * Fires after a set of changeswas executed in <undo> or <redo>.\r\n * This event contains no properties.\r\n *\r\n * Constructor: mxUndoableEdit\r\n *\r\n * Constructs a new undoable edit for the given source.\r\n */\nvar _default = exports[\"default\"] = mxToolbar;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxToolbar.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxTooltipHandler.js":
/*!***************************************************!*\
  !*** ./src/workflow/mxClient/mxTooltipHandler.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.function.bind.js */ \"../../node_modules/core-js/modules/es.function.bind.js\");\n__webpack_require__(/*! core-js/modules/es.regexp.exec.js */ \"../../node_modules/core-js/modules/es.regexp.exec.js\");\n__webpack_require__(/*! core-js/modules/es.string.replace.js */ \"../../node_modules/core-js/modules/es.string.replace.js\");\n__webpack_require__(/*! core-js/modules/web.timers.js */ \"../../node_modules/core-js/modules/web.timers.js\");\nvar _mxEvent = _interopRequireDefault(__webpack_require__(/*! ./mxEvent.js */ \"./src/workflow/mxClient/mxEvent.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ./mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nvar _mxUtils = _interopRequireDefault(__webpack_require__(/*! ./mxUtils.js */ \"./src/workflow/mxClient/mxUtils.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxTooltipHandler(graph, delay) {\n  if (graph != null) {\n    this.graph = graph;\n    this.delay = delay || 500;\n    this.graph.addMouseListener(this);\n  }\n}\n;\n\n/**\r\n * Variable: zIndex\r\n *\r\n * Specifies the zIndex for the tooltip and its shadow. Default is 10005.\r\n */\nmxTooltipHandler.prototype.zIndex = 10005;\n\n/**\r\n * Variable: graph\r\n *\r\n * Reference to the enclosing <mxGraph>.\r\n */\nmxTooltipHandler.prototype.graph = null;\n\n/**\r\n * Variable: delay\r\n *\r\n * Delay to show the tooltip in milliseconds. Default is 500.\r\n */\nmxTooltipHandler.prototype.delay = null;\n\n/**\r\n * Variable: ignoreTouchEvents\r\n *\r\n * Specifies if touch and pen events should be ignored. Default is true.\r\n */\nmxTooltipHandler.prototype.ignoreTouchEvents = true;\n\n/**\r\n * Variable: hideOnHover\r\n *\r\n * Specifies if the tooltip should be hidden if the mouse is moved over the\r\n * current cell. Default is false.\r\n */\nmxTooltipHandler.prototype.hideOnHover = false;\n\n/**\r\n * Variable: destroyed\r\n *\r\n * True if this handler was destroyed using <destroy>.\r\n */\nmxTooltipHandler.prototype.destroyed = false;\n\n/**\r\n * Variable: enabled\r\n *\r\n * Specifies if events are handled. Default is true.\r\n */\nmxTooltipHandler.prototype.enabled = true;\n\n/**\r\n * Function: isEnabled\r\n *\r\n * Returns true if events are handled. This implementation\r\n * returns <enabled>.\r\n */\nmxTooltipHandler.prototype.isEnabled = function () {\n  return this.enabled;\n};\n\n/**\r\n * Function: setEnabled\r\n *\r\n * Enables or disables event handling. This implementation\r\n * updates <enabled>.\r\n */\nmxTooltipHandler.prototype.setEnabled = function (enabled) {\n  this.enabled = enabled;\n};\n\n/**\r\n * Function: isHideOnHover\r\n *\r\n * Returns <hideOnHover>.\r\n */\nmxTooltipHandler.prototype.isHideOnHover = function () {\n  return this.hideOnHover;\n};\n\n/**\r\n * Function: setHideOnHover\r\n *\r\n * Sets <hideOnHover>.\r\n */\nmxTooltipHandler.prototype.setHideOnHover = function (value) {\n  this.hideOnHover = value;\n};\n\n/**\r\n * Function: init\r\n *\r\n * Initializes the DOM nodes required for this tooltip handler.\r\n */\nmxTooltipHandler.prototype.init = function () {\n  if (document.body != null) {\n    this.div = document.createElement('div');\n    this.div.className = 'mxTooltip';\n    this.div.style.visibility = 'hidden';\n    document.body.appendChild(this.div);\n    _mxEvent[\"default\"].addGestureListeners(this.div, _mxGraphUtils[\"default\"].bind(this, function (evt) {\n      this.hideTooltip();\n    }));\n  }\n};\n\n/**\r\n * Function: mouseDown\r\n *\r\n * Handles the event by initiating a rubberband selection. By consuming the\r\n * event all subsequent events of the gesture are redirected to this\r\n * handler.\r\n */\nmxTooltipHandler.prototype.mouseDown = function (sender, me) {\n  this.reset(me, false);\n  this.hideTooltip();\n};\n\n/**\r\n * Function: mouseMove\r\n *\r\n * Handles the event by updating the rubberband selection.\r\n */\nmxTooltipHandler.prototype.mouseMove = function (sender, me) {\n  if (me.getX() != this.lastX || me.getY() != this.lastY) {\n    this.reset(me, true);\n    if (this.isHideOnHover() || me.getState() != this.state || me.getSource() != this.node && (!this.stateSource || me.getState() != null && this.stateSource == (me.isSource(me.getState().shape) || !me.isSource(me.getState().text)))) {\n      this.hideTooltip();\n    }\n  }\n  this.lastX = me.getX();\n  this.lastY = me.getY();\n};\n\n/**\r\n * Function: mouseUp\r\n *\r\n * Handles the event by resetting the tooltip timer or hiding the existing\r\n * tooltip.\r\n */\nmxTooltipHandler.prototype.mouseUp = function (sender, me) {\n  this.reset(me, true);\n  this.hideTooltip();\n};\n\n/**\r\n * Function: resetTimer\r\n *\r\n * Resets the timer.\r\n */\nmxTooltipHandler.prototype.resetTimer = function () {\n  if (this.thread != null) {\n    window.clearTimeout(this.thread);\n    this.thread = null;\n  }\n};\n\n/**\r\n * Function: reset\r\n *\r\n * Resets and/or restarts the timer to trigger the display of the tooltip.\r\n */\nmxTooltipHandler.prototype.reset = function (me, restart) {\n  if (!this.ignoreTouchEvents || _mxEvent[\"default\"].isMouseEvent(me.getEvent())) {\n    this.resetTimer();\n    if (restart && this.isEnabled() && me.getState() != null && (this.div == null || this.div.style.visibility == 'hidden')) {\n      var state = me.getState();\n      var node = me.getSource();\n      var x = me.getX();\n      var y = me.getY();\n      var stateSource = me.isSource(state.shape) || me.isSource(state.text);\n      this.thread = window.setTimeout(_mxGraphUtils[\"default\"].bind(this, function () {\n        if (!this.graph.isEditing() && !this.graph.popupMenuHandler.isMenuShowing() && !this.graph.isMouseDown) {\n          // Uses information from inside event cause using the event at\n          // this (delayed) point in time is not possible in IE as it no\n          // longer contains the required information (member not found)\n          var tip = this.graph.getTooltip(state, node, x, y);\n          this.show(tip, x, y);\n          this.state = state;\n          this.node = node;\n          this.stateSource = stateSource;\n        }\n      }), this.delay);\n    }\n  }\n};\n\n/**\r\n * Function: hide\r\n *\r\n * Hides the tooltip and resets the timer.\r\n */\nmxTooltipHandler.prototype.hide = function () {\n  this.resetTimer();\n  this.hideTooltip();\n};\n\n/**\r\n * Function: hideTooltip\r\n *\r\n * Hides the tooltip.\r\n */\nmxTooltipHandler.prototype.hideTooltip = function () {\n  if (this.div != null) {\n    this.div.style.visibility = 'hidden';\n  }\n};\n\n/**\r\n * Function: show\r\n *\r\n * Shows the tooltip for the specified cell and optional index at the\r\n * specified location (with a vertical offset of 10 pixels).\r\n */\nmxTooltipHandler.prototype.show = function (tip, x, y) {\n  if (!this.destroyed && tip != null && tip.length > 0) {\n    // Initializes the DOM nodes if required\n    if (this.div == null) {\n      this.init();\n    }\n    var origin = _mxUtils[\"default\"].getScrollOrigin();\n    this.div.style.zIndex = this.zIndex;\n    this.div.style.left = x + origin.x + 'px';\n    this.div.style.top = y + _mxConstants[\"default\"].TOOLTIP_VERTICAL_OFFSET + origin.y + 'px';\n    if (!_mxGraphUtils[\"default\"].isNode(tip)) {\n      this.div.innerHTML = tip.replace(/\\n/g, '<br>');\n    } else {\n      this.div.innerHTML = '';\n      this.div.appendChild(tip);\n    }\n    this.div.style.visibility = '';\n    _mxUtils[\"default\"].fit(this.div);\n  }\n};\n\n/**\r\n * Function: destroy\r\n *\r\n * Destroys the handler and all its resources and DOM nodes.\r\n */\nmxTooltipHandler.prototype.destroy = function () {\n  if (!this.destroyed) {\n    this.graph.removeMouseListener(this);\n    _mxEvent[\"default\"].release(this.div);\n    if (this.div != null && this.div.parentNode != null) {\n      this.div.parentNode.removeChild(this.div);\n    }\n    this.destroyed = true;\n    this.div = null;\n  }\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxCellTracker\r\n *\r\n * Event handler that highlights cells. Inherits from <mxCellMarker>.\r\n *\r\n * Example:\r\n *\r\n * (code)\r\n * new mxCellTracker(graph, '#00FF00');\r\n * (end)\r\n *\r\n * For detecting dragEnter, dragOver and dragLeave on cells, the following\r\n * code can be used:\r\n *\r\n * (code)\r\n * graph.addMouseListener(\r\n * {\r\n *   cell: null,\r\n *   mouseDown: function(sender, me) { },\r\n *   mouseMove: function(sender, me)\r\n *   {\r\n *     var tmp = me.getCell();\r\n *\r\n *     if (tmp != this.cell)\r\n *     {\r\n *       if (this.cell != null)\r\n *       {\r\n *         this.dragLeave(me.getEvent(), this.cell);\r\n *       }\r\n *\r\n *       this.cell = tmp;\r\n *\r\n *       if (this.cell != null)\r\n *       {\r\n *         this.dragEnter(me.getEvent(), this.cell);\r\n *       }\r\n *     }\r\n *\r\n *     if (this.cell != null)\r\n *     {\r\n *       this.dragOver(me.getEvent(), this.cell);\r\n *     }\r\n *   },\r\n *   mouseUp: function(sender, me) { },\r\n *   dragEnter: function(evt, cell)\r\n *   {\r\n *     mxLog.debug('dragEnter', cell.value);\r\n *   },\r\n *   dragOver: function(evt, cell)\r\n *   {\r\n *     mxLog.debug('dragOver', cell.value);\r\n *   },\r\n *   dragLeave: function(evt, cell)\r\n *   {\r\n *     mxLog.debug('dragLeave', cell.value);\r\n *   }\r\n * });\r\n * (end)\r\n *\r\n * Constructor: mxCellTracker\r\n *\r\n * Constructs an event handler that highlights cells.\r\n *\r\n * Parameters:\r\n *\r\n * graph - Reference to the enclosing <mxGraph>.\r\n * color - Color of the highlight. Default is blue.\r\n * funct - Optional JavaScript function that is used to override\r\n * <mxCellMarker.getCell>.\r\n */\nvar _default = exports[\"default\"] = mxTooltipHandler;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxTooltipHandler.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxTriangle.js":
/*!*********************************************!*\
  !*** ./src/workflow/mxClient/mxTriangle.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _mxPoint = _interopRequireDefault(__webpack_require__(/*! ./mxPoint.js */ \"./src/workflow/mxClient/mxPoint.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxActor = _interopRequireDefault(__webpack_require__(/*! ./mxActor.js */ \"./src/workflow/mxClient/mxActor.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ./mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxTriangle() {\n  _mxActor[\"default\"].call(this);\n}\n;\n\n/**\r\n * Extends mxActor.\r\n */\n_mxGraphUtils[\"default\"].extend(mxTriangle, _mxActor[\"default\"]);\n\n/**\r\n * Function: redrawPath\r\n *\r\n * Draws the path for this shape.\r\n */\nmxTriangle.prototype.redrawPath = function (c, x, y, w, h) {\n  var arcSize = _mxGraphUtils[\"default\"].getValue(this.style, _mxConstants[\"default\"].STYLE_ARCSIZE, _mxConstants[\"default\"].LINE_ARCSIZE) / 2;\n  this.addPoints(c, [new _mxPoint[\"default\"](0, 0), new _mxPoint[\"default\"](w, 0.5 * h), new _mxPoint[\"default\"](0, h)], this.isRounded, arcSize, true);\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxHexagon\r\n *\r\n * Implementation of the hexagon shape.\r\n *\r\n * Constructor: mxHexagon\r\n *\r\n * Constructs a new hexagon shape.\r\n */\nvar _default = exports[\"default\"] = mxTriangle;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxTriangle.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxUndoManager.js":
/*!************************************************!*\
  !*** ./src/workflow/mxClient/mxUndoManager.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.splice.js */ \"../../node_modules/core-js/modules/es.array.splice.js\");\n__webpack_require__(/*! core-js/modules/es.string.trim.js */ \"../../node_modules/core-js/modules/es.string.trim.js\");\nvar _mxEventObject = _interopRequireDefault(__webpack_require__(/*! ./mxEventObject.js */ \"./src/workflow/mxClient/mxEventObject.js\"));\nvar _mxEvent = _interopRequireDefault(__webpack_require__(/*! ./mxEvent.js */ \"./src/workflow/mxClient/mxEvent.js\"));\nvar _mxEventSource = _interopRequireDefault(__webpack_require__(/*! ./mxEventSource.js */ \"./src/workflow/mxClient/mxEventSource.js\"));\nvar _mxValueChange = _interopRequireDefault(__webpack_require__(/*! ./mxValueChange */ \"./src/workflow/mxClient/mxValueChange.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxUndoManager(size) {\n  this.size = size != null ? size : 100;\n  this.clear();\n}\n;\n\n/**\r\n * Extends mxEventSource.\r\n */\nmxUndoManager.prototype = new _mxEventSource[\"default\"]();\nmxUndoManager.prototype.constructor = mxUndoManager;\n\n/**\r\n * Variable: size\r\n *\r\n * Maximum command history size. 0 means unlimited history. Default is\r\n * 100.\r\n */\nmxUndoManager.prototype.size = null;\n\n/**\r\n * Variable: history\r\n *\r\n * Array that contains the steps of the command history.\r\n */\nmxUndoManager.prototype.history = null;\n\n/**\r\n * Variable: indexOfNextAdd\r\n *\r\n * Index of the element to be added next.\r\n */\nmxUndoManager.prototype.indexOfNextAdd = 0;\n\n/**\r\n * Function: isEmpty\r\n *\r\n * Returns true if the history is empty.\r\n */\nmxUndoManager.prototype.isEmpty = function () {\n  return this.history.length == 0;\n};\n\n/**\r\n * Function: clear\r\n *\r\n * Clears the command history.\r\n */\nmxUndoManager.prototype.clear = function () {\n  this.history = [];\n  this.indexOfNextAdd = 0;\n  this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].CLEAR));\n};\n\n/**\r\n * Function: canUndo\r\n *\r\n * Returns true if an undo is possible.\r\n */\nmxUndoManager.prototype.canUndo = function () {\n  return this.indexOfNextAdd > 0;\n};\n\n/**\r\n * Function: undo\r\n *\r\n * Undoes the last change.\r\n */\nmxUndoManager.prototype.undo = function () {\n  while (this.indexOfNextAdd > 0) {\n    var edit = this.history[--this.indexOfNextAdd];\n    edit.undo();\n    if (edit.isSignificant()) {\n      this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].UNDO, 'edit', edit));\n      break;\n    }\n  }\n};\n\n/**\r\n * Function: canRedo\r\n *\r\n * Returns true if a redo is possible.\r\n */\nmxUndoManager.prototype.canRedo = function () {\n  return this.indexOfNextAdd < this.history.length;\n};\n\n/**\r\n * Function: redo\r\n *\r\n * Redoes the last change.\r\n */\nmxUndoManager.prototype.redo = function () {\n  var n = this.history.length;\n  while (this.indexOfNextAdd < n) {\n    var edit = this.history[this.indexOfNextAdd++];\n    edit.redo();\n    if (edit.isSignificant()) {\n      this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].REDO, 'edit', edit));\n      break;\n    }\n  }\n};\n\n/**\r\n * Function: undoableEditHappened\r\n *\r\n * Method to be called to add new undoable edits to the <history>.\r\n */\nmxUndoManager.prototype.undoableEditHappened = function (undoableEdit) {\n  this.trim();\n  if (this.size > 0 && this.size == this.history.length) {\n    this.history.shift();\n  }\n\n  //TODO: 代码优化 将change合并到一个undoableEdit中\n  var changes = undoableEdit.changes;\n  if (changes && changes.length && changes[0] instanceof _mxValueChange[\"default\"]) {\n    //使用mxPropertyChange代替mxValueChange，mxPropertyChange中会做判断是否execute mxValueChange\n    //属性的改变应该是一次操作，因此此处不push valueChange\n    return;\n  }\n  this.history.push(undoableEdit);\n  this.indexOfNextAdd = this.history.length;\n  this.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].ADD, 'edit', undoableEdit));\n};\n\n/**\r\n * Function: trim\r\n *\r\n * Removes all pending steps after <indexOfNextAdd> from the history,\r\n * invoking die on each edit. This is called from <undoableEditHappened>.\r\n */\nmxUndoManager.prototype.trim = function () {\n  if (this.history.length > this.indexOfNextAdd) {\n    var edits = this.history.splice(this.indexOfNextAdd, this.history.length - this.indexOfNextAdd);\n    for (var i = 0; i < edits.length; i++) {\n      edits[i].die();\n    }\n  }\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n *\r\n * Class: mxUrlConverter\r\n *\r\n * Converts relative and absolute URLs to absolute URLs with protocol and domain.\r\n */\nvar _default = exports[\"default\"] = mxUndoManager;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxUndoManager.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxUndoableEdit.js":
/*!*************************************************!*\
  !*** ./src/workflow/mxClient/mxUndoableEdit.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _mxEventObject = _interopRequireDefault(__webpack_require__(/*! ./mxEventObject.js */ \"./src/workflow/mxClient/mxEventObject.js\"));\nvar _mxEvent = _interopRequireDefault(__webpack_require__(/*! ./mxEvent.js */ \"./src/workflow/mxClient/mxEvent.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxUndoableEdit(source, significant) {\n  this.source = source;\n  this.changes = [];\n  this.significant = significant != null ? significant : true;\n}\n;\n\n/**\r\n * Variable: source\r\n *\r\n * Specifies the source of the edit.\r\n */\nmxUndoableEdit.prototype.source = null;\n\n/**\r\n * Variable: changes\r\n *\r\n * Array that contains the changes that make up this edit. The changes are\r\n * expected to either have an undo and redo function, or an execute\r\n * function. Default is an empty array.\r\n */\nmxUndoableEdit.prototype.changes = null;\n\n/**\r\n * Variable: significant\r\n *\r\n * Specifies if the undoable change is significant.\r\n * Default is true.\r\n */\nmxUndoableEdit.prototype.significant = null;\n\n/**\r\n * Variable: undone\r\n *\r\n * Specifies if this edit has been undone. Default is false.\r\n */\nmxUndoableEdit.prototype.undone = false;\n\n/**\r\n * Variable: redone\r\n *\r\n * Specifies if this edit has been redone. Default is false.\r\n */\nmxUndoableEdit.prototype.redone = false;\n\n/**\r\n * Function: isEmpty\r\n *\r\n * Returns true if the this edit contains no changes.\r\n */\nmxUndoableEdit.prototype.isEmpty = function () {\n  return this.changes.length == 0;\n};\n\n/**\r\n * Function: isSignificant\r\n *\r\n * Returns <significant>.\r\n */\nmxUndoableEdit.prototype.isSignificant = function () {\n  return this.significant;\n};\n\n/**\r\n * Function: add\r\n *\r\n * Adds the specified change to this edit. The change is an object that is\r\n * expected to either have an undo and redo, or an execute function.\r\n */\nmxUndoableEdit.prototype.add = function (change) {\n  this.changes.push(change);\n};\n\n/**\r\n * Function: notify\r\n *\r\n * Hook to notify any listeners of the changes after an <undo> or <redo>\r\n * has been carried out. This implementation is empty.\r\n */\nmxUndoableEdit.prototype.notify = function () {};\n\n/**\r\n * Function: die\r\n *\r\n * Hook to free resources after the edit has been removed from the command\r\n * history. This implementation is empty.\r\n */\nmxUndoableEdit.prototype.die = function () {};\n\n/**\r\n * Function: undo\r\n *\r\n * Undoes all changes in this edit.\r\n */\nmxUndoableEdit.prototype.undo = function () {\n  if (!this.undone) {\n    this.source.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].START_EDIT));\n    var count = this.changes.length;\n    for (var i = count - 1; i >= 0; i--) {\n      var change = this.changes[i];\n      if (change.execute != null) {\n        change.execute();\n      } else if (change.undo != null) {\n        change.undo();\n      }\n\n      // New global executed event\n      this.source.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].EXECUTED, 'change', change));\n    }\n    this.undone = true;\n    this.redone = false;\n    this.source.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].END_EDIT));\n  }\n  this.notify();\n};\n\n/**\r\n * Function: redo\r\n *\r\n * Redoes all changes in this edit.\r\n */\nmxUndoableEdit.prototype.redo = function () {\n  if (!this.redone) {\n    this.source.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].START_EDIT));\n    var count = this.changes.length;\n    for (var i = 0; i < count; i++) {\n      var change = this.changes[i];\n      if (change.execute != null) {\n        change.execute();\n      } else if (change.redo != null) {\n        change.redo();\n      }\n\n      // New global executed event\n      this.source.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].EXECUTED, 'change', change));\n    }\n    this.undone = false;\n    this.redone = true;\n    this.source.fireEvent(new _mxEventObject[\"default\"](_mxEvent[\"default\"].END_EDIT));\n  }\n  this.notify();\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxUndoManager\r\n *\r\n * Implements a command history. When changing the graph model, an\r\n * <mxUndoableChange> object is created at the start of the transaction (when\r\n * model.beginUpdate is called). All atomic changes are then added to this\r\n * object until the last model.endUpdate call, at which point the\r\n * <mxUndoableEdit> is dispatched in an event, and added to the history inside\r\n * <mxUndoManager>. This is done by an event listener in\r\n * <mxEditor.installUndoHandler>.\r\n *\r\n * Each atomic change of the model is represented by an object (eg.\r\n * <mxRootChange>, <mxChildChange>, <mxTerminalChange> etc) which contains the\r\n * complete undo information. The <mxUndoManager> also listens to the\r\n * <mxGraphView> and stores it's changes to the current root as insignificant\r\n * undoable changes, so that drilling (step into, step up) is undone.\r\n *\r\n * This means when you execute an atomic change on the model, then change the\r\n * current root on the view and click undo, the change of the root will be\r\n * undone together with the change of the model so that the display represents\r\n * the state at which the model was changed. However, these changes are not\r\n * transmitted for sharing as they do not represent a state change.\r\n *\r\n * Example:\r\n *\r\n * When adding an undo manager to a graph, make sure to add it\r\n * to the model and the view as well to maintain a consistent\r\n * display across multiple undo/redo steps.\r\n *\r\n * (code)\r\n * var undoManager = new mxUndoManager();\r\n * var listener = function(sender, evt)\r\n * {\r\n *   undoManager.undoableEditHappened(evt.getProperty('edit'));\r\n * };\r\n * graph.getModel().addListener(mxEvent.UNDO, listener);\r\n * graph.getView().addListener(mxEvent.UNDO, listener);\r\n * (end)\r\n *\r\n * The code creates a function that informs the undoManager\r\n * of an undoable edit and binds it to the undo event of\r\n * <mxGraphModel> and <mxGraphView> using\r\n * <mxEventSource.addListener>.\r\n *\r\n * Event: mxEvent.CLEAR\r\n *\r\n * Fires after <clear> was invoked. This event has no properties.\r\n *\r\n * Event: mxEvent.UNDO\r\n *\r\n * Fires afer a significant edit was undone in <undo>. The <code>edit</code>\r\n * property contains the <mxUndoableEdit> that was undone.\r\n *\r\n * Event: mxEvent.REDO\r\n *\r\n * Fires afer a significant edit was redone in <redo>. The <code>edit</code>\r\n * property contains the <mxUndoableEdit> that was redone.\r\n *\r\n * Event: mxEvent.ADD\r\n *\r\n * Fires after an undoable edit was added to the history. The <code>edit</code>\r\n * property contains the <mxUndoableEdit> that was added.\r\n *\r\n * Constructor: mxUndoManager\r\n *\r\n * Constructs a new undo manager with the given history size. If no history\r\n * size is given, then a default size of 100 steps is used.\r\n */\nvar _default = exports[\"default\"] = mxUndoableEdit;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxUndoableEdit.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxUrlConverter.js":
/*!*************************************************!*\
  !*** ./src/workflow/mxClient/mxUrlConverter.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.last-index-of.js */ \"../../node_modules/core-js/modules/es.array.last-index-of.js\");\nvar mxUrlConverter = function mxUrlConverter() {\n  // Empty constructor\n};\n\n/**\r\n * Variable: enabled\r\n *\r\n * Specifies if the converter is enabled. Default is true.\r\n */\nmxUrlConverter.prototype.enabled = true;\n\n/**\r\n * Variable: baseUrl\r\n *\r\n * Specifies the base URL to be used as a prefix for relative URLs.\r\n */\nmxUrlConverter.prototype.baseUrl = null;\n\n/**\r\n * Variable: baseDomain\r\n *\r\n * Specifies the base domain to be used as a prefix for absolute URLs.\r\n */\nmxUrlConverter.prototype.baseDomain = null;\n\n/**\r\n * Function: updateBaseUrl\r\n *\r\n * Private helper function to update the base URL.\r\n */\nmxUrlConverter.prototype.updateBaseUrl = function () {\n  this.baseDomain = location.protocol + '//' + location.host;\n  this.baseUrl = this.baseDomain + location.pathname;\n  var tmp = this.baseUrl.lastIndexOf('/');\n\n  // Strips filename etc\n  if (tmp > 0) {\n    this.baseUrl = this.baseUrl.substring(0, tmp + 1);\n  }\n};\n\n/**\r\n * Function: isEnabled\r\n *\r\n * Returns <enabled>.\r\n */\nmxUrlConverter.prototype.isEnabled = function () {\n  return this.enabled;\n};\n\n/**\r\n * Function: setEnabled\r\n *\r\n * Sets <enabled>.\r\n */\nmxUrlConverter.prototype.setEnabled = function (value) {\n  this.enabled = value;\n};\n\n/**\r\n * Function: getBaseUrl\r\n *\r\n * Returns <baseUrl>.\r\n */\nmxUrlConverter.prototype.getBaseUrl = function () {\n  return this.baseUrl;\n};\n\n/**\r\n * Function: setBaseUrl\r\n *\r\n * Sets <baseUrl>.\r\n */\nmxUrlConverter.prototype.setBaseUrl = function (value) {\n  this.baseUrl = value;\n};\n\n/**\r\n * Function: getBaseDomain\r\n *\r\n * Returns <baseDomain>.\r\n */\nmxUrlConverter.prototype.getBaseDomain = function () {\n  return this.baseDomain;\n},\n/**\r\n * Function: setBaseDomain\r\n *\r\n * Sets <baseDomain>.\r\n */\nmxUrlConverter.prototype.setBaseDomain = function (value) {\n  this.baseDomain = value;\n},\n/**\r\n * Function: isRelativeUrl\r\n *\r\n * Returns true if the given URL is relative.\r\n */\nmxUrlConverter.prototype.isRelativeUrl = function (url) {\n  return url.substring(0, 2) != '//' && url.substring(0, 7) != 'http://' && url.substring(0, 8) != 'https://' && url.substring(0, 10) != 'data:image';\n};\n\n/**\r\n * Function: convert\r\n *\r\n * Converts the given URL to an absolute URL with protol and domain.\r\n * Relative URLs are first converted to absolute URLs.\r\n */\nmxUrlConverter.prototype.convert = function (url) {\n  if (this.isEnabled() && this.isRelativeUrl(url)) {\n    if (this.getBaseUrl() == null) {\n      this.updateBaseUrl();\n    }\n    if (url.charAt(0) == '/') {\n      url = this.getBaseDomain() + url;\n    } else {\n      url = this.getBaseUrl() + url;\n    }\n  }\n  return url;\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxPanningManager\r\n *\r\n * Implements a handler for panning.\r\n */\nvar _default = exports[\"default\"] = mxUrlConverter;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxUrlConverter.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxUtils.js":
/*!******************************************!*\
  !*** ./src/workflow/mxClient/mxUtils.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.symbol.js */ \"../../node_modules/core-js/modules/es.symbol.js\");\n__webpack_require__(/*! core-js/modules/es.symbol.description.js */ \"../../node_modules/core-js/modules/es.symbol.description.js\");\n__webpack_require__(/*! core-js/modules/es.symbol.iterator.js */ \"../../node_modules/core-js/modules/es.symbol.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.array.iterator.js */ \"../../node_modules/core-js/modules/es.array.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\n__webpack_require__(/*! core-js/modules/es.string.iterator.js */ \"../../node_modules/core-js/modules/es.string.iterator.js\");\n__webpack_require__(/*! core-js/modules/web.dom-collections.iterator.js */ \"../../node_modules/core-js/modules/web.dom-collections.iterator.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.index-of.js */ \"../../node_modules/core-js/modules/es.array.index-of.js\");\n__webpack_require__(/*! core-js/modules/es.array.join.js */ \"../../node_modules/core-js/modules/es.array.join.js\");\n__webpack_require__(/*! core-js/modules/es.array.sort.js */ \"../../node_modules/core-js/modules/es.array.sort.js\");\n__webpack_require__(/*! core-js/modules/es.array.splice.js */ \"../../node_modules/core-js/modules/es.array.splice.js\");\n__webpack_require__(/*! core-js/modules/es.date.to-string.js */ \"../../node_modules/core-js/modules/es.date.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.function.bind.js */ \"../../node_modules/core-js/modules/es.function.bind.js\");\n__webpack_require__(/*! core-js/modules/es.object.to-string.js */ \"../../node_modules/core-js/modules/es.object.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.parse-float.js */ \"../../node_modules/core-js/modules/es.parse-float.js\");\n__webpack_require__(/*! core-js/modules/es.parse-int.js */ \"../../node_modules/core-js/modules/es.parse-int.js\");\n__webpack_require__(/*! core-js/modules/es.regexp.exec.js */ \"../../node_modules/core-js/modules/es.regexp.exec.js\");\n__webpack_require__(/*! core-js/modules/es.regexp.to-string.js */ \"../../node_modules/core-js/modules/es.regexp.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.string.replace.js */ \"../../node_modules/core-js/modules/es.string.replace.js\");\n__webpack_require__(/*! core-js/modules/es.string.split.js */ \"../../node_modules/core-js/modules/es.string.split.js\");\n__webpack_require__(/*! core-js/modules/es.string.trim.js */ \"../../node_modules/core-js/modules/es.string.trim.js\");\n__webpack_require__(/*! core-js/modules/es.string.link.js */ \"../../node_modules/core-js/modules/es.string.link.js\");\nvar _mxDragSource = _interopRequireDefault(__webpack_require__(/*! ./mxDragSource.js */ \"./src/workflow/mxClient/mxDragSource.js\"));\nvar _mxEffects = _interopRequireDefault(__webpack_require__(/*! ./mxEffects.js */ \"./src/workflow/mxClient/mxEffects.js\"));\nvar _mxTemporaryCellStates = _interopRequireDefault(__webpack_require__(/*! ./mxTemporaryCellStates.js */ \"./src/workflow/mxClient/mxTemporaryCellStates.js\"));\nvar _mxDictionary = _interopRequireDefault(__webpack_require__(/*! ./mxDictionary.js */ \"./src/workflow/mxClient/mxDictionary.js\"));\nvar _mxWindow = _interopRequireDefault(__webpack_require__(/*! ./mxWindow.js */ \"./src/workflow/mxClient/mxWindow.js\"));\nvar _mxRectangle = _interopRequireDefault(__webpack_require__(/*! ./mxRectangle.js */ \"./src/workflow/mxClient/mxRectangle.js\"));\nvar _mxCodec = _interopRequireDefault(__webpack_require__(/*! ./mxCodec.js */ \"./src/workflow/mxClient/mxCodec.js\"));\nvar _mxCellPath = _interopRequireDefault(__webpack_require__(/*! ./mxCellPath.js */ \"./src/workflow/mxClient/mxCellPath.js\"));\nvar _mxClient = _interopRequireDefault(__webpack_require__(/*! ./mxClient.js */ \"./src/workflow/mxClient/mxClient.js\"));\nvar _mxPoint = _interopRequireDefault(__webpack_require__(/*! ./mxPoint.js */ \"./src/workflow/mxClient/mxPoint.js\"));\nvar _mxXmlRequest = _interopRequireDefault(__webpack_require__(/*! ./mxXmlRequest.js */ \"./src/workflow/mxClient/mxXmlRequest.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxEventUtils = _interopRequireDefault(__webpack_require__(/*! ./mxEventUtils.js */ \"./src/workflow/mxClient/mxEventUtils.js\"));\nvar _mxLog = _interopRequireDefault(__webpack_require__(/*! ./mxLog.js */ \"./src/workflow/mxClient/mxLog.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ./mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nvar _mxRequestUtils = _interopRequireDefault(__webpack_require__(/*! ./mxRequestUtils.js */ \"./src/workflow/mxClient/mxRequestUtils.js\"));\nvar _mxResources = _interopRequireDefault(__webpack_require__(/*! ./mxResources.js */ \"./src/workflow/mxClient/mxResources.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nvar mxUtils = {\n  /**\r\n   * Class: mxUtils\r\n   *\r\n   * A singleton class that provides cross-browser helper methods.\r\n   * This is a global functionality. To access the functions in this\r\n   * class, use the global classname appended by the functionname.\r\n   * You may have to load chrome://global/content/contentAreaUtils.js\r\n   * to disable certain security restrictions in Mozilla for the <open>,\r\n   * <save>, <saveAs> and <copy> function.\r\n   *\r\n   * For example, the following code displays an error message:\r\n   *\r\n   * (code)\r\n   * mxUtils.error('Browser is not supported!', 200, false);\r\n   * (end)\r\n   *\r\n   * Variable: errorResource\r\n   *\r\n   * Specifies the resource key for the title of the error window. If the\r\n   * resource for this key does not exist then the value is used as\r\n   * the title. Default is 'error'.\r\n   */\n  errorResource: _mxClient[\"default\"].language != 'none' ? 'error' : '',\n  /**\r\n   * Variable: closeResource\r\n   *\r\n   * Specifies the resource key for the label of the close button. If the\r\n   * resource for this key does not exist then the value is used as\r\n   * the label. Default is 'close'.\r\n   */\n  closeResource: _mxClient[\"default\"].language != 'none' ? 'close' : '',\n  /**\r\n   * Variable: errorImage\r\n   *\r\n   * Defines the image used for error dialogs.\r\n   */\n  errorImage: _mxClient[\"default\"].imageBasePath + '/error.gif',\n  /**\r\n   * Function: removeCursors\r\n   *\r\n   * Removes the cursors from the style of the given DOM node and its\r\n   * descendants.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * element - DOM node to remove the cursor style from.\r\n   */\n  removeCursors: function removeCursors(element) {\n    if (element.style != null) {\n      element.style.cursor = '';\n    }\n    var children = element.childNodes;\n    if (children != null) {\n      var childCount = children.length;\n      for (var i = 0; i < childCount; i += 1) {\n        mxUtils.removeCursors(children[i]);\n      }\n    }\n  },\n  /**\r\n   * Function: getCurrentStyle\r\n   *\r\n   * Returns the current style of the specified element.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * element - DOM node whose current style should be returned.\r\n   */\n  getCurrentStyle: _mxGraphUtils[\"default\"].getCurrentStyle,\n  /**\r\n   * Function: parseCssNumber\r\n   *\r\n   * Parses the given CSS numeric value adding handling for the values thin,\r\n   * medium and thick (2, 4 and 6).\r\n   */\n  parseCssNumber: function parseCssNumber(value) {\n    if (value == 'thin') {\n      value = '2';\n    } else if (value == 'medium') {\n      value = '4';\n    } else if (value == 'thick') {\n      value = '6';\n    }\n    value = parseFloat(value);\n    if (isNaN(value)) {\n      value = 0;\n    }\n    return value;\n  },\n  /**\r\n   * Function: setPrefixedStyle\r\n   *\r\n   * Adds the given style with the standard name and an optional vendor prefix for the current\r\n   * browser.\r\n   *\r\n   * (code)\r\n   * mxGraphUtils.setPrefixedStyle(node.style, 'transformOrigin', '0% 0%');\r\n   * (end)\r\n   */\n  setPrefixedStyle: _mxGraphUtils[\"default\"].setPrefixedStyle,\n  /**\r\n   * Function: hasScrollbars\r\n   *\r\n   * Returns true if the overflow CSS property of the given node is either\r\n   * scroll or auto.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * node - DOM node whose style should be checked for scrollbars.\r\n   */\n  hasScrollbars: function hasScrollbars(node) {\n    var style = _mxGraphUtils[\"default\"].getCurrentStyle(node);\n    return style != null && (style.overflow == 'scroll' || style.overflow == 'auto');\n  },\n  /**\r\n   * Function: bind\r\n   *\r\n   * becomes a reference to that scope.\r\n   */\n  bind: _mxGraphUtils[\"default\"].bind,\n  /**\r\n   * Function: eval\r\n   *\r\n   * Evaluates the given expression using eval and returns the JavaScript\r\n   * object that represents the expression result. Supports evaluation of\r\n   * these expressions.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * expr - A string that represents a JavaScript expression.\r\n   */\n  eval: _mxGraphUtils[\"default\"].eval,\n  /**\r\n   * Function: findNode\r\n   *\r\n   * Returns the first node where attr equals value.\r\n   * This implementation does not use XPath.\r\n   */\n  findNode: function findNode(node, attr, value) {\n    if (node.nodeType == _mxConstants[\"default\"].NODETYPE_ELEMENT) {\n      var tmp = node.getAttribute(attr);\n      if (tmp != null && tmp == value) {\n        return node;\n      }\n    }\n    node = node.firstChild;\n    while (node != null) {\n      var result = mxUtils.findNode(node, attr, value);\n      if (result != null) {\n        return result;\n      }\n      node = node.nextSibling;\n    }\n    return null;\n  },\n  /**\r\n   * Function: getFunctionName\r\n   *\r\n   * Returns the name for the given function.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * f - JavaScript object that represents a function.\r\n   */\n  getFunctionName: function getFunctionName(f) {\n    return _mxGraphUtils[\"default\"].getFunctionName(f);\n  },\n  /**\r\n   * Function: indexOf\r\n   *\r\n   * Returns the index of obj in array or -1 if the array does not contain\r\n   * the given object.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * array - Array to check for the given obj.\r\n   * obj - Object to find in the given array.\r\n   */\n  indexOf: function indexOf(array, obj) {\n    return _mxGraphUtils[\"default\"].indexOf(array, obj);\n  },\n  /**\r\n   * Function: forEach\r\n   *\r\n   * Calls the given function for each element of the given array and returns\r\n   * the array.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * array - Array that contains the elements.\r\n   * fn - Function to be called for each object.\r\n   */\n  forEach: function forEach(array, fn) {\n    if (array != null && fn != null) {\n      for (var i = 0; i < array.length; i++) {\n        fn(array[i]);\n      }\n    }\n    return array;\n  },\n  /**\r\n   * Function: remove\r\n   *\r\n   * Removes all occurrences of the given object in the given array or\r\n   * object. If there are multiple occurrences of the object, be they\r\n   * associative or as an array entry, all occurrences are removed from\r\n   * the array or deleted from the object. By removing the object from\r\n   * the array, all elements following the removed element are shifted\r\n   * by one step towards the beginning of the array.\r\n   *\r\n   * The length of arrays is not modified inside this function.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * obj - Object to find in the given array.\r\n   * array - Array to check for the given obj.\r\n   */\n  remove: function remove(obj, array) {\n    var result = null;\n    if (_typeof(array) == 'object') {\n      var index = _mxGraphUtils[\"default\"].indexOf(array, obj);\n      while (index >= 0) {\n        array.splice(index, 1);\n        result = obj;\n        index = _mxGraphUtils[\"default\"].indexOf(array, obj);\n      }\n    }\n    for (var key in array) {\n      if (array[key] == obj) {\n        delete array[key];\n        result = obj;\n      }\n    }\n    return result;\n  },\n  /**\r\n   * Function: isNode\r\n   *\r\n   * Returns true if the given value is an XML node with the node name\r\n   * and if the optional attribute has the specified value.\r\n   *\r\n   * This implementation assumes that the given value is a DOM node if the\r\n   * nodeType property is numeric, that is, if isNaN returns false for\r\n   * value.nodeType.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * value - Object that should be examined as a node.\r\n   * nodeName - String that specifies the node name.\r\n   * attributeName - Optional attribute name to check.\r\n   * attributeValue - Optional attribute value to check.\r\n   */\n  isNode: function isNode(value, nodeName, attributeName, attributeValue) {\n    return _mxGraphUtils[\"default\"].isNode(value, nodeName, attributeName, attributeValue);\n  },\n  /**\r\n   * Function: isAncestorNode\r\n   *\r\n   * Returns true if the given ancestor is an ancestor of the\r\n   * given DOM node in the DOM. This also returns true if the\r\n   * child is the ancestor.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * ancestor - DOM node that represents the ancestor.\r\n   * child - DOM node that represents the child.\r\n   */\n  isAncestorNode: function isAncestorNode(ancestor, child) {\n    return _mxGraphUtils[\"default\"].isAncestorNode(ancestor, child);\n  },\n  /**\r\n   * Function: getChildNodes\r\n   *\r\n   * Returns an array of child nodes that are of the given node type.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * node - Parent DOM node to return the children from.\r\n   * nodeType - Optional node type to return. Default is\r\n   * <mxConstants.NODETYPE_ELEMENT>.\r\n   */\n  getChildNodes: _mxGraphUtils[\"default\"].getChildNodes,\n  /**\r\n   * Function: importNode\r\n   *\r\n   * Cross browser implementation for document.importNode. Uses document.importNode\r\n   * in all browsers but IE, where the node is cloned by creating a new node and\r\n   * copying all attributes and children into it using importNode, recursively.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * doc - Document to import the node into.\r\n   * node - Node to be imported.\r\n   * allChildren - If all children should be imported.\r\n   */\n  importNode: _mxGraphUtils[\"default\"].importNode,\n  /**\r\n   * Function: createXmlDocument\r\n   *\r\n   * Returns a new, empty XML document.\r\n   */\n  createXmlDocument: function createXmlDocument() {\n    return _mxGraphUtils[\"default\"].createXmlDocument();\n  },\n  /**\r\n   * Function: parseXml\r\n   *\r\n   * Parses the specified XML string into a new XML document and returns the\r\n   * new document.\r\n   *\r\n   * Example:\r\n   *\r\n   * (code)\r\n   * var doc = mxUtils.parseXml(\r\n   *   '<mxGraphModel><root><MyDiagram id=\"0\"><mxCell/></MyDiagram>'+\r\n   *   '<MyLayer id=\"1\"><mxCell parent=\"0\" /></MyLayer><MyObject id=\"2\">'+\r\n   *   '<mxCell style=\"strokeColor=blue;fillColor=red\" parent=\"1\" vertex=\"1\">'+\r\n   *   '<mxGeometry x=\"10\" y=\"10\" width=\"80\" height=\"30\" as=\"geometry\"/>'+\r\n   *   '</mxCell></MyObject></root></mxGraphModel>');\r\n   * (end)\r\n   *\r\n   * Parameters:\r\n   *\r\n   * xml - String that contains the XML data.\r\n   */\n  parseXml: _mxGraphUtils[\"default\"].parseXml,\n  /**\r\n   * Function: clearSelection\r\n   *\r\n   * Clears the current selection in the page.\r\n   */\n  clearSelection: function () {\n    if (document.selection) {\n      return function () {\n        document.selection.empty();\n      };\n    } else if (window.getSelection) {\n      return function () {\n        window.getSelection().removeAllRanges();\n      };\n    } else {\n      return function () {};\n    }\n  }(),\n  /**\r\n   * Function: getPrettyXML\r\n   *\r\n   * Returns a pretty printed string that represents the XML tree for the\r\n   * given node. This method should only be used to print XML for reading,\r\n   * use <getXml> instead to obtain a string for processing.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * node - DOM node to return the XML for.\r\n   * tab - Optional string that specifies the indentation for one level.\r\n   * Default is two spaces.\r\n   * indent - Optional string that represents the current indentation.\r\n   * Default is an empty string.\r\n   */\n  getPrettyXml: function getPrettyXml(node, tab, indent) {\n    var result = [];\n    if (node != null) {\n      tab = tab || '  ';\n      indent = indent || '';\n      if (node.nodeType == _mxConstants[\"default\"].NODETYPE_TEXT) {\n        result.push(node.value);\n      } else {\n        result.push(indent + '<' + node.nodeName);\n\n        // Creates the string with the node attributes\n        // and converts all HTML entities in the values\n        var attrs = node.attributes;\n        if (attrs != null) {\n          for (var i = 0; i < attrs.length; i++) {\n            var val = _mxGraphUtils[\"default\"].htmlEntities(attrs[i].value);\n            result.push(' ' + attrs[i].nodeName + '=\"' + val + '\"');\n          }\n        }\n\n        // Recursively creates the XML string for each\n        // child nodes and appends it here with an\n        // indentation\n        var tmp = node.firstChild;\n        if (tmp != null) {\n          result.push('>\\n');\n          while (tmp != null) {\n            result.push(mxUtils.getPrettyXml(tmp, tab, indent + tab));\n            tmp = tmp.nextSibling;\n          }\n          result.push(indent + '</' + node.nodeName + '>\\n');\n        } else {\n          result.push('/>\\n');\n        }\n      }\n    }\n    return result.join('');\n  },\n  /**\r\n   * Function: removeWhitespace\r\n   *\r\n   * Removes the sibling text nodes for the given node that only consists\r\n   * of tabs, newlines and spaces.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * node - DOM node whose siblings should be removed.\r\n   * before - Optional boolean that specifies the direction of the traversal.\r\n   */\n  removeWhitespace: _mxGraphUtils[\"default\"].removeWhitespace,\n  /**\r\n   * Function: htmlEntities\r\n   *\r\n   * Replaces characters (less than, greater than, newlines and quotes) with\r\n   * their HTML entities in the given string and returns the result.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * s - String that contains the characters to be converted.\r\n   * newline - If newlines should be replaced. Default is true.\r\n   */\n  htmlEntities: function htmlEntities(s, newline) {\n    return _mxGraphUtils[\"default\"].htmlEntities(s, newline);\n  },\n  /**\r\n   * Function: isVml\r\n   *\r\n   * Returns true if the given node is in the VML namespace.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * node - DOM node whose tag urn should be checked.\r\n   */\n  isVml: function isVml(node) {\n    return _mxGraphUtils[\"default\"].isVml(node);\n  },\n  /**\r\n   * Function: getXml\r\n   *\r\n   * Returns the XML content of the specified node. For Internet Explorer,\r\n   * all \\r\\n\\t[\\t]* are removed from the XML string and the remaining \\r\\n\r\n   * are replaced by \\n. All \\n are then replaced with linefeed, or &#xa; if\r\n   * no linefeed is defined.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * node - DOM node to return the XML for.\r\n   * linefeed - Optional string that linefeeds are converted into. Default is\r\n   * &#xa;\r\n   */\n  getXml: function getXml(node, linefeed) {\n    var xml = '';\n    if (window.XMLSerializer != null) {\n      var xmlSerializer = new XMLSerializer();\n      xml = xmlSerializer.serializeToString(node);\n    } else if (node.xml != null) {\n      xml = node.xml.replace(/\\r\\n\\t[\\t]*/g, '').replace(/>\\r\\n/g, '>').replace(/\\r\\n/g, '\\n');\n    }\n\n    // Replaces linefeeds with HTML Entities.\n    linefeed = linefeed || '&#xa;';\n    xml = xml.replace(/\\n/g, linefeed);\n    return xml;\n  },\n  /**\r\n   * Function: extractTextWithWhitespace\r\n   *\r\n   * Returns the text content of the specified node.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * elems - DOM nodes to return the text for.\r\n   */\n  extractTextWithWhitespace: function extractTextWithWhitespace(elems) {\n    // Converts newlines in plain text to breaks in HTML\n    // to match the plain text output\n    var ignoreBr = false;\n    var ret = [];\n    for (var i = 0; elems[i]; i++) {\n      var elem = elems[i];\n\n      // Get the text from text nodes and CDATA nodes\n      if (elem.nodeType === 3 || elem.nodeType === 4) {\n        // Workaround for last empty element in IE 11\n        if (document.documentMode == 11 && i == elems.length - 1 && elem.nodeValue.length == 0) {\n          break;\n        }\n\n        // Only inserts a newline if the next element is not another text element\n        ret.push(elem.nodeValue + (elem.nextSibling == null || elem.nextSibling.nodeType != 3 ? '\\n' : ''));\n        ignoreBr = true;\n\n        // Traverse everything else, except comment nodes\n      } else if (elem.nodeType !== 8) {\n        // Best effort normalization translates BR (except after text) and empty P (in IE) to line breaks\n        if ((_mxClient[\"default\"].IS_IE || _mxClient[\"default\"].IS_IE11) && elem.nodeName == 'P' && elem.innerHTML.length == 0 || !ignoreBr && elem.nodeName == 'BR' || elem.nodeName == 'DIV' && elem.innerHTML == '<br>') {\n          ret.push('\\n');\n        } else {\n          ret.push(mxUtils.extractTextWithWhitespace(elem.childNodes));\n        }\n        ignoreBr = false;\n      }\n    }\n    return ret.join('');\n  },\n  /**\r\n   * Function: replaceTrailingNewlines\r\n   *\r\n   * Replaces each trailing newline with the given pattern.\r\n   */\n  replaceTrailingNewlines: function replaceTrailingNewlines(str, pattern) {\n    return _mxGraphUtils[\"default\"].replaceTrailingNewlines(str, pattern);\n  },\n  /**\r\n   * Function: getTextContent\r\n   *\r\n   * Returns the text content of the specified node.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * node - DOM node to return the text content for.\r\n   */\n  getTextContent: _mxGraphUtils[\"default\"].getTextContent,\n  /**\r\n   * Function: setTextContent\r\n   *\r\n   * Sets the text content of the specified node.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * node - DOM node to set the text content for.\r\n   * text - String that represents the text content.\r\n   */\n  setTextContent: _mxGraphUtils[\"default\"].setTextContent,\n  /**\r\n   * Function: getInnerHtml\r\n   *\r\n   * Returns the inner HTML for the given node as a string or an empty string\r\n   * if no node was specified. The inner HTML is the text representing all\r\n   * children of the node, but not the node itself.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * node - DOM node to return the inner HTML for.\r\n   */\n  getInnerHtml: _mxGraphUtils[\"default\"].getInnerHtml,\n  /**\r\n   * Function: getOuterHtml\r\n   *\r\n   * Returns the outer HTML for the given node as a string or an empty\r\n   * string if no node was specified. The outer HTML is the text representing\r\n   * all children of the node including the node itself.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * node - DOM node to return the outer HTML for.\r\n   */\n  getOuterHtml: _mxGraphUtils[\"default\"].getOuterHtml,\n  /**\r\n   * Function: write\r\n   *\r\n   * Creates a text node for the given string and appends it to the given\r\n   * parent. Returns the text node.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * parent - DOM node to append the text node to.\r\n   * text - String representing the text to be added.\r\n   */\n  write: function write(parent, text) {\n    return _mxGraphUtils[\"default\"].write(parent, text);\n  },\n  /**\r\n   * Function: writeln\r\n   *\r\n   * Creates a text node for the given string and appends it to the given\r\n   * parent with an additional linefeed. Returns the text node.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * parent - DOM node to append the text node to.\r\n   * text - String representing the text to be added.\r\n   */\n  writeln: function writeln(parent, text) {\n    return _mxGraphUtils[\"default\"].writeln(parent, text);\n  },\n  /**\r\n   * Function: br\r\n   *\r\n   * Appends a linebreak to the given parent and returns the linebreak.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * parent - DOM node to append the linebreak to.\r\n   */\n  br: function br(parent, count) {\n    count = count || 1;\n    var br = null;\n    for (var i = 0; i < count; i++) {\n      if (parent != null) {\n        br = parent.ownerDocument.createElement('br');\n        parent.appendChild(br);\n      }\n    }\n    return br;\n  },\n  /**\r\n   * Function: button\r\n   *\r\n   * Returns a new button with the given level and function as an onclick\r\n   * event handler.\r\n   *\r\n   * (code)\r\n   * document.body.appendChild(mxUtils.button('Test', function(evt)\r\n   * {\r\n   *   alert('Hello, World!');\r\n   * }));\r\n   * (end)\r\n   *\r\n   * Parameters:\r\n   *\r\n   * label - String that represents the label of the button.\r\n   * funct - Function to be called if the button is pressed.\r\n   * doc - Optional document to be used for creating the button. Default is the\r\n   * current document.\r\n   */\n  button: function button(label, funct, doc) {\n    doc = doc != null ? doc : document;\n    var button = doc.createElement('button');\n    _mxGraphUtils[\"default\"].write(button, label);\n    _mxEventUtils[\"default\"].addListener(button, 'click', function (evt) {\n      funct(evt);\n    });\n    return button;\n  },\n  /**\r\n   * Function: para\r\n   *\r\n   * Appends a new paragraph with the given text to the specified parent and\r\n   * returns the paragraph.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * parent - DOM node to append the text node to.\r\n   * text - String representing the text for the new paragraph.\r\n   */\n  para: function para(parent, text) {\n    var p = document.createElement('p');\n    _mxGraphUtils[\"default\"].write(p, text);\n    if (parent != null) {\n      parent.appendChild(p);\n    }\n    return p;\n  },\n  /**\r\n   * Function: addTransparentBackgroundFilter\r\n   *\r\n   * Adds a transparent background to the filter of the given node. This\r\n   * background can be used in IE8 standards mode (native IE8 only) to pass\r\n   * events through the node.\r\n   */\n  addTransparentBackgroundFilter: function addTransparentBackgroundFilter(node) {\n    _mxGraphUtils[\"default\"].addTransparentBackgroundFilter(node);\n  },\n  /**\r\n   * Function: linkAction\r\n   *\r\n   * Adds a hyperlink to the specified parent that invokes action on the\r\n   * specified editor.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * parent - DOM node to contain the new link.\r\n   * text - String that is used as the link label.\r\n   * editor - <mxEditor> that will execute the action.\r\n   * action - String that defines the name of the action to be executed.\r\n   * pad - Optional left-padding for the link. Default is 0.\r\n   */\n  linkAction: function linkAction(parent, text, editor, action, pad) {\n    return mxUtils.link(parent, text, function () {\n      editor.execute(action);\n    }, pad);\n  },\n  /**\r\n   * Function: linkInvoke\r\n   *\r\n   * Adds a hyperlink to the specified parent that invokes the specified\r\n   * function on the editor passing along the specified argument. The\r\n   * function name is the name of a function of the editor instance,\r\n   * not an action name.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * parent - DOM node to contain the new link.\r\n   * text - String that is used as the link label.\r\n   * editor - <mxEditor> instance to execute the function on.\r\n   * functName - String that represents the name of the function.\r\n   * arg - Object that represents the argument to the function.\r\n   * pad - Optional left-padding for the link. Default is 0.\r\n   */\n  linkInvoke: function linkInvoke(parent, text, editor, functName, arg, pad) {\n    return mxUtils.link(parent, text, function () {\n      editor[functName](arg);\n    }, pad);\n  },\n  /**\r\n   * Function: link\r\n   *\r\n   * Adds a hyperlink to the specified parent and invokes the given function\r\n   * when the link is clicked.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * parent - DOM node to contain the new link.\r\n   * text - String that is used as the link label.\r\n   * funct - Function to execute when the link is clicked.\r\n   * pad - Optional left-padding for the link. Default is 0.\r\n   */\n  link: function link(parent, text, funct, pad) {\n    var a = document.createElement('span');\n    a.style.color = 'blue';\n    a.style.textDecoration = 'underline';\n    a.style.cursor = 'pointer';\n    if (pad != null) {\n      a.style.paddingLeft = pad + 'px';\n    }\n    _mxEventUtils[\"default\"].addListener(a, 'click', funct);\n    _mxGraphUtils[\"default\"].write(a, text);\n    if (parent != null) {\n      parent.appendChild(a);\n    }\n    return a;\n  },\n  /**\r\n   * Function: fit\r\n   *\r\n   * Makes sure the given node is inside the visible area of the window. This\r\n   * is done by setting the left and top in the style.\r\n   */\n  fit: function fit(node) {\n    var left = parseInt(node.offsetLeft);\n    var width = parseInt(node.offsetWidth);\n    var offset = mxUtils.getDocumentScrollOrigin(node.ownerDocument);\n    var sl = offset.x;\n    var st = offset.y;\n    var b = document.body;\n    var d = document.documentElement;\n    var right = sl + (b.clientWidth || d.clientWidth);\n    if (left + width > right) {\n      node.style.left = Math.max(sl, right - width) + 'px';\n    }\n    var top = parseInt(node.offsetTop);\n    var height = parseInt(node.offsetHeight);\n    var bottom = st + Math.max(b.clientHeight || 0, d.clientHeight);\n    if (top + height > bottom) {\n      node.style.top = Math.max(st, bottom - height) + 'px';\n    }\n  },\n  /**\r\n   * Function: load\r\n   *\r\n   * Loads the specified URL *synchronously* and returns the <mxXmlRequest>.\r\n   * Throws an exception if the file cannot be loaded. See <mxRequestUtils.get> for\r\n   * an asynchronous implementation.\r\n   *\r\n   * Example:\r\n   *\r\n   * (code)\r\n   * try\r\n   * {\r\n   *   var req = mxRequestUtils.load(filename);\r\n   *   var root = req.getDocumentElement();\r\n   *   // Process XML DOM...\r\n   * }\r\n   * catch (ex)\r\n   * {\r\n   *   mxUtils.alert('Cannot load '+filename+': '+ex);\r\n   * }\r\n   * (end)\r\n   *\r\n   * Parameters:\r\n   *\r\n   * url - URL to get the data from.\r\n   */\n  load: function load(url) {\n    return _mxRequestUtils[\"default\"].load(url);\n  },\n  /**\r\n   * Function: get\r\n   *\r\n   * Loads the specified URL *asynchronously* and invokes the given functions\r\n   * depending on the request status. Returns the <mxXmlRequest> in use. Both\r\n   * functions take the <mxXmlRequest> as the only parameter. See\r\n   * <mxRequestUtils.load> for a synchronous implementation.\r\n   *\r\n   * Example:\r\n   *\r\n   * (code)\r\n   * mxRequestUtils.get(url, function(req)\r\n   * {\r\n   *    var node = req.getDocumentElement();\r\n   *    // Process XML DOM...\r\n   * });\r\n   * (end)\r\n   *\r\n   * So for example, to load a diagram into an existing graph model, the\r\n   * following code is used.\r\n   *\r\n   * (code)\r\n   * mxRequestUtils.get(url, function(req)\r\n   * {\r\n   *   var node = req.getDocumentElement();\r\n   *   var dec = new mxCodec(node.ownerDocument);\r\n   *   dec.decode(node, graph.getModel());\r\n   * });\r\n   * (end)\r\n   *\r\n   * Parameters:\r\n   *\r\n   * url - URL to get the data from.\r\n   * onload - Optional function to execute for a successful response.\r\n   * onerror - Optional function to execute on error.\r\n   * binary - Optional boolean parameter that specifies if the request is\r\n   * binary.\r\n   * timeout - Optional timeout in ms before calling ontimeout.\r\n   * ontimeout - Optional function to execute on timeout.\r\n   */\n  get: function get(url, onload, onerror, binary, timeout, ontimeout) {\n    return _mxRequestUtils[\"default\"].get(url, onload, onerror, binary, timeout, ontimeout);\n  },\n  /**\r\n   * Function: getAll\r\n   *\r\n   * Loads the URLs in the given array *asynchronously* and invokes the given function\r\n   * if all requests returned with a valid 2xx status. The error handler is invoked\r\n   * once on the first error or invalid response.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * urls - Array of URLs to be loaded.\r\n   * onload - Callback with array of <mxXmlRequests>.\r\n   * onerror - Optional function to execute on error.\r\n   */\n  getAll: function getAll(urls, onload, onerror) {\n    var remain = urls.length;\n    var result = [];\n    var errors = 0;\n    var err = function err() {\n      if (errors == 0 && onerror != null) {\n        onerror();\n      }\n      errors++;\n    };\n    for (var i = 0; i < urls.length; i++) {\n      (function (url, index) {\n        _mxRequestUtils[\"default\"].get(url, function (req) {\n          var status = req.getStatus();\n          if (status < 200 || status > 299) {\n            err();\n          } else {\n            result[index] = req;\n            remain--;\n            if (remain == 0) {\n              onload(result);\n            }\n          }\n        }, err);\n      })(urls[i], i);\n    }\n    if (remain == 0) {\n      onload(result);\n    }\n  },\n  /**\r\n   * Function: post\r\n   *\r\n   * Posts the specified params to the given URL *asynchronously* and invokes\r\n   * the given functions depending on the request status. Returns the\r\n   * <mxXmlRequest> in use. Both functions take the <mxXmlRequest> as the\r\n   * only parameter. Make sure to use encodeURIComponent for the parameter\r\n   * values.\r\n   *\r\n   * Example:\r\n   *\r\n   * (code)\r\n   * mxUtils.post(url, 'key=value', function(req)\r\n   * {\r\n   * \tmxUtils.alert('Ready: '+req.isReady()+' Status: '+req.getStatus());\r\n   *  // Process req.getDocumentElement() using DOM API if OK...\r\n   * });\r\n   * (end)\r\n   *\r\n   * Parameters:\r\n   *\r\n   * url - URL to get the data from.\r\n   * params - Parameters for the post request.\r\n   * onload - Optional function to execute for a successful response.\r\n   * onerror - Optional function to execute on error.\r\n   */\n  post: function post(url, params, onload, onerror) {\n    return new _mxXmlRequest[\"default\"](url, params).send(onload, onerror);\n  },\n  /**\r\n   * Function: submit\r\n   *\r\n   * Submits the given parameters to the specified URL using\r\n   * <mxXmlRequest.simulate> and returns the <mxXmlRequest>.\r\n   * Make sure to use encodeURIComponent for the parameter\r\n   * values.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * url - URL to get the data from.\r\n   * params - Parameters for the form.\r\n   * doc - Document to create the form in.\r\n   * target - Target to send the form result to.\r\n   */\n  submit: function submit(url, params, doc, target) {\n    return new _mxXmlRequest[\"default\"](url, params).simulate(doc, target);\n  },\n  /**\r\n   * Function: loadInto\r\n   *\r\n   * Loads the specified URL *asynchronously* into the specified document,\r\n   * invoking onload after the document has been loaded. This implementation\r\n   * does not use <mxXmlRequest>, but the document.load method.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * url - URL to get the data from.\r\n   * doc - The document to load the URL into.\r\n   * onload - Function to execute when the URL has been loaded.\r\n   */\n  loadInto: function loadInto(url, doc, onload) {\n    if (_mxClient[\"default\"].IS_IE) {\n      doc.onreadystatechange = function () {\n        if (doc.readyState == 4) {\n          onload();\n        }\n      };\n    } else {\n      doc.addEventListener('load', onload, false);\n    }\n    doc.load(url);\n  },\n  /**\r\n   * Function: getValue\r\n   *\r\n   * Returns the value for the given key in the given associative array or\r\n   * the given default value if the value is null.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * array - Associative array that contains the value for the key.\r\n   * key - Key whose value should be returned.\r\n   * defaultValue - Value to be returned if the value for the given\r\n   * key is null.\r\n   */\n  getValue: function getValue(array, key, defaultValue) {\n    return _mxGraphUtils[\"default\"].getValue(array, key, defaultValue);\n  },\n  /**\r\n   * Function: getNumber\r\n   *\r\n   * Returns the numeric value for the given key in the given associative\r\n   * array or the given default value (or 0) if the value is null. The value\r\n   * is converted to a numeric value using the Number function.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * array - Associative array that contains the value for the key.\r\n   * key - Key whose value should be returned.\r\n   * defaultValue - Value to be returned if the value for the given\r\n   * key is null. Default is 0.\r\n   */\n  getNumber: function getNumber(array, key, defaultValue) {\n    return _mxGraphUtils[\"default\"].getNumber(array, key, defaultValue);\n  },\n  /**\r\n   * Function: getColor\r\n   *\r\n   * Returns the color value for the given key in the given associative\r\n   * array or the given default value if the value is null. If the value\r\n   * is <mxConstants.NONE> then null is returned.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * array - Associative array that contains the value for the key.\r\n   * key - Key whose value should be returned.\r\n   * defaultValue - Value to be returned if the value for the given\r\n   * key is null. Default is null.\r\n   */\n  getColor: function getColor(array, key, defaultValue) {\n    return _mxGraphUtils[\"default\"].getColor(array, key, defaultValue);\n  },\n  /**\r\n   * Function: clone\r\n   *\r\n   * Recursively clones the specified object ignoring all fieldnames in the\r\n   * given array of transient fields. <mxObjectIdentity.FIELD_NAME> is always\r\n   * ignored by this function.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * obj - Object to be cloned.\r\n   * transients - Optional array of strings representing the fieldname to be\r\n   * ignored.\r\n   * shallow - Optional boolean argument to specify if a shallow clone should\r\n   * be created, that is, one where all object references are not cloned or,\r\n   * in other words, one where only atomic (strings, numbers) values are\r\n   * cloned. Default is false.\r\n   */\n  clone: function clone(obj, transients, shallow) {\n    return _mxGraphUtils[\"default\"].clone(obj, transients, shallow);\n  },\n  /**\r\n   * Function: equalPoints\r\n   *\r\n   * Compares all mxPoints in the given lists.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * a - Array of <mxPoints> to be compared.\r\n   * b - Array of <mxPoints> to be compared.\r\n   */\n  equalPoints: function equalPoints(a, b) {\n    if (a == null && b != null || a != null && b == null || a != null && b != null && a.length != b.length) {\n      return false;\n    } else if (a != null && b != null) {\n      for (var i = 0; i < a.length; i++) {\n        if (a[i] == b[i] || a[i] != null && !a[i].equals(b[i])) {\n          return false;\n        }\n      }\n    }\n    return true;\n  },\n  /**\r\n   * Function: equalEntries\r\n   *\r\n   * Returns true if all properties of the given objects are equal. Values\r\n   * with NaN are equal to NaN and unequal to any other value.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * a - First object to be compared.\r\n   * b - Second object to be compared.\r\n   */\n  equalEntries: function equalEntries(a, b) {\n    if (a == null && b != null || a != null && b == null || a != null && b != null && a.length != b.length) {\n      return false;\n    } else if (a != null && b != null) {\n      // Counts keys in b to check if all values have been compared\n      var count = 0;\n      for (var key in b) {\n        count++;\n      }\n      for (var key in a) {\n        count--;\n        if ((!mxUtils.isNaN(a[key]) || !mxUtils.isNaN(b[key])) && a[key] != b[key]) {\n          return false;\n        }\n      }\n    }\n    return count == 0;\n  },\n  /**\r\n   * Function: removeDuplicates\r\n   *\r\n   * Removes all duplicates from the given array.\r\n   */\n  removeDuplicates: function removeDuplicates(arr) {\n    var dict = new _mxDictionary[\"default\"]();\n    var result = [];\n    for (var i = 0; i < arr.length; i++) {\n      if (!dict.get(arr[i])) {\n        result.push(arr[i]);\n        dict.put(arr[i], true);\n      }\n    }\n    return result;\n  },\n  /**\r\n   * Function: isNaN\r\n   *\r\n   * Returns true if the given value is of type number and isNaN returns true.\r\n   */\n  isNaN: function (_isNaN) {\n    function isNaN(_x) {\n      return _isNaN.apply(this, arguments);\n    }\n    isNaN.toString = function () {\n      return _isNaN.toString();\n    };\n    return isNaN;\n  }(function (value) {\n    return typeof value == 'number' && isNaN(value);\n  }),\n  /**\r\n   * Function: extend\r\n   *\r\n   * Assigns a copy of the superclass prototype to the subclass prototype.\r\n   * Note that this does not call the constructor of the superclass at this\r\n   * point, the superclass constructor should be called explicitely in the\r\n   * subclass constructor. Below is an example.\r\n   *\r\n   * (code)\r\n   * MyGraph = function(container, model, renderHint, stylesheet)\r\n   * {\r\n   *   mxGraph.call(this, container, model, renderHint, stylesheet);\r\n   * }\r\n   *\r\n   * mxGraphUtils.extend(MyGraph, mxGraph);\r\n   * (end)\r\n   *\r\n   * Parameters:\r\n   *\r\n   * ctor - Constructor of the subclass.\r\n   * superCtor - Constructor of the superclass.\r\n   */\n  extend: function extend(ctor, superCtor) {\n    _mxGraphUtils[\"default\"].extend(ctor, superCtor);\n  },\n  /**\r\n   * Function: toString\r\n   *\r\n   * Returns a textual representation of the specified object.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * obj - Object to return the string representation for.\r\n   */\n  toString: function toString(obj) {\n    return _mxGraphUtils[\"default\"].toString(obj);\n  },\n  /**\r\n   * Function: toRadians\r\n   *\r\n   * Converts the given degree to radians.\r\n   */\n  toRadians: _mxGraphUtils[\"default\"].toRadians,\n  /**\r\n   * Function: toDegree\r\n   *\r\n   * Converts the given radians to degree.\r\n   */\n  toDegree: _mxGraphUtils[\"default\"].toDegree,\n  /**\r\n   * Function: arcToCurves\r\n   *\r\n   * Converts the given arc to a series of curves.\r\n   */\n  arcToCurves: function arcToCurves(x0, y0, r1, r2, angle, largeArcFlag, sweepFlag, x, y) {\n    return _mxGraphUtils[\"default\"].arcToCurves(x0, y0, r1, r2, angle, largeArcFlag, sweepFlag, x, y);\n  },\n  /**\r\n   * Function: getBoundingBox\r\n   *\r\n   * Returns the bounding box for the rotated rectangle.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * rect - <mxRectangle> to be rotated.\r\n   * angle - Number that represents the angle (in degrees).\r\n   * cx - Optional <mxPoint> that represents the rotation center. If no\r\n   * rotation center is given then the center of rect is used.\r\n   */\n  getBoundingBox: function getBoundingBox(rect, rotation, cx) {\n    var result = null;\n    if (rect != null && rotation != null && rotation != 0) {\n      var rad = mxUtils.toRadians(rotation);\n      var cos = Math.cos(rad);\n      var sin = Math.sin(rad);\n      cx = cx != null ? cx : new _mxPoint[\"default\"](rect.x + rect.width / 2, rect.y + rect.height / 2);\n      var p1 = new _mxPoint[\"default\"](rect.x, rect.y);\n      var p2 = new _mxPoint[\"default\"](rect.x + rect.width, rect.y);\n      var p3 = new _mxPoint[\"default\"](p2.x, rect.y + rect.height);\n      var p4 = new _mxPoint[\"default\"](rect.x, p3.y);\n      p1 = mxUtils.getRotatedPoint(p1, cos, sin, cx);\n      p2 = mxUtils.getRotatedPoint(p2, cos, sin, cx);\n      p3 = mxUtils.getRotatedPoint(p3, cos, sin, cx);\n      p4 = mxUtils.getRotatedPoint(p4, cos, sin, cx);\n      result = new _mxRectangle[\"default\"](p1.x, p1.y, 0, 0);\n      result.add(new _mxRectangle[\"default\"](p2.x, p2.y, 0, 0));\n      result.add(new _mxRectangle[\"default\"](p3.x, p3.y, 0, 0));\n      result.add(new _mxRectangle[\"default\"](p4.x, p4.y, 0, 0));\n    }\n    return result;\n  },\n  /**\r\n   * Function: getRotatedPoint\r\n   *\r\n   * Rotates the given point by the given cos and sin.\r\n   */\n  getRotatedPoint: function getRotatedPoint(pt, cos, sin, c) {\n    c = c != null ? c : new _mxPoint[\"default\"]();\n    var x = pt.x - c.x;\n    var y = pt.y - c.y;\n    var x1 = x * cos - y * sin;\n    var y1 = y * cos + x * sin;\n    return new _mxPoint[\"default\"](x1 + c.x, y1 + c.y);\n  },\n  /**\r\n   * Returns an integer mask of the port constraints of the given map\r\n   * @param dict the style map to determine the port constraints for\r\n   * @param defaultValue Default value to return if the key is undefined.\r\n   * @return the mask of port constraint directions\r\n   *\r\n   * Parameters:\r\n   *\r\n   * terminal - <mxCelState> that represents the terminal.\r\n   * edge - <mxCellState> that represents the edge.\r\n   * source - Boolean that specifies if the terminal is the source terminal.\r\n   * defaultValue - Default value to be returned.\r\n   */\n  getPortConstraints: function getPortConstraints(terminal, edge, source, defaultValue) {\n    return _mxGraphUtils[\"default\"].getPortConstraints(terminal, edge, source, defaultValue);\n  },\n  /**\r\n   * Function: reversePortConstraints\r\n   *\r\n   * Reverse the port constraint bitmask. For example, north | east\r\n   * becomes south | west\r\n   */\n  reversePortConstraints: function reversePortConstraints(constraint) {\n    return _mxGraphUtils[\"default\"].reversePortConstraints(constraint);\n  },\n  /**\r\n   * Function: findNearestSegment\r\n   *\r\n   * Finds the index of the nearest segment on the given cell state for\r\n   * the specified coordinate pair.\r\n   */\n  findNearestSegment: _mxGraphUtils[\"default\"].findNearestSegment,\n  /**\r\n   * Function: rectangleIntersectsSegment\r\n   *\r\n   * Returns true if the given rectangle intersects the given segment.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * bounds - <mxRectangle> that represents the rectangle.\r\n   * p1 - <mxPoint> that represents the first point of the segment.\r\n   * p2 - <mxPoint> that represents the second point of the segment.\r\n   */\n  rectangleIntersectsSegment: function rectangleIntersectsSegment(bounds, p1, p2) {\n    var top = bounds.y;\n    var left = bounds.x;\n    var bottom = top + bounds.height;\n    var right = left + bounds.width;\n\n    // Find min and max X for the segment\n    var minX = p1.x;\n    var maxX = p2.x;\n    if (p1.x > p2.x) {\n      minX = p2.x;\n      maxX = p1.x;\n    }\n\n    // Find the intersection of the segment's and rectangle's x-projections\n    if (maxX > right) {\n      maxX = right;\n    }\n    if (minX < left) {\n      minX = left;\n    }\n    if (minX > maxX)\n      // If their projections do not intersect return false\n      {\n        return false;\n      }\n\n    // Find corresponding min and max Y for min and max X we found before\n    var minY = p1.y;\n    var maxY = p2.y;\n    var dx = p2.x - p1.x;\n    if (Math.abs(dx) > 0.0000001) {\n      var a = (p2.y - p1.y) / dx;\n      var b = p1.y - a * p1.x;\n      minY = a * minX + b;\n      maxY = a * maxX + b;\n    }\n    if (minY > maxY) {\n      var tmp = maxY;\n      maxY = minY;\n      minY = tmp;\n    }\n\n    // Find the intersection of the segment's and rectangle's y-projections\n    if (maxY > bottom) {\n      maxY = bottom;\n    }\n    if (minY < top) {\n      minY = top;\n    }\n    if (minY > maxY)\n      // If Y-projections do not intersect return false\n      {\n        return false;\n      }\n    return true;\n  },\n  /**\r\n   * Function: contains\r\n   *\r\n   * Returns true if the specified point (x, y) is contained in the given rectangle.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * bounds - <mxRectangle> that represents the area.\r\n   * x - X-coordinate of the point.\r\n   * y - Y-coordinate of the point.\r\n   */\n  contains: _mxGraphUtils[\"default\"].contains,\n  /**\r\n   * Function: intersects\r\n   *\r\n   * Returns true if the two rectangles intersect.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * a - <mxRectangle> to be checked for intersection.\r\n   * b - <mxRectangle> to be checked for intersection.\r\n   */\n  intersects: function intersects(a, b) {\n    return _mxGraphUtils[\"default\"].intersects(a, b);\n  },\n  /**\r\n   * Function: intersects\r\n   *\r\n   * Returns true if the two rectangles intersect.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * a - <mxRectangle> to be checked for intersection.\r\n   * b - <mxRectangle> to be checked for intersection.\r\n   */\n  intersectsHotspot: function intersectsHotspot(state, x, y, hotspot, min, max) {\n    hotspot = hotspot != null ? hotspot : 1;\n    min = min != null ? min : 0;\n    max = max != null ? max : 0;\n    if (hotspot > 0) {\n      var cx = state.getCenterX();\n      var cy = state.getCenterY();\n      var w = state.width;\n      var h = state.height;\n      var start = _mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_STARTSIZE) * state.view.scale;\n      if (start > 0) {\n        if (_mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_HORIZONTAL, true)) {\n          cy = state.y + start / 2;\n          h = start;\n        } else {\n          cx = state.x + start / 2;\n          w = start;\n        }\n      }\n      w = Math.max(min, w * hotspot);\n      h = Math.max(min, h * hotspot);\n      if (max > 0) {\n        w = Math.min(w, max);\n        h = Math.min(h, max);\n      }\n      var rect = new _mxRectangle[\"default\"](cx - w / 2, cy - h / 2, w, h);\n      var alpha = mxUtils.toRadians(_mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_ROTATION) || 0);\n      if (alpha != 0) {\n        var cos = Math.cos(-alpha);\n        var sin = Math.sin(-alpha);\n        var cx = new _mxPoint[\"default\"](state.getCenterX(), state.getCenterY());\n        var pt = mxUtils.getRotatedPoint(new _mxPoint[\"default\"](x, y), cos, sin, cx);\n        x = pt.x;\n        y = pt.y;\n      }\n      return mxUtils.contains(rect, x, y);\n    }\n    return true;\n  },\n  /**\r\n   * Function: getOffset\r\n   *\r\n   * Returns the offset for the specified container as an <mxPoint>. The\r\n   * offset is the distance from the top left corner of the container to the\r\n   * top left corner of the document.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * container - DOM node to return the offset for.\r\n   * scollOffset - Optional boolean to add the scroll offset of the document.\r\n   * Default is false.\r\n   */\n  getOffset: function getOffset(container, scrollOffset) {\n    var offsetLeft = 0;\n    var offsetTop = 0;\n    if (scrollOffset != null && scrollOffset) {\n      var offset = mxUtils.getDocumentScrollOrigin(container.ownerDocument);\n      offsetLeft += offset.x;\n      offsetTop += offset.y;\n    }\n    var r = container.getBoundingClientRect();\n    if (r != null) {\n      offsetLeft += r.left;\n      offsetTop += r.top;\n    }\n    return new _mxPoint[\"default\"](offsetLeft, offsetTop);\n  },\n  /**\r\n   * Function: getDocumentScrollOrigin\r\n   *\r\n   * Returns the scroll origin of the given document or the current document\r\n   * if no document is given.\r\n   */\n  getDocumentScrollOrigin: function getDocumentScrollOrigin(doc) {\n    if (_mxClient[\"default\"].IS_QUIRKS) {\n      return new _mxPoint[\"default\"](doc.body.scrollLeft, doc.body.scrollTop);\n    } else {\n      var wnd = doc.defaultView || doc.parentWindow;\n      var x = wnd != null && window.pageXOffset !== undefined ? window.pageXOffset : (document.documentElement || document.body.parentNode || document.body).scrollLeft;\n      var y = wnd != null && window.pageYOffset !== undefined ? window.pageYOffset : (document.documentElement || document.body.parentNode || document.body).scrollTop;\n      return new _mxPoint[\"default\"](x, y);\n    }\n  },\n  /**\r\n   * Function: getScrollOrigin\r\n   *\r\n   * Returns the top, left corner of the viewrect as an <mxPoint>.\r\n   */\n  getScrollOrigin: function getScrollOrigin(node) {\n    var b = document.body;\n    var d = document.documentElement;\n    var result = mxUtils.getDocumentScrollOrigin(node != null ? node.ownerDocument : document);\n    while (node != null && node != b && node != d) {\n      if (!isNaN(node.scrollLeft) && !isNaN(node.scrollTop)) {\n        result.x += node.scrollLeft;\n        result.y += node.scrollTop;\n      }\n      node = node.parentNode;\n    }\n    return result;\n  },\n  /**\r\n   * Function: convertPoint\r\n   *\r\n   * Converts the specified point (x, y) using the offset of the specified\r\n   * container and returns a new <mxPoint> with the result.\r\n   *\r\n   * (code)\r\n   * var pt = mxUtils.convertPoint(graph.container,\r\n   *   mxEvent.getClientX(evt), mxEvent.getClientY(evt));\r\n   * (end)\r\n   *\r\n   * Parameters:\r\n   *\r\n   * container - DOM node to use for the offset.\r\n   * x - X-coordinate of the point to be converted.\r\n   * y - Y-coordinate of the point to be converted.\r\n   */\n  convertPoint: function convertPoint(container, x, y) {\n    var origin = mxUtils.getScrollOrigin(container);\n    var offset = mxUtils.getOffset(container);\n    offset.x -= origin.x;\n    offset.y -= origin.y;\n    return new _mxPoint[\"default\"](x - offset.x, y - offset.y);\n  },\n  /**\r\n   * Function: ltrim\r\n   *\r\n   * Strips all whitespaces from the beginning of the string. Without the\r\n   * second parameter, this will trim these characters:\r\n   *\r\n   * - \" \" (ASCII 32 (0x20)), an ordinary space\r\n   * - \"\\t\" (ASCII 9 (0x09)), a tab\r\n   * - \"\\n\" (ASCII 10 (0x0A)), a new line (line feed)\r\n   * - \"\\r\" (ASCII 13 (0x0D)), a carriage return\r\n   * - \"\\0\" (ASCII 0 (0x00)), the NUL-byte\r\n   * - \"\\x0B\" (ASCII 11 (0x0B)), a vertical tab\r\n   */\n  ltrim: function ltrim(str, chars) {\n    return _mxGraphUtils[\"default\"].ltrim(str, chars);\n  },\n  /**\r\n   * Function: rtrim\r\n   *\r\n   * Strips all whitespaces from the end of the string. Without the second\r\n   * parameter, this will trim these characters:\r\n   *\r\n   * - \" \" (ASCII 32 (0x20)), an ordinary space\r\n   * - \"\\t\" (ASCII 9 (0x09)), a tab\r\n   * - \"\\n\" (ASCII 10 (0x0A)), a new line (line feed)\r\n   * - \"\\r\" (ASCII 13 (0x0D)), a carriage return\r\n   * - \"\\0\" (ASCII 0 (0x00)), the NUL-byte\r\n   * - \"\\x0B\" (ASCII 11 (0x0B)), a vertical tab\r\n   */\n  rtrim: function rtrim(str, chars) {\n    return _mxGraphUtils[\"default\"].rtrim(str, chars);\n  },\n  /**\r\n   * Function: trim\r\n   *\r\n   * Strips all whitespaces from both end of the string.\r\n   * Without the second parameter, Javascript function will trim these\r\n   * characters:\r\n   *\r\n   * - \" \" (ASCII 32 (0x20)), an ordinary space\r\n   * - \"\\t\" (ASCII 9 (0x09)), a tab\r\n   * - \"\\n\" (ASCII 10 (0x0A)), a new line (line feed)\r\n   * - \"\\r\" (ASCII 13 (0x0D)), a carriage return\r\n   * - \"\\0\" (ASCII 0 (0x00)), the NUL-byte\r\n   * - \"\\x0B\" (ASCII 11 (0x0B)), a vertical tab\r\n   */\n  trim: function trim(str, chars) {\n    return _mxGraphUtils[\"default\"].trim(str, chars);\n  },\n  /**\r\n   * Function: isNumeric\r\n   *\r\n   * Returns true if the specified value is numeric, that is, if it is not\r\n   * null, not an empty string, not a HEX number and isNaN returns false.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * n - String representing the possibly numeric value.\r\n   */\n  isNumeric: _mxGraphUtils[\"default\"].isNumeric,\n  /**\r\n   * Function: isInteger\r\n   *\r\n   * Returns true if the given value is an valid integer number.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * n - String representing the possibly numeric value.\r\n   */\n  isInteger: _mxGraphUtils[\"default\"].isInteger,\n  /**\r\n   * Function: mod\r\n   *\r\n   * Returns the remainder of division of n by m. You should use this instead\r\n   * of the built-in operation as the built-in operation does not properly\r\n   * handle negative numbers.\r\n   */\n  mod: function mod(n, m) {\n    return _mxGraphUtils[\"default\"].mod(n, m);\n  },\n  /**\r\n   * Function: intersection\r\n   *\r\n   * Returns the intersection of two lines as an <mxPoint>.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * x0 - X-coordinate of the first line's startpoint.\r\n   * y0 - X-coordinate of the first line's startpoint.\r\n   * x1 - X-coordinate of the first line's endpoint.\r\n   * y1 - Y-coordinate of the first line's endpoint.\r\n   * x2 - X-coordinate of the second line's startpoint.\r\n   * y2 - Y-coordinate of the second line's startpoint.\r\n   * x3 - X-coordinate of the second line's endpoint.\r\n   * y3 - Y-coordinate of the second line's endpoint.\r\n   */\n  intersection: function intersection(x0, y0, x1, y1, x2, y2, x3, y3) {\n    var denom = (y3 - y2) * (x1 - x0) - (x3 - x2) * (y1 - y0);\n    var nume_a = (x3 - x2) * (y0 - y2) - (y3 - y2) * (x0 - x2);\n    var nume_b = (x1 - x0) * (y0 - y2) - (y1 - y0) * (x0 - x2);\n    var ua = nume_a / denom;\n    var ub = nume_b / denom;\n    if (ua >= 0.0 && ua <= 1.0 && ub >= 0.0 && ub <= 1.0) {\n      // Get the intersection point\n      var intersectionX = x0 + ua * (x1 - x0);\n      var intersectionY = y0 + ua * (y1 - y0);\n      return new _mxPoint[\"default\"](intersectionX, intersectionY);\n    }\n\n    // No intersection\n    return null;\n  },\n  /**\r\n   * Function: ptSegDistSq\r\n   *\r\n   * Returns the square distance between a segment and a point. To get the\r\n   * distance between a point and a line (with infinite length) use\r\n   * <mxUtils.ptLineDist>.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * x1 - X-coordinate of the startpoint of the segment.\r\n   * y1 - Y-coordinate of the startpoint of the segment.\r\n   * x2 - X-coordinate of the endpoint of the segment.\r\n   * y2 - Y-coordinate of the endpoint of the segment.\r\n   * px - X-coordinate of the point.\r\n   * py - Y-coordinate of the point.\r\n   */\n  ptSegDistSq: function ptSegDistSq(x1, y1, x2, y2, px, py) {\n    return _mxGraphUtils[\"default\"].ptSegDistSq(x1, y1, x2, y2, px, py);\n  },\n  /**\r\n   * Function: ptLineDist\r\n   *\r\n   * Returns the distance between a line defined by two points and a point.\r\n   * To get the distance between a point and a segment (with a specific\r\n   * length) use <mxUtils.ptSeqDistSq>.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * x1 - X-coordinate of point 1 of the line.\r\n   * y1 - Y-coordinate of point 1 of the line.\r\n   * x2 - X-coordinate of point 1 of the line.\r\n   * y2 - Y-coordinate of point 1 of the line.\r\n   * px - X-coordinate of the point.\r\n   * py - Y-coordinate of the point.\r\n   */\n  ptLineDist: function ptLineDist(x1, y1, x2, y2, px, py) {\n    return Math.abs((y2 - y1) * px - (x2 - x1) * py + x2 * y1 - y2 * x1) / Math.sqrt((y2 - y1) * (y2 - y1) + (x2 - x1) * (x2 - x1));\n  },\n  /**\r\n   * Function: relativeCcw\r\n   *\r\n   * Returns 1 if the given point on the right side of the segment, 0 if its\r\n   * on the segment, and -1 if the point is on the left side of the segment.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * x1 - X-coordinate of the startpoint of the segment.\r\n   * y1 - Y-coordinate of the startpoint of the segment.\r\n   * x2 - X-coordinate of the endpoint of the segment.\r\n   * y2 - Y-coordinate of the endpoint of the segment.\r\n   * px - X-coordinate of the point.\r\n   * py - Y-coordinate of the point.\r\n   */\n  relativeCcw: function relativeCcw(x1, y1, x2, y2, px, py) {\n    x2 -= x1;\n    y2 -= y1;\n    px -= x1;\n    py -= y1;\n    var ccw = px * y2 - py * x2;\n    if (ccw == 0.0) {\n      ccw = px * x2 + py * y2;\n      if (ccw > 0.0) {\n        px -= x2;\n        py -= y2;\n        ccw = px * x2 + py * y2;\n        if (ccw < 0.0) {\n          ccw = 0.0;\n        }\n      }\n    }\n    return ccw < 0.0 ? -1 : ccw > 0.0 ? 1 : 0;\n  },\n  /**\r\n   * Function: animateChanges\r\n   *\r\n   * See <mxEffects.animateChanges>. This is for backwards compatibility and\r\n   * will be removed later.\r\n   */\n  animateChanges: function animateChanges(graph, changes) {\n    // LATER: Deprecated, remove this function\n    _mxEffects[\"default\"].animateChanges.apply(this, arguments);\n  },\n  /**\r\n   * Function: cascadeOpacity\r\n   *\r\n   * See <mxEffects.cascadeOpacity>. This is for backwards compatibility and\r\n   * will be removed later.\r\n   */\n  cascadeOpacity: function cascadeOpacity(graph, cell, opacity) {\n    _mxEffects[\"default\"].cascadeOpacity.apply(this, arguments);\n  },\n  /**\r\n   * Function: fadeOut\r\n   *\r\n   * See <mxEffects.fadeOut>. This is for backwards compatibility and\r\n   * will be removed later.\r\n   */\n  fadeOut: function fadeOut(node, from, remove, step, delay, isEnabled) {\n    _mxEffects[\"default\"].fadeOut.apply(this, arguments);\n  },\n  /**\r\n   * Function: setOpacity\r\n   *\r\n   * Sets the opacity of the specified DOM node to the given value in %.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * node - DOM node to set the opacity for.\r\n   * value - Opacity in %. Possible values are between 0 and 100.\r\n   */\n  setOpacity: function setOpacity(node, value) {\n    _mxGraphUtils[\"default\"].setOpacity(node, value);\n  },\n  /**\r\n   * Function: createImage\r\n   *\r\n   * Creates and returns an image (IMG node) or VML image (v:image) in IE6 in\r\n   * quirks mode.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * src - URL that points to the image to be displayed.\r\n   */\n  createImage: function createImage(src) {\n    var imageNode = null;\n    if (_mxClient[\"default\"].IS_IE6 && document.compatMode != 'CSS1Compat') {\n      imageNode = document.createElement(_mxClient[\"default\"].VML_PREFIX + ':image');\n      imageNode.setAttribute('src', src);\n      imageNode.style.borderStyle = 'none';\n    } else {\n      imageNode = document.createElement('img');\n      imageNode.setAttribute('src', src);\n      imageNode.setAttribute('border', '0');\n    }\n    return imageNode;\n  },\n  /**\r\n   * Function: sortCells\r\n   *\r\n   * Sorts the given cells according to the order in the cell hierarchy.\r\n   * Ascending is optional and defaults to true.\r\n   */\n  sortCells: function sortCells(cells, ascending) {\n    ascending = ascending != null ? ascending : true;\n    var lookup = new _mxDictionary[\"default\"]();\n    cells.sort(function (o1, o2) {\n      var p1 = lookup.get(o1);\n      if (p1 == null) {\n        p1 = _mxCellPath[\"default\"].create(o1).split(_mxCellPath[\"default\"].PATH_SEPARATOR);\n        lookup.put(o1, p1);\n      }\n      var p2 = lookup.get(o2);\n      if (p2 == null) {\n        p2 = _mxCellPath[\"default\"].create(o2).split(_mxCellPath[\"default\"].PATH_SEPARATOR);\n        lookup.put(o2, p2);\n      }\n      var comp = _mxCellPath[\"default\"].compare(p1, p2);\n      return comp == 0 ? 0 : comp > 0 == ascending ? 1 : -1;\n    });\n    return cells;\n  },\n  /**\r\n   * Function: getStylename\r\n   *\r\n   * Returns the stylename in a style of the form [(stylename|key=value);] or\r\n   * an empty string if the given style does not contain a stylename.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * style - String of the form [(stylename|key=value);].\r\n   */\n  getStylename: function getStylename(style) {\n    if (style != null) {\n      var pairs = style.split(';');\n      var stylename = pairs[0];\n      if (stylename.indexOf('=') < 0) {\n        return stylename;\n      }\n    }\n    return '';\n  },\n  /**\r\n   * Function: getStylenames\r\n   *\r\n   * Returns the stylenames in a style of the form [(stylename|key=value);]\r\n   * or an empty array if the given style does not contain any stylenames.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * style - String of the form [(stylename|key=value);].\r\n   */\n  getStylenames: function getStylenames(style) {\n    var result = [];\n    if (style != null) {\n      var pairs = style.split(';');\n      for (var i = 0; i < pairs.length; i++) {\n        if (pairs[i].indexOf('=') < 0) {\n          result.push(pairs[i]);\n        }\n      }\n    }\n    return result;\n  },\n  /**\r\n   * Function: indexOfStylename\r\n   *\r\n   * Returns the index of the given stylename in the given style. This\r\n   * returns -1 if the given stylename does not occur (as a stylename) in the\r\n   * given style, otherwise it returns the index of the first character.\r\n   */\n  indexOfStylename: function indexOfStylename(style, stylename) {\n    if (style != null && stylename != null) {\n      var tokens = style.split(';');\n      var pos = 0;\n      for (var i = 0; i < tokens.length; i++) {\n        if (tokens[i] == stylename) {\n          return pos;\n        }\n        pos += tokens[i].length + 1;\n      }\n    }\n    return -1;\n  },\n  /**\r\n   * Function: addStylename\r\n   *\r\n   * Adds the specified stylename to the given style if it does not already\r\n   * contain the stylename.\r\n   */\n  addStylename: function addStylename(style, stylename) {\n    if (_mxGraphUtils[\"default\"].indexOfStylename(style, stylename) < 0) {\n      if (style == null) {\n        style = '';\n      } else if (style.length > 0 && style.charAt(style.length - 1) != ';') {\n        style += ';';\n      }\n      style += stylename;\n    }\n    return style;\n  },\n  /**\r\n   * Function: removeStylename\r\n   *\r\n   * Removes all occurrences of the specified stylename in the given style\r\n   * and returns the updated style. Trailing semicolons are not preserved.\r\n   */\n  removeStylename: function removeStylename(style, stylename) {\n    var result = [];\n    if (style != null) {\n      var tokens = style.split(';');\n      for (var i = 0; i < tokens.length; i++) {\n        if (tokens[i] != stylename) {\n          result.push(tokens[i]);\n        }\n      }\n    }\n    return result.join(';');\n  },\n  /**\r\n   * Function: removeAllStylenames\r\n   *\r\n   * Removes all stylenames from the given style and returns the updated\r\n   * style.\r\n   */\n  removeAllStylenames: function removeAllStylenames(style) {\n    var result = [];\n    if (style != null) {\n      var tokens = style.split(';');\n      for (var i = 0; i < tokens.length; i++) {\n        // Keeps the key, value assignments\n        if (tokens[i].indexOf('=') >= 0) {\n          result.push(tokens[i]);\n        }\n      }\n    }\n    return result.join(';');\n  },\n  /**\r\n   * Function: setCellStyles\r\n   *\r\n   * Assigns the value for the given key in the styles of the given cells, or\r\n   * removes the key from the styles if the value is null.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * model - <mxGraphModel> to execute the transaction in.\r\n   * cells - Array of <mxCells> to be updated.\r\n   * key - Key of the style to be changed.\r\n   * value - New value for the given key.\r\n   */\n  setCellStyles: function setCellStyles(model, cells, key, value) {\n    if (cells != null && cells.length > 0) {\n      model.beginUpdate();\n      try {\n        for (var i = 0; i < cells.length; i++) {\n          if (cells[i] != null) {\n            var style = mxUtils.setStyle(model.getStyle(cells[i]), key, value);\n            model.setStyle(cells[i], style);\n          }\n        }\n      } finally {\n        model.endUpdate();\n      }\n    }\n  },\n  /**\r\n   * Function: setStyle\r\n   *\r\n   * Adds or removes the given key, value pair to the style and returns the\r\n   * new style. If value is null or zero length then the key is removed from\r\n   * the style. This is for cell styles, not for CSS styles.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * style - String of the form [(stylename|key=value);].\r\n   * key - Key of the style to be changed.\r\n   * value - New value for the given key.\r\n   */\n  setStyle: function setStyle(style, key, value) {\n    var isValue = value != null && (typeof value.length == 'undefined' || value.length > 0);\n    if (style == null || style.length == 0) {\n      if (isValue) {\n        style = key + '=' + value + ';';\n      }\n    } else {\n      if (style.substring(0, key.length + 1) == key + '=') {\n        var next = style.indexOf(';');\n        if (isValue) {\n          style = key + '=' + value + (next < 0 ? ';' : style.substring(next));\n        } else {\n          style = next < 0 || next == style.length - 1 ? '' : style.substring(next + 1);\n        }\n      } else {\n        var index = style.indexOf(';' + key + '=');\n        if (index < 0) {\n          if (isValue) {\n            var sep = style.charAt(style.length - 1) == ';' ? '' : ';';\n            style = style + sep + key + '=' + value + ';';\n          }\n        } else {\n          var next = style.indexOf(';', index + 1);\n          if (isValue) {\n            style = style.substring(0, index + 1) + key + '=' + value + (next < 0 ? ';' : style.substring(next));\n          } else {\n            style = style.substring(0, index) + (next < 0 ? ';' : style.substring(next));\n          }\n        }\n      }\n    }\n    return style;\n  },\n  /**\r\n   * Function: setCellStyleFlags\r\n   *\r\n   * Sets or toggles the flag bit for the given key in the cell's styles.\r\n   * If value is null then the flag is toggled.\r\n   *\r\n   * Example:\r\n   *\r\n   * (code)\r\n   * var cells = graph.getSelectionCells();\r\n   * mxUtils.setCellStyleFlags(graph.model,\r\n   * \t\t\tcells,\r\n   * \t\t\tmxConstants.STYLE_FONTSTYLE,\r\n   * \t\t\tmxConstants.FONT_BOLD);\r\n   * (end)\r\n   *\r\n   * Toggles the bold font style.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * model - <mxGraphModel> that contains the cells.\r\n   * cells - Array of <mxCells> to change the style for.\r\n   * key - Key of the style to be changed.\r\n   * flag - Integer for the bit to be changed.\r\n   * value - Optional boolean value for the flag.\r\n   */\n  setCellStyleFlags: function setCellStyleFlags(model, cells, key, flag, value) {\n    if (cells != null && cells.length > 0) {\n      model.beginUpdate();\n      try {\n        for (var i = 0; i < cells.length; i++) {\n          if (cells[i] != null) {\n            var style = mxUtils.setStyleFlag(model.getStyle(cells[i]), key, flag, value);\n            model.setStyle(cells[i], style);\n          }\n        }\n      } finally {\n        model.endUpdate();\n      }\n    }\n  },\n  /**\r\n   * Function: setStyleFlag\r\n   *\r\n   * Sets or removes the given key from the specified style and returns the\r\n   * new style. If value is null then the flag is toggled.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * style - String of the form [(stylename|key=value);].\r\n   * key - Key of the style to be changed.\r\n   * flag - Integer for the bit to be changed.\r\n   * value - Optional boolean value for the given flag.\r\n   */\n  setStyleFlag: function setStyleFlag(style, key, flag, value) {\n    if (style == null || style.length == 0) {\n      if (value || value == null) {\n        style = key + '=' + flag;\n      } else {\n        style = key + '=0';\n      }\n    } else {\n      var index = style.indexOf(key + '=');\n      if (index < 0) {\n        var sep = style.charAt(style.length - 1) == ';' ? '' : ';';\n        if (value || value == null) {\n          style = style + sep + key + '=' + flag;\n        } else {\n          style = style + sep + key + '=0';\n        }\n      } else {\n        var cont = style.indexOf(';', index);\n        var tmp = '';\n        if (cont < 0) {\n          tmp = style.substring(index + key.length + 1);\n        } else {\n          tmp = style.substring(index + key.length + 1, cont);\n        }\n        if (value == null) {\n          tmp = parseInt(tmp) ^ flag;\n        } else if (value) {\n          tmp = parseInt(tmp) | flag;\n        } else {\n          tmp = parseInt(tmp) & ~flag;\n        }\n        style = style.substring(0, index) + key + '=' + tmp + (cont >= 0 ? style.substring(cont) : '');\n      }\n    }\n    return style;\n  },\n  /**\r\n   * Function: getAlignmentAsPoint\r\n   *\r\n   * Returns an <mxPoint> that represents the horizontal and vertical alignment\r\n   * for numeric computations. X is -0.5 for center, -1 for right and 0 for\r\n   * left alignment. Y is -0.5 for middle, -1 for bottom and 0 for top\r\n   * alignment. Default values for missing arguments is top, left.\r\n   */\n  getAlignmentAsPoint: function getAlignmentAsPoint(align, valign) {\n    var dx = 0;\n    var dy = 0;\n\n    // Horizontal alignment\n    if (align == _mxConstants[\"default\"].ALIGN_CENTER) {\n      dx = -0.5;\n    } else if (align == _mxConstants[\"default\"].ALIGN_RIGHT) {\n      dx = -1;\n    }\n\n    // Vertical alignment\n    if (valign == _mxConstants[\"default\"].ALIGN_MIDDLE) {\n      dy = -0.5;\n    } else if (valign == _mxConstants[\"default\"].ALIGN_BOTTOM) {\n      dy = -1;\n    }\n    return new _mxPoint[\"default\"](dx, dy);\n  },\n  /**\r\n   * Function: getSizeForString\r\n   *\r\n   * Returns an <mxRectangle> with the size (width and height in pixels) of\r\n   * the given string. The string may contain HTML markup. Newlines should be\r\n   * converted to <br> before calling this method. The caller is responsible\r\n   * for sanitizing the HTML markup.\r\n   *\r\n   * Example:\r\n   *\r\n   * (code)\r\n   * var label = graph.getLabel(cell).replace(/\\n/g, \"<br>\");\r\n   * var size = graph.getSizeForString(label);\r\n   * (end)\r\n   *\r\n   * Parameters:\r\n   *\r\n   * text - String whose size should be returned.\r\n   * fontSize - Integer that specifies the font size in pixels. Default is\r\n   * <mxConstants.DEFAULT_FONTSIZE>.\r\n   * fontFamily - String that specifies the name of the font family. Default\r\n   * is <mxConstants.DEFAULT_FONTFAMILY>.\r\n   * textWidth - Optional width for text wrapping.\r\n   */\n  getSizeForString: function getSizeForString(text, fontSize, fontFamily, textWidth) {\n    fontSize = fontSize != null ? fontSize : _mxConstants[\"default\"].DEFAULT_FONTSIZE;\n    fontFamily = fontFamily != null ? fontFamily : _mxConstants[\"default\"].DEFAULT_FONTFAMILY;\n    var div = document.createElement('div');\n\n    // Sets the font size and family\n    div.style.fontFamily = fontFamily;\n    div.style.fontSize = Math.round(fontSize) + 'px';\n    div.style.lineHeight = Math.round(fontSize * _mxConstants[\"default\"].LINE_HEIGHT) + 'px';\n\n    // Disables block layout and outside wrapping and hides the div\n    div.style.position = 'absolute';\n    div.style.visibility = 'hidden';\n    div.style.display = _mxClient[\"default\"].IS_QUIRKS ? 'inline' : 'inline-block';\n    div.style.zoom = '1';\n    if (textWidth != null) {\n      div.style.width = textWidth + 'px';\n      div.style.whiteSpace = 'normal';\n    } else {\n      div.style.whiteSpace = 'nowrap';\n    }\n\n    // Adds the text and inserts into DOM for updating of size\n    div.innerHTML = text;\n    document.body.appendChild(div);\n\n    // Gets the size and removes from DOM\n    var size = new _mxRectangle[\"default\"](0, 0, div.offsetWidth, div.offsetHeight);\n    document.body.removeChild(div);\n    return size;\n  },\n  /**\r\n   * Function: getViewXml\r\n   */\n  getViewXml: function getViewXml(graph, scale, cells, x0, y0) {\n    x0 = x0 != null ? x0 : 0;\n    y0 = y0 != null ? y0 : 0;\n    scale = scale != null ? scale : 1;\n    if (cells == null) {\n      var model = graph.getModel();\n      cells = [model.getRoot()];\n    }\n    var view = graph.getView();\n    var result = null;\n\n    // Disables events on the view\n    var eventsEnabled = view.isEventsEnabled();\n    view.setEventsEnabled(false);\n\n    // Workaround for label bounds not taken into account for image export.\n    // Creates a temporary draw pane which is used for rendering the text.\n    // Text rendering is required for finding the bounds of the labels.\n    var drawPane = view.drawPane;\n    var overlayPane = view.overlayPane;\n    if (graph.dialect == _mxConstants[\"default\"].DIALECT_SVG) {\n      view.drawPane = document.createElementNS(_mxConstants[\"default\"].NS_SVG, 'g');\n      view.canvas.appendChild(view.drawPane);\n\n      // Redirects cell overlays into temporary container\n      view.overlayPane = document.createElementNS(_mxConstants[\"default\"].NS_SVG, 'g');\n      view.canvas.appendChild(view.overlayPane);\n    } else {\n      view.drawPane = view.drawPane.cloneNode(false);\n      view.canvas.appendChild(view.drawPane);\n\n      // Redirects cell overlays into temporary container\n      view.overlayPane = view.overlayPane.cloneNode(false);\n      view.canvas.appendChild(view.overlayPane);\n    }\n\n    // Resets the translation\n    var translate = view.getTranslate();\n    view.translate = new _mxPoint[\"default\"](x0, y0);\n\n    // Creates the temporary cell states in the view\n    var temp = new _mxTemporaryCellStates[\"default\"](graph.getView(), scale, cells);\n    try {\n      var enc = new _mxCodec[\"default\"]();\n      result = enc.encode(graph.getView());\n    } finally {\n      temp.destroy();\n      view.translate = translate;\n      view.canvas.removeChild(view.drawPane);\n      view.canvas.removeChild(view.overlayPane);\n      view.drawPane = drawPane;\n      view.overlayPane = overlayPane;\n      view.setEventsEnabled(eventsEnabled);\n    }\n    return result;\n  },\n  /**\r\n   * Function: getScaleForPageCount\r\n   *\r\n   * Returns the scale to be used for printing the graph with the given\r\n   * bounds across the specifies number of pages with the given format. The\r\n   * scale is always computed such that it given the given amount or fewer\r\n   * pages in the print output. See <mxPrintPreview> for an example.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * pageCount - Specifies the number of pages in the print output.\r\n   * graph - <mxGraph> that should be printed.\r\n   * pageFormat - Optional <mxRectangle> that specifies the page format.\r\n   * Default is <mxConstants.PAGE_FORMAT_A4_PORTRAIT>.\r\n   * border - The border along each side of every page.\r\n   */\n  getScaleForPageCount: function getScaleForPageCount(pageCount, graph, pageFormat, border) {\n    if (pageCount < 1) {\n      // We can't work with less than 1 page, return no scale\n      // change\n      return 1;\n    }\n    pageFormat = pageFormat != null ? pageFormat : _mxConstants[\"default\"].PAGE_FORMAT_A4_PORTRAIT;\n    border = border != null ? border : 0;\n    var availablePageWidth = pageFormat.width - border * 2;\n    var availablePageHeight = pageFormat.height - border * 2;\n\n    // Work out the number of pages required if the\n    // graph is not scaled.\n    var graphBounds = graph.getGraphBounds().clone();\n    var sc = graph.getView().getScale();\n    graphBounds.width /= sc;\n    graphBounds.height /= sc;\n    var graphWidth = graphBounds.width;\n    var graphHeight = graphBounds.height;\n    var scale = 1;\n\n    // The ratio of the width/height for each printer page\n    var pageFormatAspectRatio = availablePageWidth / availablePageHeight;\n    // The ratio of the width/height for the graph to be printer\n    var graphAspectRatio = graphWidth / graphHeight;\n\n    // The ratio of horizontal pages / vertical pages for this\n    // graph to maintain its aspect ratio on this page format\n    var pagesAspectRatio = graphAspectRatio / pageFormatAspectRatio;\n\n    // Factor the square root of the page count up and down\n    // by the pages aspect ratio to obtain a horizontal and\n    // vertical page count that adds up to the page count\n    // and has the correct aspect ratio\n    var pageRoot = Math.sqrt(pageCount);\n    var pagesAspectRatioSqrt = Math.sqrt(pagesAspectRatio);\n    var numRowPages = pageRoot * pagesAspectRatioSqrt;\n    var numColumnPages = pageRoot / pagesAspectRatioSqrt;\n\n    // These value are rarely more than 2 rounding downs away from\n    // a total that meets the page count. In cases of one being less\n    // than 1 page, the other value can be too high and take more iterations\n    // In this case, just change that value to be the page count, since\n    // we know the other value is 1\n    if (numRowPages < 1 && numColumnPages > pageCount) {\n      var scaleChange = numColumnPages / pageCount;\n      numColumnPages = pageCount;\n      numRowPages /= scaleChange;\n    }\n    if (numColumnPages < 1 && numRowPages > pageCount) {\n      var scaleChange = numRowPages / pageCount;\n      numRowPages = pageCount;\n      numColumnPages /= scaleChange;\n    }\n    var currentTotalPages = Math.ceil(numRowPages) * Math.ceil(numColumnPages);\n    var numLoops = 0;\n\n    // Iterate through while the rounded up number of pages comes to\n    // a total greater than the required number\n    while (currentTotalPages > pageCount) {\n      // Round down the page count (rows or columns) that is\n      // closest to its next integer down in percentage terms.\n      // i.e. Reduce the page total by reducing the total\n      // page area by the least possible amount\n\n      var roundRowDownProportion = Math.floor(numRowPages) / numRowPages;\n      var roundColumnDownProportion = Math.floor(numColumnPages) / numColumnPages;\n\n      // If the round down proportion is, work out the proportion to\n      // round down to 1 page less\n      if (roundRowDownProportion == 1) {\n        roundRowDownProportion = Math.floor(numRowPages - 1) / numRowPages;\n      }\n      if (roundColumnDownProportion == 1) {\n        roundColumnDownProportion = Math.floor(numColumnPages - 1) / numColumnPages;\n      }\n\n      // Check which rounding down is smaller, but in the case of very small roundings\n      // try the other dimension instead\n      var scaleChange = 1;\n\n      // Use the higher of the two values\n      if (roundRowDownProportion > roundColumnDownProportion) {\n        scaleChange = roundRowDownProportion;\n      } else {\n        scaleChange = roundColumnDownProportion;\n      }\n      numRowPages = numRowPages * scaleChange;\n      numColumnPages = numColumnPages * scaleChange;\n      currentTotalPages = Math.ceil(numRowPages) * Math.ceil(numColumnPages);\n      numLoops++;\n      if (numLoops > 10) {\n        break;\n      }\n    }\n\n    // Work out the scale from the number of row pages required\n    // The column pages will give the same value\n    var posterWidth = availablePageWidth * numRowPages;\n    scale = posterWidth / graphWidth;\n\n    // Allow for rounding errors\n    return scale * 0.99999;\n  },\n  /**\r\n   * Function: show\r\n   *\r\n   * Copies the styles and the markup from the graph's container into the\r\n   * given document and removes all cursor styles. The document is returned.\r\n   *\r\n   * This function should be called from within the document with the graph.\r\n   * If you experience problems with missing stylesheets in IE then try adding\r\n   * the domain to the trusted sites.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * graph - <mxGraph> to be copied.\r\n   * doc - Document where the new graph is created.\r\n   * x0 - X-coordinate of the graph view origin. Default is 0.\r\n   * y0 - Y-coordinate of the graph view origin. Default is 0.\r\n   * w - Optional width of the graph view.\r\n   * h - Optional height of the graph view.\r\n   */\n  show: function show(graph, doc, x0, y0, w, h) {\n    x0 = x0 != null ? x0 : 0;\n    y0 = y0 != null ? y0 : 0;\n    if (doc == null) {\n      var wnd = window.open();\n      doc = wnd.document;\n    } else {\n      doc.open();\n    }\n\n    // Workaround for missing print output in IE9 standards\n    if (document.documentMode == 9) {\n      doc.writeln('<!--[if IE]><meta http-equiv=\"X-UA-Compatible\" content=\"IE=9\"><![endif]-->');\n    }\n    var bounds = graph.getGraphBounds();\n    var dx = Math.ceil(x0 - bounds.x);\n    var dy = Math.ceil(y0 - bounds.y);\n    if (w == null) {\n      w = Math.ceil(bounds.width + x0) + Math.ceil(Math.ceil(bounds.x) - bounds.x);\n    }\n    if (h == null) {\n      h = Math.ceil(bounds.height + y0) + Math.ceil(Math.ceil(bounds.y) - bounds.y);\n    }\n\n    // Needs a special way of creating the page so that no click is required\n    // to refresh the contents after the external CSS styles have been loaded.\n    // To avoid a click or programmatic refresh, the styleSheets[].cssText\n    // property is copied over from the original document.\n    if (_mxClient[\"default\"].IS_IE || document.documentMode == 11) {\n      var html = '<html><head>';\n      var base = document.getElementsByTagName('base');\n      for (var i = 0; i < base.length; i++) {\n        html += base[i].outerHTML;\n      }\n      html += '<style>';\n\n      // Copies the stylesheets without having to load them again\n      for (var i = 0; i < document.styleSheets.length; i++) {\n        try {\n          html += document.styleSheets[i].cssText;\n        } catch (e) {\n          // ignore security exception\n        }\n      }\n      html += '</style></head><body style=\"margin:0px;\">';\n\n      // Copies the contents of the graph container\n      html += '<div style=\"position:absolute;overflow:hidden;width:' + w + 'px;height:' + h + 'px;\"><div style=\"position:relative;left:' + dx + 'px;top:' + dy + 'px;\">';\n      html += graph.container.innerHTML;\n      html += '</div></div></body><html>';\n      doc.writeln(html);\n      doc.close();\n    } else {\n      doc.writeln('<html><head>');\n      var base = document.getElementsByTagName('base');\n      for (var i = 0; i < base.length; i++) {\n        doc.writeln(mxUtils.getOuterHtml(base[i]));\n      }\n      var links = document.getElementsByTagName('link');\n      for (var i = 0; i < links.length; i++) {\n        doc.writeln(mxUtils.getOuterHtml(links[i]));\n      }\n      var styles = document.getElementsByTagName('style');\n      for (var i = 0; i < styles.length; i++) {\n        doc.writeln(mxUtils.getOuterHtml(styles[i]));\n      }\n      doc.writeln('</head><body style=\"margin:0px;\"></body></html>');\n      doc.close();\n      var outer = doc.createElement('div');\n      outer.position = 'absolute';\n      outer.overflow = 'hidden';\n      outer.style.width = w + 'px';\n      outer.style.height = h + 'px';\n\n      // Required for HTML labels if foreignObjects are disabled\n      var div = doc.createElement('div');\n      div.style.position = 'absolute';\n      div.style.left = dx + 'px';\n      div.style.top = dy + 'px';\n      var node = graph.container.firstChild;\n      var svg = null;\n      while (node != null) {\n        var clone = node.cloneNode(true);\n        if (node == graph.view.drawPane.ownerSVGElement) {\n          outer.appendChild(clone);\n          svg = clone;\n        } else {\n          div.appendChild(clone);\n        }\n        node = node.nextSibling;\n      }\n      doc.body.appendChild(outer);\n      if (div.firstChild != null) {\n        doc.body.appendChild(div);\n      }\n      if (svg != null) {\n        svg.style.minWidth = '';\n        svg.style.minHeight = '';\n        svg.firstChild.setAttribute('transform', 'translate(' + dx + ',' + dy + ')');\n      }\n    }\n    mxUtils.removeCursors(doc.body);\n    return doc;\n  },\n  /**\r\n   * Function: printScreen\r\n   *\r\n   * Prints the specified graph using a new window and the built-in print\r\n   * dialog.\r\n   *\r\n   * This function should be called from within the document with the graph.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * graph - <mxGraph> to be printed.\r\n   */\n  printScreen: function printScreen(graph) {\n    var wnd = window.open();\n    var bounds = graph.getGraphBounds();\n    mxUtils.show(graph, wnd.document);\n    var print = function print() {\n      wnd.focus();\n      wnd.print();\n      wnd.close();\n    };\n\n    // Workaround for Google Chrome which needs a bit of a\n    // delay in order to render the SVG contents\n    if (_mxClient[\"default\"].IS_GC) {\n      wnd.setTimeout(print, 500);\n    } else {\n      print();\n    }\n  },\n  /**\r\n   * Function: popup\r\n   *\r\n   * Shows the specified text content in a new <mxWindow> or a new browser\r\n   * window if isInternalWindow is false.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * content - String that specifies the text to be displayed.\r\n   * isInternalWindow - Optional boolean indicating if an mxWindow should be\r\n   * used instead of a new browser window. Default is false.\r\n   */\n  popup: function popup(content, isInternalWindow) {\n    _mxGraphUtils[\"default\"].popup(content, isInternalWindow);\n  },\n  /**\r\n   * Function: alert\r\n   *\r\n   * Displayss the given alert in a new dialog. This implementation uses the\r\n   * built-in alert function. This is used to display validation errors when\r\n   * connections cannot be changed or created.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * message - String specifying the message to be displayed.\r\n   */\n  alert: function (_alert) {\n    function alert(_x2) {\n      return _alert.apply(this, arguments);\n    }\n    alert.toString = function () {\n      return _alert.toString();\n    };\n    return alert;\n  }(function (message) {\n    alert(message);\n  }),\n  /**\r\n   * Function: prompt\r\n   *\r\n   * Displays the given message in a prompt dialog. This implementation uses\r\n   * the built-in prompt function.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * message - String specifying the message to be displayed.\r\n   * defaultValue - Optional string specifying the default value.\r\n   */\n  prompt: function (_prompt) {\n    function prompt(_x3, _x4) {\n      return _prompt.apply(this, arguments);\n    }\n    prompt.toString = function () {\n      return _prompt.toString();\n    };\n    return prompt;\n  }(function (message, defaultValue) {\n    return prompt(message, defaultValue != null ? defaultValue : '');\n  }),\n  /**\r\n   * Function: confirm\r\n   *\r\n   * Displays the given message in a confirm dialog. This implementation uses\r\n   * the built-in confirm function.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * message - String specifying the message to be displayed.\r\n   */\n  confirm: function (_confirm) {\n    function confirm(_x5) {\n      return _confirm.apply(this, arguments);\n    }\n    confirm.toString = function () {\n      return _confirm.toString();\n    };\n    return confirm;\n  }(function (message) {\n    return confirm(message);\n  }),\n  /**\r\n   * Function: error\r\n   *\r\n   * Displays the given error message in a new <mxWindow> of the given width.\r\n   * If close is true then an additional close button is added to the window.\r\n   * The optional icon specifies the icon to be used for the window. Default\r\n   * is <mxUtils.errorImage>.\r\n   *\r\n   * Parameters:\r\n   *\r\n   * message - String specifying the message to be displayed.\r\n   * width - Integer specifying the width of the window.\r\n   * close - Optional boolean indicating whether to add a close button.\r\n   * icon - Optional icon for the window decoration.\r\n   */\n  error: function error(message, width, close, icon) {\n    var div = document.createElement('div');\n    div.style.padding = '20px';\n    var img = document.createElement('img');\n    img.setAttribute('src', icon || mxUtils.errorImage);\n    img.setAttribute('valign', 'bottom');\n    img.style.verticalAlign = 'middle';\n    div.appendChild(img);\n    div.appendChild(document.createTextNode(\"\\xA0\")); // &nbsp;\n    div.appendChild(document.createTextNode(\"\\xA0\")); // &nbsp;\n    div.appendChild(document.createTextNode(\"\\xA0\")); // &nbsp;\n    _mxGraphUtils[\"default\"].write(div, message);\n    var w = document.body.clientWidth;\n    var h = document.body.clientHeight || document.documentElement.clientHeight;\n    var warn = new _mxWindow[\"default\"](_mxResources[\"default\"].get(mxUtils.errorResource) || mxUtils.errorResource, div, (w - width) / 2, h / 4, width, null, false, true);\n    if (close) {\n      mxUtils.br(div);\n      var tmp = document.createElement('p');\n      var button = document.createElement('button');\n      if (_mxClient[\"default\"].IS_IE) {\n        button.style.cssText = 'float:right';\n      } else {\n        button.setAttribute('style', 'float:right');\n      }\n      _mxEventUtils[\"default\"].addListener(button, 'click', function (evt) {\n        warn.destroy();\n      });\n      _mxGraphUtils[\"default\"].write(button, _mxResources[\"default\"].get(mxUtils.closeResource) || mxUtils.closeResource);\n      tmp.appendChild(button);\n      div.appendChild(tmp);\n      mxUtils.br(div);\n      warn.setClosable(true);\n    }\n    warn.setVisible(true);\n    return warn;\n  },\n  /**\r\n   * Function: makeDraggable\r\n   *\r\n   * Configures the given DOM element to act as a drag source for the\r\n   * specified graph. Returns a a new <mxDragSource>. If\r\n   * <mxDragSource.guideEnabled> is enabled then the x and y arguments must\r\n   * be used in funct to match the preview location.\r\n   *\r\n   * Example:\r\n   *\r\n   * (code)\r\n   * var funct = function(graph, evt, cell, x, y)\r\n   * {\r\n   *   if (graph.canImportCell(cell))\r\n   *   {\r\n   *     var parent = graph.getDefaultParent();\r\n   *     var vertex = null;\r\n   *\r\n   *     graph.getModel().beginUpdate();\r\n   *     try\r\n   *     {\r\n   * \t     vertex = graph.insertVertex(parent, null, 'Hello', x, y, 80, 30);\r\n   *     }\r\n   *     finally\r\n   *     {\r\n   *       graph.getModel().endUpdate();\r\n   *     }\r\n   *\r\n   *     graph.setSelectionCell(vertex);\r\n   *   }\r\n   * }\r\n   *\r\n   * var img = document.createElement('img');\r\n   * img.setAttribute('src', 'editors/images/rectangle.gif');\r\n   * img.style.position = 'absolute';\r\n   * img.style.left = '0px';\r\n   * img.style.top = '0px';\r\n   * img.style.width = '16px';\r\n   * img.style.height = '16px';\r\n   *\r\n   * var dragImage = img.cloneNode(true);\r\n   * dragImage.style.width = '32px';\r\n   * dragImage.style.height = '32px';\r\n   * mxUtils.makeDraggable(img, graph, funct, dragImage);\r\n   * document.body.appendChild(img);\r\n   * (end)\r\n   *\r\n   * Parameters:\r\n   *\r\n   * element - DOM element to make draggable.\r\n   * graphF - <mxGraph> that acts as the drop target or a function that takes a\r\n   * mouse event and returns the current <mxGraph>.\r\n   * funct - Function to execute on a successful drop.\r\n   * dragElement - Optional DOM node to be used for the drag preview.\r\n   * dx - Optional horizontal offset between the cursor and the drag\r\n   * preview.\r\n   * dy - Optional vertical offset between the cursor and the drag\r\n   * preview.\r\n   * autoscroll - Optional boolean that specifies if autoscroll should be\r\n   * used. Default is mxGraph.autoscroll.\r\n   * scalePreview - Optional boolean that specifies if the preview element\r\n   * should be scaled according to the graph scale. If this is true, then\r\n   * the offsets will also be scaled. Default is false.\r\n   * highlightDropTargets - Optional boolean that specifies if dropTargets\r\n   * should be highlighted. Default is true.\r\n   * getDropTarget - Optional function to return the drop target for a given\r\n   * location (x, y). Default is mxGraph.getCellAt.\r\n   */\n  makeDraggable: function makeDraggable(element, graphF, funct, dragElement, dx, dy, autoscroll, scalePreview, highlightDropTargets, getDropTarget) {\n    var dragSource = new _mxDragSource[\"default\"](element, funct);\n    dragSource.dragOffset = new _mxPoint[\"default\"](dx != null ? dx : 0, dy != null ? dy : _mxConstants[\"default\"].TOOLTIP_VERTICAL_OFFSET);\n    dragSource.autoscroll = autoscroll;\n\n    // Cannot enable this by default. This needs to be enabled in the caller\n    // if the funct argument uses the new x- and y-arguments.\n    dragSource.setGuidesEnabled(false);\n    if (highlightDropTargets != null) {\n      dragSource.highlightDropTargets = highlightDropTargets;\n    }\n\n    // Overrides function to find drop target cell\n    if (getDropTarget != null) {\n      dragSource.getDropTarget = getDropTarget;\n    }\n\n    // Overrides function to get current graph\n    dragSource.getGraphForEvent = function (evt) {\n      return typeof graphF == 'function' ? graphF(evt) : graphF;\n    };\n\n    // Translates switches into dragSource customizations\n    if (dragElement != null) {\n      dragSource.createDragElement = function () {\n        return dragElement.cloneNode(true);\n      };\n      if (scalePreview) {\n        dragSource.createPreviewElement = function (graph) {\n          var elt = dragElement.cloneNode(true);\n          var w = parseInt(elt.style.width);\n          var h = parseInt(elt.style.height);\n          elt.style.width = Math.round(w * graph.view.scale) + 'px';\n          elt.style.height = Math.round(h * graph.view.scale) + 'px';\n          return elt;\n        };\n      }\n    }\n    return dragSource;\n  }\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\nvar _default = exports[\"default\"] = mxUtils;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxUtils.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxValueChange.js":
/*!************************************************!*\
  !*** ./src/workflow/mxClient/mxValueChange.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nfunction mxValueChange(model, cell, value) {\n  this.model = model;\n  this.cell = cell;\n  this.value = value;\n  this.previous = value;\n}\n;\n\n/**\r\n * Function: execute\r\n *\r\n * Changes the value of <cell> to <previous> using\r\n * <mxGraphModel.valueForCellChanged>.\r\n */\nmxValueChange.prototype.execute = function () {\n  this.value = this.previous;\n  this.previous = this.model.valueForCellChanged(this.cell, this.previous);\n};\nmxValueChange.getName = function () {\n  return 'mxValueChange';\n};\n/**\r\n * Class: mxPropertyChange\r\n *\r\n * Action to change a user object in a model.\r\n *\r\n * Constructor: mxPropertyChange\r\n *\r\n * Constructs a change of a user object in the\r\n * specified model.\r\n */\nvar _default = exports[\"default\"] = mxValueChange;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxValueChange.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxVertexHandler.js":
/*!**************************************************!*\
  !*** ./src/workflow/mxClient/mxVertexHandler.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.fill.js */ \"../../node_modules/core-js/modules/es.array.fill.js\");\n__webpack_require__(/*! core-js/modules/es.function.bind.js */ \"../../node_modules/core-js/modules/es.function.bind.js\");\n__webpack_require__(/*! core-js/modules/es.number.constructor.js */ \"../../node_modules/core-js/modules/es.number.constructor.js\");\nvar _mxClient = _interopRequireDefault(__webpack_require__(/*! ./mxClient.js */ \"./src/workflow/mxClient/mxClient.js\"));\nvar _mxImageShape = _interopRequireDefault(__webpack_require__(/*! ./mxImageShape.js */ \"./src/workflow/mxClient/mxImageShape.js\"));\nvar _mxEvent = _interopRequireDefault(__webpack_require__(/*! ./mxEvent.js */ \"./src/workflow/mxClient/mxEvent.js\"));\nvar _mxPoint = _interopRequireDefault(__webpack_require__(/*! ./mxPoint.js */ \"./src/workflow/mxClient/mxPoint.js\"));\nvar _mxGraphHandler = _interopRequireDefault(__webpack_require__(/*! ./mxGraphHandler.js */ \"./src/workflow/mxClient/mxGraphHandler.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxEllipse = _interopRequireDefault(__webpack_require__(/*! ./mxEllipse.js */ \"./src/workflow/mxClient/mxEllipse.js\"));\nvar _mxRectangle = _interopRequireDefault(__webpack_require__(/*! ./mxRectangle.js */ \"./src/workflow/mxClient/mxRectangle.js\"));\nvar _mxRectangleShape = _interopRequireDefault(__webpack_require__(/*! ./mxRectangleShape.js */ \"./src/workflow/mxClient/mxRectangleShape.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ./mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nvar _mxUtils = _interopRequireDefault(__webpack_require__(/*! ./mxUtils.js */ \"./src/workflow/mxClient/mxUtils.js\"));\nvar _workflowUtil = __webpack_require__(/*! ../util/workflowUtil */ \"./src/workflow/util/workflowUtil.js\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxVertexHandler(state) {\n  if (state != null) {\n    this.state = state;\n    this.init();\n\n    // Handles escape keystrokes\n    this.escapeHandler = _mxGraphUtils[\"default\"].bind(this, function (sender, evt) {\n      if (this.livePreview && this.index != null) {\n        // Redraws the live preview\n        this.state.view.graph.cellRenderer.redraw(this.state, true);\n\n        // Redraws connected edges\n        this.state.view.invalidate(this.state.cell);\n        this.state.invalid = false;\n        this.state.view.validate();\n      }\n      this.reset();\n    });\n    this.state.view.graph.addListener(_mxEvent[\"default\"].ESCAPE, this.escapeHandler);\n  }\n}\n;\n\n/**\r\n * Variable: graph\r\n *\r\n * Reference to the enclosing <mxGraph>.\r\n */\nmxVertexHandler.prototype.graph = null;\n\n/**\r\n * Variable: state\r\n *\r\n * Reference to the <mxCellState> being modified.\r\n */\nmxVertexHandler.prototype.state = null;\n\n/**\r\n * Variable: singleSizer\r\n *\r\n * Specifies if only one sizer handle at the bottom, right corner should be\r\n * used. Default is false.\r\n */\nmxVertexHandler.prototype.singleSizer = false;\n\n/**\r\n * Variable: index\r\n *\r\n * Holds the index of the current handle.\r\n */\nmxVertexHandler.prototype.index = null;\n\n/**\r\n * Variable: allowHandleBoundsCheck\r\n *\r\n * Specifies if the bounds of handles should be used for hit-detection in IE or\r\n * if <tolerance> > 0. Default is true.\r\n */\nmxVertexHandler.prototype.allowHandleBoundsCheck = true;\n\n/**\r\n * Variable: handleImage\r\n *\r\n * Optional <mxImage> to be used as handles. Default is null.\r\n */\nmxVertexHandler.prototype.handleImage = null;\n\n/**\r\n * Variable: tolerance\r\n *\r\n * Optional tolerance for hit-detection in <getHandleForEvent>. Default is 0.\r\n */\nmxVertexHandler.prototype.tolerance = 0;\n\n/**\r\n * Variable: rotationEnabled\r\n *\r\n * Specifies if a rotation handle should be visible. Default is false.\r\n */\nmxVertexHandler.prototype.rotationEnabled = false;\n\n/**\r\n * Variable: parentHighlightEnabled\r\n *\r\n * Specifies if the parent should be highlighted if a child cell is selected.\r\n * Default is false.\r\n */\nmxVertexHandler.prototype.parentHighlightEnabled = false;\n\n/**\r\n * Variable: rotationRaster\r\n *\r\n * Specifies if rotation steps should be \"rasterized\" depening on the distance\r\n * to the handle. Default is true.\r\n */\nmxVertexHandler.prototype.rotationRaster = true;\n\n/**\r\n * Variable: rotationCursor\r\n *\r\n * Specifies the cursor for the rotation handle. Default is 'crosshair'.\r\n */\nmxVertexHandler.prototype.rotationCursor = 'crosshair';\n\n/**\r\n * Variable: livePreview\r\n *\r\n * Specifies if resize should change the cell in-place. This is an experimental\r\n * feature for non-touch devices. Default is false.\r\n */\nmxVertexHandler.prototype.livePreview = false;\n\n/**\r\n * Variable: manageSizers\r\n *\r\n * Specifies if sizers should be hidden and spaced if the vertex is small.\r\n * Default is false.\r\n */\nmxVertexHandler.prototype.manageSizers = false;\n\n/**\r\n * Variable: constrainGroupByChildren\r\n *\r\n * Specifies if the size of groups should be constrained by the children.\r\n * Default is false.\r\n */\nmxVertexHandler.prototype.constrainGroupByChildren = false;\n\n/**\r\n * Variable: rotationHandleVSpacing\r\n *\r\n * Vertical spacing for rotation icon. Default is -16.\r\n */\nmxVertexHandler.prototype.rotationHandleVSpacing = -16;\n\n/**\r\n * Variable: horizontalOffset\r\n *\r\n * The horizontal offset for the handles. This is updated in <redrawHandles>\r\n * if <manageSizers> is true and the sizers are offset horizontally.\r\n */\nmxVertexHandler.prototype.horizontalOffset = 0;\n\n/**\r\n * Variable: verticalOffset\r\n *\r\n * The horizontal offset for the handles. This is updated in <redrawHandles>\r\n * if <manageSizers> is true and the sizers are offset vertically.\r\n */\nmxVertexHandler.prototype.verticalOffset = 0;\n\n/**\r\n * Function: init\r\n *\r\n * Initializes the shapes required for this vertex handler.\r\n */\nmxVertexHandler.prototype.init = function () {\n  this.graph = this.state.view.graph;\n  this.selectionBounds = this.getSelectionBounds(this.state);\n  this.bounds = new _mxRectangle[\"default\"](this.selectionBounds.x, this.selectionBounds.y, this.selectionBounds.width, this.selectionBounds.height);\n  this.selectionBorder = this.createSelectionShape(this.bounds);\n  // VML dialect required here for event transparency in IE\n  this.selectionBorder.dialect = this.graph.dialect != _mxConstants[\"default\"].DIALECT_SVG ? _mxConstants[\"default\"].DIALECT_VML : _mxConstants[\"default\"].DIALECT_SVG;\n  this.selectionBorder.pointerEvents = false;\n  this.selectionBorder.rotation = Number(this.state.style[_mxConstants[\"default\"].STYLE_ROTATION] || '0');\n  this.selectionBorder.init(this.graph.getView().getOverlayPane());\n  _mxEvent[\"default\"].redirectMouseEvents(this.selectionBorder.node, this.graph, this.state);\n  if (this.graph.isCellMovable(this.state.cell)) {\n    this.selectionBorder.setCursor(_mxConstants[\"default\"].CURSOR_MOVABLE_VERTEX);\n  }\n\n  // Adds the sizer handles\n  if (_mxGraphHandler[\"default\"].prototype.maxCells <= 0 || this.graph.getSelectionCount() < _mxGraphHandler[\"default\"].prototype.maxCells) {\n    var resizable = this.graph.isCellResizable(this.state.cell);\n    this.sizers = [];\n    if (resizable || this.graph.isLabelMovable(this.state.cell) && this.state.width >= 2 && this.state.height >= 2) {\n      var i = 0;\n      if (resizable) {\n        if (!this.singleSizer) {\n          this.sizers.push(this.createSizer('nw-resize', i++));\n          this.sizers.push(this.createSizer('n-resize', i++));\n          this.sizers.push(this.createSizer('ne-resize', i++));\n          this.sizers.push(this.createSizer('w-resize', i++));\n          this.sizers.push(this.createSizer('e-resize', i++));\n          this.sizers.push(this.createSizer('sw-resize', i++));\n          this.sizers.push(this.createSizer('s-resize', i++));\n        }\n        this.sizers.push(this.createSizer('se-resize', i++));\n      }\n      var geo = this.graph.model.getGeometry(this.state.cell);\n      if (geo != null && !geo.relative && !this.graph.isSwimlane(this.state.cell) && this.graph.isLabelMovable(this.state.cell)) {\n        // Marks this as the label handle for getHandleForEvent\n        this.labelShape = this.createSizer(_mxConstants[\"default\"].CURSOR_LABEL_HANDLE, _mxEvent[\"default\"].LABEL_HANDLE, _mxConstants[\"default\"].LABEL_HANDLE_SIZE, _mxConstants[\"default\"].LABEL_HANDLE_FILLCOLOR);\n        this.sizers.push(this.labelShape);\n      }\n    } else if (this.graph.isCellMovable(this.state.cell) && !this.graph.isCellResizable(this.state.cell) && this.state.width < 2 && this.state.height < 2) {\n      this.labelShape = this.createSizer(_mxConstants[\"default\"].CURSOR_MOVABLE_VERTEX, _mxEvent[\"default\"].LABEL_HANDLE, null, _mxConstants[\"default\"].LABEL_HANDLE_FILLCOLOR);\n      this.sizers.push(this.labelShape);\n    }\n  }\n\n  // Adds the rotation handler\n  if (this.isRotationHandleVisible()) {\n    this.rotationShape = this.createSizer(this.rotationCursor, _mxEvent[\"default\"].ROTATION_HANDLE, _mxConstants[\"default\"].HANDLE_SIZE + 3, _mxConstants[\"default\"].HANDLE_FILLCOLOR);\n    this.sizers.push(this.rotationShape);\n  }\n  this.customHandles = this.createCustomHandles();\n  this.redraw();\n  if (this.constrainGroupByChildren) {\n    this.updateMinBounds();\n  }\n};\n\n/**\r\n * Function: isRotationHandleVisible\r\n *\r\n * Returns true if the rotation handle should be showing.\r\n */\nmxVertexHandler.prototype.isRotationHandleVisible = function () {\n  return this.graph.isEnabled() && this.rotationEnabled && this.graph.isCellRotatable(this.state.cell) && (_mxGraphHandler[\"default\"].prototype.maxCells <= 0 || this.graph.getSelectionCount() < _mxGraphHandler[\"default\"].prototype.maxCells) && this.state.width >= 2 && this.state.height >= 2;\n};\n\n/**\r\n * Function: isConstrainedEvent\r\n *\r\n * Returns true if the aspect ratio if the cell should be maintained.\r\n */\nmxVertexHandler.prototype.isConstrainedEvent = function (me) {\n  return _mxEvent[\"default\"].isShiftDown(me.getEvent()) || this.state.style[_mxConstants[\"default\"].STYLE_ASPECT] == 'fixed';\n};\n\n/**\r\n * Function: isCenteredEvent\r\n *\r\n * Returns true if the aspect ratio if the cell should be maintained.\r\n */\nmxVertexHandler.prototype.isCenteredEvent = function (state, me) {\n  return false;\n};\n\n/**\r\n * Function: createCustomHandles\r\n *\r\n * Returns an array of custom handles. This implementation returns null.\r\n */\nmxVertexHandler.prototype.createCustomHandles = function () {\n  return null;\n};\n\n/**\r\n * Function: updateMinBounds\r\n *\r\n * Initializes the shapes required for this vertex handler.\r\n */\nmxVertexHandler.prototype.updateMinBounds = function () {\n  var children = this.graph.getChildCells(this.state.cell);\n  if (children.length > 0) {\n    this.minBounds = this.graph.view.getBounds(children);\n    if (this.minBounds != null) {\n      var s = this.state.view.scale;\n      var t = this.state.view.translate;\n      this.minBounds.x -= this.state.x;\n      this.minBounds.y -= this.state.y;\n      this.minBounds.x /= s;\n      this.minBounds.y /= s;\n      this.minBounds.width /= s;\n      this.minBounds.height /= s;\n      this.x0 = this.state.x / s - t.x;\n      this.y0 = this.state.y / s - t.y;\n    }\n  }\n};\n\n/**\r\n * Function: getSelectionBounds\r\n *\r\n * Returns the mxRectangle that defines the bounds of the selection\r\n * border.\r\n */\nmxVertexHandler.prototype.getSelectionBounds = function (state) {\n  return new _mxRectangle[\"default\"](Math.round(state.x), Math.round(state.y), Math.round(state.width), Math.round(state.height));\n};\n\n/**\r\n * Function: createParentHighlightShape\r\n *\r\n * Creates the shape used to draw the selection border.\r\n */\nmxVertexHandler.prototype.createParentHighlightShape = function (bounds) {\n  return this.createSelectionShape(bounds);\n};\n\n/**\r\n * Function: createSelectionShape\r\n *\r\n * Creates the shape used to draw the selection border.\r\n */\nmxVertexHandler.prototype.createSelectionShape = function (bounds) {\n  var shape = new _mxRectangleShape[\"default\"](bounds, null, this.getSelectionColor());\n  var graph = this.graph;\n  if ((0, _workflowUtil.isBizFlow)(graph.flowType) && graph.isEnabled()) {\n    shape.stroke = _mxConstants[\"default\"].BIZFLOW_EDGE_SELECTION_COLOR;\n    shape.isDashed = _mxConstants[\"default\"].BIZFLOW_EDGE_SELECTION_DASHED;\n    shape.strokewidth = _mxConstants[\"default\"].BIZFLOW_EDGE_SELECTION_STROKEWIDTH;\n    shape.style = {\n      arcSize: 4.16\n    };\n    shape.isRounded = true;\n  } else {\n    shape.strokewidth = this.getSelectionStrokeWidth();\n    shape.isDashed = this.isSelectionDashed();\n  }\n  return shape;\n};\n\n/**\r\n * Function: getSelectionColor\r\n *\r\n * Returns <mxConstants.VERTEX_SELECTION_COLOR>.\r\n */\nmxVertexHandler.prototype.getSelectionColor = function () {\n  return _mxConstants[\"default\"].VERTEX_SELECTION_COLOR;\n};\n\n/**\r\n * Function: getSelectionStrokeWidth\r\n *\r\n * Returns <mxConstants.VERTEX_SELECTION_STROKEWIDTH>.\r\n */\nmxVertexHandler.prototype.getSelectionStrokeWidth = function () {\n  return _mxConstants[\"default\"].VERTEX_SELECTION_STROKEWIDTH;\n};\n\n/**\r\n * Function: isSelectionDashed\r\n *\r\n * Returns <mxConstants.VERTEX_SELECTION_DASHED>.\r\n */\nmxVertexHandler.prototype.isSelectionDashed = function () {\n  return _mxConstants[\"default\"].VERTEX_SELECTION_DASHED;\n};\n\n/**\r\n * Function: createSizer\r\n *\r\n * Creates a sizer handle for the specified cursor and index and returns\r\n * the new <mxRectangleShape> that represents the handle.\r\n */\nmxVertexHandler.prototype.createSizer = function (cursor, index, size, fillColor) {\n  size = size || _mxConstants[\"default\"].HANDLE_SIZE;\n  var bounds = new _mxRectangle[\"default\"](0, 0, size, size);\n  var sizer = this.createSizerShape(bounds, index, fillColor);\n  if (sizer.isHtmlAllowed() && this.state.text != null && this.state.text.node.parentNode == this.graph.container) {\n    sizer.bounds.height -= 1;\n    sizer.bounds.width -= 1;\n    sizer.dialect = _mxConstants[\"default\"].DIALECT_STRICTHTML;\n    sizer.init(this.graph.container);\n  } else {\n    sizer.dialect = this.graph.dialect != _mxConstants[\"default\"].DIALECT_SVG ? _mxConstants[\"default\"].DIALECT_MIXEDHTML : _mxConstants[\"default\"].DIALECT_SVG;\n    sizer.init(this.graph.getView().getOverlayPane());\n  }\n  _mxEvent[\"default\"].redirectMouseEvents(sizer.node, this.graph, this.state);\n  if (this.graph.isEnabled()) {\n    sizer.setCursor(cursor);\n  }\n  if (!this.isSizerVisible(index)) {\n    sizer.visible = false;\n  }\n  return sizer;\n};\n\n/**\r\n * Function: isSizerVisible\r\n *\r\n * Returns true if the sizer for the given index is visible.\r\n * This returns true for all given indices.\r\n */\nmxVertexHandler.prototype.isSizerVisible = function (index) {\n  return true;\n};\n\n/**\r\n * Function: createSizerShape\r\n *\r\n * Creates the shape used for the sizer handle for the specified bounds an\r\n * index. Only images and rectangles should be returned if support for HTML\r\n * labels with not foreign objects is required.\r\n */\nmxVertexHandler.prototype.createSizerShape = function (bounds, index, fillColor) {\n  if (this.handleImage != null) {\n    bounds = new _mxRectangle[\"default\"](bounds.x, bounds.y, this.handleImage.width, this.handleImage.height);\n    var shape = new _mxImageShape[\"default\"](bounds, this.handleImage.src);\n\n    // Allows HTML rendering of the images\n    shape.preserveImageAspect = false;\n    return shape;\n  } else if (index == _mxEvent[\"default\"].ROTATION_HANDLE) {\n    return new _mxEllipse[\"default\"](bounds, fillColor || _mxConstants[\"default\"].HANDLE_FILLCOLOR, _mxConstants[\"default\"].HANDLE_STROKECOLOR);\n  } else {\n    return new _mxRectangleShape[\"default\"](bounds, fillColor || _mxConstants[\"default\"].HANDLE_FILLCOLOR, _mxConstants[\"default\"].HANDLE_STROKECOLOR);\n  }\n};\n\n/**\r\n * Function: createBounds\r\n *\r\n * Helper method to create an <mxRectangle> around the given centerpoint\r\n * with a width and height of 2*s or 6, if no s is given.\r\n */\nmxVertexHandler.prototype.moveSizerTo = function (shape, x, y) {\n  if (shape != null) {\n    shape.bounds.x = Math.floor(x - shape.bounds.width / 2);\n    shape.bounds.y = Math.floor(y - shape.bounds.height / 2);\n\n    // Fixes visible inactive handles in VML\n    if (shape.node != null && shape.node.style.display != 'none') {\n      shape.redraw();\n    }\n  }\n};\n\n/**\r\n * Function: getHandleForEvent\r\n *\r\n * Returns the index of the handle for the given event. This returns the index\r\n * of the sizer from where the event originated or <mxEvent.LABEL_INDEX>.\r\n */\nmxVertexHandler.prototype.getHandleForEvent = function (me) {\n  // Connection highlight may consume events before they reach sizer handle\n  var tol = !_mxEvent[\"default\"].isMouseEvent(me.getEvent()) ? this.tolerance : 1;\n  var hit = this.allowHandleBoundsCheck && (_mxClient[\"default\"].IS_IE || tol > 0) ? new _mxRectangle[\"default\"](me.getGraphX() - tol, me.getGraphY() - tol, 2 * tol, 2 * tol) : null;\n  function checkShape(shape) {\n    return shape != null && (me.isSource(shape) || hit != null && _mxUtils[\"default\"].intersects(shape.bounds, hit) && shape.node.style.display != 'none' && shape.node.style.visibility != 'hidden');\n  }\n  if (this.customHandles != null && this.isCustomHandleEvent(me)) {\n    // Inverse loop order to match display order\n    for (var i = this.customHandles.length - 1; i >= 0; i--) {\n      if (checkShape(this.customHandles[i].shape)) {\n        // LATER: Return reference to active shape\n        return _mxEvent[\"default\"].CUSTOM_HANDLE - i;\n      }\n    }\n  }\n  if (checkShape(this.rotationShape)) {\n    return _mxEvent[\"default\"].ROTATION_HANDLE;\n  } else if (checkShape(this.labelShape)) {\n    return _mxEvent[\"default\"].LABEL_HANDLE;\n  }\n  if (this.sizers != null) {\n    for (var i = 0; i < this.sizers.length; i++) {\n      if (checkShape(this.sizers[i])) {\n        return i;\n      }\n    }\n  }\n  return null;\n};\n\n/**\r\n * Function: isCustomHandleEvent\r\n *\r\n * Returns true if the given event allows custom handles to be changed. This\r\n * implementation returns true.\r\n */\nmxVertexHandler.prototype.isCustomHandleEvent = function (me) {\n  return true;\n};\n\n/**\r\n * Function: mouseDown\r\n *\r\n * Handles the event if a handle has been clicked. By consuming the\r\n * event all subsequent events of the gesture are redirected to this\r\n * handler.\r\n */\nmxVertexHandler.prototype.mouseDown = function (sender, me) {\n  var tol = !_mxEvent[\"default\"].isMouseEvent(me.getEvent()) ? this.tolerance : 0;\n  if (!me.isConsumed() && this.graph.isEnabled() && (tol > 0 || me.getState() == this.state)) {\n    var handle = this.getHandleForEvent(me);\n    if (handle != null) {\n      this.start(me.getGraphX(), me.getGraphY(), handle);\n      me.consume();\n    }\n  }\n};\n\n/**\r\n * Function: isLivePreviewBorder\r\n *\r\n * Called if <livePreview> is enabled to check if a border should be painted.\r\n * This implementation returns true if the shape is transparent.\r\n */\nmxVertexHandler.prototype.isLivePreviewBorder = function () {\n  return this.state.shape != null && this.state.shape.fill == null && this.state.shape.stroke == null;\n};\n\n/**\r\n * Function: start\r\n *\r\n * Starts the handling of the mouse gesture.\r\n */\nmxVertexHandler.prototype.start = function (x, y, index) {\n  this.inTolerance = true;\n  this.childOffsetX = 0;\n  this.childOffsetY = 0;\n  this.index = index;\n  this.startX = x;\n  this.startY = y;\n\n  // Saves reference to parent state\n  var model = this.state.view.graph.model;\n  var parent = model.getParent(this.state.cell);\n  if (this.state.view.currentRoot != parent && (model.isVertex(parent) || model.isEdge(parent))) {\n    this.parentState = this.state.view.graph.view.getState(parent);\n  }\n\n  // Creates a preview that can be on top of any HTML label\n  this.selectionBorder.node.style.display = index == _mxEvent[\"default\"].ROTATION_HANDLE ? 'inline' : 'none';\n\n  // Creates the border that represents the new bounds\n  if (!this.livePreview || this.isLivePreviewBorder()) {\n    this.preview = this.createSelectionShape(this.bounds);\n    if (!(_mxClient[\"default\"].IS_SVG && Number(this.state.style[_mxConstants[\"default\"].STYLE_ROTATION] || '0') != 0) && this.state.text != null && this.state.text.node.parentNode == this.graph.container) {\n      this.preview.dialect = _mxConstants[\"default\"].DIALECT_STRICTHTML;\n      this.preview.init(this.graph.container);\n    } else {\n      this.preview.dialect = this.graph.dialect != _mxConstants[\"default\"].DIALECT_SVG ? _mxConstants[\"default\"].DIALECT_VML : _mxConstants[\"default\"].DIALECT_SVG;\n      this.preview.init(this.graph.view.getOverlayPane());\n    }\n  }\n\n  // Prepares the handles for live preview\n  if (this.livePreview) {\n    this.hideSizers();\n    if (index == _mxEvent[\"default\"].ROTATION_HANDLE) {\n      this.rotationShape.node.style.display = '';\n    } else if (index == _mxEvent[\"default\"].LABEL_HANDLE) {\n      this.labelShape.node.style.display = '';\n    } else if (this.sizers != null && this.sizers[index] != null) {\n      this.sizers[index].node.style.display = '';\n    } else if (index <= _mxEvent[\"default\"].CUSTOM_HANDLE && this.customHandles != null) {\n      this.customHandles[_mxEvent[\"default\"].CUSTOM_HANDLE - index].setVisible(true);\n    }\n\n    // Gets the array of connected edge handlers for redrawing\n    var edges = this.graph.getEdges(this.state.cell);\n    this.edgeHandlers = [];\n    for (var i = 0; i < edges.length; i++) {\n      var handler = this.graph.selectionCellsHandler.getHandler(edges[i]);\n      if (handler != null) {\n        this.edgeHandlers.push(handler);\n      }\n    }\n  }\n};\n\n/**\r\n * Function: hideHandles\r\n *\r\n * Shortcut to <hideSizers>.\r\n */\nmxVertexHandler.prototype.setHandlesVisible = function (visible) {\n  if (this.sizers != null) {\n    for (var i = 0; i < this.sizers.length; i++) {\n      this.sizers[i].node.style.display = visible ? '' : 'none';\n    }\n  }\n  if (this.customHandles != null) {\n    for (var i = 0; i < this.customHandles.length; i++) {\n      this.customHandles[i].setVisible(visible);\n    }\n  }\n};\n\n/**\r\n * Function: hideSizers\r\n *\r\n * Hides all sizers except.\r\n *\r\n * Starts the handling of the mouse gesture.\r\n */\nmxVertexHandler.prototype.hideSizers = function () {\n  this.setHandlesVisible(false);\n};\n\n/**\r\n * Function: checkTolerance\r\n *\r\n * Checks if the coordinates for the given event are within the\r\n * <mxGraph.tolerance>. If the event is a mouse event then the tolerance is\r\n * ignored.\r\n */\nmxVertexHandler.prototype.checkTolerance = function (me) {\n  if (this.inTolerance && this.startX != null && this.startY != null) {\n    if (_mxEvent[\"default\"].isMouseEvent(me.getEvent()) || Math.abs(me.getGraphX() - this.startX) > this.graph.tolerance || Math.abs(me.getGraphY() - this.startY) > this.graph.tolerance) {\n      this.inTolerance = false;\n    }\n  }\n};\n\n/**\r\n * Function: updateHint\r\n *\r\n * Hook for subclassers do show details while the handler is active.\r\n */\nmxVertexHandler.prototype.updateHint = function (me) {};\n\n/**\r\n * Function: removeHint\r\n *\r\n * Hooks for subclassers to hide details when the handler gets inactive.\r\n */\nmxVertexHandler.prototype.removeHint = function () {};\n\n/**\r\n * Function: roundAngle\r\n *\r\n * Hook for rounding the angle. This uses Math.round.\r\n */\nmxVertexHandler.prototype.roundAngle = function (angle) {\n  return Math.round(angle * 10) / 10;\n};\n\n/**\r\n * Function: roundLength\r\n *\r\n * Hook for rounding the unscaled width or height. This uses Math.round.\r\n */\nmxVertexHandler.prototype.roundLength = function (length) {\n  return Math.round(length);\n};\n\n/**\r\n * Function: mouseMove\r\n *\r\n * Handles the event by updating the preview.\r\n */\nmxVertexHandler.prototype.mouseMove = function (sender, me) {\n  if (!me.isConsumed() && this.index != null) {\n    // Checks tolerance for ignoring single clicks\n    this.checkTolerance(me);\n    if (!this.inTolerance) {\n      if (this.index <= _mxEvent[\"default\"].CUSTOM_HANDLE) {\n        if (this.customHandles != null) {\n          this.customHandles[_mxEvent[\"default\"].CUSTOM_HANDLE - this.index].processEvent(me);\n        }\n      } else if (this.index == _mxEvent[\"default\"].LABEL_HANDLE) {\n        this.moveLabel(me);\n      } else if (this.index == _mxEvent[\"default\"].ROTATION_HANDLE) {\n        this.rotateVertex(me);\n      } else {\n        this.resizeVertex(me);\n      }\n      this.updateHint(me);\n    }\n    me.consume();\n  }\n  // Workaround for disabling the connect highlight when over handle\n  else if (!this.graph.isMouseDown && this.getHandleForEvent(me) != null) {\n    me.consume(false);\n  }\n};\n\n/**\r\n * Function: rotateVertex\r\n *\r\n * Rotates the vertex.\r\n */\nmxVertexHandler.prototype.moveLabel = function (me) {\n  var point = new _mxPoint[\"default\"](me.getGraphX(), me.getGraphY());\n  var tr = this.graph.view.translate;\n  var scale = this.graph.view.scale;\n  if (this.graph.isGridEnabledEvent(me.getEvent())) {\n    point.x = (this.graph.snap(point.x / scale - tr.x) + tr.x) * scale;\n    point.y = (this.graph.snap(point.y / scale - tr.y) + tr.y) * scale;\n  }\n  var index = this.rotationShape != null ? this.sizers.length - 2 : this.sizers.length - 1;\n  this.moveSizerTo(this.sizers[index], point.x, point.y);\n};\n\n/**\r\n * Function: rotateVertex\r\n *\r\n * Rotates the vertex.\r\n */\nmxVertexHandler.prototype.rotateVertex = function (me) {\n  var point = new _mxPoint[\"default\"](me.getGraphX(), me.getGraphY());\n  var dx = this.state.x + this.state.width / 2 - point.x;\n  var dy = this.state.y + this.state.height / 2 - point.y;\n  this.currentAlpha = dx != 0 ? Math.atan(dy / dx) * 180 / Math.PI + 90 : dy < 0 ? 180 : 0;\n  if (dx > 0) {\n    this.currentAlpha -= 180;\n  }\n\n  // Rotation raster\n  if (this.rotationRaster && this.graph.isGridEnabledEvent(me.getEvent())) {\n    var dx = point.x - this.state.getCenterX();\n    var dy = point.y - this.state.getCenterY();\n    var dist = Math.abs(Math.sqrt(dx * dx + dy * dy) - 20) * 3;\n    var raster = Math.max(1, 5 * Math.min(3, Math.max(0, Math.round(80 / Math.abs(dist)))));\n    this.currentAlpha = Math.round(this.currentAlpha / raster) * raster;\n  } else {\n    this.currentAlpha = this.roundAngle(this.currentAlpha);\n  }\n  this.selectionBorder.rotation = this.currentAlpha;\n  this.selectionBorder.redraw();\n  if (this.livePreview) {\n    this.redrawHandles();\n  }\n};\n\n/**\r\n * Function: rotateVertex\r\n *\r\n * Rotates the vertex.\r\n */\nmxVertexHandler.prototype.resizeVertex = function (me) {\n  var ct = new _mxPoint[\"default\"](this.state.getCenterX(), this.state.getCenterY());\n  var alpha = _mxUtils[\"default\"].toRadians(this.state.style[_mxConstants[\"default\"].STYLE_ROTATION] || '0');\n  var point = new _mxPoint[\"default\"](me.getGraphX(), me.getGraphY());\n  var tr = this.graph.view.translate;\n  var scale = this.graph.view.scale;\n  var cos = Math.cos(-alpha);\n  var sin = Math.sin(-alpha);\n  var dx = point.x - this.startX;\n  var dy = point.y - this.startY;\n\n  // Rotates vector for mouse gesture\n  var tx = cos * dx - sin * dy;\n  var ty = sin * dx + cos * dy;\n  dx = tx;\n  dy = ty;\n  var geo = this.graph.getCellGeometry(this.state.cell);\n  this.unscaledBounds = this.union(geo, dx / scale, dy / scale, this.index, this.graph.isGridEnabledEvent(me.getEvent()), 1, new _mxPoint[\"default\"](0, 0), this.isConstrainedEvent(me), this.isCenteredEvent(this.state, me));\n\n  // Keeps vertex within maximum graph or parent bounds\n  if (!geo.relative) {\n    var max = this.graph.getMaximumGraphBounds();\n\n    // Handles child cells\n    if (max != null && this.parentState != null) {\n      max = _mxRectangle[\"default\"].fromRectangle(max);\n      max.x -= (this.parentState.x - tr.x * scale) / scale;\n      max.y -= (this.parentState.y - tr.y * scale) / scale;\n    }\n    if (this.graph.isConstrainChild(this.state.cell)) {\n      var tmp = this.graph.getCellContainmentArea(this.state.cell);\n      if (tmp != null) {\n        var overlap = this.graph.getOverlap(this.state.cell);\n        if (overlap > 0) {\n          tmp = _mxRectangle[\"default\"].fromRectangle(tmp);\n          tmp.x -= tmp.width * overlap;\n          tmp.y -= tmp.height * overlap;\n          tmp.width += 2 * tmp.width * overlap;\n          tmp.height += 2 * tmp.height * overlap;\n        }\n        if (max == null) {\n          max = tmp;\n        } else {\n          max = _mxRectangle[\"default\"].fromRectangle(max);\n          max.intersect(tmp);\n        }\n      }\n    }\n    if (max != null) {\n      if (this.unscaledBounds.x < max.x) {\n        this.unscaledBounds.width -= max.x - this.unscaledBounds.x;\n        this.unscaledBounds.x = max.x;\n      }\n      if (this.unscaledBounds.y < max.y) {\n        this.unscaledBounds.height -= max.y - this.unscaledBounds.y;\n        this.unscaledBounds.y = max.y;\n      }\n      if (this.unscaledBounds.x + this.unscaledBounds.width > max.x + max.width) {\n        this.unscaledBounds.width -= this.unscaledBounds.x + this.unscaledBounds.width - max.x - max.width;\n      }\n      if (this.unscaledBounds.y + this.unscaledBounds.height > max.y + max.height) {\n        this.unscaledBounds.height -= this.unscaledBounds.y + this.unscaledBounds.height - max.y - max.height;\n      }\n    }\n  }\n  this.bounds = new _mxRectangle[\"default\"]((this.parentState != null ? this.parentState.x : tr.x * scale) + this.unscaledBounds.x * scale, (this.parentState != null ? this.parentState.y : tr.y * scale) + this.unscaledBounds.y * scale, this.unscaledBounds.width * scale, this.unscaledBounds.height * scale);\n  if (geo.relative && this.parentState != null) {\n    this.bounds.x += this.state.x - this.parentState.x;\n    this.bounds.y += this.state.y - this.parentState.y;\n  }\n  cos = Math.cos(alpha);\n  sin = Math.sin(alpha);\n  var c2 = new _mxPoint[\"default\"](this.bounds.getCenterX(), this.bounds.getCenterY());\n  var dx = c2.x - ct.x;\n  var dy = c2.y - ct.y;\n  var dx2 = cos * dx - sin * dy;\n  var dy2 = sin * dx + cos * dy;\n  var dx3 = dx2 - dx;\n  var dy3 = dy2 - dy;\n  var dx4 = this.bounds.x - this.state.x;\n  var dy4 = this.bounds.y - this.state.y;\n  var dx5 = cos * dx4 - sin * dy4;\n  var dy5 = sin * dx4 + cos * dy4;\n  this.bounds.x += dx3;\n  this.bounds.y += dy3;\n\n  // Rounds unscaled bounds to int\n  this.unscaledBounds.x = this.roundLength(this.unscaledBounds.x + dx3 / scale);\n  this.unscaledBounds.y = this.roundLength(this.unscaledBounds.y + dy3 / scale);\n  this.unscaledBounds.width = this.roundLength(this.unscaledBounds.width);\n  this.unscaledBounds.height = this.roundLength(this.unscaledBounds.height);\n\n  // Shifts the children according to parent offset\n  if (!this.graph.isCellCollapsed(this.state.cell) && (dx3 != 0 || dy3 != 0)) {\n    this.childOffsetX = this.state.x - this.bounds.x + dx5;\n    this.childOffsetY = this.state.y - this.bounds.y + dy5;\n  } else {\n    this.childOffsetX = 0;\n    this.childOffsetY = 0;\n  }\n  if (this.livePreview) {\n    this.updateLivePreview(me);\n  }\n  if (this.preview != null) {\n    this.drawPreview();\n  }\n};\n\n/**\r\n * Function: updateLivePreview\r\n *\r\n * Repaints the live preview.\r\n */\nmxVertexHandler.prototype.updateLivePreview = function (me) {\n  // TODO: Apply child offset to children in live preview\n  var scale = this.graph.view.scale;\n  var tr = this.graph.view.translate;\n\n  // Saves current state\n  var tempState = this.state.clone();\n\n  // Temporarily changes size and origin\n  this.state.x = this.bounds.x;\n  this.state.y = this.bounds.y;\n  this.state.origin = new _mxPoint[\"default\"](this.state.x / scale - tr.x, this.state.y / scale - tr.y);\n  this.state.width = this.bounds.width;\n  this.state.height = this.bounds.height;\n\n  // Needed to force update of text bounds\n  this.state.unscaledWidth = null;\n\n  // Redraws cell and handles\n  var off = this.state.absoluteOffset;\n  off = new _mxPoint[\"default\"](off.x, off.y);\n\n  // Required to store and reset absolute offset for updating label position\n  this.state.absoluteOffset.x = 0;\n  this.state.absoluteOffset.y = 0;\n  var geo = this.graph.getCellGeometry(this.state.cell);\n  if (geo != null) {\n    var offset = geo.offset || this.EMPTY_POINT;\n    if (offset != null && !geo.relative) {\n      this.state.absoluteOffset.x = this.state.view.scale * offset.x;\n      this.state.absoluteOffset.y = this.state.view.scale * offset.y;\n    }\n    this.state.view.updateVertexLabelOffset(this.state);\n  }\n\n  // Draws the live preview\n  this.state.view.graph.cellRenderer.redraw(this.state, true);\n\n  // Redraws connected edges TODO: Include child edges\n  this.state.view.invalidate(this.state.cell);\n  this.state.invalid = false;\n  this.state.view.validate();\n  this.redrawHandles();\n\n  // Restores current state\n  this.state.setState(tempState);\n};\n\n/**\r\n * Function: mouseUp\r\n *\r\n * Handles the event by applying the changes to the geometry.\r\n */\nmxVertexHandler.prototype.mouseUp = function (sender, me) {\n  if (this.index != null && this.state != null) {\n    var point = new _mxPoint[\"default\"](me.getGraphX(), me.getGraphY());\n    this.graph.getModel().beginUpdate();\n    try {\n      if (this.index <= _mxEvent[\"default\"].CUSTOM_HANDLE) {\n        if (this.customHandles != null) {\n          this.customHandles[_mxEvent[\"default\"].CUSTOM_HANDLE - this.index].execute();\n        }\n      } else if (this.index == _mxEvent[\"default\"].ROTATION_HANDLE) {\n        if (this.currentAlpha != null) {\n          var delta = this.currentAlpha - (this.state.style[_mxConstants[\"default\"].STYLE_ROTATION] || 0);\n          if (delta != 0) {\n            this.rotateCell(this.state.cell, delta);\n          }\n        } else {\n          this.rotateClick();\n        }\n      } else {\n        var gridEnabled = this.graph.isGridEnabledEvent(me.getEvent());\n        var alpha = _mxUtils[\"default\"].toRadians(this.state.style[_mxConstants[\"default\"].STYLE_ROTATION] || '0');\n        var cos = Math.cos(-alpha);\n        var sin = Math.sin(-alpha);\n        var dx = point.x - this.startX;\n        var dy = point.y - this.startY;\n\n        // Rotates vector for mouse gesture\n        var tx = cos * dx - sin * dy;\n        var ty = sin * dx + cos * dy;\n        dx = tx;\n        dy = ty;\n        var s = this.graph.view.scale;\n        var recurse = this.isRecursiveResize(this.state, me);\n        this.resizeCell(this.state.cell, this.roundLength(dx / s), this.roundLength(dy / s), this.index, gridEnabled, this.isConstrainedEvent(me), recurse);\n      }\n    } finally {\n      this.graph.getModel().endUpdate();\n    }\n    me.consume();\n    this.reset();\n  }\n};\n\n/**\r\n * Function: rotateCell\r\n *\r\n * Rotates the given cell to the given rotation.\r\n */\nmxVertexHandler.prototype.isRecursiveResize = function (state, me) {\n  return this.graph.isRecursiveResize(this.state);\n};\n\n/**\r\n * Function: rotateClick\r\n *\r\n * Hook for subclassers to implement a single click on the rotation handle.\r\n * This code is executed as part of the model transaction. This implementation\r\n * is empty.\r\n */\nmxVertexHandler.prototype.rotateClick = function () {};\n\n/**\r\n * Function: rotateCell\r\n *\r\n * Rotates the given cell and its children by the given angle in degrees.\r\n *\r\n * Parameters:\r\n *\r\n * cell - <mxCell> to be rotated.\r\n * angle - Angle in degrees.\r\n */\nmxVertexHandler.prototype.rotateCell = function (cell, angle, parent) {\n  if (angle != 0) {\n    var model = this.graph.getModel();\n    if (model.isVertex(cell) || model.isEdge(cell)) {\n      if (!model.isEdge(cell)) {\n        var state = this.graph.view.getState(cell);\n        var style = state != null ? state.style : this.graph.getCellStyle(cell);\n        if (style != null) {\n          var total = (style[_mxConstants[\"default\"].STYLE_ROTATION] || 0) + angle;\n          this.graph.setCellStyles(_mxConstants[\"default\"].STYLE_ROTATION, total, [cell]);\n        }\n      }\n      var geo = this.graph.getCellGeometry(cell);\n      if (geo != null) {\n        var pgeo = this.graph.getCellGeometry(parent);\n        if (pgeo != null && !model.isEdge(parent)) {\n          geo = geo.clone();\n          geo.rotate(angle, new _mxPoint[\"default\"](pgeo.width / 2, pgeo.height / 2));\n          model.setGeometry(cell, geo);\n        }\n        if (model.isVertex(cell) && !geo.relative || model.isEdge(cell)) {\n          // Recursive rotation\n          var childCount = model.getChildCount(cell);\n          for (var i = 0; i < childCount; i++) {\n            this.rotateCell(model.getChildAt(cell, i), angle, cell);\n          }\n        }\n      }\n    }\n  }\n};\n\n/**\r\n * Function: reset\r\n *\r\n * Resets the state of this handler.\r\n */\nmxVertexHandler.prototype.reset = function () {\n  if (this.sizers != null && this.index != null && this.sizers[this.index] != null && this.sizers[this.index].node.style.display == 'none') {\n    this.sizers[this.index].node.style.display = '';\n  }\n  this.currentAlpha = null;\n  this.inTolerance = null;\n  this.index = null;\n\n  // TODO: Reset and redraw cell states for live preview\n  if (this.preview != null) {\n    this.preview.destroy();\n    this.preview = null;\n  }\n  if (this.livePreview && this.sizers != null) {\n    for (var i = 0; i < this.sizers.length; i++) {\n      if (this.sizers[i] != null) {\n        this.sizers[i].node.style.display = '';\n      }\n    }\n  }\n  if (this.customHandles != null) {\n    for (var i = 0; i < this.customHandles.length; i++) {\n      this.customHandles[i].reset();\n    }\n  }\n\n  // Checks if handler has been destroyed\n  if (this.selectionBorder != null) {\n    this.selectionBorder.node.style.display = 'inline';\n    this.selectionBounds = this.getSelectionBounds(this.state);\n    this.bounds = new _mxRectangle[\"default\"](this.selectionBounds.x, this.selectionBounds.y, this.selectionBounds.width, this.selectionBounds.height);\n    this.drawPreview();\n  }\n  this.removeHint();\n  this.redrawHandles();\n  this.edgeHandlers = null;\n  this.unscaledBounds = null;\n};\n\n/**\r\n * Function: resizeCell\r\n *\r\n * Uses the given vector to change the bounds of the given cell\r\n * in the graph using <mxGraph.resizeCell>.\r\n */\nmxVertexHandler.prototype.resizeCell = function (cell, dx, dy, index, gridEnabled, constrained, recurse) {\n  var geo = this.graph.model.getGeometry(cell);\n  if (geo != null) {\n    if (index == _mxEvent[\"default\"].LABEL_HANDLE) {\n      var scale = this.graph.view.scale;\n      dx = Math.round((this.labelShape.bounds.getCenterX() - this.startX) / scale);\n      dy = Math.round((this.labelShape.bounds.getCenterY() - this.startY) / scale);\n      geo = geo.clone();\n      if (geo.offset == null) {\n        geo.offset = new _mxPoint[\"default\"](dx, dy);\n      } else {\n        geo.offset.x += dx;\n        geo.offset.y += dy;\n      }\n      this.graph.model.setGeometry(cell, geo);\n    } else if (this.unscaledBounds != null) {\n      var scale = this.graph.view.scale;\n      if (this.childOffsetX != 0 || this.childOffsetY != 0) {\n        this.moveChildren(cell, Math.round(this.childOffsetX / scale), Math.round(this.childOffsetY / scale));\n      }\n      this.graph.resizeCell(cell, this.unscaledBounds, recurse);\n    }\n  }\n};\n\n/**\r\n * Function: moveChildren\r\n *\r\n * Moves the children of the given cell by the given vector.\r\n */\nmxVertexHandler.prototype.moveChildren = function (cell, dx, dy) {\n  var model = this.graph.getModel();\n  var childCount = model.getChildCount(cell);\n  for (var i = 0; i < childCount; i++) {\n    var child = model.getChildAt(cell, i);\n    var geo = this.graph.getCellGeometry(child);\n    if (geo != null) {\n      geo = geo.clone();\n      geo.translate(dx, dy);\n      model.setGeometry(child, geo);\n    }\n  }\n};\n/**\r\n * Function: union\r\n *\r\n * Returns the union of the given bounds and location for the specified\r\n * handle index.\r\n *\r\n * To override this to limit the size of vertex via a minWidth/-Height style,\r\n * the following code can be used.\r\n *\r\n * (code)\r\n * var vertexHandlerUnion = mxVertexHandler.prototype.union;\r\n * mxVertexHandler.prototype.union = function(bounds, dx, dy, index, gridEnabled, scale, tr, constrained)\r\n * {\r\n *   var result = vertexHandlerUnion.apply(this, arguments);\r\n *\r\n *   result.width = Math.max(result.width, mxGraphUtils.getNumber(this.state.style, 'minWidth', 0));\r\n *   result.height = Math.max(result.height, mxGraphUtils.getNumber(this.state.style, 'minHeight', 0));\r\n *\r\n *   return result;\r\n * };\r\n * (end)\r\n *\r\n * The minWidth/-Height style can then be used as follows:\r\n *\r\n * (code)\r\n * graph.insertVertex(parent, null, 'Hello,', 20, 20, 80, 30, 'minWidth=100;minHeight=100;');\r\n * (end)\r\n *\r\n * To override this to update the height for a wrapped text if the width of a vertex is\r\n * changed, the following can be used.\r\n *\r\n * (code)\r\n * var mxVertexHandlerUnion = mxVertexHandler.prototype.union;\r\n * mxVertexHandler.prototype.union = function(bounds, dx, dy, index, gridEnabled, scale, tr, constrained)\r\n * {\r\n *   var result = mxVertexHandlerUnion.apply(this, arguments);\r\n *   var s = this.state;\r\n *\r\n *   if (this.graph.isHtmlLabel(s.cell) && (index == 3 || index == 4) &&\r\n *       s.text != null && s.style[mxConstants.STYLE_WHITE_SPACE] == 'wrap')\r\n *   {\r\n *     var label = this.graph.getLabel(s.cell);\r\n *     var fontSize = mxGraphUtils.getNumber(s.style, mxConstants.STYLE_FONTSIZE, mxConstants.DEFAULT_FONTSIZE);\r\n *     var ww = result.width / s.view.scale - s.text.spacingRight - s.text.spacingLeft\r\n *\r\n *     result.height = mxUtils.getSizeForString(label, fontSize, s.style[mxConstants.STYLE_FONTFAMILY], ww).height;\r\n *   }\r\n *\r\n *   return result;\r\n * };\r\n * (end)\r\n */\nmxVertexHandler.prototype.union = function (bounds, dx, dy, index, gridEnabled, scale, tr, constrained, centered) {\n  if (this.singleSizer) {\n    var x = bounds.x + bounds.width + dx;\n    var y = bounds.y + bounds.height + dy;\n    if (gridEnabled) {\n      x = this.graph.snap(x / scale) * scale;\n      y = this.graph.snap(y / scale) * scale;\n    }\n    var rect = new _mxRectangle[\"default\"](bounds.x, bounds.y, 0, 0);\n    rect.add(new _mxRectangle[\"default\"](x, y, 0, 0));\n    return rect;\n  } else {\n    var w0 = bounds.width;\n    var h0 = bounds.height;\n    var left = bounds.x - tr.x * scale;\n    var right = left + w0;\n    var top = bounds.y - tr.y * scale;\n    var bottom = top + h0;\n    var cx = left + w0 / 2;\n    var cy = top + h0 / 2;\n    if (index > 4 /* Bottom Row */) {\n      bottom = bottom + dy;\n      if (gridEnabled) {\n        bottom = this.graph.snap(bottom / scale) * scale;\n      }\n    } else if (index < 3 /* Top Row */) {\n      top = top + dy;\n      if (gridEnabled) {\n        top = this.graph.snap(top / scale) * scale;\n      }\n    }\n    if (index == 0 || index == 3 || index == 5 /* Left */) {\n      left += dx;\n      if (gridEnabled) {\n        left = this.graph.snap(left / scale) * scale;\n      }\n    } else if (index == 2 || index == 4 || index == 7 /* Right */) {\n      right += dx;\n      if (gridEnabled) {\n        right = this.graph.snap(right / scale) * scale;\n      }\n    }\n    var width = right - left;\n    var height = bottom - top;\n    if (constrained) {\n      var geo = this.graph.getCellGeometry(this.state.cell);\n      if (geo != null) {\n        var aspect = geo.width / geo.height;\n        if (index == 1 || index == 2 || index == 7 || index == 6) {\n          width = height * aspect;\n        } else {\n          height = width / aspect;\n        }\n        if (index == 0) {\n          left = right - width;\n          top = bottom - height;\n        }\n      }\n    }\n    if (centered) {\n      width += width - w0;\n      height += height - h0;\n      var cdx = cx - (left + width / 2);\n      var cdy = cy - (top + height / 2);\n      left += cdx;\n      top += cdy;\n      right += cdx;\n      bottom += cdy;\n    }\n\n    // Flips over left side\n    if (width < 0) {\n      left += width;\n      width = Math.abs(width);\n    }\n\n    // Flips over top side\n    if (height < 0) {\n      top += height;\n      height = Math.abs(height);\n    }\n    var result = new _mxRectangle[\"default\"](left + tr.x * scale, top + tr.y * scale, width, height);\n    if (this.minBounds != null) {\n      result.width = Math.max(result.width, this.minBounds.x * scale + this.minBounds.width * scale + Math.max(0, this.x0 * scale - result.x));\n      result.height = Math.max(result.height, this.minBounds.y * scale + this.minBounds.height * scale + Math.max(0, this.y0 * scale - result.y));\n    }\n    return result;\n  }\n};\n\n/**\r\n * Function: redraw\r\n *\r\n * Redraws the handles and the preview.\r\n */\nmxVertexHandler.prototype.redraw = function () {\n  this.selectionBounds = this.getSelectionBounds(this.state);\n  this.bounds = new _mxRectangle[\"default\"](this.selectionBounds.x, this.selectionBounds.y, this.selectionBounds.width, this.selectionBounds.height);\n  this.redrawHandles();\n  this.drawPreview();\n};\n\n/**\r\n * Returns the padding to be used for drawing handles for the current <bounds>.\r\n */\nmxVertexHandler.prototype.getHandlePadding = function () {\n  // KNOWN: Tolerance depends on event type (eg. 0 for mouse events)\n  var result = new _mxPoint[\"default\"](0, 0);\n  var tol = this.tolerance;\n  if (this.sizers != null && this.sizers.length > 0 && this.sizers[0] != null && (this.bounds.width < 2 * this.sizers[0].bounds.width + 2 * tol || this.bounds.height < 2 * this.sizers[0].bounds.height + 2 * tol)) {\n    tol /= 2;\n    result.x = this.sizers[0].bounds.width + tol;\n    result.y = this.sizers[0].bounds.height + tol;\n  }\n  return result;\n};\n\n/**\r\n * Function: redrawHandles\r\n *\r\n * Redraws the handles. To hide certain handles the following code can be used.\r\n *\r\n * (code)\r\n * mxVertexHandler.prototype.redrawHandles = function()\r\n * {\r\n *   mxVertexHandlerRedrawHandles.apply(this, arguments);\r\n *\r\n *   if (this.sizers != null && this.sizers.length > 7)\r\n *   {\r\n *     this.sizers[1].node.style.display = 'none';\r\n *     this.sizers[6].node.style.display = 'none';\r\n *   }\r\n * };\r\n * (end)\r\n */\nmxVertexHandler.prototype.redrawHandles = function () {\n  var tol = this.tolerance;\n  this.horizontalOffset = 0;\n  this.verticalOffset = 0;\n  var s = this.bounds;\n  if (this.sizers != null && this.sizers.length > 0 && this.sizers[0] != null) {\n    if (this.index == null && this.manageSizers && this.sizers.length >= 8) {\n      // KNOWN: Tolerance depends on event type (eg. 0 for mouse events)\n      var padding = this.getHandlePadding();\n      this.horizontalOffset = padding.x;\n      this.verticalOffset = padding.y;\n      if (this.horizontalOffset != 0 || this.verticalOffset != 0) {\n        s = new _mxRectangle[\"default\"](s.x, s.y, s.width, s.height);\n        s.x -= this.horizontalOffset / 2;\n        s.width += this.horizontalOffset;\n        s.y -= this.verticalOffset / 2;\n        s.height += this.verticalOffset;\n      }\n      if (this.sizers.length >= 8) {\n        if (s.width < 2 * this.sizers[0].bounds.width + 2 * tol || s.height < 2 * this.sizers[0].bounds.height + 2 * tol) {\n          this.sizers[0].node.style.display = 'none';\n          this.sizers[2].node.style.display = 'none';\n          this.sizers[5].node.style.display = 'none';\n          this.sizers[7].node.style.display = 'none';\n        } else {\n          this.sizers[0].node.style.display = '';\n          this.sizers[2].node.style.display = '';\n          this.sizers[5].node.style.display = '';\n          this.sizers[7].node.style.display = '';\n        }\n      }\n    }\n    var r = s.x + s.width;\n    var b = s.y + s.height;\n    if (this.singleSizer) {\n      this.moveSizerTo(this.sizers[0], r, b);\n    } else {\n      var cx = s.x + s.width / 2;\n      var cy = s.y + s.height / 2;\n      if (this.sizers.length >= 8) {\n        var crs = ['nw-resize', 'n-resize', 'ne-resize', 'e-resize', 'se-resize', 's-resize', 'sw-resize', 'w-resize'];\n        var alpha = _mxUtils[\"default\"].toRadians(this.state.style[_mxConstants[\"default\"].STYLE_ROTATION] || '0');\n        var cos = Math.cos(alpha);\n        var sin = Math.sin(alpha);\n        var da = Math.round(alpha * 4 / Math.PI);\n        var ct = new _mxPoint[\"default\"](s.getCenterX(), s.getCenterY());\n        var pt = _mxUtils[\"default\"].getRotatedPoint(new _mxPoint[\"default\"](s.x, s.y), cos, sin, ct);\n        this.moveSizerTo(this.sizers[0], pt.x, pt.y);\n        this.sizers[0].setCursor(crs[_mxGraphUtils[\"default\"].mod(0 + da, crs.length)]);\n        pt.x = cx;\n        pt.y = s.y;\n        pt = _mxUtils[\"default\"].getRotatedPoint(pt, cos, sin, ct);\n        this.moveSizerTo(this.sizers[1], pt.x, pt.y);\n        this.sizers[1].setCursor(crs[_mxGraphUtils[\"default\"].mod(1 + da, crs.length)]);\n        pt.x = r;\n        pt.y = s.y;\n        pt = _mxUtils[\"default\"].getRotatedPoint(pt, cos, sin, ct);\n        this.moveSizerTo(this.sizers[2], pt.x, pt.y);\n        this.sizers[2].setCursor(crs[_mxGraphUtils[\"default\"].mod(2 + da, crs.length)]);\n        pt.x = s.x;\n        pt.y = cy;\n        pt = _mxUtils[\"default\"].getRotatedPoint(pt, cos, sin, ct);\n        this.moveSizerTo(this.sizers[3], pt.x, pt.y);\n        this.sizers[3].setCursor(crs[_mxGraphUtils[\"default\"].mod(7 + da, crs.length)]);\n        pt.x = r;\n        pt.y = cy;\n        pt = _mxUtils[\"default\"].getRotatedPoint(pt, cos, sin, ct);\n        this.moveSizerTo(this.sizers[4], pt.x, pt.y);\n        this.sizers[4].setCursor(crs[_mxGraphUtils[\"default\"].mod(3 + da, crs.length)]);\n        pt.x = s.x;\n        pt.y = b;\n        pt = _mxUtils[\"default\"].getRotatedPoint(pt, cos, sin, ct);\n        this.moveSizerTo(this.sizers[5], pt.x, pt.y);\n        this.sizers[5].setCursor(crs[_mxGraphUtils[\"default\"].mod(6 + da, crs.length)]);\n        pt.x = cx;\n        pt.y = b;\n        pt = _mxUtils[\"default\"].getRotatedPoint(pt, cos, sin, ct);\n        this.moveSizerTo(this.sizers[6], pt.x, pt.y);\n        this.sizers[6].setCursor(crs[_mxGraphUtils[\"default\"].mod(5 + da, crs.length)]);\n        pt.x = r;\n        pt.y = b;\n        pt = _mxUtils[\"default\"].getRotatedPoint(pt, cos, sin, ct);\n        this.moveSizerTo(this.sizers[7], pt.x, pt.y);\n        this.sizers[7].setCursor(crs[_mxGraphUtils[\"default\"].mod(4 + da, crs.length)]);\n        this.moveSizerTo(this.sizers[8], cx + this.state.absoluteOffset.x, cy + this.state.absoluteOffset.y);\n      } else if (this.state.width >= 2 && this.state.height >= 2) {\n        this.moveSizerTo(this.sizers[0], cx + this.state.absoluteOffset.x, cy + this.state.absoluteOffset.y);\n      } else {\n        this.moveSizerTo(this.sizers[0], this.state.x, this.state.y);\n      }\n    }\n  }\n  if (this.rotationShape != null) {\n    var alpha = _mxUtils[\"default\"].toRadians(this.currentAlpha != null ? this.currentAlpha : this.state.style[_mxConstants[\"default\"].STYLE_ROTATION] || '0');\n    var cos = Math.cos(alpha);\n    var sin = Math.sin(alpha);\n    var ct = new _mxPoint[\"default\"](this.state.getCenterX(), this.state.getCenterY());\n    var pt = _mxUtils[\"default\"].getRotatedPoint(new _mxPoint[\"default\"](s.x + s.width / 2, s.y + this.rotationHandleVSpacing), cos, sin, ct);\n    if (this.rotationShape.node != null) {\n      this.moveSizerTo(this.rotationShape, pt.x, pt.y);\n    }\n  }\n  if (this.selectionBorder != null) {\n    this.selectionBorder.rotation = Number(this.state.style[_mxConstants[\"default\"].STYLE_ROTATION] || '0');\n  }\n  if (this.edgeHandlers != null) {\n    for (var i = 0; i < this.edgeHandlers.length; i++) {\n      this.edgeHandlers[i].redraw();\n    }\n  }\n  if (this.customHandles != null) {\n    for (var i = 0; i < this.customHandles.length; i++) {\n      this.customHandles[i].redraw();\n    }\n  }\n  this.updateParentHighlight();\n};\n\n/**\r\n * Function: updateParentHighlight\r\n *\r\n * Updates the highlight of the parent if <parentHighlightEnabled> is true.\r\n */\nmxVertexHandler.prototype.updateParentHighlight = function () {\n  // If not destroyed\n  if (this.selectionBorder != null) {\n    if (this.parentHighlight != null) {\n      var parent = this.graph.model.getParent(this.state.cell);\n      if (this.graph.model.isVertex(parent)) {\n        var pstate = this.graph.view.getState(parent);\n        var b = this.parentHighlight.bounds;\n        if (pstate != null && (b.x != pstate.x || b.y != pstate.y || b.width != pstate.width || b.height != pstate.height)) {\n          this.parentHighlight.bounds = pstate;\n          this.parentHighlight.redraw();\n        }\n      } else {\n        this.parentHighlight.destroy();\n        this.parentHighlight = null;\n      }\n    } else if (this.parentHighlightEnabled) {\n      var parent = this.graph.model.getParent(this.state.cell);\n      if (this.graph.model.isVertex(parent)) {\n        var pstate = this.graph.view.getState(parent);\n        if (pstate != null) {\n          this.parentHighlight = this.createParentHighlightShape(pstate);\n          // VML dialect required here for event transparency in IE\n          this.parentHighlight.dialect = this.graph.dialect != _mxConstants[\"default\"].DIALECT_SVG ? _mxConstants[\"default\"].DIALECT_VML : _mxConstants[\"default\"].DIALECT_SVG;\n          this.parentHighlight.pointerEvents = false;\n          this.parentHighlight.rotation = Number(pstate.style[_mxConstants[\"default\"].STYLE_ROTATION] || '0');\n          this.parentHighlight.init(this.graph.getView().getOverlayPane());\n        }\n      }\n    }\n  }\n};\n\n/**\r\n * Function: drawPreview\r\n *\r\n * Redraws the preview.\r\n */\nmxVertexHandler.prototype.drawPreview = function () {\n  if (this.preview != null) {\n    this.preview.bounds = this.bounds;\n    if (this.preview.node.parentNode == this.graph.container) {\n      this.preview.bounds.width = Math.max(0, this.preview.bounds.width - 1);\n      this.preview.bounds.height = Math.max(0, this.preview.bounds.height - 1);\n    }\n    this.preview.rotation = Number(this.state.style[_mxConstants[\"default\"].STYLE_ROTATION] || '0');\n    this.preview.redraw();\n  }\n  this.selectionBorder.bounds = this.bounds;\n  this.selectionBorder.redraw();\n  if (this.parentHighlight != null) {\n    this.parentHighlight.redraw();\n  }\n};\n\n/**\r\n * Function: destroy\r\n *\r\n * Destroys the handler and all its resources and DOM nodes.\r\n */\nmxVertexHandler.prototype.destroy = function () {\n  if (this.escapeHandler != null) {\n    this.state.view.graph.removeListener(this.escapeHandler);\n    this.escapeHandler = null;\n  }\n  if (this.preview != null) {\n    this.preview.destroy();\n    this.preview = null;\n  }\n  if (this.parentHighlight != null) {\n    this.parentHighlight.destroy();\n    this.parentHighlight = null;\n  }\n  if (this.selectionBorder != null) {\n    this.selectionBorder.destroy();\n    this.selectionBorder = null;\n  }\n  this.labelShape = null;\n  this.removeHint();\n  if (this.sizers != null) {\n    for (var i = 0; i < this.sizers.length; i++) {\n      this.sizers[i].destroy();\n    }\n    this.sizers = null;\n  }\n  if (this.customHandles != null) {\n    for (var i = 0; i < this.customHandles.length; i++) {\n      this.customHandles[i].destroy();\n    }\n    this.customHandles = null;\n  }\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxEdgeHandler\r\n *\r\n * Graph event handler that reconnects edges and modifies control points and\r\n * the edge label location. Uses <mxTerminalMarker> for finding and\r\n * highlighting new source and target vertices. This handler is automatically\r\n * created in <mxGraph.createHandler> for each selected edge.\r\n *\r\n * To enable adding/removing control points, the following code can be used:\r\n *\r\n * (code)\r\n * mxEdgeHandler.prototype.addEnabled = true;\r\n * mxEdgeHandler.prototype.removeEnabled = true;\r\n * (end)\r\n *\r\n * Note: This experimental feature is not recommended for production use.\r\n *\r\n * Constructor: mxEdgeHandler\r\n *\r\n * Constructs an edge handler for the specified <mxCellState>.\r\n *\r\n * Parameters:\r\n *\r\n * state - <mxCellState> of the cell to be handled.\r\n */\nvar _default = exports[\"default\"] = mxVertexHandler;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxVertexHandler.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxVisibleChange.js":
/*!**************************************************!*\
  !*** ./src/workflow/mxClient/mxVisibleChange.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nfunction mxVisibleChange(model, cell, visible) {\n  this.model = model;\n  this.cell = cell;\n  this.visible = visible;\n  this.previous = visible;\n}\n;\n\n/**\r\n * Function: execute\r\n *\r\n * Changes the visible state of <cell> to <previous> using\r\n * <mxGraphModel.visibleStateForCellChanged>.\r\n */\nmxVisibleChange.prototype.execute = function () {\n  this.visible = this.previous;\n  this.previous = this.model.visibleStateForCellChanged(this.cell, this.previous);\n};\nmxVisibleChange.getName = function () {\n  return 'mxVisibleChange';\n};\n/**\r\n * Class: mxCellAttributeChange\r\n *\r\n * Action to change the attribute of a cell's user object.\r\n * There is no method on the graph model that uses this\r\n * action. To use the action, you can use the code shown\r\n * in the example below.\r\n *\r\n * Example:\r\n *\r\n * To change the attributeName in the cell's user object\r\n * to attributeValue, use the following code:\r\n *\r\n * (code)\r\n * model.beginUpdate();\r\n * try\r\n * {\r\n *   var edit = new mxCellAttributeChange(\r\n *     cell, attributeName, attributeValue);\r\n *   model.execute(edit);\r\n * }\r\n * finally\r\n * {\r\n *   model.endUpdate();\r\n * }\r\n * (end)\r\n *\r\n * Constructor: mxCellAttributeChange\r\n *\r\n * Constructs a change of a attribute of the DOM node\r\n * stored as the value of the given <mxCell>.\r\n */\nvar _default = exports[\"default\"] = mxVisibleChange;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxVisibleChange.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxVmlCanvas2D.js":
/*!************************************************!*\
  !*** ./src/workflow/mxClient/mxVmlCanvas2D.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.fill.js */ \"../../node_modules/core-js/modules/es.array.fill.js\");\n__webpack_require__(/*! core-js/modules/es.array.filter.js */ \"../../node_modules/core-js/modules/es.array.filter.js\");\n__webpack_require__(/*! core-js/modules/es.array.join.js */ \"../../node_modules/core-js/modules/es.array.join.js\");\n__webpack_require__(/*! core-js/modules/es.number.to-fixed.js */ \"../../node_modules/core-js/modules/es.number.to-fixed.js\");\n__webpack_require__(/*! core-js/modules/es.object.to-string.js */ \"../../node_modules/core-js/modules/es.object.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.parse-float.js */ \"../../node_modules/core-js/modules/es.parse-float.js\");\n__webpack_require__(/*! core-js/modules/es.parse-int.js */ \"../../node_modules/core-js/modules/es.parse-int.js\");\nvar _mxPoint = _interopRequireDefault(__webpack_require__(/*! ./mxPoint.js */ \"./src/workflow/mxClient/mxPoint.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxAbstractCanvas2D = _interopRequireDefault(__webpack_require__(/*! ./mxAbstractCanvas2D.js */ \"./src/workflow/mxClient/mxAbstractCanvas2D.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nvar mxVmlCanvas2D = function mxVmlCanvas2D(root) {\n  _mxAbstractCanvas2D[\"default\"].call(this);\n\n  /**\r\n   * Variable: root\r\n   *\r\n   * Reference to the container for the SVG content.\r\n   */\n  this.root = root;\n};\n\n/**\r\n * Extends mxAbstractCanvas2D\r\n */\n_mxGraphUtils[\"default\"].extend(mxVmlCanvas2D, _mxAbstractCanvas2D[\"default\"]);\n\n/**\r\n * Variable: path\r\n *\r\n * Holds the current DOM node.\r\n */\nmxVmlCanvas2D.prototype.node = null;\n\n/**\r\n * Variable: textEnabled\r\n *\r\n * Specifies if text output should be enabledetB. Default is true.\r\n */\nmxVmlCanvas2D.prototype.textEnabled = true;\n\n/**\r\n * Variable: moveOp\r\n *\r\n * Contains the string used for moving in paths. Default is 'm'.\r\n */\nmxVmlCanvas2D.prototype.moveOp = 'm';\n\n/**\r\n * Variable: lineOp\r\n *\r\n * Contains the string used for moving in paths. Default is 'l'.\r\n */\nmxVmlCanvas2D.prototype.lineOp = 'l';\n\n/**\r\n * Variable: curveOp\r\n *\r\n * Contains the string used for bezier curves. Default is 'c'.\r\n */\nmxVmlCanvas2D.prototype.curveOp = 'c';\n\n/**\r\n * Variable: closeOp\r\n *\r\n * Holds the operator for closing curves. Default is 'x e'.\r\n */\nmxVmlCanvas2D.prototype.closeOp = 'x';\n\n/**\r\n * Variable: rotatedHtmlBackground\r\n *\r\n * Background color for rotated HTML. Default is ''. This can be set to eg.\r\n * white to improve rendering of rotated text in VML for IE9.\r\n */\nmxVmlCanvas2D.prototype.rotatedHtmlBackground = '';\n\n/**\r\n * Variable: vmlScale\r\n *\r\n * Specifies the scale used to draw VML shapes.\r\n */\nmxVmlCanvas2D.prototype.vmlScale = 1;\n\n/**\r\n * Function: createElement\r\n *\r\n * Creates the given element using the document.\r\n */\nmxVmlCanvas2D.prototype.createElement = function (name) {\n  return document.createElement(name);\n};\n\n/**\r\n * Function: createVmlElement\r\n *\r\n * Creates a new element using <createElement> and prefixes the given name with\r\n * <mxClient.VML_PREFIX>.\r\n */\nmxVmlCanvas2D.prototype.createVmlElement = function (name) {\n  return this.createElement(mxClient.VML_PREFIX + ':' + name);\n};\n\n/**\r\n * Function: addNode\r\n *\r\n * Adds the current node to the <root>.\r\n */\nmxVmlCanvas2D.prototype.addNode = function (filled, stroked) {\n  var node = this.node;\n  var s = this.state;\n  if (node != null) {\n    if (node.nodeName == 'shape') {\n      // Checks if the path is not empty\n      if (this.path != null && this.path.length > 0) {\n        node.path = this.path.join(' ') + ' e';\n        node.style.width = this.root.style.width;\n        node.style.height = this.root.style.height;\n        node.coordsize = parseInt(node.style.width) + ' ' + parseInt(node.style.height);\n      } else {\n        return;\n      }\n    }\n    node.strokeweight = this.format(Math.max(1, s.strokeWidth * s.scale / this.vmlScale)) + 'px';\n    if (s.shadow) {\n      this.root.appendChild(this.createShadow(node, filled && s.fillColor != null, stroked && s.strokeColor != null));\n    }\n    if (stroked && s.strokeColor != null) {\n      node.stroked = 'true';\n      node.strokecolor = s.strokeColor;\n    } else {\n      node.stroked = 'false';\n    }\n    node.appendChild(this.createStroke());\n    if (filled && s.fillColor != null) {\n      node.appendChild(this.createFill());\n    } else if (this.pointerEvents && (node.nodeName != 'shape' || this.path[this.path.length - 1] == this.closeOp)) {\n      node.appendChild(this.createTransparentFill());\n    } else {\n      node.filled = 'false';\n    }\n\n    // LATER: Update existing DOM for performance\n    this.root.appendChild(node);\n  }\n};\n\n/**\r\n * Function: createTransparentFill\r\n *\r\n * Creates a transparent fill.\r\n */\nmxVmlCanvas2D.prototype.createTransparentFill = function () {\n  var fill = this.createVmlElement('fill');\n  fill.src = mxClient.imageBasePath + '/transparent.gif';\n  fill.type = 'tile';\n  return fill;\n};\n\n/**\r\n * Function: createFill\r\n *\r\n * Creates a fill for the current state.\r\n */\nmxVmlCanvas2D.prototype.createFill = function () {\n  var s = this.state;\n\n  // Gradients in foregrounds not supported because special gradients\n  // with bounds must be created for each element in graphics-canvases\n  var fill = this.createVmlElement('fill');\n  fill.color = s.fillColor;\n  if (s.gradientColor != null) {\n    fill.type = 'gradient';\n    fill.method = 'none';\n    fill.color2 = s.gradientColor;\n    var angle = 180 - s.rotation;\n    if (s.gradientDirection == mxConstants.DIRECTION_WEST) {\n      angle -= 90 + (this.root.style.flip == 'x' ? 180 : 0);\n    } else if (s.gradientDirection == mxConstants.DIRECTION_EAST) {\n      angle += 90 + (this.root.style.flip == 'x' ? 180 : 0);\n    } else if (s.gradientDirection == mxConstants.DIRECTION_NORTH) {\n      angle -= 180 + (this.root.style.flip == 'y' ? -180 : 0);\n    } else {\n      angle += this.root.style.flip == 'y' ? -180 : 0;\n    }\n    if (this.root.style.flip == 'x' || this.root.style.flip == 'y') {\n      angle *= -1;\n    }\n\n    // LATER: Fix outer bounding box for rotated shapes used in VML.\n    fill.angle = _mxGraphUtils[\"default\"].mod(angle, 360);\n    fill.opacity = s.alpha * s.gradientFillAlpha * 100 + '%';\n    fill.setAttribute(mxClient.OFFICE_PREFIX + ':opacity2', s.alpha * s.gradientAlpha * 100 + '%');\n  } else if (s.alpha < 1 || s.fillAlpha < 1) {\n    fill.opacity = s.alpha * s.fillAlpha * 100 + '%';\n  }\n  return fill;\n};\n/**\r\n * Function: createStroke\r\n *\r\n * Creates a fill for the current state.\r\n */\nmxVmlCanvas2D.prototype.createStroke = function () {\n  var s = this.state;\n  var stroke = this.createVmlElement('stroke');\n  stroke.endcap = s.lineCap || 'flat';\n  stroke.joinstyle = s.lineJoin || 'miter';\n  stroke.miterlimit = s.miterLimit || '10';\n  if (s.alpha < 1 || s.strokeAlpha < 1) {\n    stroke.opacity = s.alpha * s.strokeAlpha * 100 + '%';\n  }\n  if (s.dashed) {\n    stroke.dashstyle = this.getVmlDashStyle();\n  }\n  return stroke;\n};\n\n/**\r\n * Function: getVmlDashPattern\r\n *\r\n * Returns a VML dash pattern for the current dashPattern.\r\n * See http://msdn.microsoft.com/en-us/library/bb264085(v=vs.85).aspx\r\n */\nmxVmlCanvas2D.prototype.getVmlDashStyle = function () {\n  var result = 'dash';\n  if (typeof this.state.dashPattern === 'string') {\n    var tok = this.state.dashPattern.split(' ');\n    if (tok.length > 0 && tok[0] == 1) {\n      result = '0 2';\n    }\n  }\n  return result;\n};\n\n/**\r\n * Function: createShadow\r\n *\r\n * Creates a shadow for the given node.\r\n */\nmxVmlCanvas2D.prototype.createShadow = function (node, filled, stroked) {\n  var s = this.state;\n  var rad = -s.rotation * (Math.PI / 180);\n  var cos = Math.cos(rad);\n  var sin = Math.sin(rad);\n  var dx = s.shadowDx * s.scale;\n  var dy = s.shadowDy * s.scale;\n  if (this.root.style.flip == 'x') {\n    dx *= -1;\n  } else if (this.root.style.flip == 'y') {\n    dy *= -1;\n  }\n  var shadow = node.cloneNode(true);\n  shadow.style.marginLeft = Math.round(dx * cos - dy * sin) + 'px';\n  shadow.style.marginTop = Math.round(dx * sin + dy * cos) + 'px';\n\n  // Workaround for wrong cloning in IE8 standards mode\n  if (document.documentMode == 8) {\n    shadow.strokeweight = node.strokeweight;\n    if (node.nodeName == 'shape') {\n      shadow.path = this.path.join(' ') + ' e';\n      shadow.style.width = this.root.style.width;\n      shadow.style.height = this.root.style.height;\n      shadow.coordsize = parseInt(node.style.width) + ' ' + parseInt(node.style.height);\n    }\n  }\n  if (stroked) {\n    shadow.strokecolor = s.shadowColor;\n    shadow.appendChild(this.createShadowStroke());\n  } else {\n    shadow.stroked = 'false';\n  }\n  if (filled) {\n    shadow.appendChild(this.createShadowFill());\n  } else {\n    shadow.filled = 'false';\n  }\n  return shadow;\n};\n\n/**\r\n * Function: createShadowFill\r\n *\r\n * Creates the fill for the shadow.\r\n */\nmxVmlCanvas2D.prototype.createShadowFill = function () {\n  var fill = this.createVmlElement('fill');\n  fill.color = this.state.shadowColor;\n  fill.opacity = this.state.alpha * this.state.shadowAlpha * 100 + '%';\n  return fill;\n};\n\n/**\r\n * Function: createShadowStroke\r\n *\r\n * Creates the stroke for the shadow.\r\n */\nmxVmlCanvas2D.prototype.createShadowStroke = function () {\n  var stroke = this.createStroke();\n  stroke.opacity = this.state.alpha * this.state.shadowAlpha * 100 + '%';\n  return stroke;\n};\n\n/**\r\n * Function: rotate\r\n *\r\n * Sets the rotation of the canvas. Note that rotation cannot be concatenated.\r\n */\nmxVmlCanvas2D.prototype.rotate = function (theta, flipH, flipV, cx, cy) {\n  if (flipH && flipV) {\n    theta += 180;\n  } else if (flipH) {\n    this.root.style.flip = 'x';\n  } else if (flipV) {\n    this.root.style.flip = 'y';\n  }\n  if (flipH ? !flipV : flipV) {\n    theta *= -1;\n  }\n  this.root.style.rotation = theta;\n  this.state.rotation = this.state.rotation + theta;\n  this.state.rotationCx = cx;\n  this.state.rotationCy = cy;\n};\n\n/**\r\n * Function: begin\r\n *\r\n * Extends superclass to create path.\r\n */\nmxVmlCanvas2D.prototype.begin = function () {\n  _mxAbstractCanvas2D[\"default\"].prototype.begin.apply(this, arguments);\n  this.node = this.createVmlElement('shape');\n  this.node.style.position = 'absolute';\n};\n\n/**\r\n * Function: quadTo\r\n *\r\n * Replaces quadratic curve with bezier curve in VML.\r\n */\nmxVmlCanvas2D.prototype.quadTo = function (x1, y1, x2, y2) {\n  var s = this.state;\n  var cpx0 = (this.lastX + s.dx) * s.scale;\n  var cpy0 = (this.lastY + s.dy) * s.scale;\n  var qpx1 = (x1 + s.dx) * s.scale;\n  var qpy1 = (y1 + s.dy) * s.scale;\n  var cpx3 = (x2 + s.dx) * s.scale;\n  var cpy3 = (y2 + s.dy) * s.scale;\n  var cpx1 = cpx0 + 2 / 3 * (qpx1 - cpx0);\n  var cpy1 = cpy0 + 2 / 3 * (qpy1 - cpy0);\n  var cpx2 = cpx3 + 2 / 3 * (qpx1 - cpx3);\n  var cpy2 = cpy3 + 2 / 3 * (qpy1 - cpy3);\n  this.path.push('c ' + this.format(cpx1) + ' ' + this.format(cpy1) + ' ' + this.format(cpx2) + ' ' + this.format(cpy2) + ' ' + this.format(cpx3) + ' ' + this.format(cpy3));\n  this.lastX = cpx3 / s.scale - s.dx;\n  this.lastY = cpy3 / s.scale - s.dy;\n};\n\n/**\r\n * Function: createRect\r\n *\r\n * Sets the glass gradient.\r\n */\nmxVmlCanvas2D.prototype.createRect = function (nodeName, x, y, w, h) {\n  var s = this.state;\n  var n = this.createVmlElement(nodeName);\n  n.style.position = 'absolute';\n  n.style.left = this.format((x + s.dx) * s.scale) + 'px';\n  n.style.top = this.format((y + s.dy) * s.scale) + 'px';\n  n.style.width = this.format(w * s.scale) + 'px';\n  n.style.height = this.format(h * s.scale) + 'px';\n  return n;\n};\n\n/**\r\n * Function: rect\r\n *\r\n * Sets the current path to a rectangle.\r\n */\nmxVmlCanvas2D.prototype.rect = function (x, y, w, h) {\n  this.node = this.createRect('rect', x, y, w, h);\n};\n\n/**\r\n * Function: roundrect\r\n *\r\n * Sets the current path to a rounded rectangle.\r\n */\nmxVmlCanvas2D.prototype.roundrect = function (x, y, w, h, dx, dy) {\n  this.node = this.createRect('roundrect', x, y, w, h);\n  // SetAttribute needed here for IE8\n  this.node.setAttribute('arcsize', Math.max(dx * 100 / w, dy * 100 / h) + '%');\n};\n\n/**\r\n * Function: ellipse\r\n *\r\n * Sets the current path to an ellipse.\r\n */\nmxVmlCanvas2D.prototype.ellipse = function (x, y, w, h) {\n  this.node = this.createRect('oval', x, y, w, h);\n};\n\n/**\r\n * Function: image\r\n *\r\n * Paints an image.\r\n */\nmxVmlCanvas2D.prototype.image = function (x, y, w, h, src, aspect, flipH, flipV) {\n  var node = null;\n  if (!aspect) {\n    node = this.createRect('image', x, y, w, h);\n    node.src = src;\n  } else {\n    // Uses fill with aspect to avoid asynchronous update of size\n    node = this.createRect('rect', x, y, w, h);\n    node.stroked = 'false';\n\n    // Handles image aspect via fill\n    var fill = this.createVmlElement('fill');\n    fill.aspect = 'atmost';\n    fill.rotate = 'true';\n    fill.type = 'frame';\n    fill.src = src;\n    node.appendChild(fill);\n  }\n  if (flipH && flipV) {\n    node.style.rotation = '180';\n  } else if (flipH) {\n    node.style.flip = 'x';\n  } else if (flipV) {\n    node.style.flip = 'y';\n  }\n  if (this.state.alpha < 1 || this.state.fillAlpha < 1) {\n    // KNOWN: Borders around transparent images in IE<9. Using fill.opacity\n    // fixes this problem by adding a white background in all IE versions.\n    node.style.filter += 'alpha(opacity=' + this.state.alpha * this.state.fillAlpha * 100 + ')';\n  }\n  this.root.appendChild(node);\n};\n\n/**\r\n * Function: createText\r\n *\r\n * Creates the innermost element that contains the HTML text.\r\n */\nmxVmlCanvas2D.prototype.createDiv = function (str, align, valign, overflow) {\n  var div = this.createElement('div');\n  var state = this.state;\n  var css = '';\n  if (state.fontBackgroundColor != null) {\n    css += 'background-color:' + state.fontBackgroundColor + ';';\n  }\n  if (state.fontBorderColor != null) {\n    css += 'border:1px solid ' + state.fontBorderColor + ';';\n  }\n  if (_mxGraphUtils[\"default\"].isNode(str)) {\n    div.appendChild(str);\n  } else {\n    if (overflow != 'fill' && overflow != 'width') {\n      var div2 = this.createElement('div');\n      div2.style.cssText = css;\n      div2.style.display = mxClient.IS_QUIRKS ? 'inline' : 'inline-block';\n      div2.style.zoom = '1';\n      div2.style.textDecoration = 'inherit';\n      div2.innerHTML = str;\n      div.appendChild(div2);\n    } else {\n      div.style.cssText = css;\n      div.innerHTML = str;\n    }\n  }\n  var style = div.style;\n  style.fontSize = state.fontSize / this.vmlScale + 'px';\n  style.fontFamily = state.fontFamily;\n  style.color = state.fontColor;\n  style.verticalAlign = 'top';\n  style.textAlign = align || 'left';\n  style.lineHeight = mxConstants.ABSOLUTE_LINE_HEIGHT ? state.fontSize * mxConstants.LINE_HEIGHT / this.vmlScale + 'px' : mxConstants.LINE_HEIGHT;\n  if ((state.fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD) {\n    style.fontWeight = 'bold';\n  }\n  if ((state.fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC) {\n    style.fontStyle = 'italic';\n  }\n  if ((state.fontStyle & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE) {\n    style.textDecoration = 'underline';\n  }\n  return div;\n};\n\n/**\r\n * Function: text\r\n *\r\n * Paints the given text. Possible values for format are empty string for plain\r\n * text and html for HTML markup. Clipping, text background and border are not\r\n * supported for plain text in VML.\r\n */\nmxVmlCanvas2D.prototype.text = function (x, y, w, h, str, align, valign, wrap, format, overflow, clip, rotation, dir) {\n  if (this.textEnabled && str != null) {\n    var s = this.state;\n    if (format == 'html') {\n      if (s.rotation != null) {\n        var pt = this.rotatePoint(x, y, s.rotation, s.rotationCx, s.rotationCy);\n        x = pt.x;\n        y = pt.y;\n      }\n      if (document.documentMode == 8 && !mxClient.IS_EM) {\n        x += s.dx;\n        y += s.dy;\n\n        // Workaround for rendering offsets\n        if (overflow != 'fill' && valign == mxConstants.ALIGN_TOP) {\n          y -= 1;\n        }\n      } else {\n        x *= s.scale;\n        y *= s.scale;\n      }\n\n      // Adds event transparency in IE8 standards without the transparent background\n      // filter which cannot be used due to bugs in the zoomed bounding box (too slow)\n      // FIXME: No event transparency if inside v:rect (ie part of shape)\n      // KNOWN: Offset wrong for rotated text with word that are longer than the wrapping\n      // width in IE8 because real width of text cannot be determined here.\n      // This should be fixed in mxText.updateBoundingBox by calling before this and\n      // passing the real width to this method if not clipped and wrapped.\n      var abs = document.documentMode == 8 && !mxClient.IS_EM ? this.createVmlElement('group') : this.createElement('div');\n      abs.style.position = 'absolute';\n      abs.style.display = 'inline';\n      abs.style.left = this.format(x) + 'px';\n      abs.style.top = this.format(y) + 'px';\n      abs.style.zoom = s.scale;\n      var box = this.createElement('div');\n      box.style.position = 'relative';\n      box.style.display = 'inline';\n      var margin = _mxGraphUtils[\"default\"].getAlignmentAsPoint(align, valign, _mxPoint[\"default\"]);\n      var dx = margin.x;\n      var dy = margin.y;\n      var div = this.createDiv(str, align, valign, overflow);\n      var inner = this.createElement('div');\n      if (dir != null) {\n        div.setAttribute('dir', dir);\n      }\n      if (wrap && w > 0) {\n        if (!clip) {\n          div.style.width = Math.round(w) + 'px';\n        }\n        div.style.wordWrap = mxConstants.WORD_WRAP;\n        div.style.whiteSpace = 'normal';\n\n        // LATER: Check if other cases need to be handled\n        if (div.style.wordWrap == 'break-word') {\n          var tmp = div;\n          if (tmp.firstChild != null && tmp.firstChild.nodeName == 'DIV') {\n            tmp.firstChild.style.width = '100%';\n          }\n        }\n      } else {\n        div.style.whiteSpace = 'nowrap';\n      }\n      var rot = s.rotation + (rotation || 0);\n      if (this.rotateHtml && rot != 0) {\n        inner.style.display = 'inline';\n        inner.style.zoom = '1';\n        inner.appendChild(div);\n\n        // Box not needed for rendering in IE8 standards\n        if (document.documentMode == 8 && !mxClient.IS_EM && this.root.nodeName != 'DIV') {\n          box.appendChild(inner);\n          abs.appendChild(box);\n        } else {\n          abs.appendChild(inner);\n        }\n      } else if (document.documentMode == 8 && !mxClient.IS_EM) {\n        box.appendChild(div);\n        abs.appendChild(box);\n      } else {\n        div.style.display = 'inline';\n        abs.appendChild(div);\n      }\n\n      // Inserts the node into the DOM\n      if (this.root.nodeName != 'DIV') {\n        // Rectangle to fix position in group\n        var rect = this.createVmlElement('rect');\n        rect.stroked = 'false';\n        rect.filled = 'false';\n        rect.appendChild(abs);\n        this.root.appendChild(rect);\n      } else {\n        this.root.appendChild(abs);\n      }\n      if (clip) {\n        div.style.overflow = 'hidden';\n        div.style.width = Math.round(w) + 'px';\n        if (!mxClient.IS_QUIRKS) {\n          div.style.maxHeight = Math.round(h) + 'px';\n        }\n      } else if (overflow == 'fill') {\n        // KNOWN: Affects horizontal alignment in quirks\n        // but fill should only be used with align=left\n        div.style.overflow = 'hidden';\n        div.style.width = Math.max(0, w) + 1 + 'px';\n        div.style.height = Math.max(0, h) + 1 + 'px';\n      } else if (overflow == 'width') {\n        // KNOWN: Affects horizontal alignment in quirks\n        // but fill should only be used with align=left\n        div.style.overflow = 'hidden';\n        div.style.width = Math.max(0, w) + 1 + 'px';\n        div.style.maxHeight = Math.max(0, h) + 1 + 'px';\n      }\n      if (this.rotateHtml && rot != 0) {\n        var rad = rot * (Math.PI / 180);\n\n        // Precalculate cos and sin for the rotation\n        var real_cos = parseFloat(parseFloat(Math.cos(rad)).toFixed(8));\n        var real_sin = parseFloat(parseFloat(Math.sin(-rad)).toFixed(8));\n        rad %= 2 * Math.PI;\n        if (rad < 0) rad += 2 * Math.PI;\n        rad %= Math.PI;\n        if (rad > Math.PI / 2) rad = Math.PI - rad;\n        var cos = Math.cos(rad);\n        var sin = Math.sin(rad);\n\n        // Adds div to document to measure size\n        if (document.documentMode == 8 && !mxClient.IS_EM) {\n          div.style.display = 'inline-block';\n          inner.style.display = 'inline-block';\n          box.style.display = 'inline-block';\n        }\n        div.style.visibility = 'hidden';\n        div.style.position = 'absolute';\n        document.body.appendChild(div);\n        var sizeDiv = div;\n        if (sizeDiv.firstChild != null && sizeDiv.firstChild.nodeName == 'DIV') {\n          sizeDiv = sizeDiv.firstChild;\n        }\n        var tmp = sizeDiv.offsetWidth + 3;\n        var oh = sizeDiv.offsetHeight;\n        if (clip) {\n          w = Math.min(w, tmp);\n          oh = Math.min(oh, h);\n        } else {\n          w = tmp;\n        }\n\n        // Handles words that are longer than the given wrapping width\n        if (wrap) {\n          div.style.width = w + 'px';\n        }\n\n        // Simulates max-height in quirks\n        if (mxClient.IS_QUIRKS && (clip || overflow == 'width') && oh > h) {\n          oh = h;\n\n          // Quirks does not support maxHeight\n          div.style.height = oh + 'px';\n        }\n        h = oh;\n        var top_fix = (h - h * cos + w * -sin) / 2 - real_sin * w * (dx + 0.5) + real_cos * h * (dy + 0.5);\n        var left_fix = (w - w * cos + h * -sin) / 2 + real_cos * w * (dx + 0.5) + real_sin * h * (dy + 0.5);\n        if (abs.nodeName == 'group' && this.root.nodeName == 'DIV') {\n          // Workaround for bug where group gets moved away if left and top are non-zero in IE8 standards\n          var pos = this.createElement('div');\n          pos.style.display = 'inline-block';\n          pos.style.position = 'absolute';\n          pos.style.left = this.format(x + (left_fix - w / 2) * s.scale) + 'px';\n          pos.style.top = this.format(y + (top_fix - h / 2) * s.scale) + 'px';\n          abs.parentNode.appendChild(pos);\n          pos.appendChild(abs);\n        } else {\n          var sc = document.documentMode == 8 && !mxClient.IS_EM ? 1 : s.scale;\n          abs.style.left = this.format(x + (left_fix - w / 2) * sc) + 'px';\n          abs.style.top = this.format(y + (top_fix - h / 2) * sc) + 'px';\n        }\n\n        // KNOWN: Rotated text rendering quality is bad for IE9 quirks\n        inner.style.filter = \"progid:DXImageTransform.Microsoft.Matrix(M11=\" + real_cos + \", M12=\" + real_sin + \", M21=\" + -real_sin + \", M22=\" + real_cos + \", sizingMethod='auto expand')\";\n        inner.style.backgroundColor = this.rotatedHtmlBackground;\n        if (this.state.alpha < 1) {\n          inner.style.filter += 'alpha(opacity=' + this.state.alpha * 100 + ')';\n        }\n\n        // Restore parent node for DIV\n        inner.appendChild(div);\n        div.style.position = '';\n        div.style.visibility = '';\n      } else if (document.documentMode != 8 || mxClient.IS_EM) {\n        div.style.verticalAlign = 'top';\n        if (this.state.alpha < 1) {\n          abs.style.filter = 'alpha(opacity=' + this.state.alpha * 100 + ')';\n        }\n\n        // Adds div to document to measure size\n        var divParent = div.parentNode;\n        div.style.visibility = 'hidden';\n        document.body.appendChild(div);\n        w = div.offsetWidth;\n        var oh = div.offsetHeight;\n\n        // Simulates max-height in quirks\n        if (mxClient.IS_QUIRKS && clip && oh > h) {\n          oh = h;\n\n          // Quirks does not support maxHeight\n          div.style.height = oh + 'px';\n        }\n        h = oh;\n        div.style.visibility = '';\n        divParent.appendChild(div);\n        abs.style.left = this.format(x + w * dx * this.state.scale) + 'px';\n        abs.style.top = this.format(y + h * dy * this.state.scale) + 'px';\n      } else {\n        if (this.state.alpha < 1) {\n          div.style.filter = 'alpha(opacity=' + this.state.alpha * 100 + ')';\n        }\n\n        // Faster rendering in IE8 without offsetWidth/Height\n        box.style.left = dx * 100 + '%';\n        box.style.top = dy * 100 + '%';\n      }\n    } else {\n      this.plainText(x, y, w, h, _mxGraphUtils[\"default\"].htmlEntities(str, false), align, valign, wrap, format, overflow, clip, rotation, dir);\n    }\n  }\n};\n\n/**\r\n * Function: plainText\r\n *\r\n * Paints the outline of the current path.\r\n */\nmxVmlCanvas2D.prototype.plainText = function (x, y, w, h, str, align, valign, wrap, format, overflow, clip, rotation, dir) {\n  // TextDirection is ignored since this code is not used (format is always HTML in the text function)\n  var s = this.state;\n  x = (x + s.dx) * s.scale;\n  y = (y + s.dy) * s.scale;\n  var node = this.createVmlElement('shape');\n  node.style.width = '1px';\n  node.style.height = '1px';\n  node.stroked = 'false';\n  var fill = this.createVmlElement('fill');\n  fill.color = s.fontColor;\n  fill.opacity = s.alpha * 100 + '%';\n  node.appendChild(fill);\n  var path = this.createVmlElement('path');\n  path.textpathok = 'true';\n  path.v = 'm ' + this.format(0) + ' ' + this.format(0) + ' l ' + this.format(1) + ' ' + this.format(0);\n  node.appendChild(path);\n\n  // KNOWN: Font family and text decoration ignored\n  var tp = this.createVmlElement('textpath');\n  tp.style.cssText = 'v-text-align:' + align;\n  tp.style.align = align;\n  tp.style.fontFamily = s.fontFamily;\n  tp.string = str;\n  tp.on = 'true';\n\n  // Scale via fontsize instead of node.style.zoom for correct offsets in IE8\n  var size = s.fontSize * s.scale / this.vmlScale;\n  tp.style.fontSize = size + 'px';\n\n  // Bold\n  if ((s.fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD) {\n    tp.style.fontWeight = 'bold';\n  }\n\n  // Italic\n  if ((s.fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC) {\n    tp.style.fontStyle = 'italic';\n  }\n\n  // Underline\n  if ((s.fontStyle & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE) {\n    tp.style.textDecoration = 'underline';\n  }\n  var lines = str.split('\\n');\n  var textHeight = size + (lines.length - 1) * size * mxConstants.LINE_HEIGHT;\n  var dx = 0;\n  var dy = 0;\n  if (valign == mxConstants.ALIGN_BOTTOM) {\n    dy = -textHeight / 2;\n  } else if (valign != mxConstants.ALIGN_MIDDLE)\n    // top\n    {\n      dy = textHeight / 2;\n    }\n  if (rotation != null) {\n    node.style.rotation = rotation;\n    var rad = rotation * (Math.PI / 180);\n    dx = Math.sin(rad) * dy;\n    dy = Math.cos(rad) * dy;\n  }\n\n  // FIXME: Clipping is relative to bounding box\n  /*if (clip)\r\n  {\r\n  \tnode.style.clip = 'rect(0px ' + this.format(w) + 'px ' + this.format(h) + 'px 0px)';\r\n  }*/\n\n  node.appendChild(tp);\n  node.style.left = this.format(x - dx) + 'px';\n  node.style.top = this.format(y + dy) + 'px';\n  this.root.appendChild(node);\n};\n\n/**\r\n * Function: stroke\r\n *\r\n * Paints the outline of the current path.\r\n */\nmxVmlCanvas2D.prototype.stroke = function () {\n  this.addNode(false, true);\n};\n\n/**\r\n * Function: fill\r\n *\r\n * Fills the current path.\r\n */\nmxVmlCanvas2D.prototype.fill = function () {\n  this.addNode(true, false);\n};\n\n/**\r\n * Function: fillAndStroke\r\n *\r\n * Fills and paints the outline of the current path.\r\n */\nmxVmlCanvas2D.prototype.fillAndStroke = function () {\n  this.addNode(true, true);\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxGuide\r\n *\r\n * Implements the alignment of selection cells to other cells in the graph.\r\n *\r\n * Constructor: mxGuide\r\n *\r\n * Constructs a new guide object.\r\n */\nvar _default = exports[\"default\"] = mxVmlCanvas2D;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxVmlCanvas2D.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxWindow.js":
/*!*******************************************!*\
  !*** ./src/workflow/mxClient/mxWindow.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.index-of.js */ \"../../node_modules/core-js/modules/es.array.index-of.js\");\n__webpack_require__(/*! core-js/modules/es.function.bind.js */ \"../../node_modules/core-js/modules/es.function.bind.js\");\n__webpack_require__(/*! core-js/modules/es.parse-int.js */ \"../../node_modules/core-js/modules/es.parse-int.js\");\nvar _mxEventObject = _interopRequireDefault(__webpack_require__(/*! ./mxEventObject.js */ \"./src/workflow/mxClient/mxEventObject.js\"));\nvar _mxClient = _interopRequireDefault(__webpack_require__(/*! ./mxClient.js */ \"./src/workflow/mxClient/mxClient.js\"));\nvar _mxEventSource = _interopRequireDefault(__webpack_require__(/*! ./mxEventSource.js */ \"./src/workflow/mxClient/mxEventSource.js\"));\nvar _mxEventUtils = _interopRequireDefault(__webpack_require__(/*! ./mxEventUtils.js */ \"./src/workflow/mxClient/mxEventUtils.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxRectangle = _interopRequireDefault(__webpack_require__(/*! ./mxRectangle.js */ \"./src/workflow/mxClient/mxRectangle.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ./mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxWindow(title, content, x, y, width, height, minimizable, movable, replaceNode, style) {\n  if (content != null) {\n    minimizable = minimizable != null ? minimizable : true;\n    this.content = content;\n    this.init(x, y, width, height, style);\n    this.installMaximizeHandler();\n    this.installMinimizeHandler();\n    this.installCloseHandler();\n    this.setMinimizable(minimizable);\n    this.setTitle(title);\n    if (movable == null || movable) {\n      this.installMoveHandler();\n    }\n    if (replaceNode != null && replaceNode.parentNode != null) {\n      replaceNode.parentNode.replaceChild(this.div, replaceNode);\n    } else {\n      document.body.appendChild(this.div);\n    }\n  }\n}\n;\n\n/**\r\n * Extends mxEventSource.\r\n */\nmxWindow.prototype = new _mxEventSource[\"default\"]();\nmxWindow.prototype.constructor = mxWindow;\n\n/**\r\n * Variable: closeImage\r\n *\r\n * URL of the image to be used for the close icon in the titlebar.\r\n */\nmxWindow.prototype.closeImage = _mxClient[\"default\"].imageBasePath + '/close.gif';\n\n/**\r\n * Variable: minimizeImage\r\n *\r\n * URL of the image to be used for the minimize icon in the titlebar.\r\n */\nmxWindow.prototype.minimizeImage = _mxClient[\"default\"].imageBasePath + '/minimize.gif';\n\n/**\r\n * Variable: normalizeImage\r\n *\r\n * URL of the image to be used for the normalize icon in the titlebar.\r\n */\nmxWindow.prototype.normalizeImage = _mxClient[\"default\"].imageBasePath + '/normalize.gif';\n\n/**\r\n * Variable: maximizeImage\r\n *\r\n * URL of the image to be used for the maximize icon in the titlebar.\r\n */\nmxWindow.prototype.maximizeImage = _mxClient[\"default\"].imageBasePath + '/maximize.gif';\n\n/**\r\n * Variable: normalizeImage\r\n *\r\n * URL of the image to be used for the resize icon.\r\n */\nmxWindow.prototype.resizeImage = _mxClient[\"default\"].imageBasePath + '/resize.gif';\n\n/**\r\n * Variable: visible\r\n *\r\n * Boolean flag that represents the visible state of the window.\r\n */\nmxWindow.prototype.visible = false;\n\n/**\r\n * Variable: minimumSize\r\n *\r\n * <mxRectangle> that specifies the minimum width and height of the window.\r\n * Default is (50, 40).\r\n */\nmxWindow.prototype.minimumSize = new _mxRectangle[\"default\"](0, 0, 50, 40);\n\n/**\r\n * Variable: destroyOnClose\r\n *\r\n * Specifies if the window should be destroyed when it is closed. If this\r\n * is false then the window is hidden using <setVisible>. Default is true.\r\n */\nmxWindow.prototype.destroyOnClose = true;\n\n/**\r\n * Variable: contentHeightCorrection\r\n *\r\n * Defines the correction factor for computing the height of the contentWrapper.\r\n * Default is 6 for IE 7/8 standards mode and 2 for all other browsers and modes.\r\n */\nmxWindow.prototype.contentHeightCorrection = document.documentMode == 8 || document.documentMode == 7 ? 6 : 2;\n\n/**\r\n * Variable: title\r\n *\r\n * Reference to the DOM node (TD) that contains the title.\r\n */\nmxWindow.prototype.title = null;\n\n/**\r\n * Variable: content\r\n *\r\n * Reference to the DOM node that represents the window content.\r\n */\nmxWindow.prototype.content = null;\n\n/**\r\n * Function: init\r\n *\r\n * Initializes the DOM tree that represents the window.\r\n */\nmxWindow.prototype.init = function (x, y, width, height, style) {\n  style = style != null ? style : 'mxWindow';\n  this.div = document.createElement('div');\n  this.div.className = style;\n  this.div.style.left = x + 'px';\n  this.div.style.top = y + 'px';\n  this.table = document.createElement('table');\n  this.table.className = style;\n\n  // Disables built-in pan and zoom in IE10 and later\n  if (_mxClient[\"default\"].IS_POINTER) {\n    this.div.style.touchAction = 'none';\n  }\n\n  // Workaround for table size problems in FF\n  if (width != null) {\n    if (!_mxClient[\"default\"].IS_QUIRKS) {\n      this.div.style.width = width + 'px';\n    }\n    this.table.style.width = width + 'px';\n  }\n  if (height != null) {\n    if (!_mxClient[\"default\"].IS_QUIRKS) {\n      this.div.style.height = height + 'px';\n    }\n    this.table.style.height = height + 'px';\n  }\n\n  // Creates title row\n  var tbody = document.createElement('tbody');\n  var tr = document.createElement('tr');\n  this.title = document.createElement('td');\n  this.title.className = style + 'Title';\n  tr.appendChild(this.title);\n  tbody.appendChild(tr);\n\n  // Creates content row and table cell\n  tr = document.createElement('tr');\n  this.td = document.createElement('td');\n  this.td.className = style + 'Pane';\n  if (document.documentMode == 7) {\n    this.td.style.height = '100%';\n  }\n  this.contentWrapper = document.createElement('div');\n  this.contentWrapper.className = style + 'Pane';\n  this.contentWrapper.style.width = '100%';\n  this.contentWrapper.appendChild(this.content);\n\n  // Workaround for div around div restricts height\n  // of inner div if outerdiv has hidden overflow\n  if (_mxClient[\"default\"].IS_QUIRKS || this.content.nodeName.toUpperCase() != 'DIV') {\n    this.contentWrapper.style.height = '100%';\n  }\n\n  // Puts all content into the DOM\n  this.td.appendChild(this.contentWrapper);\n  tr.appendChild(this.td);\n  tbody.appendChild(tr);\n  this.table.appendChild(tbody);\n  this.div.appendChild(this.table);\n\n  // Puts the window on top of other windows when clicked\n  var activator = _mxGraphUtils[\"default\"].bind(this, function (evt) {\n    this.activate();\n  });\n  _mxEventUtils[\"default\"].addGestureListeners(this.title, activator);\n  _mxEventUtils[\"default\"].addGestureListeners(this.table, activator);\n  this.hide();\n};\n\n/**\r\n * Function: setTitle\r\n *\r\n * Sets the window title to the given string. HTML markup inside the title\r\n * will be escaped.\r\n */\nmxWindow.prototype.setTitle = function (title) {\n  // Removes all text content nodes (normally just one)\n  var child = this.title.firstChild;\n  while (child != null) {\n    var next = child.nextSibling;\n    if (child.nodeType == _mxConstants[\"default\"].NODETYPE_TEXT) {\n      child.parentNode.removeChild(child);\n    }\n    child = next;\n  }\n  _mxGraphUtils[\"default\"].write(this.title, title || '');\n};\n\n/**\r\n * Function: setScrollable\r\n *\r\n * Sets if the window contents should be scrollable.\r\n */\nmxWindow.prototype.setScrollable = function (scrollable) {\n  // Workaround for hang in Presto 2.5.22 (Opera 10.5)\n  if (navigator.userAgent.indexOf('Presto/2.5') < 0) {\n    if (scrollable) {\n      this.contentWrapper.style.overflow = 'auto';\n    } else {\n      this.contentWrapper.style.overflow = 'hidden';\n    }\n  }\n};\n\n/**\r\n * Function: activate\r\n *\r\n * Puts the window on top of all other windows.\r\n */\nmxWindow.prototype.activate = function () {\n  if (mxWindow.activeWindow != this) {\n    var style = _mxGraphUtils[\"default\"].getCurrentStyle(this.getElement());\n    var index = style != null ? style.zIndex : 3;\n    if (mxWindow.activeWindow) {\n      var elt = mxWindow.activeWindow.getElement();\n      if (elt != null && elt.style != null) {\n        elt.style.zIndex = index;\n      }\n    }\n    var previousWindow = mxWindow.activeWindow;\n    this.getElement().style.zIndex = parseInt(index) + 1;\n    mxWindow.activeWindow = this;\n    this.fireEvent(new _mxEventObject[\"default\"](_mxEventUtils[\"default\"].ACTIVATE, 'previousWindow', previousWindow));\n  }\n};\n\n/**\r\n * Function: getElement\r\n *\r\n * Returuns the outermost DOM node that makes up the window.\r\n */\nmxWindow.prototype.getElement = function () {\n  return this.div;\n};\n\n/**\r\n * Function: fit\r\n *\r\n * Makes sure the window is inside the client area of the window.\r\n */\nmxWindow.prototype.fit = function () {\n  _mxGraphUtils[\"default\"].fit(this.div);\n};\n\n/**\r\n * Function: isResizable\r\n *\r\n * Returns true if the window is resizable.\r\n */\nmxWindow.prototype.isResizable = function () {\n  if (this.resize != null) {\n    return this.resize.style.display != 'none';\n  }\n  return false;\n};\n\n/**\r\n * Function: setResizable\r\n *\r\n * Sets if the window should be resizable. To avoid interference with some\r\n * built-in features of IE10 and later, the use of the following code is\r\n * recommended if there are resizable <mxWindow>s in the page:\r\n *\r\n * (code)\r\n * if (mxClient.IS_POINTER)\r\n * {\r\n *   document.body.style.msTouchAction = 'none';\r\n * }\r\n * (end)\r\n */\nmxWindow.prototype.setResizable = function (resizable) {\n  if (resizable) {\n    if (this.resize == null) {\n      this.resize = document.createElement('img');\n      this.resize.style.position = 'absolute';\n      this.resize.style.bottom = '2px';\n      this.resize.style.right = '2px';\n      this.resize.setAttribute('src', _mxClient[\"default\"].imageBasePath + '/resize.gif');\n      this.resize.style.cursor = 'nw-resize';\n      var startX = null;\n      var startY = null;\n      var width = null;\n      var height = null;\n      var start = _mxGraphUtils[\"default\"].bind(this, function (evt) {\n        // LATER: pointerdown starting on border of resize does start\n        // the drag operation but does not fire consecutive events via\n        // one of the listeners below (does pan instead).\n        // Workaround: document.body.style.msTouchAction = 'none'\n        this.activate();\n        startX = _mxEventUtils[\"default\"].getClientX(evt);\n        startY = _mxEventUtils[\"default\"].getClientY(evt);\n        width = this.div.offsetWidth;\n        height = this.div.offsetHeight;\n        _mxEventUtils[\"default\"].addGestureListeners(document, null, dragHandler, dropHandler);\n        this.fireEvent(new _mxEventObject[\"default\"](_mxEventUtils[\"default\"].RESIZE_START, 'event', evt));\n        _mxEventUtils[\"default\"].consume(evt);\n      });\n\n      // Adds a temporary pair of listeners to intercept\n      // the gesture event in the document\n      var dragHandler = _mxGraphUtils[\"default\"].bind(this, function (evt) {\n        if (startX != null && startY != null) {\n          var dx = _mxEventUtils[\"default\"].getClientX(evt) - startX;\n          var dy = _mxEventUtils[\"default\"].getClientY(evt) - startY;\n          this.setSize(width + dx, height + dy);\n          this.fireEvent(new _mxEventObject[\"default\"](_mxEventUtils[\"default\"].RESIZE, 'event', evt));\n          _mxEventUtils[\"default\"].consume(evt);\n        }\n      });\n      var dropHandler = _mxGraphUtils[\"default\"].bind(this, function (evt) {\n        if (startX != null && startY != null) {\n          startX = null;\n          startY = null;\n          _mxEventUtils[\"default\"].removeGestureListeners(document, null, dragHandler, dropHandler);\n          this.fireEvent(new _mxEventObject[\"default\"](_mxEventUtils[\"default\"].RESIZE_END, 'event', evt));\n          _mxEventUtils[\"default\"].consume(evt);\n        }\n      });\n      _mxEventUtils[\"default\"].addGestureListeners(this.resize, start, dragHandler, dropHandler);\n      this.div.appendChild(this.resize);\n    } else {\n      this.resize.style.display = 'inline';\n    }\n  } else if (this.resize != null) {\n    this.resize.style.display = 'none';\n  }\n};\n\n/**\r\n * Function: setSize\r\n *\r\n * Sets the size of the window.\r\n */\nmxWindow.prototype.setSize = function (width, height) {\n  width = Math.max(this.minimumSize.width, width);\n  height = Math.max(this.minimumSize.height, height);\n\n  // Workaround for table size problems in FF\n  if (!_mxClient[\"default\"].IS_QUIRKS) {\n    this.div.style.width = width + 'px';\n    this.div.style.height = height + 'px';\n  }\n  this.table.style.width = width + 'px';\n  this.table.style.height = height + 'px';\n  if (!_mxClient[\"default\"].IS_QUIRKS) {\n    this.contentWrapper.style.height = this.div.offsetHeight - this.title.offsetHeight - this.contentHeightCorrection + 'px';\n  }\n};\n\n/**\r\n * Function: setMinimizable\r\n *\r\n * Sets if the window is minimizable.\r\n */\nmxWindow.prototype.setMinimizable = function (minimizable) {\n  this.minimize.style.display = minimizable ? '' : 'none';\n};\n\n/**\r\n * Function: getMinimumSize\r\n *\r\n * Returns an <mxRectangle> that specifies the size for the minimized window.\r\n * A width or height of 0 means keep the existing width or height. This\r\n * implementation returns the height of the window title and keeps the width.\r\n */\nmxWindow.prototype.getMinimumSize = function () {\n  return new _mxRectangle[\"default\"](0, 0, 0, this.title.offsetHeight);\n};\n\n/**\r\n * Function: installMinimizeHandler\r\n *\r\n * Installs the event listeners required for minimizing the window.\r\n */\nmxWindow.prototype.installMinimizeHandler = function () {\n  this.minimize = document.createElement('img');\n  this.minimize.setAttribute('src', this.minimizeImage);\n  this.minimize.setAttribute('align', 'right');\n  this.minimize.setAttribute('title', 'Minimize');\n  this.minimize.style.cursor = 'pointer';\n  this.minimize.style.marginRight = '1px';\n  this.minimize.style.display = 'none';\n  this.title.appendChild(this.minimize);\n  var minimized = false;\n  var maxDisplay = null;\n  var height = null;\n  var funct = _mxGraphUtils[\"default\"].bind(this, function (evt) {\n    this.activate();\n    if (!minimized) {\n      minimized = true;\n      this.minimize.setAttribute('src', this.normalizeImage);\n      this.minimize.setAttribute('title', 'Normalize');\n      this.contentWrapper.style.display = 'none';\n      maxDisplay = this.maximize.style.display;\n      this.maximize.style.display = 'none';\n      height = this.table.style.height;\n      var minSize = this.getMinimumSize();\n      if (minSize.height > 0) {\n        if (!_mxClient[\"default\"].IS_QUIRKS) {\n          this.div.style.height = minSize.height + 'px';\n        }\n        this.table.style.height = minSize.height + 'px';\n      }\n      if (minSize.width > 0) {\n        if (!_mxClient[\"default\"].IS_QUIRKS) {\n          this.div.style.width = minSize.width + 'px';\n        }\n        this.table.style.width = minSize.width + 'px';\n      }\n      if (this.resize != null) {\n        this.resize.style.visibility = 'hidden';\n      }\n      this.fireEvent(new _mxEventObject[\"default\"](_mxEventUtils[\"default\"].MINIMIZE, 'event', evt));\n    } else {\n      minimized = false;\n      this.minimize.setAttribute('src', this.minimizeImage);\n      this.minimize.setAttribute('title', 'Minimize');\n      this.contentWrapper.style.display = ''; // default\n      this.maximize.style.display = maxDisplay;\n      if (!_mxClient[\"default\"].IS_QUIRKS) {\n        this.div.style.height = height;\n      }\n      this.table.style.height = height;\n      if (this.resize != null) {\n        this.resize.style.visibility = '';\n      }\n      this.fireEvent(new _mxEventObject[\"default\"](_mxEventUtils[\"default\"].NORMALIZE, 'event', evt));\n    }\n    _mxEventUtils[\"default\"].consume(evt);\n  });\n  _mxEventUtils[\"default\"].addGestureListeners(this.minimize, funct);\n};\n\n/**\r\n * Function: setMaximizable\r\n *\r\n * Sets if the window is maximizable.\r\n */\nmxWindow.prototype.setMaximizable = function (maximizable) {\n  this.maximize.style.display = maximizable ? '' : 'none';\n};\n\n/**\r\n * Function: installMaximizeHandler\r\n *\r\n * Installs the event listeners required for maximizing the window.\r\n */\nmxWindow.prototype.installMaximizeHandler = function () {\n  this.maximize = document.createElement('img');\n  this.maximize.setAttribute('src', this.maximizeImage);\n  this.maximize.setAttribute('align', 'right');\n  this.maximize.setAttribute('title', 'Maximize');\n  this.maximize.style.cursor = 'default';\n  this.maximize.style.marginLeft = '1px';\n  this.maximize.style.cursor = 'pointer';\n  this.maximize.style.display = 'none';\n  this.title.appendChild(this.maximize);\n  var maximized = false;\n  var x = null;\n  var y = null;\n  var height = null;\n  var width = null;\n  var funct = _mxGraphUtils[\"default\"].bind(this, function (evt) {\n    this.activate();\n    if (this.maximize.style.display != 'none') {\n      if (!maximized) {\n        maximized = true;\n        this.maximize.setAttribute('src', this.normalizeImage);\n        this.maximize.setAttribute('title', 'Normalize');\n        this.contentWrapper.style.display = '';\n        this.minimize.style.visibility = 'hidden';\n\n        // Saves window state\n        x = parseInt(this.div.style.left);\n        y = parseInt(this.div.style.top);\n        height = this.table.style.height;\n        width = this.table.style.width;\n        this.div.style.left = '0px';\n        this.div.style.top = '0px';\n        var docHeight = Math.max(document.body.clientHeight || 0, document.documentElement.clientHeight || 0);\n        if (!_mxClient[\"default\"].IS_QUIRKS) {\n          this.div.style.width = document.body.clientWidth - 2 + 'px';\n          this.div.style.height = docHeight - 2 + 'px';\n        }\n        this.table.style.width = document.body.clientWidth - 2 + 'px';\n        this.table.style.height = docHeight - 2 + 'px';\n        if (this.resize != null) {\n          this.resize.style.visibility = 'hidden';\n        }\n        if (!_mxClient[\"default\"].IS_QUIRKS) {\n          var style = _mxGraphUtils[\"default\"].getCurrentStyle(this.contentWrapper);\n          if (style.overflow == 'auto' || this.resize != null) {\n            this.contentWrapper.style.height = this.div.offsetHeight - this.title.offsetHeight - this.contentHeightCorrection + 'px';\n          }\n        }\n        this.fireEvent(new _mxEventObject[\"default\"](_mxEventUtils[\"default\"].MAXIMIZE, 'event', evt));\n      } else {\n        maximized = false;\n        this.maximize.setAttribute('src', this.maximizeImage);\n        this.maximize.setAttribute('title', 'Maximize');\n        this.contentWrapper.style.display = '';\n        this.minimize.style.visibility = '';\n\n        // Restores window state\n        this.div.style.left = x + 'px';\n        this.div.style.top = y + 'px';\n        if (!_mxClient[\"default\"].IS_QUIRKS) {\n          this.div.style.height = height;\n          this.div.style.width = width;\n          var style = _mxGraphUtils[\"default\"].getCurrentStyle(this.contentWrapper);\n          if (style.overflow == 'auto' || this.resize != null) {\n            this.contentWrapper.style.height = this.div.offsetHeight - this.title.offsetHeight - this.contentHeightCorrection + 'px';\n          }\n        }\n        this.table.style.height = height;\n        this.table.style.width = width;\n        if (this.resize != null) {\n          this.resize.style.visibility = '';\n        }\n        this.fireEvent(new _mxEventObject[\"default\"](_mxEventUtils[\"default\"].NORMALIZE, 'event', evt));\n      }\n      _mxEventUtils[\"default\"].consume(evt);\n    }\n  });\n  _mxEventUtils[\"default\"].addGestureListeners(this.maximize, funct);\n  _mxEventUtils[\"default\"].addListener(this.title, 'dblclick', funct);\n};\n\n/**\r\n * Function: installMoveHandler\r\n *\r\n * Installs the event listeners required for moving the window.\r\n */\nmxWindow.prototype.installMoveHandler = function () {\n  this.title.style.cursor = 'move';\n  _mxEventUtils[\"default\"].addGestureListeners(this.title, _mxGraphUtils[\"default\"].bind(this, function (evt) {\n    var startX = mxGraphUtilsgetClientX(evt);\n    var startY = _mxEventUtils[\"default\"].getClientY(evt);\n    var x = this.getX();\n    var y = this.getY();\n\n    // Adds a temporary pair of listeners to intercept\n    // the gesture event in the document\n    var dragHandler = _mxGraphUtils[\"default\"].bind(this, function (evt) {\n      var dx = _mxEventUtils[\"default\"].getClientX(evt) - startX;\n      var dy = _mxEventUtils[\"default\"].getClientY(evt) - startY;\n      this.setLocation(x + dx, y + dy);\n      this.fireEvent(new _mxEventObject[\"default\"](_mxEventUtils[\"default\"].MOVE, 'event', evt));\n      _mxEventUtils[\"default\"].consume(evt);\n    });\n    var dropHandler = _mxGraphUtils[\"default\"].bind(this, function (evt) {\n      _mxEventUtils[\"default\"].removeGestureListeners(document, null, dragHandler, dropHandler);\n      this.fireEvent(new _mxEventObject[\"default\"](_mxEventUtils[\"default\"].MOVE_END, 'event', evt));\n      _mxEventUtils[\"default\"].consume(evt);\n    });\n    _mxEventUtils[\"default\"].addGestureListeners(document, null, dragHandler, dropHandler);\n    this.fireEvent(new _mxEventObject[\"default\"](_mxEventUtils[\"default\"].MOVE_START, 'event', evt));\n    _mxEventUtils[\"default\"].consume(evt);\n  }));\n\n  // Disables built-in pan and zoom in IE10 and later\n  if (_mxClient[\"default\"].IS_POINTER) {\n    this.title.style.touchAction = 'none';\n  }\n};\n\n/**\r\n * Function: setLocation\r\n *\r\n * Sets the upper, left corner of the window.\r\n */\nmxWindow.prototype.setLocation = function (x, y) {\n  this.div.style.left = x + 'px';\n  this.div.style.top = y + 'px';\n};\n\n/**\r\n * Function: getX\r\n *\r\n * Returns the current position on the x-axis.\r\n */\nmxWindow.prototype.getX = function () {\n  return parseInt(this.div.style.left);\n};\n\n/**\r\n * Function: getY\r\n *\r\n * Returns the current position on the y-axis.\r\n */\nmxWindow.prototype.getY = function () {\n  return parseInt(this.div.style.top);\n};\n\n/**\r\n * Function: installCloseHandler\r\n *\r\n * Adds the <closeImage> as a new image node in <closeImg> and installs the\r\n * <close> event.\r\n */\nmxWindow.prototype.installCloseHandler = function () {\n  this.closeImg = document.createElement('img');\n  this.closeImg.setAttribute('src', this.closeImage);\n  this.closeImg.setAttribute('align', 'right');\n  this.closeImg.setAttribute('title', 'Close');\n  this.closeImg.style.marginLeft = '2px';\n  this.closeImg.style.cursor = 'pointer';\n  this.closeImg.style.display = 'none';\n  this.title.insertBefore(this.closeImg, this.title.firstChild);\n  _mxEventUtils[\"default\"].addGestureListeners(this.closeImg, _mxGraphUtils[\"default\"].bind(this, function (evt) {\n    this.fireEvent(new _mxEventObject[\"default\"](_mxEventUtils[\"default\"].CLOSE, 'event', evt));\n    if (this.destroyOnClose) {\n      this.destroy();\n    } else {\n      this.setVisible(false);\n    }\n    _mxEventUtils[\"default\"].consume(evt);\n  }));\n};\n\n/**\r\n * Function: setImage\r\n *\r\n * Sets the image associated with the window.\r\n *\r\n * Parameters:\r\n *\r\n * image - URL of the image to be used.\r\n */\nmxWindow.prototype.setImage = function (image) {\n  this.image = document.createElement('img');\n  this.image.setAttribute('src', image);\n  this.image.setAttribute('align', 'left');\n  this.image.style.marginRight = '4px';\n  this.image.style.marginLeft = '0px';\n  this.image.style.marginTop = '-2px';\n  this.title.insertBefore(this.image, this.title.firstChild);\n};\n\n/**\r\n * Function: setClosable\r\n *\r\n * Sets the image associated with the window.\r\n *\r\n * Parameters:\r\n *\r\n * closable - Boolean specifying if the window should be closable.\r\n */\nmxWindow.prototype.setClosable = function (closable) {\n  this.closeImg.style.display = closable ? '' : 'none';\n};\n\n/**\r\n * Function: isVisible\r\n *\r\n * Returns true if the window is visible.\r\n */\nmxWindow.prototype.isVisible = function () {\n  if (this.div != null) {\n    return this.div.style.display != 'none';\n  }\n  return false;\n};\n\n/**\r\n * Function: setVisible\r\n *\r\n * Shows or hides the window depending on the given flag.\r\n *\r\n * Parameters:\r\n *\r\n * visible - Boolean indicating if the window should be made visible.\r\n */\nmxWindow.prototype.setVisible = function (visible) {\n  if (this.div != null && this.isVisible() != visible) {\n    if (visible) {\n      this.show();\n    } else {\n      this.hide();\n    }\n  }\n};\n\n/**\r\n * Function: show\r\n *\r\n * Shows the window.\r\n */\nmxWindow.prototype.show = function () {\n  this.div.style.display = '';\n  this.activate();\n  var style = _mxGraphUtils[\"default\"].getCurrentStyle(this.contentWrapper);\n  if (!_mxClient[\"default\"].IS_QUIRKS && (style.overflow == 'auto' || this.resize != null)) {\n    this.contentWrapper.style.height = this.div.offsetHeight - this.title.offsetHeight - this.contentHeightCorrection + 'px';\n  }\n  this.fireEvent(new _mxEventObject[\"default\"](_mxEventUtils[\"default\"].SHOW));\n};\n\n/**\r\n * Function: hide\r\n *\r\n * Hides the window.\r\n */\nmxWindow.prototype.hide = function () {\n  this.div.style.display = 'none';\n  this.fireEvent(new _mxEventObject[\"default\"](_mxEventUtils[\"default\"].HIDE));\n};\n\n/**\r\n * Function: destroy\r\n *\r\n * Destroys the window and removes all associated resources. Fires a\r\n * <destroy> event prior to destroying the window.\r\n */\nmxWindow.prototype.destroy = function () {\n  this.fireEvent(new _mxEventObject[\"default\"](_mxEventUtils[\"default\"].DESTROY));\n  if (this.div != null) {\n    _mxEventUtils[\"default\"].release(this.div);\n    this.div.parentNode.removeChild(this.div);\n    this.div = null;\n  }\n  this.title = null;\n  this.content = null;\n  this.contentWrapper = null;\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxForm\r\n *\r\n * A simple class for creating HTML forms.\r\n *\r\n * Constructor: mxForm\r\n *\r\n * Creates a HTML table using the specified classname.\r\n */\nvar _default = exports[\"default\"] = mxWindow;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxWindow.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxXmlCanvas2D.js":
/*!************************************************!*\
  !*** ./src/workflow/mxClient/mxXmlCanvas2D.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.fill.js */ \"../../node_modules/core-js/modules/es.array.fill.js\");\n__webpack_require__(/*! core-js/modules/es.number.to-fixed.js */ \"../../node_modules/core-js/modules/es.number.to-fixed.js\");\n__webpack_require__(/*! core-js/modules/es.parse-float.js */ \"../../node_modules/core-js/modules/es.parse-float.js\");\nvar _mxAbstractCanvas2D = _interopRequireDefault(__webpack_require__(/*! ./mxAbstractCanvas2D.js */ \"./src/workflow/mxClient/mxAbstractCanvas2D.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ./mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxXmlCanvas2D(root) {\n  _mxAbstractCanvas2D[\"default\"].call(this);\n\n  /**\r\n   * Variable: root\r\n   *\r\n   * Reference to the container for the SVG content.\r\n   */\n  this.root = root;\n\n  // Writes default settings;\n  this.writeDefaults();\n}\n;\n\n/**\r\n * Extends mxAbstractCanvas2D\r\n */\n_mxGraphUtils[\"default\"].extend(mxXmlCanvas2D, _mxAbstractCanvas2D[\"default\"]);\n\n/**\r\n * Variable: textEnabled\r\n *\r\n * Specifies if text output should be enabled. Default is true.\r\n */\nmxXmlCanvas2D.prototype.textEnabled = true;\n\n/**\r\n * Variable: compressed\r\n *\r\n * Specifies if the output should be compressed by removing redundant calls.\r\n * Default is true.\r\n */\nmxXmlCanvas2D.prototype.compressed = true;\n\n/**\r\n * Function: writeDefaults\r\n *\r\n * Writes the rendering defaults to <root>:\r\n */\nmxXmlCanvas2D.prototype.writeDefaults = function () {\n  var elem;\n\n  // Writes font defaults\n  elem = this.createElement('fontfamily');\n  elem.setAttribute('family', _mxConstants[\"default\"].DEFAULT_FONTFAMILY);\n  this.root.appendChild(elem);\n  elem = this.createElement('fontsize');\n  elem.setAttribute('size', _mxConstants[\"default\"].DEFAULT_FONTSIZE);\n  this.root.appendChild(elem);\n\n  // Writes shadow defaults\n  elem = this.createElement('shadowcolor');\n  elem.setAttribute('color', _mxConstants[\"default\"].SHADOWCOLOR);\n  this.root.appendChild(elem);\n  elem = this.createElement('shadowalpha');\n  elem.setAttribute('alpha', _mxConstants[\"default\"].SHADOW_OPACITY);\n  this.root.appendChild(elem);\n  elem = this.createElement('shadowoffset');\n  elem.setAttribute('dx', _mxConstants[\"default\"].SHADOW_OFFSET_X);\n  elem.setAttribute('dy', _mxConstants[\"default\"].SHADOW_OFFSET_Y);\n  this.root.appendChild(elem);\n};\n\n/**\r\n * Function: format\r\n *\r\n * Returns a formatted number with 2 decimal places.\r\n */\nmxXmlCanvas2D.prototype.format = function (value) {\n  return parseFloat(parseFloat(value).toFixed(2));\n};\n\n/**\r\n * Function: createElement\r\n *\r\n * Creates the given element using the owner document of <root>.\r\n */\nmxXmlCanvas2D.prototype.createElement = function (name) {\n  return this.root.ownerDocument.createElement(name);\n};\n\n/**\r\n * Function: save\r\n *\r\n * Saves the drawing state.\r\n */\nmxXmlCanvas2D.prototype.save = function () {\n  if (this.compressed) {\n    _mxAbstractCanvas2D[\"default\"].prototype.save.apply(this, arguments);\n  }\n  this.root.appendChild(this.createElement('save'));\n};\n\n/**\r\n * Function: restore\r\n *\r\n * Restores the drawing state.\r\n */\nmxXmlCanvas2D.prototype.restore = function () {\n  if (this.compressed) {\n    _mxAbstractCanvas2D[\"default\"].prototype.restore.apply(this, arguments);\n  }\n  this.root.appendChild(this.createElement('restore'));\n};\n\n/**\r\n * Function: scale\r\n *\r\n * Scales the output.\r\n *\r\n * Parameters:\r\n *\r\n * scale - Number that represents the scale where 1 is equal to 100%.\r\n */\nmxXmlCanvas2D.prototype.scale = function (value) {\n  var elem = this.createElement('scale');\n  elem.setAttribute('scale', value);\n  this.root.appendChild(elem);\n};\n\n/**\r\n * Function: translate\r\n *\r\n * Translates the output.\r\n *\r\n * Parameters:\r\n *\r\n * dx - Number that specifies the horizontal translation.\r\n * dy - Number that specifies the vertical translation.\r\n */\nmxXmlCanvas2D.prototype.translate = function (dx, dy) {\n  var elem = this.createElement('translate');\n  elem.setAttribute('dx', this.format(dx));\n  elem.setAttribute('dy', this.format(dy));\n  this.root.appendChild(elem);\n};\n\n/**\r\n * Function: rotate\r\n *\r\n * Rotates and/or flips the output around a given center. (Note: Due to\r\n * limitations in VML, the rotation cannot be concatenated.)\r\n *\r\n * Parameters:\r\n *\r\n * theta - Number that represents the angle of the rotation (in degrees).\r\n * flipH - Boolean indicating if the output should be flipped horizontally.\r\n * flipV - Boolean indicating if the output should be flipped vertically.\r\n * cx - Number that represents the x-coordinate of the rotation center.\r\n * cy - Number that represents the y-coordinate of the rotation center.\r\n */\nmxXmlCanvas2D.prototype.rotate = function (theta, flipH, flipV, cx, cy) {\n  var elem = this.createElement('rotate');\n  if (theta != 0 || flipH || flipV) {\n    elem.setAttribute('theta', this.format(theta));\n    elem.setAttribute('flipH', flipH ? '1' : '0');\n    elem.setAttribute('flipV', flipV ? '1' : '0');\n    elem.setAttribute('cx', this.format(cx));\n    elem.setAttribute('cy', this.format(cy));\n    this.root.appendChild(elem);\n  }\n};\n\n/**\r\n * Function: setAlpha\r\n *\r\n * Sets the current alpha.\r\n *\r\n * Parameters:\r\n *\r\n * value - Number that represents the new alpha. Possible values are between\r\n * 1 (opaque) and 0 (transparent).\r\n */\nmxXmlCanvas2D.prototype.setAlpha = function (value) {\n  if (this.compressed) {\n    if (this.state.alpha == value) {\n      return;\n    }\n    _mxAbstractCanvas2D[\"default\"].prototype.setAlpha.apply(this, arguments);\n  }\n  var elem = this.createElement('alpha');\n  elem.setAttribute('alpha', this.format(value));\n  this.root.appendChild(elem);\n};\n\n/**\r\n * Function: setFillAlpha\r\n *\r\n * Sets the current fill alpha.\r\n *\r\n * Parameters:\r\n *\r\n * value - Number that represents the new fill alpha. Possible values are between\r\n * 1 (opaque) and 0 (transparent).\r\n */\nmxXmlCanvas2D.prototype.setFillAlpha = function (value) {\n  if (this.compressed) {\n    if (this.state.fillAlpha == value) {\n      return;\n    }\n    _mxAbstractCanvas2D[\"default\"].prototype.setFillAlpha.apply(this, arguments);\n  }\n  var elem = this.createElement('fillalpha');\n  elem.setAttribute('alpha', this.format(value));\n  this.root.appendChild(elem);\n};\n\n/**\r\n * Function: setStrokeAlpha\r\n *\r\n * Sets the current stroke alpha.\r\n *\r\n * Parameters:\r\n *\r\n * value - Number that represents the new stroke alpha. Possible values are between\r\n * 1 (opaque) and 0 (transparent).\r\n */\nmxXmlCanvas2D.prototype.setStrokeAlpha = function (value) {\n  if (this.compressed) {\n    if (this.state.strokeAlpha == value) {\n      return;\n    }\n    _mxAbstractCanvas2D[\"default\"].prototype.setStrokeAlpha.apply(this, arguments);\n  }\n  var elem = this.createElement('strokealpha');\n  elem.setAttribute('alpha', this.format(value));\n  this.root.appendChild(elem);\n};\n\n/**\r\n * Function: setFillColor\r\n *\r\n * Sets the current fill color.\r\n *\r\n * Parameters:\r\n *\r\n * value - Hexadecimal representation of the color or 'none'.\r\n */\nmxXmlCanvas2D.prototype.setFillColor = function (value) {\n  if (value == _mxConstants[\"default\"].NONE) {\n    value = null;\n  }\n  if (this.compressed) {\n    if (this.state.fillColor == value) {\n      return;\n    }\n    _mxAbstractCanvas2D[\"default\"].prototype.setFillColor.apply(this, arguments);\n  }\n  var elem = this.createElement('fillcolor');\n  elem.setAttribute('color', value != null ? value : _mxConstants[\"default\"].NONE);\n  this.root.appendChild(elem);\n};\n\n/**\r\n * Function: setGradient\r\n *\r\n * Sets the gradient. Note that the coordinates may be ignored by some implementations.\r\n *\r\n * Parameters:\r\n *\r\n * color1 - Hexadecimal representation of the start color.\r\n * color2 - Hexadecimal representation of the end color.\r\n * x - X-coordinate of the gradient region.\r\n * y - y-coordinate of the gradient region.\r\n * w - Width of the gradient region.\r\n * h - Height of the gradient region.\r\n * direction - One of <mxConstants.DIRECTION_NORTH>, <mxConstants.DIRECTION_EAST>,\r\n * <mxConstants.DIRECTION_SOUTH> or <mxConstants.DIRECTION_WEST>.\r\n * alpha1 - Optional alpha of the start color. Default is 1. Possible values\r\n * are between 1 (opaque) and 0 (transparent).\r\n * alpha2 - Optional alpha of the end color. Default is 1. Possible values\r\n * are between 1 (opaque) and 0 (transparent).\r\n */\nmxXmlCanvas2D.prototype.setGradient = function (color1, color2, x, y, w, h, direction, alpha1, alpha2) {\n  if (color1 != null && color2 != null) {\n    _mxAbstractCanvas2D[\"default\"].prototype.setGradient.apply(this, arguments);\n    var elem = this.createElement('gradient');\n    elem.setAttribute('c1', color1);\n    elem.setAttribute('c2', color2);\n    elem.setAttribute('x', this.format(x));\n    elem.setAttribute('y', this.format(y));\n    elem.setAttribute('w', this.format(w));\n    elem.setAttribute('h', this.format(h));\n\n    // Default direction is south\n    if (direction != null) {\n      elem.setAttribute('direction', direction);\n    }\n    if (alpha1 != null) {\n      elem.setAttribute('alpha1', alpha1);\n    }\n    if (alpha2 != null) {\n      elem.setAttribute('alpha2', alpha2);\n    }\n    this.root.appendChild(elem);\n  }\n};\n\n/**\r\n * Function: setStrokeColor\r\n *\r\n * Sets the current stroke color.\r\n *\r\n * Parameters:\r\n *\r\n * value - Hexadecimal representation of the color or 'none'.\r\n */\nmxXmlCanvas2D.prototype.setStrokeColor = function (value) {\n  if (value == _mxConstants[\"default\"].NONE) {\n    value = null;\n  }\n  if (this.compressed) {\n    if (this.state.strokeColor == value) {\n      return;\n    }\n    _mxAbstractCanvas2D[\"default\"].prototype.setStrokeColor.apply(this, arguments);\n  }\n  var elem = this.createElement('strokecolor');\n  elem.setAttribute('color', value != null ? value : _mxConstants[\"default\"].NONE);\n  this.root.appendChild(elem);\n};\n\n/**\r\n * Function: setStrokeWidth\r\n *\r\n * Sets the current stroke width.\r\n *\r\n * Parameters:\r\n *\r\n * value - Numeric representation of the stroke width.\r\n */\nmxXmlCanvas2D.prototype.setStrokeWidth = function (value) {\n  if (this.compressed) {\n    if (this.state.strokeWidth == value) {\n      return;\n    }\n    _mxAbstractCanvas2D[\"default\"].prototype.setStrokeWidth.apply(this, arguments);\n  }\n  var elem = this.createElement('strokewidth');\n  elem.setAttribute('width', this.format(value));\n  this.root.appendChild(elem);\n};\n\n/**\r\n * Function: setDashed\r\n *\r\n * Enables or disables dashed lines.\r\n *\r\n * Parameters:\r\n *\r\n * value - Boolean that specifies if dashed lines should be enabled.\r\n */\nmxXmlCanvas2D.prototype.setDashed = function (value) {\n  if (this.compressed) {\n    if (this.state.dashed == value) {\n      return;\n    }\n    _mxAbstractCanvas2D[\"default\"].prototype.setDashed.apply(this, arguments);\n  }\n  var elem = this.createElement('dashed');\n  elem.setAttribute('dashed', value ? '1' : '0');\n  this.root.appendChild(elem);\n};\n\n/**\r\n * Function: setDashPattern\r\n *\r\n * Sets the current dash pattern. Default is '3 3'.\r\n *\r\n * Parameters:\r\n *\r\n * value - String that represents the dash pattern, which is a sequence of\r\n * numbers defining the length of the dashes and the length of the spaces\r\n * between the dashes. The lengths are relative to the line width - a length\r\n * of 1 is equals to the line width.\r\n */\nmxXmlCanvas2D.prototype.setDashPattern = function (value) {\n  if (this.compressed) {\n    if (this.state.dashPattern == value) {\n      return;\n    }\n    _mxAbstractCanvas2D[\"default\"].prototype.setDashPattern.apply(this, arguments);\n  }\n  var elem = this.createElement('dashpattern');\n  elem.setAttribute('pattern', value);\n  this.root.appendChild(elem);\n};\n\n/**\r\n * Function: setLineCap\r\n *\r\n * Sets the line cap. Default is 'flat' which corresponds to 'butt' in SVG.\r\n *\r\n * Parameters:\r\n *\r\n * value - String that represents the line cap. Possible values are flat, round\r\n * and square.\r\n */\nmxXmlCanvas2D.prototype.setLineCap = function (value) {\n  if (this.compressed) {\n    if (this.state.lineCap == value) {\n      return;\n    }\n    _mxAbstractCanvas2D[\"default\"].prototype.setLineCap.apply(this, arguments);\n  }\n  var elem = this.createElement('linecap');\n  elem.setAttribute('cap', value);\n  this.root.appendChild(elem);\n};\n\n/**\r\n * Function: setLineJoin\r\n *\r\n * Sets the line join. Default is 'miter'.\r\n *\r\n * Parameters:\r\n *\r\n * value - String that represents the line join. Possible values are miter,\r\n * round and bevel.\r\n */\nmxXmlCanvas2D.prototype.setLineJoin = function (value) {\n  if (this.compressed) {\n    if (this.state.lineJoin == value) {\n      return;\n    }\n    _mxAbstractCanvas2D[\"default\"].prototype.setLineJoin.apply(this, arguments);\n  }\n  var elem = this.createElement('linejoin');\n  elem.setAttribute('join', value);\n  this.root.appendChild(elem);\n};\n\n/**\r\n * Function: setMiterLimit\r\n *\r\n * Sets the miter limit. Default is 10.\r\n *\r\n * Parameters:\r\n *\r\n * value - Number that represents the miter limit.\r\n */\nmxXmlCanvas2D.prototype.setMiterLimit = function (value) {\n  if (this.compressed) {\n    if (this.state.miterLimit == value) {\n      return;\n    }\n    _mxAbstractCanvas2D[\"default\"].prototype.setMiterLimit.apply(this, arguments);\n  }\n  var elem = this.createElement('miterlimit');\n  elem.setAttribute('limit', value);\n  this.root.appendChild(elem);\n};\n\n/**\r\n * Function: setFontColor\r\n *\r\n * Sets the current font color. Default is '#000000'.\r\n *\r\n * Parameters:\r\n *\r\n * value - Hexadecimal representation of the color or 'none'.\r\n */\nmxXmlCanvas2D.prototype.setFontColor = function (value) {\n  if (this.textEnabled) {\n    if (value == _mxConstants[\"default\"].NONE) {\n      value = null;\n    }\n    if (this.compressed) {\n      if (this.state.fontColor == value) {\n        return;\n      }\n      _mxAbstractCanvas2D[\"default\"].prototype.setFontColor.apply(this, arguments);\n    }\n    var elem = this.createElement('fontcolor');\n    elem.setAttribute('color', value != null ? value : _mxConstants[\"default\"].NONE);\n    this.root.appendChild(elem);\n  }\n};\n\n/**\r\n * Function: setFontBackgroundColor\r\n *\r\n * Sets the current font background color.\r\n *\r\n * Parameters:\r\n *\r\n * value - Hexadecimal representation of the color or 'none'.\r\n */\nmxXmlCanvas2D.prototype.setFontBackgroundColor = function (value) {\n  if (this.textEnabled) {\n    if (value == _mxConstants[\"default\"].NONE) {\n      value = null;\n    }\n    if (this.compressed) {\n      if (this.state.fontBackgroundColor == value) {\n        return;\n      }\n      _mxAbstractCanvas2D[\"default\"].prototype.setFontBackgroundColor.apply(this, arguments);\n    }\n    var elem = this.createElement('fontbackgroundcolor');\n    elem.setAttribute('color', value != null ? value : _mxConstants[\"default\"].NONE);\n    this.root.appendChild(elem);\n  }\n};\n\n/**\r\n * Function: setFontBorderColor\r\n *\r\n * Sets the current font border color.\r\n *\r\n * Parameters:\r\n *\r\n * value - Hexadecimal representation of the color or 'none'.\r\n */\nmxXmlCanvas2D.prototype.setFontBorderColor = function (value) {\n  if (this.textEnabled) {\n    if (value == _mxConstants[\"default\"].NONE) {\n      value = null;\n    }\n    if (this.compressed) {\n      if (this.state.fontBorderColor == value) {\n        return;\n      }\n      _mxAbstractCanvas2D[\"default\"].prototype.setFontBorderColor.apply(this, arguments);\n    }\n    var elem = this.createElement('fontbordercolor');\n    elem.setAttribute('color', value != null ? value : _mxConstants[\"default\"].NONE);\n    this.root.appendChild(elem);\n  }\n};\n\n/**\r\n * Function: setFontSize\r\n *\r\n * Sets the current font size. Default is <mxConstants.DEFAULT_FONTSIZE>.\r\n *\r\n * Parameters:\r\n *\r\n * value - Numeric representation of the font size.\r\n */\nmxXmlCanvas2D.prototype.setFontSize = function (value) {\n  if (this.textEnabled) {\n    if (this.compressed) {\n      if (this.state.fontSize == value) {\n        return;\n      }\n      _mxAbstractCanvas2D[\"default\"].prototype.setFontSize.apply(this, arguments);\n    }\n    var elem = this.createElement('fontsize');\n    elem.setAttribute('size', value);\n    this.root.appendChild(elem);\n  }\n};\n\n/**\r\n * Function: setFontFamily\r\n *\r\n * Sets the current font family. Default is <mxConstants.DEFAULT_FONTFAMILY>.\r\n *\r\n * Parameters:\r\n *\r\n * value - String representation of the font family. This handles the same\r\n * values as the CSS font-family property.\r\n */\nmxXmlCanvas2D.prototype.setFontFamily = function (value) {\n  if (this.textEnabled) {\n    if (this.compressed) {\n      if (this.state.fontFamily == value) {\n        return;\n      }\n      _mxAbstractCanvas2D[\"default\"].prototype.setFontFamily.apply(this, arguments);\n    }\n    var elem = this.createElement('fontfamily');\n    elem.setAttribute('family', value);\n    this.root.appendChild(elem);\n  }\n};\n\n/**\r\n * Function: setFontStyle\r\n *\r\n * Sets the current font style.\r\n *\r\n * Parameters:\r\n *\r\n * value - Numeric representation of the font family. This is the sum of the\r\n * font styles from <mxConstants>.\r\n */\nmxXmlCanvas2D.prototype.setFontStyle = function (value) {\n  if (this.textEnabled) {\n    if (value == null) {\n      value = 0;\n    }\n    if (this.compressed) {\n      if (this.state.fontStyle == value) {\n        return;\n      }\n      _mxAbstractCanvas2D[\"default\"].prototype.setFontStyle.apply(this, arguments);\n    }\n    var elem = this.createElement('fontstyle');\n    elem.setAttribute('style', value);\n    this.root.appendChild(elem);\n  }\n};\n\n/**\r\n * Function: setShadow\r\n *\r\n * Enables or disables shadows.\r\n *\r\n * Parameters:\r\n *\r\n * value - Boolean that specifies if shadows should be enabled.\r\n */\nmxXmlCanvas2D.prototype.setShadow = function (value) {\n  if (this.compressed) {\n    if (this.state.shadow == value) {\n      return;\n    }\n    _mxAbstractCanvas2D[\"default\"].prototype.setShadow.apply(this, arguments);\n  }\n  var elem = this.createElement('shadow');\n  elem.setAttribute('enabled', value ? '1' : '0');\n  this.root.appendChild(elem);\n};\n\n/**\r\n * Function: setShadowColor\r\n *\r\n * Sets the current shadow color. Default is <mxConstants.SHADOWCOLOR>.\r\n *\r\n * Parameters:\r\n *\r\n * value - Hexadecimal representation of the color or 'none'.\r\n */\nmxXmlCanvas2D.prototype.setShadowColor = function (value) {\n  if (this.compressed) {\n    if (value == _mxConstants[\"default\"].NONE) {\n      value = null;\n    }\n    if (this.state.shadowColor == value) {\n      return;\n    }\n    _mxAbstractCanvas2D[\"default\"].prototype.setShadowColor.apply(this, arguments);\n  }\n  var elem = this.createElement('shadowcolor');\n  elem.setAttribute('color', value != null ? value : _mxConstants[\"default\"].NONE);\n  this.root.appendChild(elem);\n};\n\n/**\r\n * Function: setShadowAlpha\r\n *\r\n * Sets the current shadows alpha. Default is <mxConstants.SHADOW_OPACITY>.\r\n *\r\n * Parameters:\r\n *\r\n * value - Number that represents the new alpha. Possible values are between\r\n * 1 (opaque) and 0 (transparent).\r\n */\nmxXmlCanvas2D.prototype.setShadowAlpha = function (value) {\n  if (this.compressed) {\n    if (this.state.shadowAlpha == value) {\n      return;\n    }\n    _mxAbstractCanvas2D[\"default\"].prototype.setShadowAlpha.apply(this, arguments);\n  }\n  var elem = this.createElement('shadowalpha');\n  elem.setAttribute('alpha', value);\n  this.root.appendChild(elem);\n};\n\n/**\r\n * Function: setShadowOffset\r\n *\r\n * Sets the current shadow offset.\r\n *\r\n * Parameters:\r\n *\r\n * dx - Number that represents the horizontal offset of the shadow.\r\n * dy - Number that represents the vertical offset of the shadow.\r\n */\nmxXmlCanvas2D.prototype.setShadowOffset = function (dx, dy) {\n  if (this.compressed) {\n    if (this.state.shadowDx == dx && this.state.shadowDy == dy) {\n      return;\n    }\n    _mxAbstractCanvas2D[\"default\"].prototype.setShadowOffset.apply(this, arguments);\n  }\n  var elem = this.createElement('shadowoffset');\n  elem.setAttribute('dx', dx);\n  elem.setAttribute('dy', dy);\n  this.root.appendChild(elem);\n};\n\n/**\r\n * Function: rect\r\n *\r\n * Puts a rectangle into the drawing buffer.\r\n *\r\n * Parameters:\r\n *\r\n * x - Number that represents the x-coordinate of the rectangle.\r\n * y - Number that represents the y-coordinate of the rectangle.\r\n * w - Number that represents the width of the rectangle.\r\n * h - Number that represents the height of the rectangle.\r\n */\nmxXmlCanvas2D.prototype.rect = function (x, y, w, h) {\n  var elem = this.createElement('rect');\n  elem.setAttribute('x', this.format(x));\n  elem.setAttribute('y', this.format(y));\n  elem.setAttribute('w', this.format(w));\n  elem.setAttribute('h', this.format(h));\n  this.root.appendChild(elem);\n};\n\n/**\r\n * Function: roundrect\r\n *\r\n * Puts a rounded rectangle into the drawing buffer.\r\n *\r\n * Parameters:\r\n *\r\n * x - Number that represents the x-coordinate of the rectangle.\r\n * y - Number that represents the y-coordinate of the rectangle.\r\n * w - Number that represents the width of the rectangle.\r\n * h - Number that represents the height of the rectangle.\r\n * dx - Number that represents the horizontal rounding.\r\n * dy - Number that represents the vertical rounding.\r\n */\nmxXmlCanvas2D.prototype.roundrect = function (x, y, w, h, dx, dy) {\n  var elem = this.createElement('roundrect');\n  elem.setAttribute('x', this.format(x));\n  elem.setAttribute('y', this.format(y));\n  elem.setAttribute('w', this.format(w));\n  elem.setAttribute('h', this.format(h));\n  elem.setAttribute('dx', this.format(dx));\n  elem.setAttribute('dy', this.format(dy));\n  this.root.appendChild(elem);\n};\n\n/**\r\n * Function: ellipse\r\n *\r\n * Puts an ellipse into the drawing buffer.\r\n *\r\n * Parameters:\r\n *\r\n * x - Number that represents the x-coordinate of the ellipse.\r\n * y - Number that represents the y-coordinate of the ellipse.\r\n * w - Number that represents the width of the ellipse.\r\n * h - Number that represents the height of the ellipse.\r\n */\nmxXmlCanvas2D.prototype.ellipse = function (x, y, w, h) {\n  var elem = this.createElement('ellipse');\n  elem.setAttribute('x', this.format(x));\n  elem.setAttribute('y', this.format(y));\n  elem.setAttribute('w', this.format(w));\n  elem.setAttribute('h', this.format(h));\n  this.root.appendChild(elem);\n};\n\n/**\r\n * Function: image\r\n *\r\n * Paints an image.\r\n *\r\n * Parameters:\r\n *\r\n * x - Number that represents the x-coordinate of the image.\r\n * y - Number that represents the y-coordinate of the image.\r\n * w - Number that represents the width of the image.\r\n * h - Number that represents the height of the image.\r\n * src - String that specifies the URL of the image.\r\n * aspect - Boolean indicating if the aspect of the image should be preserved.\r\n * flipH - Boolean indicating if the image should be flipped horizontally.\r\n * flipV - Boolean indicating if the image should be flipped vertically.\r\n */\nmxXmlCanvas2D.prototype.image = function (x, y, w, h, src, aspect, flipH, flipV) {\n  src = this.converter.convert(src);\n\n  // LATER: Add option for embedding images as base64.\n  var elem = this.createElement('image');\n  elem.setAttribute('x', this.format(x));\n  elem.setAttribute('y', this.format(y));\n  elem.setAttribute('w', this.format(w));\n  elem.setAttribute('h', this.format(h));\n  elem.setAttribute('src', src);\n  elem.setAttribute('aspect', aspect ? '1' : '0');\n  elem.setAttribute('flipH', flipH ? '1' : '0');\n  elem.setAttribute('flipV', flipV ? '1' : '0');\n  this.root.appendChild(elem);\n};\n\n/**\r\n * Function: begin\r\n *\r\n * Starts a new path and puts it into the drawing buffer.\r\n */\nmxXmlCanvas2D.prototype.begin = function () {\n  this.root.appendChild(this.createElement('begin'));\n  this.lastX = 0;\n  this.lastY = 0;\n};\n\n/**\r\n * Function: moveTo\r\n *\r\n * Moves the current path the given point.\r\n *\r\n * Parameters:\r\n *\r\n * x - Number that represents the x-coordinate of the point.\r\n * y - Number that represents the y-coordinate of the point.\r\n */\nmxXmlCanvas2D.prototype.moveTo = function (x, y) {\n  var elem = this.createElement('move');\n  elem.setAttribute('x', this.format(x));\n  elem.setAttribute('y', this.format(y));\n  this.root.appendChild(elem);\n  this.lastX = x;\n  this.lastY = y;\n};\n\n/**\r\n * Function: lineTo\r\n *\r\n * Draws a line to the given coordinates.\r\n *\r\n * Parameters:\r\n *\r\n * x - Number that represents the x-coordinate of the endpoint.\r\n * y - Number that represents the y-coordinate of the endpoint.\r\n */\nmxXmlCanvas2D.prototype.lineTo = function (x, y) {\n  var elem = this.createElement('line');\n  elem.setAttribute('x', this.format(x));\n  elem.setAttribute('y', this.format(y));\n  this.root.appendChild(elem);\n  this.lastX = x;\n  this.lastY = y;\n};\n\n/**\r\n * Function: quadTo\r\n *\r\n * Adds a quadratic curve to the current path.\r\n *\r\n * Parameters:\r\n *\r\n * x1 - Number that represents the x-coordinate of the control point.\r\n * y1 - Number that represents the y-coordinate of the control point.\r\n * x2 - Number that represents the x-coordinate of the endpoint.\r\n * y2 - Number that represents the y-coordinate of the endpoint.\r\n */\nmxXmlCanvas2D.prototype.quadTo = function (x1, y1, x2, y2) {\n  var elem = this.createElement('quad');\n  elem.setAttribute('x1', this.format(x1));\n  elem.setAttribute('y1', this.format(y1));\n  elem.setAttribute('x2', this.format(x2));\n  elem.setAttribute('y2', this.format(y2));\n  this.root.appendChild(elem);\n  this.lastX = x2;\n  this.lastY = y2;\n};\n\n/**\r\n * Function: curveTo\r\n *\r\n * Adds a bezier curve to the current path.\r\n *\r\n * Parameters:\r\n *\r\n * x1 - Number that represents the x-coordinate of the first control point.\r\n * y1 - Number that represents the y-coordinate of the first control point.\r\n * x2 - Number that represents the x-coordinate of the second control point.\r\n * y2 - Number that represents the y-coordinate of the second control point.\r\n * x3 - Number that represents the x-coordinate of the endpoint.\r\n * y3 - Number that represents the y-coordinate of the endpoint.\r\n */\nmxXmlCanvas2D.prototype.curveTo = function (x1, y1, x2, y2, x3, y3) {\n  var elem = this.createElement('curve');\n  elem.setAttribute('x1', this.format(x1));\n  elem.setAttribute('y1', this.format(y1));\n  elem.setAttribute('x2', this.format(x2));\n  elem.setAttribute('y2', this.format(y2));\n  elem.setAttribute('x3', this.format(x3));\n  elem.setAttribute('y3', this.format(y3));\n  this.root.appendChild(elem);\n  this.lastX = x3;\n  this.lastY = y3;\n};\n\n/**\r\n * Function: close\r\n *\r\n * Closes the current path.\r\n */\nmxXmlCanvas2D.prototype.close = function () {\n  this.root.appendChild(this.createElement('close'));\n};\n\n/**\r\n * Function: text\r\n *\r\n * Paints the given text. Possible values for format are empty string for\r\n * plain text and html for HTML markup. Background and border color as well\r\n * as clipping is not available in plain text labels for VML. HTML labels\r\n * are not available as part of shapes with no foreignObject support in SVG\r\n * (eg. IE9, IE10).\r\n *\r\n * Parameters:\r\n *\r\n * x - Number that represents the x-coordinate of the text.\r\n * y - Number that represents the y-coordinate of the text.\r\n * w - Number that represents the available width for the text or 0 for automatic width.\r\n * h - Number that represents the available height for the text or 0 for automatic height.\r\n * str - String that specifies the text to be painted.\r\n * align - String that represents the horizontal alignment.\r\n * valign - String that represents the vertical alignment.\r\n * wrap - Boolean that specifies if word-wrapping is enabled. Requires w > 0.\r\n * format - Empty string for plain text or 'html' for HTML markup.\r\n * overflow - Specifies the overflow behaviour of the label. Requires w > 0 and/or h > 0.\r\n * clip - Boolean that specifies if the label should be clipped. Requires w > 0 and/or h > 0.\r\n * rotation - Number that specifies the angle of the rotation around the anchor point of the text.\r\n * dir - Optional string that specifies the text direction. Possible values are rtl and lrt.\r\n */\nmxXmlCanvas2D.prototype.text = function (x, y, w, h, str, align, valign, wrap, format, overflow, clip, rotation, dir) {\n  if (this.textEnabled && str != null) {\n    if (_mxGraphUtils[\"default\"].isNode(str)) {\n      str = _mxGraphUtils[\"default\"].getOuterHtml(str);\n    }\n    var elem = this.createElement('text');\n    elem.setAttribute('x', this.format(x));\n    elem.setAttribute('y', this.format(y));\n    elem.setAttribute('w', this.format(w));\n    elem.setAttribute('h', this.format(h));\n    elem.setAttribute('str', str);\n    if (align != null) {\n      elem.setAttribute('align', align);\n    }\n    if (valign != null) {\n      elem.setAttribute('valign', valign);\n    }\n    elem.setAttribute('wrap', wrap ? '1' : '0');\n    if (format == null) {\n      format = '';\n    }\n    elem.setAttribute('format', format);\n    if (overflow != null) {\n      elem.setAttribute('overflow', overflow);\n    }\n    if (clip != null) {\n      elem.setAttribute('clip', clip ? '1' : '0');\n    }\n    if (rotation != null) {\n      elem.setAttribute('rotation', rotation);\n    }\n    if (dir != null) {\n      elem.setAttribute('dir', dir);\n    }\n    this.root.appendChild(elem);\n  }\n};\n\n/**\r\n * Function: stroke\r\n *\r\n * Paints the outline of the current drawing buffer.\r\n */\nmxXmlCanvas2D.prototype.stroke = function () {\n  this.root.appendChild(this.createElement('stroke'));\n};\n\n/**\r\n * Function: fill\r\n *\r\n * Fills the current drawing buffer.\r\n */\nmxXmlCanvas2D.prototype.fill = function () {\n  this.root.appendChild(this.createElement('fill'));\n};\n\n/**\r\n * Function: fillAndStroke\r\n *\r\n * Fills the current drawing buffer and its outline.\r\n */\nmxXmlCanvas2D.prototype.fillAndStroke = function () {\n  this.root.appendChild(this.createElement('fillstroke'));\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\n/**\r\n * Class: mxSvgCanvas2D\r\n *\r\n * Extends <mxAbstractCanvas2D> to implement a canvas for SVG. This canvas writes all\r\n * calls as SVG output to the given SVG root node.\r\n *\r\n * (code)\r\n * var svgDoc = mxGraphUtils.createXmlDocument();\r\n * var root = (svgDoc.createElementNS != null) ?\r\n * \t\tsvgDoc.createElementNS(mxConstants.NS_SVG, 'svg') : svgDoc.createElement('svg');\r\n *\r\n * if (svgDoc.createElementNS == null)\r\n * {\r\n *   root.setAttribute('xmlns', mxConstants.NS_SVG);\r\n *   root.setAttribute('xmlns:xlink', mxConstants.NS_XLINK);\r\n * }\r\n * else\r\n * {\r\n *   root.setAttributeNS('http://www.w3.org/2000/xmlns/', 'xmlns:xlink', mxConstants.NS_XLINK);\r\n * }\r\n *\r\n * var bounds = graph.getGraphBounds();\r\n * root.setAttribute('width', (bounds.x + bounds.width + 4) + 'px');\r\n * root.setAttribute('height', (bounds.y + bounds.height + 4) + 'px');\r\n * root.setAttribute('version', '1.1');\r\n *\r\n * svgDoc.appendChild(root);\r\n *\r\n * var svgCanvas = new mxSvgCanvas2D(root);\r\n * (end)\r\n *\r\n * A description of the public API is available in <mxXmlCanvas2D>.\r\n *\r\n * To disable anti-aliasing in the output, use the following code.\r\n *\r\n * (code)\r\n * graph.view.canvas.ownerSVGElement.setAttribute('shape-rendering', 'crispEdges');\r\n * (end)\r\n *\r\n * Or set the respective attribute in the SVG element directly.\r\n *\r\n * Constructor: mxSvgCanvas2D\r\n *\r\n * Constructs a new SVG canvas.\r\n *\r\n * Parameters:\r\n *\r\n * root - SVG container for the output.\r\n * styleEnabled - Optional boolean that specifies if a style section should be\r\n * added. The style section sets the default font-size, font-family and\r\n * stroke-miterlimit globally. Default is false.\r\n */\nvar _default = exports[\"default\"] = mxXmlCanvas2D;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxXmlCanvas2D.js?");

/***/ }),

/***/ "./src/workflow/mxClient/mxXmlRequest.js":
/*!***********************************************!*\
  !*** ./src/workflow/mxClient/mxXmlRequest.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.index-of.js */ \"../../node_modules/core-js/modules/es.array.index-of.js\");\n__webpack_require__(/*! core-js/modules/es.function.bind.js */ \"../../node_modules/core-js/modules/es.function.bind.js\");\nvar _mxClient = _interopRequireDefault(__webpack_require__(/*! ./mxClient.js */ \"./src/workflow/mxClient/mxClient.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ./mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction mxXmlRequest(url, params, method, async, username, password) {\n  this.url = url;\n  this.params = params;\n  this.method = method || 'POST';\n  this.async = async != null ? async : true;\n  this.username = username;\n  this.password = password;\n}\n;\n\n/**\r\n * Variable: url\r\n *\r\n * Holds the target URL of the request.\r\n */\nmxXmlRequest.prototype.url = null;\n\n/**\r\n * Variable: params\r\n *\r\n * Holds the form encoded data for the POST request.\r\n */\nmxXmlRequest.prototype.params = null;\n\n/**\r\n * Variable: method\r\n *\r\n * Specifies the request method. Possible values are POST and GET. Default\r\n * is POST.\r\n */\nmxXmlRequest.prototype.method = null;\n\n/**\r\n * Variable: async\r\n *\r\n * Boolean indicating if the request is asynchronous.\r\n */\nmxXmlRequest.prototype.async = null;\n\n/**\r\n * Variable: binary\r\n *\r\n * Boolean indicating if the request is binary. This option is ignored in IE.\r\n * In all other browsers the requested mime type is set to\r\n * text/plain; charset=x-user-defined. Default is false.\r\n */\nmxXmlRequest.prototype.binary = false;\n\n/**\r\n * Variable: withCredentials\r\n *\r\n * Specifies if withCredentials should be used in HTML5-compliant browsers. Default is\r\n * false.\r\n */\nmxXmlRequest.prototype.withCredentials = false;\n\n/**\r\n * Variable: username\r\n *\r\n * Specifies the username to be used for authentication.\r\n */\nmxXmlRequest.prototype.username = null;\n\n/**\r\n * Variable: password\r\n *\r\n * Specifies the password to be used for authentication.\r\n */\nmxXmlRequest.prototype.password = null;\n\n/**\r\n * Variable: request\r\n *\r\n * Holds the inner, browser-specific request object.\r\n */\nmxXmlRequest.prototype.request = null;\n\n/**\r\n * Variable: decodeSimulateValues\r\n *\r\n * Specifies if request values should be decoded as URIs before setting the\r\n * textarea value in <simulate>. Defaults to false for backwards compatibility,\r\n * to avoid another decode on the server this should be set to true.\r\n */\nmxXmlRequest.prototype.decodeSimulateValues = false;\n\n/**\r\n * Function: isBinary\r\n *\r\n * Returns <binary>.\r\n */\nmxXmlRequest.prototype.isBinary = function () {\n  return this.binary;\n};\n\n/**\r\n * Function: setBinary\r\n *\r\n * Sets <binary>.\r\n */\nmxXmlRequest.prototype.setBinary = function (value) {\n  this.binary = value;\n};\n\n/**\r\n * Function: getText\r\n *\r\n * Returns the response as a string.\r\n */\nmxXmlRequest.prototype.getText = function () {\n  return this.request.responseText;\n};\n\n/**\r\n * Function: isReady\r\n *\r\n * Returns true if the response is ready.\r\n */\nmxXmlRequest.prototype.isReady = function () {\n  return this.request.readyState == 4;\n};\n\n/**\r\n * Function: getDocumentElement\r\n *\r\n * Returns the document element of the response XML document.\r\n */\nmxXmlRequest.prototype.getDocumentElement = function () {\n  var doc = this.getXml();\n  if (doc != null) {\n    return doc.documentElement;\n  }\n  return null;\n};\n\n/**\r\n * Function: getXml\r\n *\r\n * Returns the response as an XML document. Use <getDocumentElement> to get\r\n * the document element of the XML document.\r\n */\nmxXmlRequest.prototype.getXml = function () {\n  var xml = this.request.responseXML;\n\n  // Handles missing response headers in IE, the first condition handles\n  // the case where responseXML is there, but using its nodes leads to\n  // type errors in the mxCellCodec when putting the nodes into a new\n  // document. This happens in IE9 standards mode and with XML user\n  // objects only, as they are used directly as values in cells.\n  if (document.documentMode >= 9 || xml == null || xml.documentElement == null) {\n    xml = _mxGraphUtils[\"default\"].parseXml(this.request.responseText);\n  }\n  return xml;\n};\n\n/**\r\n * Function: getText\r\n *\r\n * Returns the response as a string.\r\n */\nmxXmlRequest.prototype.getText = function () {\n  return this.request.responseText;\n};\n\n/**\r\n * Function: getStatus\r\n *\r\n * Returns the status as a number, eg. 404 for \"Not found\" or 200 for \"OK\".\r\n * Note: The NS_ERROR_NOT_AVAILABLE for invalid responses cannot be cought.\r\n */\nmxXmlRequest.prototype.getStatus = function () {\n  return this.request.status;\n};\n\n/**\r\n * Function: create\r\n *\r\n * Creates and returns the inner <request> object.\r\n */\nmxXmlRequest.prototype.create = function () {\n  if (window.XMLHttpRequest) {\n    return function () {\n      var req = new XMLHttpRequest();\n\n      // TODO: Check for overrideMimeType required here?\n      if (this.isBinary() && req.overrideMimeType) {\n        req.overrideMimeType('text/plain; charset=x-user-defined');\n      }\n      return req;\n    };\n  } else if (typeof ActiveXObject != 'undefined') {\n    return function () {\n      // TODO: Implement binary option\n      return new ActiveXObject('Microsoft.XMLHTTP');\n    };\n  }\n}();\n\n/**\r\n * Function: send\r\n *\r\n * Send the <request> to the target URL using the specified functions to\r\n * process the response asychronously.\r\n *\r\n * Parameters:\r\n *\r\n * onload - Function to be invoked if a successful response was received.\r\n * onerror - Function to be called on any error.\r\n * timeout - Optional timeout in ms before calling ontimeout.\r\n * ontimeout - Optional function to execute on timeout.\r\n */\nmxXmlRequest.prototype.send = function (onload, onerror, timeout, ontimeout) {\n  this.request = this.create();\n  if (this.request != null) {\n    if (onload != null) {\n      this.request.onreadystatechange = _mxGraphUtils[\"default\"].bind(this, function () {\n        if (this.isReady()) {\n          onload(this);\n          this.onreadystatechaange = null;\n        }\n      });\n    }\n    this.request.open(this.method, this.url, this.async, this.username, this.password);\n    this.setRequestHeaders(this.request, this.params);\n    if (window.XMLHttpRequest && this.withCredentials) {\n      this.request.withCredentials = 'true';\n    }\n    if (!_mxClient[\"default\"].IS_QUIRKS && (document.documentMode == null || document.documentMode > 9) && window.XMLHttpRequest && timeout != null && ontimeout != null) {\n      this.request.timeout = timeout;\n      this.request.ontimeout = ontimeout;\n    }\n    this.request.send(this.params);\n  }\n};\n\n/**\r\n * Function: setRequestHeaders\r\n *\r\n * Sets the headers for the given request and parameters. This sets the\r\n * content-type to application/x-www-form-urlencoded if any params exist.\r\n *\r\n * Example:\r\n *\r\n * (code)\r\n * request.setRequestHeaders = function(request, params)\r\n * {\r\n *   if (params != null)\r\n *   {\r\n *     request.setRequestHeader('Content-Type',\r\n *             'multipart/form-data');\r\n *     request.setRequestHeader('Content-Length',\r\n *             params.length);\r\n *   }\r\n * };\r\n * (end)\r\n *\r\n * Use the code above before calling <send> if you require a\r\n * multipart/form-data request.\r\n */\nmxXmlRequest.prototype.setRequestHeaders = function (request, params) {\n  if (params != null) {\n    request.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n  }\n};\n\n/**\r\n * Function: simulate\r\n *\r\n * Creates and posts a request to the given target URL using a dynamically\r\n * created form inside the given document.\r\n *\r\n * Parameters:\r\n *\r\n * docs - Document that contains the form element.\r\n * target - Target to send the form result to.\r\n */\nmxXmlRequest.prototype.simulate = function (doc, target) {\n  doc = doc || document;\n  var old = null;\n  if (doc == document) {\n    old = window.onbeforeunload;\n    window.onbeforeunload = null;\n  }\n  var form = doc.createElement('form');\n  form.setAttribute('method', this.method);\n  form.setAttribute('action', this.url);\n  if (target != null) {\n    form.setAttribute('target', target);\n  }\n  form.style.display = 'none';\n  form.style.visibility = 'hidden';\n  var pars = this.params.indexOf('&') > 0 ? this.params.split('&') : this.params.split();\n\n  // Adds the parameters as textareas to the form\n  for (var i = 0; i < pars.length; i++) {\n    var pos = pars[i].indexOf('=');\n    if (pos > 0) {\n      var name = pars[i].substring(0, pos);\n      var value = pars[i].substring(pos + 1);\n      if (this.decodeSimulateValues) {\n        value = decodeURIComponent(value);\n      }\n      var textarea = doc.createElement('textarea');\n      textarea.setAttribute('name', name);\n      _mxGraphUtils[\"default\"].write(textarea, value);\n      form.appendChild(textarea);\n    }\n  }\n  doc.body.appendChild(form);\n  form.submit();\n  doc.body.removeChild(form);\n  if (old != null) {\n    window.onbeforeunload = old;\n  }\n};\n/**\r\n * Copyright (c) 2006-2015, JGraph Ltd\r\n * Copyright (c) 2006-2015, Gaudenz Alder\r\n */\nvar _default = exports[\"default\"] = mxXmlRequest;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxClient/mxXmlRequest.js?");

/***/ }),

/***/ "./src/workflow/mxGraph/Action.js":
/*!****************************************!*\
  !*** ./src/workflow/mxGraph/Action.js ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _mxEventObject = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxEventObject.js */ \"./src/workflow/mxClient/mxEventObject.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxEventSource = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxEventSource.js */ \"./src/workflow/mxClient/mxEventSource.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction Action(label, funct, enabled, iconCls, shortcut) {\n  _mxEventSource[\"default\"].call(this);\n  this.label = label;\n  this.funct = funct;\n  this.enabled = enabled != null ? enabled : true;\n  this.iconCls = iconCls;\n  this.shortcut = shortcut;\n  this.visible = true;\n}\n;\n\n// Action inherits from mxEventSource\n_mxGraphUtils[\"default\"].extend(Action, _mxEventSource[\"default\"]);\n\n/**\r\n * Sets the enabled state of the action and fires a stateChanged event.\r\n */\nAction.prototype.setEnabled = function (value) {\n  if (this.enabled != value) {\n    this.enabled = value;\n    this.fireEvent(new _mxEventObject[\"default\"]('stateChanged'));\n  }\n};\n\n/**\r\n * Sets the enabled state of the action and fires a stateChanged event.\r\n */\nAction.prototype.isEnabled = function () {\n  return this.enabled;\n};\n\n/**\r\n * Sets the enabled state of the action and fires a stateChanged event.\r\n */\nAction.prototype.setToggleAction = function (value) {\n  this.toggleAction = value;\n};\n\n/**\r\n * Sets the enabled state of the action and fires a stateChanged event.\r\n */\nAction.prototype.setSelectedCallback = function (funct) {\n  this.selectedCallback = funct;\n};\n\n/**\r\n * Sets the enabled state of the action and fires a stateChanged event.\r\n */\nAction.prototype.isSelected = function () {\n  return this.selectedCallback();\n};\nvar _default = exports[\"default\"] = Action;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxGraph/Action.js?");

/***/ }),

/***/ "./src/workflow/mxGraph/Actions.js":
/*!*****************************************!*\
  !*** ./src/workflow/mxGraph/Actions.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.function.bind.js */ \"../../node_modules/core-js/modules/es.function.bind.js\");\n__webpack_require__(/*! core-js/modules/es.parse-int.js */ \"../../node_modules/core-js/modules/es.parse-int.js\");\nvar _mxEventObject = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxEventObject.js */ \"./src/workflow/mxClient/mxEventObject.js\"));\nvar _mxClipboard = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxClipboard.js */ \"./src/workflow/mxClient/mxClipboard.js\"));\nvar _OutlineWindow = _interopRequireDefault(__webpack_require__(/*! ./OutlineWindow.js */ \"./src/workflow/mxGraph/OutlineWindow.js\"));\nvar _LayersWindow = _interopRequireDefault(__webpack_require__(/*! ./LayersWindow.js */ \"./src/workflow/mxGraph/LayersWindow.js\"));\nvar _mxClient = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxClient.js */ \"./src/workflow/mxClient/mxClient.js\"));\nvar _EditDiagramDialog = _interopRequireDefault(__webpack_require__(/*! ./EditDiagramDialog.js */ \"./src/workflow/mxGraph/EditDiagramDialog.js\"));\nvar _Action = _interopRequireDefault(__webpack_require__(/*! ./Action.js */ \"./src/workflow/mxGraph/Action.js\"));\nvar _FilenameDialog = _interopRequireDefault(__webpack_require__(/*! ./FilenameDialog.js */ \"./src/workflow/mxGraph/FilenameDialog.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxResources = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxResources.js */ \"./src/workflow/mxClient/mxResources.js\"));\nvar _OpenFile = _interopRequireDefault(__webpack_require__(/*! ./OpenFile.js */ \"./src/workflow/mxGraph/OpenFile.js\"));\nvar _ExportDialog = _interopRequireDefault(__webpack_require__(/*! ./ExportDialog.js */ \"./src/workflow/mxGraph/ExportDialog.js\"));\nvar _PrintDialog = _interopRequireDefault(__webpack_require__(/*! ./PrintDialog.js */ \"./src/workflow/mxGraph/PrintDialog.js\"));\nvar _PageSetupDialog = _interopRequireDefault(__webpack_require__(/*! ./PageSetupDialog.js */ \"./src/workflow/mxGraph/PageSetupDialog.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nvar _mxUtils = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxUtils.js */ \"./src/workflow/mxClient/mxUtils.js\"));\nvar _mxGraphConstant = __webpack_require__(/*! ../constants/mxGraphConstant */ \"./src/workflow/constants/mxGraphConstant.js\");\nvar _GraphActions = __webpack_require__(/*! ./GraphActions.js */ \"./src/workflow/mxGraph/GraphActions.js\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction Actions(editorUi) {\n  this.editorUi = editorUi;\n  this.actions = new Object();\n  this.init();\n}\n;\n\n/**\r\n * Adds the default actions.\r\n */\nActions.prototype.init = function () {\n  var ui = this.editorUi;\n  var editor = ui.editor;\n  var graph = editor.graph;\n  var isGraphEnabled = function isGraphEnabled() {\n    return _Action[\"default\"].prototype.isEnabled.apply(this, arguments) && graph.isEnabled();\n  };\n\n  // File actions\n  this.addAction('new...', function () {\n    window.open(ui.getUrl());\n  });\n  this.addAction('open...', function () {\n    window.openNew = true;\n    window.openKey = 'open';\n    ui.openFile();\n  });\n  this.addAction('import...', (0, _GraphActions.importAction)(ui, editor)).isEnabled = isGraphEnabled;\n  this.addAction('save', function () {\n    ui.saveFile(false);\n  }, null, null, 'Ctrl+S').isEnabled = isGraphEnabled;\n  this.addAction('saveAs...', function () {\n    ui.saveFile(true);\n  }, null, null, 'Ctrl+Shift+S').isEnabled = isGraphEnabled;\n  this.addAction('export...', function () {\n    ui.showDialog(new _ExportDialog[\"default\"](ui).container, 300, 210, true, true);\n  });\n  this.addAction('editDiagram...', function () {\n    var dlg = new _EditDiagramDialog[\"default\"](ui);\n    ui.showDialog(dlg.container, 620, 420, true, true);\n    dlg.init();\n  });\n  this.addAction('pageSetup...', function () {\n    ui.showDialog(new _PageSetupDialog[\"default\"](ui).container, 320, 220, true, true);\n  }).isEnabled = isGraphEnabled;\n  this.addAction('print...', function () {\n    ui.showDialog(new _PrintDialog[\"default\"](ui).container, 300, 180, true, true);\n  }, null, 'sprite-print', 'Ctrl+P');\n  this.addAction('preview', function () {\n    _mxUtils[\"default\"].show(graph, null, 10, 10);\n  });\n\n  // Edit actions\n  this.addAction('undo', function () {\n    ui.undo();\n  }, null, 'sprite-undo', 'Ctrl+Z');\n  this.addAction('redo', function () {\n    ui.redo();\n  }, null, 'sprite-redo', !_mxClient[\"default\"].IS_WIN ? 'Ctrl+Shift+Z' : 'Ctrl+Y');\n  this.addAction('cut', function () {\n    _mxClipboard[\"default\"].cut(graph);\n  }, null, 'sprite-cut', 'Ctrl+X');\n  this.addAction('copy', function () {\n    ui.clipboardCopy(graph);\n  }, null, 'sprite-copy', 'Ctrl+C');\n  this.addAction('paste', function () {\n    if (graph.cellEditor.isContentEditing() || !_mxClipboard[\"default\"].isEmpty() && graph.isEnabled() && !graph.isCellLocked(graph.getDefaultParent())) {\n      ui.clipboardPaste(graph);\n    }\n  }, false, 'sprite-paste', 'Ctrl+V');\n  this.addAction('pasteHere', (0, _GraphActions.pasteHereAction)(graph));\n  function deleteCells(includeEdges) {\n    // Cancels interactive operations\n    graph.escape();\n    var selectedCells = graph.getSelectionCells();\n    var cells = graph.getDeletableCells(selectedCells);\n    if (cells != null && cells.length > 0) {\n      var parents = graph.model.getParents(cells);\n      graph.removeCells(cells, includeEdges);\n\n      // Selects parents for easier editing of groups\n      if (parents != null) {\n        var select = [];\n        for (var i = 0; i < parents.length; i++) {\n          if (graph.model.getCell(parents[i].id) && (graph.model.isVertex(parents[i]) || graph.model.isEdge(parents[i]))) {\n            select.push(parents[i]);\n          }\n        }\n        graph.setSelectionCells(select);\n      }\n    }\n    if (selectedCells != null && cells != null) {\n      graph.fireEvent(new _mxEventObject[\"default\"](_mxGraphConstant.EVENT.AFTER_DELETE_CELLS, 'cells', cells, 'selectedCells', selectedCells));\n    }\n  }\n  ;\n  this.addAction('delete', function () {\n    deleteCells(false);\n  }, null, null, 'Delete');\n  this.addAction('deleteAll', function () {\n    deleteCells(true);\n  }, null, null, 'Ctrl+Delete');\n  this.addAction('duplicate', function () {\n    graph.setSelectionCells(graph.duplicateCells());\n  }, null, null, 'Ctrl+D');\n  this.addAction('turn', function () {\n    graph.setSelectionCells(graph.turnShapes(graph.getSelectionCells()));\n  }, null, null, 'Ctrl+R');\n  this.addAction('selectVertices', function () {\n    graph.selectVertices();\n  }, null, null, 'Ctrl+Shift+I');\n  this.addAction('selectEdges', function () {\n    graph.selectEdges();\n  }, null, null, 'Ctrl+Shift+E');\n  this.addAction('selectAll', function () {\n    graph.selectAll(null, true);\n  }, null, null, 'Ctrl+A');\n  this.addAction('selectNone', function () {\n    graph.clearSelection();\n  }, null, null, 'Ctrl+Shift+A');\n  this.addAction('lockUnlock', (0, _GraphActions.lockUnlockAction)(graph), null, null, 'Ctrl+L');\n\n  // Navigation actions\n  this.addAction('home', function () {\n    graph.home();\n  }, null, null, 'Home');\n  this.addAction('exitGroup', function () {\n    graph.exitGroup();\n  }, null, null, 'Ctrl+Shift+Page Up');\n  this.addAction('enterGroup', function () {\n    graph.enterGroup();\n  }, null, null, 'Ctrl+Shift+Page Down');\n  this.addAction('expand', function () {\n    graph.foldCells(false);\n  }, null, null, 'Ctrl+Page Down');\n  this.addAction('collapse', function () {\n    graph.foldCells(true);\n  }, null, null, 'Ctrl+Page Up');\n\n  // Arrange actions\n  this.addAction('toFront', function () {\n    graph.orderCells(false);\n  }, null, null, 'Ctrl+Shift+F');\n  this.addAction('toBack', function () {\n    graph.orderCells(true);\n  }, null, null, 'Ctrl+Shift+B');\n  this.addAction('group', (0, _GraphActions.groupAction)(graph), null, null, 'Ctrl+G');\n  this.addAction('ungroup', (0, _GraphActions.ungroupAction)(graph), null, null, 'Ctrl+Shift+U');\n  this.addAction('removeFromGroup', function () {\n    graph.removeCellsFromParent();\n  });\n  // Adds action\n  this.addAction('editData...', (0, _GraphActions.editDataAction)(ui, graph), null, null, 'Ctrl+M');\n  this.addAction('editTooltip...', (0, _GraphActions.editTooltipAction)(ui, graph));\n  this.addAction('openLink', (0, _GraphActions.openLinkAction)(graph));\n  this.addAction('editLink...', (0, _GraphActions.editLinkAction)(ui, graph));\n  this.addAction('insertLink', (0, _GraphActions.insertLinkAction)(ui, graph)).isEnabled = isGraphEnabled;\n  this.addAction('link...', (0, _GraphActions.linkAction)(ui)).isEnabled = isGraphEnabled;\n  this.addAction('autosize', (0, _GraphActions.autosizeAction)(graph), null, null, 'Ctrl+Shift+Y');\n  this.addAction('formattedText', (0, _GraphActions.formattedTextAction)(ui, graph));\n  this.addAction('wordWrap', (0, _GraphActions.wordWrapAction)(graph));\n  this.addAction('rotation', (0, _GraphActions.rotationAction)(ui, graph));\n  // View actions\n  this.addAction('resetView', function () {\n    graph.zoomTo(1);\n    ui.resetScrollbars();\n  }, null, null, 'Ctrl+H');\n  this.addAction('zoomIn', function (evt) {\n    graph.zoomIn();\n  }, null, null, 'Ctrl + / Alt+Mousewheel');\n  this.addAction('zoomOut', function (evt) {\n    graph.zoomOut();\n  }, null, null, 'Ctrl - / Alt+Mousewheel');\n  this.addAction('fitWindow', function () {\n    graph.fit();\n  }, null, null, 'Ctrl+Shift+H');\n  this.addAction('fitPage', (0, _GraphActions.fitPageAction)(graph), null, null, 'Ctrl+J');\n  this.addAction('fitTwoPages', (0, _GraphActions.fitTwoPagesAction)(graph), null, null, 'Ctrl+Shift+J');\n  this.addAction('fitPageWidth', (0, _GraphActions.fitPageWidthAction)(graph));\n  this.put('customZoom', new _Action[\"default\"](_mxResources[\"default\"].get('custom') + '...', _mxGraphUtils[\"default\"].bind(this, function () {\n    var dlg = new _FilenameDialog[\"default\"](this.editorUi, parseInt(graph.getView().getScale() * 100), _mxResources[\"default\"].get('apply'), _mxGraphUtils[\"default\"].bind(this, function (newValue) {\n      var val = parseInt(newValue);\n      if (!isNaN(val) && val > 0) {\n        graph.zoomTo(val / 100);\n      }\n    }), _mxResources[\"default\"].get('zoom') + ' (%)');\n    this.editorUi.showDialog(dlg.container, 300, 80, true, true);\n    dlg.init();\n  }), null, null, 'Ctrl+0'));\n  this.addAction('pageScale', (0, _GraphActions.pageScaleAction)(graph));\n\n  // Option actions\n  var action = null;\n  action = this.addAction('grid', function () {\n    graph.setGridEnabled(!graph.isGridEnabled());\n    ui.fireEvent(new _mxEventObject[\"default\"]('gridEnabledChanged'));\n  }, null, null, 'Ctrl+Shift+G');\n  action.setToggleAction(true);\n  action.setSelectedCallback(function () {\n    return graph.isGridEnabled();\n  });\n  action.setEnabled(false);\n  action = this.addAction('guides', function () {\n    graph.graphHandler.guidesEnabled = !graph.graphHandler.guidesEnabled;\n    ui.fireEvent(new _mxEventObject[\"default\"]('guidesEnabledChanged'));\n  });\n  action.setToggleAction(true);\n  action.setSelectedCallback(function () {\n    return graph.graphHandler.guidesEnabled;\n  });\n  action.setEnabled(false);\n  action = this.addAction('tooltips', function () {\n    graph.tooltipHandler.setEnabled(!graph.tooltipHandler.isEnabled());\n  });\n  action.setToggleAction(true);\n  action.setSelectedCallback(function () {\n    return graph.tooltipHandler.isEnabled();\n  });\n  action = this.addAction('collapseExpand', function () {\n    ui.setFoldingEnabled(!graph.foldingEnabled);\n  });\n  action.setToggleAction(true);\n  action.setSelectedCallback(function () {\n    return graph.foldingEnabled;\n  });\n  action.isEnabled = isGraphEnabled;\n  action = this.addAction('scrollbars', function () {\n    ui.setScrollbars(!ui.hasScrollbars());\n  });\n  action.setToggleAction(true);\n  action.setSelectedCallback(function () {\n    return graph.scrollbars;\n  });\n  action = this.addAction('pageView', (0, _GraphActions.pageViewAction)(ui, graph));\n  action.setToggleAction(true);\n  action.setSelectedCallback(function () {\n    return graph.pageVisible;\n  });\n  this.put('pageBackgroundColor', new _Action[\"default\"](_mxResources[\"default\"].get('backgroundColor') + '...', function () {\n    ui.pickColor(graph.background || 'none', function (color) {\n      ui.setBackgroundColor(color);\n    });\n  }));\n  action = this.addAction('connectionArrows', function () {\n    graph.connectionArrowsEnabled = !graph.connectionArrowsEnabled;\n    ui.fireEvent(new _mxEventObject[\"default\"]('connectionArrowsChanged'));\n  }, null, null, 'Ctrl+Q');\n  action.setToggleAction(true);\n  action.setSelectedCallback(function () {\n    return graph.connectionArrowsEnabled;\n  });\n  action = this.addAction('connectionPoints', function () {\n    graph.setConnectable(!graph.connectionHandler.isEnabled());\n    ui.fireEvent(new _mxEventObject[\"default\"]('connectionPointsChanged'));\n  }, null, null, 'Ctrl+Shift+Q');\n  action.setToggleAction(true);\n  action.setSelectedCallback(function () {\n    return graph.connectionHandler.isEnabled();\n  });\n  action = this.addAction('copyConnect', function () {\n    graph.connectionHandler.setCreateTarget(!graph.connectionHandler.isCreateTarget());\n    ui.fireEvent(new _mxEventObject[\"default\"]('copyConnectChanged'));\n  });\n  action.setToggleAction(true);\n  action.setSelectedCallback(function () {\n    return graph.connectionHandler.isCreateTarget();\n  });\n  action.isEnabled = isGraphEnabled;\n  action = this.addAction('autosave', function () {\n    ui.editor.setAutosave(!ui.editor.autosave);\n  });\n  action.setToggleAction(true);\n  action.setSelectedCallback(function () {\n    return ui.editor.autosave;\n  });\n  action.isEnabled = isGraphEnabled;\n  action.visible = false;\n\n  // Font style actions\n  var toggleFontStyle = _mxGraphUtils[\"default\"].bind(this, function (key, style, fn, shortcut) {\n    return this.addAction(key, function () {\n      if (fn != null && graph.cellEditor.isContentEditing()) {\n        fn();\n      } else {\n        graph.stopEditing(false);\n        graph.toggleCellStyleFlags(_mxConstants[\"default\"].STYLE_FONTSTYLE, style);\n      }\n    }, null, null, shortcut);\n  });\n  toggleFontStyle('bold', _mxConstants[\"default\"].FONT_BOLD, function () {\n    document.execCommand('bold', false, null);\n  }, 'Ctrl+B');\n  toggleFontStyle('italic', _mxConstants[\"default\"].FONT_ITALIC, function () {\n    document.execCommand('italic', false, null);\n  }, 'Ctrl+I');\n  toggleFontStyle('underline', _mxConstants[\"default\"].FONT_UNDERLINE, function () {\n    document.execCommand('underline', false, null);\n  }, 'Ctrl+U');\n\n  // Color actions\n  this.addAction('fontColor...', function () {\n    ui.menus.pickColor(_mxConstants[\"default\"].STYLE_FONTCOLOR, 'forecolor', '000000');\n  });\n  this.addAction('strokeColor...', function () {\n    ui.menus.pickColor(_mxConstants[\"default\"].STYLE_STROKECOLOR);\n  });\n  this.addAction('fillColor...', function () {\n    ui.menus.pickColor(_mxConstants[\"default\"].STYLE_FILLCOLOR);\n  });\n  this.addAction('gradientColor...', function () {\n    ui.menus.pickColor(_mxConstants[\"default\"].STYLE_GRADIENTCOLOR);\n  });\n  this.addAction('backgroundColor...', function () {\n    ui.menus.pickColor(_mxConstants[\"default\"].STYLE_LABEL_BACKGROUNDCOLOR, 'backcolor');\n  });\n  this.addAction('borderColor...', function () {\n    ui.menus.pickColor(_mxConstants[\"default\"].STYLE_LABEL_BORDERCOLOR);\n  });\n\n  // Format actions\n  this.addAction('vertical', function () {\n    ui.menus.toggleStyle(_mxConstants[\"default\"].STYLE_HORIZONTAL, true);\n  });\n  this.addAction('shadow', function () {\n    ui.menus.toggleStyle(_mxConstants[\"default\"].STYLE_SHADOW);\n  });\n  this.addAction('solid', (0, _GraphActions.solidAction)(ui, graph));\n  this.addAction('dashed', (0, _GraphActions.dashedAction)(ui, graph));\n  this.addAction('dotted', (0, _GraphActions.dottedAction)(ui, graph));\n  this.addAction('sharp', (0, _GraphActions.sharpAction)(ui, graph));\n  this.addAction('rounded', (0, _GraphActions.roundedAction)(ui, graph));\n  this.addAction('toggleRounded', (0, _GraphActions.toggleRoundedAction)(ui, graph));\n  this.addAction('curved', (0, _GraphActions.curvedAction)(ui, graph));\n  this.addAction('collapsible', (0, _GraphActions.collapsibleAction)(ui, graph));\n  this.addAction('editStyle...', (0, _GraphActions.editStyleAction)(graph), null, null, 'Ctrl+E');\n  this.addAction('setAsDefaultStyle', function () {\n    if (graph.isEnabled() && !graph.isSelectionEmpty()) {\n      ui.setDefaultStyle(graph.getSelectionCell());\n    }\n  }, null, null, 'Ctrl+Shift+D');\n  this.addAction('clearDefaultStyle', function () {\n    if (graph.isEnabled()) {\n      ui.clearDefaultStyle();\n    }\n  }, null, null, 'Ctrl+Shift+R');\n  this.addAction('addWaypoint', (0, _GraphActions.addWaypointAction)(editor, graph));\n  this.addAction('removeWaypoint', function () {\n    // TODO: Action should run with \"this\" set to action\n    var rmWaypointAction = ui.actions.get('removeWaypoint');\n    if (rmWaypointAction.handler != null) {\n      // NOTE: Popupevent handled and action updated in Menus.createPopupMenu\n      rmWaypointAction.handler.removePoint(rmWaypointAction.handler.state, rmWaypointAction.index);\n    }\n  });\n  this.addAction('clearWaypoints', (0, _GraphActions.clearWaypointsAction)(graph));\n  action = this.addAction('subscript', _mxGraphUtils[\"default\"].bind(this, function () {\n    if (graph.cellEditor.isContentEditing()) {\n      document.execCommand('subscript', false, null);\n    }\n  }), null, null, 'Ctrl+,');\n  action = this.addAction('superscript', _mxGraphUtils[\"default\"].bind(this, function () {\n    if (graph.cellEditor.isContentEditing()) {\n      document.execCommand('superscript', false, null);\n    }\n  }), null, null, 'Ctrl+.');\n  this.addAction('image...', (0, _GraphActions.imageAction)(ui, graph)).isEnabled = isGraphEnabled;\n  this.addAction('insertImage...', function () {\n    if (graph.isEnabled() && !graph.isCellLocked(graph.getDefaultParent())) {\n      graph.clearSelection();\n      ui.actions.get('image').funct();\n    }\n  }).isEnabled = isGraphEnabled;\n  action = this.addAction('layers', (0, _GraphActions.layersAction)(ui), null, null, 'Ctrl+Shift+L');\n  action.setToggleAction(true);\n  action.setSelectedCallback(_mxGraphUtils[\"default\"].bind(this, function () {\n    return this.layersWindow != null && this.layersWindow.window.isVisible();\n  }));\n  action = this.addAction('formatPanel', _mxGraphUtils[\"default\"].bind(this, function () {\n    ui.toggleFormatPanel();\n  }), null, null, 'Ctrl+Shift+P');\n  action.setToggleAction(true);\n  action.setSelectedCallback(_mxGraphUtils[\"default\"].bind(this, function () {\n    return true;\n  }));\n  action = this.addAction('outline', (0, _GraphActions.outlineAction)(ui), null, null, 'Ctrl+Shift+O');\n  action.setToggleAction(true);\n  action.setSelectedCallback(_mxGraphUtils[\"default\"].bind(this, function () {\n    return this.outlineWindow != null && this.outlineWindow.window.isVisible();\n  }));\n  this.addAction('animation', (0, _GraphActions.animationAction)(ui, graph), null, null, 'Ctrl+M');\n};\n\n/**\r\n * Registers the given action under the given name.\r\n */\nActions.prototype.addAction = function (key, funct, enabled, iconCls, shortcut) {\n  var title;\n  if (key.substring(key.length - 3) == '...') {\n    key = key.substring(0, key.length - 3);\n    title = _mxResources[\"default\"].get(key) + '...';\n  } else {\n    title = _mxResources[\"default\"].get(key);\n  }\n  return this.put(key, new _Action[\"default\"](title, funct, enabled, iconCls, shortcut));\n};\n\n/**\r\n * Registers the given action under the given name.\r\n */\nActions.prototype.put = function (name, action) {\n  this.actions[name] = action;\n  return action;\n};\n\n/**\r\n * Returns the action for the given name or null if no such action exists.\r\n */\nActions.prototype.get = function (name) {\n  return this.actions[name];\n};\n\n/**\r\n * Constructs a new action for the given parameters.\r\n */\nvar _default = exports[\"default\"] = Actions;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxGraph/Actions.js?");

/***/ }),

/***/ "./src/workflow/mxGraph/BillCard.js":
/*!******************************************!*\
  !*** ./src/workflow/mxGraph/BillCard.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.function.name.js */ \"../../node_modules/core-js/modules/es.function.name.js\");\nvar _HtmlCard = _interopRequireDefault(__webpack_require__(/*! ./HtmlCard.js */ \"./src/workflow/mxGraph/HtmlCard.js\"));\nvar _mxUtils = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxUtils.js */ \"./src/workflow/mxClient/mxUtils.js\"));\nvar _BillCard = _interopRequireDefault(__webpack_require__(/*! ../css/BillCard.less */ \"./src/workflow/css/BillCard.less\"));\nvar _templateWeb = _interopRequireDefault(__webpack_require__(/*! art-template/lib/template-web.js */ \"../../node_modules/art-template/lib/template-web.js\"));\nvar _HtmlTemplates = __webpack_require__(/*! ./HtmlTemplates.js */ \"./src/workflow/mxGraph/HtmlTemplates.js\");\nvar _icon_custom_relation = _interopRequireDefault(__webpack_require__(/*! ../images/icon_custom_relation.png */ \"./src/workflow/images/icon_custom_relation.png\"));\nvar _noPermission = _interopRequireDefault(__webpack_require__(/*! ../images/no-permission.png */ \"./src/workflow/images/no-permission.png\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction BillCard() {\n  _HtmlCard[\"default\"].call(this);\n}\n_mxUtils[\"default\"].extend(BillCard, _HtmlCard[\"default\"]);\nBillCard.prototype.getCardHTML = function (props) {\n  var data = {};\n  var tpl = null;\n  if (props.lock) {\n    tpl = _HtmlTemplates.billCardLockedTpl;\n    data = {\n      lock: props.lock,\n      title: props.title,\n      lockIcon: _noPermission[\"default\"],\n      lockTip: props.lockTip\n    };\n  } else {\n    tpl = _HtmlTemplates.billCardTpl;\n    data = {\n      title: props.title,\n      subtitle: props.subtitle,\n      name: props.name,\n      department: props.department,\n      note: props.status\n    };\n    if (props.hasCustomRelation) {\n      data.billIcon = _icon_custom_relation[\"default\"];\n    }\n  }\n  return _templateWeb[\"default\"].render(tpl, {\n    styles: _BillCard[\"default\"],\n    data: data\n  });\n};\nBillCard.prototype.getActivatedStyleClass = function () {\n  return _BillCard[\"default\"].activatedCard;\n};\nvar _default = exports[\"default\"] = BillCard;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxGraph/BillCard.js?");

/***/ }),

/***/ "./src/workflow/mxGraph/CardMouseListener.js":
/*!***************************************************!*\
  !*** ./src/workflow/mxGraph/CardMouseListener.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.for-each.js */ \"../../node_modules/core-js/modules/es.array.for-each.js\");\n__webpack_require__(/*! core-js/modules/es.object.to-string.js */ \"../../node_modules/core-js/modules/es.object.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.regexp.exec.js */ \"../../node_modules/core-js/modules/es.regexp.exec.js\");\n__webpack_require__(/*! core-js/modules/es.string.replace.js */ \"../../node_modules/core-js/modules/es.string.replace.js\");\n__webpack_require__(/*! core-js/modules/web.dom-collections.for-each.js */ \"../../node_modules/core-js/modules/web.dom-collections.for-each.js\");\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"webpack/sharing/consume/default/react/react?dca2\"));\nvar _reactDom = _interopRequireDefault(__webpack_require__(/*! react-dom */ \"webpack/sharing/consume/default/react-dom/react-dom?418d\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _StatusTip = _interopRequireDefault(__webpack_require__(/*! ./StatusTip.js */ \"./src/workflow/mxGraph/StatusTip.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction CardMouseListener(graph, subscribeEvent) {\n  var _this = this;\n  this.graph = graph;\n  subscribeEvent('renderTooltipData', function () {\n    var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var datas = args[0];\n    var tipContainer = graph.container.querySelector(\"#\".concat(_this.tipId));\n    datas.forEach(function (data) {\n      _reactDom[\"default\"].render( /*#__PURE__*/_react[\"default\"].createElement(_StatusTip[\"default\"], {\n        datas: data\n      }), tipContainer);\n    });\n  });\n}\nCardMouseListener.prototype.graph = null;\nCardMouseListener.prototype.clickedIconCellId = null;\nCardMouseListener.prototype.activedIconCellId = null;\nCardMouseListener.prototype.activedCardId = null;\nCardMouseListener.prototype.tipId = \"status-tip-container\";\nCardMouseListener.prototype.shapeRegex = /shape=ierp\\.billrelation\\.Icon([a-zA-Z]+?);.*/;\nCardMouseListener.prototype.activeShapeRegex = /shape=ierp\\.billrelation\\.Icon[a-zA-Z]+?_Active;.*/;\nCardMouseListener.prototype.mouseDown = function (sender, me) {\n  var cell = me.getCell();\n  if (cell && this.clickedIconCellId === cell.getId()) {\n    return;\n  }\n  var activeCell = sender.getModel().getCell(this.clickedIconCellId);\n  if (activeCell) {\n    if (this.leaveIcon(sender, activeCell)) {\n      this.clickedIconCellId = null;\n      if (activeCell && activeCell.getId() == this.activedIconCellId) {\n        this.activedIconCellId = null;\n      }\n      var tipContainer = sender.container.querySelector(\"#\".concat(this.tipId));\n      if (tipContainer) {\n        tipContainer.style.display = 'none';\n      }\n    }\n  }\n  if (cell && cell.isVertex() && this.hasPlugin(cell)) {\n    //hover - mousemown\n    if (this.activeShapeRegex.test(cell.style) || this.hoverIcon(sender, cell)) {\n      this.clickedIconCellId = cell.getId();\n      this.renderLabelTips(sender, me);\n    }\n  }\n};\nCardMouseListener.prototype.mouseMove = function (sender, me) {\n  if (this.clicked) {\n    return;\n  }\n  var cell = me.getCell();\n  if (cell && this.activedIconCellId === cell.getId()) {\n    return;\n  }\n  if (this.activedIconCellId !== this.clickedIconCellId) {\n    var activeCell = sender.getModel().getCell(this.activedIconCellId);\n    if (activeCell != null) {\n      this.dragLeave(me.getEvent(), sender, activeCell);\n    }\n  }\n  if (cell && cell.isVertex() && this.hasPlugin(cell)) {\n    this.dragEnter(me.getEvent(), sender, cell);\n  }\n};\nCardMouseListener.prototype.mouseUp = function (sender, me) {\n  var cell = me.getCell();\n  if (cell && this.activedCardId === cell.getId()) {\n    return;\n  }\n  var view = sender && sender.view;\n  var activeCard = sender.getModel().getCell(this.activedCardId);\n  if (view && activeCard) {\n    var activeState = view.getState(activeCard);\n    var div = activeState.shape.cardnode;\n    var activatedStyleClass = activeState.shape.getActivatedStyleClass();\n    _mxGraphUtils[\"default\"].removeClass(div, activatedStyleClass);\n    resetRelationGraphCellStyle(sender, activeCard);\n    this.activedCardId = null;\n    var props = activeCard.properties;\n    if (!(props && props.lock)) {\n      sender.invokeCustomEvent('deselectCard', props);\n    }\n  }\n  if (cell && /billCard|stackedCard/.test(cell.type)) {\n    this.activedCardId = cell.getId();\n  }\n  function resetRelationGraphCellStyle(graph, cell) {\n    try {\n      var ids = cell.lineIds;\n      if (ids) {\n        var elts = [];\n        var model = graph.getModel();\n        for (var i = 0; i < ids.length; i++) {\n          elts.push(model.getCell(ids[i]));\n        }\n        graph.setCellStyles(\"strokeColor\", \"#A1CFFF!important\", elts);\n        var ret = [];\n        var cardCells = [];\n        var cells = model.cells;\n        for (var key in cells) {\n          var _cell = cells[key];\n          if (_mxGraphUtils[\"default\"].isBillRelationCard(_cell.type)) {\n            cardCells.push(_cell);\n            continue;\n          }\n          if (_cell.vertex || _cell.edge) {\n            ret.push(_cell);\n          }\n        }\n        graph.setCellStyles(\"opacity\", \"100\", ret);\n        _mxGraphUtils[\"default\"].setBillRelationCardOpacity(graph, cardCells, 100);\n      }\n    } catch (e) {\n      console.log(e);\n    }\n  }\n};\nCardMouseListener.prototype.dragEnter = function (evt, graph, cell) {\n  if (this.hoverIcon(graph, cell)) {\n    this.activedIconCellId = cell.getId();\n  }\n};\nCardMouseListener.prototype.dragLeave = function (evt, graph, cell) {\n  if (this.leaveIcon(graph, cell)) {\n    this.activedIconCellId = null;\n  }\n};\nCardMouseListener.prototype.hoverIcon = function (graph, cell) {\n  var style = cell.style;\n  if (this.shapeRegex.test(style)) {\n    var shape = style.replace(this.shapeRegex, '$1');\n    var newStyle = style.replace(shape, \"\".concat(shape, \"_Active\"));\n    graph.setCellStyle(newStyle, [cell]);\n    return true;\n  }\n  return false;\n};\nCardMouseListener.prototype.leaveIcon = function (graph, cell) {\n  var style = cell.style;\n  if (this.activeShapeRegex.test(style)) {\n    var newStyle = style.replace('_Active', '');\n    graph.setCellStyle(newStyle, [cell]);\n    return true;\n  }\n  return false;\n};\nCardMouseListener.prototype.renderLabelTips = function (graph, me) {\n  var container = graph && graph.container;\n  if (!container) {\n    return;\n  }\n  var tipContainer = container.querySelector(\"#\".concat(this.tipId));\n  var cell = me.state && me.state.cell;\n  if (cell && this.activeShapeRegex.test(cell.style)) {\n    var height = 112;\n    var width = 212;\n    var scale = graph.view.scale || 1;\n    if (!tipContainer) {\n      tipContainer = document.createElement('div');\n      tipContainer.id = this.tipId;\n      tipContainer.style.height = \"\".concat(height, \"px\");\n      tipContainer.style.width = \"\".concat(width, \"px\");\n      tipContainer.style.position = 'absolute';\n      container.appendChild(tipContainer);\n    }\n    tipContainer.style.display = 'block';\n    tipContainer.style.transform = \"scale(\".concat(scale, \")\");\n    var deviation = (scale * width - width) / 2;\n    tipContainer.style.left = me.state.x + me.state.width + deviation + 'px';\n    tipContainer.style.top = me.state.y - (height - me.state.height) / 2 + 'px';\n    var datas = cell.properties;\n    _reactDom[\"default\"].render( /*#__PURE__*/_react[\"default\"].createElement(_StatusTip[\"default\"], {\n      datas: datas\n    }), tipContainer);\n    graph.invokeCustomEvent('afterShowIconTip', datas);\n  } else {\n    if (tipContainer) {\n      tipContainer.style.display = 'none';\n    }\n  }\n};\nCardMouseListener.prototype.reset = function (graph) {\n  this.clickedIconCellId = null;\n  this.activedIconCellId = null;\n  this.activedCardId = null;\n  var tipContainer = graph.container.querySelector(\"#\".concat(this.tipId));\n  if (tipContainer) {\n    tipContainer.style.display = 'none';\n  }\n};\nCardMouseListener.prototype.hasPlugin = function (cell) {\n  return cell.properties && cell.properties.plugin;\n};\nvar _default = exports[\"default\"] = CardMouseListener;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxGraph/CardMouseListener.js?");

/***/ }),

/***/ "./src/workflow/mxGraph/ColorDialog.js":
/*!*********************************************!*\
  !*** ./src/workflow/mxGraph/ColorDialog.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.splice.js */ \"../../node_modules/core-js/modules/es.array.splice.js\");\n__webpack_require__(/*! core-js/modules/es.function.bind.js */ \"../../node_modules/core-js/modules/es.function.bind.js\");\nvar _mxEventObject = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxEventObject.js */ \"./src/workflow/mxClient/mxEventObject.js\"));\nvar _mxClient = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxClient.js */ \"./src/workflow/mxClient/mxClient.js\"));\nvar _mxEvent = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxEvent.js */ \"./src/workflow/mxClient/mxEvent.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxResources = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxResources.js */ \"./src/workflow/mxClient/mxResources.js\"));\nvar _mxUtils = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxUtils.js */ \"./src/workflow/mxClient/mxUtils.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nvar ColorDialog = function ColorDialog(editorUi, color, apply, cancelFn) {\n  this.editorUi = editorUi;\n  var input = document.createElement('input');\n  input.style.marginBottom = '10px';\n  input.style.width = '216px';\n\n  // Required for picker to render in IE\n  if (_mxClient[\"default\"].IS_IE) {\n    input.style.marginTop = '10px';\n    document.body.appendChild(input);\n  }\n  this.init = function () {\n    if (!_mxClient[\"default\"].IS_TOUCH) {\n      input.focus();\n    }\n  };\n  var picker = new jscolor.color(input);\n  picker.pickerOnfocus = false;\n  picker.showPicker();\n  var div = document.createElement('div');\n  jscolor.picker.box.style.position = 'relative';\n  jscolor.picker.box.style.width = '230px';\n  jscolor.picker.box.style.height = '100px';\n  jscolor.picker.box.style.paddingBottom = '10px';\n  div.appendChild(jscolor.picker.box);\n  var center = document.createElement('center');\n  function addPresets(presets, rowLength, defaultColor) {\n    rowLength = rowLength != null ? rowLength : 12;\n    var table = document.createElement('table');\n    table.style.borderCollapse = 'collapse';\n    table.setAttribute('cellspacing', '0');\n    table.style.marginBottom = '20px';\n    table.style.cellSpacing = '0px';\n    var tbody = document.createElement('tbody');\n    table.appendChild(tbody);\n    var rows = presets.length / rowLength;\n    for (var row = 0; row < rows; row++) {\n      var tr = document.createElement('tr');\n      for (var i = 0; i < rowLength; i++) {\n        (function (clr) {\n          var td = document.createElement('td');\n          td.style.border = '1px solid black';\n          td.style.padding = '0px';\n          td.style.width = '16px';\n          td.style.height = '16px';\n          if (clr == null) {\n            clr = defaultColor;\n          }\n          if (clr == 'none') {\n            td.style.background = 'url(\\'' + Dialog.prototype.noColorImage + '\\')';\n          } else {\n            td.style.backgroundColor = '#' + clr;\n          }\n          tr.appendChild(td);\n          if (clr != null) {\n            td.style.cursor = 'pointer';\n            _mxEvent[\"default\"].addListener(td, 'click', function () {\n              if (clr == 'none') {\n                picker.fromString('ffffff');\n                input.value = 'none';\n              } else {\n                picker.fromString(clr);\n              }\n            });\n          }\n        })(presets[row * rowLength + i]);\n      }\n      tbody.appendChild(tr);\n    }\n    center.appendChild(table);\n    return table;\n  }\n  ;\n  div.appendChild(input);\n  _mxUtils[\"default\"].br(div);\n\n  // Adds recent colors\n  var table = addPresets(ColorDialog.recentColors.length == 0 ? ['FFFFFF'] : ColorDialog.recentColors, 12, 'FFFFFF');\n  table.style.marginBottom = '8px';\n\n  // Adds presets\n  var table = addPresets(['E6D0DE', 'CDA2BE', 'B5739D', 'E1D5E7', 'C3ABD0', 'A680B8', 'D4E1F5', 'A9C4EB', '7EA6E0', 'D5E8D4', '9AC7BF', '67AB9F', 'D5E8D4', 'B9E0A5', '97D077', 'FFF2CC', 'FFE599', 'FFD966', 'FFF4C3', 'FFCE9F', 'FFB570', 'F8CECC', 'F19C99', 'EA6B66'], 12);\n  table.style.marginBottom = '8px';\n  table = addPresets(['none', 'FFFFFF', 'E6E6E6', 'CCCCCC', 'B3B3B3', '999999', '808080', '666666', '4D4D4D', '333333', '1A1A1A', '000000', 'FFCCCC', 'FFE6CC', 'FFFFCC', 'E6FFCC', 'CCFFCC', 'CCFFE6', 'CCFFFF', 'CCE5FF', 'CCCCFF', 'E5CCFF', 'FFCCFF', 'FFCCE6', 'FF9999', 'FFCC99', 'FFFF99', 'CCFF99', '99FF99', '99FFCC', '99FFFF', '99CCFF', '9999FF', 'CC99FF', 'FF99FF', 'FF99CC', 'FF6666', 'FFB366', 'FFFF66', 'B3FF66', '66FF66', '66FFB3', '66FFFF', '66B2FF', '6666FF', 'B266FF', 'FF66FF', 'FF66B3', 'FF3333', 'FF9933', 'FFFF33', '99FF33', '33FF33', '33FF99', '33FFFF', '3399FF', '3333FF', '9933FF', 'FF33FF', 'FF3399', 'FF0000', 'FF8000', 'FFFF00', '80FF00', '00FF00', '00FF80', '00FFFF', '007FFF', '0000FF', '7F00FF', 'FF00FF', 'FF0080', 'CC0000', 'CC6600', 'CCCC00', '66CC00', '00CC00', '00CC66', '00CCCC', '0066CC', '0000CC', '6600CC', 'CC00CC', 'CC0066', '990000', '994C00', '999900', '4D9900', '009900', '00994D', '009999', '004C99', '000099', '4C0099', '990099', '99004D', '660000', '663300', '666600', '336600', '006600', '006633', '006666', '003366', '000066', '330066', '660066', '660033', '330000', '331A00', '333300', '1A3300', '003300', '00331A', '003333', '001933', '000033', '190033', '330033', '33001A']);\n  table.style.marginBottom = '16px';\n  div.appendChild(center);\n  var buttons = document.createElement('div');\n  buttons.style.textAlign = 'right';\n  buttons.style.whiteSpace = 'nowrap';\n  var cancelBtn = _mxUtils[\"default\"].button(_mxResources[\"default\"].get('cancel'), function () {\n    editorUi.hideDialog();\n    if (cancelFn != null) {\n      cancelFn();\n    }\n  });\n  cancelBtn.className = 'geBtn';\n  if (editorUi.editor.cancelFirst) {\n    buttons.appendChild(cancelBtn);\n  }\n  var applyFunction = apply != null ? apply : this.createApplyFunction();\n  var applyBtn = _mxUtils[\"default\"].button(_mxResources[\"default\"].get('apply'), function () {\n    var color = input.value;\n    ColorDialog.addRecentColor(color, 12);\n    if (color != 'none' && color.charAt(0) != '#') {\n      color = '#' + color;\n    }\n    applyFunction(color);\n    editorUi.hideDialog();\n  });\n  applyBtn.className = 'geBtn gePrimaryBtn';\n  buttons.appendChild(applyBtn);\n  if (!editorUi.editor.cancelFirst) {\n    buttons.appendChild(cancelBtn);\n  }\n  if (color != null) {\n    if (color == 'none') {\n      picker.fromString('ffffff');\n      input.value = 'none';\n    } else {\n      picker.fromString(color);\n    }\n  }\n  div.appendChild(buttons);\n  this.picker = picker;\n  this.colorInput = input;\n\n  // LATER: Only fires if input if focused, should always\n  // fire if this dialog is showing.\n  _mxEvent[\"default\"].addListener(div, 'keydown', function (e) {\n    if (e.keyCode == 27) {\n      editorUi.hideDialog();\n      if (cancelFn != null) {\n        cancelFn();\n      }\n      _mxEvent[\"default\"].consume(e);\n    }\n  });\n  this.container = div;\n};\n\n/* Creates function to apply value */\nColorDialog.prototype.createApplyFunction = function () {\n  return _mxGraphUtils[\"default\"].bind(this, function (color) {\n    var graph = this.editorUi.editor.graph;\n    graph.getModel().beginUpdate();\n    try {\n      graph.setCellStyles(this.currentColorKey, color);\n      this.editorUi.fireEvent(new _mxEventObject[\"default\"]('styleChanged', 'keys', [this.currentColorKey], 'values', [color], 'cells', graph.getSelectionCells()));\n    } finally {\n      graph.getModel().endUpdate();\n    }\n  });\n};\n\n/**\r\n * \r\n */\nColorDialog.recentColors = [];\n\n/**\r\n * Adds recent color for later use.\r\n */\nColorDialog.addRecentColor = function (color, max) {\n  if (color != null) {\n    _mxUtils[\"default\"].remove(color, ColorDialog.recentColors);\n    ColorDialog.recentColors.splice(0, 0, color);\n    if (ColorDialog.recentColors.length > max) {\n      ColorDialog.recentColors.pop();\n    }\n  }\n};\n\n/**\r\n * Constructs a new about dialog.\r\n */\nvar _default = exports[\"default\"] = ColorDialog;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxGraph/ColorDialog.js?");

/***/ }),

/***/ "./src/workflow/mxGraph/Dialog.js":
/*!****************************************!*\
  !*** ./src/workflow/mxGraph/Dialog.js ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.function.bind.js */ \"../../node_modules/core-js/modules/es.function.bind.js\");\nvar _mxEventObject = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxEventObject.js */ \"./src/workflow/mxClient/mxEventObject.js\"));\nvar _mxClient = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxClient.js */ \"./src/workflow/mxClient/mxClient.js\"));\nvar _mxPopupMenu = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxPopupMenu.js */ \"./src/workflow/mxClient/mxPopupMenu.js\"));\nvar _mxResources = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxResources.js */ \"./src/workflow/mxClient/mxResources.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxDivResizer = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxDivResizer.js */ \"./src/workflow/mxClient/mxDivResizer.js\"));\nvar _mxEvent = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxEvent.js */ \"./src/workflow/mxClient/mxEvent.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction Dialog(editorUi, elt, w, h, modal, closable, onClose) {\n  var dx = 0;\n  if (_mxClient[\"default\"].IS_VML && (document.documentMode == null || document.documentMode < 8)) {\n    // Adds padding as a workaround for box model in older IE versions\n    // This needs to match the total padding of geDialog in CSS\n    dx = 80;\n  }\n  w += dx;\n  h += dx;\n  var left = Math.max(0, Math.round((document.body.scrollWidth - w) / 2));\n  var top = Math.max(0, Math.round((Math.max(document.body.scrollHeight, document.documentElement.scrollHeight) - h) / 3));\n\n  // Increments zIndex to put subdialogs and background over existing dialogs and background\n  if (editorUi.dialogs.length > 0) {\n    this.zIndex += editorUi.dialogs.length * 2;\n  }\n  var div = editorUi.createDiv('geDialog');\n  div.style.width = w + 'px';\n  div.style.height = h + 'px';\n  div.style.left = left + 'px';\n  div.style.top = top + 'px';\n  div.style.zIndex = this.zIndex;\n  if (this.bg == null) {\n    this.bg = editorUi.createDiv('background');\n    this.bg.style.position = 'absolute';\n    this.bg.style.background = 'white';\n    this.bg.style.left = '0px';\n    this.bg.style.top = '0px';\n    this.bg.style.bottom = '0px';\n    this.bg.style.right = '0px';\n    this.bg.style.zIndex = this.zIndex - 2;\n    _mxGraphUtils[\"default\"].setOpacity(this.bg, this.bgOpacity);\n    if (_mxClient[\"default\"].IS_QUIRKS) {\n      new _mxDivResizer[\"default\"](this.bg);\n    }\n  }\n  if (modal) {\n    document.body.appendChild(this.bg);\n  }\n  div.appendChild(elt);\n  document.body.appendChild(div);\n  if (closable) {\n    var img = document.createElement('img');\n    img.setAttribute('src', Dialog.prototype.closeImage);\n    img.setAttribute('title', _mxResources[\"default\"].get('close'));\n    img.className = 'geDialogClose';\n    img.style.top = top + 14 + 'px';\n    img.style.left = left + w + 38 - dx + 'px';\n    img.style.zIndex = this.zIndex;\n    _mxEvent[\"default\"].addListener(img, 'click', _mxGraphUtils[\"default\"].bind(this, function () {\n      editorUi.hideDialog(true);\n    }));\n    document.body.appendChild(img);\n    this.dialogImg = img;\n    _mxEvent[\"default\"].addListener(this.bg, 'click', _mxGraphUtils[\"default\"].bind(this, function () {\n      editorUi.hideDialog(true);\n    }));\n  }\n  this.onDialogClose = onClose;\n  this.container = div;\n  editorUi.editor.fireEvent(new _mxEventObject[\"default\"]('showDialog'));\n}\n;\n\n/**\r\n * \r\n */\nDialog.prototype.zIndex = _mxPopupMenu[\"default\"].prototype.zIndex - 1;\n\n/**\r\n * \r\n */\nDialog.prototype.noColorImage = !_mxClient[\"default\"].IS_SVG ? IMAGE_PATH + '/nocolor.png' : 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyBpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBXaW5kb3dzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOkEzRDlBMUUwODYxMTExRTFCMzA4RDdDMjJBMEMxRDM3IiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOkEzRDlBMUUxODYxMTExRTFCMzA4RDdDMjJBMEMxRDM3Ij4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6QTNEOUExREU4NjExMTFFMUIzMDhEN0MyMkEwQzFEMzciIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6QTNEOUExREY4NjExMTFFMUIzMDhEN0MyMkEwQzFEMzciLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz5xh3fmAAAABlBMVEX////MzMw46qqDAAAAGElEQVR42mJggAJGKGAYIIGBth8KAAIMAEUQAIElnLuQAAAAAElFTkSuQmCC';\n\n/**\r\n * \r\n */\nDialog.prototype.closeImage = !_mxClient[\"default\"].IS_SVG ? IMAGE_PATH + '/close.png' : 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJAQMAAADaX5RTAAAABlBMVEV7mr3///+wksspAAAAAnRSTlP/AOW3MEoAAAAdSURBVAgdY9jXwCDDwNDRwHCwgeExmASygSL7GgB12QiqNHZZIwAAAABJRU5ErkJggg==';\n\n/**\r\n * \r\n */\nDialog.prototype.clearImage = !_mxClient[\"default\"].IS_SVG ? IMAGE_PATH + '/clear.gif' : 'data:image/gif;base64,R0lGODlhDQAKAIABAMDAwP///yH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS4wLWMwNjAgNjEuMTM0Nzc3LCAyMDEwLzAyLzEyLTE3OjMyOjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IFdpbmRvd3MiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OUIzOEM1NzI4NjEyMTFFMUEzMkNDMUE3NjZERDE2QjIiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OUIzOEM1NzM4NjEyMTFFMUEzMkNDMUE3NjZERDE2QjIiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5QjM4QzU3MDg2MTIxMUUxQTMyQ0MxQTc2NkREMTZCMiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo5QjM4QzU3MTg2MTIxMUUxQTMyQ0MxQTc2NkREMTZCMiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PgH//v38+/r5+Pf29fTz8vHw7+7t7Ovq6ejn5uXk4+Lh4N/e3dzb2tnY19bV1NPS0dDPzs3My8rJyMfGxcTDwsHAv769vLu6ubi3trW0s7KxsK+urayrqqmop6alpKOioaCfnp2cm5qZmJeWlZSTkpGQj46NjIuKiYiHhoWEg4KBgH9+fXx7enl4d3Z1dHNycXBvbm1sa2ppaGdmZWRjYmFgX15dXFtaWVhXVlVUU1JRUE9OTUxLSklIR0ZFRENCQUA/Pj08Ozo5ODc2NTQzMjEwLy4tLCsqKSgnJiUkIyIhIB8eHRwbGhkYFxYVFBMSERAPDg0MCwoJCAcGBQQDAgEAACH5BAEAAAEALAAAAAANAAoAAAIXTGCJebD9jEOTqRlttXdrB32PJ2ncyRQAOw==';\n\n/**\r\n * \r\n */\nDialog.prototype.lockedImage = !_mxClient[\"default\"].IS_SVG ? IMAGE_PATH + '/locked.png' : 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAMAAABhq6zVAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MzdDMDZCODExNzIxMTFFNUI0RTk5NTg4OTcyMUUyODEiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MzdDMDZCODIxNzIxMTFFNUI0RTk5NTg4OTcyMUUyODEiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDozN0MwNkI3RjE3MjExMUU1QjRFOTk1ODg5NzIxRTI4MSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDozN0MwNkI4MDE3MjExMUU1QjRFOTk1ODg5NzIxRTI4MSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PvqMCFYAAAAVUExURZmZmb+/v7KysqysrMzMzLGxsf///4g8N1cAAAAHdFJOU////////wAaSwNGAAAAPElEQVR42lTMQQ4AIQgEwUa0//9kTQirOweYOgDqAMbZUr10AGlAwx4/BJ2QJ4U0L5brYjovvpv32xZgAHZaATFtMbu4AAAAAElFTkSuQmCC';\n\n/**\r\n * \r\n */\nDialog.prototype.unlockedImage = !_mxClient[\"default\"].IS_SVG ? IMAGE_PATH + '/unlocked.png' : 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAMAAABhq6zVAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MzdDMDZCN0QxNzIxMTFFNUI0RTk5NTg4OTcyMUUyODEiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MzdDMDZCN0UxNzIxMTFFNUI0RTk5NTg4OTcyMUUyODEiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDozN0MwNkI3QjE3MjExMUU1QjRFOTk1ODg5NzIxRTI4MSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDozN0MwNkI3QzE3MjExMUU1QjRFOTk1ODg5NzIxRTI4MSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PkKMpVwAAAAYUExURZmZmbKysr+/v6ysrOXl5czMzLGxsf///zHN5lwAAAAIdFJOU/////////8A3oO9WQAAADxJREFUeNpUzFESACAEBNBVsfe/cZJU+8Mzs8CIABCidtfGOndnYsT40HDSiCcbPdoJo10o9aI677cpwACRoAF3dFNlswAAAABJRU5ErkJggg==';\n\n/**\r\n * Removes the dialog from the DOM.\r\n */\nDialog.prototype.bgOpacity = 80;\n\n/**\r\n * Removes the dialog from the DOM.\r\n */\nDialog.prototype.close = function (cancel) {\n  if (this.onDialogClose != null) {\n    this.onDialogClose(cancel);\n    this.onDialogClose = null;\n  }\n  if (this.dialogImg != null) {\n    this.dialogImg.parentNode.removeChild(this.dialogImg);\n    this.dialogImg = null;\n  }\n  if (this.bg != null && this.bg.parentNode != null) {\n    this.bg.parentNode.removeChild(this.bg);\n  }\n  this.container.parentNode.removeChild(this.container);\n};\n\n/**\r\n * Constructs a new open dialog.\r\n */\nvar _default = exports[\"default\"] = Dialog;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxGraph/Dialog.js?");

/***/ }),

/***/ "./src/workflow/mxGraph/EditDataDialog.js":
/*!************************************************!*\
  !*** ./src/workflow/mxGraph/EditDataDialog.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.index-of.js */ \"../../node_modules/core-js/modules/es.array.index-of.js\");\n__webpack_require__(/*! core-js/modules/es.array.splice.js */ \"../../node_modules/core-js/modules/es.array.splice.js\");\nvar _mxClient = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxClient.js */ \"./src/workflow/mxClient/mxClient.js\"));\nvar _mxEvent = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxEvent.js */ \"./src/workflow/mxClient/mxEvent.js\"));\nvar _mxForm = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxForm.js */ \"./src/workflow/mxClient/mxForm.js\"));\nvar _mxResources = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxResources.js */ \"./src/workflow/mxClient/mxResources.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxUtils = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxUtils.js */ \"./src/workflow/mxClient/mxUtils.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nvar EditDataDialog = function EditDataDialog(ui, cell) {\n  var div = document.createElement('div');\n  var graph = ui.editor.graph;\n  div.style.height = '310px';\n  div.style.overflow = 'auto';\n  var value = graph.getModel().getValue(cell);\n\n  // Converts the value to an XML node\n  if (!_mxGraphUtils[\"default\"].isNode(value)) {\n    var doc = _mxUtils[\"default\"].createXmlDocument();\n    var obj = doc.createElement('object');\n    obj.setAttribute('label', value || '');\n    value = obj;\n  }\n\n  // Creates the dialog contents\n  var form = new _mxForm[\"default\"]('properties');\n  form.table.style.width = '100%';\n  form.table.style.paddingRight = '20px';\n  var attrs = value.attributes;\n  var names = [];\n  var texts = [];\n  var count = 0;\n\n  // FIXME: Fix remove button for quirks mode\n  var addRemoveButton = function addRemoveButton(text, name) {\n    text.parentNode.style.marginRight = '12px';\n    var removeAttr = document.createElement('a');\n    var img = _mxUtils[\"default\"].createImage(Dialog.prototype.closeImage);\n    img.style.height = '9px';\n    img.style.fontSize = '9px';\n    img.style.marginBottom = '7px';\n    removeAttr.className = 'geButton';\n    removeAttr.setAttribute('title', _mxResources[\"default\"].get('delete'));\n    removeAttr.style.margin = '0px';\n    removeAttr.style.width = '14px';\n    removeAttr.style.height = '14px';\n    removeAttr.style.fontSize = '14px';\n    removeAttr.style.cursor = 'pointer';\n    removeAttr.style.marginLeft = '6px';\n    removeAttr.appendChild(img);\n    var removeAttrFn = function (name) {\n      return function () {\n        var count = 0;\n        for (var j = 0; j < names.length; j++) {\n          if (names[j] == name) {\n            texts[j] = null;\n            form.table.deleteRow(count);\n            break;\n          }\n          if (texts[j] != null) {\n            count++;\n          }\n        }\n      };\n    }(name);\n    _mxEvent[\"default\"].addListener(removeAttr, 'click', removeAttrFn);\n    text.parentNode.style.whiteSpace = 'nowrap';\n    text.parentNode.appendChild(removeAttr);\n  };\n  var addTextArea = function addTextArea(index, name, value) {\n    names[index] = name;\n    texts[index] = form.addTextarea(names[count] + ':', value, 2);\n    texts[index].style.width = '100%';\n    addRemoveButton(texts[index], name);\n  };\n  for (var i = 0; i < attrs.length; i++) {\n    if (attrs[i].nodeName != 'label' && attrs[i].nodeName != 'placeholders') {\n      addTextArea(count, attrs[i].nodeName, attrs[i].nodeValue);\n      count++;\n    }\n  }\n  div.appendChild(form.table);\n  var newProp = document.createElement('div');\n  newProp.style.whiteSpace = 'nowrap';\n  newProp.style.marginTop = '6px';\n  var nameInput = document.createElement('input');\n  nameInput.setAttribute('placeholder', _mxResources[\"default\"].get('enterPropertyName'));\n  nameInput.setAttribute('type', 'text');\n  nameInput.setAttribute('size', _mxClient[\"default\"].IS_QUIRKS ? '18' : '22');\n  nameInput.style.marginLeft = '2px';\n  newProp.appendChild(nameInput);\n  div.appendChild(newProp);\n  var addBtn = _mxUtils[\"default\"].button(_mxResources[\"default\"].get('addProperty'), function () {\n    if (nameInput.value.length > 0) {\n      var name = nameInput.value;\n      if (name != null && name.length > 0 && name != 'label' && name != 'placeholders') {\n        try {\n          var idx = _mxGraphUtils[\"default\"].indexOf(names, name);\n          if (idx >= 0 && texts[idx] != null) {\n            texts[idx].focus();\n          } else {\n            // Checks if the name is valid\n            var clone = value.cloneNode(false);\n            clone.setAttribute(name, '');\n            if (idx >= 0) {\n              names.splice(idx, 1);\n              texts.splice(idx, 1);\n            }\n            names.push(name);\n            var text = form.addTextarea(name + ':', '', 2);\n            text.style.width = '100%';\n            texts.push(text);\n            addRemoveButton(text, name);\n            text.focus();\n          }\n          nameInput.value = '';\n        } catch (e) {\n          _mxUtils[\"default\"].alert(e);\n        }\n      }\n    } else {\n      _mxUtils[\"default\"].alert(_mxResources[\"default\"].get('invalidName'));\n    }\n  });\n  this.init = function () {\n    if (texts.length > 0) {\n      texts[0].focus();\n    } else {\n      nameInput.focus();\n    }\n  };\n  addBtn.setAttribute('disabled', 'disabled');\n  addBtn.style.marginLeft = '10px';\n  addBtn.style.width = '144px';\n  newProp.appendChild(addBtn);\n  var cancelBtn = _mxUtils[\"default\"].button(_mxResources[\"default\"].get('cancel'), function () {\n    ui.hideDialog.apply(ui, arguments);\n  });\n  cancelBtn.className = 'geBtn';\n  var applyBtn = _mxUtils[\"default\"].button(_mxResources[\"default\"].get('apply'), function () {\n    try {\n      ui.hideDialog.apply(ui, arguments);\n\n      // Clones and updates the value\n      value = {};\n      /*value = value.cloneNode(true);\r\n      \r\n      for (var i = 0; i < names.length; i++)\r\n      {\r\n      \tif (texts[i] == null)\r\n      \t{\r\n      \t\tvalue.removeAttribute(names[i]);\r\n      \t}\r\n      \telse\r\n      \t{\r\n      \t\tvalue.setAttribute(names[i], texts[i].value);\r\n      \t}\r\n      }*/\n\n      // Updates the value of the cell (undoable)\n      graph.getModel().setValue(cell, value);\n    } catch (e) {\n      _mxUtils[\"default\"].alert(e);\n    }\n  });\n  applyBtn.className = 'geBtn gePrimaryBtn';\n  function updateAddBtn() {\n    if (nameInput.value.length > 0) {\n      addBtn.removeAttribute('disabled');\n    } else {\n      addBtn.setAttribute('disabled', 'disabled');\n    }\n  }\n  ;\n  _mxEvent[\"default\"].addListener(nameInput, 'keyup', updateAddBtn);\n\n  // Catches all changes that don't fire a keyup (such as paste via mouse)\n  _mxEvent[\"default\"].addListener(nameInput, 'change', updateAddBtn);\n  var buttons = document.createElement('div');\n  buttons.style.marginTop = '18px';\n  buttons.style.textAlign = 'right';\n  if (ui.editor.graph.getModel().isVertex(cell) || ui.editor.graph.getModel().isEdge(cell)) {\n    var replace = document.createElement('span');\n    replace.style.marginRight = '10px';\n    var input = document.createElement('input');\n    input.setAttribute('type', 'checkbox');\n    input.style.marginRight = '6px';\n\n    /*if (value.getAttribute('placeholders') == '1')\r\n    {\r\n    \tinput.setAttribute('checked', 'checked');\r\n    \tinput.defaultChecked = true;\r\n    }*/\n\n    _mxEvent[\"default\"].addListener(input, 'click', function () {\n      /*if (value.getAttribute('placeholders') == '1')\r\n      {\r\n      \tvalue.removeAttribute('placeholders');\r\n      }\r\n      else\r\n      {\r\n      \tvalue.setAttribute('placeholders', '1');\r\n      }*/\n    });\n    replace.appendChild(input);\n    _mxGraphUtils[\"default\"].write(replace, _mxResources[\"default\"].get('placeholders'));\n    if (EditDataDialog.placeholderHelpLink != null) {\n      var link = document.createElement('a');\n      link.setAttribute('href', EditDataDialog.placeholderHelpLink);\n      link.setAttribute('title', _mxResources[\"default\"].get('help'));\n      link.setAttribute('target', '_blank');\n      link.style.marginLeft = '10px';\n      link.style.cursor = 'help';\n      var icon = document.createElement('img');\n      icon.setAttribute('border', '0');\n      icon.setAttribute('valign', 'middle');\n      icon.style.marginTop = '-4px';\n      icon.setAttribute('src', Editor.helpImage);\n      link.appendChild(icon);\n      replace.appendChild(link);\n    }\n    buttons.appendChild(replace);\n  }\n  if (ui.editor.cancelFirst) {\n    buttons.appendChild(cancelBtn);\n    buttons.appendChild(applyBtn);\n  } else {\n    buttons.appendChild(applyBtn);\n    buttons.appendChild(cancelBtn);\n  }\n  div.appendChild(buttons);\n  this.container = div;\n};\n\n/**\r\n * Optional help link.\r\n */\nEditDataDialog.placeholderHelpLink = null;\n\n/**\r\n * Constructs a new link dialog.\r\n */\nvar _default = exports[\"default\"] = EditDataDialog;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxGraph/EditDataDialog.js?");

/***/ }),

/***/ "./src/workflow/mxGraph/EditDiagramDialog.js":
/*!***************************************************!*\
  !*** ./src/workflow/mxGraph/EditDiagramDialog.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.string.trim.js */ \"../../node_modules/core-js/modules/es.string.trim.js\");\nvar _mxGraphModel = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxGraphModel.js */ \"./src/workflow/mxClient/mxGraphModel.js\"));\nvar _OpenFile = _interopRequireDefault(__webpack_require__(/*! ./OpenFile.js */ \"./src/workflow/mxGraph/OpenFile.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxResources = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxResources.js */ \"./src/workflow/mxClient/mxResources.js\"));\nvar _mxCodec = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxCodec.js */ \"./src/workflow/mxClient/mxCodec.js\"));\nvar _mxUtils = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxUtils.js */ \"./src/workflow/mxClient/mxUtils.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nvar EditDiagramDialog = function EditDiagramDialog(editorUi) {\n  var div = document.createElement('div');\n  div.style.textAlign = 'right';\n  var textarea = document.createElement('textarea');\n  textarea.setAttribute('wrap', 'off');\n  textarea.style.overflow = 'auto';\n  textarea.style.resize = 'none';\n  textarea.style.width = '600px';\n  textarea.style.height = '370px';\n  textarea.style.marginBottom = '16px';\n  textarea.value = _mxUtils[\"default\"].getPrettyXml(editorUi.editor.getGraphXml());\n  div.appendChild(textarea);\n  this.init = function () {\n    textarea.focus();\n  };\n\n  // Enables dropping files\n  if (Graph.fileSupport) {\n    var handleDrop = function handleDrop(evt) {\n      evt.stopPropagation();\n      evt.preventDefault();\n      if (evt.dataTransfer.files.length > 0) {\n        var file = evt.dataTransfer.files[0];\n        var reader = new FileReader();\n        reader.onload = function (e) {\n          textarea.value = e.target.result;\n        };\n        reader.readAsText(file);\n      } else {\n        textarea.value = editorUi.extractGraphModelFromEvent(evt);\n      }\n    };\n    var handleDragOver = function handleDragOver(evt) {\n      evt.stopPropagation();\n      evt.preventDefault();\n    };\n    ;\n    ;\n\n    // Setup the dnd listeners.\n    textarea.addEventListener('dragover', handleDragOver, false);\n    textarea.addEventListener('drop', handleDrop, false);\n  }\n  var cancelBtn = _mxUtils[\"default\"].button(_mxResources[\"default\"].get('cancel'), function () {\n    editorUi.hideDialog();\n  });\n  cancelBtn.className = 'geBtn';\n  if (editorUi.editor.cancelFirst) {\n    div.appendChild(cancelBtn);\n  }\n  var select = document.createElement('select');\n  select.style.width = '180px';\n  select.className = 'geBtn';\n  if (editorUi.editor.graph.isEnabled()) {\n    var replaceOption = document.createElement('option');\n    replaceOption.setAttribute('value', 'replace');\n    _mxGraphUtils[\"default\"].write(replaceOption, _mxResources[\"default\"].get('replaceExistingDrawing'));\n    select.appendChild(replaceOption);\n  }\n  var newOption = document.createElement('option');\n  newOption.setAttribute('value', 'new');\n  _mxGraphUtils[\"default\"].write(newOption, _mxResources[\"default\"].get('openInNewWindow'));\n  var chromeApp = window.chrome != null && chrome.app != null && chrome.app.runtime != null;\n  if (!chromeApp) {\n    select.appendChild(newOption);\n  }\n  if (editorUi.editor.graph.isEnabled()) {\n    var importOption = document.createElement('option');\n    importOption.setAttribute('value', 'import');\n    _mxGraphUtils[\"default\"].write(importOption, _mxResources[\"default\"].get('addToExistingDrawing'));\n    select.appendChild(importOption);\n  }\n  div.appendChild(select);\n  var okBtn = _mxUtils[\"default\"].button(_mxResources[\"default\"].get('ok'), function () {\n    // Removes all illegal control characters before parsing\n    var data = editorUi.editor.graph.zapGremlins(_mxGraphUtils[\"default\"].trim(textarea.value));\n    var error = null;\n    if (select.value == 'new') {\n      window.openFile = new _OpenFile[\"default\"](function () {\n        editorUi.hideDialog();\n        window.openFile = null;\n      });\n      window.openFile.setData(data, null);\n      window.open(editorUi.getUrl());\n    } else if (select.value == 'replace') {\n      editorUi.editor.graph.model.beginUpdate();\n      try {\n        editorUi.editor.setGraphXml(_mxUtils[\"default\"].parseXml(data).documentElement);\n        // LATER: Why is hideDialog between begin-/endUpdate faster?\n        editorUi.hideDialog();\n      } catch (e) {\n        error = e;\n      } finally {\n        editorUi.editor.graph.model.endUpdate();\n      }\n    } else if (select.value == 'import') {\n      editorUi.editor.graph.model.beginUpdate();\n      try {\n        var doc = _mxUtils[\"default\"].parseXml(data);\n        var model = new _mxGraphModel[\"default\"]();\n        var codec = new _mxCodec[\"default\"](doc);\n        codec.decode(doc.documentElement, model);\n        var children = model.getChildren(model.getChildAt(model.getRoot(), 0));\n        editorUi.editor.graph.setSelectionCells(editorUi.editor.graph.importCells(children));\n\n        // LATER: Why is hideDialog between begin-/endUpdate faster?\n        editorUi.hideDialog();\n      } catch (e) {\n        error = e;\n      } finally {\n        editorUi.editor.graph.model.endUpdate();\n      }\n    }\n    if (error != null) {\n      _mxUtils[\"default\"].alert(error.message);\n    }\n  });\n  okBtn.className = 'geBtn gePrimaryBtn';\n  div.appendChild(okBtn);\n  if (!editorUi.editor.cancelFirst) {\n    div.appendChild(cancelBtn);\n  }\n  this.container = div;\n};\n\n/**\r\n * Constructs a new export dialog.\r\n */\nvar _default = exports[\"default\"] = EditDiagramDialog;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxGraph/EditDiagramDialog.js?");

/***/ }),

/***/ "./src/workflow/mxGraph/Editor.js":
/*!****************************************!*\
  !*** ./src/workflow/mxGraph/Editor.js ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.function.bind.js */ \"../../node_modules/core-js/modules/es.function.bind.js\");\n__webpack_require__(/*! core-js/modules/es.parse-float.js */ \"../../node_modules/core-js/modules/es.parse-float.js\");\nvar _mxEventObject = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxEventObject.js */ \"./src/workflow/mxClient/mxEventObject.js\"));\nvar _mxClient = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxClient.js */ \"./src/workflow/mxClient/mxClient.js\"));\nvar _mxGraph = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxGraph.js */ \"./src/workflow/mxClient/mxGraph.js\"));\nvar _mxEvent = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxEvent.js */ \"./src/workflow/mxClient/mxEvent.js\"));\nvar _Graph = _interopRequireDefault(__webpack_require__(/*! ./Graph.js */ \"./src/workflow/mxGraph/Graph.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxResources = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxResources.js */ \"./src/workflow/mxClient/mxResources.js\"));\nvar _mxEventSource = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxEventSource.js */ \"./src/workflow/mxClient/mxEventSource.js\"));\nvar _mxUndoManager = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxUndoManager.js */ \"./src/workflow/mxClient/mxUndoManager.js\"));\nvar _mxRectangle = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxRectangle.js */ \"./src/workflow/mxClient/mxRectangle.js\"));\nvar _mxCodec = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxCodec.js */ \"./src/workflow/mxClient/mxCodec.js\"));\nvar _mxUtils = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxUtils.js */ \"./src/workflow/mxClient/mxUtils.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nvar Editor = function Editor(chromeless, themes, model, graph, formId) {\n  _mxEventSource[\"default\"].call(this);\n  this.chromeless = chromeless != null ? chromeless : this.chromeless;\n  this.initStencilRegistry();\n  this.graph = graph || this.createGraph(themes, model);\n  this.undoManager = this.createUndoManager();\n  this.status = '';\n  this.getOrCreateFilename = function () {\n    return this.filename || _mxResources[\"default\"].get('drawing', [Editor.pageCounter]) + '.xml';\n  };\n  this.getFilename = function () {\n    return this.filename;\n  };\n\n  // Sets the status and fires a statusChanged event\n  this.setStatus = function (value) {\n    this.status = value;\n    this.fireEvent(new _mxEventObject[\"default\"]('statusChanged'));\n  };\n\n  // Returns the current status\n  this.getStatus = function () {\n    return this.status;\n  };\n\n  // Updates modified state if graph changes\n  this.graphChangeListener = function () {\n    this.setModified(true);\n  };\n  this.graph.getModel().addListener(_mxEvent[\"default\"].CHANGE, _mxGraphUtils[\"default\"].bind(this, function () {\n    this.graphChangeListener.apply(this, arguments);\n  }));\n\n  // Sets persistent graph state defaults\n  this.graph.resetViewOnRootChange = false;\n  //流程设计线可以拖动；流程管理，线不可以拖动\n  if (formId == \"ide_workflowdesigner\") {\n    this.graph.edgeLabelsMovable = true;\n  } else {\n    this.graph.edgeLabelsMovable = false;\n  }\n  this.init();\n};\n\n/**\r\n * Counts open editor tabs (must be global for cross-window access)\r\n */\nEditor.pageCounter = 0;\n\n// Cross-domain window access is not allowed in FF, so if we\n// were opened from another domain then this will fail.\n(function () {\n  try {\n    var op = window;\n    while (op.opener != null && typeof op.opener.Editor !== 'undefined' && !isNaN(op.opener.Editor.pageCounter)) {\n      op = op.opener;\n    }\n\n    // Increments the counter in the first opener in the chain\n    if (op != null) {\n      op.Editor.pageCounter++;\n      Editor.pageCounter = op.Editor.pageCounter;\n    }\n  } catch (e) {\n    // ignore\n  }\n})();\n\n/**\r\n * Specifies if local storage should be used (eg. on the iPad which has no filesystem)\r\n */\nEditor.useLocalStorage = typeof Storage != 'undefined' && _mxClient[\"default\"].IS_IOS;\n\n/**\r\n * Images below are for lightbox and embedding toolbars.\r\n */\nEditor.helpImage = _mxClient[\"default\"].IS_SVG ? 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAXVBMVEUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC5BxTwAAAAH3RSTlMAlUF8boNQIE0LBgOgkGlHNSwqFIx/dGVUOjApmV9ezNACSAAAAIVJREFUGNNtjNsOgzAMQ5NeoVcKDAZs+//PXLKI8YKlWvaRU7jXuFpb9qsbdK05XILUiE8JHQox1Pv3OgFUzf1AGqWqUg+QBwLF0YAeegBlCNgRWOpB5vUfTCmeoHQ/wNdy0jLH/cM+b+wLTw4n/7ACEmHVVy8h6qy8V7MNcGowWpsNbvUFcGUEdSi1s/oAAAAASUVORK5CYII=' : IMAGE_PATH + '/help.png';\n\n/**\r\n * Sets the default font size.\r\n */\nEditor.checkmarkImage = _mxClient[\"default\"].IS_SVG ? 'data:image/gif;base64,R0lGODlhFQAVAMQfAGxsbHx8fIqKioaGhvb29nJycvr6+sDAwJqamltbW5OTk+np6YGBgeTk5Ly8vJiYmP39/fLy8qWlpa6ursjIyOLi4vj4+N/f3+3t7fT09LCwsHZ2dubm5r6+vmZmZv///yH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS4wLWMwNjAgNjEuMTM0Nzc3LCAyMDEwLzAyLzEyLTE3OjMyOjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IFdpbmRvd3MiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OEY4NTZERTQ5QUFBMTFFMUE5MTVDOTM5MUZGMTE3M0QiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OEY4NTZERTU5QUFBMTFFMUE5MTVDOTM5MUZGMTE3M0QiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Rjg1NkRFMjlBQUExMUUxQTkxNUM5MzkxRkYxMTczRCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Rjg1NkRFMzlBQUExMUUxQTkxNUM5MzkxRkYxMTczRCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PgH//v38+/r5+Pf29fTz8vHw7+7t7Ovq6ejn5uXk4+Lh4N/e3dzb2tnY19bV1NPS0dDPzs3My8rJyMfGxcTDwsHAv769vLu6ubi3trW0s7KxsK+urayrqqmop6alpKOioaCfnp2cm5qZmJeWlZSTkpGQj46NjIuKiYiHhoWEg4KBgH9+fXx7enl4d3Z1dHNycXBvbm1sa2ppaGdmZWRjYmFgX15dXFtaWVhXVlVUU1JRUE9OTUxLSklIR0ZFRENCQUA/Pj08Ozo5ODc2NTQzMjEwLy4tLCsqKSgnJiUkIyIhIB8eHRwbGhkYFxYVFBMSERAPDg0MCwoJCAcGBQQDAgEAACH5BAEAAB8ALAAAAAAVABUAAAVI4CeOZGmeaKqubKtylktSgCOLRyLd3+QJEJnh4VHcMoOfYQXQLBcBD4PA6ngGlIInEHEhPOANRkaIFhq8SuHCE1Hb8Lh8LgsBADs=' : IMAGE_PATH + '/checkmark.gif';\n\n/**\r\n * Images below are for lightbox and embedding toolbars.\r\n */\nEditor.maximizeImage = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAVBAMAAABbObilAAAAElBMVEUAAAAAAAAAAAAAAAAAAAAAAADgKxmiAAAABXRSTlMA758vX1Pw3BoAAABJSURBVAjXY8AJQkODGBhUQ0MhbAUGBiYY24CBgRnGFmZgMISwgwwDGRhEhVVBbAVmEQYGRwMmBjIAQi/CTIRd6G5AuA3dzYQBAHj0EFdHkvV4AAAAAElFTkSuQmCC';\n\n/**\r\n * Specifies the image URL to be used for the transparent background.\r\n */\nEditor.zoomOutImage = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAVBAMAAABbObilAAAAElBMVEUAAAAAAAAsLCxxcXEhISFgYGChjTUxAAAAAXRSTlMAQObYZgAAAEdJREFUCNdjIAMwCQrB2YKCggJQJqMwA7MglK1owMBgqABVApITgLJZXFxgbIQ4Qj3CHIT5ggoIe5kgNkM1KSDYKBKqxPkDAPo5BAZBE54hAAAAAElFTkSuQmCC';\n\n/**\r\n * Specifies the image URL to be used for the transparent background.\r\n */\nEditor.zoomInImage = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAVBAMAAABbObilAAAAElBMVEUAAAAAAAAsLCwhISFxcXFgYGBavKaoAAAAAXRSTlMAQObYZgAAAElJREFUCNdjIAMwCQrB2YKCggJQJqMIA4sglK3owMzgqABVwsDMwCgAZTMbG8PYCHGEeoQ5CPMFFRD2MkFshmpSQLBRJFSJ8wcAEqcEM2uhl2MAAAAASUVORK5CYII=';\n\n/**\r\n * Specifies the image URL to be used for the transparent background.\r\n */\nEditor.zoomFitImage = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAVBAMAAABbObilAAAAD1BMVEUAAAAAAAAwMDBwcHBgYGC1xl09AAAAAXRSTlMAQObYZgAAAEFJREFUCNdjIAMwCQrB2YKCggJQJqMwA7MglK1owMBgqABVApITwMdGqEeYgzBfUAFhLxPEZqgmBQQbRUKFOH8AAK5OA3lA+FFOAAAAAElFTkSuQmCC';\n\n/**\r\n * Specifies the image URL to be used for the transparent background.\r\n */\nEditor.layersImage = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAVCAMAAACeyVWkAAAAaVBMVEUAAAAgICAICAgdHR0PDw8WFhYICAgLCwsXFxcvLy8ODg4uLi4iIiIqKiokJCQYGBgKCgonJycFBQUCAgIqKiocHBwcHBwODg4eHh4cHBwnJycJCQkUFBQqKiojIyMuLi4ZGRkgICAEBATOWYXAAAAAGnRSTlMAD7+fnz8/H7/ff18/77+vr5+fn39/b28fH2xSoKsAAACQSURBVBjTrYxJEsMgDARZZMAY73sgCcn/HxnhKtnk7j6oRq0psfuoyndZ/SuODkHPLzfVT6KeyPePnJ7KrnkRjWMXTn4SMnN8mXe2SSM3ts8L/ZUxxrbAULSYJJULE0Iw9pjpenoICcgcX61mGgTgtCv9Be99pzCoDhNQWQnchD1mup5++CYGcoQexajZbfwAj/0MD8ZOaUgAAAAASUVORK5CYII=';\n\n/**\r\n * Specifies the image URL to be used for the transparent background.\r\n */\nEditor.zoomOutLargeImage = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAilBMVEUAAAD////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////2N2iNAAAALXRSTlMA+vTcKMM96GRBHwXxi0YaX1HLrKWhiHpWEOnOr52Vb2xKSDcT19PKv5l/Ngdk8+viAAABJklEQVQ4y4WT2XaDMAxEvWD2nSSUNEnTJN3r//+9Sj7ILAY6L0ijC4ONYVZRpo6cByrz2YKSUGorGTpz71lPVHvT+avoB5wIkU/mxk8veceSuNoLg44IzziXjvpih72wKQnm8yc2UoiP/LAd8jQfe2Xf4Pq+2EyYIvv9wbzHHCgwxDdlBtWZOdqDfTCVgqpygQpsZaojVAVc9UjQxnAJDIBhiQv84tq3gMQCAVTxVoSibXJf8tMuc7e1TB/DCmejBNg/w1Y3c+AM5vv4w7xM59/oXamrHaLVqPQ+OTCnmMZxgz0SdL5zji0/ld6j88qGa5KIiBB6WeJGKfUKwSMKLuXgvl1TW0tm5R9UQL/efSDYsnzxD8CinhBsTTdugJatKpJwf8v+ADb8QmvW7AeAAAAAAElFTkSuQmCC';\n\n/**\r\n * Specifies the image URL to be used for the transparent background.\r\n */\nEditor.zoomInLargeImage = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAilBMVEUAAAD////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////2N2iNAAAALXRSTlMA+vTcKMM96GRBHwXxi0YaX1HLrKWhiHpWEOnOr52Vb2xKSDcT19PKv5l/Ngdk8+viAAABKElEQVQ4y4WT6WKCMBCENwkBwn2oFKvWqr3L+79es4EkQIDOH2d3Pxk2ABiJlB8JCXjqw4LikHVGLHTm3nM3UeVN5690GBBN0GwyV/3kkrUQR+WeKnREeKpzaXWd77CmJiXGfPIEI4V4yQ9TIW/ntlcMBe731Vts9w5TWG8F5j3mQI4hvrKpdGeYA7CX9qAcl650gVJartxRuhyHVghF8idQAIbFLvCLu28BsQEC6aKtCK6Pyb3JT7PmbmtNH8Ny56CotD/2qOs5cJbuffxgXmCib+xddVU5RNOhkvvkhTlFehzVWCOh3++MYElOhfdovaImnRYVmqDdsuhNp1QrBBE6uGC2+3ZNjGdg5B94oD+9uyVgWT79BwAxEBTWdOu3bWBVgsn/N/AHUD9IC01Oe40AAAAASUVORK5CYII=';\n\n/**\r\n * Specifies the image URL to be used for the transparent background.\r\n */\nEditor.actualSizeLargeImage = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAilBMVEUAAAD////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////2N2iNAAAALXRSTlMA+vTcKMM96GRBHwXxi0YaX1HLrKWhiHpWEOnOr52Vb2xKSDcT19PKv5l/Ngdk8+viAAABIUlEQVQ4y4WT2XqDIBCFBxDc9yTWNEnTJN3r+79eGT4BEbXnaubMr8dBBaM450dCQp4LWFAascGIRd48eB4cNYE7f6XjgGiCFs5c+dml6CFN6j1V6IQIlHPpdV/usKcmJcV88gQTRXjLD9Mhb+fWq8YG9/uCmTCFjeeDeY85UGKIUGUuqzN42kv7oCouq9oHamlzVR1lVfpAIu1QVRiW+sAv7r4FpAYIZZVsRXB9TP5Dfpo1d1trCgzz1iiptH/sUbdz4CzN9+mLeXHn3+hdddd4RDegsrvzwZwSs2GLPRJidAqCLTlVwaMPqpYMWjTWBB2WRW86pVkhSKyDK2bdt2tmagZG4sBD/evdLQHLEvQfAOKRoLCmG1FAB6uKmby+gz+REDn7O5+EwQAAAABJRU5ErkJggg==';\n\n/**\r\n * Specifies the image URL to be used for the transparent background.\r\n */\nEditor.layersLargeImage = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAmVBMVEUAAAD////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////+/v7///+bnZkkAAAAMnRSTlMABPr8ByiD88KsTi/rvJb272mjeUA1CuPe1M/KjVxYHxMP6KZ0S9nYzGRGGRaznpGIbzaGUf0AAAHESURBVDjLbZLZYoIwEEVDgLCjbKIgAlqXqt3m/z+uNwu1rcyDhjl3ktnYL7OY254C0VX3yWFZfzDrOClbbgKxi0YDHjwl4jbnRkXxJS/C1YP3DbBhD1n7Ex4uaAqdVDb3yJ/4J/3nJD2to/ngQz/DfUvzMp4JJ5sSCaF5oXmemgQDfDxzbi+Kq4sU+vNcuAmx94JtyOP2DD4Epz2asWSCz4Z/4fECxyNj9zC9xNLHcdPEO+awDKeSaUu0W4twZQiO2hYVisTR3RCtK/c1X6t4xMEpiGqXqVntEBLolkZZsKY4QtwH6jzq67dEHlJysB1aNOD3XT7n1UkasQN59L4yC2RELMDSeCRtz3yV22Ub3ozIUTknYx8JWqDdQxbUes98cR2kZtUSveF/bAhcedwEWmlxIkpZUy4XOCb6VBjjxHvbwo/1lBAHHi2JCr0NI570QhyHq/DhJoE2lLgyA4RVe6KmZ47O/3b86MCP0HWa73A8/C3SUc5Qc1ajt6fgpXJ+RGpMvDSchepZDOOQRcZVIKcK90x2D7etqtI+56+u6n3sPriO6nfphitR4+O2m3EbM7lh3me1FM1o+LMI887rN+s3/wZdTFlpNVJiOAAAAABJRU5ErkJggg==';\n\n/**\r\n * Specifies the image URL to be used for the transparent background.\r\n */\nEditor.closeLargeImage = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAUVBMVEUAAAD///////////////////////////////////////////////////////////////////////////////////////////////////////8IN+deAAAAGnRSTlMAuvAIg/dDM/QlOeuFhj0S5s4vKgzjxJRQNiLSey0AAADNSURBVDjLfZLbEoMgDEQjRRRs1XqX///QNmOHJSnjPkHOGR7IEmeoGtJZstnwjqbRfIsmgEdtPCqe9Ynz7ZSc07rE2QiSc+qv8TvjRXA2PDUm3dpe82iJhOEUfxJJo3aCv+jKmRmH4lcCjCjeh9GWOdL/GZZkXH3PYYDrHBnfc4D/RVZf5sjoC1was+Y6HQxwaUxFvq/a0Pv343VCTxfBSRiB+ab3M3eiQZXmMNBJ3Y8pGRZtYQ7DgHMXJEdPLTaN/qBjzJOBc3nmNcbsA16bMR0oLqf+AAAAAElFTkSuQmCC';\n\n/**\r\n * Specifies the image URL to be used for the transparent background.\r\n */\nEditor.editLargeImage = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAgMAAAAOFJJnAAAACVBMVEUAAAD///////9zeKVjAAAAAnRSTlMAgJsrThgAAABcSURBVBjThc6xDcAgDATAd8MQTEPW8TRUmYCGnzLRYyOlIV+dZFtvkICTFGqiJEzAG0/Uje9oL+e5Vu4F5yUYJxxqGKhQZ0eBvmgwYQLQaARKD1hbiPyDR0QOeAC31EyNe5X/kAAAAABJRU5ErkJggg==';\n\n// Editor inherits from mxEventSource\n_mxGraphUtils[\"default\"].extend(Editor, _mxEventSource[\"default\"]);\n\n/**\r\n * Stores initial state of mxClient.NO_FO.\r\n */\nEditor.prototype.originalNoForeignObject = _mxClient[\"default\"].NO_FO;\n\n/**\r\n * Specifies the image URL to be used for the transparent background.\r\n */\nEditor.prototype.transparentImage = _mxClient[\"default\"].IS_SVG ? 'data:image/gif;base64,R0lGODlhMAAwAIAAAP///wAAACH5BAEAAAAALAAAAAAwADAAAAIxhI+py+0Po5y02ouz3rz7D4biSJbmiabqyrbuC8fyTNf2jef6zvf+DwwKh8Si8egpAAA7' : IMAGE_PATH + '/transparent.gif';\n\n/**\r\n * Specifies if the canvas should be extended in all directions. Default is true.\r\n */\nEditor.prototype.extendCanvas = true;\n\n/**\r\n * Specifies if the app should run in chromeless mode. Default is false.\r\n * This default is only used if the contructor argument is null.\r\n */\nEditor.prototype.chromeless = false;\n\n/**\r\n * Specifies the order of OK/Cancel buttons in dialogs. Default is true.\r\n * Cancel first is used on Macs, Windows/Confluence uses cancel last.\r\n */\nEditor.prototype.cancelFirst = true;\n\n/**\r\n * Specifies if the editor is enabled. Default is true.\r\n */\nEditor.prototype.enabled = true;\n\n/**\r\n * Contains the name which was used for the last save. Default value is null.\r\n */\nEditor.prototype.filename = null;\n\n/**\r\n * Contains the current modified state of the diagram. This is false for\r\n * new diagrams and after the diagram was saved.\r\n */\nEditor.prototype.modified = false;\n\n/**\r\n * Specifies if the diagram should be saved automatically if possible. Default\r\n * is true.\r\n */\nEditor.prototype.autosave = true;\n\n/**\r\n * Specifies the top spacing for the initial page view. Default is 0.\r\n */\nEditor.prototype.initialTopSpacing = 0;\n\n/**\r\n * Specifies the app name. Default is document.title.\r\n */\nEditor.prototype.appName = document.title;\n\n/**\r\n * \r\n */\nEditor.prototype.editBlankUrl = window.location.protocol + '//' + window.location.host + '/?client=1';\n\n/**\r\n * \r\n */\nEditor.prototype.editBlankFallbackUrl = window.location.protocol + '//' + window.location.host + '/?create=drawdata&splash=0';\n\n/**\r\n * Initializes the environment.\r\n */\nEditor.prototype.init = function () {};\n\n/**\r\n * Sets the XML node for the current diagram.\r\n */\nEditor.prototype.setAutosave = function (value) {\n  this.autosave = value;\n  this.fireEvent(new _mxEventObject[\"default\"]('autosaveChanged'));\n};\n\n/**\r\n * \r\n */\nEditor.prototype.editAsNew = function (xml, title) {\n  var p = title != null ? '&title=' + encodeURIComponent(title) : '';\n  if (typeof window.postMessage !== 'undefined' && (document.documentMode == null || document.documentMode >= 10)) {\n    var wnd = null;\n    var receive = _mxGraphUtils[\"default\"].bind(this, function (evt) {\n      if (evt.data == 'ready' && evt.source == wnd) {\n        wnd.postMessage(xml, '*');\n        _mxEvent[\"default\"].removeListener(window, 'message', receive);\n      }\n    });\n    _mxEvent[\"default\"].addListener(window, 'message', receive);\n    wnd = window.open(this.editBlankUrl + p);\n  } else {\n    // Data is pulled from global variable after tab loads\n    window.drawdata = xml;\n    window.open(this.editBlankFallbackUrl + p);\n  }\n};\n\n/**\r\n * Sets the XML node for the current diagram.\r\n */\nEditor.prototype.createGraph = function (themes, model) {\n  var graph = new _Graph[\"default\"](null, model, null, null, themes);\n  graph.transparentBackground = false;\n  return graph;\n};\n\n/**\r\n * Sets the XML node for the current diagram.\r\n */\nEditor.prototype.resetGraph = function () {\n  //this.graph.gridEnabled = !this.chromeless || urlParams['grid'] == '1';\n  this.graph.graphHandler.guidesEnabled = true;\n  this.graph.setTooltips(true);\n  this.graph.setConnectable(true);\n  this.graph.foldingEnabled = true;\n  this.graph.scrollbars = this.graph.defaultScrollbars;\n  this.graph.pageVisible = this.graph.defaultPageVisible;\n  this.graph.pageBreaksVisible = this.graph.pageVisible;\n  this.graph.preferPageSize = this.graph.pageBreaksVisible;\n  this.graph.background = this.graph.defaultGraphBackground;\n  this.graph.pageScale = _mxGraph[\"default\"].prototype.pageScale;\n  this.graph.pageFormat = _mxGraph[\"default\"].prototype.pageFormat;\n  this.updateGraphComponents();\n  this.graph.view.setScale(1);\n};\n\n/**\r\n * Sets the XML node for the current diagram.\r\n */\nEditor.prototype.readGraphState = function (node) {\n  this.graph.gridEnabled = node.getAttribute('grid') != '0' && (!this.chromeless || urlParams['grid'] == '1');\n  this.graph.gridSize = parseFloat(node.getAttribute('gridSize')) || _mxGraph[\"default\"].prototype.gridSize;\n  this.graph.graphHandler.guidesEnabled = node.getAttribute('guides') != '0';\n  this.graph.setTooltips(node.getAttribute('tooltips') != '0');\n  this.graph.setConnectable(node.getAttribute('connect') != '0');\n  this.graph.connectionArrowsEnabled = node.getAttribute('arrows') != '0';\n  this.graph.foldingEnabled = node.getAttribute('fold') != '0';\n  if (this.chromeless && this.graph.foldingEnabled) {\n    this.graph.foldingEnabled = urlParams['nav'] == '1';\n    this.graph.cellRenderer.forceControlClickHandler = this.graph.foldingEnabled;\n  }\n  var ps = node.getAttribute('pageScale');\n  if (ps != null) {\n    this.graph.pageScale = ps;\n  } else {\n    this.graph.pageScale = _mxGraph[\"default\"].prototype.pageScale;\n  }\n  if (!this.graph.lightbox) {\n    var pv = node.getAttribute('page');\n    if (pv != null) {\n      this.graph.pageVisible = pv != '0';\n    } else {\n      this.graph.pageVisible = this.graph.defaultPageVisible;\n    }\n  } else {\n    this.graph.pageVisible = false;\n  }\n  this.graph.pageBreaksVisible = this.graph.pageVisible;\n  this.graph.preferPageSize = this.graph.pageBreaksVisible;\n  var pw = node.getAttribute('pageWidth');\n  var ph = node.getAttribute('pageHeight');\n  if (pw != null && ph != null) {\n    this.graph.pageFormat = new _mxRectangle[\"default\"](0, 0, parseFloat(pw), parseFloat(ph));\n  }\n\n  // Loads the persistent state settings\n  var bg = node.getAttribute('background');\n  if (bg != null && bg.length > 0) {\n    this.graph.background = bg;\n  } else {\n    this.graph.background = this.graph.defaultGraphBackground;\n  }\n};\n\n/**\r\n * Sets the XML node for the current diagram.\r\n */\nEditor.prototype.setGraphXml = function (node, formId) {\n  if (node != null) {\n    var dec = new _mxCodec[\"default\"](node.ownerDocument);\n    if (node.nodeName == 'mxGraphModel') {\n      this.graph.model.beginUpdate();\n      try {\n        this.graph.model.clear();\n        //this.graph.view.scale = 1;\n        if (formId == \"wf_viewflowchartmobile\") {\n          this.graph.view.scale = 0.8;\n        }\n        this.readGraphState(node);\n        this.updateGraphComponents();\n        dec.decode(node, this.graph.getModel());\n      } finally {\n        this.graph.model.endUpdate();\n      }\n\n      //this.fireEvent(new mxEventObject('resetGraphView'));\n    } else if (node.nodeName == 'root') {\n      this.resetGraph();\n\n      // Workaround for invalid XML output in Firefox 20 due to bug in mxUtils.getXml\n      var wrapper = dec.document.createElement('mxGraphModel');\n      wrapper.appendChild(node);\n      dec.decode(wrapper, this.graph.getModel());\n      this.updateGraphComponents();\n      this.fireEvent(new _mxEventObject[\"default\"]('resetGraphView'));\n    } else {\n      throw {\n        message: _mxResources[\"default\"].get('cannotOpenFile'),\n        node: node,\n        toString: function toString() {\n          return this.message;\n        }\n      };\n    }\n  } else {\n    this.resetGraph();\n    this.graph.model.clear();\n    this.fireEvent(new _mxEventObject[\"default\"]('resetGraphView'));\n  }\n};\n\n/**\r\n * Returns the XML node that represents the current diagram.\r\n */\nEditor.prototype.getGraphXml = function (ignoreSelection) {\n  ignoreSelection = ignoreSelection != null ? ignoreSelection : true;\n  var node = null;\n  if (ignoreSelection) {\n    var enc = new _mxCodec[\"default\"](_mxUtils[\"default\"].createXmlDocument());\n    node = enc.encode(this.graph.getModel());\n  } else {\n    node = this.graph.encodeCells(this.graph.getSelectionCells());\n  }\n  if (this.graph.view.translate.x != 0 || this.graph.view.translate.y != 0) {\n    node.setAttribute('dx', Math.round(this.graph.view.translate.x * 100) / 100);\n    node.setAttribute('dy', Math.round(this.graph.view.translate.y * 100) / 100);\n  }\n  node.setAttribute('grid', this.graph.isGridEnabled() ? '1' : '0');\n  node.setAttribute('gridSize', this.graph.gridSize);\n  node.setAttribute('guides', this.graph.graphHandler.guidesEnabled ? '1' : '0');\n  node.setAttribute('tooltips', this.graph.tooltipHandler.isEnabled() ? '1' : '0');\n  node.setAttribute('connect', this.graph.connectionHandler.isEnabled() ? '1' : '0');\n  node.setAttribute('arrows', this.graph.connectionArrowsEnabled ? '1' : '0');\n  node.setAttribute('fold', this.graph.foldingEnabled ? '1' : '0');\n  node.setAttribute('page', this.graph.pageVisible ? '1' : '0');\n  node.setAttribute('pageScale', this.graph.pageScale);\n  node.setAttribute('pageWidth', this.graph.pageFormat.width);\n  node.setAttribute('pageHeight', this.graph.pageFormat.height);\n  if (this.graph.background != null) {\n    node.setAttribute('background', this.graph.background);\n  }\n  return node;\n};\n\n/**\r\n * Keeps the graph container in sync with the persistent graph state\r\n */\nEditor.prototype.updateGraphComponents = function () {\n  var graph = this.graph;\n  if (graph.container != null) {\n    graph.view.validateBackground();\n    graph.container.style.overflow = graph.scrollbars ? 'auto' : 'hidden';\n    this.fireEvent(new _mxEventObject[\"default\"]('updateGraphComponents'));\n  }\n};\n\n/**\r\n * Sets the modified flag.\r\n */\nEditor.prototype.setModified = function (value) {\n  this.modified = value;\n};\n\n/**\r\n * Sets the filename.\r\n */\nEditor.prototype.setFilename = function (value) {\n  this.filename = value;\n};\n\n/**\r\n * Creates and returns a new undo manager.\r\n */\nEditor.prototype.createUndoManager = function () {\n  var graph = this.graph;\n  var undoMgr = new _mxUndoManager[\"default\"]();\n  this.undoListener = function (sender, evt) {\n    undoMgr.undoableEditHappened(evt.getProperty('edit'));\n  };\n\n  // Installs the command history\n  var listener = _mxGraphUtils[\"default\"].bind(this, function (sender, evt) {\n    this.undoListener.apply(this, arguments);\n  });\n  graph.getModel().addListener(_mxEvent[\"default\"].UNDO, listener);\n  graph.getView().addListener(_mxEvent[\"default\"].UNDO, listener);\n\n  // Keeps the selection in sync with the history\n  var undoHandler = function undoHandler(sender, evt) {\n    var cand = graph.getSelectionCellsForChanges(evt.getProperty('edit').changes);\n    var model = graph.getModel();\n    var cells = [];\n    for (var i = 0; i < cand.length; i++) {\n      if ((model.isVertex(cand[i]) || model.isEdge(cand[i])) && graph.view.getState(cand[i]) != null) {\n        cells.push(cand[i]);\n      }\n    }\n    graph.setSelectionCells(cells);\n  };\n  undoMgr.addListener(_mxEvent[\"default\"].UNDO, undoHandler);\n  undoMgr.addListener(_mxEvent[\"default\"].REDO, undoHandler);\n  return undoMgr;\n};\n\n/**\r\n * Adds basic stencil set (no namespace).\r\n */\nEditor.prototype.initStencilRegistry = function () {};\n\n/**\r\n * Creates and returns a new undo manager.\r\n */\nEditor.prototype.destroy = function () {\n  if (this.graph != null) {\n    this.graph.destroy();\n    this.graph = null;\n  }\n};\n\n/**\r\n * Class for asynchronously opening a new window and loading a file at the same\r\n * time. This acts as a bridge between the open dialog and the new editor.\r\n */\nvar _default = exports[\"default\"] = Editor;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxGraph/Editor.js?");

/***/ }),

/***/ "./src/workflow/mxGraph/ExportDialog.js":
/*!**********************************************!*\
  !*** ./src/workflow/mxGraph/ExportDialog.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.index-of.js */ \"../../node_modules/core-js/modules/es.array.index-of.js\");\n__webpack_require__(/*! core-js/modules/es.array.last-index-of.js */ \"../../node_modules/core-js/modules/es.array.last-index-of.js\");\n__webpack_require__(/*! core-js/modules/es.function.bind.js */ \"../../node_modules/core-js/modules/es.function.bind.js\");\n__webpack_require__(/*! core-js/modules/es.parse-int.js */ \"../../node_modules/core-js/modules/es.parse-int.js\");\nvar _mxEvent = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxEvent.js */ \"./src/workflow/mxClient/mxEvent.js\"));\nvar _mxXmlRequest = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxXmlRequest.js */ \"./src/workflow/mxClient/mxXmlRequest.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxResources = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxResources.js */ \"./src/workflow/mxClient/mxResources.js\"));\nvar _mxImageExport = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxImageExport.js */ \"./src/workflow/mxClient/mxImageExport.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nvar _mxUtils = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxUtils.js */ \"./src/workflow/mxClient/mxUtils.js\"));\nvar _mxXmlCanvas2D = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxXmlCanvas2D.js */ \"./src/workflow/mxClient/mxXmlCanvas2D.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nvar ExportDialog = function ExportDialog(editorUi) {\n  var graph = editorUi.editor.graph;\n  var bounds = graph.getGraphBounds();\n  var scale = graph.view.scale;\n  var width = Math.ceil(bounds.width / scale);\n  var height = Math.ceil(bounds.height / scale);\n  var row, td;\n  var table = document.createElement('table');\n  var tbody = document.createElement('tbody');\n  row = document.createElement('tr');\n  td = document.createElement('td');\n  td.style.fontSize = '10pt';\n  td.style.width = '100px';\n  _mxGraphUtils[\"default\"].write(td, _mxResources[\"default\"].get('filename') + ':');\n  row.appendChild(td);\n  var nameInput = document.createElement('input');\n  nameInput.setAttribute('value', editorUi.editor.getOrCreateFilename());\n  nameInput.style.width = '180px';\n  td = document.createElement('td');\n  td.appendChild(nameInput);\n  row.appendChild(td);\n  tbody.appendChild(row);\n  row = document.createElement('tr');\n  td = document.createElement('td');\n  td.style.fontSize = '10pt';\n  _mxGraphUtils[\"default\"].write(td, _mxResources[\"default\"].get('format') + ':');\n  row.appendChild(td);\n  var imageFormatSelect = document.createElement('select');\n  imageFormatSelect.style.width = '180px';\n  var pngOption = document.createElement('option');\n  pngOption.setAttribute('value', 'png');\n  _mxGraphUtils[\"default\"].write(pngOption, _mxResources[\"default\"].get('formatPng'));\n  imageFormatSelect.appendChild(pngOption);\n  var gifOption = document.createElement('option');\n  if (ExportDialog.showGifOption) {\n    gifOption.setAttribute('value', 'gif');\n    _mxGraphUtils[\"default\"].write(gifOption, _mxResources[\"default\"].get('formatGif'));\n    imageFormatSelect.appendChild(gifOption);\n  }\n  var jpgOption = document.createElement('option');\n  jpgOption.setAttribute('value', 'jpg');\n  _mxGraphUtils[\"default\"].write(jpgOption, _mxResources[\"default\"].get('formatJpg'));\n  imageFormatSelect.appendChild(jpgOption);\n  var pdfOption = document.createElement('option');\n  pdfOption.setAttribute('value', 'pdf');\n  _mxGraphUtils[\"default\"].write(pdfOption, _mxResources[\"default\"].get('formatPdf'));\n  imageFormatSelect.appendChild(pdfOption);\n  var svgOption = document.createElement('option');\n  svgOption.setAttribute('value', 'svg');\n  _mxGraphUtils[\"default\"].write(svgOption, _mxResources[\"default\"].get('formatSvg'));\n  imageFormatSelect.appendChild(svgOption);\n  if (ExportDialog.showXmlOption) {\n    var xmlOption = document.createElement('option');\n    xmlOption.setAttribute('value', 'xml');\n    _mxGraphUtils[\"default\"].write(xmlOption, _mxResources[\"default\"].get('formatXml'));\n    imageFormatSelect.appendChild(xmlOption);\n  }\n  td = document.createElement('td');\n  td.appendChild(imageFormatSelect);\n  row.appendChild(td);\n  tbody.appendChild(row);\n  row = document.createElement('tr');\n  td = document.createElement('td');\n  td.style.fontSize = '10pt';\n  _mxGraphUtils[\"default\"].write(td, _mxResources[\"default\"].get('backgroundColor') + ':');\n  row.appendChild(td);\n  var backgroundInput = document.createElement('input');\n  var tmp = graph.background == null || graph.background == _mxConstants[\"default\"].NONE ? '#ffffff' : graph.background;\n  backgroundInput.setAttribute('value', tmp);\n  backgroundInput.style.width = '80px';\n  var backgroundCheckbox = document.createElement('input');\n  backgroundCheckbox.setAttribute('type', 'checkbox');\n  backgroundCheckbox.checked = graph.background == null || graph.background == _mxConstants[\"default\"].NONE;\n  td = document.createElement('td');\n  td.appendChild(backgroundInput);\n  td.appendChild(backgroundCheckbox);\n  _mxGraphUtils[\"default\"].write(td, _mxResources[\"default\"].get('transparent'));\n  row.appendChild(td);\n  tbody.appendChild(row);\n  row = document.createElement('tr');\n  td = document.createElement('td');\n  td.style.fontSize = '10pt';\n  _mxGraphUtils[\"default\"].write(td, _mxResources[\"default\"].get('width') + ':');\n  row.appendChild(td);\n  var widthInput = document.createElement('input');\n  widthInput.setAttribute('value', width);\n  widthInput.style.width = '180px';\n  td = document.createElement('td');\n  td.appendChild(widthInput);\n  row.appendChild(td);\n  tbody.appendChild(row);\n  row = document.createElement('tr');\n  td = document.createElement('td');\n  td.style.fontSize = '10pt';\n  _mxGraphUtils[\"default\"].write(td, _mxResources[\"default\"].get('height') + ':');\n  row.appendChild(td);\n  var heightInput = document.createElement('input');\n  heightInput.setAttribute('value', height);\n  heightInput.style.width = '180px';\n  td = document.createElement('td');\n  td.appendChild(heightInput);\n  row.appendChild(td);\n  tbody.appendChild(row);\n  row = document.createElement('tr');\n  td = document.createElement('td');\n  td.style.fontSize = '10pt';\n  _mxGraphUtils[\"default\"].write(td, _mxResources[\"default\"].get('borderWidth') + ':');\n  row.appendChild(td);\n  var borderInput = document.createElement('input');\n  borderInput.setAttribute('value', width);\n  borderInput.style.width = '180px';\n  borderInput.value = '0';\n  td = document.createElement('td');\n  td.appendChild(borderInput);\n  row.appendChild(td);\n  tbody.appendChild(row);\n  table.appendChild(tbody);\n\n  // Handles changes in the export format\n  function formatChanged() {\n    var name = nameInput.value;\n    var dot = name.lastIndexOf('.');\n    if (dot > 0) {\n      nameInput.value = name.substring(0, dot + 1) + imageFormatSelect.value;\n    } else {\n      nameInput.value = name + '.' + imageFormatSelect.value;\n    }\n    if (imageFormatSelect.value === 'xml') {\n      widthInput.setAttribute('disabled', 'true');\n      heightInput.setAttribute('disabled', 'true');\n      borderInput.setAttribute('disabled', 'true');\n    } else {\n      widthInput.removeAttribute('disabled');\n      heightInput.removeAttribute('disabled');\n      borderInput.removeAttribute('disabled');\n    }\n    if (imageFormatSelect.value === 'png' || imageFormatSelect.value === 'svg') {\n      backgroundCheckbox.removeAttribute('disabled');\n    } else {\n      backgroundCheckbox.setAttribute('disabled', 'disabled');\n    }\n  }\n  ;\n  _mxEvent[\"default\"].addListener(imageFormatSelect, 'change', formatChanged);\n  formatChanged();\n  function checkValues() {\n    if (widthInput.value * heightInput.value > MAX_AREA || widthInput.value <= 0) {\n      widthInput.style.backgroundColor = 'red';\n    } else {\n      widthInput.style.backgroundColor = '';\n    }\n    if (widthInput.value * heightInput.value > MAX_AREA || heightInput.value <= 0) {\n      heightInput.style.backgroundColor = 'red';\n    } else {\n      heightInput.style.backgroundColor = '';\n    }\n  }\n  ;\n  _mxEvent[\"default\"].addListener(widthInput, 'change', function () {\n    if (width > 0) {\n      heightInput.value = Math.ceil(parseInt(widthInput.value) * height / width);\n    } else {\n      heightInput.value = '0';\n    }\n    checkValues();\n  });\n  _mxEvent[\"default\"].addListener(heightInput, 'change', function () {\n    if (height > 0) {\n      widthInput.value = Math.ceil(parseInt(heightInput.value) * width / height);\n    } else {\n      widthInput.value = '0';\n    }\n    checkValues();\n  });\n\n  // Resuable image export instance\n  var imgExport = new _mxImageExport[\"default\"]();\n  function getSvg() {\n    var b = Math.max(0, parseInt(borderInput.value)) + 1;\n    var scale = parseInt(widthInput.value) / width;\n    var bg = null;\n    if (backgroundInput.value != '' && backgroundInput.value != _mxConstants[\"default\"].NONE && !backgroundCheckbox.checked) {\n      bg = backgroundInput.value;\n    }\n    return graph.getSvg(bg, scale, b);\n  }\n  ;\n  function getXml() {\n    return _mxUtils[\"default\"].getXml(editorUi.editor.getGraphXml());\n  }\n  ;\n  row = document.createElement('tr');\n  td = document.createElement('td');\n  td.setAttribute('align', 'right');\n  td.style.paddingTop = '24px';\n  td.colSpan = 2;\n  var saveBtn = _mxUtils[\"default\"].button(_mxResources[\"default\"].get('export'), _mxGraphUtils[\"default\"].bind(this, function () {\n    if (parseInt(widthInput.value) <= 0 && parseInt(heightInput.value) <= 0) {\n      _mxUtils[\"default\"].alert(_mxResources[\"default\"].get('drawingEmpty'));\n    } else {\n      var format = imageFormatSelect.value;\n      var name = nameInput.value;\n      if (format == 'xml') {\n        editorUi.hideDialog();\n        ExportDialog.saveLocalFile(getXml(), name, format);\n      } else if (format == 'svg') {\n        var xml = _mxUtils[\"default\"].getXml(getSvg());\n        if (xml.length < MAX_REQUEST_SIZE) {\n          editorUi.hideDialog();\n          ExportDialog.saveLocalFile(xml, name, format);\n        } else {\n          _mxUtils[\"default\"].alert(_mxResources[\"default\"].get('drawingTooLarge'));\n          _mxUtils[\"default\"].popup(xml);\n        }\n      } else {\n        var param = null;\n        var w = parseInt(widthInput.value) || 0;\n        var h = parseInt(heightInput.value) || 0;\n        var b = Math.max(0, parseInt(borderInput.value)) + 1;\n        var exp = ExportDialog.getExportParameter(editorUi, format);\n        if (typeof exp == 'function') {\n          param = exp();\n        } else {\n          var scale = parseInt(widthInput.value) / width;\n          var bounds = graph.getGraphBounds();\n          var vs = graph.view.scale;\n\n          // New image export\n          var xmlDoc = _mxUtils[\"default\"].createXmlDocument();\n          var root = xmlDoc.createElement('output');\n          xmlDoc.appendChild(root);\n\n          // Renders graph. Offset will be multiplied with state's scale when painting state.\n          var xmlCanvas = new _mxXmlCanvas2D[\"default\"](root);\n          xmlCanvas.translate(Math.floor((b / scale - bounds.x) / vs), Math.floor((b / scale - bounds.y) / vs));\n          xmlCanvas.scale(scale / vs);\n          imgExport.drawState(graph.getView().getState(graph.model.root), xmlCanvas);\n\n          // Puts request data together\n          w = Math.ceil(bounds.width * scale / vs + 2 * b);\n          h = Math.ceil(bounds.height * scale / vs + 2 * b);\n          param = 'xml=' + encodeURIComponent(_mxUtils[\"default\"].getXml(root));\n        }\n\n        // Requests image if request is valid\n        if (param != null && param.length <= MAX_REQUEST_SIZE && w * h < MAX_AREA) {\n          var bg = '&bg=none';\n          if (backgroundInput.value != '' && backgroundInput.value != _mxConstants[\"default\"].NONE && (format != 'png' || !backgroundCheckbox.checked)) {\n            bg = '&bg=' + backgroundInput.value;\n          }\n          editorUi.hideDialog();\n          var data = decodeURIComponent(param.substring(param.indexOf('=') + 1));\n          ExportDialog.saveRequest(data, name, format, function (newTitle, base64) {\n            // Base64 not used in this example\n            return new _mxXmlRequest[\"default\"](EXPORT_URL, 'format=' + format + '&base64=' + (base64 || '0') + (newTitle != null ? '&filename=' + encodeURIComponent(newTitle) : '') + bg + '&w=' + w + '&h=' + h + '&border=' + b + '&' + param);\n          });\n        } else {\n          _mxUtils[\"default\"].alert(_mxResources[\"default\"].get('drawingTooLarge'));\n        }\n      }\n    }\n  }));\n  saveBtn.className = 'geBtn gePrimaryBtn';\n  var cancelBtn = _mxUtils[\"default\"].button(_mxResources[\"default\"].get('cancel'), function () {\n    editorUi.hideDialog();\n  });\n  cancelBtn.className = 'geBtn';\n  if (editorUi.editor.cancelFirst) {\n    td.appendChild(cancelBtn);\n    td.appendChild(saveBtn);\n  } else {\n    td.appendChild(saveBtn);\n    td.appendChild(cancelBtn);\n  }\n  row.appendChild(td);\n  tbody.appendChild(row);\n  table.appendChild(tbody);\n  this.container = table;\n};\n\n/**\r\n * Global switches for the export dialog.\r\n */\nExportDialog.showGifOption = true;\n\n/**\r\n * Global switches for the export dialog.\r\n */\nExportDialog.showXmlOption = true;\n\n/**\r\n * Hook for getting the export format. Returns null for the default\r\n * intermediate XML export format or a function that returns the\r\n * parameter and value to be used in the request in the form\r\n * key=value, where value should be URL encoded.\r\n */\nExportDialog.saveLocalFile = function (data, filename, format) {\n  new _mxXmlRequest[\"default\"](SAVE_URL, 'xml=' + encodeURIComponent(data) + '&filename=' + encodeURIComponent(filename) + '&format=' + format).simulate(document, '_blank');\n};\n\n/**\r\n * Hook for getting the export format. Returns null for the default\r\n * intermediate XML export format or a function that returns the\r\n * parameter and value to be used in the request in the form\r\n * key=value, where value should be URL encoded.\r\n */\nExportDialog.saveRequest = function (data, filename, format, fn) {\n  fn(filename).simulate(document, '_blank');\n};\n\n/**\r\n * Hook for getting the export format. Returns null for the default\r\n * intermediate XML export format or a function that returns the\r\n * parameter and value to be used in the request in the form\r\n * key=value, where value should be URL encoded.\r\n */\nExportDialog.getExportParameter = function (ui, format) {\n  return null;\n};\n\n/**\r\n * Constructs a new metadata dialog.\r\n */\nvar _default = exports[\"default\"] = ExportDialog;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxGraph/ExportDialog.js?");

/***/ }),

/***/ "./src/workflow/mxGraph/FilenameDialog.js":
/*!************************************************!*\
  !*** ./src/workflow/mxGraph/FilenameDialog.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _mxClient = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxClient.js */ \"./src/workflow/mxClient/mxClient.js\"));\nvar _mxEvent = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxEvent.js */ \"./src/workflow/mxClient/mxEvent.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxResources = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxResources.js */ \"./src/workflow/mxClient/mxResources.js\"));\nvar _mxUtils = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxUtils.js */ \"./src/workflow/mxClient/mxUtils.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nvar FilenameDialog = function FilenameDialog(editorUi, filename, buttonText, fn, label, validateFn, content, helpLink, closeOnBtn) {\n  closeOnBtn = closeOnBtn != null ? closeOnBtn : true;\n  var row, td;\n  var table = document.createElement('table');\n  var tbody = document.createElement('tbody');\n  table.style.marginTop = '8px';\n  row = document.createElement('tr');\n  td = document.createElement('td');\n  td.style.fontSize = '10pt';\n  td.style.width = '120px';\n  _mxGraphUtils[\"default\"].write(td, (label || _mxResources[\"default\"].get('filename')) + ':');\n  row.appendChild(td);\n  var nameInput = document.createElement('input');\n  nameInput.setAttribute('value', filename || '');\n  nameInput.style.width = '180px';\n  var genericBtn = _mxUtils[\"default\"].button(buttonText, function () {\n    if (validateFn == null || validateFn(nameInput.value)) {\n      if (closeOnBtn) {\n        editorUi.hideDialog();\n      }\n      fn(nameInput.value);\n    }\n  });\n  genericBtn.className = 'geBtn gePrimaryBtn';\n  this.init = function () {\n    if (label == null && content != null) {\n      return;\n    }\n    nameInput.focus();\n    if (_mxClient[\"default\"].IS_FF || document.documentMode >= 5 || _mxClient[\"default\"].IS_QUIRKS) {\n      nameInput.select();\n    } else {\n      document.execCommand('selectAll', false, null);\n    }\n\n    // Installs drag and drop handler for links\n    /*if (Graph.fileSupport)\r\n    {\r\n    \t// Setup the dnd listeners\r\n    \tvar dlg = table.parentNode;\r\n    \tvar graph = editorUi.editor.graph;\r\n    \tvar dropElt = null;\r\n    \t\t\r\n    \tmxEvent.addListener(dlg, 'dragleave', function(evt)\r\n    \t{\r\n    \t\tif (dropElt != null)\r\n    \t    {\r\n    \t\t\tdropElt.style.backgroundColor = '';\r\n    \t    \tdropElt = null;\r\n    \t    }\r\n    \t    \r\n    \t\tevt.stopPropagation();\r\n    \t\tevt.preventDefault();\r\n    \t});\r\n    \t\r\n    \tmxEvent.addListener(dlg, 'dragover', mxGraphUtils.bind(this, function(evt)\r\n    \t{\r\n    \t\t// IE 10 does not implement pointer-events so it can't have a drop highlight\r\n    \t\tif (dropElt == null && (!mxClient.IS_IE || document.documentMode > 10))\r\n    \t\t{\r\n    \t\t\tdropElt = nameInput;\r\n    \t\t\tdropElt.style.backgroundColor = '#ebf2f9';\r\n    \t\t}\r\n    \t\t\r\n    \t\tevt.stopPropagation();\r\n    \t\tevt.preventDefault();\r\n    \t}));\r\n    \t\t\t\r\n    \tmxEvent.addListener(dlg, 'drop', mxGraphUtils.bind(this, function(evt)\r\n    \t{\r\n    \t    if (dropElt != null)\r\n    \t    {\r\n    \t\t\tdropElt.style.backgroundColor = '';\r\n    \t    \tdropElt = null;\r\n    \t    }\r\n    \t\t\t    if (mxGraphUtils.indexOf(evt.dataTransfer.types, 'text/uri-list') >= 0)\r\n    \t    {\r\n    \t    \tnameInput.value = decodeURIComponent(evt.dataTransfer.getData('text/uri-list'));\r\n    \t    \tgenericBtn.click();\r\n    \t    }\r\n    \t\t\t    evt.stopPropagation();\r\n    \t    evt.preventDefault();\r\n    \t}));\r\n    }*/\n  };\n  td = document.createElement('td');\n  td.appendChild(nameInput);\n  row.appendChild(td);\n  if (label != null || content == null) {\n    tbody.appendChild(row);\n  }\n  if (content != null) {\n    row = document.createElement('tr');\n    td = document.createElement('td');\n    td.colSpan = 2;\n    td.appendChild(content);\n    row.appendChild(td);\n    tbody.appendChild(row);\n  }\n  row = document.createElement('tr');\n  td = document.createElement('td');\n  td.colSpan = 2;\n  td.style.paddingTop = '20px';\n  td.style.whiteSpace = 'nowrap';\n  td.setAttribute('align', 'right');\n  var cancelBtn = _mxUtils[\"default\"].button(_mxResources[\"default\"].get('cancel'), function () {\n    editorUi.hideDialog();\n  });\n  cancelBtn.className = 'geBtn';\n  if (editorUi.editor.cancelFirst) {\n    td.appendChild(cancelBtn);\n  }\n  if (helpLink != null) {\n    var helpBtn = _mxUtils[\"default\"].button(_mxResources[\"default\"].get('help'), function () {\n      window.open(helpLink);\n    });\n    helpBtn.className = 'geBtn';\n    td.appendChild(helpBtn);\n  }\n  _mxEvent[\"default\"].addListener(nameInput, 'keypress', function (e) {\n    if (e.keyCode == 13) {\n      genericBtn.click();\n    }\n  });\n  td.appendChild(genericBtn);\n  if (!editorUi.editor.cancelFirst) {\n    td.appendChild(cancelBtn);\n  }\n  row.appendChild(td);\n  tbody.appendChild(row);\n  table.appendChild(tbody);\n  this.container = table;\n};\n\n/**\r\n * Constructs a new textarea dialog.\r\n */\nvar _default = exports[\"default\"] = FilenameDialog;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxGraph/FilenameDialog.js?");

/***/ }),

/***/ "./src/workflow/mxGraph/Graph.js":
/*!***************************************!*\
  !*** ./src/workflow/mxGraph/Graph.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.symbol.js */ \"../../node_modules/core-js/modules/es.symbol.js\");\n__webpack_require__(/*! core-js/modules/es.symbol.description.js */ \"../../node_modules/core-js/modules/es.symbol.description.js\");\n__webpack_require__(/*! core-js/modules/es.symbol.iterator.js */ \"../../node_modules/core-js/modules/es.symbol.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.array.iterator.js */ \"../../node_modules/core-js/modules/es.array.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\n__webpack_require__(/*! core-js/modules/es.string.iterator.js */ \"../../node_modules/core-js/modules/es.string.iterator.js\");\n__webpack_require__(/*! core-js/modules/web.dom-collections.iterator.js */ \"../../node_modules/core-js/modules/web.dom-collections.iterator.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.concat.js */ \"../../node_modules/core-js/modules/es.array.concat.js\");\n__webpack_require__(/*! core-js/modules/es.array.fill.js */ \"../../node_modules/core-js/modules/es.array.fill.js\");\n__webpack_require__(/*! core-js/modules/es.array.index-of.js */ \"../../node_modules/core-js/modules/es.array.index-of.js\");\n__webpack_require__(/*! core-js/modules/es.array.join.js */ \"../../node_modules/core-js/modules/es.array.join.js\");\n__webpack_require__(/*! core-js/modules/es.array.last-index-of.js */ \"../../node_modules/core-js/modules/es.array.last-index-of.js\");\n__webpack_require__(/*! core-js/modules/es.array.slice.js */ \"../../node_modules/core-js/modules/es.array.slice.js\");\n__webpack_require__(/*! core-js/modules/es.date.to-string.js */ \"../../node_modules/core-js/modules/es.date.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.function.bind.js */ \"../../node_modules/core-js/modules/es.function.bind.js\");\n__webpack_require__(/*! core-js/modules/es.object.to-string.js */ \"../../node_modules/core-js/modules/es.object.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.regexp.constructor.js */ \"../../node_modules/core-js/modules/es.regexp.constructor.js\");\n__webpack_require__(/*! core-js/modules/es.regexp.exec.js */ \"../../node_modules/core-js/modules/es.regexp.exec.js\");\n__webpack_require__(/*! core-js/modules/es.regexp.to-string.js */ \"../../node_modules/core-js/modules/es.regexp.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.string.match.js */ \"../../node_modules/core-js/modules/es.string.match.js\");\n__webpack_require__(/*! core-js/modules/es.string.replace.js */ \"../../node_modules/core-js/modules/es.string.replace.js\");\n__webpack_require__(/*! core-js/modules/web.timers.js */ \"../../node_modules/core-js/modules/web.timers.js\");\nvar _mxEventObject = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxEventObject.js */ \"./src/workflow/mxClient/mxEventObject.js\"));\nvar _mxStackLayout = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxStackLayout.js */ \"./src/workflow/mxClient/mxStackLayout.js\"));\nvar _mxHierarchicalLayout = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxHierarchicalLayout.js */ \"./src/workflow/mxClient/mxHierarchicalLayout.js\"));\nvar _mxGraph = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxGraph.js */ \"./src/workflow/mxClient/mxGraph.js\"));\nvar _mxEvent = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxEvent.js */ \"./src/workflow/mxClient/mxEvent.js\"));\nvar _mxConnectionHandler = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxConnectionHandler.js */ \"./src/workflow/mxClient/mxConnectionHandler.js\"));\nvar _mxEdgeHandler = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxEdgeHandler.js */ \"./src/workflow/mxClient/mxEdgeHandler.js\"));\nvar _mxPopupMenu = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxPopupMenu.js */ \"./src/workflow/mxClient/mxPopupMenu.js\"));\nvar _mxRectangle = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxRectangle.js */ \"./src/workflow/mxClient/mxRectangle.js\"));\nvar _mxCellRenderer = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxCellRenderer.js */ \"./src/workflow/mxClient/mxCellRenderer.js\"));\nvar _mxCompactTreeLayout = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxCompactTreeLayout.js */ \"./src/workflow/mxClient/mxCompactTreeLayout.js\"));\nvar _mxClient = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxClient.js */ \"./src/workflow/mxClient/mxClient.js\"));\nvar _mxGuide = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxGuide.js */ \"./src/workflow/mxClient/mxGuide.js\"));\nvar _mxRubberband = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxRubberband.js */ \"./src/workflow/mxClient/mxRubberband.js\"));\nvar _mxPoint = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxPoint.js */ \"./src/workflow/mxClient/mxPoint.js\"));\nvar _mxGraphHandler = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxGraphHandler.js */ \"./src/workflow/mxClient/mxGraphHandler.js\"));\nvar _mxResources = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxResources.js */ \"./src/workflow/mxClient/mxResources.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxLayoutManager = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxLayoutManager.js */ \"./src/workflow/mxClient/mxLayoutManager.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nvar _mxUtils = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxUtils.js */ \"./src/workflow/mxClient/mxUtils.js\"));\nvar _mxEdgeStyle = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxEdgeStyle.js */ \"./src/workflow/mxClient/mxEdgeStyle.js\"));\nvar _mxDragSource = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxDragSource.js */ \"./src/workflow/mxClient/mxDragSource.js\"));\nvar _mxVertexHandler = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxVertexHandler.js */ \"./src/workflow/mxClient/mxVertexHandler.js\"));\nvar _mxGraphConstant = __webpack_require__(/*! ../constants/mxGraphConstant */ \"./src/workflow/constants/mxGraphConstant.js\");\nvar _workflowUtil = __webpack_require__(/*! ../util/workflowUtil */ \"./src/workflow/util/workflowUtil.js\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nvar Graph = function Graph(container, model, renderHint, stylesheet, themes) {\n  _mxGraph[\"default\"].call(this, container, model, renderHint, stylesheet);\n  this.themes = themes || this.defaultThemes;\n\n  // Sets the base domain URL and domain path URL for relative links.\n  var b = this.baseUrl;\n  var p = b.indexOf('//');\n  this.domainUrl = '';\n  this.domainPathUrl = '';\n  if (p > 0) {\n    var d = b.indexOf('/', p + 2);\n    if (d > 0) {\n      this.domainUrl = b.substring(0, d);\n    }\n    d = b.lastIndexOf('/');\n    if (d > 0) {\n      this.domainPathUrl = b.substring(0, d + 1);\n    }\n  }\n\n  // Adds support for HTML labels via style. Note: Currently, only the Java\n  // backend supports HTML labels but CSS support is limited to the following:\n  // http://docs.oracle.com/javase/6/docs/api/index.html?javax/swing/text/html/CSS.html\n  // TODO: Wrap should not affect isHtmlLabel output (should be handled later)\n  this.isHtmlLabel = function (cell) {\n    var state = this.view.getState(cell);\n    var style = state != null ? state.style : this.getCellStyle(cell);\n    return style['html'] == '1' || style[_mxConstants[\"default\"].STYLE_WHITE_SPACE] == 'wrap';\n  };\n\n  // Implements a listener for hover and click handling on edges\n  if (this.edgeMode) {\n    var start = {\n      point: null,\n      event: null,\n      state: null,\n      handle: null,\n      selected: false\n    };\n\n    // Uses this event to process mouseDown to check the selection state before it is changed\n    this.addListener(_mxEvent[\"default\"].FIRE_MOUSE_EVENT, _mxGraphUtils[\"default\"].bind(this, function (sender, evt) {\n      if (evt.getProperty('eventName') == 'mouseDown' && this.isEnabled()) {\n        var me = evt.getProperty('event');\n        if (!_mxEvent[\"default\"].isControlDown(me.getEvent()) && !_mxEvent[\"default\"].isShiftDown(me.getEvent())) {\n          var state = me.getState();\n          if (state != null) {\n            // Checks if state was removed in call to stopEditing above\n            if (this.model.isEdge(state.cell)) {\n              start.point = new _mxPoint[\"default\"](me.getGraphX(), me.getGraphY());\n              start.selected = this.isCellSelected(state.cell);\n              start.state = state;\n              start.event = me;\n              if (state.text != null && state.text.boundingBox != null && _mxUtils[\"default\"].contains(state.text.boundingBox, me.getGraphX(), me.getGraphY())) {\n                start.handle = _mxEvent[\"default\"].LABEL_HANDLE;\n              } else {\n                var handler = this.selectionCellsHandler.getHandler(state.cell);\n                if (handler != null && handler.bends != null && handler.bends.length > 0) {\n                  start.handle = handler.getHandleForEvent(me);\n                }\n              }\n            }\n          }\n        }\n      }\n    }));\n    var mouseDown = null;\n    this.addMouseListener({\n      mouseDown: function mouseDown(sender, me) {},\n      mouseMove: _mxGraphUtils[\"default\"].bind(this, function (sender, me) {\n        if (this.isEnabled() && !this.panningHandler.isActive() && !_mxEvent[\"default\"].isControlDown(me.getEvent()) && !_mxEvent[\"default\"].isShiftDown(me.getEvent()) && !_mxEvent[\"default\"].isAltDown(me.getEvent())) {\n          var tol = this.tolerance;\n          if (start.point != null && start.state != null && start.event != null) {\n            var state = start.state;\n            if (Math.abs(start.point.x - me.getGraphX()) > tol * this.view.scale || Math.abs(start.point.y - me.getGraphY()) > tol * this.view.scale) {\n              // Lazy selection for edges inside groups\n              if (!this.isCellSelected(state.cell)) {\n                this.setSelectionCell(state.cell);\n              }\n              var handler = this.selectionCellsHandler.getHandler(state.cell);\n              if (handler != null && handler.bends != null && handler.bends.length > 0) {\n                var handle = handler.getHandleForEvent(start.event);\n                var edgeStyle = this.view.getEdgeStyle(state);\n                var entity = edgeStyle == _mxEdgeStyle[\"default\"].EntityRelation;\n\n                // Handles special case where label was clicked on unselected edge in which\n                // case the label will be moved regardless of the handle that is returned\n                if (!start.selected && start.handle == _mxEvent[\"default\"].LABEL_HANDLE) {\n                  handle = start.handle;\n                }\n                if (!entity || handle == 0 || handle == handler.bends.length - 1 || handle == _mxEvent[\"default\"].LABEL_HANDLE) {\n                  // Source or target handle or connected for direct handle access or orthogonal line\n                  // with just two points where the central handle is moved regardless of mouse position\n                  if (handle == _mxEvent[\"default\"].LABEL_HANDLE || handle == 0 || state.visibleSourceState != null || handle == handler.bends.length - 1 || state.visibleTargetState != null) {\n                    if (!entity && handle != _mxEvent[\"default\"].LABEL_HANDLE) {\n                      var pts = state.absolutePoints;\n\n                      // Default case where handles are at corner points handles\n                      // drag of corner as drag of existing point\n                      if (pts != null && (edgeStyle == null && handle == null || edgeStyle == _mxEdgeStyle[\"default\"].OrthConnector)) {\n                        // Does not use handles if they were not initially visible\n                        handle = start.handle;\n                        if (handle == null) {\n                          var box = new _mxRectangle[\"default\"](start.point.x, start.point.y);\n                          box.grow(_mxEdgeHandler[\"default\"].prototype.handleImage.width / 2);\n                          if (_mxUtils[\"default\"].contains(box, pts[0].x, pts[0].y)) {\n                            // Moves source terminal handle\n                            handle = 0;\n                          } else if (_mxUtils[\"default\"].contains(box, pts[pts.length - 1].x, pts[pts.length - 1].y)) {\n                            // Moves target terminal handle\n                            handle = handler.bends.length - 1;\n                          } else {\n                            // Checks if edge has no bends\n                            var nobends = edgeStyle != null && (pts.length == 2 || pts.length == 3 && (Math.round(pts[0].x - pts[1].x) == 0 && Math.round(pts[1].x - pts[2].x) == 0 || Math.round(pts[0].y - pts[1].y) == 0 && Math.round(pts[1].y - pts[2].y) == 0));\n                            if (nobends) {\n                              // Moves central handle for straight orthogonal edges\n                              handle = 2;\n                            } else {\n                              // Finds and moves vertical or horizontal segment\n                              handle = _mxUtils[\"default\"].findNearestSegment(state, start.point.x, start.point.y);\n\n                              // Converts segment to virtual handle index\n                              if (edgeStyle == null) {\n                                handle = _mxEvent[\"default\"].VIRTUAL_HANDLE - handle;\n                              }\n                              // Maps segment to handle\n                              else {\n                                handle += 1;\n                              }\n                            }\n                          }\n                        }\n                      }\n\n                      // Creates a new waypoint and starts moving it\n                      if (handle == null) {\n                        handle = _mxEvent[\"default\"].VIRTUAL_HANDLE;\n                      }\n                    }\n                    handler.start(me.getGraphX(), me.getGraphX(), handle);\n                    start.state = null;\n                    start.event = null;\n                    start.point = null;\n                    start.handle = null;\n                    start.selected = false;\n                    me.consume();\n\n                    // Removes preview rectangle in graph handler\n                    this.graphHandler.reset();\n                  }\n                } else if (entity && (state.visibleSourceState != null || state.visibleTargetState != null)) {\n                  // Disables moves on entity to make it consistent\n                  this.graphHandler.reset();\n                  me.consume();\n                }\n              }\n            }\n          } else {\n            // Updates cursor for unselected edges under the mouse\n            var state = me.getState();\n            if (state != null) {\n              // Checks if state was removed in call to stopEditing above\n              if (this.model.isEdge(state.cell)) {\n                var cursor = null;\n                var pts = state.absolutePoints;\n                if (pts != null) {\n                  var box = new _mxRectangle[\"default\"](me.getGraphX(), me.getGraphY());\n                  box.grow(_mxEdgeHandler[\"default\"].prototype.handleImage.width / 2);\n                  if (state.text != null && state.text.boundingBox != null && _mxUtils[\"default\"].contains(state.text.boundingBox, me.getGraphX(), me.getGraphY())) {\n                    cursor = 'move';\n                  } else if (_mxUtils[\"default\"].contains(box, pts[0].x, pts[0].y) || _mxUtils[\"default\"].contains(box, pts[pts.length - 1].x, pts[pts.length - 1].y)) {\n                    cursor = 'pointer';\n                  } else if (state.visibleSourceState != null || state.visibleTargetState != null) {\n                    // Moving is not allowed for entity relation but still indicate hover state\n                    var tmp = this.view.getEdgeStyle(state);\n                    cursor = 'crosshair';\n                    if (tmp != _mxEdgeStyle[\"default\"].EntityRelation && this.isOrthogonal(state)) {\n                      var idx = _mxUtils[\"default\"].findNearestSegment(state, me.getGraphX(), me.getGraphY());\n                      if (idx < pts.length - 1 && idx >= 0) {\n                        cursor = Math.round(pts[idx].x - pts[idx + 1].x) == 0 ? 'col-resize' : 'row-resize';\n                      }\n                    }\n                  }\n                }\n                if (cursor != null) {\n                  state.setCursor(cursor);\n                }\n              }\n            }\n          }\n        }\n      }),\n      mouseUp: _mxGraphUtils[\"default\"].bind(this, function (sender, me) {\n        start.state = null;\n        start.event = null;\n        start.point = null;\n        start.handle = null;\n      })\n    });\n  }\n\n  // HTML entities are displayed as plain text in wrapped plain text labels\n  this.cellRenderer.getLabelValue = function (state) {\n    var result = _mxCellRenderer[\"default\"].prototype.getLabelValue.apply(this, arguments);\n    if (state.view.graph.isHtmlLabel(state.cell)) {\n      if (state.style['html'] != 1) {\n        result = _mxGraphUtils[\"default\"].htmlEntities(result, false);\n      } else {\n        result = state.view.graph.sanitizeHtml(result);\n      }\n    }\n    return result;\n  };\n\n  // All code below not available and not needed in embed mode\n  if (typeof _mxVertexHandler[\"default\"] !== 'undefined') {\n    this.setConnectable(true);\n    this.setDropEnabled(true);\n    this.setPanning(true);\n    this.setTooltips(true);\n    this.setAllowLoops(true);\n    this.allowAutoPanning = true;\n    this.resetEdgesOnConnect = false;\n    //暂时先注释掉，影响“setRemoveCellsFromParent(false)”功能\n    this.constrainChildren = false;\n    this.constrainRelativeChildren = true;\n\n    // Do not scroll after moving cells\n    this.graphHandler.scrollOnMove = false;\n    this.graphHandler.scaleGrid = true;\n\n    // Disables cloning of connection sources by default\n    this.connectionHandler.setCreateTarget(false);\n    this.connectionHandler.insertBeforeSource = true;\n\n    // Disables built-in connection starts\n    this.connectionHandler.isValidSource = function (cell, me) {\n      return false;\n    };\n\n    // Sets the style to be used when an elbow edge is double clicked\n    this.alternateEdgeStyle = 'vertical';\n    if (stylesheet == null) {\n      this.loadStylesheet();\n    }\n\n    // Adds page centers to the guides for moving cells\n    var graphHandlerGetGuideStates = this.graphHandler.getGuideStates;\n    this.graphHandler.getGuideStates = function () {\n      var result = graphHandlerGetGuideStates.apply(this, arguments);\n\n      // Create virtual cell state for page centers\n      if (this.graph.pageVisible) {\n        var guides = [];\n        var pf = this.graph.pageFormat;\n        var ps = this.graph.pageScale;\n        var pw = pf.width * ps;\n        var ph = pf.height * ps;\n        var t = this.graph.view.translate;\n        var s = this.graph.view.scale;\n        var layout = this.graph.getPageLayout();\n        for (var i = 0; i < layout.width; i++) {\n          guides.push(new _mxRectangle[\"default\"](((layout.x + i) * pw + t.x) * s, (layout.y * ph + t.y) * s, pw * s, ph * s));\n        }\n        for (var j = 0; j < layout.height; j++) {\n          guides.push(new _mxRectangle[\"default\"]((layout.x * pw + t.x) * s, ((layout.y + j) * ph + t.y) * s, pw * s, ph * s));\n        }\n\n        // Page center guides have predence over normal guides\n        result = guides.concat(result);\n      }\n      return result;\n    };\n\n    // Overrides zIndex for dragElement\n    _mxDragSource[\"default\"].prototype.dragElementZIndex = _mxPopupMenu[\"default\"].prototype.zIndex;\n\n    // Overrides color for virtual guides for page centers\n    _mxGuide[\"default\"].prototype.getGuideColor = function (state, horizontal) {\n      return state.cell == null ? '#ffa500' /* orange */ : _mxConstants[\"default\"].GUIDE_COLOR;\n    };\n\n    // Changes color of move preview for black backgrounds\n    this.graphHandler.createPreviewShape = function (bounds) {\n      this.previewColor = this.graph.background == '#000000' ? '#ffffff' : _mxGraphHandler[\"default\"].prototype.previewColor;\n      return _mxGraphHandler[\"default\"].prototype.createPreviewShape.apply(this, arguments);\n    };\n\n    // Handles parts of cells by checking if part=1 is in the style and returning the parent\n    // if the parent is not already in the list of cells. container style is used to disable\n    // step into swimlanes and dropTarget style is used to disable acting as a drop target.\n    // LATER: Handle recursive parts\n    this.graphHandler.getCells = function (initialCell) {\n      var cells = _mxGraphHandler[\"default\"].prototype.getCells.apply(this, arguments);\n      var newCells = [];\n      for (var i = 0; i < cells.length; i++) {\n        var state = this.graph.view.getState(cells[i]);\n        var style = state != null ? state.style : this.graph.getCellStyle(cells[i]);\n        if (_mxGraphUtils[\"default\"].getValue(style, 'part', '0') == '1') {\n          var parent = this.graph.model.getParent(cells[i]);\n          if (this.graph.model.isVertex(parent) && _mxGraphUtils[\"default\"].indexOf(cells, parent) < 0) {\n            newCells.push(parent);\n          }\n        } else {\n          newCells.push(cells[i]);\n        }\n      }\n      return newCells;\n    };\n    var graph = this;\n    // Returns the relative position of the given child\n    var getRelativePosition = function getRelativePosition(state, dx, dy) {\n      if (state != null) {\n        var model = graph.getModel();\n        var geo = model.getGeometry(state.cell);\n        if (geo != null && geo.relative && !model.isEdge(state.cell)) {\n          var parent = model.getParent(state.cell);\n          if (model.isVertex(parent)) {\n            var pstate = graph.view.getState(parent);\n            if (pstate != null) {\n              var scale = graph.view.scale;\n              var x = state.x + dx;\n              var y = state.y + dy;\n              if (geo.offset != null) {\n                x -= geo.offset.x * scale;\n                y -= geo.offset.y * scale;\n              }\n              x = (x - pstate.x) / pstate.width;\n              y = (y - pstate.y) / pstate.height;\n              if (Math.abs(y - 0.5) <= Math.abs((x - 0.5) / 2)) {\n                x = x > 0.5 ? 1 : 0;\n                y = Math.min(1, Math.max(0, y));\n              } else {\n                x = Math.min(1, Math.max(0, x));\n                y = y > 0.5 ? 1 : 0;\n              }\n              return new _mxPoint[\"default\"](x, y);\n            }\n          }\n        }\n      }\n      return null;\n    };\n\n    // Replaces translation for relative children\n    this.translateCell = function (cell, dx, dy) {\n      if (_mxGraphUtils[\"default\"].isBoundaryEvent(cell.getType())) {\n        var rel = getRelativePosition(this.view.getState(cell), dx * graph.view.scale, dy * graph.view.scale);\n        if (rel != null) {\n          var geo = this.model.getGeometry(cell);\n          if (geo != null && geo.relative) {\n            geo = geo.clone();\n            geo.x = rel.x;\n            geo.y = rel.y;\n            this.model.setGeometry(cell, geo);\n          }\n        } else {\n          _mxGraph[\"default\"].prototype.translateCell.apply(this, arguments);\n        }\n      } else {\n        _mxGraph[\"default\"].prototype.translateCell.apply(this, arguments);\n      }\n    };\n\n    // Replaces move preview for relative children\n    this.graphHandler.getDelta = function (me) {\n      var cell = this.graph.getSelectionCell();\n      if (cell && _mxGraphUtils[\"default\"].isBoundaryEvent(cell.getType())) {\n        var point = _mxUtils[\"default\"].convertPoint(this.graph.container, me.getX(), me.getY());\n        var delta = new _mxPoint[\"default\"](point.x - this.first.x, point.y - this.first.y);\n        if (this.cells != null && this.cells.length > 0 && this.cells[0] != null) {\n          var state = this.graph.view.getState(this.cells[0]);\n          var rel = getRelativePosition(state, delta.x, delta.y);\n          if (rel != null) {\n            var pstate = this.graph.view.getState(this.graph.model.getParent(state.cell));\n            if (pstate != null) {\n              delta = new _mxPoint[\"default\"](pstate.x + pstate.width * rel.x - state.getCenterX(), pstate.y + pstate.height * rel.y - state.getCenterY());\n            }\n          }\n        }\n        return delta;\n      } else {\n        return _mxGraphHandler[\"default\"].prototype.getDelta.apply(this, arguments);\n      }\n    };\n\n    // Handles parts of cells when cloning the source for new connections\n    this.connectionHandler.createTargetVertex = function (evt, source) {\n      var state = this.graph.view.getState(source);\n      var style = state != null ? state.style : this.graph.getCellStyle(source);\n      if (_mxGraphUtils[\"default\"].getValue(style, 'part', false)) {\n        var parent = this.graph.model.getParent(source);\n        if (this.graph.model.isVertex(parent)) {\n          source = parent;\n        }\n      }\n      return _mxConnectionHandler[\"default\"].prototype.createTargetVertex.apply(this, arguments);\n    };\n    var rubberband = new _mxRubberband[\"default\"](this);\n    this.getRubberband = function () {\n      return rubberband;\n    };\n\n    // Timer-based activation of outline connect in connection handler\n    var startTime = new Date().getTime();\n    var timeOnTarget = 0;\n    var connectionHandlerMouseMove = this.connectionHandler.mouseMove;\n    this.connectionHandler.mouseMove = function () {\n      var prev = this.currentState;\n      connectionHandlerMouseMove.apply(this, arguments);\n      if (prev != this.currentState) {\n        startTime = new Date().getTime();\n        timeOnTarget = 0;\n      } else {\n        timeOnTarget = new Date().getTime() - startTime;\n      }\n    };\n\n    // Activates outline connect after 1500ms with touch event or if alt is pressed inside the shape\n    var connectionHandleIsOutlineConnectEvent = this.connectionHandler.isOutlineConnectEvent;\n    this.connectionHandler.isOutlineConnectEvent = function (me) {\n      return this.currentState != null && me.getState() == this.currentState && timeOnTarget > 2000 || (this.currentState == null || _mxGraphUtils[\"default\"].getValue(this.currentState.style, 'outlineConnect', '1') != '0') && connectionHandleIsOutlineConnectEvent.apply(this, arguments);\n    };\n\n    // Adds shift+click to toggle selection state\n    var isToggleEvent = this.isToggleEvent;\n    this.isToggleEvent = function (evt) {\n      return isToggleEvent.apply(this, arguments) || _mxEvent[\"default\"].isShiftDown(evt);\n    };\n\n    // Workaround for Firefox where first mouse down is received\n    // after tap and hold if scrollbars are visible, which means\n    // start rubberband immediately if no cell is under mouse.\n    var isForceRubberBandEvent = rubberband.isForceRubberbandEvent;\n    rubberband.isForceRubberbandEvent = function (me) {\n      return isForceRubberBandEvent.apply(this, arguments) || _mxUtils[\"default\"].hasScrollbars(this.graph.container) && _mxClient[\"default\"].IS_FF && _mxClient[\"default\"].IS_WIN && me.getState() == null && _mxEvent[\"default\"].isTouchEvent(me.getEvent());\n    };\n\n    // Shows hand cursor while panning\n    var prevCursor = null;\n    this.panningHandler.addListener(_mxEvent[\"default\"].PAN_START, _mxGraphUtils[\"default\"].bind(this, function () {\n      if (this.isEnabled()) {\n        prevCursor = this.container.style.cursor;\n        this.container.style.cursor = 'move';\n      }\n    }));\n    this.panningHandler.addListener(_mxEvent[\"default\"].PAN_END, _mxGraphUtils[\"default\"].bind(this, function () {\n      if (this.isEnabled()) {\n        this.container.style.cursor = prevCursor;\n      }\n    }));\n    this.popupMenuHandler.autoExpand = true;\n    this.popupMenuHandler.isSelectOnPopup = function (me) {\n      return _mxEvent[\"default\"].isMouseEvent(me.getEvent());\n    };\n\n    // Enables links if graph is \"disabled\" (ie. read-only)\n    var click = this.click;\n    this.click = function (me) {\n      if (!this.isEnabled() && !me.isConsumed()) {\n        var cell = me.getCell();\n        if (cell != null) {\n          var link = this.getLinkForCell(cell);\n          if (link != null) {\n            window.open(link);\n          }\n        }\n      } else {\n        return click.apply(this, arguments);\n      }\n    };\n\n    // Shows pointer cursor for clickable cells with links\n    // ie. if the graph is disabled and cells cannot be selected\n    var getCursorForCell = this.getCursorForCell;\n    this.getCursorForCell = function (cell) {\n      if (!this.isEnabled()) {\n        var link = this.getLinkForCell(cell);\n        if (link != null) {\n          return 'pointer';\n        }\n      } else {\n        return getCursorForCell.apply(this, arguments);\n      }\n    };\n\n    // Changes rubberband selection to be recursive\n    this.selectRegion = function (rect, evt) {\n      var cells = this.getAllCells(rect.x, rect.y, rect.width, rect.height);\n      this.selectCellsForEvent(cells, evt);\n      return cells;\n    };\n\n    // Recursive implementation for rubberband selection\n    this.getAllCells = function (x, y, width, height, parent, result) {\n      result = result != null ? result : [];\n      if (width > 0 || height > 0) {\n        var model = this.getModel();\n        var right = x + width;\n        var bottom = y + height;\n        if (parent == null) {\n          parent = this.getCurrentRoot();\n          if (parent == null) {\n            parent = model.getRoot();\n          }\n        }\n        if (parent != null) {\n          var childCount = model.getChildCount(parent);\n          for (var i = 0; i < childCount; i++) {\n            var cell = model.getChildAt(parent, i);\n            var state = this.view.getState(cell);\n            if (state != null && this.isCellVisible(cell) && _mxGraphUtils[\"default\"].getValue(state.style, 'locked', '0') != '1') {\n              var deg = _mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_ROTATION) || 0;\n              var box = state;\n              if (deg != 0) {\n                box = _mxUtils[\"default\"].getBoundingBox(box, deg);\n              }\n              if ((model.isEdge(cell) || model.isVertex(cell)) && box.x >= x && box.y + box.height <= bottom && box.y >= y && box.x + box.width <= right) {\n                result.push(cell);\n              }\n              this.getAllCells(x, y, width, height, cell, result);\n            }\n          }\n        }\n      }\n      return result;\n    };\n\n    // Never removes cells from parents that are being moved\n    var graphHandlerShouldRemoveCellsFromParent = this.graphHandler.shouldRemoveCellsFromParent;\n    this.graphHandler.shouldRemoveCellsFromParent = function (parent, cells, evt) {\n      if (this.graph.isCellSelected(parent)) {\n        return false;\n      }\n      return graphHandlerShouldRemoveCellsFromParent.apply(this, arguments);\n    };\n\n    // Unlocks all cells\n    this.isCellLocked = function (cell) {\n      var pState = this.view.getState(cell);\n      while (pState != null) {\n        if (_mxGraphUtils[\"default\"].getValue(pState.style, 'locked', '0') == '1') {\n          return true;\n        }\n        pState = this.view.getState(this.model.getParent(pState.cell));\n      }\n      return false;\n    };\n    var tapAndHoldSelection = null;\n\n    // Uses this event to process mouseDown to check the selection state before it is changed\n    this.addListener(_mxEvent[\"default\"].FIRE_MOUSE_EVENT, _mxGraphUtils[\"default\"].bind(this, function (sender, evt) {\n      if (evt.getProperty('eventName') == 'mouseDown') {\n        var me = evt.getProperty('event');\n        var state = me.getState();\n        if (state != null && !this.isSelectionEmpty() && !this.isCellSelected(state.cell)) {\n          tapAndHoldSelection = this.getSelectionCells();\n        } else {\n          tapAndHoldSelection = null;\n        }\n      }\n    }));\n\n    // Tap and hold on background starts rubberband for multiple selected\n    // cells the cell associated with the event is deselected\n    this.addListener(_mxEvent[\"default\"].TAP_AND_HOLD, _mxGraphUtils[\"default\"].bind(this, function (sender, evt) {\n      if (!_mxEvent[\"default\"].isMultiTouchEvent(evt)) {\n        var me = evt.getProperty('event');\n        var cell = evt.getProperty('cell');\n        if (cell == null) {\n          var pt = _mxUtils[\"default\"].convertPoint(this.container, _mxEvent[\"default\"].getClientX(me), _mxEvent[\"default\"].getClientY(me));\n          rubberband.start(pt.x, pt.y);\n        } else if (tapAndHoldSelection != null) {\n          this.addSelectionCells(tapAndHoldSelection);\n        } else if (this.getSelectionCount() > 1 && this.isCellSelected(cell)) {\n          this.removeSelectionCell(cell);\n        }\n\n        // Blocks further processing of the event\n        tapAndHoldSelection = null;\n        evt.consume();\n      }\n    }));\n\n    // On connect the target is selected and we clone the cell of the preview edge for insert\n    this.connectionHandler.selectCells = function (edge, target) {\n      this.graph.setSelectionCell(target || edge);\n    };\n\n    // Shows connection points only if cell not selected\n    this.connectionHandler.constraintHandler.isStateIgnored = function (state, source) {\n      return source && state.view.graph.isCellSelected(state.cell);\n    };\n\n    // Updates constraint handler if the selection changes\n    this.selectionModel.addListener(_mxEvent[\"default\"].CHANGE, _mxGraphUtils[\"default\"].bind(this, function () {\n      var ch = this.connectionHandler.constraintHandler;\n      if (ch.currentFocus != null && ch.isStateIgnored(ch.currentFocus, true)) {\n        ch.currentFocus = null;\n        ch.constraints = null;\n        ch.destroyIcons();\n      }\n      ch.destroyFocusHighlight();\n    }));\n\n    // Initializes touch interface\n    if (Graph.touchStyle) {\n      this.initTouch();\n    }\n\n    /**\r\n     * Adds locking\r\n     */\n    var graphUpdateMouseEvent = this.updateMouseEvent;\n    this.updateMouseEvent = function (me) {\n      me = graphUpdateMouseEvent.apply(this, arguments);\n      if (this.isCellLocked(me.getCell())) {\n        me.state = null;\n      }\n      return me;\n    };\n  }\n};\n\n/**\r\n * Specifies if the touch UI should be used (cannot detect touch in FF so always on for Windows/Linux)\r\n */\nGraph.touchStyle = _mxClient[\"default\"].IS_TOUCH || _mxClient[\"default\"].IS_FF && _mxClient[\"default\"].IS_WIN || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 || window.urlParams == null || urlParams['touch'] == '1';\n\n/**\r\n * Shortcut for capability check.\r\n */\nGraph.fileSupport = window.File != null && window.FileReader != null && window.FileList != null && (window.urlParams == null || urlParams['filesupport'] != '0');\n\n// Graph inherits from mxGraph\n_mxGraphUtils[\"default\"].extend(Graph, _mxGraph[\"default\"]);\n\n/**\r\n * Allows all values in fit.\r\n */\nGraph.prototype.minFitScale = null;\n\n/**\r\n * Allows all values in fit.\r\n */\nGraph.prototype.maxFitScale = null;\n\n/**\r\n * Sets the default target for all links in cells.\r\n */\nGraph.prototype.linkTarget = '_blank';\n\n/**\r\n * Scrollbars are enabled on non-touch devices (not including Firefox because touch events\r\n * cannot be detected in Firefox, see above).\r\n */\nGraph.prototype.defaultScrollbars = true; //!mxClient.IS_IOS;\n\n/**\r\n * Specifies if the page should be visible for new files. Default is true.\r\n */\nGraph.prototype.defaultPageVisible = true;\n\n/**\r\n * Specifies if the app should run in chromeless mode. Default is false.\r\n * This default is only used if the contructor argument is null.\r\n */\nGraph.prototype.lightbox = false;\n\n/**\r\n * 属性配置页面打开时加1，关闭时减1，控制阻塞层\r\n */\nGraph.prototype.configurePageCount = 0;\n\n/**\r\n * graph所属页面pageId\r\n */\nGraph.prototype.pageId = null;\n\n/**\r\n * \r\n */\nGraph.prototype.defaultGraphBackground = '#ffffff';\n\n/**\r\n * Overrides the background color and paints a transparent background.\r\n */\nGraph.prototype.transparentBackground = true;\n\n/**\r\n * Sets the default target for all links in cells.\r\n */\nGraph.prototype.defaultEdgeLength = 80;\n\n/**\r\n * Allows all values in fit.\r\n */\nGraph.prototype.edgeMode = false;\n\n/**\r\n * Allows all values in fit.\r\n */\nGraph.prototype.connectionArrowsEnabled = true;\n\n/**\r\n * Specifies the regular expression for matching placeholders.\r\n */\nGraph.prototype.placeholderPattern = new RegExp('%(date\\{.*\\}|[^%^\\{^\\}]+)%', 'g');\n\n/**\r\n * Specifies the default name for the theme. Default is 'default'.\r\n */\nGraph.prototype.defaultThemeName = 'default';\n\n/**\r\n * Specifies the default name for the theme. Default is 'default'.\r\n */\nGraph.prototype.defaultThemes = {};\n\n/**\r\n * Base URL for relative links.\r\n */\nGraph.prototype.baseUrl = window.location != window.parent.location ? document.referrer : document.location.toString();\n\n/**\r\n * Installs child layout styles.\r\n */\nGraph.prototype.init = function (container) {\n  _mxGraph[\"default\"].prototype.init.apply(this, arguments);\n  this.initLayoutManager();\n};\n\n/**\r\n * Installs automatic layout via styles\r\n */\nGraph.prototype.initLayoutManager = function () {\n  this.layoutManager = new _mxLayoutManager[\"default\"](this);\n  this.layoutManager.getLayout = function (cell) {\n    var state = this.graph.view.getState(cell);\n    var style = state != null ? state.style : this.graph.getCellStyle(cell);\n    if (style['childLayout'] == 'stackLayout') {\n      var stackLayout = new _mxStackLayout[\"default\"](this.graph, true);\n      stackLayout.resizeParentMax = true;\n      stackLayout.horizontal = _mxGraphUtils[\"default\"].getValue(style, 'horizontalStack', '1') == '1';\n      stackLayout.resizeParent = _mxGraphUtils[\"default\"].getValue(style, 'resizeParent', '1') == '1';\n      stackLayout.resizeLast = _mxGraphUtils[\"default\"].getValue(style, 'resizeLast', '0') == '1';\n      stackLayout.marginLeft = style['marginLeft'] || 0;\n      stackLayout.marginRight = style['marginRight'] || 0;\n      stackLayout.marginTop = style['marginTop'] || 0;\n      stackLayout.marginBottom = style['marginBottom'] || 0;\n      stackLayout.fill = true;\n      return stackLayout;\n    } else if (style['childLayout'] == 'treeLayout') {\n      var treeLayout = new _mxCompactTreeLayout[\"default\"](this.graph);\n      treeLayout.horizontal = _mxGraphUtils[\"default\"].getValue(style, 'horizontalTree', '1') == '1';\n      treeLayout.resizeParent = _mxGraphUtils[\"default\"].getValue(style, 'resizeParent', '1') == '1';\n      treeLayout.groupPadding = _mxGraphUtils[\"default\"].getValue(style, 'parentPadding', 20);\n      treeLayout.levelDistance = _mxGraphUtils[\"default\"].getValue(style, 'treeLevelDistance', 30);\n      treeLayout.maintainParentLocation = true;\n      treeLayout.edgeRouting = false;\n      treeLayout.resetEdges = false;\n      return treeLayout;\n    } else if (style['childLayout'] == 'flowLayout') {\n      var flowLayout = new _mxHierarchicalLayout[\"default\"](this.graph, _mxGraphUtils[\"default\"].getValue(style, 'flowOrientation', _mxConstants[\"default\"].DIRECTION_EAST));\n      flowLayout.resizeParent = _mxGraphUtils[\"default\"].getValue(style, 'resizeParent', '1') == '1';\n      flowLayout.parentBorder = _mxGraphUtils[\"default\"].getValue(style, 'parentPadding', 20);\n      flowLayout.maintainParentLocation = true;\n\n      // Special undocumented styles for changing the hierarchical\n      flowLayout.intraCellSpacing = _mxGraphUtils[\"default\"].getValue(style, 'intraCellSpacing', _mxHierarchicalLayout[\"default\"].prototype.intraCellSpacing);\n      flowLayout.interRankCellSpacing = _mxGraphUtils[\"default\"].getValue(style, 'interRankCellSpacing', _mxHierarchicalLayout[\"default\"].prototype.interRankCellSpacing);\n      flowLayout.interHierarchySpacing = _mxGraphUtils[\"default\"].getValue(style, 'interHierarchySpacing', _mxHierarchicalLayout[\"default\"].prototype.interHierarchySpacing);\n      flowLayout.parallelEdgeSpacing = _mxGraphUtils[\"default\"].getValue(style, 'parallelEdgeSpacing', _mxHierarchicalLayout[\"default\"].prototype.parallelEdgeSpacing);\n      return flowLayout;\n    }\n    return null;\n  };\n};\n\n/**\r\n * Sanitizes the given HTML markup.\r\n */\nGraph.prototype.sanitizeHtml = function (value) {\n  // Uses https://code.google.com/p/google-caja/wiki/JsHtmlSanitizer\n  // NOTE: Original minimized sanitizer was modified to support data URIs for images\n  // LATER: Add MathML to whitelisted tags\n  function urlX(link) {\n    if (link != null && link.toString().toLowerCase().substring(0, 11) !== 'javascript:') {\n      return link;\n    }\n    return null;\n  }\n  ;\n  function idX(id) {\n    return id;\n  }\n  ;\n  return (0, _workflowUtil.sanitize)(value, urlX, idX);\n};\n\n/**\r\n * Revalidates all cells with placeholders in the current graph model.\r\n */\nGraph.prototype.updatePlaceholders = function () {\n  var model = this.model;\n  var validate = false;\n  for (var key in this.model.cells) {\n    var cell = this.model.cells[key];\n    if (this.isReplacePlaceholders(cell)) {\n      this.view.invalidate(cell, false, false);\n      validate = true;\n    }\n  }\n  if (validate) {\n    this.view.validate();\n  }\n};\n\n/**\r\n * Adds support for placeholders in labels.\r\n */\nGraph.prototype.isReplacePlaceholders = function (cell) {\n  return cell.value != null && _typeof(cell.value) == 'object'; //&& cell.value.getAttribute('placeholders') == '1';\n};\n\n/**\r\n * Adds ctrl+shift+connect to disable connections.\r\n */\nGraph.prototype.isIgnoreTerminalEvent = function (evt) {\n  return _mxEvent[\"default\"].isShiftDown(evt) && _mxEvent[\"default\"].isControlDown(evt);\n};\n\n/**\r\n * Adds support for placeholders in labels.\r\n */\nGraph.prototype.isSplitTarget = function (target, cells, evt) {\n  return !_mxEvent[\"default\"].isShiftDown(evt) && _mxGraph[\"default\"].prototype.isSplitTarget.apply(this, arguments);\n};\n\n/**\r\n * Adds support for placeholders in labels.\r\n */\nGraph.prototype.getLabel = function (cell) {\n  var result = _mxGraph[\"default\"].prototype.getLabel.apply(this, arguments);\n  if (result != null && this.isReplacePlaceholders(cell) && cell.getAttribute('placeholder') == null) {\n    result = this.replacePlaceholders(cell, result);\n  }\n  return result;\n};\n\n/**\r\n * Adds labelMovable style.\r\n */\nGraph.prototype.isLabelMovable = function (cell) {\n  var state = this.view.getState(cell);\n  var style = state != null ? state.style : this.getCellStyle(cell);\n  return !this.isCellLocked(cell) && (this.model.isEdge(cell) && this.edgeLabelsMovable || this.model.isVertex(cell) && (this.vertexLabelsMovable || _mxGraphUtils[\"default\"].getValue(style, 'labelMovable', '0') == '1'));\n};\n\n/**\r\n * Adds event if grid size is changed.\r\n */\n_mxGraph[\"default\"].prototype.setGridSize = function (value) {\n  this.gridSize = value;\n  this.fireEvent(new _mxEventObject[\"default\"]('gridSizeChanged'));\n};\n\n/**\r\n * Private helper method.\r\n */\nGraph.prototype.getGlobalVariable = function (name) {\n  var val = null;\n  if (name == 'date') {\n    val = new Date().toLocaleDateString();\n  } else if (name == 'time') {\n    val = new Date().toLocaleTimeString();\n  } else if (name == 'timestamp') {\n    val = new Date().toLocaleString();\n  } else if (name.substring(0, 5) == 'date{') {\n    var fmt = name.substring(5, name.length - 1);\n    val = this.formatDate(new Date(), fmt);\n  }\n  return val;\n};\n\n/**\r\n * Formats a date, see http://blog.stevenlevithan.com/archives/date-time-format\r\n */\nGraph.prototype.formatDate = function (date, mask, utc) {\n  // LATER: Cache regexs\n  if (this.dateFormatCache == null) {\n    this.dateFormatCache = {\n      i18n: {\n        dayNames: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n        monthNames: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\", \"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"]\n      },\n      masks: {\n        \"default\": \"ddd mmm dd yyyy HH:MM:ss\",\n        shortDate: \"m/d/yy\",\n        mediumDate: \"mmm d, yyyy\",\n        longDate: \"mmmm d, yyyy\",\n        fullDate: \"dddd, mmmm d, yyyy\",\n        shortTime: \"h:MM TT\",\n        mediumTime: \"h:MM:ss TT\",\n        longTime: \"h:MM:ss TT Z\",\n        isoDate: \"yyyy-mm-dd\",\n        isoTime: \"HH:MM:ss\",\n        isoDateTime: \"yyyy-mm-dd'T'HH:MM:ss\",\n        isoUtcDateTime: \"UTC:yyyy-mm-dd'T'HH:MM:ss'Z'\"\n      }\n    };\n  }\n  var dF = this.dateFormatCache;\n  var token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\\1?|[LloSZ]|\"[^\"]*\"|'[^']*'/g,\n    timezone = /\\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\\d{4})?)\\b/g,\n    timezoneClip = /[^-+\\dA-Z]/g,\n    pad = function pad(val, len) {\n      val = String(val);\n      len = len || 2;\n      while (val.length < len) val = \"0\" + val;\n      return val;\n    };\n\n  // You can't provide utc if you skip other args (use the \"UTC:\" mask prefix)\n  if (arguments.length == 1 && Object.prototype.toString.call(date) == \"[object String]\" && !/\\d/.test(date)) {\n    mask = date;\n    date = undefined;\n  }\n\n  // Passing date through Date applies Date.parse, if necessary\n  date = date ? new Date(date) : new Date();\n  if (isNaN(date)) throw SyntaxError(\"invalid date\");\n  mask = String(dF.masks[mask] || mask || dF.masks[\"default\"]);\n\n  // Allow setting the utc argument via the mask\n  if (mask.slice(0, 4) == \"UTC:\") {\n    mask = mask.slice(4);\n    utc = true;\n  }\n  var _ = utc ? \"getUTC\" : \"get\",\n    d = date[_ + \"Date\"](),\n    D = date[_ + \"Day\"](),\n    m = date[_ + \"Month\"](),\n    y = date[_ + \"FullYear\"](),\n    H = date[_ + \"Hours\"](),\n    M = date[_ + \"Minutes\"](),\n    s = date[_ + \"Seconds\"](),\n    L = date[_ + \"Milliseconds\"](),\n    o = utc ? 0 : date.getTimezoneOffset(),\n    flags = {\n      d: d,\n      dd: pad(d),\n      ddd: dF.i18n.dayNames[D],\n      dddd: dF.i18n.dayNames[D + 7],\n      m: m + 1,\n      mm: pad(m + 1),\n      mmm: dF.i18n.monthNames[m],\n      mmmm: dF.i18n.monthNames[m + 12],\n      yy: String(y).slice(2),\n      yyyy: y,\n      h: H % 12 || 12,\n      hh: pad(H % 12 || 12),\n      H: H,\n      HH: pad(H),\n      M: M,\n      MM: pad(M),\n      s: s,\n      ss: pad(s),\n      l: pad(L, 3),\n      L: pad(L > 99 ? Math.round(L / 10) : L),\n      t: H < 12 ? \"a\" : \"p\",\n      tt: H < 12 ? \"am\" : \"pm\",\n      T: H < 12 ? \"A\" : \"P\",\n      TT: H < 12 ? \"AM\" : \"PM\",\n      Z: utc ? \"UTC\" : (String(date).match(timezone) || [\"\"]).pop().replace(timezoneClip, \"\"),\n      o: (o > 0 ? \"-\" : \"+\") + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),\n      S: [\"th\", \"st\", \"nd\", \"rd\"][d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10]\n    };\n  return mask.replace(token, function ($0) {\n    return $0 in flags ? flags[$0] : $0.slice(1, $0.length - 1);\n  });\n};\n\n/**\r\n * \r\n */\nGraph.prototype.createLayersDialog = function () {\n  var div = document.createElement('div');\n  div.style.position = 'absolute';\n  var model = this.getModel();\n  var childCount = model.getChildCount(model.root);\n  for (var i = 0; i < childCount; i++) {\n    (function (layer) {\n      var span = document.createElement('div');\n      span.style.overflow = 'hidden';\n      span.style.textOverflow = 'ellipsis';\n      span.style.padding = '2px';\n      span.style.whiteSpace = 'nowrap';\n      var cb = document.createElement('input');\n      cb.setAttribute('type', 'checkbox');\n      if (model.isVisible(layer)) {\n        cb.setAttribute('checked', 'checked');\n        cb.defaultChecked = true;\n      }\n      span.appendChild(cb);\n      var title = layer.value || _mxResources[\"default\"].get('background') || 'Background';\n      span.setAttribute('title', title);\n      _mxGraphUtils[\"default\"].write(span, title);\n      div.appendChild(span);\n      _mxEvent[\"default\"].addListener(cb, 'click', function () {\n        if (cb.getAttribute('checked') != null) {\n          cb.removeAttribute('checked');\n        } else {\n          cb.setAttribute('checked', 'checked');\n        }\n        model.setVisible(layer, cb.checked);\n      });\n    })(model.getChildAt(model.root, i));\n  }\n  return div;\n};\n\n/**\r\n * Private helper method.\r\n */\nGraph.prototype.replacePlaceholders = function (cell, str) {\n  var result = [];\n  var last = 0;\n  while (match = this.placeholderPattern.exec(str)) {\n    var val = match[0];\n    if (val.length > 2 && val != '%label%' && val != '%tooltip%') {\n      var tmp = null;\n      if (match.index > last && str.charAt(match.index - 1) == '%') {\n        tmp = val.substring(1);\n      } else {\n        var name = val.substring(1, val.length - 1);\n\n        // Workaround for invalid char for getting attribute in older versions of IE\n        if (name.indexOf('{') < 0) {\n          var current = cell;\n\n          /*while (tmp == null && current != null)\r\n          {\r\n          \tif (current.value != null && typeof(current.value) == 'object')\r\n          \t{\r\n          \t\ttmp = current.value.getAttribute(name);\r\n          \t}\r\n          \t\r\n          \tcurrent = this.model.getParent(current);\r\n          }*/\n        }\n        if (tmp == null) {\n          tmp = this.getGlobalVariable(name);\n        }\n      }\n      result.push(str.substring(last, match.index) + (tmp || val));\n      last = match.index + val.length;\n    }\n  }\n  result.push(str.substring(last));\n  return result.join('');\n};\n\n/**\r\n * Selects cells for connect vertex return value.\r\n */\nGraph.prototype.selectCellsForConnectVertex = function (cells, evt, hoverIcons) {\n  // Selects only target vertex if one exists\n  if (cells.length == 2 && this.model.isVertex(cells[1])) {\n    this.setSelectionCell(cells[1]);\n    if (hoverIcons != null) {\n      // Adds hover icons to new target vertex for touch devices\n      if (_mxEvent[\"default\"].isTouchEvent(evt)) {\n        hoverIcons.update(hoverIcons.getState(this.view.getState(cells[1])));\n      } else {\n        // Hides hover icons after click with mouse\n        hoverIcons.reset();\n      }\n    }\n    this.scrollCellToVisible(cells[1]);\n  } else {\n    this.setSelectionCells(cells);\n  }\n};\n\n/**\r\n * Adds a connection to the given vertex.\r\n */\nGraph.prototype.connectVertex = function (source, direction, length, evt, forceClone) {\n  var pt = source.geometry.relative ? new _mxPoint[\"default\"](source.parent.geometry.width * source.geometry.x, source.parent.geometry.height * source.geometry.y) : new _mxPoint[\"default\"](source.geometry.x, source.geometry.y);\n  if (direction == _mxConstants[\"default\"].DIRECTION_NORTH) {\n    pt.x += source.geometry.width / 2;\n    pt.y -= length;\n  } else if (direction == _mxConstants[\"default\"].DIRECTION_SOUTH) {\n    pt.x += source.geometry.width / 2;\n    pt.y += source.geometry.height + length;\n  } else if (direction == _mxConstants[\"default\"].DIRECTION_WEST) {\n    pt.x -= length;\n    pt.y += source.geometry.height / 2;\n  } else {\n    pt.x += source.geometry.width + length;\n    pt.y += source.geometry.height / 2;\n  }\n  var parentState = this.view.getState(this.model.getParent(source));\n  var s = this.view.scale;\n  var t = this.view.translate;\n  var dx = t.x * s;\n  var dy = t.y * s;\n  if (this.model.isVertex(parentState.cell)) {\n    dx = parentState.x;\n    dy = parentState.y;\n  }\n\n  // Workaround for relative child cells\n  if (this.model.isVertex(source.parent) && source.geometry.relative) {\n    pt.x += source.parent.geometry.x;\n    pt.y += source.parent.geometry.y;\n  }\n\n  // Checks actual end point of edge for target cell\n  var target = _mxEvent[\"default\"].isControlDown(evt) && !forceClone ? null : this.getCellAt(dx + pt.x * s, dy + pt.y * s);\n  if (this.model.isAncestor(target, source)) {\n    target = null;\n  }\n\n  // Checks if target or ancestor is locked\n  var temp = target;\n  while (temp != null) {\n    if (this.isCellLocked(temp)) {\n      target = null;\n      break;\n    }\n    temp = this.model.getParent(temp);\n  }\n\n  // Checks if source and target intersect\n  if (target != null) {\n    var sourceState = this.view.getState(source);\n    var targetState = this.view.getState(target);\n    if (sourceState != null && targetState != null && _mxUtils[\"default\"].intersects(sourceState, targetState)) {\n      target = null;\n    }\n  }\n  var duplicate = forceClone || true; //!mxEvent.isShiftDown(evt) || forceClone\n\n  if (duplicate) {\n    if (direction == _mxConstants[\"default\"].DIRECTION_NORTH) {\n      pt.y -= source.geometry.height / 2;\n    } else if (direction == _mxConstants[\"default\"].DIRECTION_SOUTH) {\n      pt.y += source.geometry.height / 2;\n    } else if (direction == _mxConstants[\"default\"].DIRECTION_WEST) {\n      pt.x -= source.geometry.width / 2;\n    } else {\n      pt.x += source.geometry.width / 2;\n    }\n  }\n\n  // Uses connectable parent vertex if one exists\n  if (target != null && !this.isCellConnectable(target)) {\n    var parent = this.getModel().getParent(target);\n    if (this.getModel().isVertex(parent) && this.isCellConnectable(parent)) {\n      target = parent;\n    }\n  }\n  if (target == source || this.model.isEdge(target) || !this.isCellConnectable(target)) {\n    target = null;\n  }\n  var result = [];\n  this.model.beginUpdate();\n  try {\n    var realTarget = target;\n    if (realTarget == null && duplicate) {\n      // Handles relative children\n      var cellToClone = source;\n      var geo = this.getCellGeometry(source);\n      while (geo != null && geo.relative) {\n        cellToClone = this.getModel().getParent(cellToClone);\n        geo = this.getCellGeometry(cellToClone);\n      }\n\n      // Handle consistuents for cloning\n      var state = this.view.getState(cellToClone);\n      var style = state != null ? state.style : this.getCellStyle(cellToClone);\n      if (_mxGraphUtils[\"default\"].getValue(style, 'part', false)) {\n        var tmpParent = this.model.getParent(cellToClone);\n        if (this.model.isVertex(tmpParent)) {\n          cellToClone = tmpParent;\n        }\n      }\n      geo = geo.clone();\n      geo.x = pt.x - geo.width / 2;\n      geo.y = pt.y - geo.height / 2;\n      realTarget = this.duplicateCells([cellToClone], false, geo)[0];\n    }\n\n    // Never connects children in stack layouts\n    var layout = null;\n    if (this.layoutManager != null) {\n      layout = this.layoutManager.getLayout(this.model.getParent(source));\n    }\n    var edge = _mxEvent[\"default\"].isControlDown(evt) && duplicate || target == null && layout != null && layout.constructor == _mxStackLayout[\"default\"] ? null : this.insertEdge(this.model.getParent(source), null, '', source, realTarget, this.createCurrentEdgeStyle());\n\n    // Inserts edge before source\n    if (edge != null && this.connectionHandler.insertBeforeSource) {\n      var index = null;\n      var tmp = source;\n      while (tmp.parent != null && tmp.geometry != null && tmp.geometry.relative && tmp.parent != edge.parent) {\n        tmp = this.model.getParent(tmp);\n      }\n      if (tmp != null && tmp.parent != null && tmp.parent == edge.parent) {\n        var index = tmp.parent.getIndex(tmp);\n        tmp.parent.insert(edge, index);\n      }\n    }\n\n    // Special case: Click on west icon puts clone before cell\n    if (target == null && realTarget != null && layout != null && source.parent != null && layout.constructor == _mxStackLayout[\"default\"] && direction == _mxConstants[\"default\"].DIRECTION_WEST) {\n      var index = source.parent.getIndex(source);\n      source.parent.insert(realTarget, index);\n    }\n    if (edge != null) {\n      // Uses elbow edges with vertical or horizontal direction\n      //\t\t\tvar elbowValue = (direction == mxConstants.DIRECTION_NORTH || direction == mxConstants.DIRECTION_SOUTH) ? 'vertical' : 'horizontal';\n      //\t\t\tedge.style = mxUtils.setStyle(edge.style, 'edgeStyle', 'elbowEdgeStyle');\n      //\t\t\tedge.style = mxUtils.setStyle(edge.style, 'elbow', elbowValue);\n      result.push(edge);\n    }\n    if (target == null && realTarget != null) {\n      result.push(realTarget);\n    }\n    if (realTarget == null && edge != null) {\n      edge.geometry.setTerminalPoint(pt, false);\n    }\n    if (edge != null) {\n      this.fireEvent(new _mxEventObject[\"default\"]('cellsInserted', 'cells', [edge]));\n    }\n  } finally {\n    this.model.endUpdate();\n  }\n  return result;\n};\n\n/**\r\n * Returns the label for the given cell.\r\n */\nGraph.prototype.convertValueToString = function (cell) {\n  if (cell.value != null && _typeof(cell.value) == 'object') {\n    if (this.isReplacePlaceholders(cell) && cell.getAttribute('placeholder') != null) {\n      return this.getModel().getRoot().getAttribute(cell.getAttribute('placeholder')) || '';\n    } else {\n      return cell.value.value; //getAttribute('label');\n    }\n  }\n  return _mxGraph[\"default\"].prototype.convertValueToString.apply(this, arguments);\n};\n\n/**\r\n * Returns the link for the given cell.\r\n */\nGraph.prototype.getLinkForCell = function (cell) {\n  /*if (cell.value != null && typeof(cell.value) == 'object')\r\n  {\r\n  \tvar link = cell.value.getAttribute('link');\r\n  \t\r\n  \t// Removes links with leading javascript: protocol\r\n  \t// TODO: Check more possible attack vectors\r\n  \tif (link != null && link.toLowerCase().substring(0, 11) === 'javascript:')\r\n  \t{\r\n  \t\tlink = link.substring(11);\r\n  \t}\r\n  \t\r\n  \treturn link;\r\n  }*/\n\n  return null;\n};\n\n/**\r\n * Overrides label orientation for collapsed swimlanes inside stack.\r\n */\nGraph.prototype.getCellStyle = function (cell) {\n  var style = _mxGraph[\"default\"].prototype.getCellStyle.apply(this, arguments);\n  if (cell != null && this.layoutManager != null) {\n    var parent = this.model.getParent(cell);\n    if (this.model.isVertex(parent) && this.isCellCollapsed(cell)) {\n      var layout = this.layoutManager.getLayout(parent);\n      if (layout != null && layout.constructor == _mxStackLayout[\"default\"]) {\n        style[_mxConstants[\"default\"].STYLE_HORIZONTAL] = !layout.horizontal;\n      }\n    }\n  }\n  if (cell && cell.isEdge() && (0, _workflowUtil.isBizFlow)(this.flowType) && !style.strokeColor_important) {\n    style.strokeColor = '#7F93BC';\n  }\n  return style;\n};\n\n/**\r\n * Disables alternate width persistence for stack layout parents\r\n */\nGraph.prototype.updateAlternateBounds = function (cell, geo, willCollapse) {\n  if (cell != null && geo != null && this.layoutManager != null && geo.alternateBounds != null) {\n    var layout = this.layoutManager.getLayout(this.model.getParent(cell));\n    if (layout != null && layout.constructor == _mxStackLayout[\"default\"]) {\n      if (layout.horizontal) {\n        geo.alternateBounds.height = 0;\n      } else {\n        geo.alternateBounds.width = 0;\n      }\n    }\n  }\n  _mxGraph[\"default\"].prototype.updateAlternateBounds.apply(this, arguments);\n};\n\n/**\r\n * Adds Shift+collapse/expand and size management for folding inside stack\r\n */\nGraph.prototype.isMoveCellsEvent = function (evt) {\n  return _mxEvent[\"default\"].isShiftDown(evt);\n};\n\n/**\r\n * Adds Shift+collapse/expand and size management for folding inside stack\r\n */\nGraph.prototype.foldCells = function (collapse, recurse, cells, checkFoldable, evt) {\n  recurse = recurse != null ? recurse : false;\n  if (cells == null) {\n    cells = this.getFoldableCells(this.getSelectionCells(), collapse);\n  }\n  if (cells != null) {\n    this.model.beginUpdate();\n    try {\n      _mxGraph[\"default\"].prototype.foldCells.apply(this, arguments);\n\n      // Resizes all parent stacks if alt is not pressed\n      if (this.layoutManager != null) {\n        for (var i = 0; i < cells.length; i++) {\n          var state = this.view.getState(cells[i]);\n          var geo = this.getCellGeometry(cells[i]);\n          if (state != null && geo != null) {\n            var dx = Math.round(geo.width - state.width / this.view.scale);\n            var dy = Math.round(geo.height - state.height / this.view.scale);\n            if (dy != 0 || dx != 0) {\n              var parent = this.model.getParent(cells[i]);\n              var layout = this.layoutManager.getLayout(parent);\n              if (layout == null) {\n                // Moves cells to the right and down after collapse/expand\n                if (evt != null && this.isMoveCellsEvent(evt)) {\n                  this.moveSiblings(state, parent, dx, dy);\n                }\n              } else if ((evt == null || !_mxEvent[\"default\"].isAltDown(evt)) && layout.constructor == _mxStackLayout[\"default\"] && !layout.resizeLast) {\n                this.resizeParentStacks(parent, layout, dx, dy);\n              }\n            }\n          }\n        }\n      }\n    } finally {\n      this.model.endUpdate();\n    }\n    this.fireEvent(new _mxEventObject[\"default\"](_mxGraphConstant.EVENT.AFTER_FOLD_CELLS, 'cells', cells));\n\n    // Selects cells after folding\n    if (this.isEnabled()) {\n      this.setSelectionCells(cells);\n    }\n  }\n};\n\n/**\r\n * Overrides label orientation for collapsed swimlanes inside stack.\r\n */\nGraph.prototype.moveSiblings = function (state, parent, dx, dy) {\n  this.model.beginUpdate();\n  try {\n    var cells = this.getCellsBeyond(state.x, state.y, parent, true, true);\n    for (var i = 0; i < cells.length; i++) {\n      if (cells[i] != state.cell) {\n        var tmp = this.view.getState(cells[i]);\n        var geo = this.getCellGeometry(cells[i]);\n        if (tmp != null && geo != null) {\n          geo = geo.clone();\n          geo.translate(Math.round(dx * Math.max(0, Math.min(1, (tmp.x - state.x) / state.width))), Math.round(dy * Math.max(0, Math.min(1, (tmp.y - state.y) / state.height))));\n          this.model.setGeometry(cells[i], geo);\n        }\n      }\n    }\n  } finally {\n    this.model.endUpdate();\n  }\n};\n\n/**\r\n * Overrides label orientation for collapsed swimlanes inside stack.\r\n */\nGraph.prototype.resizeParentStacks = function (parent, layout, dx, dy) {\n  if (this.layoutManager != null && layout != null && layout.constructor == _mxStackLayout[\"default\"] && !layout.resizeLast) {\n    this.model.beginUpdate();\n    try {\n      var dir = layout.horizontal;\n\n      // Bubble resize up for all parent stack layouts with same orientation\n      while (parent != null && layout != null && layout.constructor == _mxStackLayout[\"default\"] && layout.horizontal == dir && !layout.resizeLast) {\n        var pgeo = this.getCellGeometry(parent);\n        var pstate = this.view.getState(parent);\n        if (pstate != null && pgeo != null) {\n          pgeo = pgeo.clone();\n          if (layout.horizontal) {\n            pgeo.width += dx + Math.min(0, pstate.width / this.view.scale - pgeo.width);\n          } else {\n            pgeo.height += dy + Math.min(0, pstate.height / this.view.scale - pgeo.height);\n          }\n          this.model.setGeometry(parent, pgeo);\n        }\n        parent = this.model.getParent(parent);\n        layout = this.layoutManager.getLayout(parent);\n      }\n    } finally {\n      this.model.endUpdate();\n    }\n  }\n};\n\n/**\r\n * Disables drill-down for non-swimlanes.\r\n */\nGraph.prototype.isContainer = function (cell) {\n  var state = this.view.getState(cell);\n  var style = state != null ? state.style : this.getCellStyle(cell);\n  if (this.isSwimlane(cell)) {\n    return style['container'] != '0';\n  } else {\n    return style['container'] == '1';\n  }\n};\n\n/**\r\n * Adds a connectable style.\r\n */\nGraph.prototype.isCellConnectable = function (cell) {\n  var state = this.view.getState(cell);\n  var style = state != null ? state.style : this.getCellStyle(cell);\n  return style['connectable'] != null ? style['connectable'] != '0' : _mxGraph[\"default\"].prototype.isCellConnectable.apply(this, arguments);\n};\n\n/**\r\n * Function: selectAll\r\n * \r\n * Selects all children of the given parent cell or the children of the\r\n * default parent if no parent is specified. To select leaf vertices and/or\r\n * edges use <selectCells>.\r\n * \r\n * Parameters:\r\n * \r\n * parent - Optional <mxCell> whose children should be selected.\r\n * Default is <defaultParent>.\r\n */\nGraph.prototype.selectAll = function (parent) {\n  parent = parent || this.getDefaultParent();\n  if (!this.isCellLocked(parent)) {\n    _mxGraph[\"default\"].prototype.selectAll.apply(this, arguments);\n  }\n};\n\n/**\r\n * Function: selectCells\r\n * \r\n * Selects all vertices and/or edges depending on the given boolean\r\n * arguments recursively, starting at the given parent or the default\r\n * parent if no parent is specified. Use <selectAll> to select all cells.\r\n * For vertices, only cells with no children are selected.\r\n * \r\n * Parameters:\r\n * \r\n * vertices - Boolean indicating if vertices should be selected.\r\n * edges - Boolean indicating if edges should be selected.\r\n * parent - Optional <mxCell> that acts as the root of the recursion.\r\n * Default is <defaultParent>.\r\n */\nGraph.prototype.selectCells = function (vertices, edges, parent) {\n  parent = parent || this.getDefaultParent();\n  if (!this.isCellLocked(parent)) {\n    _mxGraph[\"default\"].prototype.selectCells.apply(this, arguments);\n  }\n};\n\n/**\r\n * Function: getSwimlaneAt\r\n * \r\n * Returns the bottom-most swimlane that intersects the given point (x, y)\r\n * in the cell hierarchy that starts at the given parent.\r\n * \r\n * Parameters:\r\n * \r\n * x - X-coordinate of the location to be checked.\r\n * y - Y-coordinate of the location to be checked.\r\n * parent - <mxCell> that should be used as the root of the recursion.\r\n * Default is <defaultParent>.\r\n */\nGraph.prototype.getSwimlaneAt = function (x, y, parent) {\n  parent = parent || this.getDefaultParent();\n  if (!this.isCellLocked(parent)) {\n    return _mxGraph[\"default\"].prototype.getSwimlaneAt.apply(this, arguments);\n  }\n  return null;\n};\n\n/**\r\n * Disables folding for non-swimlanes.\r\n */\nGraph.prototype.isCellFoldable = function (cell) {\n  var state = this.view.getState(cell);\n  var style = state != null ? state.style : this.getCellStyle(cell);\n  return this.foldingEnabled && !this.isCellLocked(cell) && (this.isContainer(cell) && style['collapsible'] != '0' || !this.isContainer(cell) && style['collapsible'] == '1');\n};\n\n/**\r\n * Stops all interactions and clears the selection.\r\n */\nGraph.prototype.reset = function () {\n  if (this.isEditing()) {\n    this.stopEditing(true);\n  }\n  this.escape();\n  if (!this.isSelectionEmpty()) {\n    this.clearSelection();\n  }\n};\n\n/**\r\n * Overridden to limit zoom to 1% - 16.000%.\r\n */\nGraph.prototype.zoom = function (factor, center) {\n  factor = Math.max(0.01, Math.min(this.view.scale * factor, 160)) / this.view.scale;\n  _mxGraph[\"default\"].prototype.zoom.apply(this, arguments);\n};\n\n/**\r\n * Function: zoomIn\r\n * \r\n * Zooms into the graph by <zoomFactor>.\r\n */\nGraph.prototype.zoomIn = function () {\n  // Switches to 1% zoom steps below 15%\n  /*if (this.view.scale < 0.15)\r\n  {\r\n  \tthis.zoom((this.view.scale + 0.01) / this.view.scale);\r\n  }\r\n  else\r\n  {\r\n  \t// Uses to 5% zoom steps for better grid rendering in webkit\r\n  \t// and to avoid rounding errors for zoom steps\r\n  \tthis.zoom((Math.round(this.view.scale * this.zoomFactor * 20) / 20) / this.view.scale);\r\n  }*/\n  this.zoomByStep(true);\n};\n\n/**\r\n * Function: zoomOut\r\n * \r\n * Zooms out of the graph by <zoomFactor>.\r\n */\nGraph.prototype.zoomOut = function () {\n  // Switches to 1% zoom steps below 15%\n  /*if (this.view.scale <= 0.15)\r\n  {\r\n  \tthis.zoom((this.view.scale - 0.01) / this.view.scale);\r\n  }\r\n  else\r\n  {\r\n  \t// Uses to 5% zoom steps for better grid rendering in webkit\r\n  \t// and to avoid rounding errors for zoom steps\r\n  \tthis.zoom((Math.round(this.view.scale * (1 / this.zoomFactor) * 20) / 20) / this.view.scale);\r\n  }*/\n  this.zoomByStep(false);\n};\n\n/*\r\n * 将进度转换为缩放系数\r\n * UE规定缩放进度为：50%，缩放范围：50% ~ 200%\r\n */\nGraph.prototype.zoomByStep = function (zoomIn) {\n  var next = this.view.scale;\n  if (zoomIn) {\n    next += 0.1;\n  } else {\n    next -= 0.1;\n  }\n  if (next < _mxGraphConstant.zoom_min || next > _mxGraphConstant.zoom_max) {\n    return;\n  }\n  if (next) {\n    this.zoom(next / this.view.scale);\n  }\n};\n\n/**\r\n * Overrides tooltips to show custom tooltip or metadata.\r\n */\nGraph.prototype.getTooltipForCell = function (cell) {\n  var tip = '';\n\n  /*if (mxGraphUtils.isNode(cell.value))\r\n  {\r\n  \tvar tmp = cell.value.getAttribute('tooltip');\r\n  \t\r\n  \tif (tmp != null)\r\n  \t{\r\n  \t\tif (tmp != null && this.isReplacePlaceholders(cell))\r\n  \t\t{\r\n  \t\t\ttmp = this.replacePlaceholders(cell, tmp);\r\n  \t\t}\r\n  \t\t\r\n  \t\ttip = this.sanitizeHtml(tmp);\r\n  \t}\r\n  \telse\r\n  \t{\r\n  \t\tvar ignored = ['label', 'tooltip', 'placeholders'];\r\n  \t\tvar attrs = cell.value.attributes;\r\n  \t\t\r\n  \t\t// Hides links in edit mode\r\n  \t\tif (this.isEnabled())\r\n  \t\t{\r\n  \t\t\tignored.push('link');\r\n  \t\t}\r\n  \t\t\r\n  \t\tfor (var i = 0; i < attrs.length; i++)\r\n  \t\t{\r\n  \t\t\tif (mxGraphUtils.indexOf(ignored, attrs[i].nodeName) < 0 && attrs[i].nodeValue.length > 0)\r\n  \t\t\t{\r\n  \t\t\t\t// Hides link key in read mode\r\n  \t\t\t\tif (attrs[i].nodeName == 'link')\r\n  \t\t\t\t{\r\n  \t\t\t\t\ttip += mxGraphUtils.htmlEntities(this.getLinkUrl(attrs[i].nodeValue)) + '\\n';\r\n  \t\t\t\t}\r\n  \t\t\t\telse\r\n  \t\t\t\t{\r\n  \t\t\t\t\ttip += attrs[i].nodeName + ': ' + mxGraphUtils.htmlEntities(attrs[i].nodeValue) + '\\n';\r\n  \t\t\t\t}\r\n  \t\t\t}\r\n  \t\t}\r\n  \t\t\r\n  \t\tif (tip.length > 0)\r\n  \t\t{\r\n  \t\t\ttip = tip.substring(0, tip.length - 1);\r\n  \t\t}\r\n  \t}\r\n  }*/\n\n  return tip;\n};\n\n/**\r\n * Turns the given string into an array.\r\n */\nGraph.prototype.stringToBytes = function (str) {\n  var arr = new Array(str.length);\n  for (var i = 0; i < str.length; i++) {\n    arr[i] = str.charCodeAt(i);\n  }\n  return arr;\n};\n\n/**\r\n * Turns the given array into a string.\r\n */\nGraph.prototype.bytesToString = function (arr) {\n  var result = new Array(arr.length);\n  for (var i = 0; i < arr.length; i++) {\n    result[i] = String.fromCharCode(arr[i]);\n  }\n  return result.join('');\n};\n\n/**\r\n * Returns a base64 encoded version of the compressed string.\r\n */\nGraph.prototype.compress = function (data) {\n  if (data == null || data.length == 0 || typeof pako === 'undefined') {\n    return data;\n  } else {\n    var tmp = this.bytesToString(pako.deflateRaw(encodeURIComponent(data)));\n    return window.btoa ? btoa(tmp) : Base64.encode(tmp, true);\n  }\n};\n\n/**\r\n * Returns a decompressed version of the base64 encoded string.\r\n */\nGraph.prototype.decompress = function (data) {\n  if (data == null || data.length == 0 || typeof pako === 'undefined') {\n    return data;\n  } else {\n    var tmp = window.atob ? atob(data) : Base64.decode(data, true);\n    return this.zapGremlins(decodeURIComponent(this.bytesToString(pako.inflateRaw(tmp))));\n  }\n};\n\n/**\r\n * Removes all illegal control characters with ASCII code <32 except TAB, LF\r\n * and CR.\r\n */\nGraph.prototype.zapGremlins = function (text) {\n  var checked = [];\n  for (var i = 0; i < text.length; i++) {\n    var code = text.charCodeAt(i);\n\n    // Removes all control chars except TAB, LF and CR\n    if (code >= 32 || code == 9 || code == 10 || code == 13) {\n      checked.push(text.charAt(i));\n    }\n  }\n  return checked.join('');\n};\nfunction getModelBounds(graph) {\n  var pageSize = graph.getPreferredPageSize();\n  var translate = graph.view.translate;\n  return {\n    upperLeft: {\n      x: translate.x,\n      y: translate.y\n    },\n    lowerRight: {\n      x: pageSize.width,\n      y: pageSize.height\n    }\n  };\n}\nGraph.prototype.getModelGraph = function () {\n  var json = this.model.getModelGraph();\n  json.bounds = getModelBounds(this);\n  return json;\n};\n\n/**\r\n* 返回图形的json格式\r\n*/\nGraph.prototype.getJSONModel = function () {\n  var json = this.model.toBpmnJSON();\n  json.bounds = getModelBounds(this);\n  return json;\n};\nGraph.prototype.resetStylesheet = function () {\n  this.setStylesheet(this.createStylesheet());\n};\n\n/**\r\n * Returns the DOM nodes for the given cells.\r\n */\nGraph.prototype.getNodesForCells = function (cells) {\n  var nodes = [];\n  for (var i = 0; i < cells.length; i++) {\n    var state = this.view.getState(cells[i]);\n    if (state != null) {\n      var shapes = this.cellRenderer.getShapesForState(state);\n      for (var j = 0; j < shapes.length; j++) {\n        if (shapes[j] != null && shapes[j].node != null) {\n          nodes.push(shapes[j].node);\n        }\n      }\n\n      // Adds folding icon\n      if (state.control != null && state.control.node != null) {\n        nodes.push(state.control.node);\n      }\n    }\n  }\n  return nodes;\n};\n\n/**\r\n * Creates animations for the given cells.\r\n */\nGraph.prototype.createWipeAnimations = function (cells, wipeIn) {\n  var animations = [];\n  for (var i = 0; i < cells.length; i++) {\n    var state = this.view.getState(cells[i]);\n    if (state != null && state.shape != null) {\n      // TODO: include descendants\n      if (this.model.isEdge(state.cell) && state.absolutePoints != null && state.absolutePoints.length > 1) {\n        animations.push(this.createEdgeWipeAnimation(state, wipeIn));\n      } else if (this.model.isVertex(state.cell) && state.shape.bounds != null) {\n        animations.push(this.createVertexWipeAnimation(state, wipeIn));\n      }\n    }\n  }\n  return animations;\n};\n\n/**\r\n * Creates an object to show the given edge cell state.\r\n */\nGraph.prototype.createEdgeWipeAnimation = function (state, wipeIn) {\n  var pts = state.absolutePoints.slice();\n  var segs = state.segments;\n  var total = state.length;\n  var n = pts.length;\n  return {\n    execute: _mxUtils[\"default\"].bind(this, function (step, steps) {\n      if (state.shape != null) {\n        var pts2 = [pts[0]];\n        var f = step / steps;\n        if (!wipeIn) {\n          f = 1 - f;\n        }\n        var dist = total * f;\n        for (var i = 1; i < n; i++) {\n          if (dist <= segs[i - 1]) {\n            pts2.push(new _mxPoint[\"default\"](pts[i - 1].x + (pts[i].x - pts[i - 1].x) * dist / segs[i - 1], pts[i - 1].y + (pts[i].y - pts[i - 1].y) * dist / segs[i - 1]));\n            break;\n          } else {\n            dist -= segs[i - 1];\n            pts2.push(pts[i]);\n          }\n        }\n        state.shape.points = pts2;\n        state.shape.redraw();\n        if (step == 0) {\n          Graph.setOpacityForNodes(this.getNodesForCells([state.cell]), 1);\n        }\n        if (state.text != null && state.text.node != null) {\n          state.text.node.style.opacity = f;\n        }\n      }\n    }),\n    stop: _mxUtils[\"default\"].bind(this, function () {\n      if (state.shape != null) {\n        state.shape.points = pts;\n        state.shape.redraw();\n        if (state.text != null && state.text.node != null) {\n          state.text.node.style.opacity = '';\n        }\n        Graph.setOpacityForNodes(this.getNodesForCells([state.cell]), wipeIn ? 1 : 0);\n      }\n    })\n  };\n};\n\n/**\r\n * Creates an object to show the given vertex cell state.\r\n */\nGraph.prototype.createVertexWipeAnimation = function (state, wipeIn) {\n  var bds = new _mxRectangle[\"default\"].fromRectangle(state.shape.bounds);\n  return {\n    execute: _mxUtils[\"default\"].bind(this, function (step, steps) {\n      if (state.shape != null) {\n        var f = step / steps;\n        if (!wipeIn) {\n          f = 1 - f;\n        }\n        state.shape.bounds = new _mxRectangle[\"default\"](bds.x, bds.y, bds.width * f, bds.height);\n        state.shape.redraw();\n        if (step == 0) {\n          Graph.setOpacityForNodes(this.getNodesForCells([state.cell]), 1);\n        }\n        if (state.text != null && state.text.node != null) {\n          state.text.node.style.opacity = f;\n        }\n      }\n    }),\n    stop: _mxUtils[\"default\"].bind(this, function () {\n      if (state.shape != null) {\n        state.shape.bounds = bds;\n        state.shape.redraw();\n        if (state.text != null && state.text.node != null) {\n          state.text.node.style.opacity = '';\n        }\n        Graph.setOpacityForNodes(this.getNodesForCells([state.cell]), wipeIn ? 1 : 0);\n      }\n    })\n  };\n};\n\n/**\r\n * Runs the animations for the given cells.\r\n */\nGraph.prototype.executeAnimations = function (animations, done, steps, delay) {\n  steps = steps != null ? steps : 30;\n  delay = delay != null ? delay : 30;\n  var thread = null;\n  var step = 0;\n  var animate = _mxUtils[\"default\"].bind(this, function () {\n    if (step == steps || this.stoppingCustomActions) {\n      window.clearInterval(thread);\n      for (var i = 0; i < animations.length; i++) {\n        animations[i].stop();\n      }\n      if (done != null) {\n        done();\n      }\n    } else {\n      for (var i = 0; i < animations.length; i++) {\n        animations[i].execute(step, steps);\n      }\n    }\n    step++;\n  });\n  thread = window.setInterval(animate, delay);\n  animate();\n};\n\n/**\r\n * Fades the given nodes in or out.\r\n */\nGraph.fadeNodes = function (nodes, start, end, done, delay) {\n  delay = delay != null ? delay : 1000;\n  Graph.setTransitionForNodes(nodes, null);\n  Graph.setOpacityForNodes(nodes, start);\n  window.setTimeout(function () {\n    Graph.setTransitionForNodes(nodes, 'all ' + delay + 'ms ease-in-out');\n    Graph.setOpacityForNodes(nodes, end);\n    window.setTimeout(function () {\n      Graph.setTransitionForNodes(nodes, null);\n      if (done != null) {\n        done();\n      }\n    }, delay);\n  }, 0);\n};\n\n/**\r\n * Sets the transition for the given nodes.\r\n */\nGraph.setTransitionForNodes = function (nodes, transition) {\n  for (var i = 0; i < nodes.length; i++) {\n    _mxUtils[\"default\"].setPrefixedStyle(nodes[i].style, 'transition', transition);\n  }\n};\n\n/**\r\n * Sets the opacity for the given nodes.\r\n */\nGraph.setOpacityForNodes = function (nodes, opacity) {\n  for (var i = 0; i < nodes.length; i++) {\n    nodes[i].style.opacity = opacity;\n  }\n};\n\n/**\r\n * Hover icons are used for hover, vertex handler and drag from sidebar.\r\n */\nvar _default = exports[\"default\"] = Graph;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxGraph/Graph.js?");

/***/ }),

/***/ "./src/workflow/mxGraph/GraphActions.js":
/*!**********************************************!*\
  !*** ./src/workflow/mxGraph/GraphActions.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.addWaypointAction = addWaypointAction;\nexports.animationAction = animationAction;\nexports.autosizeAction = autosizeAction;\nexports.clearWaypointsAction = clearWaypointsAction;\nexports.collapsibleAction = collapsibleAction;\nexports.curvedAction = curvedAction;\nexports.dashedAction = dashedAction;\nexports.dottedAction = dottedAction;\nexports.editDataAction = editDataAction;\nexports.editLinkAction = editLinkAction;\nexports.editStyleAction = editStyleAction;\nexports.editTooltipAction = editTooltipAction;\nexports.fitPageAction = fitPageAction;\nexports.fitPageWidthAction = fitPageWidthAction;\nexports.fitTwoPagesAction = fitTwoPagesAction;\nexports.formattedTextAction = formattedTextAction;\nexports.groupAction = groupAction;\nexports.imageAction = imageAction;\nexports.importAction = importAction;\nexports.insertLinkAction = insertLinkAction;\nexports.layersAction = layersAction;\nexports.linkAction = linkAction;\nexports.lockUnlockAction = lockUnlockAction;\nexports.openLinkAction = openLinkAction;\nexports.outlineAction = outlineAction;\nexports.pageScaleAction = pageScaleAction;\nexports.pageViewAction = pageViewAction;\nexports.pasteHereAction = pasteHereAction;\nexports.rotationAction = rotationAction;\nexports.roundedAction = roundedAction;\nexports.sharpAction = sharpAction;\nexports.solidAction = solidAction;\nexports.toggleRoundedAction = toggleRoundedAction;\nexports.ungroupAction = ungroupAction;\nexports.wordWrapAction = wordWrapAction;\n__webpack_require__(/*! core-js/modules/es.array.index-of.js */ \"../../node_modules/core-js/modules/es.array.index-of.js\");\n__webpack_require__(/*! core-js/modules/es.array.last-index-of.js */ \"../../node_modules/core-js/modules/es.array.last-index-of.js\");\n__webpack_require__(/*! core-js/modules/es.function.bind.js */ \"../../node_modules/core-js/modules/es.function.bind.js\");\n__webpack_require__(/*! core-js/modules/es.function.name.js */ \"../../node_modules/core-js/modules/es.function.name.js\");\n__webpack_require__(/*! core-js/modules/es.object.keys.js */ \"../../node_modules/core-js/modules/es.object.keys.js\");\n__webpack_require__(/*! core-js/modules/es.parse-float.js */ \"../../node_modules/core-js/modules/es.parse-float.js\");\n__webpack_require__(/*! core-js/modules/es.parse-int.js */ \"../../node_modules/core-js/modules/es.parse-int.js\");\n__webpack_require__(/*! core-js/modules/es.regexp.exec.js */ \"../../node_modules/core-js/modules/es.regexp.exec.js\");\n__webpack_require__(/*! core-js/modules/es.string.replace.js */ \"../../node_modules/core-js/modules/es.string.replace.js\");\n__webpack_require__(/*! core-js/modules/es.string.trim.js */ \"../../node_modules/core-js/modules/es.string.trim.js\");\n__webpack_require__(/*! core-js/modules/web.timers.js */ \"../../node_modules/core-js/modules/web.timers.js\");\nvar _mxEventObject = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxEventObject.js */ \"./src/workflow/mxClient/mxEventObject.js\"));\nvar _mxGraphModel = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxGraphModel.js */ \"./src/workflow/mxClient/mxGraphModel.js\"));\nvar _mxGeometry = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxGeometry.js */ \"./src/workflow/mxClient/mxGeometry.js\"));\nvar _mxCodec = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxCodec.js */ \"./src/workflow/mxClient/mxCodec.js\"));\nvar _mxEdgeHandler = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxEdgeHandler.js */ \"./src/workflow/mxClient/mxEdgeHandler.js\"));\nvar _OpenDialog = _interopRequireDefault(__webpack_require__(/*! ./OpenDialog.js */ \"./src/workflow/mxGraph/OpenDialog.js\"));\nvar _OpenFile = _interopRequireDefault(__webpack_require__(/*! ./OpenFile.js */ \"./src/workflow/mxGraph/OpenFile.js\"));\nvar _Graph = _interopRequireDefault(__webpack_require__(/*! ./Graph.js */ \"./src/workflow/mxGraph/Graph.js\"));\nvar _LinkDialog = _interopRequireDefault(__webpack_require__(/*! ./LinkDialog.js */ \"./src/workflow/mxGraph/LinkDialog.js\"));\nvar _mxCell = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxCell.js */ \"./src/workflow/mxClient/mxCell.js\"));\nvar _mxUtils = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxUtils.js */ \"./src/workflow/mxClient/mxUtils.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxClipboard = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxClipboard.js */ \"./src/workflow/mxClient/mxClipboard.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nvar _EditDataDialog = _interopRequireDefault(__webpack_require__(/*! ./EditDataDialog.js */ \"./src/workflow/mxGraph/EditDataDialog.js\"));\nvar _TextareaDialog = _interopRequireDefault(__webpack_require__(/*! ./TextareaDialog.js */ \"./src/workflow/mxGraph/TextareaDialog.js\"));\nvar _FilenameDialog = _interopRequireDefault(__webpack_require__(/*! ./FilenameDialog.js */ \"./src/workflow/mxGraph/FilenameDialog.js\"));\nvar _mxResources = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxResources.js */ \"./src/workflow/mxClient/mxResources.js\"));\nvar _OutlineWindow = _interopRequireDefault(__webpack_require__(/*! ./OutlineWindow.js */ \"./src/workflow/mxGraph/OutlineWindow.js\"));\nvar _LayersWindow = _interopRequireDefault(__webpack_require__(/*! ./LayersWindow.js */ \"./src/workflow/mxGraph/LayersWindow.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction outlineAction(ui) {\n  return _mxGraphUtils[\"default\"].bind(this, function () {\n    if (this.outlineWindow == null) {\n      // LATER: Check layers window for initial placement\n      this.outlineWindow = new _OutlineWindow[\"default\"](ui, document.body.offsetWidth - 260, 100, 180, 180);\n      this.outlineWindow.window.addListener('show', function () {\n        ui.fireEvent(new _mxEventObject[\"default\"]('outline'));\n      });\n      this.outlineWindow.window.addListener('hide', function () {\n        ui.fireEvent(new _mxEventObject[\"default\"]('outline'));\n      });\n      this.outlineWindow.window.setVisible(true);\n      ui.fireEvent(new _mxEventObject[\"default\"]('outline'));\n    } else {\n      this.outlineWindow.window.setVisible(!this.outlineWindow.window.isVisible());\n    }\n    ui.fireEvent(new _mxEventObject[\"default\"]('outline'));\n  });\n}\n;\nfunction layersAction(ui) {\n  return _mxGraphUtils[\"default\"].bind(this, function () {\n    if (this.layersWindow == null) {\n      // LATER: Check outline window for initial placement\n      this.layersWindow = new _LayersWindow[\"default\"](ui, document.body.offsetWidth - 280, 120, 220, 180);\n      this.layersWindow.window.addListener('show', function () {\n        ui.fireEvent(new _mxEventObject[\"default\"]('layers'));\n      });\n      this.layersWindow.window.addListener('hide', function () {\n        ui.fireEvent(new _mxEventObject[\"default\"]('layers'));\n      });\n      this.layersWindow.window.setVisible(true);\n      ui.fireEvent(new _mxEventObject[\"default\"]('layers'));\n    } else {\n      this.layersWindow.window.setVisible(!this.layersWindow.window.isVisible());\n    }\n\n    //ui.fireEvent(new mxEventObject('layers'));\n  });\n}\n;\nfunction imageAction(ui, graph) {\n  return function () {\n    if (graph.isEnabled() && !graph.isCellLocked(graph.getDefaultParent())) {\n      var title = _mxResources[\"default\"].get('image') + ' (' + _mxResources[\"default\"].get('url') + '):';\n      var state = graph.getView().getState(graph.getSelectionCell());\n      var value = '';\n      if (state != null) {\n        value = state.style[_mxConstants[\"default\"].STYLE_IMAGE] || value;\n      }\n      var selectionState = graph.cellEditor.saveSelection();\n      ui.showImageDialog(title, value, function (newValue, w, h) {\n        // Inserts image into HTML text\n        if (graph.cellEditor.isContentEditing()) {\n          graph.cellEditor.restoreSelection(selectionState);\n          graph.insertImage(newValue, w, h);\n        } else {\n          var cells = graph.getSelectionCells();\n          if (newValue != null) {\n            var select = null;\n            graph.getModel().beginUpdate();\n            try {\n              // Inserts new cell if no cell is selected\n              if (cells.length == 0) {\n                var pt = graph.getInsertPoint();\n                cells = [graph.insertVertex(graph.getDefaultParent(), null, '', pt.x, pt.y, w, h, 'shape=image;verticalLabelPosition=bottom;verticalAlign=top;')];\n                select = cells;\n              }\n              graph.setCellStyles(_mxConstants[\"default\"].STYLE_IMAGE, newValue, cells);\n\n              // Sets shape only if not already shape with image (label or image)\n              var state = graph.view.getState(cells[0]);\n              var style = state != null ? state.style : graph.getCellStyle(cells[0]);\n              if (style[_mxConstants[\"default\"].STYLE_SHAPE] != 'image' && style[_mxConstants[\"default\"].STYLE_SHAPE] != 'label') {\n                graph.setCellStyles(_mxConstants[\"default\"].STYLE_SHAPE, 'image', cells);\n              }\n              if (graph.getSelectionCount() == 1) {\n                if (w != null && h != null) {\n                  var cell = cells[0];\n                  var geo = graph.getModel().getGeometry(cell);\n                  if (geo != null) {\n                    geo = geo.clone();\n                    geo.width = w;\n                    geo.height = h;\n                    graph.getModel().setGeometry(cell, geo);\n                  }\n                }\n              }\n            } finally {\n              graph.getModel().endUpdate();\n            }\n            if (select != null) {\n              graph.setSelectionCells(select);\n              graph.scrollCellToVisible(select[0]);\n            }\n          }\n        }\n      }, graph.cellEditor.isContentEditing(), !graph.cellEditor.isContentEditing());\n    }\n  };\n}\n;\nfunction clearWaypointsAction(graph) {\n  return function () {\n    var cells = graph.getSelectionCells();\n    if (cells != null) {\n      graph.getModel().beginUpdate();\n      try {\n        for (var i = 0; i < cells.length; i++) {\n          var cell = cells[i];\n          if (graph.getModel().isEdge(cell)) {\n            var geo = graph.getCellGeometry(cell);\n            if (geo != null) {\n              geo = geo.clone();\n              geo.points = null;\n              graph.getModel().setGeometry(cell, geo);\n            }\n          }\n        }\n      } finally {\n        graph.getModel().endUpdate();\n      }\n    }\n  };\n}\n;\nfunction addWaypointAction(editor, graph) {\n  return function () {\n    var cell = graph.getSelectionCell();\n    if (cell != null && graph.getModel().isEdge(cell)) {\n      var handler = editor.graph.selectionCellsHandler.getHandler(cell);\n      if (handler instanceof _mxEdgeHandler[\"default\"]) {\n        var t = graph.view.translate;\n        var s = graph.view.scale;\n        var dx = t.x;\n        var dy = t.y;\n        var parent = graph.getModel().getParent(cell);\n        var pgeo = graph.getCellGeometry(parent);\n        while (graph.getModel().isVertex(parent) && pgeo != null) {\n          dx += pgeo.x;\n          dy += pgeo.y;\n          parent = graph.getModel().getParent(parent);\n          pgeo = graph.getCellGeometry(parent);\n        }\n        var x = Math.round(graph.snap(graph.popupMenuHandler.triggerX / s - dx));\n        var y = Math.round(graph.snap(graph.popupMenuHandler.triggerY / s - dy));\n        handler.addPointAt(handler.state, x, y);\n      }\n    }\n  };\n}\n;\nfunction editStyleAction(graph) {\n  return _mxGraphUtils[\"default\"].bind(this, function () {\n    var cells = graph.getSelectionCells();\n    if (cells != null && cells.length > 0) {\n      var model = graph.getModel();\n      var dlg = new _TextareaDialog[\"default\"](this.editorUi, _mxResources[\"default\"].get('editStyle') + ':', model.getStyle(cells[0]) || '', function (newValue) {\n        if (newValue != null) {\n          graph.setCellStyle(_mxGraphUtils[\"default\"].trim(newValue), cells);\n        }\n      }, null, null, 400, 220);\n      this.editorUi.showDialog(dlg.container, 420, 300, true, true);\n      dlg.init();\n    }\n  });\n}\n;\nfunction collapsibleAction(ui, graph) {\n  return function () {\n    var state = graph.view.getState(graph.getSelectionCell());\n    var value = '1';\n    if (state != null && graph.getFoldingImage(state) != null) {\n      value = '0';\n    }\n    graph.setCellStyles('collapsible', value);\n    ui.fireEvent(new _mxEventObject[\"default\"]('styleChanged', 'keys', ['collapsible'], 'values', [value], 'cells', graph.getSelectionCells()));\n  };\n}\n;\nfunction curvedAction(ui, graph) {\n  return function () {\n    graph.getModel().beginUpdate();\n    try {\n      graph.setCellStyles(_mxConstants[\"default\"].STYLE_ROUNDED, '0');\n      graph.setCellStyles(_mxConstants[\"default\"].STYLE_CURVED, '1');\n      ui.fireEvent(new _mxEventObject[\"default\"]('styleChanged', 'keys', [_mxConstants[\"default\"].STYLE_ROUNDED, _mxConstants[\"default\"].STYLE_CURVED], 'values', ['0', '1'], 'cells', graph.getSelectionCells()));\n    } finally {\n      graph.getModel().endUpdate();\n    }\n  };\n}\n;\nfunction toggleRoundedAction(ui, graph) {\n  return function () {\n    if (!graph.isSelectionEmpty() && graph.isEnabled()) {\n      graph.getModel().beginUpdate();\n      try {\n        var cells = graph.getSelectionCells();\n        var state = graph.view.getState(cells[0]);\n        var style = state != null ? state.style : graph.getCellStyle(cells[0]);\n        var value = _mxGraphUtils[\"default\"].getValue(style, _mxConstants[\"default\"].STYLE_ROUNDED, '0') == '1' ? '0' : '1';\n        graph.setCellStyles(_mxConstants[\"default\"].STYLE_ROUNDED, value);\n        graph.setCellStyles(_mxConstants[\"default\"].STYLE_CURVED, null);\n        ui.fireEvent(new _mxEventObject[\"default\"]('styleChanged', 'keys', [_mxConstants[\"default\"].STYLE_ROUNDED, _mxConstants[\"default\"].STYLE_CURVED], 'values', [value, '0'], 'cells', graph.getSelectionCells()));\n      } finally {\n        graph.getModel().endUpdate();\n      }\n    }\n  };\n}\n;\nfunction roundedAction(ui, graph) {\n  return function () {\n    graph.getModel().beginUpdate();\n    try {\n      graph.setCellStyles(_mxConstants[\"default\"].STYLE_ROUNDED, '1');\n      graph.setCellStyles(_mxConstants[\"default\"].STYLE_CURVED, '0');\n      ui.fireEvent(new _mxEventObject[\"default\"]('styleChanged', 'keys', [_mxConstants[\"default\"].STYLE_ROUNDED, _mxConstants[\"default\"].STYLE_CURVED], 'values', ['1', '0'], 'cells', graph.getSelectionCells()));\n    } finally {\n      graph.getModel().endUpdate();\n    }\n  };\n}\n;\nfunction sharpAction(ui, graph) {\n  return function () {\n    graph.getModel().beginUpdate();\n    try {\n      graph.setCellStyles(_mxConstants[\"default\"].STYLE_ROUNDED, '0');\n      graph.setCellStyles(_mxConstants[\"default\"].STYLE_CURVED, '0');\n      ui.fireEvent(new _mxEventObject[\"default\"]('styleChanged', 'keys', [_mxConstants[\"default\"].STYLE_ROUNDED, _mxConstants[\"default\"].STYLE_CURVED], 'values', ['0', '0'], 'cells', graph.getSelectionCells()));\n    } finally {\n      graph.getModel().endUpdate();\n    }\n  };\n}\n;\nfunction dottedAction(ui, graph) {\n  return function () {\n    graph.getModel().beginUpdate();\n    try {\n      graph.setCellStyles(_mxConstants[\"default\"].STYLE_DASHED, '1');\n      graph.setCellStyles(_mxConstants[\"default\"].STYLE_DASH_PATTERN, '1 4');\n      ui.fireEvent(new _mxEventObject[\"default\"]('styleChanged', 'keys', [_mxConstants[\"default\"].STYLE_DASHED, _mxConstants[\"default\"].STYLE_DASH_PATTERN], 'values', ['1', '1 4'], 'cells', graph.getSelectionCells()));\n    } finally {\n      graph.getModel().endUpdate();\n    }\n  };\n}\n;\nfunction dashedAction(ui, graph) {\n  return function () {\n    graph.getModel().beginUpdate();\n    try {\n      graph.setCellStyles(_mxConstants[\"default\"].STYLE_DASHED, '1');\n      graph.setCellStyles(_mxConstants[\"default\"].STYLE_DASH_PATTERN, null);\n      ui.fireEvent(new _mxEventObject[\"default\"]('styleChanged', 'keys', [_mxConstants[\"default\"].STYLE_DASHED, _mxConstants[\"default\"].STYLE_DASH_PATTERN], 'values', ['1', null], 'cells', graph.getSelectionCells()));\n    } finally {\n      graph.getModel().endUpdate();\n    }\n  };\n}\n;\nfunction solidAction(ui, graph) {\n  return function () {\n    graph.getModel().beginUpdate();\n    try {\n      graph.setCellStyles(_mxConstants[\"default\"].STYLE_DASHED, null);\n      graph.setCellStyles(_mxConstants[\"default\"].STYLE_DASH_PATTERN, null);\n      ui.fireEvent(new _mxEventObject[\"default\"]('styleChanged', 'keys', [_mxConstants[\"default\"].STYLE_DASHED, _mxConstants[\"default\"].STYLE_DASH_PATTERN], 'values', [null, null], 'cells', graph.getSelectionCells()));\n    } finally {\n      graph.getModel().endUpdate();\n    }\n  };\n}\n;\nfunction pageViewAction(ui, graph) {\n  return _mxGraphUtils[\"default\"].bind(this, function () {\n    var hasScrollbars = _mxUtils[\"default\"].hasScrollbars(graph.container);\n    var tx = 0;\n    var ty = 0;\n    if (hasScrollbars) {\n      tx = graph.view.translate.x * graph.view.scale - graph.container.scrollLeft;\n      ty = graph.view.translate.y * graph.view.scale - graph.container.scrollTop;\n    }\n    graph.pageVisible = !graph.pageVisible;\n    graph.pageBreaksVisible = graph.pageVisible;\n    graph.preferPageSize = graph.pageBreaksVisible;\n    graph.view.validateBackground();\n\n    // Workaround for possible handle offset\n    if (hasScrollbars) {\n      var cells = graph.getSelectionCells();\n      graph.clearSelection();\n      graph.setSelectionCells(cells);\n    }\n\n    // Calls updatePageBreaks\n    graph.sizeDidChange();\n    if (hasScrollbars) {\n      graph.container.scrollLeft = graph.view.translate.x * graph.view.scale - tx;\n      graph.container.scrollTop = graph.view.translate.y * graph.view.scale - ty;\n    }\n    ui.fireEvent(new _mxEventObject[\"default\"]('pageViewChanged'));\n  });\n}\n;\nfunction pageScaleAction(graph) {\n  return _mxGraphUtils[\"default\"].bind(this, function () {\n    var dlg = new _FilenameDialog[\"default\"](this.editorUi, parseInt(graph.pageScale * 100), _mxResources[\"default\"].get('apply'), _mxGraphUtils[\"default\"].bind(this, function (newValue) {\n      var val = parseInt(newValue);\n      if (!isNaN(val) && val > 0) {\n        ui.setPageScale(val / 100);\n      }\n    }), _mxResources[\"default\"].get('pageScale') + ' (%)');\n    this.editorUi.showDialog(dlg.container, 300, 80, true, true);\n    dlg.init();\n  });\n}\n;\nfunction fitPageWidthAction(graph) {\n  return _mxGraphUtils[\"default\"].bind(this, function () {\n    if (!graph.pageVisible) {\n      this.get('pageView').funct();\n    }\n    var fmt = graph.pageFormat;\n    var ps = graph.pageScale;\n    var cw = graph.container.clientWidth - 10;\n    var scale = Math.floor(20 * cw / fmt.width / ps) / 20;\n    graph.zoomTo(scale);\n    if (_mxUtils[\"default\"].hasScrollbars(graph.container)) {\n      var pad = graph.getPagePadding();\n      graph.container.scrollLeft = Math.min(pad.x * graph.view.scale, (graph.container.scrollWidth - graph.container.clientWidth) / 2);\n    }\n  });\n}\n;\nfunction fitTwoPagesAction(graph) {\n  return _mxGraphUtils[\"default\"].bind(this, function () {\n    if (!graph.pageVisible) {\n      this.get('pageView').funct();\n    }\n    var fmt = graph.pageFormat;\n    var ps = graph.pageScale;\n    var cw = graph.container.clientWidth - 10;\n    var ch = graph.container.clientHeight - 10;\n    var scale = Math.floor(20 * Math.min(cw / (2 * fmt.width) / ps, ch / fmt.height / ps)) / 20;\n    graph.zoomTo(scale);\n    if (_mxUtils[\"default\"].hasScrollbars(graph.container)) {\n      var pad = graph.getPagePadding();\n      graph.container.scrollTop = Math.min(pad.y, (graph.container.scrollHeight - graph.container.clientHeight) / 2);\n      graph.container.scrollLeft = Math.min(pad.x, (graph.container.scrollWidth - graph.container.clientWidth) / 2);\n    }\n  });\n}\n;\nfunction fitPageAction(graph) {\n  return _mxGraphUtils[\"default\"].bind(this, function () {\n    if (!graph.pageVisible) {\n      this.get('pageView').funct();\n    }\n    var fmt = graph.pageFormat;\n    var ps = graph.pageScale;\n    var cw = graph.container.clientWidth - 10;\n    var ch = graph.container.clientHeight - 10;\n    var scale = Math.floor(20 * Math.min(cw / fmt.width / ps, ch / fmt.height / ps)) / 20;\n    graph.zoomTo(scale);\n    if (_mxUtils[\"default\"].hasScrollbars(graph.container)) {\n      var pad = graph.getPagePadding();\n      graph.container.scrollTop = pad.y * graph.view.scale;\n      graph.container.scrollLeft = Math.min(pad.x * graph.view.scale, (graph.container.scrollWidth - graph.container.clientWidth) / 2);\n    }\n  });\n}\n;\nfunction rotationAction(ui, graph) {\n  return function () {\n    var value = '0';\n    var state = graph.getView().getState(graph.getSelectionCell());\n    if (state != null) {\n      value = state.style[_mxConstants[\"default\"].STYLE_ROTATION] || value;\n    }\n    var dlg = new _FilenameDialog[\"default\"](ui, value, _mxResources[\"default\"].get('apply'), function (newValue) {\n      if (newValue != null && newValue.length > 0) {\n        graph.setCellStyles(_mxConstants[\"default\"].STYLE_ROTATION, newValue);\n      }\n    }, _mxResources[\"default\"].get('enterValue') + ' (' + _mxResources[\"default\"].get('rotation') + ' 0-360)');\n    ui.showDialog(dlg.container, 300, 80, true, true);\n    dlg.init();\n  };\n}\n;\nfunction wordWrapAction(graph) {\n  return function () {\n    var state = graph.getView().getState(graph.getSelectionCell());\n    var value = 'wrap';\n    graph.stopEditing();\n    if (state != null && state.style[_mxConstants[\"default\"].STYLE_WHITE_SPACE] == 'wrap') {\n      value = null;\n    }\n    graph.setCellStyles(_mxConstants[\"default\"].STYLE_WHITE_SPACE, value);\n  };\n}\n;\nfunction formattedTextAction(ui, graph) {\n  return function () {\n    var state = graph.getView().getState(graph.getSelectionCell());\n    if (state != null) {\n      var value = '1';\n      graph.stopEditing();\n      graph.getModel().beginUpdate();\n      try {\n        if (state.style['html'] == '1') {\n          value = null;\n\n          // Removes newlines from HTML and converts breaks to newlines\n          // to match the HTML output in plain text\n          if (_mxGraphUtils[\"default\"].getValue(state.style, 'nl2Br', '1') != '0') {\n            graph.cellLabelChanged(state.cell, graph.convertValueToString(state.cell).replace(/\\n/g, '').replace(/<br\\s*.?>/g, '\\n'));\n          }\n        } else {\n          // FIXME: HTML entities are converted in plain text labels if word wrap is on\n          // TODO: Convert HTML entities? (Check for userobject!)\n          // Converts newlines in plain text to breaks in HTML\n          // to match the plain text output\n          var label = graph.convertValueToString(state.cell);\n          if (_mxGraphUtils[\"default\"].getValue(state.style, 'nl2Br', '1') != '0') {\n            label = label.replace(/\\n/g, '<br/>');\n          }\n          graph.cellLabelChanged(state.cell, graph.sanitizeHtml(label));\n        }\n        graph.setCellStyles('html', value);\n        ui.fireEvent(new _mxEventObject[\"default\"]('styleChanged', 'keys', ['html'], 'values', [value != null ? value : '0'], 'cells', graph.getSelectionCells()));\n      } finally {\n        graph.getModel().endUpdate();\n      }\n    }\n  };\n}\n;\nfunction autosizeAction(graph) {\n  return function () {\n    var cells = graph.getSelectionCells();\n    if (cells != null) {\n      graph.getModel().beginUpdate();\n      try {\n        for (var i = 0; i < cells.length; i++) {\n          var cell = cells[i];\n          if (graph.getModel().getChildCount(cell)) {\n            graph.updateGroupBounds([cell], 20);\n          } else {\n            var state = graph.view.getState(cell);\n            var geo = graph.getCellGeometry(cell);\n            if (graph.getModel().isVertex(cell) && state != null && state.text != null && geo != null && graph.isWrapping(cell)) {\n              geo = geo.clone();\n              geo.height = state.text.boundingBox.height / graph.view.scale;\n              graph.getModel().setGeometry(cell, geo);\n            } else {\n              graph.updateCellSize(cell);\n            }\n          }\n        }\n      } finally {\n        graph.getModel().endUpdate();\n      }\n    }\n  };\n}\n;\nfunction linkAction(ui) {\n  return _mxGraphUtils[\"default\"].bind(this, function () {\n    var graph = ui.editor.graph;\n    if (graph.isEnabled()) {\n      if (graph.cellEditor.isContentEditing()) {\n        var link = graph.getParentByName(graph.getSelectedElement(), 'A', graph.cellEditor.textarea);\n        var oldValue = '';\n        if (link != null) {\n          oldValue = link.getAttribute('href') || '';\n        }\n        var selState = graph.cellEditor.saveSelection();\n        ui.showLinkDialog(oldValue, _mxResources[\"default\"].get('apply'), _mxGraphUtils[\"default\"].bind(this, function (value) {\n          graph.cellEditor.restoreSelection(selState);\n          if (value != null) {\n            if (value.length == 0) {\n              document.execCommand('unlink', false);\n            } else {\n              // To find the new link, we create a list of all existing links first\n              var tmp = graph.cellEditor.textarea.getElementsByTagName('a');\n              var oldLinks = [];\n              for (var i = 0; i < tmp.length; i++) {\n                oldLinks.push(tmp[i]);\n              }\n\n              // LATER: Fix inserting link/image in IE8/quirks after focus lost\n              document.execCommand('createlink', false, _mxGraphUtils[\"default\"].trim(value));\n\n              // Adds target=\"_blank\" for the new link\n              var newLinks = graph.cellEditor.textarea.getElementsByTagName('a');\n              if (newLinks.length == oldLinks.length + 1) {\n                // Inverse order in favor of appended links\n                for (var i = newLinks.length - 1; i >= 0; i--) {\n                  if (i == 0 || newLinks[i] != oldLinks[i - 1]) {\n                    newLinks[i].setAttribute('target', '_blank');\n                    break;\n                  }\n                }\n              }\n            }\n          }\n        }));\n      } else if (graph.isSelectionEmpty()) {\n        this.get('insertLink').funct();\n      } else {\n        this.get('editLink').funct();\n      }\n    }\n  });\n}\n;\nfunction insertLinkAction(ui, graph) {\n  return function () {\n    if (graph.isEnabled() && !graph.isCellLocked(graph.getDefaultParent())) {\n      var dlg = new _LinkDialog[\"default\"](ui, '', _mxResources[\"default\"].get('insert'), function (link, docs) {\n        link = _mxGraphUtils[\"default\"].trim(link);\n        if (link.length > 0) {\n          var title = link.substring(link.lastIndexOf('/') + 1);\n          var icon = null;\n          if (docs != null && docs.length > 0) {\n            icon = docs[0].iconUrl;\n            title = docs[0].name || docs[0].type;\n            title = title.charAt(0).toUpperCase() + title.substring(1);\n            if (title.length > 30) {\n              title = title.substring(0, 30) + '...';\n            }\n          }\n          var pt = graph.getInsertPoint();\n          var linkCell = new _mxCell[\"default\"](title, new _mxGeometry[\"default\"](pt.x, pt.y, 100, 40), 'fontColor=#0000EE;fontStyle=4;rounded=1;overflow=hidden;' + (icon != null ? 'shape=label;imageWidth=16;imageHeight=16;spacingLeft=26;align=left;image=' + icon : 'spacing=10;'));\n          linkCell.vertex = true;\n          graph.setLinkForCell(linkCell, link);\n          graph.cellSizeUpdated(linkCell, true);\n          graph.setSelectionCell(graph.addCell(linkCell));\n        }\n      });\n      ui.showDialog(dlg.container, 420, 90, true, true);\n      dlg.init();\n    }\n  };\n}\n;\nfunction editLinkAction(ui, graph) {\n  return function () {\n    var graph = ui.editor.graph;\n    if (graph.isEnabled() && !graph.isSelectionEmpty()) {\n      var cell = graph.getSelectionCell();\n      var value = graph.getLinkForCell(cell) || '';\n      ui.showLinkDialog(value, _mxResources[\"default\"].get('apply'), function (link) {\n        link = _mxGraphUtils[\"default\"].trim(link);\n        graph.setLinkForCell(cell, link.length > 0 ? link : null);\n      });\n    }\n  };\n}\n;\nfunction openLinkAction(graph) {\n  return function () {\n    var link = graph.getLinkForCell(graph.getSelectionCell());\n    if (link != null) {\n      window.open(link);\n    }\n  };\n}\n;\nfunction editTooltipAction(ui, graph) {\n  return function () {\n    var graph = ui.editor.graph;\n    if (graph.isEnabled() && !graph.isSelectionEmpty()) {\n      var cell = graph.getSelectionCell();\n      var tooltip = '';\n      if (_mxGraphUtils[\"default\"].isNode(cell.value)) {\n        /*var tmp = cell.value.getAttribute('tooltip');\n        \tif (tmp != null)\n        {\n        \ttooltip = tmp;\n        }*/\n      }\n      var dlg = new _TextareaDialog[\"default\"](ui, _mxResources[\"default\"].get('editTooltip') + ':', tooltip, function (newValue) {\n        graph.setTooltipForCell(cell, newValue);\n      });\n      ui.showDialog(dlg.container, 320, 200, true, true);\n      dlg.init();\n    }\n  };\n}\n;\nfunction editDataAction(ui, graph) {\n  return function () {\n    var cell = graph.getSelectionCell() || graph.getModel().getRoot();\n    if (cell != null) {\n      var dlg = new _EditDataDialog[\"default\"](ui, cell);\n      ui.showDialog(dlg.container, 320, 320, true, false);\n      dlg.init();\n    }\n  };\n}\n;\nfunction ungroupAction(graph) {\n  return function () {\n    if (graph.getSelectionCount() == 1 && graph.getModel().getChildCount(graph.getSelectionCell()) == 0) {\n      graph.setCellStyles('container', '0');\n    } else {\n      graph.setSelectionCells(graph.ungroupCells());\n    }\n  };\n}\n;\nfunction groupAction(graph) {\n  return function () {\n    if (graph.getSelectionCount() == 1) {\n      graph.setCellStyles('container', '1');\n    } else {\n      graph.setSelectionCell(graph.groupCells(null, 0));\n    }\n  };\n}\n;\nfunction lockUnlockAction(graph) {\n  return function () {\n    if (!graph.isSelectionEmpty()) {\n      graph.getModel().beginUpdate();\n      try {\n        var defaultValue = graph.isCellMovable(graph.getSelectionCell()) ? 1 : 0;\n        graph.toggleCellStyles(_mxConstants[\"default\"].STYLE_MOVABLE, defaultValue);\n        graph.toggleCellStyles(_mxConstants[\"default\"].STYLE_RESIZABLE, defaultValue);\n        graph.toggleCellStyles(_mxConstants[\"default\"].STYLE_ROTATABLE, defaultValue);\n        graph.toggleCellStyles(_mxConstants[\"default\"].STYLE_DELETABLE, defaultValue);\n        graph.toggleCellStyles(_mxConstants[\"default\"].STYLE_EDITABLE, defaultValue);\n        graph.toggleCellStyles('connectable', defaultValue);\n      } finally {\n        graph.getModel().endUpdate();\n      }\n    }\n  };\n}\nfunction pasteHereAction(graph) {\n  return function (evt) {\n    if (graph.isEnabled() && !graph.isCellLocked(graph.getDefaultParent())) {\n      graph.getModel().beginUpdate();\n      try {\n        var cells = _mxClipboard[\"default\"].paste(graph);\n        if (cells != null) {\n          var bb = graph.getBoundingBoxFromGeometry(cells);\n          if (bb != null) {\n            var t = graph.view.translate;\n            var s = graph.view.scale;\n            var dx = t.x;\n            var dy = t.y;\n            var x = Math.round(graph.snap(graph.popupMenuHandler.triggerX / s - dx));\n            var y = Math.round(graph.snap(graph.popupMenuHandler.triggerY / s - dy));\n            graph.cellsMoved(cells, x - bb.x, y - bb.y);\n          }\n        }\n      } finally {\n        graph.getModel().endUpdate();\n      }\n    }\n  };\n}\nfunction animationAction(ui, graph) {\n  function animateCells(graph, cells, steps, delay) {\n    graph.executeAnimations(graph.createWipeAnimations(cells, true), null, steps, delay);\n  }\n  ;\n  function toggleFlowAnim(graph, cells, status) {\n    if (!status) {\n      status = 'toggle';\n    }\n    for (var i = 0; i < cells.length; i++) {\n      if (ui.editor.graph.model.isEdge(cells[i])) {\n        var state = graph.view.getState(cells[i]);\n        if (state && state.shape != null) {\n          var paths = state.shape.node.getElementsByTagName('path');\n          if (paths.length > 1) {\n            if (status == 'toggle' && paths[1].getAttribute('class') == 'mxEdgeFlow' || status == 'stop') {\n              paths[1].removeAttribute('class');\n              if (_mxUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_DASHED, '0') != '1') {\n                paths[1].removeAttribute('stroke-dasharray');\n              }\n            } else if (status == 'toggle' && paths[1].getAttribute('class') != 'mxEdgeFlow' || status == 'start') {\n              paths[1].setAttribute('class', 'mxEdgeFlow');\n              if (_mxUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_DASHED, '0') != '1') {\n                paths[1].setAttribute('stroke-dasharray', '8');\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  ;\n  function mapCell(cell, clone, mapping) {\n    mapping = mapping != null ? mapping : new Object();\n    mapping[cell.id] = clone;\n    var childCount = cell.getChildCount();\n    for (var i = 0; i < childCount; i++) {\n      mapCell(cell.getChildAt(i), clone.getChildAt(i), mapping);\n    }\n    return mapping;\n  }\n  ;\n  var allowedToRun = false;\n  var running = false;\n  function stop() {\n    allowedToRun = false;\n  }\n  ;\n  function run(graph, steps, loop, cellMap) {\n    if (!steps || steps.length < 1) {\n      return;\n    }\n    if (!running) {\n      var next = function next() {\n        if (allowedToRun && step < steps.length) {\n          var tokens = steps[step].split(' ');\n          if (tokens.length > 0) {\n            if (tokens[0] == 'wait' && tokens.length > 1) {\n              window.setTimeout(function () {\n                step++;\n                next();\n              }, parseFloat(tokens[1]));\n            } else {\n              if (tokens.length > 1) {\n                var cell = mapping[tokens[1]];\n                if (cell != null) {\n                  if (tokens[0] == 'show') {\n                    graph.setCellStyles('opacity', '100', [cell]);\n                    graph.setCellStyles('noLabel', null, [cell]);\n                    if (tokens.length > 2 && tokens[2] == 'fade') {\n                      _Graph[\"default\"].fadeNodes(graph.getNodesForCells([cell]), 0, 1);\n                    } else {\n                      animateCells(graph, [cell]);\n                    }\n                  } else if (tokens[0] == 'flow') {\n                    if (graph.model.isEdge(cell)) {\n                      toggleFlowAnim(graph, [cell], tokens[2]);\n                    }\n                  } else if (tokens[0] == 'hide') {\n                    _Graph[\"default\"].fadeNodes(graph.getNodesForCells([cell]), 1, 0);\n                  }\n                } else {\n                  console.log('cell not found', id, steps[step]);\n                }\n              }\n              step++;\n              next();\n            }\n          }\n        } else {\n          running = false;\n          graph.setAnimation(false);\n          if (loop) {\n            // Workaround for edge animation\n            graph.refresh();\n            run(graph, steps, loop);\n          }\n        }\n      };\n      allowedToRun = true;\n      running = true;\n      var graphModel = graph.getModel();\n      graphModel.beginUpdate();\n      try {\n        var ids = cellMap && Object.keys(cellMap);\n        if (!ids || ids.length < 1) {\n          ids = Object.keys(graphModel.cells);\n        }\n        for (var i in ids) {\n          var cell = graphModel.getCell(ids[i]);\n          if (graphModel.isVertex(cell) || graphModel.isEdge(cell)) {\n            graph.setCellStyles('opacity', '0', [cell]);\n            graph.setCellStyles('noLabel', '1', [cell]);\n          }\n        }\n      } finally {\n        graphModel.endUpdate();\n      }\n      var mapping = mapCell(ui.editor.graph.getModel().getRoot(), graphModel.getRoot());\n      var step = 0;\n      ;\n      next();\n    }\n  }\n  ;\n  function getAnimationElements(graph) {\n    var root = graph.getModel().getBPMNRoot();\n    var children = root.children;\n    if (!children || !children.length) {\n      return [];\n    }\n    var start = null;\n    for (var i = 0; i < children.length; i++) {\n      var child = children[i];\n      if (child.type == 'StartSignalEvent') {\n        start = child;\n        break;\n      }\n    }\n    if (!start) {\n      return [];\n    }\n    var nextNodes = null;\n    var queue = [[start]];\n    var layers = [];\n    var renderedEdge = {};\n    var renderedVertex = {};\n    while ((nextNodes = queue.pop()) != null) {\n      //记录当前层节点\n      var nodes = [];\n      //记录下层节点\n      var tgts = [];\n      //记录当前层节点的出口线\n      var flows = [];\n      for (var _i = 0; _i < nextNodes.length; _i++) {\n        var node = nextNodes[_i];\n        var nodeId = node.id;\n        if (renderedVertex[nodeId]) {\n          //节点已处理过\n          continue;\n        }\n        nodes.push(node);\n        renderedVertex[nodeId] = true;\n        var edges = node.edges || [];\n        for (var j = 0; j < edges.length; j++) {\n          var edge = edges[j];\n          var edgeId = edge.id;\n          var tgt = edge.target;\n          var incoming = tgt && tgt.id == nodeId;\n          if (renderedEdge[edgeId] || incoming) {\n            continue;\n          }\n          flows.push(edge);\n          renderedEdge[edgeId] = true;\n          if (!renderedVertex[tgt.id] && tgts.indexOf(tgt) < 0) {\n            tgts.push(tgt);\n          }\n        }\n      }\n      if (nodes.length > 0) {\n        layers.push(nodes);\n      }\n      if (flows.length > 0) {\n        layers.push(flows);\n      }\n      if (tgts.length > 0) {\n        queue.push(tgts);\n      }\n    }\n    return layers;\n  }\n  return _mxGraphUtils[\"default\"].bind(this, function (animation) {\n    if (graph.isAnimation()) {\n      return;\n    }\n    var layers = [];\n    if (animation instanceof Array) {\n      //指定了要动画的元素\n      layers = animation;\n    } else {\n      //从开始节点开始动画\n      layers = getAnimationElements(graph);\n    }\n    var steps = [];\n    var cellMap = {};\n    var wait = 'wait 800';\n    for (var i = 0; i < layers.length; i++) {\n      var cells = layers[i];\n      for (var j = 0; j < cells.length; j++) {\n        var cell = cells[j];\n        if (cell instanceof _mxCell[\"default\"]) {\n          //mxCell\n          steps.push(\"show \".concat(cell.id, \" fade\"));\n        } else {\n          //String\n          cellMap[cell] = cell;\n          steps.push(\"show \".concat(cell, \" fade\"));\n        }\n      }\n      steps.push(wait);\n    }\n\n    //居中\n    var container = graph.container;\n    var bounds = graph.getGraphBounds();\n    if (container && !(container.offsetWidth === 0 && container.offsetHeight === 0) && _mxUtils[\"default\"].hasScrollbars(container)) {\n      container.scrollLeft = bounds.x + bounds.width / 2 - container.clientWidth / 2;\n      container.scrollTop = bounds.y + bounds.height / 2 - container.clientHeight / 2;\n    }\n    graph.setAnimation(true);\n    run(graph, steps, false, cellMap);\n  });\n}\n;\nfunction importAction(ui, editor) {\n  return function () {\n    window.openNew = false;\n    window.openKey = 'import';\n\n    // Closes dialog after open\n    window.openFile = new _OpenFile[\"default\"](_mxGraphUtils[\"default\"].bind(this, function () {\n      ui.hideDialog();\n    }));\n    window.openFile.setConsumer(_mxGraphUtils[\"default\"].bind(this, function (xml, filename) {\n      try {\n        var doc = _mxUtils[\"default\"].parseXml(xml);\n        var model = new _mxGraphModel[\"default\"]();\n        var codec = new _mxCodec[\"default\"](doc);\n        codec.decode(doc.documentElement, model);\n        var children = model.getChildren(model.getChildAt(model.getRoot(), 0));\n        editor.graph.setSelectionCells(editor.graph.importCells(children));\n      } catch (e) {\n        _mxUtils[\"default\"].alert(_mxResources[\"default\"].get('invalidOrMissingFile') + ': ' + e.message);\n      }\n    }));\n\n    // Removes openFile if dialog is closed\n    ui.showDialog(new _OpenDialog[\"default\"](this).container, 320, 220, true, true, function () {\n      window.openFile = null;\n    });\n  };\n}\n;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxGraph/GraphActions.js?");

/***/ }),

/***/ "./src/workflow/mxGraph/HoverIcons.js":
/*!********************************************!*\
  !*** ./src/workflow/mxGraph/HoverIcons.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.symbol.js */ \"../../node_modules/core-js/modules/es.symbol.js\");\n__webpack_require__(/*! core-js/modules/es.symbol.description.js */ \"../../node_modules/core-js/modules/es.symbol.description.js\");\n__webpack_require__(/*! core-js/modules/es.symbol.iterator.js */ \"../../node_modules/core-js/modules/es.symbol.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.array.iterator.js */ \"../../node_modules/core-js/modules/es.array.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\n__webpack_require__(/*! core-js/modules/es.string.iterator.js */ \"../../node_modules/core-js/modules/es.string.iterator.js\");\n__webpack_require__(/*! core-js/modules/web.dom-collections.iterator.js */ \"../../node_modules/core-js/modules/web.dom-collections.iterator.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.concat.js */ \"../../node_modules/core-js/modules/es.array.concat.js\");\n__webpack_require__(/*! core-js/modules/es.array.filter.js */ \"../../node_modules/core-js/modules/es.array.filter.js\");\n__webpack_require__(/*! core-js/modules/es.array.reverse.js */ \"../../node_modules/core-js/modules/es.array.reverse.js\");\n__webpack_require__(/*! core-js/modules/es.array.sort.js */ \"../../node_modules/core-js/modules/es.array.sort.js\");\n__webpack_require__(/*! core-js/modules/es.date.to-string.js */ \"../../node_modules/core-js/modules/es.date.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.function.bind.js */ \"../../node_modules/core-js/modules/es.function.bind.js\");\n__webpack_require__(/*! core-js/modules/es.object.keys.js */ \"../../node_modules/core-js/modules/es.object.keys.js\");\n__webpack_require__(/*! core-js/modules/es.object.to-string.js */ \"../../node_modules/core-js/modules/es.object.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.parse-int.js */ \"../../node_modules/core-js/modules/es.parse-int.js\");\n__webpack_require__(/*! core-js/modules/es.regexp.constructor.js */ \"../../node_modules/core-js/modules/es.regexp.constructor.js\");\n__webpack_require__(/*! core-js/modules/es.regexp.exec.js */ \"../../node_modules/core-js/modules/es.regexp.exec.js\");\n__webpack_require__(/*! core-js/modules/es.regexp.to-string.js */ \"../../node_modules/core-js/modules/es.regexp.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.string.replace.js */ \"../../node_modules/core-js/modules/es.string.replace.js\");\n__webpack_require__(/*! core-js/modules/es.string.trim.js */ \"../../node_modules/core-js/modules/es.string.trim.js\");\n__webpack_require__(/*! core-js/modules/web.timers.js */ \"../../node_modules/core-js/modules/web.timers.js\");\nvar _mxPolyline = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxPolyline.js */ \"./src/workflow/mxClient/mxPolyline.js\"));\nvar _mxCellState = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxCellState.js */ \"./src/workflow/mxClient/mxCellState.js\"));\nvar _mxGraph = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxGraph.js */ \"./src/workflow/mxClient/mxGraph.js\"));\nvar _mxStencilRegistry = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxStencilRegistry.js */ \"./src/workflow/mxClient/mxStencilRegistry.js\"));\nvar _mxRubberband = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxRubberband.js */ \"./src/workflow/mxClient/mxRubberband.js\"));\nvar _mxConstraintHandler = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxConstraintHandler.js */ \"./src/workflow/mxClient/mxConstraintHandler.js\"));\nvar _mxShape = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxShape.js */ \"./src/workflow/mxClient/mxShape.js\"));\nvar _mxEventObject = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxEventObject.js */ \"./src/workflow/mxClient/mxEventObject.js\"));\nvar _mxCellRenderer = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxCellRenderer.js */ \"./src/workflow/mxClient/mxCellRenderer.js\"));\nvar _mxPopupMenuHandler = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxPopupMenuHandler.js */ \"./src/workflow/mxClient/mxPopupMenuHandler.js\"));\nvar _mxGraphHandler = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxGraphHandler.js */ \"./src/workflow/mxClient/mxGraphHandler.js\"));\nvar _mxVertexHandler = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxVertexHandler.js */ \"./src/workflow/mxClient/mxVertexHandler.js\"));\nvar _mxResources = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxResources.js */ \"./src/workflow/mxClient/mxResources.js\"));\nvar _mxCellEditor = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxCellEditor.js */ \"./src/workflow/mxClient/mxCellEditor.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nvar _mxUtils = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxUtils.js */ \"./src/workflow/mxClient/mxUtils.js\"));\nvar _mxCell = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxCell.js */ \"./src/workflow/mxClient/mxCell.js\"));\nvar _mxPanningHandler = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxPanningHandler.js */ \"./src/workflow/mxClient/mxPanningHandler.js\"));\nvar _mxConnectionHandler = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxConnectionHandler.js */ \"./src/workflow/mxClient/mxConnectionHandler.js\"));\nvar _mxEdgeHandler = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxEdgeHandler.js */ \"./src/workflow/mxClient/mxEdgeHandler.js\"));\nvar _mxElbowEdgeHandler = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxElbowEdgeHandler.js */ \"./src/workflow/mxClient/mxElbowEdgeHandler.js\"));\nvar _mxGraphModel = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxGraphModel.js */ \"./src/workflow/mxClient/mxGraphModel.js\"));\nvar _mxEllipse = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxEllipse.js */ \"./src/workflow/mxClient/mxEllipse.js\"));\nvar _mxStyleRegistry = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxStyleRegistry.js */ \"./src/workflow/mxClient/mxStyleRegistry.js\"));\nvar _mxClient = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxClient.js */ \"./src/workflow/mxClient/mxClient.js\"));\nvar _mxOutline = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxOutline.js */ \"./src/workflow/mxClient/mxOutline.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxCellHighlight = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxCellHighlight.js */ \"./src/workflow/mxClient/mxCellHighlight.js\"));\nvar _mxImageExport = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxImageExport.js */ \"./src/workflow/mxClient/mxImageExport.js\"));\nvar _mxEvent = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxEvent.js */ \"./src/workflow/mxClient/mxEvent.js\"));\nvar _mxImage = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxImage.js */ \"./src/workflow/mxClient/mxImage.js\"));\nvar _mxRectangle = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxRectangle.js */ \"./src/workflow/mxClient/mxRectangle.js\"));\nvar _mxStencil = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxStencil.js */ \"./src/workflow/mxClient/mxStencil.js\"));\nvar _mxCodec = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxCodec.js */ \"./src/workflow/mxClient/mxCodec.js\"));\nvar _mxGeometry = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxGeometry.js */ \"./src/workflow/mxClient/mxGeometry.js\"));\nvar _mxGuide = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxGuide.js */ \"./src/workflow/mxClient/mxGuide.js\"));\nvar _mxPoint = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxPoint.js */ \"./src/workflow/mxClient/mxPoint.js\"));\nvar _mxStackLayout = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxStackLayout.js */ \"./src/workflow/mxClient/mxStackLayout.js\"));\nvar _Graph = _interopRequireDefault(__webpack_require__(/*! ./Graph */ \"./src/workflow/mxGraph/Graph.js\"));\nvar _mxSvgCanvas2D = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxSvgCanvas2D.js */ \"./src/workflow/mxClient/mxSvgCanvas2D.js\"));\nvar _mxRequestUtils = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxRequestUtils.js */ \"./src/workflow/mxClient/mxRequestUtils.js\"));\nvar _mxValueChange = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxValueChange.js */ \"./src/workflow/mxClient/mxValueChange.js\"));\nvar _mxConnectionConstraint = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxConnectionConstraint.js */ \"./src/workflow/mxClient/mxConnectionConstraint.js\"));\nvar _mxRectangleShape = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxRectangleShape.js */ \"./src/workflow/mxClient/mxRectangleShape.js\"));\nvar _mxImageShape = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxImageShape.js */ \"./src/workflow/mxClient/mxImageShape.js\"));\nvar _getWebRootPath = _interopRequireDefault(__webpack_require__(/*! @/api/getWebRootPath */ \"./src/api/getWebRootPath.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nvar HoverIcons = function HoverIcons(graph) {\n  this.graph = graph;\n  this.init();\n};\n\n/**\r\n * Up arrow.\r\n */\nHoverIcons.prototype.arrowSpacing = 6;\n\n/**\r\n * Delay to switch to another state for overlapping bbox. Default is 500ms.\r\n */\nHoverIcons.prototype.updateDelay = 500;\n\n/**\r\n * Delay to switch between states. Default is 140ms.\r\n */\nHoverIcons.prototype.activationDelay = 140;\n\n/**\r\n * Up arrow.\r\n */\nHoverIcons.prototype.currentState = null;\n\n/**\r\n * Up arrow.\r\n */\nHoverIcons.prototype.activeArrow = null;\n\n/**\r\n * Up arrow.\r\n */\nHoverIcons.prototype.inactiveOpacity = 15;\n\n/**\r\n * Whether to hide arrows that collide with vertices.\r\n * LATER: Add keyboard override, touch support.\r\n */\nHoverIcons.prototype.checkCollisions = true;\n\n/**\r\n * Up arrow.\r\n */\nHoverIcons.prototype.triangleUp = new _mxImage[\"default\"](_mxClient[\"default\"].IS_SVG ? 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABoAAAAOCAYAAAAxDQxDAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6N0ZBN0E3M0U5NjZGMTFFNTg5NTRDNzQwMTgwNDlEQzQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6N0ZBN0E3M0Y5NjZGMTFFNTg5NTRDNzQwMTgwNDlEQzQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo3RkE3QTczQzk2NkYxMUU1ODk1NEM3NDAxODA0OURDNCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo3RkE3QTczRDk2NkYxMUU1ODk1NEM3NDAxODA0OURDNCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pj625P8AAACySURBVHjaYmRY956BROABxF+A+AgpmpjIsGQjEO8CYidaWeQHtYQNiDmBeAspljGRYMlqqCUwALPMg1oWhWCxBNmyjVCHUGQRyJKlOCyBATaoQ/zItSgciFcQsATdshBSLYqC+oSZhMTCBnVYFLEWgRQuItESGGCG6o0iZFECBZagW5aAyyKQxBwKLUG2bD4Qp6FblAyVoIYlyGAmzDIWKGMmA+0AyGw2RjIKVbIAQIABAFJRHSSk2rPoAAAAAElFTkSuQmCC' : IMAGE_PATH + '/triangle-up.png', 26, 14);\n\n/**\r\n * Right arrow.\r\n */\nHoverIcons.prototype.triangleRight = new _mxImage[\"default\"](_mxClient[\"default\"].IS_SVG ? 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAaCAYAAACHD21cAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NThDQzc5RTU5NjZGMTFFNTg5NTRDNzQwMTgwNDlEQzQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NThDQzc5RTY5NjZGMTFFNTg5NTRDNzQwMTgwNDlEQzQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo1OENDNzlFMzk2NkYxMUU1ODk1NEM3NDAxODA0OURDNCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo1OENDNzlFNDk2NkYxMUU1ODk1NEM3NDAxODA0OURDNCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PrHdKTUAAADDSURBVHjanNTBCgFRFIfxMeTZyEKkiBSRxbwREZGiNFZKWSnvY6OUUv6n7ilZaL459XVXv6a5c+cWovQeaSZqFoGJwzpVozzQZq4GeSDCv7AYcJ9Cx0vVpdDxWrUpdLxVLQr/4jjDBpYDblDoeKdqFDpOHRP4jSsU2rzVg8KnqqpbDFFdXck7vlRTXciuOjqT72ioo07k5Nju9dSRnFVHB/J3GBqqPf0fx2pDbwBDK3Ln2MdN1CLraSiFNcn6JJ+PAAMAbnMl1tyDPD8AAAAASUVORK5CYII=' : IMAGE_PATH + '/triangle-right.png', 14, 26);\n\n/**\r\n * Down arrow.\r\n */\nHoverIcons.prototype.triangleDown = new _mxImage[\"default\"](_mxClient[\"default\"].IS_SVG ? 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABoAAAAOCAYAAAAxDQxDAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NThDQzc5RTk5NjZGMTFFNTg5NTRDNzQwMTgwNDlEQzQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NThDQzc5RUE5NjZGMTFFNTg5NTRDNzQwMTgwNDlEQzQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo1OENDNzlFNzk2NkYxMUU1ODk1NEM3NDAxODA0OURDNCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo1OENDNzlFODk2NkYxMUU1ODk1NEM3NDAxODA0OURDNCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pv9xyy0AAADESURBVHjaYmRY956BHoAJiHOA+D+NcRrIoilAnEVDz6QD8SwWKGc6EP8F4plUtiQRiBfAgg4GZkEl/lLBgr/IlqBbxACViKPQMgxLQIAFi8JlUHoREDOTYUkckhkMuHyEbFkEEP8i0ZJobJbgswgE1gBxKJGW/YI6bCW+fIQPbCLCsl9Qn6whlGEZiLDMH4i/47AklJAlxFoEAjuA2AfNMpglm4gtgogF+5As+wX15SZiNbOQmHxBlrkBMQ/Ul0QDgAADAC8qRII7g4RyAAAAAElFTkSuQmCC' : IMAGE_PATH + '/triangle-down.png', 26, 14);\n\n/**\r\n * Left arrow.\r\n */\nHoverIcons.prototype.triangleLeft = new _mxImage[\"default\"](_mxClient[\"default\"].IS_SVG ? 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAaCAYAAACHD21cAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6N0ZBN0E3M0E5NjZGMTFFNTg5NTRDNzQwMTgwNDlEQzQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6N0ZBN0E3M0I5NjZGMTFFNTg5NTRDNzQwMTgwNDlEQzQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo1OENDNzlFQjk2NkYxMUU1ODk1NEM3NDAxODA0OURDNCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo1OENDNzlFQzk2NkYxMUU1ODk1NEM3NDAxODA0OURDNCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pi1fu2cAAADXSURBVHjalNTRB8JQFMfxVROxPyl6iuipRJFS2kv/TU89lY0piyw9pP6r3iP6He7Ndd3de87haxMfd+1ua0TVOxLOCuVNIdqiHZ1I4AbtUUsC6fIO6jzhwoWB/hOCU5Tpy+PCCTq5kA+OfKgODlGJ2r7/YMMBqkLIhn0uMmEP3VGH+zQQ7KKnBGmY+O6eD77QGH2kkOYhxeZdJTzjYnsfb2jOwbHjt6s6ltJHTmNa+SuFNBe0rMOh9/GM1i7M+QIUKLVxzNy2XB0zyYomTqUr6jnqLfoJMADoxSMHt6pxsAAAAABJRU5ErkJggg==' : IMAGE_PATH + '/triangle-left.png', 14, 26);\n\n/**\r\n * Round target.\r\n */\nHoverIcons.prototype.roundDrop = new _mxImage[\"default\"](_mxClient[\"default\"].IS_SVG ? 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABoAAAAaCAYAAACpSkzOAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6RTgxRjYzRTU1MDRFMTFFNEExQ0VFNDQwNDhGNzg2RDkiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6RTgxRjYzRTY1MDRFMTFFNEExQ0VFNDQwNDhGNzg2RDkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpFODFGNjNFMzUwNEUxMUU0QTFDRUU0NDA0OEY3ODZEOSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpFODFGNjNFNDUwNEUxMUU0QTFDRUU0NDA0OEY3ODZEOSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PuJ657wAAAE0SURBVHjaYvz//z8DPQATA50AC4zBuP4DLjXaQOwMxJZArAfE8lDxh0B8CYiPA/FeIL6KTfP/QAFUi7AABSBOAOJoIFbBIq8FxRFAfAeIlwLxAiB+gNdHaMABiIuB2IfIkAE5pB6IjYG4F4gPEBNHIEtaSLAEGfhA9ToQskgB6hNrCuLdGmqGAj6LEsj0CTafJeCySBsa8dQC0VAzMSxyxpG6yAUqUDMxLLKkQT61xGaRHg0s0sNmkTwNLJKne1mHbNFDGpj/EJtFl2hg0SVsFh2ngUXHsVm0F1oKUwvcgZqJYdFVaFFPLbAUuY5CT3Wg+mQLFSzZAjULZ6H6AFqfHKXAkqNQMx4Qqo9AlVYNmT7bAtV7gNga9gDURWfxVOXoEY+3KmeENbdo3ThhHHbtOoAAAwDmEETshQ0fBAAAAABJRU5ErkJggg==' : IMAGE_PATH + '/round-drop.png', 26, 26);\n\n/**\r\n * Refresh target.\r\n */\nHoverIcons.prototype.refreshTarget = new _mxImage[\"default\"](_mxClient[\"default\"].IS_SVG ? 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACYAAAAmCAYAAACoPemuAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NDQxNERDRTU1QjY1MTFFNDkzNTRFQTVEMTdGMTdBQjciIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NDQxNERDRTY1QjY1MTFFNDkzNTRFQTVEMTdGMTdBQjciPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo0NDE0RENFMzVCNjUxMUU0OTM1NEVBNUQxN0YxN0FCNyIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo0NDE0RENFNDVCNjUxMUU0OTM1NEVBNUQxN0YxN0FCNyIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PsvuX50AAANaSURBVHja7FjRZ1tRGD9ZJ1NCyIQSwrivI4Q8hCpjlFDyFEoYfSp9Ko1QWnmo0If+BSXkIfo0QirTMUpeGo2EPfWllFYjZMLKLDJn53d3biU337m5J223bPbxk5t7v+/c3/2+73znO8fDOWezKM/YjMpz68Lj8ejY+QTeCCwLxOS9qPxtyN+6wAeBTwJ31CCO0cJDjXBGBN4LfIepSwykTUT1bgpuib0SONIgo8KRHOtRiCFcvUcgZeGrHPNBxLIyFPyRgTGz0xLbegJCdmzpElue5KlAIMDX19d5uVzm5+fnfDAYmMA17uEZdOx2Yvb/sHlu2S0xwymn5ufneTab5b1ej08S6EAXNrDd2dnhiUTim21MvMtwQ6yiIrWwsMDPzs64rsBmf3/fvM7n89TYlUnEllSkQqEQv7q64g+Vk5MTVXosORErU0Zer5f0FEIlw2N6MxwO82QyaXql2+2SxDqdjopYWUUsqEp45IldqtWq6UWVh/1+P7+8vCTJ4QMUJSRIEXuneoH96w8PDyeWAnhSJfCqwm6NIlaklFdXV0cGhRcQ2mlJQXK5nMq2YPEZbnteU1U2lUqN/D84OGD9fl+5fgnSrFarsUwmw0qlEru4uBjTicViTk3Cr27HSnxR+Doyz0ZE1CAWiUTusbu7y9rttlZv5fP5WDQavYfIMba4uEipfhF8XtqJoZXx/uH+sC/4vPg7OljZZQbsCmLtYzc3N6zRaJhotVrmfx0xDINtbm6athYUeXpHdbBNaqZUKpWxWXV7e2vex+xaWVnhc3NzjrPUXgexyCt0m67LBV7uJMITjqRE4o8tZeg8FPpFitgapYxiOC0poFgsji1jKNo6BZZckrAGUtJsNk1vqAihCBcKhTE7hNWhqw2qFnGy5UFOUYJVIJ1OjzSE+BCEilon0URavRmBqnbbQ00AXbm+vnZc9O1tj72OnQoc2+cwygRkb2+P1et17ZoEm3g87lRmjgWZ00kbXkNuse6/Bu2wlegIxfb2tuvWGroO4bO2c4bbzUh60mxDXm1sbJhhxkQYnhS4h2fUZoRAWnf7lv8N27f8P7Xhnekjgpk+VKGOoQbsiY+hhhtF3YO7twIJ+ULvUGv+GQ2fQEvWxI/THNx5/p/BaspPAQYAqStgiSQwCDoAAAAASUVORK5CYII=' : IMAGE_PATH + '/refresh.png', 38, 38);\n\n/**\r\n * \r\n */\nHoverIcons.prototype.init = function () {\n  this.arrowUp = this.createArrow(this.triangleUp, null);\n  this.arrowRight = this.createArrow(this.triangleRight, null);\n  this.arrowDown = this.createArrow(this.triangleDown, null);\n  this.arrowLeft = this.createArrow(this.triangleLeft, null);\n  this.elts = [this.arrowUp, this.arrowRight, this.arrowDown, this.arrowLeft];\n  this.repaintHandler = _mxGraphUtils[\"default\"].bind(this, function () {\n    this.repaint();\n  });\n  this.graph.selectionModel.addListener(_mxEvent[\"default\"].CHANGE, this.repaintHandler);\n  this.graph.model.addListener(_mxEvent[\"default\"].CHANGE, this.repaintHandler);\n  this.graph.view.addListener(_mxEvent[\"default\"].SCALE_AND_TRANSLATE, this.repaintHandler);\n  this.graph.view.addListener(_mxEvent[\"default\"].TRANSLATE, this.repaintHandler);\n  this.graph.view.addListener(_mxEvent[\"default\"].SCALE, this.repaintHandler);\n  this.graph.view.addListener(_mxEvent[\"default\"].DOWN, this.repaintHandler);\n  this.graph.view.addListener(_mxEvent[\"default\"].UP, this.repaintHandler);\n  this.graph.addListener(_mxEvent[\"default\"].ROOT, this.repaintHandler);\n\n  // Resets the mouse point on escape\n  this.graph.addListener(_mxEvent[\"default\"].ESCAPE, _mxGraphUtils[\"default\"].bind(this, function () {\n    this.mouseDownPoint = null;\n  }));\n\n  // Removes hover icons if mouse leaves the container\n  _mxEvent[\"default\"].addListener(this.graph.container, 'mouseleave', _mxGraphUtils[\"default\"].bind(this, function (evt) {\n    // Workaround for IE11 firing mouseleave for touch in diagram\n    if (evt.relatedTarget != null && _mxEvent[\"default\"].getSource(evt) == this.graph.container) {\n      this.setDisplay('none');\n    }\n  }));\n\n  // Resets current state after update of selection state for touch events\n  var graphClick = this.graph.click;\n  this.graph.click = _mxGraphUtils[\"default\"].bind(this, function (me) {\n    graphClick.apply(this.graph, arguments);\n    if (this.currentState != null && !this.graph.isCellSelected(this.currentState.cell) && _mxEvent[\"default\"].isTouchEvent(me.getEvent()) && !this.graph.model.isVertex(me.getCell())) {\n      this.reset();\n    }\n  });\n\n  // Checks if connection handler was active in mouse move\n  // as workaround for possible double connection inserted\n  var connectionHandlerActive = false;\n\n  // Implements a listener for hover and click handling\n  this.graph.addMouseListener({\n    mouseDown: _mxGraphUtils[\"default\"].bind(this, function (sender, me) {\n      connectionHandlerActive = false;\n      var evt = me.getEvent();\n      if (this.isResetEvent(evt)) {\n        this.reset();\n      } else if (!this.isActive()) {\n        var state = this.getState(me.getState());\n        if (state != null || !_mxEvent[\"default\"].isTouchEvent(evt)) {\n          this.update(state);\n        }\n      }\n      this.setDisplay('none');\n    }),\n    mouseMove: _mxGraphUtils[\"default\"].bind(this, function (sender, me) {\n      var evt = me.getEvent();\n      if (this.isResetEvent(evt)) {\n        this.reset();\n      } else if (!this.graph.isMouseDown && !_mxEvent[\"default\"].isTouchEvent(evt)) {\n        this.update(this.getState(me.getState()), me.getGraphX(), me.getGraphY());\n      }\n      if (this.graph.connectionHandler != null && this.graph.connectionHandler.shape != null) {\n        connectionHandlerActive = true;\n      }\n    }),\n    mouseUp: _mxGraphUtils[\"default\"].bind(this, function (sender, me) {\n      var evt = me.getEvent();\n      if (this.isResetEvent(evt)) {\n        this.reset();\n      } else if (this.isActive() && this.mouseDownPoint != null && Math.abs(me.getGraphX() - this.mouseDownPoint.x) < this.graph.tolerance && Math.abs(me.getGraphY() - this.mouseDownPoint.y) < this.graph.tolerance) {\n        // Executes click event on highlighted arrow\n        if (!connectionHandlerActive) {\n          this.click(this.currentState, this.getDirection(), me);\n        }\n      } else if (this.isActive()) {\n        // Selects target vertex after drag and clone if not only new edge was inserted\n        if (this.graph.getSelectionCount() != 1 || !this.graph.model.isEdge(this.graph.getSelectionCell())) {\n          this.update(this.getState(this.graph.view.getState(this.graph.getCellAt(me.getGraphX(), me.getGraphY()))));\n        } else {\n          this.reset();\n        }\n      } else if (_mxEvent[\"default\"].isTouchEvent(evt) || this.bbox != null && _mxUtils[\"default\"].contains(this.bbox, me.getGraphX(), me.getGraphY())) {\n        // Shows existing hover icons if inside bounding box\n        this.setDisplay('');\n        this.repaint();\n      } else if (!_mxEvent[\"default\"].isTouchEvent(evt)) {\n        this.reset();\n      }\n      connectionHandlerActive = false;\n      this.resetActiveArrow();\n    })\n  });\n};\n\n/**\r\n * \r\n */\nHoverIcons.prototype.isResetEvent = function (evt, allowShift) {\n  return _mxEvent[\"default\"].isAltDown(evt) || this.activeArrow == null && _mxEvent[\"default\"].isShiftDown(evt) || _mxEvent[\"default\"].isMetaDown(evt) || _mxEvent[\"default\"].isPopupTrigger(evt) && !_mxEvent[\"default\"].isControlDown(evt);\n};\n\n/**\r\n * \r\n */\nHoverIcons.prototype.createArrow = function (img, tooltip) {\n  var arrow = null;\n  if (_mxClient[\"default\"].IS_IE && !_mxClient[\"default\"].IS_SVG) {\n    // Workaround for PNG images in IE6\n    if (_mxClient[\"default\"].IS_IE6 && document.compatMode != 'CSS1Compat') {\n      arrow = document.createElement(_mxClient[\"default\"].VML_PREFIX + ':image');\n      arrow.setAttribute('src', img.src);\n      arrow.style.borderStyle = 'none';\n    } else {\n      arrow = document.createElement('div');\n      arrow.style.backgroundImage = 'url(' + img.src + ')';\n      arrow.style.backgroundPosition = 'center';\n      arrow.style.backgroundRepeat = 'no-repeat';\n    }\n    arrow.style.width = img.width + 4 + 'px';\n    arrow.style.height = img.height + 4 + 'px';\n    arrow.style.display = _mxClient[\"default\"].IS_QUIRKS ? 'inline' : 'inline-block';\n  } else {\n    arrow = _mxUtils[\"default\"].createImage(img.src);\n    arrow.style.width = img.width + 'px';\n    arrow.style.height = img.height + 'px';\n  }\n  if (tooltip != null) {\n    arrow.setAttribute('title', tooltip);\n  }\n  arrow.style.position = 'absolute';\n  arrow.style.cursor = 'crosshair';\n  _mxEvent[\"default\"].addGestureListeners(arrow, _mxGraphUtils[\"default\"].bind(this, function (evt) {\n    if (this.currentState != null && !this.isResetEvent(evt)) {\n      this.mouseDownPoint = _mxUtils[\"default\"].convertPoint(this.graph.container, _mxEvent[\"default\"].getClientX(evt), _mxEvent[\"default\"].getClientY(evt));\n      this.drag(evt, this.mouseDownPoint.x, this.mouseDownPoint.y);\n      this.activeArrow = arrow;\n      this.setDisplay('none');\n      _mxEvent[\"default\"].consume(evt);\n    }\n  }));\n\n  // Captures mouse events as events on graph\n  _mxEvent[\"default\"].redirectMouseEvents(arrow, this.graph, this.currentState);\n  _mxEvent[\"default\"].addListener(arrow, 'mouseenter', _mxGraphUtils[\"default\"].bind(this, function (evt) {\n    // Workaround for Firefox firing mouseenter on touchend\n    if (_mxEvent[\"default\"].isMouseEvent(evt)) {\n      if (this.activeArrow != null && this.activeArrow != arrow) {\n        _mxGraphUtils[\"default\"].setOpacity(this.activeArrow, this.inactiveOpacity);\n      }\n      this.graph.connectionHandler.constraintHandler.reset();\n      _mxGraphUtils[\"default\"].setOpacity(arrow, 100);\n      this.activeArrow = arrow;\n    }\n  }));\n  _mxEvent[\"default\"].addListener(arrow, 'mouseleave', _mxGraphUtils[\"default\"].bind(this, function (evt) {\n    // Workaround for IE11 firing this event on touch\n    if (!this.graph.isMouseDown) {\n      this.resetActiveArrow();\n    }\n  }));\n  return arrow;\n};\n\n/**\r\n * \r\n */\nHoverIcons.prototype.resetActiveArrow = function () {\n  if (this.activeArrow != null) {\n    _mxGraphUtils[\"default\"].setOpacity(this.activeArrow, this.inactiveOpacity);\n    this.activeArrow = null;\n  }\n};\n\n/**\r\n * \r\n */\nHoverIcons.prototype.getDirection = function () {\n  var dir = _mxConstants[\"default\"].DIRECTION_EAST;\n  if (this.activeArrow == this.arrowUp) {\n    dir = _mxConstants[\"default\"].DIRECTION_NORTH;\n  } else if (this.activeArrow == this.arrowDown) {\n    dir = _mxConstants[\"default\"].DIRECTION_SOUTH;\n  } else if (this.activeArrow == this.arrowLeft) {\n    dir = _mxConstants[\"default\"].DIRECTION_WEST;\n  }\n  return dir;\n};\n\n/**\r\n * \r\n */\nHoverIcons.prototype.visitNodes = function (visitor) {\n  for (var i = 0; i < this.elts.length; i++) {\n    if (this.elts[i] != null) {\n      visitor(this.elts[i]);\n    }\n  }\n};\n\n/**\r\n * \r\n */\nHoverIcons.prototype.removeNodes = function () {\n  this.visitNodes(function (elt) {\n    if (elt.parentNode != null) {\n      elt.parentNode.removeChild(elt);\n    }\n  });\n};\n\n/**\r\n *\r\n */\nHoverIcons.prototype.setDisplay = function (display) {\n  this.visitNodes(function (elt) {\n    elt.style.display = display;\n  });\n};\n\n/**\r\n *\r\n */\nHoverIcons.prototype.isActive = function () {\n  return this.activeArrow != null && this.currentState != null;\n};\n\n/**\r\n *\r\n */\nHoverIcons.prototype.drag = function (evt, x, y) {\n  this.graph.popupMenuHandler.hideMenu();\n  this.graph.stopEditing(false);\n\n  // Checks if state was removed in call to stopEditing above\n  if (this.currentState != null) {\n    this.graph.connectionHandler.start(this.currentState, x, y);\n    this.graph.isMouseTrigger = _mxEvent[\"default\"].isMouseEvent(evt);\n    this.graph.isMouseDown = true;\n\n    // Hides handles for selection cell\n    var handler = this.graph.selectionCellsHandler.getHandler(this.currentState.cell);\n    if (handler != null) {\n      handler.setHandlesVisible(false);\n    }\n\n    // Uses elbow edges with vertical or horizontal direction\n    //\t\tvar direction = this.getDirection();\n    //\t\tvar elbowValue = (direction == mxConstants.DIRECTION_NORTH || direction == mxConstants.DIRECTION_SOUTH) ? 'vertical' : 'horizontal';\n    //\t\t\n    //\t\tvar es = this.graph.connectionHandler.edgeState;\n    //\t\tes.style['edgeStyle'] = 'elbowEdgeStyle';\n    //\t\tes.style['elbow'] = elbowValue;\n    //\t\tes.cell.style = mxUtils.setStyle(es.cell.style, 'edgeStyle', es.style['edgeStyle']);\n    //\t\tes.cell.style = mxUtils.setStyle(es.cell.style, 'elbow', es.style['elbow']);\n  }\n};\n\n/**\r\n *\r\n */\nHoverIcons.prototype.click = function (state, dir, me) {\n  var evt = me.getEvent();\n  var x = me.getGraphX();\n  var y = me.getGraphY();\n  var tmp = this.graph.view.getState(this.graph.getCellAt(x, y));\n  if (tmp != null && this.graph.model.isEdge(tmp.cell) && !_mxEvent[\"default\"].isControlDown(evt) && (tmp.getVisibleTerminalState(true) == state || tmp.getVisibleTerminalState(false) == state)) {\n    this.graph.setSelectionCell(tmp.cell);\n    this.reset();\n  } else if (state != null) {\n    var cells = this.graph.connectVertex(state.cell, dir, this.graph.defaultEdgeLength, evt);\n    this.graph.selectCellsForConnectVertex(cells, evt, this);\n\n    // Selects only target vertex if one exists\n    if (cells.length == 2 && this.graph.model.isVertex(cells[1])) {\n      this.graph.setSelectionCell(cells[1]);\n\n      // Adds hover icons to new target vertex for touch devices\n      if (_mxEvent[\"default\"].isTouchEvent(evt)) {\n        this.update(this.getState(this.graph.view.getState(cells[1])));\n      } else {\n        // Hides hover icons after click with mouse\n        this.reset();\n      }\n      this.graph.scrollCellToVisible(cells[1]);\n    } else {\n      this.graph.setSelectionCells(cells);\n    }\n  }\n  me.consume();\n};\n\n/**\r\n * \r\n */\nHoverIcons.prototype.reset = function (clearTimeout) {\n  clearTimeout = clearTimeout == null ? true : clearTimeout;\n  if (clearTimeout && this.updateThread != null) {\n    window.clearTimeout(this.updateThread);\n  }\n  this.mouseDownPoint = null;\n  this.currentState = null;\n  this.activeArrow = null;\n  this.removeNodes();\n  this.bbox = null;\n};\n\n/**\r\n * \r\n */\nHoverIcons.prototype.repaint = function () {\n  this.bbox = null;\n  if (this.currentState != null) {\n    // Checks if cell was deleted\n    this.currentState = this.getState(this.currentState);\n\n    // Cell was deleted\t\n    if (this.currentState != null && this.graph.model.isVertex(this.currentState.cell) && this.graph.isCellConnectable(this.currentState.cell)) {\n      var bds = _mxRectangle[\"default\"].fromRectangle(this.currentState);\n\n      // Uses outer bounding box to take rotation into account\n      if (this.currentState.shape != null && this.currentState.shape.boundingBox != null) {\n        bds = _mxRectangle[\"default\"].fromRectangle(this.currentState.shape.boundingBox);\n      }\n      bds.grow(this.graph.tolerance);\n      bds.grow(this.arrowSpacing);\n      var handler = this.graph.selectionCellsHandler.getHandler(this.currentState.cell);\n      if (handler != null) {\n        bds.x -= handler.horizontalOffset / 2;\n        bds.y -= handler.verticalOffset / 2;\n        bds.width += handler.horizontalOffset;\n        bds.height += handler.verticalOffset;\n\n        // Adds bounding box of rotation handle to avoid overlap\n        if (handler.rotationShape != null && handler.rotationShape.node != null && handler.rotationShape.node.style.visibility != 'hidden' && handler.rotationShape.node.style.display != 'none' && handler.rotationShape.boundingBox != null) {\n          bds.add(handler.rotationShape.boundingBox);\n        }\n      }\n      this.arrowUp.style.left = Math.round(this.currentState.getCenterX() - this.triangleUp.width / 2) + 'px';\n      this.arrowUp.style.top = Math.round(bds.y - this.triangleUp.height) + 'px';\n      _mxGraphUtils[\"default\"].setOpacity(this.arrowUp, this.inactiveOpacity);\n      this.arrowRight.style.left = Math.round(bds.x + bds.width) + 'px';\n      this.arrowRight.style.top = Math.round(this.currentState.getCenterY() - this.triangleRight.height / 2) + 'px';\n      _mxGraphUtils[\"default\"].setOpacity(this.arrowRight, this.inactiveOpacity);\n      this.arrowDown.style.left = this.arrowUp.style.left;\n      this.arrowDown.style.top = Math.round(bds.y + bds.height) + 'px';\n      _mxGraphUtils[\"default\"].setOpacity(this.arrowDown, this.inactiveOpacity);\n      this.arrowLeft.style.left = Math.round(bds.x - this.triangleLeft.width) + 'px';\n      this.arrowLeft.style.top = this.arrowRight.style.top;\n      _mxGraphUtils[\"default\"].setOpacity(this.arrowLeft, this.inactiveOpacity);\n      if (this.checkCollisions) {\n        var right = this.graph.getCellAt(bds.x + bds.width + this.triangleRight.width / 2, this.currentState.getCenterY());\n        var left = this.graph.getCellAt(bds.x - this.triangleLeft.width / 2, this.currentState.getCenterY());\n        var top = this.graph.getCellAt(this.currentState.getCenterX(), bds.y - this.triangleUp.height / 2);\n        var bottom = this.graph.getCellAt(this.currentState.getCenterX(), bds.y + bds.height + this.triangleDown.height / 2);\n\n        // Shows hover icons large cell is behind all directions of current cell\n        if (right != null && right == left && left == top && top == bottom) {\n          right = null;\n          left = null;\n          top = null;\n          bottom = null;\n        }\n\n        // Checks right arrow\n        if (right != null && !this.graph.model.isAncestor(right, this.currentState.cell)) {\n          this.arrowRight.style.visibility = 'hidden';\n        } else {\n          this.arrowRight.style.visibility = 'visible';\n        }\n\n        // Checks left arrow\n        if (left != null && !this.graph.model.isAncestor(left, this.currentState.cell)) {\n          this.arrowLeft.style.visibility = 'hidden';\n        } else {\n          this.arrowLeft.style.visibility = 'visible';\n        }\n\n        // Checks top arrow\n        if (top != null && !this.graph.model.isAncestor(top, this.currentState.cell)) {\n          this.arrowUp.style.visibility = 'hidden';\n        } else {\n          this.arrowUp.style.visibility = 'visible';\n        }\n\n        // Checks bottom arrow\n        if (bottom != null && !this.graph.model.isAncestor(bottom, this.currentState.cell)) {\n          this.arrowDown.style.visibility = 'hidden';\n        } else {\n          this.arrowDown.style.visibility = 'visible';\n        }\n      } else {\n        this.arrowLeft.style.visibility = 'visible';\n        this.arrowRight.style.visibility = 'visible';\n        this.arrowUp.style.visibility = 'visible';\n        this.arrowDown.style.visibility = 'visible';\n      }\n    } else {\n      this.reset();\n    }\n\n    // Updates bounding box\n    if (this.currentState != null) {\n      this.bbox = this.computeBoundingBox();\n\n      // Adds tolerance for hover\n      if (this.bbox != null) {\n        this.bbox.grow(10);\n      }\n    }\n  }\n};\n\n/**\r\n * \r\n */\nHoverIcons.prototype.computeBoundingBox = function () {\n  var bbox = !this.graph.model.isEdge(this.currentState.cell) ? _mxRectangle[\"default\"].fromRectangle(this.currentState) : null;\n  this.visitNodes(function (elt) {\n    if (elt.parentNode != null) {\n      var tmp = new _mxRectangle[\"default\"](elt.offsetLeft, elt.offsetTop, elt.offsetWidth, elt.offsetHeight);\n      if (bbox == null) {\n        bbox = tmp;\n      } else {\n        bbox.add(tmp);\n      }\n    }\n  });\n  return bbox;\n};\n\n/**\r\n * \r\n */\nHoverIcons.prototype.getState = function (state) {\n  if (state != null) {\n    var cell = state.cell;\n\n    // Uses connectable parent vertex if child is not connectable\n    if (this.graph.getModel().isVertex(cell) && !this.graph.isCellConnectable(cell)) {\n      var parent = this.graph.getModel().getParent(cell);\n      if (this.graph.getModel().isVertex(parent) && this.graph.isCellConnectable(parent)) {\n        cell = parent;\n      }\n    }\n\n    // Ignores locked cells and edges\n    if (this.graph.isCellLocked(cell) || this.graph.model.isEdge(cell)) {\n      cell = null;\n    }\n    state = this.graph.view.getState(cell);\n  }\n  return state;\n};\n\n/**\r\n * \r\n */\nHoverIcons.prototype.update = function (state, x, y) {\n  if (!this.graph.connectionArrowsEnabled) {\n    this.reset();\n  } else {\n    var timeOnTarget = null;\n\n    // Time on target\n    if (this.prev != state || this.isActive()) {\n      this.startTime = new Date().getTime();\n      this.prev = state;\n      timeOnTarget = 0;\n      if (this.updateThread != null) {\n        window.clearTimeout(this.updateThread);\n      }\n      if (state != null) {\n        // Starts timer to update current state with no mouse events\n        this.updateThread = window.setTimeout(_mxGraphUtils[\"default\"].bind(this, function () {\n          if (!this.isActive() && !this.graph.isMouseDown && !this.graph.panningHandler.isActive()) {\n            this.prev = state;\n            this.update(state, x, y);\n          }\n        }), this.updateDelay + 10);\n      }\n    } else if (this.startTime != null) {\n      timeOnTarget = new Date().getTime() - this.startTime;\n    }\n    this.setDisplay('');\n    if (this.currentState != null && this.currentState != state && timeOnTarget < this.activationDelay && this.bbox != null && !_mxUtils[\"default\"].contains(this.bbox, x, y)) {\n      this.reset(false);\n    } else if (this.currentState != null || timeOnTarget > this.activationDelay) {\n      if (this.currentState != state && (timeOnTarget > this.updateDelay && state != null || this.bbox == null || x == null || y == null || !_mxUtils[\"default\"].contains(this.bbox, x, y))) {\n        //TODO: 没有constraints时不显示周围的箭头，此处是否合理？\n        if (state != null && this.graph.isEnabled() && state.shape && state.shape.stencil && state.shape.stencil.constraints) {\n          this.removeNodes();\n          this.setCurrentState(state);\n          this.repaint();\n\n          // Resets connection points on other focused cells\n          if (this.graph.connectionHandler.constraintHandler.currentFocus != state) {\n            this.graph.connectionHandler.constraintHandler.reset();\n          }\n        } else {\n          this.reset();\n        }\n      }\n    }\n  }\n};\n\n/**\r\n * \r\n */\nHoverIcons.prototype.setCurrentState = function (state) {\n  if (state.style['portConstraint'] != 'eastwest') {\n    this.graph.container.appendChild(this.arrowUp);\n    this.graph.container.appendChild(this.arrowDown);\n  }\n  this.graph.container.appendChild(this.arrowRight);\n  this.graph.container.appendChild(this.arrowLeft);\n  this.currentState = state;\n};\n\n/**\r\n * Adds support for placeholders in text elements of shapes.\r\n */\n(function () {\n  var mxStencilEvaluateTextAttribute = _mxStencil[\"default\"].prototype.evaluateTextAttribute;\n  _mxStencil[\"default\"].prototype.evaluateTextAttribute = function (node, attribute, shape) {\n    var result = mxStencilEvaluateTextAttribute.apply(this, arguments);\n    var placeholders = node.getAttribute('placeholders');\n    if (placeholders == '1' && shape.state != null) {\n      result = shape.state.view.graph.replacePlaceholders(shape.state.cell, result);\n    }\n    return result;\n  };\n\n  /**\r\n   * Adds custom stencils defined via shape=stencil(value) style. The value is a base64 encoded, compressed and\r\n   * URL encoded XML definition of the shape according to the stencil definition language of mxGraph.\r\n   * \r\n   * Needs to be in this file to make sure its part of the embed client code. Also the check for ZLib is\r\n   * different than for the Editor code.\r\n   */\n  var mxCellRendererCreateShape = _mxCellRenderer[\"default\"].prototype.createShape;\n  _mxCellRenderer[\"default\"].prototype.createShape = function (state) {\n    if (state.style != null && typeof pako !== 'undefined') {\n      var shape = _mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_SHAPE, null);\n\n      // Extracts and decodes stencil XML if shape has the form shape=stencil(value)\n      if (shape != null && shape.substring(0, 8) == 'stencil(') {\n        try {\n          var stencil = shape.substring(8, shape.length - 1);\n          var doc = _mxUtils[\"default\"].parseXml(state.view.graph.decompress(stencil));\n          return new _mxShape[\"default\"](new _mxStencil[\"default\"](doc.documentElement));\n        } catch (e) {\n          if (window.console != null) {\n            console.log('Error in shape: ' + e);\n          }\n        }\n      }\n    }\n    return mxCellRendererCreateShape.apply(this, arguments);\n  };\n})();\n\n/**\r\n * Overrides stencil registry for dynamic loading of stencils.\r\n */\n/**\r\n * Maps from library names to an array of Javascript filenames,\r\n * which are synchronously loaded. Currently only stencil files\r\n * (.xml) and JS files (.js) are supported.\r\n * IMPORTANT: For embedded diagrams to work entries must also\r\n * be added in EmbedServlet.java.\r\n */\n_mxStencilRegistry[\"default\"].libraries = {};\n\n/**\r\n * Global switch to disable dynamic loading.\r\n */\n_mxStencilRegistry[\"default\"].dynamicLoading = true;\n\n/**\r\n * Stores all package names that have been dynamically loaded.\r\n * Each package is only loaded once.\r\n */\n_mxStencilRegistry[\"default\"].packages = [];\n\n// Extends the default stencil registry to add dynamic loading\n_mxStencilRegistry[\"default\"].getStencil = function (name) {\n  var result = _mxStencilRegistry[\"default\"].stencils[name];\n  if (result == null && _mxCellRenderer[\"default\"].prototype.defaultShapes[name] == null && _mxStencilRegistry[\"default\"].dynamicLoading) {\n    var basename = _mxStencilRegistry[\"default\"].getBasenameForStencil(name);\n\n    // Loads stencil files and tries again\n    if (basename != null) {\n      var libs = _mxStencilRegistry[\"default\"].libraries[basename];\n      if (libs != null) {\n        if (_mxStencilRegistry[\"default\"].packages[basename] == null) {\n          _mxStencilRegistry[\"default\"].packages[basename] = 1;\n          for (var i = 0; i < libs.length; i++) {\n            var fname = libs[i];\n            if (fname.toLowerCase().substring(fname.length - 4, fname.length) == '.xml') {\n              _mxStencilRegistry[\"default\"].loadStencilSet(fname, null);\n            } else if (fname.toLowerCase().substring(fname.length - 3, fname.length) == '.js') {\n              try {\n                var req = _mxRequestUtils[\"default\"].load(fname);\n                if (req != null && req.getStatus() == 200) {\n                  eval.call(window, req.getText());\n                }\n              } catch (e) {\n                if (window.console != null) {\n                  console.log('error in getStencil:', fname, e);\n                }\n              }\n            } else {\n              // FIXME: This does not yet work as the loading is triggered after\n              // the shape was used in the graph, at which point the keys have\n              // typically been translated in the calling method.\n              //mxResources.add(fname);\n            }\n          }\n        }\n      } else {\n        // Replaces '_-_' with '_'\n        basename = basename.replace('_-_', '_');\n        _mxStencilRegistry[\"default\"].loadStencilSet(STENCIL_PATH + '/' + basename + '.xml', null);\n      }\n      result = _mxStencilRegistry[\"default\"].stencils[name];\n    }\n  }\n  return result;\n};\n\n// Returns the basename for the given stencil or null if no file must be\n// loaded to render the given stencil.\n_mxStencilRegistry[\"default\"].getBasenameForStencil = function (name) {\n  var tmp = null;\n  if (name != null) {\n    var parts = name.split('.');\n    if (parts.length > 0 && parts[0] == 'ierp') {\n      tmp = parts[1];\n      for (var i = 2; i < parts.length - 1; i++) {\n        tmp += '/' + parts[i];\n      }\n    }\n  }\n  return tmp;\n};\n\n// Loads the given stencil set\n_mxStencilRegistry[\"default\"].loadStencilSet = function (stencilFile, postStencilLoad, force, async) {\n  force = force != null ? force : false;\n\n  // Uses additional cache for detecting previous load attempts\n  var xmlDoc = _mxStencilRegistry[\"default\"].packages[stencilFile];\n  if (force || xmlDoc == null) {\n    var install = false;\n    if (xmlDoc == null) {\n      try {\n        //请求图形文件时增加版本号\n        var filename = window.resourceVersion ? \"\".concat(stencilFile, \"?v=\").concat(window.resourceVersion) : stencilFile;\n        filename = (0, _getWebRootPath[\"default\"])(filename);\n        if (async) {\n          var req = _mxRequestUtils[\"default\"].get(filename, _mxGraphUtils[\"default\"].bind(this, function (req) {\n            if (req.getStatus() == 200) {\n              xmlDoc = req.getXml();\n              _mxStencilRegistry[\"default\"].packages[stencilFile] = xmlDoc;\n              install = true;\n              if (xmlDoc != null && xmlDoc.documentElement != null) {\n                _mxStencilRegistry[\"default\"].parseStencilSet(xmlDoc.documentElement, postStencilLoad, install);\n              }\n            }\n          }));\n          return;\n        } else {\n          var req = _mxRequestUtils[\"default\"].load(filename);\n          xmlDoc = req.getXml();\n          _mxStencilRegistry[\"default\"].packages[stencilFile] = xmlDoc;\n          install = true;\n        }\n      } catch (e) {\n        if (window.console != null) {\n          console.log('error in loadStencilSet:', stencilFile, e);\n        }\n      }\n    }\n    if (xmlDoc != null && xmlDoc.documentElement != null) {\n      _mxStencilRegistry[\"default\"].parseStencilSet(xmlDoc.documentElement, postStencilLoad, install);\n    }\n  }\n};\n\n// Takes array of strings\n_mxStencilRegistry[\"default\"].parseStencilSets = function (stencils) {\n  for (var i = 0; i < stencils.length; i++) {\n    _mxStencilRegistry[\"default\"].parseStencilSet(_mxUtils[\"default\"].parseXml(stencils[i]).documentElement);\n  }\n};\n\n// Parses the given stencil set\n_mxStencilRegistry[\"default\"].parseStencilSet = function (root, postStencilLoad, install) {\n  if (root.nodeName == 'stencils') {\n    var shapes = root.firstChild;\n    while (shapes != null) {\n      if (shapes.nodeName == 'shapes') {\n        _mxStencilRegistry[\"default\"].parseStencilSet(shapes, postStencilLoad, install);\n      }\n      shapes = shapes.nextSibling;\n    }\n  } else {\n    install = install != null ? install : true;\n    var shape = root.firstChild;\n    var packageName = '';\n    var name = root.getAttribute('name');\n    if (name != null) {\n      packageName = name + '.';\n    }\n    while (shape != null) {\n      if (shape.nodeType == _mxConstants[\"default\"].NODETYPE_ELEMENT) {\n        name = shape.getAttribute('name');\n        if (name != null) {\n          packageName = packageName.toLowerCase();\n          var stencilName = name.replace(/ /g, \"_\");\n          if (install) {\n            //stencilName去掉toLowerCase \n            _mxStencilRegistry[\"default\"].addStencil(packageName + stencilName, shape);\n          }\n          if (postStencilLoad != null) {\n            var w = shape.getAttribute('w');\n            var h = shape.getAttribute('h');\n            w = w == null ? 80 : parseInt(w, 10);\n            h = h == null ? 80 : parseInt(h, 10);\n            postStencilLoad(packageName, stencilName, name, w, h);\n          }\n        }\n      }\n      shape = shape.nextSibling;\n    }\n  }\n};\n\n/**\r\n * These overrides are only added if mxVertexHandler is defined (ie. not in embedded graph)\r\n */\nif (typeof _mxVertexHandler[\"default\"] != 'undefined') {\n  (function () {\n    // Sets colors for handles\n    _mxConstants[\"default\"].HANDLE_FILLCOLOR = '#99ccff';\n    _mxConstants[\"default\"].HANDLE_STROKECOLOR = '#0088cf';\n    _mxConstants[\"default\"].VERTEX_SELECTION_COLOR = '#00a8ff';\n    _mxConstants[\"default\"].OUTLINE_COLOR = '#00a8ff';\n    _mxConstants[\"default\"].OUTLINE_HANDLE_FILLCOLOR = '#99ccff';\n    _mxConstants[\"default\"].OUTLINE_HANDLE_STROKECOLOR = '#00a8ff';\n    _mxConstants[\"default\"].CONNECT_HANDLE_FILLCOLOR = '#cee7ff';\n    _mxConstants[\"default\"].EDGE_SELECTION_COLOR = '#00a8ff';\n    _mxConstants[\"default\"].DEFAULT_VALID_COLOR = '#00a8ff';\n    _mxConstants[\"default\"].LABEL_HANDLE_FILLCOLOR = '#cee7ff';\n    _mxConstants[\"default\"].GUIDE_COLOR = '#0088cf';\n    _mxConstants[\"default\"].HIGHLIGHT_OPACITY = 30;\n    _mxConstants[\"default\"].HIGHLIGHT_SIZE = 8;\n\n    //Enables snapping to off-grid terminals for edge waypoints\n    _mxEdgeHandler[\"default\"].prototype.snapToTerminals = true;\n\n    //Enables guides\n    _mxGraphHandler[\"default\"].prototype.guidesEnabled = true;\n\n    //Alt-move disables guides\n    _mxGuide[\"default\"].prototype.isEnabledForEvent = function (evt) {\n      return !_mxEvent[\"default\"].isAltDown(evt);\n    };\n\n    // Extends connection handler to enable ctrl+drag for cloning source cell\n    // since copyOnConnect is now disabled by default\n    var mxConnectionHandlerCreateTarget = _mxConnectionHandler[\"default\"].prototype.isCreateTarget;\n    _mxConnectionHandler[\"default\"].prototype.isCreateTarget = function (evt) {\n      return _mxEvent[\"default\"].isControlDown(evt) || mxConnectionHandlerCreateTarget.apply(this, arguments);\n    };\n\n    // Overrides highlight shape for connection points\n    _mxConstraintHandler[\"default\"].prototype.createHighlightShape = function () {\n      var hl = new _mxEllipse[\"default\"](null, this.highlightColor, this.highlightColor, 0);\n      hl.opacity = _mxConstants[\"default\"].HIGHLIGHT_OPACITY;\n      return hl;\n    };\n\n    // Overrides edge preview to use current edge shape and default style\n    _mxConnectionHandler[\"default\"].prototype.livePreview = true;\n    _mxConnectionHandler[\"default\"].prototype.cursor = 'crosshair';\n\n    // Uses current edge style for connect preview\n    _mxConnectionHandler[\"default\"].prototype.createEdgeState = function (me) {\n      var style = this.graph.createCurrentEdgeStyle();\n      var edge = this.graph.createEdge(null, null, null, null, null, style);\n      var state = new _mxCellState[\"default\"](this.graph.view, edge, this.graph.getCellStyle(edge));\n      for (var key in this.graph.currentEdgeStyle) {\n        state.style[key] = this.graph.currentEdgeStyle[key];\n      }\n      return state;\n    };\n\n    // Overrides dashed state with current edge style\n    var connectionHandlerCreateShape = _mxConnectionHandler[\"default\"].prototype.createShape;\n    _mxConnectionHandler[\"default\"].prototype.createShape = function () {\n      var shape = connectionHandlerCreateShape.apply(this, arguments);\n      shape.isDashed = this.graph.currentEdgeStyle[_mxConstants[\"default\"].STYLE_DASHED] == '1';\n      return shape;\n    };\n\n    // Overrides live preview to keep current style\n    _mxConnectionHandler[\"default\"].prototype.updatePreview = function (valid) {\n      // do not change color of preview\n    };\n\n    // Overrides connection handler to ignore edges instead of not allowing connections\n    var mxConnectionHandlerCreateMarker = _mxConnectionHandler[\"default\"].prototype.createMarker;\n    _mxConnectionHandler[\"default\"].prototype.createMarker = function () {\n      var marker = mxConnectionHandlerCreateMarker.apply(this, arguments);\n      var markerGetCell = marker.getCell;\n      marker.getCell = _mxGraphUtils[\"default\"].bind(this, function (me) {\n        var result = markerGetCell.apply(this, arguments);\n        this.error = null;\n        return result;\n      });\n      return marker;\n    };\n\n    /**\r\n     * Contains the default style for edges.\r\n     */\n    _Graph[\"default\"].prototype.defaultEdgeStyle = {\n      'edgeStyle': 'orthogonalEdgeStyle',\n      'rounded': '1',\n      'html': '1',\n      'jettySize': 'auto',\n      'orthogonalLoop': '1'\n    };\n\n    /**\r\n     * Contains the current style for edges.\r\n     */\n    _Graph[\"default\"].prototype.currentEdgeStyle = _Graph[\"default\"].prototype.defaultEdgeStyle;\n\n    /**\r\n     * Contains the current style for vertices.\r\n     */\n    _Graph[\"default\"].prototype.currentVertexStyle = {};\n\n    /**\r\n     * Returns the current edge style as a string.\r\n     */\n    _Graph[\"default\"].prototype.createCurrentEdgeStyle = function () {\n      var style = 'edgeStyle=' + (this.currentEdgeStyle['edgeStyle'] || 'none') + ';';\n      if (this.currentEdgeStyle['shape'] != null) {\n        style += 'shape=' + this.currentEdgeStyle['shape'] + ';';\n      }\n      if (this.currentEdgeStyle['curved'] != null) {\n        style += 'curved=' + this.currentEdgeStyle['curved'] + ';';\n      }\n      if (this.currentEdgeStyle['rounded'] != null) {\n        style += 'rounded=' + this.currentEdgeStyle['rounded'] + ';';\n      }\n      if (this.currentEdgeStyle['comic'] != null) {\n        style += 'comic=' + this.currentEdgeStyle['comic'] + ';';\n      }\n\n      // Special logic for custom property of elbowEdgeStyle\n      if (this.currentEdgeStyle['edgeStyle'] == 'elbowEdgeStyle' && this.currentEdgeStyle['elbow'] != null) {\n        style += 'elbow=' + this.currentEdgeStyle['elbow'] + ';';\n      }\n      if (this.currentEdgeStyle['html'] != null) {\n        style += 'html=' + this.currentEdgeStyle['html'] + ';';\n      } else {\n        style += 'html=1;';\n      }\n      return style;\n    };\n\n    /**\r\n     * Hook for subclassers.\r\n     */\n    _Graph[\"default\"].prototype.getPagePadding = function () {\n      return new _mxPoint[\"default\"](0, 0);\n    };\n\n    /**\r\n     * Loads the stylesheet for this graph.\r\n     */\n    _Graph[\"default\"].prototype.loadStylesheet = function () {\n      var node = this.themes != null ? this.themes[this.defaultThemeName] : !_mxStyleRegistry[\"default\"].dynamicLoading ? null : _mxRequestUtils[\"default\"].load(STYLE_PATH + '/default.xml').getDocumentElement();\n      if (node != null) {\n        var dec = new _mxCodec[\"default\"](node.ownerDocument);\n        dec.decode(node, this.getStylesheet());\n      }\n    };\n\n    /**\r\n     * Overrides method to provide connection constraints for shapes.\r\n     */\n    _Graph[\"default\"].prototype.getAllConnectionConstraints = function (terminal, source) {\n      if (terminal != null) {\n        var constraints = _mxGraphUtils[\"default\"].getValue(terminal.style, 'points', null);\n        if (constraints != null) {\n          // Requires an array of arrays with x, y (0..1) and an optional\n          // perimeter (0 or 1), eg. points=[[0,0,1],[0,1,0],[1,1]]\n          var result = [];\n          try {\n            var c = JSON.parse(constraints);\n            for (var i = 0; i < c.length; i++) {\n              var tmp = c[i];\n              result.push(new _mxConnectionConstraint[\"default\"](new _mxPoint[\"default\"](tmp[0], tmp[1]), tmp.length > 2 ? tmp[2] != '0' : true));\n            }\n          } catch (e) {\n            // ignore\n          }\n          return result;\n        } else {\n          if (terminal.shape != null) {\n            if (terminal.shape.stencil != null) {\n              if (terminal.shape.stencil != null) {\n                return terminal.shape.stencil.constraints;\n              }\n            } else if (terminal.shape.constraints != null) {\n              return terminal.shape.constraints;\n            }\n          }\n        }\n      }\n      return null;\n    };\n\n    /**\r\n     * Inverts the elbow edge style without removing existing styles.\r\n     */\n    _Graph[\"default\"].prototype.flipEdge = function (edge) {\n      if (edge != null) {\n        var state = this.view.getState(edge);\n        var style = state != null ? state.style : this.getCellStyle(edge);\n        if (style != null) {\n          var elbow = _mxGraphUtils[\"default\"].getValue(style, _mxConstants[\"default\"].STYLE_ELBOW, _mxConstants[\"default\"].ELBOW_HORIZONTAL);\n          var value = elbow == _mxConstants[\"default\"].ELBOW_HORIZONTAL ? _mxConstants[\"default\"].ELBOW_VERTICAL : _mxConstants[\"default\"].ELBOW_HORIZONTAL;\n          this.setCellStyles(_mxConstants[\"default\"].STYLE_ELBOW, value, [edge]);\n        }\n      }\n    };\n\n    /**\r\n     * Disables drill-down for non-swimlanes.\r\n     */\n    _Graph[\"default\"].prototype.isValidRoot = function (cell) {\n      // Counts non-relative children\n      var childCount = this.model.getChildCount(cell);\n      var realChildCount = 0;\n      for (var i = 0; i < childCount; i++) {\n        var child = this.model.getChildAt(cell, i);\n        if (this.model.isVertex(child)) {\n          var geometry = this.getCellGeometry(child);\n          if (geometry != null && !geometry.relative) {\n            realChildCount++;\n          }\n        }\n      }\n      return realChildCount > 0 || this.isContainer(cell);\n    };\n\n    /**\r\n     * Disables drill-down for non-swimlanes.\r\n     */\n    _Graph[\"default\"].prototype.isValidDropTarget = function (cell) {\n      var state = this.view.getState(cell);\n      var style = state != null ? state.style : this.getCellStyle(cell);\n      return _mxGraphUtils[\"default\"].getValue(style, 'part', '0') != '1' && (this.isContainer(cell) || _mxGraph[\"default\"].prototype.isValidDropTarget.apply(this, arguments) && _mxGraphUtils[\"default\"].getValue(style, 'dropTarget', '1') != '0');\n    };\n\n    /**\r\n     * Overrides createGroupCell to set the group style for new groups to 'group'.\r\n     */\n    _Graph[\"default\"].prototype.createGroupCell = function () {\n      var group = _mxGraph[\"default\"].prototype.createGroupCell.apply(this, arguments);\n      group.setStyle('group');\n      return group;\n    };\n\n    /**\r\n     * Disables extending parents with stack layouts on add\r\n     */\n    _Graph[\"default\"].prototype.isExtendParentsOnAdd = function (cell) {\n      var result = _mxGraph[\"default\"].prototype.isExtendParentsOnAdd.apply(this, arguments);\n      if (result && cell != null && this.layoutManager != null) {\n        var parent = this.model.getParent(cell);\n        if (parent != null) {\n          var layout = this.layoutManager.getLayout(parent);\n          if (layout != null && layout.constructor == _mxStackLayout[\"default\"]) {\n            result = false;\n          }\n        }\n      }\n      return result;\n    };\n\n    /**\r\n     * Overrides autosize to add a border.\r\n     */\n    _Graph[\"default\"].prototype.getPreferredSizeForCell = function (cell) {\n      var result = _mxGraph[\"default\"].prototype.getPreferredSizeForCell.apply(this, arguments);\n\n      // Adds buffer\n      if (result != null) {\n        result.width += 10;\n        result.height += 4;\n        if (this.gridEnabled) {\n          result.width = this.snap(result.width);\n          result.height = this.snap(result.height);\n        }\n      }\n      return result;\n    };\n\n    /**\r\n     * Turns the given cells and returns the changed cells.\r\n     */\n    _Graph[\"default\"].prototype.turnShapes = function (cells) {\n      var model = this.getModel();\n      var select = [];\n      model.beginUpdate();\n      try {\n        for (var i = 0; i < cells.length; i++) {\n          var cell = cells[i];\n          if (model.isEdge(cell)) {\n            var src = model.getTerminal(cell, true);\n            var trg = model.getTerminal(cell, false);\n            model.setTerminal(cell, trg, true);\n            model.setTerminal(cell, src, false);\n            var geo = model.getGeometry(cell);\n            if (geo != null) {\n              geo = geo.clone();\n              if (geo.points != null) {\n                geo.points.reverse();\n              }\n              var sp = geo.getTerminalPoint(true);\n              var tp = geo.getTerminalPoint(false);\n              geo.setTerminalPoint(sp, false);\n              geo.setTerminalPoint(tp, true);\n              model.setGeometry(cell, geo);\n\n              // Inverts constraints\n              var edgeState = this.view.getState(cell);\n              var sourceState = this.view.getState(src);\n              var targetState = this.view.getState(trg);\n              if (edgeState != null) {\n                var sc = sourceState != null ? this.getConnectionConstraint(edgeState, sourceState, true) : null;\n                var tc = targetState != null ? this.getConnectionConstraint(edgeState, targetState, false) : null;\n                this.setConnectionConstraint(cell, src, true, tc);\n                this.setConnectionConstraint(cell, trg, false, sc);\n              }\n              select.push(cell);\n            }\n          } else if (model.isVertex(cell)) {\n            var geo = this.getCellGeometry(cell);\n            if (geo != null) {\n              // Rotates the size and position in the geometry\n              geo = geo.clone();\n              geo.x += geo.width / 2 - geo.height / 2;\n              geo.y += geo.height / 2 - geo.width / 2;\n              var tmp = geo.width;\n              geo.width = geo.height;\n              geo.height = tmp;\n              model.setGeometry(cell, geo);\n\n              // Reads the current direction and advances by 90 degrees\n              var state = this.view.getState(cell);\n              if (state != null) {\n                var dir = state.style[_mxConstants[\"default\"].STYLE_DIRECTION] || 'east' /*default*/;\n                if (dir == 'east') {\n                  dir = 'south';\n                } else if (dir == 'south') {\n                  dir = 'west';\n                } else if (dir == 'west') {\n                  dir = 'north';\n                } else if (dir == 'north') {\n                  dir = 'east';\n                }\n                this.setCellStyles(_mxConstants[\"default\"].STYLE_DIRECTION, dir, [cell]);\n              }\n              select.push(cell);\n            }\n          }\n        }\n      } finally {\n        model.endUpdate();\n      }\n      return select;\n    };\n\n    /**\r\n     * Updates the child cells with placeholders if metadata of a cell has changed.\r\n     */\n    _Graph[\"default\"].prototype.processChange = function (change) {\n      _mxGraph[\"default\"].prototype.processChange.apply(this, arguments);\n      if (change instanceof _mxValueChange[\"default\"] && change.cell.value != null && _typeof(change.cell.value) == 'object') {\n        // Invalidates all descendants with placeholders\n        var desc = this.model.getDescendants(change.cell);\n\n        // LATER: Check if only label or tooltip have changed\n        if (desc.length > 0) {\n          for (var i = 0; i < desc.length; i++) {\n            if (this.isReplacePlaceholders(desc[i])) {\n              this.view.invalidate(desc[i], false, false);\n            }\n          }\n        }\n      }\n    };\n\n    /**\r\n     * Handles label changes for XML user objects.\r\n     */\n    _Graph[\"default\"].prototype.cellLabelChanged = function (cell, value, autoSize) {\n      // Removes all illegal control characters in user input\n      value = this.zapGremlins(value);\n      this.model.beginUpdate();\n      try {\n        if (cell.value != null && _typeof(cell.value) == 'object') {\n          var tmp = cell.value.cloneNode(true);\n          tmp.setAttribute('label', value);\n          if (this.isReplacePlaceholders(cell) && tmp.getAttribute('placeholder') != null) {\n            // LATER: Handle delete, name change\n            this.setAttributeForCell(this.getModel().getRoot(), tmp.getAttribute('placeholder'), value);\n          }\n          value = tmp;\n        }\n        _mxGraph[\"default\"].prototype.cellLabelChanged.apply(this, arguments);\n      } finally {\n        this.model.endUpdate();\n      }\n    };\n\n    /**\r\n     * Overrides ungroup to check if group should be removed.\r\n     */\n    _Graph[\"default\"].prototype.removeCellsAfterUngroup = function (cells) {\n      var cellsToRemove = [];\n      for (var i = 0; i < cells.length; i++) {\n        if (this.isCellDeletable(cells[i])) {\n          var state = this.view.getState(cells[i]);\n          if (state != null) {\n            var stroke = _mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_STROKECOLOR, _mxConstants[\"default\"].NONE);\n            var fill = _mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_FILLCOLOR, _mxConstants[\"default\"].NONE);\n            if (stroke == _mxConstants[\"default\"].NONE && fill == _mxConstants[\"default\"].NONE) {\n              cellsToRemove.push(cells[i]);\n            }\n          }\n        }\n      }\n      cells = cellsToRemove;\n      _mxGraph[\"default\"].prototype.removeCellsAfterUngroup.apply(this, arguments);\n    };\n\n    /**\r\n     * Sets the link for the given cell.\r\n     */\n    _Graph[\"default\"].prototype.setLinkForCell = function (cell, link) {\n      this.setAttributeForCell(cell, 'link', link);\n    };\n\n    /**\r\n     * Sets the link for the given cell.\r\n     */\n    _Graph[\"default\"].prototype.setTooltipForCell = function (cell, link) {\n      this.setAttributeForCell(cell, 'tooltip', link);\n    };\n\n    /**\r\n     * Sets the link for the given cell.\r\n     */\n    _Graph[\"default\"].prototype.setAttributeForCell = function (cell, attributeName, attributeValue) {\n      var value = null;\n\n      /*if (cell.value != null && typeof(cell.value) == 'object')\r\n      {\r\n      \tvalue = cell.value.cloneNode(true);\r\n      }\r\n      else\r\n      {\r\n      \tvar doc = mxUtils.createXmlDocument();\r\n      \t\r\n      \tvalue = doc.createElement('UserObject');\r\n      \tvalue.setAttribute('label', cell.value || '');\r\n      }\r\n      \r\n      if (attributeValue != null && attributeValue.length > 0)\r\n      {\r\n      \tvalue.setAttribute(attributeName, attributeValue);\r\n      }\r\n      else\r\n      {\r\n      \tvalue.removeAttribute(attributeName);\r\n      }*/\n\n      this.model.setValue(cell, value);\n    };\n\n    /**\r\n     * Overridden to stop moving edge labels between cells.\r\n     */\n    _Graph[\"default\"].prototype.getDropTarget = function (cells, evt, cell, clone) {\n      var model = this.getModel();\n\n      // Disables drop into group if alt is pressed\n      if (_mxEvent[\"default\"].isAltDown(evt)) {\n        return null;\n      }\n\n      // Disables dragging edge labels out of edges\n      for (var i = 0; i < cells.length; i++) {\n        if (this.model.isEdge(this.model.getParent(cells[i]))) {\n          return null;\n        }\n      }\n      return _mxGraph[\"default\"].prototype.getDropTarget.apply(this, arguments);\n    };\n\n    /**\r\n     * Overrides double click handling to avoid accidental inserts of new labels in dblClick below.\r\n     */\n    _Graph[\"default\"].prototype.click = function (me) {\n      _mxGraph[\"default\"].prototype.click.call(this, me);\n\n      // Stores state and source for checking in dblClick\n      this.firstClickState = me.getState();\n      this.firstClickSource = me.getSource();\n    };\n\n    /**\r\n     * Overrides double click handling to add the tolerance and inserting text.\r\n     */\n    _Graph[\"default\"].prototype.dblClick = function (evt, cell) {\n      //根据需求，双击显示编辑文本框不符合常用操作，先注释掉\n      /*if (this.isEnabled())\r\n      {\r\n      \tvar pt = mxUtils.convertPoint(this.container, mxEvent.getClientX(evt), mxEvent.getClientY(evt));\r\n      \n      \t// Automatically adds new child cells to edges on double click\r\n      \tif (evt != null && !this.model.isVertex(cell))\r\n      \t{\r\n      \t\tvar state = (this.model.isEdge(cell)) ? this.view.getState(cell) : null;\r\n      \t\tvar src = mxEvent.getSource(evt);\r\n      \t\t\r\n      \t\tif (this.firstClickState == state && this.firstClickSource == src)\r\n      \t\t{\r\n      \t\t\tif (state == null || (state.text == null || state.text.node == null ||\r\n      \t\t\t\t(!mxUtils.contains(state.text.boundingBox, pt.x, pt.y) &&\r\n      \t\t\t\t!mxUtils.isAncestorNode(state.text.node, mxEvent.getSource(evt)))))\r\n      \t\t\t{\r\n      \t\t\t\tif ((state == null && !this.isCellLocked(this.getDefaultParent())) ||\r\n      \t\t\t\t\t(state != null && !this.isCellLocked(state.cell)))\r\n      \t\t\t\t{\r\n      \t\t\t\t\t// Avoids accidental inserts on background\r\n      \t\t\t\t\tif (state != null || (mxClient.IS_VML && src == this.view.getCanvas()) ||\r\n      \t\t\t\t\t\t(mxClient.IS_SVG && src == this.view.getCanvas().ownerSVGElement))\r\n      \t\t\t\t\t{\r\n      \t\t\t\t\t\tcell = this.addText(pt.x, pt.y, state);\r\n      \t\t\t\t\t}\r\n      \t\t\t\t}\r\n      \t\t\t}\r\n      \t\t}\r\n      \t}\r\n      \r\n      \tmxGraph.prototype.dblClick.call(this, evt, cell);\r\n      }*/\n    };\n\n    /**\r\n     * Returns a point that specifies the location for inserting cells.\r\n     */\n    _Graph[\"default\"].prototype.getInsertPoint = function () {\n      var gs = this.getGridSize();\n      var dx = this.container.scrollLeft / this.view.scale - this.view.translate.x;\n      var dy = this.container.scrollTop / this.view.scale - this.view.translate.y;\n      if (this.pageVisible) {\n        var layout = this.getPageLayout();\n        var page = this.getPageSize();\n        dx = Math.max(dx, layout.x * page.width);\n        dy = Math.max(dy, layout.y * page.height);\n      }\n      return new _mxPoint[\"default\"](this.snap(dx + gs), this.snap(dy + gs));\n    };\n\n    /**\r\n     * Adds a new label at the given position and returns the new cell. State is\r\n     * an optional edge state to be used as the parent for the label. Vertices\r\n     * are not allowed currently as states.\r\n     */\n    _Graph[\"default\"].prototype.addText = function (x, y, state) {\n      // Creates a new edge label with a predefined text\n      var label = new _mxCell[\"default\"]();\n      label.value = 'Text';\n      label.style = 'text;html=1;resizable=0;points=[];';\n      label.geometry = new _mxGeometry[\"default\"](0, 0, 0, 0);\n      label.vertex = true;\n      if (state != null) {\n        label.style += 'align=center;verticalAlign=middle;labelBackgroundColor=#ffffff;';\n        label.geometry.relative = true;\n        label.connectable = false;\n\n        // Resets the relative location stored inside the geometry\n        var pt2 = this.view.getRelativePoint(state, x, y);\n        label.geometry.x = Math.round(pt2.x * 10000) / 10000;\n        label.geometry.y = Math.round(pt2.y);\n\n        // Resets the offset inside the geometry to find the offset from the resulting point\n        label.geometry.offset = new _mxPoint[\"default\"](0, 0);\n        pt2 = this.view.getPoint(state, label.geometry);\n        var scale = this.view.scale;\n        label.geometry.offset = new _mxPoint[\"default\"](Math.round((x - pt2.x) / scale), Math.round((y - pt2.y) / scale));\n      } else {\n        label.style += 'autosize=1;align=left;verticalAlign=top;spacingTop=-4;';\n        var tr = this.view.translate;\n        label.geometry.width = 40;\n        label.geometry.height = 20;\n        label.geometry.x = Math.round(x / this.view.scale) - tr.x;\n        label.geometry.y = Math.round(y / this.view.scale) - tr.y;\n      }\n      this.getModel().beginUpdate();\n      try {\n        this.addCells([label], state != null ? state.cell : null);\n        this.fireEvent(new _mxEventObject[\"default\"]('textInserted', 'cells', [label]));\n        // Updates size of text after possible change of style via event\n        this.autoSizeCell(label);\n      } finally {\n        this.getModel().endUpdate();\n      }\n      return label;\n    };\n\n    /**\r\n     * Returns the link to be used for the given URL when clicking on a cell\r\n     * where the the link is not a blank link and the diagram is not inside\r\n     * and iframe.\r\n     */\n    _Graph[\"default\"].prototype.getLinkUrl = function (url) {\n      return url;\n    };\n\n    /**\r\n     * \r\n     */\n    _Graph[\"default\"].prototype.getAbsoluteUrl = function (url) {\n      if (url != null && this.isRelativeUrl(url)) {\n        if (url.charAt(0) == '/') {\n          url = this.domainUrl + url;\n        } else {\n          url = this.domainPathUrl + url;\n        }\n      }\n      return url;\n    };\n\n    /**\r\n     * Hook for links to open in same window. Default returns true for anchors,\r\n     * links to same domain or if target == 'self' in the config.\r\n     */\n    _Graph[\"default\"].prototype.isBlankLink = function (href) {\n      var dom = this.domainUrl;\n      return urlParams['target'] != 'self' && href != null && href.charAt(0) != '#' && href.substring(0, dom.length) != dom && !this.isRelativeUrl(href);\n    };\n\n    /**\r\n     * \r\n     */\n    _Graph[\"default\"].prototype.isRelativeUrl = function (url) {\n      return !new RegExp('^(?:[a-z]+:)?//', 'i').test(url) && url.substring(0, 10) != 'data:image' && url.substring(0, 7) != 'mailto:';\n    };\n\n    /**\r\n     * Adds event handler for links and lightbox.\r\n     */\n    _Graph[\"default\"].prototype.addClickHandler = function (highlight, beforeClick, onClick) {\n      // Hides lightbox before executing links on same page\n      var checkLinks = _mxGraphUtils[\"default\"].bind(this, function () {\n        var links = this.container.getElementsByTagName('a');\n        if (links != null) {\n          for (var i = 0; i < links.length; i++) {\n            var href = links[i].getAttribute('href');\n            if (href != null && !this.isBlankLink(href)) {\n              if (window != window.top) {\n                links[i].setAttribute('target', '_top');\n                if (href.charAt('#')) {\n                  links[i].setAttribute('href', this.baseUrl + href);\n                } else {\n                  links[i].setAttribute('href', this.getAbsoluteUrl(href));\n                }\n              } else if (links[i].getAttribute('target') == '_blank') {\n                links[i].removeAttribute('target');\n              }\n              if (beforeClick != null) {\n                _mxEvent[\"default\"].addListener(links[i], 'click', beforeClick);\n              }\n            }\n          }\n        }\n      });\n      this.model.addListener(_mxEvent[\"default\"].CHANGE, checkLinks);\n      checkLinks();\n      var cursor = this.container.style.cursor;\n      var tol = this.getTolerance();\n      var graph = this;\n      var mouseListener = {\n        currentState: null,\n        currentLink: null,\n        highlight: highlight != null && highlight != '' && highlight != _mxConstants[\"default\"].NONE ? new _mxCellHighlight[\"default\"](graph, highlight, 4) : null,\n        startX: 0,\n        startY: 0,\n        scrollLeft: 0,\n        scrollTop: 0,\n        updateCurrentState: function updateCurrentState(me) {\n          var tmp = graph.view.getState(me.getCell());\n          if (tmp != this.currentState) {\n            if (this.currentState != null) {\n              this.clear();\n            }\n            this.currentState = tmp;\n            if (this.currentState != null) {\n              this.activate(this.currentState);\n            }\n          }\n        },\n        mouseDown: function mouseDown(sender, me) {\n          this.startX = me.getGraphX();\n          this.startY = me.getGraphY();\n          this.scrollLeft = graph.container.scrollLeft;\n          this.scrollTop = graph.container.scrollTop;\n          if (this.currentLink == null && graph.container.style.overflow == 'auto') {\n            graph.container.style.cursor = 'move';\n          }\n          this.updateCurrentState(me);\n        },\n        mouseMove: function mouseMove(sender, me) {\n          if (graph.isMouseDown) {\n            if (this.currentLink != null) {\n              var dx = Math.abs(this.startX - me.getGraphX());\n              var dy = Math.abs(this.startY - me.getGraphY());\n              if (dx > tol || dy > tol) {\n                this.clear();\n              }\n            }\n          } else {\n            if (me.getSource().nodeName.toLowerCase() == 'a') {\n              this.clear();\n            } else {\n              if (this.currentState != null && (me.getState() == this.currentState || me.getState() == null) && graph.intersects(this.currentState, me.getGraphX(), me.getGraphY())) {\n                return;\n              }\n              this.updateCurrentState(me);\n            }\n          }\n        },\n        mouseUp: function mouseUp(sender, me) {\n          var source = me.getSource();\n          var tmp = this.currentLink;\n          this.clear();\n\n          // Ignores clicks on links and collapse/expand icon\n          if (source.nodeName.toLowerCase() != 'a' && !me.isConsumed() && (me.getState() == null || !me.isSource(me.getState().control)) && (_mxEvent[\"default\"].isLeftMouseButton(me.getEvent()) || _mxEvent[\"default\"].isTouchEvent(me.getEvent()))) {\n            if (tmp != null) {\n              if (!graph.isBlankLink(tmp)) {\n                if (beforeClick != null) {\n                  beforeClick(me.getEvent());\n                }\n                if (tmp.charAt(0) == '#') {\n                  if (window != window.top) {\n                    window.open(graph.baseUrl + tmp, '_top');\n                  } else {\n                    window.location.hash = tmp;\n                  }\n                } else {\n                  if (window != window.top) {\n                    window.open(graph.getAbsoluteUrl(tmp), '_top');\n                  } else {\n                    window.location = tmp;\n                  }\n                }\n              } else {\n                window.open(tmp);\n              }\n              me.consume();\n            } else if (onClick != null && !me.isConsumed() && Math.abs(this.scrollLeft - graph.container.scrollLeft) < tol && Math.abs(this.scrollTop - graph.container.scrollTop) < tol && Math.abs(this.startX - me.getGraphX()) < tol && Math.abs(this.startY - me.getGraphY()) < tol) {\n              onClick(me.getEvent());\n            }\n          }\n        },\n        activate: function activate(state) {\n          this.currentLink = graph.getLinkUrl(graph.getLinkForCell(state.cell));\n          if (this.currentLink != null) {\n            graph.container.style.cursor = 'pointer';\n            if (this.highlight != null) {\n              this.highlight.highlight(state);\n            }\n          }\n        },\n        clear: function clear() {\n          if (graph.container != null) {\n            graph.container.style.cursor = cursor;\n          }\n          this.currentState = null;\n          this.currentLink = null;\n          if (this.highlight != null) {\n            this.highlight.hide();\n          }\n        }\n      };\n\n      // Ignores built-in click handling\n      graph.click = function (me) {};\n      graph.addMouseListener(mouseListener);\n      _mxEvent[\"default\"].addListener(document, 'mouseleave', function (evt) {\n        mouseListener.clear();\n      });\n    };\n\n    /**\r\n     * Duplicates the given cells and returns the duplicates.\r\n     */\n    _Graph[\"default\"].prototype.duplicateCells = function (cells, append, geo) {\n      cells = cells != null ? cells : this.getSelectionCells();\n      append = append != null ? append : true;\n      cells = this.model.getTopmostCells(cells);\n      var model = this.getModel();\n      var s = this.gridSize;\n      var select = [];\n      model.beginUpdate();\n      try {\n        var clones = this.cloneCells(cells, false);\n        for (var i = 0; i < cells.length; i++) {\n          geo && this.model.setGeometry(clones[i], geo);\n          var parent = model.getParent(cells[i]);\n          var child = this.moveCells([clones[i]], s, s, false, parent)[0];\n          select.push(child);\n          if (append) {\n            model.add(parent, clones[i]);\n          } else {\n            // Maintains child index by inserting after cloned in parent\n            var index = parent.getIndex(cells[i]);\n            model.add(parent, clones[i], index + 1);\n          }\n        }\n      } finally {\n        model.endUpdate();\n      }\n      return select;\n    };\n\n    /**\r\n     * Inserts the given image at the cursor in a content editable text box using\r\n     * the insertimage command on the document instance.\r\n     */\n    _Graph[\"default\"].prototype.insertImage = function (newValue, w, h) {\n      // To find the new image, we create a list of all existing links first\n      if (newValue != null) {\n        var tmp = this.cellEditor.textarea.getElementsByTagName('img');\n        var oldImages = [];\n        for (var i = 0; i < tmp.length; i++) {\n          oldImages.push(tmp[i]);\n        }\n\n        // LATER: Fix inserting link/image in IE8/quirks after focus lost\n        document.execCommand('insertimage', false, newValue);\n\n        // Sets size of new image\n        var newImages = this.cellEditor.textarea.getElementsByTagName('img');\n        if (newImages.length == oldImages.length + 1) {\n          // Inverse order in favor of appended images\n          for (var i = newImages.length - 1; i >= 0; i--) {\n            if (i == 0 || newImages[i] != oldImages[i - 1]) {\n              // Workaround for lost styles during undo and redo is using attributes\n              newImages[i].setAttribute('width', w);\n              newImages[i].setAttribute('height', h);\n              break;\n            }\n          }\n        }\n      }\n    };\n\n    /**\r\n     * \r\n     * @param cell\r\n     * @returns {Boolean}\r\n     */\n    _Graph[\"default\"].prototype.isCellResizable = function (cell) {\n      var result = _mxGraph[\"default\"].prototype.isCellResizable.apply(this, arguments);\n      var state = this.view.getState(cell);\n      var style = state != null ? state.style : this.getCellStyle(cell);\n      return result || _mxGraphUtils[\"default\"].getValue(style, _mxConstants[\"default\"].STYLE_RESIZABLE, '1') != '0' && style[_mxConstants[\"default\"].STYLE_WHITE_SPACE] == 'wrap';\n    };\n\n    /**\r\n     * Function: alignCells\r\n     * \r\n     * Aligns the given cells vertically or horizontally according to the given\r\n     * alignment using the optional parameter as the coordinate.\r\n     * \r\n     * Parameters:\r\n     * \r\n     * horizontal - Boolean that specifies the direction of the distribution.\r\n     * cells - Optional array of <mxCells> to be distributed. Edges are ignored.\r\n     */\n    _Graph[\"default\"].prototype.distributeCells = function (horizontal, cells) {\n      if (cells == null) {\n        cells = this.getSelectionCells();\n      }\n      if (cells != null && cells.length > 1) {\n        var vertices = [];\n        var max = null;\n        var min = null;\n        for (var i = 0; i < cells.length; i++) {\n          if (this.getModel().isVertex(cells[i])) {\n            var state = this.view.getState(cells[i]);\n            if (state != null) {\n              var tmp = horizontal ? state.getCenterX() : state.getCenterY();\n              max = max != null ? Math.max(max, tmp) : tmp;\n              min = min != null ? Math.min(min, tmp) : tmp;\n              vertices.push(state);\n            }\n          }\n        }\n        if (vertices.length > 2) {\n          vertices.sort(function (a, b) {\n            return horizontal ? a.x - b.x : a.y - b.y;\n          });\n          var t = this.view.translate;\n          var s = this.view.scale;\n          min = min / s - (horizontal ? t.x : t.y);\n          max = max / s - (horizontal ? t.x : t.y);\n          this.getModel().beginUpdate();\n          try {\n            var dt = (max - min) / (vertices.length - 1);\n            var t0 = min;\n            for (var i = 1; i < vertices.length - 1; i++) {\n              var geo = this.getCellGeometry(vertices[i].cell);\n              t0 += dt;\n              if (geo != null) {\n                geo = geo.clone();\n                if (horizontal) {\n                  geo.x = Math.round(t0 - geo.width / 2);\n                } else {\n                  geo.y = Math.round(t0 - geo.height / 2);\n                }\n                this.getModel().setGeometry(vertices[i].cell, geo);\n              }\n            }\n          } finally {\n            this.getModel().endUpdate();\n          }\n        }\n      }\n      return cells;\n    };\n\n    /**\r\n     * Adds meta-drag an Mac.\r\n     * @param evt\r\n     * @returns\r\n     */\n    _Graph[\"default\"].prototype.isCloneEvent = function (evt) {\n      return false;\n      //return (mxClient.IS_MAC && mxEvent.isMetaDown(evt)) || mxEvent.isControlDown(evt);\n    };\n\n    /**\r\n     * Translates this point by the given vector.\r\n     * \r\n     * @param {number} dx X-coordinate of the translation.\r\n     * @param {number} dy Y-coordinate of the translation.\r\n     */\n    _Graph[\"default\"].prototype.encodeCells = function (cells) {\n      var clones = this.cloneCells(cells);\n\n      // Checks for orphaned relative children and makes absolute\n      for (var i = 0; i < clones.length; i++) {\n        var state = this.view.getState(cells[i]);\n        if (state != null) {\n          var geo = this.getCellGeometry(clones[i]);\n          if (geo != null && geo.relative) {\n            geo.relative = false;\n            geo.x = state.x / state.view.scale - state.view.translate.x;\n            geo.y = state.y / state.view.scale - state.view.translate.y;\n          }\n        }\n      }\n      var codec = new _mxCodec[\"default\"]();\n      var model = new _mxGraphModel[\"default\"]();\n      var parent = model.getChildAt(model.getRoot(), 0);\n      for (var i = 0; i < cells.length; i++) {\n        model.add(parent, clones[i]);\n      }\n      return codec.encode(model);\n    };\n\n    /**\r\n     * Translates this point by the given vector.\r\n     * \r\n     * @param {number} dx X-coordinate of the translation.\r\n     * @param {number} dy Y-coordinate of the translation.\r\n     */\n    _Graph[\"default\"].prototype.createSvgImageExport = function () {\n      var exp = new _mxImageExport[\"default\"]();\n\n      // Adds hyperlinks (experimental)\n      exp.getLinkForCellState = _mxGraphUtils[\"default\"].bind(this, function (state, canvas) {\n        return this.getLinkForCell(state.cell);\n      });\n      return exp;\n    };\n\n    /**\r\n     * Translates this point by the given vector.\r\n     * \r\n     * @param {number} dx X-coordinate of the translation.\r\n     * @param {number} dy Y-coordinate of the translation.\r\n     */\n    _Graph[\"default\"].prototype.getSvg = function (background, scale, border, nocrop, crisp, ignoreSelection, showText) {\n      scale = scale != null ? scale : 1;\n      border = border != null ? border : 1;\n      crisp = crisp != null ? crisp : true;\n      ignoreSelection = ignoreSelection != null ? ignoreSelection : true;\n      showText = showText != null ? showText : true;\n      var bounds = nocrop ? this.view.getBackgroundPageBounds() : ignoreSelection ? this.getGraphBounds() : this.getBoundingBox(this.getSelectionCells());\n      if (bounds == null) {\n        throw Error(_mxResources[\"default\"].get('drawingEmpty'));\n      }\n      var imgExport = this.createSvgImageExport();\n      var imgExportDrawCellState = imgExport.drawCellState;\n\n      // Implements ignoreSelection flag\n      imgExport.drawCellState = function (state, canvas) {\n        if (ignoreSelection || state.view.graph.isCellSelected(state.cell)) {\n          imgExportDrawCellState.apply(this, arguments);\n        }\n      };\n      var vs = this.view.scale;\n\n      // Prepares SVG document that holds the output\n      var svgDoc = _mxUtils[\"default\"].createXmlDocument();\n      var root = svgDoc.createElementNS != null ? svgDoc.createElementNS(_mxConstants[\"default\"].NS_SVG, 'svg') : svgDoc.createElement('svg');\n      if (background != null) {\n        if (root.style != null) {\n          root.style.backgroundColor = background;\n        } else {\n          root.setAttribute('style', 'background-color:' + background);\n        }\n      }\n      if (svgDoc.createElementNS == null) {\n        root.setAttribute('xmlns', _mxConstants[\"default\"].NS_SVG);\n        root.setAttribute('xmlns:xlink', _mxConstants[\"default\"].NS_XLINK);\n      } else {\n        // KNOWN: Ignored in IE9-11, adds namespace for each image element instead. No workaround.\n        root.setAttributeNS('http://www.w3.org/2000/xmlns/', 'xmlns:xlink', _mxConstants[\"default\"].NS_XLINK);\n      }\n      var s = scale / vs;\n      root.setAttribute('width', Math.ceil(bounds.width * s) + 2 * border + 'px');\n      root.setAttribute('height', Math.ceil(bounds.height * s) + 2 * border + 'px');\n      root.setAttribute('version', '1.1');\n\n      // Adds group for anti-aliasing via transform\n      var node = root;\n      if (crisp) {\n        var group = svgDoc.createElementNS != null ? svgDoc.createElementNS(_mxConstants[\"default\"].NS_SVG, 'g') : svgDoc.createElement('g');\n        group.setAttribute(\"class\", \"root\");\n        group.setAttribute('transform', 'translate(0.5,0.5)');\n        root.appendChild(group);\n        svgDoc.appendChild(root);\n        node = group;\n      } else {\n        svgDoc.appendChild(root);\n      }\n\n      // Renders graph. Offset will be multiplied with state's scale when painting state.\n      // TextOffset only seems to affect FF output but used everywhere for consistency.\n      var svgCanvas = new _mxSvgCanvas2D[\"default\"](node);\n      svgCanvas.foOffset = crisp ? -0.5 : 0;\n      svgCanvas.textOffset = crisp ? -0.5 : 0;\n      svgCanvas.translate(Math.floor((border / scale - bounds.x) / vs), Math.floor((border / scale - bounds.y) / vs));\n      if (svgCanvas.defs) {\n        var defsClone = svgCanvas.defs.cloneNode(true);\n        if (root.firstChild) {\n          root.insertBefore(defsClone, root.firstChild);\n        } else {\n          root.appendChild(defsClone);\n        }\n      }\n\n      // Adds simple text fallback for viewers with no support for foreignObjects\n      var createAlternateContent = svgCanvas.createAlternateContent;\n      svgCanvas.createAlternateContent = function (fo, x, y, w, h, str, align, valign, wrap, format, overflow, clip, rotation) {\n        var s = this.state;\n\n        // Assumes a max character width of 0.2em\n        if (this.foAltText != null && (w == 0 || s.fontSize != 0 && str.length < w * 5 / s.fontSize)) {\n          var alt = this.createElement('text');\n          alt.setAttribute('x', Math.round(w / 2));\n          alt.setAttribute('y', Math.round((h + s.fontSize) / 2));\n          alt.setAttribute('fill', s.fontColor || 'black');\n          alt.setAttribute('text-anchor', 'middle');\n          alt.setAttribute('font-size', Math.round(s.fontSize) + 'px');\n          alt.setAttribute('font-family', s.fontFamily);\n          if ((s.fontStyle & _mxConstants[\"default\"].FONT_BOLD) == _mxConstants[\"default\"].FONT_BOLD) {\n            alt.setAttribute('font-weight', 'bold');\n          }\n          if ((s.fontStyle & _mxConstants[\"default\"].FONT_ITALIC) == _mxConstants[\"default\"].FONT_ITALIC) {\n            alt.setAttribute('font-style', 'italic');\n          }\n          if ((s.fontStyle & _mxConstants[\"default\"].FONT_UNDERLINE) == _mxConstants[\"default\"].FONT_UNDERLINE) {\n            alt.setAttribute('text-decoration', 'underline');\n          }\n          _mxGraphUtils[\"default\"].write(alt, str);\n          return alt;\n        } else {\n          return createAlternateContent.apply(this, arguments);\n        }\n      };\n\n      // Paints background image\n      var bgImg = this.backgroundImage;\n      if (bgImg != null) {\n        var s2 = vs / scale;\n        var tr = this.view.translate;\n        var tmp = new _mxRectangle[\"default\"](tr.x * s2, tr.y * s2, bgImg.width * s2, bgImg.height * s2);\n\n        // Checks if visible\n        if (_mxUtils[\"default\"].intersects(bounds, tmp)) {\n          svgCanvas.image(tr.x, tr.y, bgImg.width, bgImg.height, bgImg.src, true);\n        }\n      }\n      svgCanvas.scale(s);\n      svgCanvas.textEnabled = showText;\n      imgExport.drawState(this.getView().getState(this.model.root), svgCanvas);\n      return root;\n    };\n\n    /**\r\n     * Returns the first ancestor of the current selection with the given name.\r\n     */\n    _Graph[\"default\"].prototype.getSelectedElement = function () {\n      var node = null;\n      if (window.getSelection) {\n        var sel = window.getSelection();\n        if (sel.getRangeAt && sel.rangeCount) {\n          var range = sel.getRangeAt(0);\n          node = range.commonAncestorContainer;\n        }\n      } else if (document.selection) {\n        node = document.selection.createRange().parentElement();\n      }\n      return node;\n    };\n\n    /**\r\n     * Returns the first ancestor of the current selection with the given name.\r\n     */\n    _Graph[\"default\"].prototype.getParentByName = function (node, name, stopAt) {\n      while (node != null) {\n        if (node.nodeName == name) {\n          return node;\n        }\n        if (node == stopAt) {\n          return null;\n        }\n        node = node.parentNode;\n      }\n      return node;\n    };\n\n    /**\r\n     * Selects the given node.\r\n     */\n    _Graph[\"default\"].prototype.selectNode = function (node) {\n      var sel = null;\n\n      // IE9 and non-IE\n      if (window.getSelection) {\n        sel = window.getSelection();\n        if (sel.getRangeAt && sel.rangeCount) {\n          var range = document.createRange();\n          range.selectNode(node);\n          sel.removeAllRanges();\n          sel.addRange(range);\n        }\n      }\n      // IE < 9\n      else if ((sel = document.selection) && sel.type != 'Control') {\n        var originalRange = sel.createRange();\n        originalRange.collapse(true);\n        var range = sel.createRange();\n        range.setEndPoint('StartToStart', originalRange);\n        range.select();\n      }\n    };\n\n    /**\r\n     * Inserts a new row into the given table.\r\n     */\n    _Graph[\"default\"].prototype.insertRow = function (table, index) {\n      var bd = table.tBodies[0];\n      var cols = bd.rows.length > 0 ? bd.rows[0].cells.length : 1;\n      var row = bd.insertRow(index);\n      for (var i = 0; i < cols; i++) {\n        _mxUtils[\"default\"].br(row.insertCell(-1));\n      }\n      return row.cells[0];\n    };\n\n    /**\r\n     * Deletes the given column.\r\n     */\n    _Graph[\"default\"].prototype.deleteRow = function (table, index) {\n      table.tBodies[0].deleteRow(index);\n    };\n\n    /**\r\n     * Deletes the given column.\r\n     */\n    _Graph[\"default\"].prototype.insertColumn = function (table, index) {\n      var hd = table.tHead;\n      if (hd != null) {\n        // TODO: use colIndex\n        for (var h = 0; h < hd.rows.length; h++) {\n          var th = document.createElement('th');\n          hd.rows[h].appendChild(th);\n          _mxUtils[\"default\"].br(th);\n        }\n      }\n      var bd = table.tBodies[0];\n      for (var i = 0; i < bd.rows.length; i++) {\n        var cell = bd.rows[i].insertCell(index);\n        _mxUtils[\"default\"].br(cell);\n      }\n      return bd.rows[0].cells[index >= 0 ? index : bd.rows[0].cells.length - 1];\n    };\n\n    /**\r\n     * Deletes the given column.\r\n     */\n    _Graph[\"default\"].prototype.deleteColumn = function (table, index) {\n      if (index >= 0) {\n        var bd = table.tBodies[0];\n        var rows = bd.rows;\n        for (var i = 0; i < rows.length; i++) {\n          if (rows[i].cells.length > index) {\n            rows[i].deleteCell(index);\n          }\n        }\n      }\n    };\n\n    /**\r\n     * Inserts the given HTML at the caret position (no undo).\r\n     */\n    _Graph[\"default\"].prototype.pasteHtmlAtCaret = function (html) {\n      var sel, range;\n\n      // IE9 and non-IE\n      if (window.getSelection) {\n        sel = window.getSelection();\n        if (sel.getRangeAt && sel.rangeCount) {\n          range = sel.getRangeAt(0);\n          range.deleteContents();\n\n          // Range.createContextualFragment() would be useful here but is\n          // only relatively recently standardized and is not supported in\n          // some browsers (IE9, for one)\n          var el = document.createElement(\"div\");\n          el.innerHTML = html;\n          var frag = document.createDocumentFragment(),\n            node;\n          while (node = el.firstChild) {\n            var lastNode = frag.appendChild(node);\n          }\n          range.insertNode(frag);\n        }\n      }\n      // IE < 9\n      else if ((sel = document.selection) && sel.type != \"Control\") {\n        // FIXME: Does not work if selection is empty\n        sel.createRange().pasteHTML(html);\n      }\n    };\n\n    /**\r\n     * Customized graph for touch devices.\r\n     */\n    _Graph[\"default\"].prototype.initTouch = function () {\n      // Disables new connections via \"hotspot\"\n      this.connectionHandler.marker.isEnabled = function () {\n        return this.graph.connectionHandler.first != null;\n      };\n\n      // Hides menu when editing starts\n      this.addListener(_mxEvent[\"default\"].START_EDITING, function (sender, evt) {\n        this.popupMenuHandler.hideMenu();\n      });\n\n      // Adds custom hit detection if native hit detection found no cell\n      var graphUpdateMouseEvent = this.updateMouseEvent;\n      this.updateMouseEvent = function (me) {\n        me = graphUpdateMouseEvent.apply(this, arguments);\n        if (_mxEvent[\"default\"].isTouchEvent(me.getEvent()) && me.getState() == null) {\n          var cell = this.getCellAt(me.graphX, me.graphY);\n          if (cell != null && this.isSwimlane(cell) && this.hitsSwimlaneContent(cell, me.graphX, me.graphY)) {\n            cell = null;\n          } else {\n            me.state = this.view.getState(cell);\n            if (me.state != null && me.state.shape != null) {\n              this.container.style.cursor = me.state.shape.node.style.cursor;\n            }\n          }\n        }\n        if (me.getState() == null && this.isEnabled()) {\n          this.container.style.cursor = 'default';\n        }\n        return me;\n      };\n\n      // Context menu trigger implementation depending on current selection state\n      // combined with support for normal popup trigger.\n      var cellSelected = false;\n      var selectionEmpty = false;\n      var menuShowing = false;\n      var oldFireMouseEvent = this.fireMouseEvent;\n      this.fireMouseEvent = function (evtName, me, sender) {\n        if (evtName == _mxEvent[\"default\"].MOUSE_DOWN) {\n          // For hit detection on edges\n          me = this.updateMouseEvent(me);\n          cellSelected = this.isCellSelected(me.getCell());\n          selectionEmpty = this.isSelectionEmpty();\n          menuShowing = this.popupMenuHandler.isMenuShowing();\n        }\n        oldFireMouseEvent.apply(this, arguments);\n      };\n\n      // Shows popup menu if cell was selected or selection was empty and background was clicked\n      // FIXME: Conflicts with mxPopupMenuHandler.prototype.getCellForPopupEvent in Editor.js by\n      // selecting parent for selected children in groups before this check can be made.\n      this.popupMenuHandler.mouseUp = _mxGraphUtils[\"default\"].bind(this, function (sender, me) {\n        this.popupMenuHandler.popupTrigger = !this.isEditing() && this.isEnabled() && (me.getState() == null || !me.isSource(me.getState().control)) && (this.popupMenuHandler.popupTrigger || !menuShowing && !_mxEvent[\"default\"].isMouseEvent(me.getEvent()) && (selectionEmpty && me.getCell() == null && this.isSelectionEmpty() || cellSelected && this.isCellSelected(me.getCell())));\n        _mxPopupMenuHandler[\"default\"].prototype.mouseUp.apply(this.popupMenuHandler, arguments);\n      });\n    };\n\n    /**\r\n     * HTML in-place editor\r\n     */\n    _mxCellEditor[\"default\"].prototype.isContentEditing = function () {\n      var state = this.graph.view.getState(this.editingCell);\n      return state != null && state.style['html'] == 1;\n    };\n\n    /**\r\n     * Creates the keyboard event handler for the current graph and history.\r\n     */\n    _mxCellEditor[\"default\"].prototype.saveSelection = function () {\n      if (window.getSelection) {\n        var _sel = window.getSelection();\n        if (_sel.getRangeAt && _sel.rangeCount) {\n          var ranges = [];\n          for (var i = 0, len = _sel.rangeCount; i < len; ++i) {\n            ranges.push(_sel.getRangeAt(i));\n          }\n          return ranges;\n        }\n      } else if (document.selection && document.selection.createRange) {\n        return document.selection.createRange();\n      }\n      return null;\n    };\n\n    /**\r\n     * Creates the keyboard event handler for the current graph and history.\r\n     */\n    _mxCellEditor[\"default\"].prototype.restoreSelection = function (savedSel) {\n      if (savedSel) {\n        if (window.getSelection) {\n          sel = window.getSelection();\n          sel.removeAllRanges();\n          for (var i = 0, len = savedSel.length; i < len; ++i) {\n            sel.addRange(savedSel[i]);\n          }\n        } else if (document.selection && savedSel.select) {\n          savedSel.select();\n        }\n      }\n    };\n\n    /**\r\n     * Handling of special nl2Br style for not converting newlines to breaks in HTML labels.\r\n     * NOTE: Since it's easier to set this when the label is created we assume that it does\r\n     * not change during the lifetime of the mxText instance.\r\n     */\n    var mxCellRendererInitializeLabel = _mxCellRenderer[\"default\"].prototype.initializeLabel;\n    _mxCellRenderer[\"default\"].prototype.initializeLabel = function (state) {\n      if (state.text != null) {\n        state.text.replaceLinefeeds = _mxGraphUtils[\"default\"].getValue(state.style, 'nl2Br', '1') != '0';\n      }\n      mxCellRendererInitializeLabel.apply(this, arguments);\n    };\n    var mxConstraintHandlerUpdate = _mxConstraintHandler[\"default\"].prototype.update;\n    _mxConstraintHandler[\"default\"].prototype.update = function (me, source) {\n      if (this.isKeepFocusEvent(me) || !_mxEvent[\"default\"].isAltDown(me.getEvent())) {\n        mxConstraintHandlerUpdate.apply(this, arguments);\n      } else {\n        this.reset();\n      }\n    };\n\n    /**\r\n     * No dashed shapes.\r\n     */\n    _mxGuide[\"default\"].prototype.createGuideShape = function (horizontal) {\n      var guide = new _mxPolyline[\"default\"]([], _mxConstants[\"default\"].GUIDE_COLOR, _mxConstants[\"default\"].GUIDE_STROKEWIDTH);\n      return guide;\n    };\n\n    /**\r\n     * HTML in-place editor\r\n     */\n    _mxCellEditor[\"default\"].prototype.escapeCancelsEditing = false;\n    var mxCellEditorStartEditing = _mxCellEditor[\"default\"].prototype.startEditing;\n    _mxCellEditor[\"default\"].prototype.startEditing = function (cell, trigger) {\n      mxCellEditorStartEditing.apply(this, arguments);\n\n      // Overrides class in case of HTML content to add\n      // dashed borders for divs and table cells\n      var state = this.graph.view.getState(cell);\n      if (state != null && state.style['html'] == 1) {\n        this.textarea.className = 'mxCellEditor geContentEditable';\n      } else {\n        this.textarea.className = 'mxCellEditor mxPlainTextEditor';\n      }\n\n      // Toggles markup vs wysiwyg mode\n      this.codeViewMode = false;\n\n      // Stores current selection range when switching between markup and code\n      this.switchSelectionState = null;\n\n      // Selects editing cell\n      this.graph.setSelectionCell(cell);\n\n      // First run cannot set display before supercall because textarea is lazy created\n      // Lazy instantiates textarea to save memory in IE\n      if (this.textarea == null) {\n        this.init();\n      }\n\n      // Enables focus outline for edges and edge labels\n      var parent = this.graph.getModel().getParent(cell);\n      var geo = this.graph.getCellGeometry(cell);\n      if (this.graph.getModel().isEdge(parent) && geo != null && geo.relative || this.graph.getModel().isEdge(cell)) {\n        // Quirks does not support outline at all so use border instead\n        if (_mxClient[\"default\"].IS_QUIRKS) {\n          this.textarea.style.border = 'gray dotted 1px';\n        }\n        // IE>8 and FF on Windows uses outline default of none\n        else if (_mxClient[\"default\"].IS_IE || _mxClient[\"default\"].IS_IE11 || _mxClient[\"default\"].IS_FF && _mxClient[\"default\"].IS_WIN) {\n          this.textarea.style.outline = 'gray dotted 1px';\n        } else {\n          this.textarea.style.outline = '';\n        }\n      } else if (_mxClient[\"default\"].IS_QUIRKS) {\n        this.textarea.style.outline = 'none';\n        this.textarea.style.border = '';\n      }\n    };\n\n    /**\r\n     * HTML in-place editor\r\n     */\n    var cellEditorInstallListeners = _mxCellEditor[\"default\"].prototype.installListeners;\n    _mxCellEditor[\"default\"].prototype.installListeners = function (elt) {\n      cellEditorInstallListeners.apply(this, arguments);\n\n      // Adds a reference from the clone to the original node, recursively\n      function reference(node, clone) {\n        clone.originalNode = node;\n        node = node.firstChild;\n        var child = clone.firstChild;\n        while (node != null && child != null) {\n          reference(node, child);\n          node = node.nextSibling;\n          child = child.nextSibling;\n        }\n        return clone;\n      }\n      ;\n\n      // Checks the given node for new nodes, recursively\n      function checkNode(node, clone) {\n        if (clone.originalNode != node) {\n          cleanNode(node);\n        } else {\n          node = node.firstChild;\n          clone = clone.firstChild;\n          while (node != null) {\n            var nextNode = node.nextSibling;\n            if (clone == null) {\n              cleanNode(node);\n            } else {\n              checkNode(node, clone);\n              clone = clone.nextSibling;\n            }\n            node = nextNode;\n          }\n        }\n      }\n      ;\n\n      // Removes unused DOM nodes and attributes, recursively\n      function cleanNode(node) {\n        var child = node.firstChild;\n        while (child != null) {\n          var next = child.nextSibling;\n          cleanNode(child);\n          child = next;\n        }\n        if ((node.nodeType != 1 || node.nodeName !== 'BR' && node.firstChild == null) && (node.nodeType != 3 || _mxGraphUtils[\"default\"].trim(_mxUtils[\"default\"].getTextContent(node)).length == 0)) {\n          node.parentNode.removeChild(node);\n        } else {\n          // Removes linefeeds\n          if (node.nodeType == 3) {\n            _mxUtils[\"default\"].setTextContent(node, _mxUtils[\"default\"].getTextContent(node).replace(/\\n|\\r/g, ''));\n          }\n\n          // Removes CSS classes and styles (for Word and Excel)\n          if (node.nodeType == 1) {\n            node.removeAttribute('style');\n            node.removeAttribute('class');\n            node.removeAttribute('width');\n            node.removeAttribute('cellpadding');\n            node.removeAttribute('cellspacing');\n            node.removeAttribute('border');\n          }\n        }\n      }\n      ;\n\n      // Handles paste from Word, Excel etc by removing styles, classnames and unused nodes\n      // LATER: Fix undo/redo for paste\n      if (!_mxClient[\"default\"].IS_QUIRKS && document.documentMode !== 7 && document.documentMode !== 8) {\n        _mxEvent[\"default\"].addListener(this.textarea, 'paste', _mxGraphUtils[\"default\"].bind(this, function (evt) {\n          var clone = reference(this.textarea, this.textarea.cloneNode(true));\n          window.setTimeout(_mxGraphUtils[\"default\"].bind(this, function () {\n            checkNode(this.textarea, clone);\n          }), 0);\n        }));\n      }\n    };\n    _mxCellEditor[\"default\"].prototype.toggleViewMode = function () {\n      var state = this.graph.view.getState(this.editingCell) || {};\n      var nl2Br = _mxGraphUtils[\"default\"].getValue(state.style, 'nl2Br', '1') != '0';\n      var tmp = this.saveSelection();\n      if (!this.codeViewMode) {\n        // Clears the initial empty label on the first keystroke\n        if (this.clearOnChange && this.textarea.innerHTML == this.getEmptyLabelText()) {\n          this.clearOnChange = false;\n          this.textarea.innerHTML = '';\n        }\n\n        // Removes newlines from HTML and converts breaks to newlines\n        // to match the HTML output in plain text\n        var content = _mxGraphUtils[\"default\"].htmlEntities(this.textarea.innerHTML);\n\n        // Workaround for trailing line breaks being ignored in the editor\n        if (!_mxClient[\"default\"].IS_QUIRKS && document.documentMode != 8) {\n          content = _mxGraphUtils[\"default\"].replaceTrailingNewlines(content, '<div><br></div>');\n        }\n        content = this.graph.sanitizeHtml(nl2Br ? content.replace(/\\n/g, '').replace(/&lt;br\\s*.?&gt;/g, '<br>') : content);\n        this.textarea.className = 'mxCellEditor mxPlainTextEditor';\n        var size = _mxConstants[\"default\"].DEFAULT_FONTSIZE;\n        this.textarea.style.lineHeight = _mxConstants[\"default\"].ABSOLUTE_LINE_HEIGHT ? Math.round(size * _mxConstants[\"default\"].LINE_HEIGHT) + 'px' : _mxConstants[\"default\"].LINE_HEIGHT;\n        this.textarea.style.fontSize = Math.round(size) + 'px';\n        this.textarea.style.textDecoration = '';\n        this.textarea.style.fontWeight = 'normal';\n        this.textarea.style.fontStyle = '';\n        this.textarea.style.fontFamily = _mxConstants[\"default\"].DEFAULT_FONTFAMILY;\n        this.textarea.style.textAlign = 'left';\n\n        // Adds padding to make cursor visible with borders\n        this.textarea.style.padding = '2px';\n        if (this.textarea.innerHTML != content) {\n          this.textarea.innerHTML = content;\n        }\n        this.codeViewMode = true;\n      } else {\n        var content = _mxUtils[\"default\"].extractTextWithWhitespace(this.textarea.childNodes);\n\n        // Strips trailing line break\n        if (content.length > 0 && content.charAt(content.length - 1) == '\\n') {\n          content = content.substring(0, content.length - 1);\n        }\n        content = this.graph.sanitizeHtml(nl2Br ? content.replace(/\\n/g, '<br/>') : content);\n        this.textarea.className = 'mxCellEditor geContentEditable';\n        var size = _mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_FONTSIZE, _mxConstants[\"default\"].DEFAULT_FONTSIZE);\n        var family = _mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_FONTFAMILY, _mxConstants[\"default\"].DEFAULT_FONTFAMILY);\n        var align = _mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_ALIGN, _mxConstants[\"default\"].ALIGN_LEFT);\n        var bold = (_mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_FONTSTYLE, 0) & _mxConstants[\"default\"].FONT_BOLD) == _mxConstants[\"default\"].FONT_BOLD;\n        var italic = (_mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_FONTSTYLE, 0) & _mxConstants[\"default\"].FONT_ITALIC) == _mxConstants[\"default\"].FONT_ITALIC;\n        var uline = (_mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_FONTSTYLE, 0) & _mxConstants[\"default\"].FONT_UNDERLINE) == _mxConstants[\"default\"].FONT_UNDERLINE;\n        this.textarea.style.lineHeight = _mxConstants[\"default\"].ABSOLUTE_LINE_HEIGHT ? Math.round(size * _mxConstants[\"default\"].LINE_HEIGHT) + 'px' : _mxConstants[\"default\"].LINE_HEIGHT;\n        this.textarea.style.fontSize = Math.round(size) + 'px';\n        this.textarea.style.textDecoration = uline ? 'underline' : '';\n        this.textarea.style.fontWeight = bold ? 'bold' : 'normal';\n        this.textarea.style.fontStyle = italic ? 'italic' : '';\n        this.textarea.style.fontFamily = family;\n        this.textarea.style.textAlign = align;\n        this.textarea.style.padding = '0px';\n        if (this.textarea.innerHTML != content) {\n          this.textarea.innerHTML = content;\n          if (this.textarea.innerHTML.length == 0) {\n            this.textarea.innerHTML = this.getEmptyLabelText();\n            this.clearOnChange = this.textarea.innerHTML.length > 0;\n          }\n        }\n        this.codeViewMode = false;\n      }\n      this.textarea.focus();\n      if (this.switchSelectionState != null) {\n        this.restoreSelection(this.switchSelectionState);\n      }\n      this.switchSelectionState = tmp;\n      this.resize();\n    };\n    var mxCellEditorResize = _mxCellEditor[\"default\"].prototype.resize;\n    _mxCellEditor[\"default\"].prototype.resize = function (state, trigger) {\n      var state = this.graph.getView().getState(this.editingCell);\n      if (this.codeViewMode && state != null) {\n        var scale = state.view.scale;\n        this.bounds = _mxRectangle[\"default\"].fromRectangle(state);\n\n        // General placement of code editor if cell has no size\n        // LATER: Fix HTML editor bounds for edge labels\n        if (this.bounds.width == 0 && this.bounds.height == 0) {\n          this.bounds.width = 160 * scale;\n          this.bounds.height = 60 * scale;\n          var m = state.text != null ? state.text.margin : null;\n          if (m == null) {\n            m = _mxGraphUtils[\"default\"].getAlignmentAsPoint(_mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_ALIGN, _mxConstants[\"default\"].ALIGN_CENTER), _mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_VERTICAL_ALIGN, _mxConstants[\"default\"].ALIGN_MIDDLE), _mxPoint[\"default\"]);\n          }\n          this.bounds.x += m.x * this.bounds.width;\n          this.bounds.y += m.y * this.bounds.height;\n        }\n        this.textarea.style.width = Math.round((this.bounds.width - 4) / scale) + 'px';\n        this.textarea.style.height = Math.round((this.bounds.height - 4) / scale) + 'px';\n        this.textarea.style.overflow = 'auto';\n\n        // Adds scrollbar offset if visible\n        if (this.textarea.clientHeight < this.textarea.offsetHeight) {\n          this.textarea.style.height = Math.round(this.bounds.height / scale) + (this.textarea.offsetHeight - this.textarea.clientHeight) + 'px';\n          this.bounds.height = parseInt(this.textarea.style.height) * scale;\n        }\n        if (this.textarea.clientWidth < this.textarea.offsetWidth) {\n          this.textarea.style.width = Math.round(this.bounds.width / scale) + (this.textarea.offsetWidth - this.textarea.clientWidth) + 'px';\n          this.bounds.width = parseInt(this.textarea.style.width) * scale;\n        }\n        this.textarea.style.left = Math.round(this.bounds.x) + 'px';\n        this.textarea.style.top = Math.round(this.bounds.y) + 'px';\n        if (_mxClient[\"default\"].IS_VML) {\n          this.textarea.style.zoom = scale;\n        } else {\n          _mxGraphUtils[\"default\"].setPrefixedStyle(this.textarea.style, 'transform', 'scale(' + scale + ',' + scale + ')');\n        }\n      } else {\n        this.textarea.style.height = '';\n        this.textarea.style.overflow = '';\n        mxCellEditorResize.apply(this, arguments);\n      }\n    };\n    var mxCellEditorGetInitialValue = _mxCellEditor[\"default\"].prototype.getInitialValue;\n    _mxCellEditor[\"default\"].prototype.getInitialValue = function (state, trigger) {\n      if (_mxGraphUtils[\"default\"].getValue(state.style, 'html', '0') == '0') {\n        return mxCellEditorGetInitialValue.apply(this, arguments);\n      } else {\n        var result = this.graph.getEditingValue(state.cell, trigger);\n        if (_mxGraphUtils[\"default\"].getValue(state.style, 'nl2Br', '1') == '1') {\n          result = result.replace(/\\n/g, '<br/>');\n        }\n        result = this.graph.sanitizeHtml(result);\n        return result;\n      }\n    };\n    var mxCellEditorGetCurrentValue = _mxCellEditor[\"default\"].prototype.getCurrentValue;\n    _mxCellEditor[\"default\"].prototype.getCurrentValue = function (state) {\n      if (_mxGraphUtils[\"default\"].getValue(state.style, 'html', '0') == '0') {\n        return mxCellEditorGetCurrentValue.apply(this, arguments);\n      } else {\n        var result = this.graph.sanitizeHtml(this.textarea.innerHTML);\n        if (_mxGraphUtils[\"default\"].getValue(state.style, 'nl2Br', '1') == '1') {\n          result = result.replace(/\\r\\n/g, '<br/>').replace(/\\n/g, '<br/>');\n        } else {\n          result = result.replace(/\\r\\n/g, '').replace(/\\n/g, '');\n        }\n        return result;\n      }\n    };\n    var mxCellEditorStopEditing = _mxCellEditor[\"default\"].prototype.stopEditing;\n    _mxCellEditor[\"default\"].prototype.stopEditing = function (cancel) {\n      // Restores default view mode before applying value\n      if (this.codeViewMode) {\n        this.toggleViewMode();\n      }\n      mxCellEditorStopEditing.apply(this, arguments);\n\n      // Tries to move focus back to container after editing if possible\n      try {\n        this.graph.container.focus();\n      } catch (e) {\n        // ignore\n      }\n    };\n    var mxCellEditorApplyValue = _mxCellEditor[\"default\"].prototype.applyValue;\n    _mxCellEditor[\"default\"].prototype.applyValue = function (state, value) {\n      // Removes empty relative child labels in edges\n      this.graph.getModel().beginUpdate();\n      try {\n        mxCellEditorApplyValue.apply(this, arguments);\n        if (this.graph.isCellDeletable(state.cell)) {\n          var stroke = _mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_STROKECOLOR, _mxConstants[\"default\"].NONE);\n          var fill = _mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_FILLCOLOR, _mxConstants[\"default\"].NONE);\n          if (_mxGraphUtils[\"default\"].trim(value || '') == '' && stroke == _mxConstants[\"default\"].NONE && fill == _mxConstants[\"default\"].NONE) {\n            this.graph.removeCells([state.cell], false);\n          }\n        }\n      } finally {\n        this.graph.getModel().endUpdate();\n      }\n    };\n\n    /**\r\n     * Returns the background color to be used for the editing box. This returns\r\n     * the label background for edge labels and null for all other cases.\r\n     */\n    _mxCellEditor[\"default\"].prototype.getBackgroundColor = function (state) {\n      var color = null;\n      if (this.graph.getModel().isEdge(state.cell) || this.graph.getModel().isEdge(this.graph.getModel().getParent(state.cell))) {\n        var color = _mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_LABEL_BACKGROUNDCOLOR, null);\n        if (color == _mxConstants[\"default\"].NONE) {\n          color = null;\n        }\n      }\n      return color;\n    };\n    _mxCellEditor[\"default\"].prototype.getMinimumSize = function (state) {\n      var scale = this.graph.getView().scale;\n      return new _mxRectangle[\"default\"](0, 0, state.text == null ? 30 : state.text.size * scale + 20, 30);\n    };\n\n    /**\r\n     * Hints on handlers\r\n     */\n    function createHint() {\n      var hint = document.createElement('div');\n      hint.className = 'geHint';\n      hint.style.whiteSpace = 'nowrap';\n      hint.style.position = 'absolute';\n      return hint;\n    }\n    ;\n\n    /**\r\n     * Updates the hint for the current operation.\r\n     */\n    _mxGraphHandler[\"default\"].prototype.updateHint = function (me) {\n      if (this.shape != null) {\n        if (this.hint == null) {\n          this.hint = createHint();\n          this.graph.container.appendChild(this.hint);\n        }\n        var t = this.graph.view.translate;\n        var s = this.graph.view.scale;\n        var x = this.roundLength((this.bounds.x + this.currentDx) / s - t.x);\n        var y = this.roundLength((this.bounds.y + this.currentDy) / s - t.y);\n        this.hint.innerHTML = x + ', ' + y;\n        this.hint.style.left = this.shape.bounds.x + Math.round((this.shape.bounds.width - this.hint.clientWidth) / 2) + 'px';\n        this.hint.style.top = this.shape.bounds.y + this.shape.bounds.height + 12 + 'px';\n      }\n    };\n\n    /**\r\n     * Updates the hint for the current operation.\r\n     */\n    _mxGraphHandler[\"default\"].prototype.removeHint = function () {\n      if (this.hint != null) {\n        this.hint.parentNode.removeChild(this.hint);\n        this.hint = null;\n      }\n    };\n\n    /**\r\n     * Enables recursive resize for groups.\r\n     */\n    _mxVertexHandler[\"default\"].prototype.isRecursiveResize = function (state, me) {\n      return !this.graph.isSwimlane(state.cell) && this.graph.model.getChildCount(state.cell) > 0 && !_mxEvent[\"default\"].isControlDown(me.getEvent()) && !this.graph.isCellCollapsed(state.cell) && _mxGraphUtils[\"default\"].getValue(state.style, 'recursiveResize', '1') == '1' && _mxGraphUtils[\"default\"].getValue(state.style, 'childLayout', null) == null;\n    };\n\n    /**\r\n     * Enables centered resize events.\r\n     */\n    _mxVertexHandler[\"default\"].prototype.isCenteredEvent = function (state, me) {\n      return !(!this.graph.isSwimlane(state.cell) && this.graph.model.getChildCount(state.cell) > 0 && !this.graph.isCellCollapsed(state.cell) && _mxGraphUtils[\"default\"].getValue(state.style, 'recursiveResize', '1') == '1' && _mxGraphUtils[\"default\"].getValue(state.style, 'childLayout', null) == null) && _mxEvent[\"default\"].isControlDown(me.getEvent()) || _mxEvent[\"default\"].isMetaDown(me.getEvent());\n    };\n    var vertexHandlerGetHandlePadding = _mxVertexHandler[\"default\"].prototype.getHandlePadding;\n    _mxVertexHandler[\"default\"].prototype.getHandlePadding = function () {\n      var result = new _mxPoint[\"default\"](0, 0);\n      var tol = this.tolerance;\n      if (this.graph.cellEditor.getEditingCell() == this.state.cell && this.sizers != null && this.sizers.length > 0 && this.sizers[0] != null) {\n        tol /= 2;\n        result.x = this.sizers[0].bounds.width + tol;\n        result.y = this.sizers[0].bounds.height + tol;\n      } else {\n        result = vertexHandlerGetHandlePadding.apply(this, arguments);\n      }\n      return result;\n    };\n\n    /**\r\n     * Updates the hint for the current operation.\r\n     */\n    _mxVertexHandler[\"default\"].prototype.updateHint = function (me) {\n      if (this.index != _mxEvent[\"default\"].LABEL_HANDLE) {\n        if (this.hint == null) {\n          this.hint = createHint();\n          this.state.view.graph.container.appendChild(this.hint);\n        }\n        if (this.index == _mxEvent[\"default\"].ROTATION_HANDLE) {\n          this.hint.innerHTML = this.currentAlpha + '&deg;';\n        } else {\n          var s = this.state.view.scale;\n          this.hint.innerHTML = this.roundLength(this.bounds.width / s) + ' x ' + this.roundLength(this.bounds.height / s);\n        }\n        var rot = this.currentAlpha != null ? this.currentAlpha : this.state.style[_mxConstants[\"default\"].STYLE_ROTATION] || '0';\n        var bb = _mxGraphUtils[\"default\"].getBoundingBox(this.bounds, rot, null, _mxRectangle[\"default\"], _mxPoint[\"default\"]);\n        if (bb == null) {\n          bb = this.bounds;\n        }\n        this.hint.style.left = bb.x + Math.round((bb.width - this.hint.clientWidth) / 2) + 'px';\n        this.hint.style.top = bb.y + bb.height + 12 + 'px';\n      }\n    };\n\n    /**\r\n     * Updates the hint for the current operation.\r\n     */\n    _mxVertexHandler[\"default\"].prototype.removeHint = _mxGraphHandler[\"default\"].prototype.removeHint;\n\n    /**\r\n     * Updates the hint for the current operation.\r\n     */\n    _mxEdgeHandler[\"default\"].prototype.updateHint = function (me, point) {\n      if (this.hint == null) {\n        this.hint = createHint();\n        this.state.view.graph.container.appendChild(this.hint);\n      }\n      var t = this.graph.view.translate;\n      var s = this.graph.view.scale;\n      var x = this.roundLength(point.x / s - t.x);\n      var y = this.roundLength(point.y / s - t.y);\n      this.hint.innerHTML = x + ', ' + y;\n      this.hint.style.visibility = 'visible';\n      if (this.isSource || this.isTarget) {\n        if (this.constraintHandler.currentConstraint != null && this.constraintHandler.currentFocus != null) {\n          var pt = this.constraintHandler.currentConstraint.point;\n          this.hint.innerHTML = '[' + Math.round(pt.x * 100) + '%, ' + Math.round(pt.y * 100) + '%]';\n        } else if (this.marker.hasValidState()) {\n          this.hint.style.visibility = 'hidden';\n        }\n      }\n      this.hint.style.left = Math.round(me.getGraphX() - this.hint.clientWidth / 2) + 'px';\n      this.hint.style.top = Math.max(me.getGraphY(), point.y) + this.state.view.graph.gridSize + 'px';\n      if (this.hideEdgeHintThread != null) {\n        window.clearTimeout(this.hideEdgeHintThread);\n      }\n      this.hideEdgeHintThread = window.setTimeout(_mxGraphUtils[\"default\"].bind(this, function () {\n        if (this.hint != null) {\n          this.hint.style.visibility = 'hidden';\n        }\n      }), 500);\n    };\n\n    /**\r\n     * Updates the hint for the current operation.\r\n     */\n    _mxEdgeHandler[\"default\"].prototype.removeHint = _mxGraphHandler[\"default\"].prototype.removeHint;\n\n    /**\r\n     * Defines the handles for the UI. Uses data-URIs to speed-up loading time where supported.\r\n     */\n    var mainHandle = new _mxImage[\"default\"](_mxClient[\"default\"].IS_SVG ? 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAARCAYAAAA7bUf6AAAACXBIWXMAAAsTAAALEwEAmpwYAAABLUlEQVQ4y61US4rCQBBNeojiRrLSnbMOWWU3V1FPouARcgc9hyLOCSSbYZw5gRCIkM9KbevJaycS4zCOBY+iq6pf1y+xrNtiE6oEY/tVzMUXgSNoCJrUDu3qHpldutwSuIKOoEvt0m7I7DoCvNj2fb8XRdEojuN5lmVraJxhh59xFSLFF9phGL7lef6hRb63R73aHM8aAjv8JHJ47yqLlud5r0VRbHa51sPZQVuT/QU4ww4/4ljaJRubrC5SxouD6TWBQV/sEIkbs0eOIVGssSO1L5D6LQID+BHHZjdMSYpj7KZpun7/uk8CP5rNqTXLJP/OpNyTMWruP9CTP08nCILKdCp7gkCzJ8vPnz2BvW5PKhuLjJBykiQLaWIEjTP3o3Zjn/LtPO0rfvh/cgKu7z6wtPPltQAAAABJRU5ErkJggg==' : IMAGE_PATH + '/handle-main.png', 17, 17);\n    var fixedHandle = new _mxImage[\"default\"](_mxClient[\"default\"].IS_SVG ? 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAARCAYAAAA7bUf6AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NkE1NkU4Njk2QjI1MTFFNEFDMjFGQTcyODkzNTc3NkYiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NkE1NkU4NkE2QjI1MTFFNEFDMjFGQTcyODkzNTc3NkYiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo2QTU2RTg2NzZCMjUxMUU0QUMyMUZBNzI4OTM1Nzc2RiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo2QTU2RTg2ODZCMjUxMUU0QUMyMUZBNzI4OTM1Nzc2RiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pmuk6K8AAAGBSURBVHjarFRBSsNQEM3/atNs6qLowixcKELoqjuXoqfQeoF6BMEj9BCC1YIXcCGlV8hGLNZlBKWlCk1JSs13Xvw/nca6UDrwmMzMy8tk/iTCWmwi52Eq53+QeWwg2bXSSNi1WiRibgRWCTahwEQmhJgw1WJGML2BC6wQnEqlsuH7fr3f7zdHo9EdPGLkUdc8mX8TJNYIpUajsR+G4YMie3pNVKebpB6GPOrgab7kr5F24Hne9ng87r6HStUuP5V1Mc2AGHnUwWMdCck6sVut1onjOHtnt4nV7M0fAuI65VEnXk3PTFq5Eyi4rnvUe1PW9fO3QOdUzvkbyqNOvEM2dMEHK2zbLr98zJ5+cJWkAvDGUC8Wi2X28Gww6bnHcTzYWp+JGAHTCQz1KIoGfFckCyZBELR3N4V1vCOyTrhHHnXw9N5kQn8+nWq1Onc6C/cERLMn7cfZniD/257wbjDxEjqiDT0fDof3tLE+PGK9HyXNy7pYyrez9K/43/+TLwEGAMb7AY6w980DAAAAAElFTkSuQmCC' : IMAGE_PATH + '/handle-fixed.png', 17, 17);\n    var terminalHandle = new _mxImage[\"default\"](_mxClient[\"default\"].IS_SVG ? 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAARCAYAAAA7bUf6AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MEMzRUVERTk2NzU1MTFFNTg5NjNEMjREQ0FFNENFQzgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MEMzRUVERUE2NzU1MTFFNTg5NjNEMjREQ0FFNENFQzgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDowQzNFRURFNzY3NTUxMUU1ODk2M0QyNERDQUU0Q0VDOCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDowQzNFRURFODY3NTUxMUU1ODk2M0QyNERDQUU0Q0VDOCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Poj8AGUAAAF6SURBVHjarFTBSsNAEM2u2jSXeCh6sAcPilB6ys2j6Fdo/YH6CYKf0I8QrBb8AQ9S+gu5iMV6jKC0VCEJTalZ54VNnMR4ULrwmJ2Zt5PZmdkIo3yJgsRSBfmDzPUUku2VRsz2qixIehBYJZiECgsyJ0SEhQ6WBkwO8AArBKvZbG64rtsej8dd3/fvIKHDDr/myeJNYFgj2J1OZz8IggdF6+k1VoNhnEgs2OEHT/Mlv0aSQaPR2A7DcPgeKNW6/FTGxSIDdNjhB49lJCTLxOz1eieWZe2d3cZGd5RvAvQ22eEnXkvXTBqFDlTq9frR6E0Z18+qtO83ZIefeIes6IIXVpimWXv5yB8cnMqcDn+1Wq2xj2eFSfoeRdFkaz0f5OAqzunwz2azCZ8VyZS553n93U1hHO+I0uvADj94em6yQH/ujuM4ue6UzgmI6Zz0H7/nBPbf5oRng4rbyIgm9Hw6nd7TxLqQ0PV82JqXZbGUt7P0V/zv/8mXAAMASSz1f9Cd7ycAAAAASUVORK5CYII=' : IMAGE_PATH + '/handle-terminal.png', 17, 17);\n    var secondaryHandle = new _mxImage[\"default\"](_mxClient[\"default\"].IS_SVG ? 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAARCAYAAAA7bUf6AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MEJBMUVERjNEMkZDMTFFM0I0Qzc5RkE1RTc2NjI0OUIiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MEJBMUVERjREMkZDMTFFM0I0Qzc5RkE1RTc2NjI0OUIiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDowQkExRURGMUQyRkMxMUUzQjRDNzlGQTVFNzY2MjQ5QiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDowQkExRURGMkQyRkMxMUUzQjRDNzlGQTVFNzY2MjQ5QiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PvXDOj4AAAFqSURBVHjarFTNToNAEN5FLeiBmDRe7MGLF4IXbp71KapP4CPoO/QdvKiv4ME0PkAvJI2J0SueIHgAAk3b7XxkwSlgE38mmSwz8+3HsPMtUnSbbKww1VhbYB5XbrBnpX3JnlUXSbURvk1ukvcYyYy8IJ9rsoqw3MAJtsh3Xdc98H3/KgzDuyRJHrEiRh51jTOaX4LEDrk9Go1O0zR9UWTL9E0to+dyhSGPOnAab/DPKDtwHOcoy7LXz1SpxeRSzW9F7YiRRx041pGsSMC6Ty1f442LycUawRfRsOyIcDfA632ST6A3GAzOVfYu1PS+c+5q+iBQJ9wZO3TJD1aaptkX+YfYaFS3LKvPXl4fTDn3oigiYR1uJqF6nucR14rBglkQBGO5dyzkybBbxpRHHTitm5rox9PxPK81nZZOAKx1Eo5rnSD/nU54NzhxGx1hjHEcP5FifayItT5sjVvTyJ/vzr/f4l//T1YCDAC4VAdLL1OIRAAAAABJRU5ErkJggg==' : IMAGE_PATH + '/handle-secondary.png', 17, 17);\n    var rotationHandle = new _mxImage[\"default\"](_mxClient[\"default\"].IS_SVG ? 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABMAAAAVCAYAAACkCdXRAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAA6ZJREFUeNqM001IY1cUB/D/fYmm2sbR2lC1zYlgoRG6MpEyBlpxM9iFIGKFIm3s0lCKjOByhCLZCFqLBF1YFVJdSRbdFHRhBbULtRuFVBTzYRpJgo2mY5OX5N9Fo2TG+eiFA/dd3vvd8+65ByTxshARTdf1JySp6/oTEdFe9T5eg5lIcnBwkCSZyWS+exX40oyur68/KxaLf5Okw+H4X+A9JBaLfUySZ2dnnJqaosPhIAACeC34DJRKpb7IZrMcHx+nwWCgUopGo/EOKwf9fn/1CzERUevr6+9ls1mOjIwQAH0+H4PBIKPR6D2ofAQCgToRUeVYJUkuLy8TANfW1kiS8/PzCy84Mw4MDBAAZ2dnmc/nub+/X0MSEBF1cHDwMJVKsaGhgV6vl+l0mqOjo1+KyKfl1dze3l4NBoM/PZ+diFSLiIKIGBOJxA9bW1sEwNXVVSaTyQMRaRaRxrOzs+9J8ujoaE5EPhQRq67rcZ/PRwD0+/3Udf03EdEgIqZisZibnJykwWDg4eEhd3Z2xkXELCJvPpdBrYjUiEhL+Xo4HH4sIhUaAKNSqiIcDsNkMqG+vh6RSOQQQM7tdhsAQCkFAHC73UUATxcWFqypVApmsxnDw8OwWq2TADQNgAYAFosF+XweyWQSdru9BUBxcXFRB/4rEgDcPouIIx6P4+bmBi0tLSCpAzBqAIqnp6c/dnZ2IpfLYXNzE62traMADACKNputpr+/v8lms9UAKAAwiMjXe3t7KBQKqKurQy6Xi6K0i2l6evpROp1mbW0t29vbGY/Hb8/IVIqq2zlJXl1dsaOjg2azmefn5wwEAl+JSBVExCgi75PkzMwMlVJsbGxkIpFgPp8PX15ePopEIs3JZPITXdf/iEajbGpqolKKExMT1HWdHo/nIxGpgIgoEXnQ3d39kCTHxsYIgC6Xi3NzcwyHw8xkMozFYlxaWmJbWxuVUuzt7WUul6PX6/1cRN4WEe2uA0SkaWVl5XGpRVhdXU0A1DSNlZWVdz3qdDrZ09PDWCzG4+Pjn0XEWvp9KJKw2WwKwBsA3gHQHAqFfr24uMDGxgZ2d3cRiUQAAHa7HU6nE319fTg5Ofmlq6vrGwB/AngaCoWK6rbsNptNA1AJoA7Aux6Pp3NoaMhjsVg+QNmIRqO/u1yubwFEASRKUAEA7rASqABUAKgC8KAUb5XWCOAfAFcA/gJwDSB7C93DylCtdM8qABhLc5TumV6KQigUeubjfwcAHkQJ94ndWeYAAAAASUVORK5CYII=' : IMAGE_PATH + '/handle-rotate.png', 19, 21);\n    _mxVertexHandler[\"default\"].prototype.handleImage = mainHandle;\n    _mxVertexHandler[\"default\"].prototype.secondaryHandleImage = secondaryHandle;\n    _mxEdgeHandler[\"default\"].prototype.handleImage = mainHandle;\n    _mxEdgeHandler[\"default\"].prototype.terminalHandleImage = terminalHandle;\n    _mxEdgeHandler[\"default\"].prototype.fixedHandleImage = fixedHandle;\n    _mxEdgeHandler[\"default\"].prototype.labelHandleImage = secondaryHandle;\n    _mxOutline[\"default\"].prototype.sizerImage = mainHandle;\n\n    // Pre-fetches images (only needed for non data-uris)\n    if (!_mxClient[\"default\"].IS_SVG) {\n      new Image().src = mainHandle.src;\n      new Image().src = fixedHandle.src;\n      new Image().src = terminalHandle.src;\n      new Image().src = secondaryHandle.src;\n      new Image().src = rotationHandle.src;\n      new Image().src = HoverIcons.prototype.triangleUp.src;\n      new Image().src = HoverIcons.prototype.triangleRight.src;\n      new Image().src = HoverIcons.prototype.triangleDown.src;\n      new Image().src = HoverIcons.prototype.triangleLeft.src;\n      new Image().src = HoverIcons.prototype.refreshTarget.src;\n      new Image().src = HoverIcons.prototype.roundDrop.src;\n    }\n\n    // Adds rotation handle and live preview\n    _mxVertexHandler[\"default\"].prototype.rotationEnabled = true;\n    _mxVertexHandler[\"default\"].prototype.manageSizers = true;\n    _mxVertexHandler[\"default\"].prototype.livePreview = true;\n\n    // Increases default rubberband opacity (default is 20)\n    _mxRubberband[\"default\"].prototype.defaultOpacity = 30;\n\n    // Enables connections along the outline, virtual waypoints, parent highlight etc\n    _mxConnectionHandler[\"default\"].prototype.outlineConnect = true;\n    _mxCellHighlight[\"default\"].prototype.keepOnTop = true;\n    _mxVertexHandler[\"default\"].prototype.parentHighlightEnabled = false;\n    _mxVertexHandler[\"default\"].prototype.rotationHandleVSpacing = -20;\n    _mxEdgeHandler[\"default\"].prototype.parentHighlightEnabled = true;\n    _mxEdgeHandler[\"default\"].prototype.dblClickRemoveEnabled = true;\n    _mxEdgeHandler[\"default\"].prototype.straightRemoveEnabled = true;\n    _mxEdgeHandler[\"default\"].prototype.virtualBendsEnabled = true;\n    _mxEdgeHandler[\"default\"].prototype.mergeRemoveEnabled = true;\n    _mxEdgeHandler[\"default\"].prototype.manageLabelHandle = true;\n    _mxEdgeHandler[\"default\"].prototype.outlineConnect = true;\n\n    // Disables adding waypoints if shift is pressed\n    _mxEdgeHandler[\"default\"].prototype.isAddVirtualBendEvent = function (me) {\n      return !_mxEvent[\"default\"].isShiftDown(me.getEvent());\n    };\n\n    // Disables custom handles if shift is pressed\n    _mxEdgeHandler[\"default\"].prototype.isCustomHandleEvent = function (me) {\n      return !_mxEvent[\"default\"].isShiftDown(me.getEvent());\n    };\n\n    /**\r\n     * Implements touch style\r\n     */\n    if (_Graph[\"default\"].touchStyle) {\n      // Larger tolerance for real touch devices\n      if (_mxClient[\"default\"].IS_TOUCH || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0) {\n        _mxShape[\"default\"].prototype.svgStrokeTolerance = 18;\n        _mxVertexHandler[\"default\"].prototype.tolerance = 12;\n        _mxEdgeHandler[\"default\"].prototype.tolerance = 12;\n        _Graph[\"default\"].prototype.tolerance = 12;\n        _mxVertexHandler[\"default\"].prototype.rotationHandleVSpacing = -24;\n\n        // Implements a smaller tolerance for mouse events and a larger tolerance for touch\n        // events on touch devices. The default tolerance (4px) is used for mouse events.\n        _mxConstraintHandler[\"default\"].prototype.getTolerance = function (me) {\n          return _mxEvent[\"default\"].isMouseEvent(me.getEvent()) ? 4 : this.graph.getTolerance();\n        };\n      }\n\n      // One finger pans (no rubberband selection) must start regardless of mouse button\n      _mxPanningHandler[\"default\"].prototype.isPanningTrigger = function (me) {\n        var evt = me.getEvent();\n        return me.getState() == null && !_mxEvent[\"default\"].isMouseEvent(evt) || _mxEvent[\"default\"].isPopupTrigger(evt) && (me.getState() == null || _mxEvent[\"default\"].isControlDown(evt) || _mxEvent[\"default\"].isShiftDown(evt));\n      };\n\n      // Don't clear selection if multiple cells selected\n      var graphHandlerMouseDown = _mxGraphHandler[\"default\"].prototype.mouseDown;\n      _mxGraphHandler[\"default\"].prototype.mouseDown = function (sender, me) {\n        graphHandlerMouseDown.apply(this, arguments);\n        if (_mxEvent[\"default\"].isTouchEvent(me.getEvent()) && this.graph.isCellSelected(me.getCell()) && this.graph.getSelectionCount() > 1) {\n          this.delayedSelection = false;\n        }\n      };\n    } else {\n      // Removes ctrl+shift as panning trigger for space splitting\n      _mxPanningHandler[\"default\"].prototype.isPanningTrigger = function (me) {\n        var evt = me.getEvent();\n        return _mxEvent[\"default\"].isLeftMouseButton(evt) && (this.useLeftButtonForPanning && me.getState() == null || _mxEvent[\"default\"].isControlDown(evt) && !_mxEvent[\"default\"].isShiftDown(evt)) || this.usePopupTrigger && _mxEvent[\"default\"].isPopupTrigger(evt);\n      };\n    }\n\n    // Overrides/extends rubberband for space handling with Ctrl+Shift(+Alt) drag\n    _mxRubberband[\"default\"].prototype.isSpaceEvent = function (me) {\n      return this.graph.isEnabled() && !this.graph.isCellLocked(this.graph.getDefaultParent()) && _mxEvent[\"default\"].isControlDown(me.getEvent()) && _mxEvent[\"default\"].isShiftDown(me.getEvent());\n    };\n\n    // Handles moving of cells in both half panes\n    _mxRubberband[\"default\"].prototype.mouseUp = function (sender, me) {\n      var execute = this.div != null && this.div.style.display != 'none';\n      var x0 = null;\n      var y0 = null;\n      var dx = null;\n      var dy = null;\n      if (this.first != null && this.currentX != null && this.currentY != null) {\n        x0 = this.first.x;\n        y0 = this.first.y;\n        dx = (this.currentX - x0) / this.graph.view.scale;\n        dy = (this.currentY - y0) / this.graph.view.scale;\n        if (!_mxEvent[\"default\"].isAltDown(me.getEvent())) {\n          dx = this.graph.snap(dx);\n          dy = this.graph.snap(dy);\n        }\n      }\n      this.reset();\n      if (execute) {\n        if (this.isSpaceEvent(me)) {\n          this.graph.model.beginUpdate();\n          try {\n            var right = this.graph.getCellsBeyond(x0, y0, this.graph.getDefaultParent(), true, false);\n            var bottom = this.graph.getCellsBeyond(x0, y0, this.graph.getDefaultParent(), false, true);\n            for (var i = 0; i < right.length; i++) {\n              if (this.graph.isCellMovable(right[i])) {\n                var tmp = this.graph.view.getState(right[i]);\n                var geo = this.graph.getCellGeometry(right[i]);\n                if (tmp != null && geo != null) {\n                  geo = geo.clone();\n                  geo.translate(dx, 0);\n                  this.graph.model.setGeometry(right[i], geo);\n                }\n              }\n            }\n            for (var i = 0; i < bottom.length; i++) {\n              if (this.graph.isCellMovable(bottom[i])) {\n                var tmp = this.graph.view.getState(bottom[i]);\n                var geo = this.graph.getCellGeometry(bottom[i]);\n                if (tmp != null && geo != null) {\n                  geo = geo.clone();\n                  geo.translate(0, dy);\n                  this.graph.model.setGeometry(bottom[i], geo);\n                }\n              }\n            }\n          } catch (e) {\n            if (window.console != null) {\n              console.log('Error in rubberband: ' + e);\n            }\n          } finally {\n            this.graph.model.endUpdate();\n          }\n        } else {\n          var rect = new _mxRectangle[\"default\"](this.x, this.y, this.width, this.height);\n          this.graph.selectRegion(rect, me.getEvent());\n        }\n        me.consume();\n      }\n    };\n\n    // Handles preview for creating/removing space in diagram\n    _mxRubberband[\"default\"].prototype.mouseMove = function (sender, me) {\n      if (!me.isConsumed() && this.first != null) {\n        var origin = _mxGraphUtils[\"default\"].getScrollOrigin(this.graph.container, _mxPoint[\"default\"]);\n        var offset = _mxGraphUtils[\"default\"].getOffset(this.graph.container, null, _mxPoint[\"default\"]);\n        origin.x -= offset.x;\n        origin.y -= offset.y;\n        var x = me.getX() + origin.x;\n        var y = me.getY() + origin.y;\n        var dx = this.first.x - x;\n        var dy = this.first.y - y;\n        var tol = this.graph.tolerance;\n        if (this.div != null || Math.abs(dx) > tol || Math.abs(dy) > tol) {\n          if (this.div == null) {\n            this.div = this.createShape();\n          }\n\n          // Clears selection while rubberbanding. This is required because\n          // the event is not consumed in mouseDown.\n          _mxUtils[\"default\"].clearSelection();\n          this.update(x, y);\n          if (this.isSpaceEvent(me)) {\n            // TODO: Check locked state\n            var right = this.x + this.width;\n            var bottom = this.y + this.height;\n            var scale = this.graph.view.scale;\n            if (!_mxEvent[\"default\"].isAltDown(me.getEvent())) {\n              this.width = this.graph.snap(this.width / scale) * scale;\n              this.height = this.graph.snap(this.height / scale) * scale;\n              if (this.x < this.first.x) {\n                this.x = right - this.width;\n              }\n              if (this.y < this.first.y) {\n                this.y = bottom - this.height;\n              }\n            }\n            this.div.style.left = this.x + 'px';\n            this.div.style.top = origin.y + offset.y + 'px';\n            this.div.style.width = Math.max(0, this.width) + 'px';\n            this.div.style.height = Math.max(0, this.graph.container.clientHeight) + 'px';\n            this.div.style.backgroundColor = 'white';\n            this.div.style.borderWidth = '0px 1px 0px 1px';\n            this.div.style.borderStyle = 'dashed';\n            if (this.secondDiv == null) {\n              this.secondDiv = this.div.cloneNode(true);\n              this.div.parentNode.appendChild(this.secondDiv);\n            }\n            this.secondDiv.style.left = origin.x + offset.x + 'px';\n            this.secondDiv.style.top = this.y + 'px';\n            this.secondDiv.style.width = Math.max(0, this.graph.container.clientWidth) + 'px';\n            this.secondDiv.style.height = Math.max(0, this.height) + 'px';\n            this.secondDiv.style.borderWidth = '1px 0px 1px 0px';\n          } else {\n            // Hides second div and restores style\n            this.div.style.backgroundColor = '';\n            this.div.style.borderWidth = '';\n            this.div.style.borderStyle = '';\n            if (this.secondDiv != null) {\n              this.secondDiv.parentNode.removeChild(this.secondDiv);\n              this.secondDiv = null;\n            }\n          }\n          me.consume();\n        }\n      }\n    };\n\n    // Removes preview\n    var mxRubberbandReset = _mxRubberband[\"default\"].prototype.reset;\n    _mxRubberband[\"default\"].prototype.reset = function () {\n      if (this.secondDiv != null) {\n        this.secondDiv.parentNode.removeChild(this.secondDiv);\n        this.secondDiv = null;\n      }\n      mxRubberbandReset.apply(this, arguments);\n    };\n\n    // Timer-based activation of outline connect in connection handler\n    var startTime = new Date().getTime();\n    var timeOnTarget = 0;\n    var mxEdgeHandlerUpdatePreviewState = _mxEdgeHandler[\"default\"].prototype.updatePreviewState;\n    _mxEdgeHandler[\"default\"].prototype.updatePreviewState = function (edge, point, terminalState, me) {\n      mxEdgeHandlerUpdatePreviewState.apply(this, arguments);\n      if (terminalState != this.currentTerminalState) {\n        startTime = new Date().getTime();\n        timeOnTarget = 0;\n      } else {\n        timeOnTarget = new Date().getTime() - startTime;\n      }\n      this.currentTerminalState = terminalState;\n    };\n\n    // Timer-based outline connect\n    var mxEdgeHandlerIsOutlineConnectEvent = _mxEdgeHandler[\"default\"].prototype.isOutlineConnectEvent;\n    _mxEdgeHandler[\"default\"].prototype.isOutlineConnectEvent = function (me) {\n      return this.currentTerminalState != null && me.getState() == this.currentTerminalState && timeOnTarget > 2000 || (this.currentTerminalState == null || _mxGraphUtils[\"default\"].getValue(this.currentTerminalState.style, 'outlineConnect', '1') != '0') && mxEdgeHandlerIsOutlineConnectEvent.apply(this, arguments);\n    };\n\n    // Disables custom handles if shift is pressed\n    _mxVertexHandler[\"default\"].prototype.isCustomHandleEvent = function (me) {\n      return !_mxEvent[\"default\"].isShiftDown(me.getEvent());\n    };\n\n    // Shows secondary handle for fixed connection points\n    _mxEdgeHandler[\"default\"].prototype.createHandleShape = function (index, virtual) {\n      var source = index != null && index == 0;\n      var terminalState = this.state.getVisibleTerminalState(source);\n      var c = index != null && (index == 0 || index >= this.state.absolutePoints.length - 1 || this.constructor == _mxElbowEdgeHandler[\"default\"] && index == 2) ? this.graph.getConnectionConstraint(this.state, terminalState, source) : null;\n      var pt = c != null ? this.graph.getConnectionPoint(this.state.getVisibleTerminalState(source), c) : null;\n      var img = pt != null ? this.fixedHandleImage : c != null && terminalState != null ? this.terminalHandleImage : this.handleImage;\n      if (img != null) {\n        var shape = new _mxImageShape[\"default\"](new _mxRectangle[\"default\"](0, 0, img.width, img.height), img.src);\n\n        // Allows HTML rendering of the images\n        shape.preserveImageAspect = false;\n        return shape;\n      } else {\n        var s = _mxConstants[\"default\"].HANDLE_SIZE;\n        if (this.preferHtml) {\n          s -= 1;\n        }\n        return new _mxRectangleShape[\"default\"](new _mxRectangle[\"default\"](0, 0, s, s), _mxConstants[\"default\"].HANDLE_FILLCOLOR, _mxConstants[\"default\"].HANDLE_STROKECOLOR);\n      }\n    };\n    var vertexHandlerCreateSizerShape = _mxVertexHandler[\"default\"].prototype.createSizerShape;\n    _mxVertexHandler[\"default\"].prototype.createSizerShape = function (bounds, index, fillColor) {\n      this.handleImage = index == _mxEvent[\"default\"].ROTATION_HANDLE ? rotationHandle : index == _mxEvent[\"default\"].LABEL_HANDLE ? this.secondaryHandleImage : this.handleImage;\n      return vertexHandlerCreateSizerShape.apply(this, arguments);\n    };\n\n    // Special case for single edge label handle moving in which case the text bounding box is used\n    var mxGraphHandlerGetBoundingBox = _mxGraphHandler[\"default\"].prototype.getBoundingBox;\n    _mxGraphHandler[\"default\"].prototype.getBoundingBox = function (cells) {\n      if (cells != null && cells.length == 1) {\n        var model = this.graph.getModel();\n        var parent = model.getParent(cells[0]);\n        var geo = this.graph.getCellGeometry(cells[0]);\n        if (model.isEdge(parent) && geo != null && geo.relative) {\n          var state = this.graph.view.getState(cells[0]);\n          if (state != null && state.width < 2 && state.height < 2 && state.text != null && state.text.boundingBox != null) {\n            return _mxRectangle[\"default\"].fromRectangle(state.text.boundingBox);\n          }\n        }\n      }\n      return mxGraphHandlerGetBoundingBox.apply(this, arguments);\n    };\n\n    // Uses text bounding box for edge labels\n    var mxVertexHandlerGetSelectionBounds = _mxVertexHandler[\"default\"].prototype.getSelectionBounds;\n    _mxVertexHandler[\"default\"].prototype.getSelectionBounds = function (state) {\n      var model = this.graph.getModel();\n      var parent = model.getParent(state.cell);\n      var geo = this.graph.getCellGeometry(state.cell);\n      if (model.isEdge(parent) && geo != null && geo.relative && state.width < 2 && state.height < 2 && state.text != null && state.text.boundingBox != null) {\n        var bbox = state.text.unrotatedBoundingBox || state.text.boundingBox;\n        return new _mxRectangle[\"default\"](Math.round(bbox.x), Math.round(bbox.y), Math.round(bbox.width), Math.round(bbox.height));\n      } else {\n        return mxVertexHandlerGetSelectionBounds.apply(this, arguments);\n      }\n    };\n\n    // Redirects moving of edge labels to mxGraphHandler by not starting here.\n    // This will use the move preview of mxGraphHandler (see above).\n    var mxVertexHandlerMouseDown = _mxVertexHandler[\"default\"].prototype.mouseDown;\n    _mxVertexHandler[\"default\"].prototype.mouseDown = function (sender, me) {\n      var model = this.graph.getModel();\n      var parent = model.getParent(this.state.cell);\n      var geo = this.graph.getCellGeometry(this.state.cell);\n\n      // Lets rotation events through\n      var handle = this.getHandleForEvent(me);\n      if (handle == _mxEvent[\"default\"].ROTATION_HANDLE || !model.isEdge(parent) || geo == null || !geo.relative || this.state == null || this.state.width >= 2 || this.state.height >= 2) {\n        mxVertexHandlerMouseDown.apply(this, arguments);\n      }\n    };\n\n    // Shows rotation handle for edge labels.\n    _mxVertexHandler[\"default\"].prototype.isRotationHandleVisible = function () {\n      return this.graph.isEnabled() && this.rotationEnabled && this.graph.isCellRotatable(this.state.cell) && (_mxGraphHandler[\"default\"].prototype.maxCells <= 0 || this.graph.getSelectionCount() < _mxGraphHandler[\"default\"].prototype.maxCells);\n    };\n\n    // Invokes turn on single click on rotation handle\n    _mxVertexHandler[\"default\"].prototype.rotateClick = function () {\n      this.state.view.graph.turnShapes([this.state.cell]);\n    };\n    var vertexHandlerMouseMove = _mxVertexHandler[\"default\"].prototype.mouseMove;\n\n    // Workaround for \"isConsumed not defined\" in MS Edge is to use arguments\n    _mxVertexHandler[\"default\"].prototype.mouseMove = function (sender, me) {\n      vertexHandlerMouseMove.apply(this, arguments);\n      if (this.graph.graphHandler.first != null) {\n        if (this.rotationShape != null && this.rotationShape.node != null) {\n          this.rotationShape.node.style.display = 'none';\n        }\n      }\n    };\n    var vertexHandlerMouseUp = _mxVertexHandler[\"default\"].prototype.mouseUp;\n    _mxVertexHandler[\"default\"].prototype.mouseUp = function (sender, me) {\n      vertexHandlerMouseUp.apply(this, arguments);\n\n      // Shows rotation handle only if one vertex is selected\n      if (this.rotationShape != null && this.rotationShape.node != null) {\n        this.rotationShape.node.style.display = this.graph.getSelectionCount() == 1 ? '' : 'none';\n      }\n    };\n    var vertexHandlerInit = _mxVertexHandler[\"default\"].prototype.init;\n    _mxVertexHandler[\"default\"].prototype.init = function () {\n      vertexHandlerInit.apply(this, arguments);\n      var redraw = false;\n      if (this.rotationShape != null) {\n        this.rotationShape.node.setAttribute('title', _mxResources[\"default\"].get('rotateTooltip'));\n      }\n      var update = _mxGraphUtils[\"default\"].bind(this, function () {\n        // Shows rotation handle only if one vertex is selected\n        if (this.rotationShape != null && this.rotationShape.node != null) {\n          this.rotationShape.node.style.display = this.graph.getSelectionCount() == 1 ? '' : 'none';\n        }\n        if (this.specialHandle != null) {\n          this.specialHandle.node.style.display = this.graph.isEnabled() && this.graph.getSelectionCount() < this.graph.graphHandler.maxCells ? '' : 'none';\n        }\n        this.redrawHandles();\n      });\n      this.selectionHandler = _mxGraphUtils[\"default\"].bind(this, function (sender, evt) {\n        update();\n      });\n      this.graph.getSelectionModel().addListener(_mxEvent[\"default\"].CHANGE, this.selectionHandler);\n      this.changeHandler = _mxGraphUtils[\"default\"].bind(this, function (sender, evt) {\n        this.updateLinkHint(this.graph.getLinkForCell(this.state.cell));\n        update();\n      });\n      this.graph.getModel().addListener(_mxEvent[\"default\"].CHANGE, this.changeHandler);\n\n      // Repaint needed when editing stops and no change event is fired\n      this.editingHandler = _mxGraphUtils[\"default\"].bind(this, function (sender, evt) {\n        this.redrawHandles();\n      });\n      this.graph.addListener(_mxEvent[\"default\"].EDITING_STOPPED, this.editingHandler);\n      var link = this.graph.getLinkForCell(this.state.cell);\n      this.updateLinkHint(link);\n      if (link != null) {\n        redraw = true;\n      }\n      if (redraw) {\n        this.redrawHandles();\n      }\n    };\n    _mxVertexHandler[\"default\"].prototype.updateLinkHint = function (link) {\n      if (link == null || this.graph.getSelectionCount() > 1) {\n        if (this.linkHint != null) {\n          this.linkHint.parentNode.removeChild(this.linkHint);\n          this.linkHint = null;\n        }\n      } else if (link != null) {\n        if (this.linkHint == null) {\n          this.linkHint = createHint();\n          this.linkHint.style.padding = '4px 10px 6px 10px';\n          this.linkHint.style.fontSize = '90%';\n          this.linkHint.style.opacity = '1';\n          this.linkHint.style.filter = '';\n          this.updateLinkHint(link);\n          this.graph.container.appendChild(this.linkHint);\n        }\n        var label = link;\n        var max = 60;\n        var head = 36;\n        var tail = 20;\n        if (label.length > max) {\n          label = label.substring(0, head) + '...' + label.substring(label.length - tail);\n        }\n        var a = document.createElement('a');\n        a.setAttribute('href', this.graph.getLinkUrl(link));\n        a.setAttribute('title', link);\n        if (this.graph.linkTarget != null) {\n          a.setAttribute('target', this.graph.linkTarget);\n        }\n        _mxGraphUtils[\"default\"].write(a, label);\n        this.linkHint.innerHTML = '';\n        this.linkHint.appendChild(a);\n        if (this.graph.isEnabled() && typeof this.graph.editLink === 'function') {\n          var changeLink = document.createElement('img');\n          changeLink.setAttribute('src', IMAGE_PATH + '/edit.gif');\n          changeLink.setAttribute('title', _mxResources[\"default\"].get('editLink'));\n          changeLink.setAttribute('width', '11');\n          changeLink.setAttribute('height', '11');\n          changeLink.style.marginLeft = '10px';\n          changeLink.style.marginBottom = '-1px';\n          changeLink.style.cursor = 'pointer';\n          this.linkHint.appendChild(changeLink);\n          _mxEvent[\"default\"].addListener(changeLink, 'click', _mxGraphUtils[\"default\"].bind(this, function (evt) {\n            this.graph.setSelectionCell(this.state.cell);\n            this.graph.editLink();\n            _mxEvent[\"default\"].consume(evt);\n          }));\n        }\n      }\n    };\n    _mxEdgeHandler[\"default\"].prototype.updateLinkHint = _mxVertexHandler[\"default\"].prototype.updateLinkHint;\n    var edgeHandlerInit = _mxEdgeHandler[\"default\"].prototype.init;\n    _mxEdgeHandler[\"default\"].prototype.init = function () {\n      edgeHandlerInit.apply(this, arguments);\n\n      // Disables connection points\n      this.constraintHandler.isEnabled = _mxGraphUtils[\"default\"].bind(this, function () {\n        return this.state.view.graph.connectionHandler.isEnabled();\n      });\n      var update = _mxGraphUtils[\"default\"].bind(this, function () {\n        if (this.linkHint != null) {\n          this.linkHint.style.display = this.graph.getSelectionCount() == 1 ? '' : 'none';\n        }\n        if (this.labelShape != null) {\n          this.labelShape.node.style.display = this.graph.isEnabled() && this.graph.getSelectionCount() < this.graph.graphHandler.maxCells ? '' : 'none';\n        }\n      });\n      this.selectionHandler = _mxGraphUtils[\"default\"].bind(this, function (sender, evt) {\n        update();\n      });\n      this.graph.getSelectionModel().addListener(_mxEvent[\"default\"].CHANGE, this.selectionHandler);\n      this.changeHandler = _mxGraphUtils[\"default\"].bind(this, function (sender, evt) {\n        this.updateLinkHint(this.graph.getLinkForCell(this.state.cell));\n        update();\n        this.redrawHandles();\n      });\n      this.graph.getModel().addListener(_mxEvent[\"default\"].CHANGE, this.changeHandler);\n      var link = this.graph.getLinkForCell(this.state.cell);\n      if (link != null) {\n        this.updateLinkHint(link);\n        this.redrawHandles();\n      }\n    };\n\n    // Disables connection points\n    var connectionHandlerInit = _mxConnectionHandler[\"default\"].prototype.init;\n    _mxConnectionHandler[\"default\"].prototype.init = function () {\n      connectionHandlerInit.apply(this, arguments);\n      this.constraintHandler.isEnabled = _mxGraphUtils[\"default\"].bind(this, function () {\n        return this.graph.connectionHandler.isEnabled();\n      });\n    };\n    var vertexHandlerRedrawHandles = _mxVertexHandler[\"default\"].prototype.redrawHandles;\n    _mxVertexHandler[\"default\"].prototype.redrawHandles = function () {\n      vertexHandlerRedrawHandles.apply(this);\n      if (this.state != null && this.linkHint != null) {\n        var c = new _mxPoint[\"default\"](this.state.getCenterX(), this.state.getCenterY());\n        var tmp = new _mxRectangle[\"default\"](this.state.x, this.state.y - 22, this.state.width + 24, this.state.height + 22);\n        var bb = _mxGraphUtils[\"default\"].getBoundingBox(tmp, this.state.style[_mxConstants[\"default\"].STYLE_ROTATION] || '0', c, _mxRectangle[\"default\"], _mxPoint[\"default\"]);\n        var rs = bb != null ? _mxGraphUtils[\"default\"].getBoundingBox(this.state, this.state.style[_mxConstants[\"default\"].STYLE_ROTATION] || '0', null, _mxRectangle[\"default\"], _mxPoint[\"default\"]) : this.state;\n        if (bb == null) {\n          bb = this.state;\n        }\n        this.linkHint.style.left = Math.round(rs.x + (rs.width - this.linkHint.clientWidth) / 2) + 'px';\n        this.linkHint.style.top = Math.round(bb.y + bb.height + this.verticalOffset / 2 + 6 + this.state.view.graph.tolerance) + 'px';\n      }\n    };\n    var vertexHandlerReset = _mxVertexHandler[\"default\"].prototype.reset;\n    _mxVertexHandler[\"default\"].prototype.reset = function () {\n      vertexHandlerReset.apply(this, arguments);\n\n      // Shows rotation handle only if one vertex is selected\n      if (this.rotationShape != null && this.rotationShape.node != null) {\n        this.rotationShape.node.style.display = this.graph.getSelectionCount() == 1 ? '' : 'none';\n      }\n    };\n    var vertexHandlerDestroy = _mxVertexHandler[\"default\"].prototype.destroy;\n    _mxVertexHandler[\"default\"].prototype.destroy = function () {\n      vertexHandlerDestroy.apply(this, arguments);\n      if (this.linkHint != null) {\n        this.linkHint.parentNode.removeChild(this.linkHint);\n        this.linkHint = null;\n      }\n      if (this.selectionHandler != null) {\n        this.graph.getSelectionModel().removeListener(this.selectionHandler);\n        this.selectionHandler = null;\n      }\n      if (this.changeHandler != null) {\n        this.graph.getModel().removeListener(this.changeHandler);\n        this.changeHandler = null;\n      }\n      if (this.editingHandler != null) {\n        this.graph.removeListener(this.editingHandler);\n        this.editingHandler = null;\n      }\n    };\n    var edgeHandlerRedrawHandles = _mxEdgeHandler[\"default\"].prototype.redrawHandles;\n    _mxEdgeHandler[\"default\"].prototype.redrawHandles = function () {\n      // Workaround for special case where handler\n      // is reset before this which leads to a NPE\n      if (this.marker != null) {\n        edgeHandlerRedrawHandles.apply(this);\n        if (this.state != null && this.linkHint != null) {\n          var b = this.state;\n          if (this.state.text != null && this.state.text.bounds != null) {\n            b = new _mxRectangle[\"default\"](b.x, b.y, b.width, b.height);\n            b.add(this.state.text.bounds);\n          }\n          this.linkHint.style.left = Math.round(b.x + (b.width - this.linkHint.clientWidth) / 2) + 'px';\n          this.linkHint.style.top = Math.round(b.y + b.height + 6 + this.state.view.graph.tolerance) + 'px';\n        }\n      }\n    };\n    var edgeHandlerReset = _mxEdgeHandler[\"default\"].prototype.reset;\n    _mxEdgeHandler[\"default\"].prototype.reset = function () {\n      edgeHandlerReset.apply(this, arguments);\n      if (this.linkHint != null) {\n        this.linkHint.style.visibility = '';\n      }\n    };\n    var edgeHandlerDestroy = _mxEdgeHandler[\"default\"].prototype.destroy;\n    _mxEdgeHandler[\"default\"].prototype.destroy = function () {\n      edgeHandlerDestroy.apply(this, arguments);\n      if (this.linkHint != null) {\n        this.linkHint.parentNode.removeChild(this.linkHint);\n        this.linkHint = null;\n      }\n      if (this.selectionHandler != null) {\n        this.graph.getSelectionModel().removeListener(this.selectionHandler);\n        this.selectionHandler = null;\n      }\n      if (this.changeHandler != null) {\n        this.graph.getModel().removeListener(this.changeHandler);\n        this.changeHandler = null;\n      }\n    };\n  })();\n}\nvar _default = exports[\"default\"] = HoverIcons;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxGraph/HoverIcons.js?");

/***/ }),

/***/ "./src/workflow/mxGraph/HtmlCard.js":
/*!******************************************!*\
  !*** ./src/workflow/mxGraph/HtmlCard.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.index-of.js */ \"../../node_modules/core-js/modules/es.array.index-of.js\");\nvar _mxShape = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxShape.js */ \"./src/workflow/mxClient/mxShape.js\"));\nvar _mxUtils = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxUtils.js */ \"./src/workflow/mxClient/mxUtils.js\"));\nvar _mxEvent = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxEvent.js */ \"./src/workflow/mxClient/mxEvent.js\"));\nvar _mxClient = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxClient.js */ \"./src/workflow/mxClient/mxClient.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction HtmlCard() {\n  _mxShape[\"default\"].call(this);\n}\n_mxUtils[\"default\"].extend(HtmlCard, _mxShape[\"default\"]);\nHtmlCard.prototype.cardnode = null;\nHtmlCard.prototype.paintVertexShape = function (c, x, y, w, h, shape) {\n  c.rect(x, y, w, h);\n  var gx = c.node.getAttribute('x');\n  var gy = c.node.getAttribute('y');\n  c.fillAndStroke();\n  var group = document.createElementNS(_mxConstants[\"default\"].NS_SVG, 'g');\n  var fo = document.createElementNS(_mxConstants[\"default\"].NS_SVG, 'foreignObject');\n  var opacity = shape.state.style.opacity || 100;\n  fo.setAttribute('width', 216);\n  fo.setAttribute('height', 132);\n  fo.setAttribute('style', 'overflow:visible;');\n  group.setAttribute('transform', 'translate(' + gx + ',' + gy + ') scale(' + c.state.scale + ')');\n  var div = document.createElement('div');\n  var cell = this.state.cell;\n  var html = this.getCardHTML(cell.properties || {});\n  var graph = this.state.view.graph;\n  if (html) {\n    div.innerHTML = html;\n    this.cardnode = div.firstElementChild;\n    this.cardnode.style.setProperty('opacity', \"\".concat(opacity / 100));\n    this.addEventListener(this.cardnode, graph, cell);\n  }\n  fo.appendChild(div);\n  group.appendChild(fo);\n  this.node.appendChild(group);\n  c.fillAndStroke();\n};\nHtmlCard.prototype.getCardHTML = function (props) {\n  return null;\n};\nHtmlCard.prototype.getActivatedStyleClass = function () {\n  return 'activatedCard';\n};\nHtmlCard.prototype.addEventListener = function (card, graph, cell) {\n  var properties = cell.properties;\n  var actCls = this.getActivatedStyleClass();\n  card.addEventListener('keydown', function (e) {\n    if ((_mxEvent[\"default\"].isControlDown(e) || _mxClient[\"default\"].IS_MAC && e.metaKey) && e.keyCode == 67) {\n      e.stopPropagation();\n    }\n  });\n  card.addEventListener('click', function (evt) {\n    var div = evt.currentTarget;\n    var lock = div.getAttribute('data-lock');\n    if (lock == 'true') {\n      return;\n    }\n    var event = evt.target.getAttribute('data-event');\n    if (event && event.length) {\n      graph.invokeCustomEvent(event, properties);\n    } else {\n      var view = graph.getView();\n      if (!_mxGraphUtils[\"default\"].hasClass(div, actCls)) {\n        try {\n          showRelationPath(cell, graph);\n          var states = view.getCellStates([cell]);\n          if (states && states.length) {\n            div = states[0].shape.cardnode;\n          }\n        } catch (e) {\n          console.log(e);\n        }\n        graph.invokeCustomEvent('selectCard', properties);\n        _mxGraphUtils[\"default\"].addClass(div, actCls);\n      }\n    }\n  }, false);\n  function showRelationPath(cell, graph) {\n    if (cell.vertex) {\n      var lineElements = [cell];\n      var lineEdgeIds = [];\n      var lineEdges = [];\n      var inEdges = [];\n      var outEdges = [];\n      var edges = cell.edges;\n      if (!edges) {\n        return;\n      }\n      for (var i = 0; i < edges.length; i++) {\n        var edge = edges[i];\n        var source = edge.source;\n        if (source && source.id == cell.id) {\n          outEdges.push(edge);\n        } else {\n          inEdges.push(edge);\n        }\n      }\n\n      //遍历出口线路径\n      var outEdge = null;\n      while ((outEdge = outEdges.pop()) != null) {\n        lineEdges.push(outEdge);\n        lineEdgeIds.push(outEdge.id);\n        var target = outEdge.target;\n        if (!target) {\n          continue;\n        }\n        var flows = target.edges;\n        for (var _i = 0; _i < flows.length; _i++) {\n          var flow = flows[_i];\n          var src = flow.source;\n          if (src && src.id == target.id) {\n            outEdges.push(flow);\n          }\n        }\n        lineElements.push(outEdge);\n        lineElements.push(target);\n      }\n\n      //遍历入口路径\n      var inEdge = null;\n      while ((inEdge = inEdges.pop()) != null) {\n        lineEdges.push(inEdge);\n        lineEdgeIds.push(inEdge.id);\n        var _source = inEdge.source;\n        if (!_source) {\n          continue;\n        }\n        var _flows = _source.edges;\n        for (var _i2 = 0; _i2 < _flows.length; _i2++) {\n          var _flow = _flows[_i2];\n          var tgt = _flow.target;\n          if (tgt && tgt.id == _source.id) {\n            inEdges.push(_flow);\n          }\n        }\n        lineElements.push(inEdge);\n        lineElements.push(_source);\n      }\n      graph.setCellStyles(\"strokeColor\", \"#2A71F5!important\", lineEdges);\n      var lineEltIds = [];\n      for (var _i3 = 0; _i3 < lineElements.length; _i3++) {\n        var element = lineElements[_i3];\n        lineEltIds.push(element.id);\n        var children = element.children;\n        if (children && children.length) {\n          for (var j = 0; j < children.length; j++) {\n            var child = children[j];\n            lineEltIds.push(child.id);\n          }\n        }\n      }\n      cell.lineIds = lineEdgeIds;\n      var ret = [];\n      var cardElements = [];\n      var elements = graph.getModel().cells;\n      for (var key in elements) {\n        var _element = elements[key];\n        if (!_element.vertex && !_element.edge || key == cell.id) {\n          continue;\n        }\n        if (lineEltIds.indexOf(_element.id) < 0) {\n          if (_mxGraphUtils[\"default\"].isBillRelationCard(_element.type)) {\n            cardElements.push(_element);\n          } else {\n            ret.push(_element);\n          }\n        }\n      }\n      graph.setCellStyles(\"opacity\", \"30\", ret);\n      _mxGraphUtils[\"default\"].setBillRelationCardOpacity(graph, cardElements, 30);\n    }\n  }\n};\nvar _default = exports[\"default\"] = HtmlCard;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxGraph/HtmlCard.js?");

/***/ }),

/***/ "./src/workflow/mxGraph/HtmlTemplates.js":
/*!***********************************************!*\
  !*** ./src/workflow/mxGraph/HtmlTemplates.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.stackedCardTpl = exports.stackedCardLockedTpl = exports.billCardTpl = exports.billCardLockedTpl = void 0;\nvar billCardLockedTpl = exports.billCardLockedTpl = '{{if styles && data}}' + '\t<div class=\"{{styles.box}}\" data-lock=\"{{data.lock}}\">' + '\t\t<div class=\"{{styles.lockHeader}}\">' + '\t\t\t<div>{{data.title}}</div>' + '\t\t</div>' + '\t\t<div class=\"{{styles.lockContent}}\">' + '\t\t\t<img src=\"{{data.lockIcon}}\"/>' + '\t\t\t<span>{{data.lockTip}}</span>' + '\t\t</div>' + '\t</div>' + '{{/if}}';\nvar billCardTpl = exports.billCardTpl = '{{if styles && data}}' + '\t<div class=\"{{styles.box}}\" tabindex=\"0\">' + '\t\t<div class=\"{{styles.header}}\">' + '\t\t\t<div>' + '\t\t\t\t<div class=\"{{styles.title}}\" title=\"{{data.title}}\">{{data.title}}</div>' + '\t\t\t\t<div class=\"{{styles.subtitle}}\" title=\"{{data.subtitle}}\">' + '\t\t\t\t\t<a class=\"{{styles.link}}\" data-event=\"showBill\">{{data.subtitle}}</a>' + '\t\t\t\t</div>' + '\t\t\t</div>' + '\t\t\t{{if data.billIcon}}' + '\t\t\t\t<div class=\"{{styles.icon}}\">' + '\t\t\t\t\t<img src=\"{{data.billIcon}}\"/>' + '\t\t\t\t</div>' + '\t\t\t{{/if}}' + '\t\t</div>' + '\t\t<div class=\"{{styles.content}}\">' + '\t\t\t<div title=\"{{data.name}}\">{{data.name}}</div>' + '\t\t\t<div title=\"{{data.department}}\">{{data.department}}</div>' + '\t\t\t<div title=\"{{data.note}}\">{{data.note}}</div>' + '\t\t</div>' + '\t</div>' + '{{/if}}';\nvar stackedCardLockedTpl = exports.stackedCardLockedTpl = '{{if styles && data}}' + '\t<div class=\"{{styles.box}}\" data-lock=\"{{data.lock}}\">' + '\t\t<div class=\"{{styles.lockedLeft}}\"></div>' + '\t\t<div class=\"{{styles.lockedRight}}\"></div>' + '\t\t<div class=\"{{styles.layer}}\"></div>' + '\t\t' + '\t\t<div class=\"{{styles.main}}\">' + '\t\t\t<div class=\"{{styles.lockHeader}}\">' + '\t\t\t\t<span>{{data.title}}</span>' + '\t\t\t</div>' + '\t\t\t<div class=\"{{styles.lockContent}}\">' + '\t\t\t\t<img src=\"{{data.lockIcon}}\"/>' + '\t\t\t\t<span>{{data.lockTip}}</span>' + '\t\t\t</div>' + '\t\t</div>' + '\t</div>' + '{{/if}}';\nvar stackedCardTpl = exports.stackedCardTpl = '{{if styles && data}}' + '\t<div class=\"{{styles.box}}\">' + '\t\t<div class=\"{{styles.left}}\"></div>' + '\t\t<div class=\"{{styles.right}}\"></div>' + '\t\t<div class=\"{{styles.layer}}\"></div>' + '\t\t' + '\t\t<div class=\"{{styles.main}}\">' + '\t\t\t<div class=\"{{styles.header}}\">' + '\t\t\t\t<div>' + '\t\t\t\t\t<div class=\"{{styles.title}}\" title=\"{{data.title}}\">{{data.title}}</div>' + '\t\t\t\t\t<div class=\"{{styles.subtitle}}\">' + '\t\t\t\t\t\t<a class=\"{{styles.link}}\" data-event=\"showStackedBills\">{{data.subtitle}}</a>' + '\t\t\t\t\t</div>' + '\t\t\t\t</div>' + '\t\t\t\t<div class=\"{{styles.icon}}\">' + '\t\t\t\t\t<img src=\"{{data.billIcon}}\"/>' + '\t\t\t\t</div>' + '\t\t\t</div>' + '\t\t\t<div class=\"{{styles.content}}\">' + '\t\t\t\t<div title=\"{{data.name}}\">{{data.name}}</div>' + '\t\t\t\t<div title=\"{{data.department}}\">{{data.department}}</div>' + '\t\t\t\t<div title=\"{{data.note}}\">{{data.note}}</div>' + '\t\t\t</div>' + '\t\t</div>' + '\t</div>' + '{{/if}}';\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxGraph/HtmlTemplates.js?");

/***/ }),

/***/ "./src/workflow/mxGraph/LayersWindow.js":
/*!**********************************************!*\
  !*** ./src/workflow/mxGraph/LayersWindow.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.filter.js */ \"../../node_modules/core-js/modules/es.array.filter.js\");\n__webpack_require__(/*! core-js/modules/es.function.bind.js */ \"../../node_modules/core-js/modules/es.function.bind.js\");\n__webpack_require__(/*! core-js/modules/es.object.to-string.js */ \"../../node_modules/core-js/modules/es.object.to-string.js\");\nvar _mxCell = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxCell.js */ \"./src/workflow/mxClient/mxCell.js\"));\nvar _mxClient = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxClient.js */ \"./src/workflow/mxClient/mxClient.js\"));\nvar _FilenameDialog = _interopRequireDefault(__webpack_require__(/*! ./FilenameDialog.js */ \"./src/workflow/mxGraph/FilenameDialog.js\"));\nvar _mxEvent = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxEvent.js */ \"./src/workflow/mxClient/mxEvent.js\"));\nvar _mxWindow = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxWindow.js */ \"./src/workflow/mxClient/mxWindow.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxResources = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxResources.js */ \"./src/workflow/mxClient/mxResources.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nvar LayersWindow = function LayersWindow(editorUi, x, y, w, h) {\n  var graph = editorUi.editor.graph;\n  var div = document.createElement('div');\n  div.style.userSelect = 'none';\n  div.style.background = 'whiteSmoke';\n  div.style.border = '1px solid whiteSmoke';\n  div.style.height = '100%';\n  div.style.marginBottom = '10px';\n  div.style.overflow = 'auto';\n  var tbarHeight = !window.compactUi ? '30px' : '26px';\n  var listDiv = document.createElement('div');\n  listDiv.style.backgroundColor = '#e5e5e5';\n  listDiv.style.position = 'absolute';\n  listDiv.style.overflow = 'auto';\n  listDiv.style.left = '0px';\n  listDiv.style.right = '0px';\n  listDiv.style.top = '0px';\n  listDiv.style.bottom = tbarHeight;\n  div.appendChild(listDiv);\n  var dragSource = null;\n  var dropIndex = null;\n  _mxEvent[\"default\"].addListener(div, 'dragover', function (evt) {\n    evt.dataTransfer.dropEffect = 'move';\n    dropIndex = null;\n    evt.stopPropagation();\n    evt.preventDefault();\n  });\n  var layerCount = null;\n  var selectionLayer = null;\n  var ldiv = document.createElement('div');\n  ldiv.className = 'geToolbarContainer';\n  ldiv.style.position = 'absolute';\n  ldiv.style.bottom = '0px';\n  ldiv.style.left = '0px';\n  ldiv.style.right = '0px';\n  ldiv.style.height = tbarHeight;\n  ldiv.style.overflow = 'hidden';\n  ldiv.style.padding = !window.compactUi ? '1px' : '4px 0px 3px 0px';\n  ldiv.style.backgroundColor = 'whiteSmoke';\n  ldiv.style.borderWidth = '1px 0px 0px 0px';\n  ldiv.style.borderColor = '#c3c3c3';\n  ldiv.style.borderStyle = 'solid';\n  ldiv.style.display = 'block';\n  ldiv.style.whiteSpace = 'nowrap';\n  if (_mxClient[\"default\"].IS_QUIRKS) {\n    ldiv.style.filter = 'none';\n  }\n  var link = document.createElement('a');\n  link.className = 'geButton';\n  if (_mxClient[\"default\"].IS_QUIRKS) {\n    link.style.filter = 'none';\n  }\n  var removeLink = link.cloneNode();\n  removeLink.innerHTML = '<div class=\"geSprite geSprite-delete\" style=\"display:inline-block;\"></div>';\n  _mxEvent[\"default\"].addListener(removeLink, 'click', function (evt) {\n    if (graph.isEnabled()) {\n      graph.model.beginUpdate();\n      try {\n        var index = graph.model.root.getIndex(selectionLayer);\n        graph.removeCells([selectionLayer], false);\n\n        // Creates default layer if no layer exists\n        if (graph.model.getChildCount(graph.model.root) == 0) {\n          graph.model.add(graph.model.root, new _mxCell[\"default\"]());\n          graph.setDefaultParent(null);\n        } else if (index > 0 && index <= graph.model.getChildCount(graph.model.root)) {\n          graph.setDefaultParent(graph.model.getChildAt(graph.model.root, index - 1));\n        } else {\n          graph.setDefaultParent(null);\n        }\n      } finally {\n        graph.model.endUpdate();\n      }\n    }\n    _mxEvent[\"default\"].consume(evt);\n  });\n  if (!graph.isEnabled()) {\n    removeLink.className = 'geButton mxDisabled';\n  }\n  ldiv.appendChild(removeLink);\n  var insertLink = link.cloneNode();\n  insertLink.innerHTML = '<div class=\"geSprite geSprite-insert\" style=\"display:inline-block;\"></div>';\n  _mxEvent[\"default\"].addListener(insertLink, 'click', function (evt) {\n    if (graph.isEnabled() && !graph.isSelectionEmpty()) {\n      graph.moveCells(graph.getSelectionCells(), 0, 0, false, selectionLayer);\n    }\n  });\n  ldiv.appendChild(insertLink);\n  var renameLink = link.cloneNode();\n  renameLink.innerHTML = '<div class=\"geSprite geSprite-dots\" style=\"display:inline-block;\"></div>';\n  renameLink.setAttribute('title', _mxResources[\"default\"].get('rename'));\n  function renameLayer(layer) {\n    if (graph.isEnabled() && layer != null) {\n      var dlg = new _FilenameDialog[\"default\"](editorUi, layer.value || _mxResources[\"default\"].get('background'), _mxResources[\"default\"].get('rename'), _mxGraphUtils[\"default\"].bind(this, function (newValue) {\n        if (newValue != null) {\n          graph.getModel().setValue(layer, newValue);\n        }\n      }), _mxResources[\"default\"].get('enterName'));\n      editorUi.showDialog(dlg.container, 300, 100, true, true);\n      dlg.init();\n    }\n  }\n  ;\n  _mxEvent[\"default\"].addListener(renameLink, 'click', function (evt) {\n    if (graph.isEnabled()) {\n      renameLayer(selectionLayer);\n    }\n    _mxEvent[\"default\"].consume(evt);\n  });\n  if (!graph.isEnabled()) {\n    renameLink.className = 'geButton mxDisabled';\n  }\n  ldiv.appendChild(renameLink);\n  var duplicateLink = link.cloneNode();\n  duplicateLink.innerHTML = '<div class=\"geSprite geSprite-duplicate\" style=\"display:inline-block;\"></div>';\n  _mxEvent[\"default\"].addListener(duplicateLink, 'click', function (evt) {\n    if (graph.isEnabled()) {\n      var newCell = null;\n      graph.model.beginUpdate();\n      try {\n        newCell = graph.cloneCells([selectionLayer])[0];\n        newCell.value = _mxResources[\"default\"].get('untitledLayer');\n        newCell.setVisible(true);\n        newCell = graph.addCell(newCell, graph.model.root);\n        graph.setDefaultParent(newCell);\n      } finally {\n        graph.model.endUpdate();\n      }\n      if (newCell != null && !graph.isCellLocked(newCell)) {\n        graph.selectAll(newCell);\n      }\n    }\n  });\n  if (!graph.isEnabled()) {\n    duplicateLink.className = 'geButton mxDisabled';\n  }\n  ldiv.appendChild(duplicateLink);\n  var addLink = link.cloneNode();\n  addLink.innerHTML = '<div class=\"geSprite geSprite-plus\" style=\"display:inline-block;\"></div>';\n  addLink.setAttribute('title', _mxResources[\"default\"].get('addLayer'));\n  _mxEvent[\"default\"].addListener(addLink, 'click', function (evt) {\n    if (graph.isEnabled()) {\n      graph.model.beginUpdate();\n      try {\n        var cell = graph.addCell(new _mxCell[\"default\"](_mxResources[\"default\"].get('untitledLayer')), graph.model.root);\n        graph.setDefaultParent(cell);\n      } finally {\n        graph.model.endUpdate();\n      }\n    }\n    _mxEvent[\"default\"].consume(evt);\n  });\n  if (!graph.isEnabled()) {\n    addLink.className = 'geButton mxDisabled';\n  }\n  ldiv.appendChild(addLink);\n  div.appendChild(ldiv);\n  function refresh() {\n    layerCount = graph.model.getChildCount(graph.model.root);\n    listDiv.innerHTML = '';\n    function addLayer(index, label, child, defaultParent) {\n      var ldiv = document.createElement('div');\n      ldiv.className = 'geToolbarContainer';\n      ldiv.style.overflow = 'hidden';\n      ldiv.style.position = 'relative';\n      ldiv.style.padding = '4px';\n      ldiv.style.height = '22px';\n      ldiv.style.display = 'block';\n      ldiv.style.backgroundColor = 'whiteSmoke';\n      ldiv.style.borderWidth = '0px 0px 1px 0px';\n      ldiv.style.borderColor = '#c3c3c3';\n      ldiv.style.borderStyle = 'solid';\n      ldiv.style.whiteSpace = 'nowrap';\n      var left = document.createElement('div');\n      left.style.display = 'inline-block';\n      left.style.width = '100%';\n      left.style.textOverflow = 'ellipsis';\n      left.style.overflow = 'hidden';\n      _mxEvent[\"default\"].addListener(ldiv, 'dragover', function (evt) {\n        evt.dataTransfer.dropEffect = 'move';\n        dropIndex = index;\n        evt.stopPropagation();\n        evt.preventDefault();\n      });\n      _mxEvent[\"default\"].addListener(ldiv, 'dragstart', function (evt) {\n        dragSource = ldiv;\n\n        // Workaround for no DnD on DIV in FF\n        if (_mxClient[\"default\"].IS_FF) {\n          // LATER: Check what triggers a parse as XML on this in FF after drop\n          evt.dataTransfer.setData('Text', '<layer/>');\n        }\n      });\n      _mxEvent[\"default\"].addListener(ldiv, 'dragend', function (evt) {\n        if (dragSource != null) {\n          graph.addCell(child, graph.model.root, dropIndex);\n          dragSource = null;\n          dropIndex = null;\n        }\n        evt.stopPropagation();\n        evt.preventDefault();\n      });\n      var btn = document.createElement('img');\n      btn.setAttribute('draggable', 'false');\n      btn.setAttribute('align', 'top');\n      btn.setAttribute('border', '0');\n      btn.style.cursor = 'pointer';\n      btn.style.padding = '4px';\n      btn.setAttribute('title', _mxResources[\"default\"].get('lockUnlock'));\n      var state = graph.view.getState(child);\n      var style = state != null ? state.style : graph.getCellStyle(child);\n      if (_mxGraphUtils[\"default\"].getValue(style, 'locked', '0') == '1') {\n        btn.setAttribute('src', Dialog.prototype.lockedImage);\n      } else {\n        btn.setAttribute('src', Dialog.prototype.unlockedImage);\n      }\n      _mxEvent[\"default\"].addListener(btn, 'click', function (evt) {\n        if (graph.isEnabled()) {\n          var value = null;\n          graph.getModel().beginUpdate();\n          try {\n            value = _mxGraphUtils[\"default\"].getValue(style, 'locked', '0') == '1' ? null : '1';\n            graph.setCellStyles('locked', value, [child]);\n          } finally {\n            graph.getModel().endUpdate();\n          }\n          if (value == '1') {\n            graph.removeSelectionCells(graph.getModel().getDescendants(child));\n          }\n          _mxEvent[\"default\"].consume(evt);\n        }\n      });\n      left.appendChild(btn);\n      var inp = document.createElement('input');\n      inp.setAttribute('type', 'checkbox');\n      inp.setAttribute('title', _mxResources[\"default\"].get('hideIt', [child.value || _mxResources[\"default\"].get('background')]));\n      inp.style.marginLeft = '4px';\n      inp.style.marginRight = '6px';\n      inp.style.marginTop = '4px';\n      left.appendChild(inp);\n      if (!graph.isEnabled()) {\n        inp.setAttribute('disabled', 'disabled');\n      }\n      if (graph.model.isVisible(child)) {\n        inp.setAttribute('checked', 'checked');\n        inp.defaultChecked = true;\n      }\n      _mxEvent[\"default\"].addListener(inp, 'click', function (evt) {\n        if (graph.isEnabled()) {\n          graph.model.setVisible(child, !graph.model.isVisible(child));\n          _mxEvent[\"default\"].consume(evt);\n        }\n      });\n      _mxGraphUtils[\"default\"].write(left, label);\n      ldiv.appendChild(left);\n      if (graph.isEnabled()) {\n        // Fallback if no drag and drop is available\n        if (_mxClient[\"default\"].IS_TOUCH || _mxClient[\"default\"].IS_POINTER || _mxClient[\"default\"].IS_VML || _mxClient[\"default\"].IS_IE && document.documentMode < 10) {\n          var right = document.createElement('div');\n          right.style.display = 'block';\n          right.style.textAlign = 'right';\n          right.style.whiteSpace = 'nowrap';\n          right.style.position = 'absolute';\n          right.style.right = '6px';\n          right.style.top = '6px';\n\n          // Poor man's change layer order\n          if (index > 0) {\n            var img2 = document.createElement('a');\n            img2.setAttribute('title', _mxResources[\"default\"].get('toBack'));\n            img2.className = 'geButton';\n            img2.style.cssFloat = 'none';\n            img2.innerHTML = '&#9650;';\n            img2.style.width = '14px';\n            img2.style.height = '14px';\n            img2.style.fontSize = '14px';\n            img2.style.margin = '0px';\n            img2.style.marginTop = '-1px';\n            right.appendChild(img2);\n            _mxEvent[\"default\"].addListener(img2, 'click', function (evt) {\n              if (graph.isEnabled()) {\n                graph.addCell(child, graph.model.root, index - 1);\n              }\n              _mxEvent[\"default\"].consume(evt);\n            });\n          }\n          if (index >= 0 && index < layerCount - 1) {\n            var img1 = document.createElement('a');\n            img1.setAttribute('title', _mxResources[\"default\"].get('toFront'));\n            img1.className = 'geButton';\n            img1.style.cssFloat = 'none';\n            img1.innerHTML = '&#9660;';\n            img1.style.width = '14px';\n            img1.style.height = '14px';\n            img1.style.fontSize = '14px';\n            img1.style.margin = '0px';\n            img1.style.marginTop = '-1px';\n            right.appendChild(img1);\n            _mxEvent[\"default\"].addListener(img1, 'click', function (evt) {\n              if (graph.isEnabled()) {\n                graph.addCell(child, graph.model.root, index + 1);\n              }\n              _mxEvent[\"default\"].consume(evt);\n            });\n          }\n          ldiv.appendChild(right);\n        }\n        if (_mxClient[\"default\"].IS_SVG && (!_mxClient[\"default\"].IS_IE || document.documentMode >= 10)) {\n          ldiv.setAttribute('draggable', 'true');\n          ldiv.style.cursor = 'move';\n        }\n      }\n      _mxEvent[\"default\"].addListener(ldiv, 'dblclick', function (evt) {\n        var nodeName = _mxEvent[\"default\"].getSource(evt).nodeName;\n        if (nodeName != 'INPUT' && nodeName != 'IMG') {\n          renameLayer(child);\n          _mxEvent[\"default\"].consume(evt);\n        }\n      });\n      if (graph.getDefaultParent() == child) {\n        ldiv.style.background = '#e6eff8';\n        selectionLayer = child;\n      } else {\n        _mxEvent[\"default\"].addListener(ldiv, 'click', function (evt) {\n          if (graph.isEnabled()) {\n            graph.setDefaultParent(defaultParent);\n            graph.view.setCurrentRoot(null);\n            refresh();\n          }\n        });\n      }\n      listDiv.appendChild(ldiv);\n    }\n    ;\n\n    // Cannot be moved or deleted\n    for (var i = 0; i < layerCount; i++) {\n      _mxGraphUtils[\"default\"].bind(this, function (child) {\n        addLayer(i, child.value || _mxResources[\"default\"].get('background'), child, child);\n      })(graph.model.getChildAt(graph.model.root, i));\n    }\n    removeLink.setAttribute('title', _mxResources[\"default\"].get('removeIt', [selectionLayer.value || _mxResources[\"default\"].get('background')]));\n    insertLink.setAttribute('title', _mxResources[\"default\"].get('moveSelectionTo', [selectionLayer.value || _mxResources[\"default\"].get('background')]));\n    duplicateLink.setAttribute('title', _mxResources[\"default\"].get('duplicateIt', [selectionLayer.value || _mxResources[\"default\"].get('background')]));\n    renameLink.setAttribute('title', _mxResources[\"default\"].get('renameIt', [selectionLayer.value || _mxResources[\"default\"].get('background')]));\n    if (graph.isSelectionEmpty()) {\n      insertLink.className = 'geButton mxDisabled';\n    }\n  }\n  ;\n  refresh();\n  graph.model.addListener(_mxEvent[\"default\"].CHANGE, function () {\n    refresh();\n  });\n  graph.selectionModel.addListener(_mxEvent[\"default\"].CHANGE, function () {\n    if (graph.isSelectionEmpty()) {\n      insertLink.className = 'geButton mxDisabled';\n    } else {\n      insertLink.className = 'geButton';\n    }\n  });\n  this.window = new _mxWindow[\"default\"](_mxResources[\"default\"].get('layers'), div, x, y, w, h, true, true);\n  this.window.destroyOnClose = false;\n  this.window.setMaximizable(false);\n  this.window.setResizable(true);\n  this.window.setClosable(true);\n  this.window.setVisible(true);\n\n  // Make refresh available via instance\n  this.refreshLayers = refresh;\n  this.window.setLocation = function (x, y) {\n    x = Math.max(0, x);\n    y = Math.max(0, y);\n    _mxWindow[\"default\"].prototype.setLocation.apply(this, arguments);\n  };\n  _mxEvent[\"default\"].addListener(window, 'resize', _mxGraphUtils[\"default\"].bind(this, function () {\n    var iw = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;\n    var ih = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;\n    var x = this.window.getX();\n    var y = this.window.getY();\n    if (x + this.window.table.clientWidth > iw) {\n      x = Math.max(0, iw - this.window.table.clientWidth);\n    }\n    if (y + this.window.table.clientHeight > ih) {\n      y = Math.max(0, ih - this.window.table.clientHeight);\n    }\n    if (this.window.getX() != x || this.window.getY() != y) {\n      this.window.setLocation(x, y);\n    }\n  }));\n};\nvar _default = exports[\"default\"] = LayersWindow;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxGraph/LayersWindow.js?");

/***/ }),

/***/ "./src/workflow/mxGraph/LinkDialog.js":
/*!********************************************!*\
  !*** ./src/workflow/mxGraph/LinkDialog.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _mxClient = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxClient.js */ \"./src/workflow/mxClient/mxClient.js\"));\nvar _mxEvent = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxEvent.js */ \"./src/workflow/mxClient/mxEvent.js\"));\nvar _mxResources = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxResources.js */ \"./src/workflow/mxClient/mxResources.js\"));\nvar _mxUtils = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxUtils.js */ \"./src/workflow/mxClient/mxUtils.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nvar LinkDialog = function LinkDialog(editorUi, initialValue, btnLabel, fn) {\n  var div = document.createElement('div');\n  _mxGraphUtils[\"default\"].write(div, _mxResources[\"default\"].get('editLink') + ':');\n  var inner = document.createElement('div');\n  inner.className = 'geTitle';\n  inner.style.backgroundColor = 'transparent';\n  inner.style.borderColor = 'transparent';\n  inner.style.whiteSpace = 'nowrap';\n  inner.style.textOverflow = 'clip';\n  inner.style.cursor = 'default';\n  if (!_mxClient[\"default\"].IS_VML) {\n    inner.style.paddingRight = '20px';\n  }\n  var linkInput = document.createElement('input');\n  linkInput.setAttribute('value', initialValue);\n  linkInput.setAttribute('placeholder', 'http://www.example.com/');\n  linkInput.setAttribute('type', 'text');\n  linkInput.style.marginTop = '6px';\n  linkInput.style.width = '400px';\n  linkInput.style.backgroundImage = 'url(\\'' + Dialog.prototype.clearImage + '\\')';\n  linkInput.style.backgroundRepeat = 'no-repeat';\n  linkInput.style.backgroundPosition = '100% 50%';\n  linkInput.style.paddingRight = '14px';\n  var cross = document.createElement('div');\n  cross.setAttribute('title', _mxResources[\"default\"].get('reset'));\n  cross.style.position = 'relative';\n  cross.style.left = '-16px';\n  cross.style.width = '12px';\n  cross.style.height = '14px';\n  cross.style.cursor = 'pointer';\n\n  // Workaround for inline-block not supported in IE\n  cross.style.display = _mxClient[\"default\"].IS_VML ? 'inline' : 'inline-block';\n  cross.style.top = (_mxClient[\"default\"].IS_VML ? 0 : 3) + 'px';\n\n  // Needed to block event transparency in IE\n  cross.style.background = 'url(' + IMAGE_PATH + '/transparent.gif)';\n  _mxEvent[\"default\"].addListener(cross, 'click', function () {\n    linkInput.value = '';\n    linkInput.focus();\n  });\n  inner.appendChild(linkInput);\n  inner.appendChild(cross);\n  div.appendChild(inner);\n  this.init = function () {\n    linkInput.focus();\n    if (_mxClient[\"default\"].IS_FF || document.documentMode >= 5 || _mxClient[\"default\"].IS_QUIRKS) {\n      linkInput.select();\n    } else {\n      document.execCommand('selectAll', false, null);\n    }\n  };\n  var btns = document.createElement('div');\n  btns.style.marginTop = '18px';\n  btns.style.textAlign = 'right';\n  _mxEvent[\"default\"].addListener(linkInput, 'keypress', function (e) {\n    if (e.keyCode == 13) {\n      editorUi.hideDialog();\n      fn(linkInput.value);\n    }\n  });\n  var cancelBtn = _mxUtils[\"default\"].button(_mxResources[\"default\"].get('cancel'), function () {\n    editorUi.hideDialog();\n  });\n  cancelBtn.className = 'geBtn';\n  if (editorUi.editor.cancelFirst) {\n    btns.appendChild(cancelBtn);\n  }\n  var mainBtn = _mxUtils[\"default\"].button(btnLabel, function () {\n    editorUi.hideDialog();\n    fn(linkInput.value);\n  });\n  mainBtn.className = 'geBtn gePrimaryBtn';\n  btns.appendChild(mainBtn);\n  if (!editorUi.editor.cancelFirst) {\n    btns.appendChild(cancelBtn);\n  }\n  div.appendChild(btns);\n  this.container = div;\n};\n\n/**\r\n * \r\n */\nvar _default = exports[\"default\"] = LinkDialog;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxGraph/LinkDialog.js?");

/***/ }),

/***/ "./src/workflow/mxGraph/Menu.js":
/*!**************************************!*\
  !*** ./src/workflow/mxGraph/Menu.js ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _mxEventObject = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxEventObject.js */ \"./src/workflow/mxClient/mxEventObject.js\"));\nvar _mxResources = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxResources.js */ \"./src/workflow/mxClient/mxResources.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxEventSource = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxEventSource.js */ \"./src/workflow/mxClient/mxEventSource.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction Menu(funct, enabled) {\n  _mxEventSource[\"default\"].call(this);\n  this.funct = funct;\n  this.enabled = enabled != null ? enabled : true;\n}\n;\n\n// Menu inherits from mxEventSource\n_mxGraphUtils[\"default\"].extend(Menu, _mxEventSource[\"default\"]);\n\n/**\r\n * Sets the enabled state of the action and fires a stateChanged event.\r\n */\nMenu.prototype.isEnabled = function () {\n  return this.enabled;\n};\n\n/**\r\n * Sets the enabled state of the action and fires a stateChanged event.\r\n */\nMenu.prototype.setEnabled = function (value) {\n  if (this.enabled != value) {\n    this.enabled = value;\n    this.fireEvent(new _mxEventObject[\"default\"]('stateChanged'));\n  }\n};\n\n/**\r\n * Sets the enabled state of the action and fires a stateChanged event.\r\n */\nMenu.prototype.execute = function (menu, parent) {\n  this.funct(menu, parent);\n};\nvar resourceText = \"alreadyConnected=Nodes already connected\\n\" + \"cancel=Cancel\\n\" + \"close=Close\\n\" + \"collapse-expand=Collapse/Expand\\n\" + \"containsValidationErrors=Contains validation errors\\n\" + \"done=Done\\n\" + \"doubleClickOrientation=Doubleclick to Change Orientation\\n\" + \"error=Error\\n\" + \"ok=OK\\n\" + \"updatingDocument=Updating Document. Please wait...\\n\" + \"updatingSelection=Updating Selection. Please wait...\\n\" + \"about=About\\n\" + \"actualSize=Actual Size\\n\" + \"add=Add\\n\" + \"addLayer=Add Layer\\n\" + \"addProperty=Add Property\\n\" + \"addToExistingDrawing=Add to Existing Drawing\\n\" + \"addWaypoint=Add Waypoint\\n\" + \"advanced=Advanced\\n\" + \"align=Align\\n\" + \"alignment=Alignment\\n\" + \"allChangesLost=All changes will be lost!\\n\" + \"angle=Angle\\n\" + \"apply=Apply\\n\" + \"arrange=Arrange\\n\" + \"arrow=Arrow\\n\" + \"arrows=Arrows\\n\" + \"automatic=Automatic\\n\" + \"autosave=Autosave\\n\" + \"autosize=Autosize\\n\" + \"background=Background\\n\" + \"backgroundColor=Background Color\\n\" + \"backgroundImage=Background Image\\n\" + \"basic=Basic\\n\" + \"block=Block\\n\" + \"blockquote=Blockquote\\n\" + \"bold=Bold\\n\" + \"borderWidth=Borderwidth\\n\" + \"borderColor=Border Color\\n\" + \"bottom=Bottom\\n\" + \"bottomAlign=Bottom Align\\n\" + \"bottomLeft=Bottom Left\\n\" + \"bottomRight=Bottom Right\\n\" + \"bulletedList=Bulleted List\\n\" + \"cannotOpenFile=Cannot open file\\n\" + \"center=Center\\n\" + \"change=Change\\n\" + \"changeOrientation=Change Orientation\\n\" + \"circle=Circle\\n\" + \"classic=Classic\\n\" + \"clearDefaultStyle=Clear Default Style\\n\" + \"clearWaypoints=Clear Waypoints\\n\" + \"clipart=Clipart\\n\" + \"collapse=Collapse\\n\" + \"collapseExpand=Collapse/Expand\\n\" + \"collapsible=Collapsible\\n\" + \"comic=Comic\\n\" + \"connect=Connect\\n\" + \"connection=Connection\\n\" + \"connectionPoints=Connection points\\n\" + \"connectionArrows=Connection arrows\\n\" + \"constrainProportions=Constrain Proportions\\n\" + \"copy=Copy\\n\" + \"copyConnect=Copy on Connect\\n\" + \"create=Create\\n\" + \"curved=Curved\\n\" + \"custom=Custom\\n\" + \"cut=Cut\\n\" + \"dashed=Dashed\\n\" + \"decreaseIndent=Decrease Indent\\n\" + \"default=Default\\n\" + \"delete=Delete\\n\" + \"deleteColumn=Delete Column\\n\" + \"deleteRow=Delete Row\\n\" + \"diagram=Diagram\\n\" + \"diamond=Diamond\\n\" + \"diamondThin=Diamond (thin)\\n\" + \"direction=Direction\\n\" + \"distribute=Distribute\\n\" + \"divider=Divider\\n\" + \"documentProperties=Document Properties\\n\" + \"dotted=Dotted\\n\" + \"drawing=Drawing{1}\\n\" + \"drawingEmpty=Drawing is empty\\n\" + \"drawingTooLarge=Drawing is too large\\n\" + \"duplicate=Duplicate\\n\" + \"duplicateIt=Duplicate {1}\\n\" + \"east=East\\n\" + \"edit=Edit\\n\" + \"editData=Edit Data\\n\" + \"editDiagram=Edit Diagram\\n\" + \"editImage=Edit Image\\n\" + \"editLink=Edit Link\\n\" + \"editStyle=Edit Style\\n\" + \"editTooltip=Edit Tooltip\\n\" + \"enterGroup=Enter Group\\n\" + \"enterValue=Enter Value\\n\" + \"enterName=Enter Name\\n\" + \"enterPropertyName=Enter Property Name\\n\" + \"entityRelation=Entity Relation\\n\" + \"exitGroup=Exit Group\\n\" + \"expand=Expand\\n\" + \"export=Export\\n\" + \"extras=Extras\\n\" + \"file=File\\n\" + \"fileNotFound=File not found\\n\" + \"filename=Filename\\n\" + \"fill=Fill\\n\" + \"fillColor=Fill Color\\n\" + \"fitPage=One Page\\n\" + \"fitPageWidth=Page Width\\n\" + \"fitTwoPages=Two Pages\\n\" + \"fitWindow=Fit Window\\n\" + \"flip=Flip\\n\" + \"flipH=Flip Horizontal\\n\" + \"flipV=Flip Vertical\\n\" + \"font=Font\\n\" + \"fontFamily=Font Family\\n\" + \"fontColor=Font Color\\n\" + \"fontSize=Font Size\\n\" + \"format=Format\\n\" + \"formatPanel=Format Panel\\n\" + \"formatPdf=PDF\\n\" + \"formatPng=PNG\\n\" + \"formatGif=GIF\\n\" + \"formatJpg=JPEG\\n\" + \"formatSvg=SVG\\n\" + \"formatXml=XML\\n\" + \"formatted=Formatted\\n\" + \"formattedText=Formatted Text\\n\" + \"general=General\\n\" + \"glass=Glass\\n\" + \"global=Global\\n\" + \"gradient=Gradient\\n\" + \"gradientColor=Color\\n\" + \"grid=Grid\\n\" + \"gridSize=Grid Size\\n\" + \"group=Group\\n\" + \"guides=Guides\\n\" + \"heading=Heading\\n\" + \"height=Height\\n\" + \"help=Help\\n\" + \"hide=Hide\\n\" + \"hideIt=Hide {1}\\n\" + \"hidden=Hidden\\n\" + \"home=Home\\n\" + \"horizontal=Horizontal\\n\" + \"horizontalFlow=Horizontal Flow\\n\" + \"horizontalTree=Horizontal Tree\\n\" + \"html=HTML\\n\" + \"image=Image\\n\" + \"images=Images\\n\" + \"import=Import\\n\" + \"increaseIndent=Increase Indent\\n\" + \"insert=Insert\\n\" + \"insertColumnBefore=Insert Column Left\\n\" + \"insertColumnAfter=Insert Column Right\\n\" + \"insertHorizontalRule=Insert Horizontal Rule\\n\" + \"insertImage=Insert Image\\n\" + \"insertLink=Insert Link\\n\" + \"insertRowBefore=Insert Row Above\\n\" + \"insertRowAfter=Insert Row Below\\n\" + \"invalidName=Invalid name\\n\" + \"invalidOrMissingFile=Invalid or missing file\\n\" + \"isometric=Isometric\\n\" + \"italic=Italic\\n\" + \"layers=Layers\\n\" + \"landscape=Landscape\\n\" + \"laneColor=Lanecolor\\n\" + \"layout=Layout\\n\" + \"left=Left\\n\" + \"leftAlign=Left Align\\n\" + \"leftToRight=Left to Right\\n\" + \"line=Line\\n\" + \"link=Link\\n\" + \"lineend=Line End\\n\" + \"lineheight=Line Height\\n\" + \"linestart=Line Start\\n\" + \"linewidth=Linewidth\\n\" + \"loading=Loading\\n\" + \"lockUnlock=Lock/Unlock\\n\" + \"manual=Manual\\n\" + \"middle=Middle\\n\" + \"misc=Misc\\n\" + \"more=More\\n\" + \"moreResults=More Results\\n\" + \"move=Move\\n\" + \"moveSelectionTo=Move Selection to {1}\\n\" + \"navigation=Navigation\\n\" + \"new=New\\n\" + \"noColor=No Color\\n\" + \"noFiles=No files\\n\" + \"noMoreResults=No more results\\n\" + \"none=None\\n\" + \"noResultsFor=No results for '{1}'\\n\" + \"normal=Normal\\n\" + \"north=North\\n\" + \"numberedList=Numbered List\\n\" + \"opacity=Opacity\\n\" + \"open=Open\\n\" + \"openArrow=Open Arrow\\n\" + \"openFile=Open File\\n\" + \"openLink=Open Link\\n\" + \"openSupported=Supported format is .XML files saved from this software\\n\" + \"openInNewWindow=Open in New Window\\n\" + \"openInThisWindow=Open in this Window\\n\" + \"options=Options\\n\" + \"organic=Organic\\n\" + \"orthogonal=Orthogonal\\n\" + \"outline=Outline\\n\" + \"oval=Oval\\n\" + \"pages=Pages\\n\" + \"pageView=Page View\\n\" + \"pageScale=Page Scale\\n\" + \"pageSetup=Page Setup\\n\" + \"panTooltip=Space+Drag to Scroll\\n\" + \"paperSize=Paper Size\\n\" + \"paste=Paste\\n\" + \"pasteHere=Paste Here\\n\" + \"pattern=Pattern\\n\" + \"perimeter=Perimeter\\n\" + \"placeholders=Placeholders\\n\" + \"plusTooltip=Click to connect and clone (ctrl+click to clone, shift+click to connect). Drag to connect (ctrl+drag to clone).\\n\" + \"portrait=Portrait\\n\" + \"position=Position\\n\" + \"posterPrint=Poster Print\\n\" + \"preview=Preview\\n\" + \"print=Print\\n\" + \"radialTree=Radial Tree\\n\" + \"redo=Redo\\n\" + \"removeFormat=Clear Formatting\\n\" + \"removeFromGroup=Remove from Group\\n\" + \"removeIt=Remove {1}\\n\" + \"removeWaypoint=Remove Waypoint\\n\" + \"rename=Rename\\n\" + \"renameIt=Rename {1}\\n\" + \"replace=Replace\\n\" + \"replaceIt={1} already exists. Do you want to replace it?\\n\" + \"replaceExistingDrawing=Replace existing drawing\\n\" + \"reset=Reset\\n\" + \"resetView=Reset View\\n\" + \"right=Right\\n\" + \"rightAlign=Right Align\\n\" + \"rightToLeft=Right to Left\\n\" + \"rotate=Rotate\\n\" + \"rotateTooltip=Click and drag to rotate, click to turn by 90 degrees\\n\" + \"rotation=Rotation\\n\" + \"rounded=Rounded\\n\" + \"save=Save\\n\" + \"saveAs=Save as\\n\" + \"saved=Saved\\n\" + \"scrollbars=Scrollbars\\n\" + \"search=Search\\n\" + \"searchShapes=Search Shapes\\n\" + \"selectAll=Select All\\n\" + \"selectEdges=Select Edges\\n\" + \"selectFont=Select a Font\\n\" + \"selectNone=Select None\\n\" + \"selectVertices=Select Vertices\\n\" + \"setAsDefaultStyle=Set as Default Style\\n\" + \"shadow=Shadow\\n\" + \"shape=Shape\\n\" + \"sharp=Sharp\\n\" + \"sidebarTooltip=Click to expand. Drag and drop shapes into the diagram. Shift+click to change selection. Alt+click to insert and connect.\\n\" + \"simple=Simple\\n\" + \"simpleArrow=Simple Arrow\\n\" + \"size=Size\\n\" + \"solid=Solid\\n\" + \"sourceSpacing=Source Spacing\\n\" + \"south=South\\n\" + \"spacing=Spacing\\n\" + \"straight=Straight\\n\" + \"strokeColor=Line Color\\n\" + \"style=Style\\n\" + \"subscript=Subscript\\n\" + \"superscript=Superscript\\n\" + \"table=Table\\n\" + \"targetSpacing=Target Spacing\\n\" + \"text=Text\\n\" + \"textAlignment=Text Alignment\\n\" + \"textOpacity=Text Opacity\\n\" + \"toBack=To Back\\n\" + \"toFront=To Front\\n\" + \"tooltips=Tooltips\\n\" + \"top=Top\\n\" + \"topAlign=Top Align\\n\" + \"topLeft=Top Left\\n\" + \"topRight=Top Right\\n\" + \"transparent=Transparent\\n\" + \"turn=Turn\\n\" + \"uml=UML\\n\" + \"underline=Underline\\n\" + \"undo=Undo\\n\" + \"ungroup=Ungroup\\n\" + \"url=URL\\n\" + \"untitledLayer=Untitled Layer\\n\" + \"vertical=Vertical\\n\" + \"verticalFlow=Vertical Flow\\n\" + \"verticalTree=Vertical Tree\\n\" + \"view=View\\n\" + \"waypoints=Waypoints\\n\" + \"west=West\\n\" + \"width=Width\\n\" + \"wordWrap=Word Wrap\\n\" + \"writingDirection=Writing Direction\\n\" + \"zoom=Zoom\\n\" + \"zoomIn=Zoom In\\n\" + \"zoomOut=Zoom Out\";\n_mxResources[\"default\"].parse(resourceText);\nvar _default = exports[\"default\"] = Menu;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxGraph/Menu.js?");

/***/ }),

/***/ "./src/workflow/mxGraph/Menus.js":
/*!***************************************!*\
  !*** ./src/workflow/mxGraph/Menus.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.concat.js */ \"../../node_modules/core-js/modules/es.array.concat.js\");\n__webpack_require__(/*! core-js/modules/es.array.join.js */ \"../../node_modules/core-js/modules/es.array.join.js\");\n__webpack_require__(/*! core-js/modules/es.function.bind.js */ \"../../node_modules/core-js/modules/es.function.bind.js\");\nvar _mxEventObject = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxEventObject.js */ \"./src/workflow/mxClient/mxEventObject.js\"));\nvar _mxHierarchicalLayout = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxHierarchicalLayout.js */ \"./src/workflow/mxClient/mxHierarchicalLayout.js\"));\nvar _mxCircleLayout = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxCircleLayout.js */ \"./src/workflow/mxClient/mxCircleLayout.js\"));\nvar _mxEvent = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxEvent.js */ \"./src/workflow/mxClient/mxEvent.js\"));\nvar _mxMouseEvent = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxMouseEvent.js */ \"./src/workflow/mxClient/mxMouseEvent.js\"));\nvar _ColorDialog = _interopRequireDefault(__webpack_require__(/*! ./ColorDialog.js */ \"./src/workflow/mxGraph/ColorDialog.js\"));\nvar _mxCompactTreeLayout = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxCompactTreeLayout.js */ \"./src/workflow/mxClient/mxCompactTreeLayout.js\"));\nvar _mxFastOrganicLayout = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxFastOrganicLayout.js */ \"./src/workflow/mxClient/mxFastOrganicLayout.js\"));\nvar _Menu = _interopRequireDefault(__webpack_require__(/*! ./Menu.js */ \"./src/workflow/mxGraph/Menu.js\"));\nvar _mxClient = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxClient.js */ \"./src/workflow/mxClient/mxClient.js\"));\nvar _FilenameDialog = _interopRequireDefault(__webpack_require__(/*! ./FilenameDialog.js */ \"./src/workflow/mxGraph/FilenameDialog.js\"));\nvar _mxRadialTreeLayout = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxRadialTreeLayout.js */ \"./src/workflow/mxClient/mxRadialTreeLayout.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxResources = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxResources.js */ \"./src/workflow/mxClient/mxResources.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nvar _mxEdgeHandler = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxEdgeHandler.js */ \"./src/workflow/mxClient/mxEdgeHandler.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nvar Menus = function Menus(editorUi) {\n  this.editorUi = editorUi;\n  this.menus = new Object();\n  this.init();\n\n  // Pre-fetches checkmark image\n  if (!_mxClient[\"default\"].IS_SVG) {\n    new Image().src = this.checkmarkImage;\n  }\n};\n\n/**\r\n * Sets the default font family.\r\n */\nMenus.prototype.defaultFont = 'Helvetica';\n\n/**\r\n * Sets the default font size.\r\n */\nMenus.prototype.defaultFontSize = '12';\n\n/**\r\n * Sets the default font size.\r\n */\nMenus.prototype.defaultMenuItems = ['file', 'edit', 'view', 'arrange', 'extras', 'help'];\n\n/**\r\n * Adds the label menu items to the given menu and parent.\r\n */\nMenus.prototype.defaultFonts = ['Helvetica', 'Verdana', 'Times New Roman', 'Garamond', 'Comic Sans MS', 'Courier New', 'Georgia', 'Lucida Console', 'Tahoma'];\n\n/**\r\n * Adds the label menu items to the given menu and parent.\r\n */\nMenus.prototype.init = function () {\n  var graph = this.editorUi.editor.graph;\n  var isGraphEnabled = _mxGraphUtils[\"default\"].bind(graph, graph.isEnabled);\n  this.customFonts = [];\n  this.customFontSizes = [];\n  this.put('fontFamily', new _Menu[\"default\"](_mxGraphUtils[\"default\"].bind(this, function (menu, parent) {\n    var addItem = _mxGraphUtils[\"default\"].bind(this, function (fontname) {\n      var tr = this.styleChange(menu, fontname, [_mxConstants[\"default\"].STYLE_FONTFAMILY], [fontname], null, parent, function () {\n        document.execCommand('fontname', false, fontname);\n      });\n      tr.firstChild.nextSibling.style.fontFamily = fontname;\n    });\n    for (var i = 0; i < this.defaultFonts.length; i++) {\n      addItem(this.defaultFonts[i]);\n    }\n    menu.addSeparator(parent);\n    if (this.customFonts.length > 0) {\n      for (var i = 0; i < this.customFonts.length; i++) {\n        addItem(this.customFonts[i]);\n      }\n      menu.addSeparator(parent);\n      menu.addItem(_mxResources[\"default\"].get('reset'), null, _mxGraphUtils[\"default\"].bind(this, function () {\n        this.customFonts = [];\n      }), parent);\n      menu.addSeparator(parent);\n    }\n    this.promptChange(menu, _mxResources[\"default\"].get('custom') + '...', '', _mxConstants[\"default\"].DEFAULT_FONTFAMILY, _mxConstants[\"default\"].STYLE_FONTFAMILY, parent, true, _mxGraphUtils[\"default\"].bind(this, function (newValue) {\n      this.customFonts.push(newValue);\n    }));\n  })));\n  this.put('formatBlock', new _Menu[\"default\"](_mxGraphUtils[\"default\"].bind(this, function (menu, parent) {\n    function addItem(label, tag) {\n      return menu.addItem(label, null, _mxGraphUtils[\"default\"].bind(this, function () {\n        // TODO: Check if visible\n        graph.cellEditor.textarea.focus();\n        document.execCommand('formatBlock', false, '<' + tag + '>');\n      }), parent);\n    }\n    ;\n    addItem(_mxResources[\"default\"].get('normal'), 'p');\n    addItem('', 'h1').firstChild.nextSibling.innerHTML = '<h1 style=\"margin:0px;\">' + _mxResources[\"default\"].get('heading') + ' 1</h1>';\n    addItem('', 'h2').firstChild.nextSibling.innerHTML = '<h2 style=\"margin:0px;\">' + _mxResources[\"default\"].get('heading') + ' 2</h2>';\n    addItem('', 'h3').firstChild.nextSibling.innerHTML = '<h3 style=\"margin:0px;\">' + _mxResources[\"default\"].get('heading') + ' 3</h3>';\n    addItem('', 'h4').firstChild.nextSibling.innerHTML = '<h4 style=\"margin:0px;\">' + _mxResources[\"default\"].get('heading') + ' 4</h4>';\n    addItem('', 'h5').firstChild.nextSibling.innerHTML = '<h5 style=\"margin:0px;\">' + _mxResources[\"default\"].get('heading') + ' 5</h5>';\n    addItem('', 'h6').firstChild.nextSibling.innerHTML = '<h6 style=\"margin:0px;\">' + _mxResources[\"default\"].get('heading') + ' 6</h6>';\n    addItem('', 'pre').firstChild.nextSibling.innerHTML = '<pre style=\"margin:0px;\">' + _mxResources[\"default\"].get('formatted') + '</pre>';\n    addItem('', 'blockquote').firstChild.nextSibling.innerHTML = '<blockquote style=\"margin-top:0px;margin-bottom:0px;\">' + _mxResources[\"default\"].get('blockquote') + '</blockquote>';\n  })));\n  this.put('fontSize', new _Menu[\"default\"](_mxGraphUtils[\"default\"].bind(this, function (menu, parent) {\n    var sizes = [6, 8, 9, 10, 11, 12, 14, 18, 24, 36, 48, 72];\n    var addItem = _mxGraphUtils[\"default\"].bind(this, function (fontsize) {\n      this.styleChange(menu, fontsize, [_mxConstants[\"default\"].STYLE_FONTSIZE], [fontsize], null, parent, function () {\n        // Creates an element with arbitrary size 3\n        document.execCommand('fontSize', false, '3');\n\n        // Changes the css font size of the first font element inside the in-place editor with size 3\n        // hopefully the above element that we've just created. LATER: Check for new element using\n        // previous result of getElementsByTagName (see other actions)\n        var elts = graph.cellEditor.textarea.getElementsByTagName('font');\n        for (var i = 0; i < elts.length; i++) {\n          if (elts[i].getAttribute('size') == '3') {\n            elts[i].removeAttribute('size');\n            elts[i].style.fontSize = fontsize + 'px';\n            break;\n          }\n        }\n      });\n    });\n    for (var i = 0; i < sizes.length; i++) {\n      addItem(sizes[i]);\n    }\n    menu.addSeparator(parent);\n    if (this.customFontSizes.length > 0) {\n      for (var i = 0; i < this.customFontSizes.length; i++) {\n        addItem(this.customFontSizes[i]);\n      }\n      menu.addSeparator(parent);\n      menu.addItem(_mxResources[\"default\"].get('reset'), null, _mxGraphUtils[\"default\"].bind(this, function () {\n        this.customFontSizes = [];\n      }), parent);\n      menu.addSeparator(parent);\n    }\n    this.promptChange(menu, _mxResources[\"default\"].get('custom') + '...', '(pt)', '12', _mxConstants[\"default\"].STYLE_FONTSIZE, parent, true, _mxGraphUtils[\"default\"].bind(this, function (newValue) {\n      this.customFontSizes.push(newValue);\n    }));\n  })));\n  this.put('direction', new _Menu[\"default\"](_mxGraphUtils[\"default\"].bind(this, function (menu, parent) {\n    menu.addItem(_mxResources[\"default\"].get('flipH'), null, function () {\n      graph.toggleCellStyles(_mxConstants[\"default\"].STYLE_FLIPH, false);\n    }, parent);\n    menu.addItem(_mxResources[\"default\"].get('flipV'), null, function () {\n      graph.toggleCellStyles(_mxConstants[\"default\"].STYLE_FLIPV, false);\n    }, parent);\n    this.addMenuItems(menu, ['-', 'rotation'], parent);\n  })));\n  this.put('align', new _Menu[\"default\"](_mxGraphUtils[\"default\"].bind(this, function (menu, parent) {\n    menu.addItem(_mxResources[\"default\"].get('leftAlign'), null, function () {\n      graph.alignCells(_mxConstants[\"default\"].ALIGN_LEFT);\n    }, parent);\n    menu.addItem(_mxResources[\"default\"].get('center'), null, function () {\n      graph.alignCells(_mxConstants[\"default\"].ALIGN_CENTER);\n    }, parent);\n    menu.addItem(_mxResources[\"default\"].get('rightAlign'), null, function () {\n      graph.alignCells(_mxConstants[\"default\"].ALIGN_RIGHT);\n    }, parent);\n    menu.addSeparator(parent);\n    menu.addItem(_mxResources[\"default\"].get('topAlign'), null, function () {\n      graph.alignCells(_mxConstants[\"default\"].ALIGN_TOP);\n    }, parent);\n    menu.addItem(_mxResources[\"default\"].get('middle'), null, function () {\n      graph.alignCells(_mxConstants[\"default\"].ALIGN_MIDDLE);\n    }, parent);\n    menu.addItem(_mxResources[\"default\"].get('bottomAlign'), null, function () {\n      graph.alignCells(_mxConstants[\"default\"].ALIGN_BOTTOM);\n    }, parent);\n  })));\n  this.put('distribute', new _Menu[\"default\"](_mxGraphUtils[\"default\"].bind(this, function (menu, parent) {\n    menu.addItem(_mxResources[\"default\"].get('horizontal'), null, function () {\n      graph.distributeCells(true);\n    }, parent);\n    menu.addItem(_mxResources[\"default\"].get('vertical'), null, function () {\n      graph.distributeCells(false);\n    }, parent);\n  })));\n  this.put('layout', new _Menu[\"default\"](_mxGraphUtils[\"default\"].bind(this, function (menu, parent) {\n    menu.addItem(_mxResources[\"default\"].get('horizontalFlow'), null, _mxGraphUtils[\"default\"].bind(this, function () {\n      var layout = new _mxHierarchicalLayout[\"default\"](graph, _mxConstants[\"default\"].DIRECTION_WEST);\n      this.editorUi.executeLayout(function () {\n        var selectionCells = graph.getSelectionCells();\n        layout.execute(graph.getDefaultParent(), selectionCells.length == 0 ? null : selectionCells);\n      }, true);\n    }), parent);\n    menu.addItem(_mxResources[\"default\"].get('verticalFlow'), null, _mxGraphUtils[\"default\"].bind(this, function () {\n      var layout = new _mxHierarchicalLayout[\"default\"](graph, _mxConstants[\"default\"].DIRECTION_NORTH);\n      this.editorUi.executeLayout(function () {\n        var selectionCells = graph.getSelectionCells();\n        layout.execute(graph.getDefaultParent(), selectionCells.length == 0 ? null : selectionCells);\n      }, true);\n    }), parent);\n    menu.addSeparator(parent);\n    menu.addItem(_mxResources[\"default\"].get('horizontalTree'), null, _mxGraphUtils[\"default\"].bind(this, function () {\n      var tmp = graph.getSelectionCell();\n      var roots = null;\n      if (tmp == null || graph.getModel().getChildCount(tmp) == 0) {\n        if (graph.getModel().getEdgeCount(tmp) == 0) {\n          roots = graph.findTreeRoots(graph.getDefaultParent());\n        }\n      } else {\n        roots = graph.findTreeRoots(tmp);\n      }\n      if (roots != null && roots.length > 0) {\n        tmp = roots[0];\n      }\n      if (tmp != null) {\n        var layout = new _mxCompactTreeLayout[\"default\"](graph, true);\n        layout.edgeRouting = false;\n        layout.levelDistance = 30;\n        this.editorUi.executeLayout(function () {\n          layout.execute(graph.getDefaultParent(), tmp);\n        }, true);\n      }\n    }), parent);\n    menu.addItem(_mxResources[\"default\"].get('verticalTree'), null, _mxGraphUtils[\"default\"].bind(this, function () {\n      var tmp = graph.getSelectionCell();\n      var roots = null;\n      if (tmp == null || graph.getModel().getChildCount(tmp) == 0) {\n        if (graph.getModel().getEdgeCount(tmp) == 0) {\n          roots = graph.findTreeRoots(graph.getDefaultParent());\n        }\n      } else {\n        roots = graph.findTreeRoots(tmp);\n      }\n      if (roots != null && roots.length > 0) {\n        tmp = roots[0];\n      }\n      if (tmp != null) {\n        var layout = new _mxCompactTreeLayout[\"default\"](graph, false);\n        layout.edgeRouting = false;\n        layout.levelDistance = 30;\n        this.editorUi.executeLayout(function () {\n          layout.execute(graph.getDefaultParent(), tmp);\n        }, true);\n      }\n    }), parent);\n    menu.addItem(_mxResources[\"default\"].get('radialTree'), null, _mxGraphUtils[\"default\"].bind(this, function () {\n      var tmp = graph.getSelectionCell();\n      var roots = null;\n      if (tmp == null || graph.getModel().getChildCount(tmp) == 0) {\n        if (graph.getModel().getEdgeCount(tmp) == 0) {\n          roots = graph.findTreeRoots(graph.getDefaultParent());\n        }\n      } else {\n        roots = graph.findTreeRoots(tmp);\n      }\n      if (roots != null && roots.length > 0) {\n        tmp = roots[0];\n      }\n      if (tmp != null) {\n        var layout = new _mxRadialTreeLayout[\"default\"](graph, false);\n        layout.levelDistance = 60;\n        layout.autoRadius = true;\n        this.editorUi.executeLayout(function () {\n          layout.execute(graph.getDefaultParent(), tmp);\n          if (!graph.isSelectionEmpty()) {\n            tmp = graph.getModel().getParent(tmp);\n            if (graph.getModel().isVertex(tmp)) {\n              graph.updateGroupBounds([tmp], graph.gridSize * 2, true);\n            }\n          }\n        }, true);\n      }\n    }), parent);\n    menu.addSeparator(parent);\n    menu.addItem(_mxResources[\"default\"].get('organic'), null, _mxGraphUtils[\"default\"].bind(this, function () {\n      var layout = new _mxFastOrganicLayout[\"default\"](graph);\n      this.editorUi.executeLayout(function () {\n        var tmp = graph.getSelectionCell();\n        if (tmp == null || graph.getModel().getChildCount(tmp) == 0) {\n          tmp = graph.getDefaultParent();\n        }\n        layout.execute(tmp);\n        if (graph.getModel().isVertex(tmp)) {\n          graph.updateGroupBounds([tmp], graph.gridSize * 2, true);\n        }\n      }, true);\n    }), parent);\n    menu.addItem(_mxResources[\"default\"].get('circle'), null, _mxGraphUtils[\"default\"].bind(this, function () {\n      var layout = new _mxCircleLayout[\"default\"](graph);\n      this.editorUi.executeLayout(function () {\n        var tmp = graph.getSelectionCell();\n        if (tmp == null || graph.getModel().getChildCount(tmp) == 0) {\n          tmp = graph.getDefaultParent();\n        }\n        layout.execute(tmp);\n        if (graph.getModel().isVertex(tmp)) {\n          graph.updateGroupBounds([tmp], graph.gridSize * 2, true);\n        }\n      }, true);\n    }), parent);\n  })));\n  this.put('navigation', new _Menu[\"default\"](_mxGraphUtils[\"default\"].bind(this, function (menu, parent) {\n    this.addMenuItems(menu, ['home', '-', 'exitGroup', 'enterGroup', '-', 'expand', 'collapse', '-', 'collapsible'], parent);\n  })));\n  this.put('arrange', new _Menu[\"default\"](_mxGraphUtils[\"default\"].bind(this, function (menu, parent) {\n    this.addMenuItems(menu, ['toFront', 'toBack', '-'], parent);\n    this.addSubmenu('direction', menu, parent);\n    this.addMenuItems(menu, ['turn', '-'], parent);\n    this.addSubmenu('align', menu, parent);\n    this.addSubmenu('distribute', menu, parent);\n    menu.addSeparator(parent);\n    this.addSubmenu('navigation', menu, parent);\n    this.addSubmenu('insert', menu, parent);\n    this.addSubmenu('layout', menu, parent);\n    this.addMenuItems(menu, ['-', 'group', 'ungroup', 'removeFromGroup', '-', 'clearWaypoints', 'autosize'], parent);\n  }))).isEnabled = isGraphEnabled;\n  this.put('insert', new _Menu[\"default\"](_mxGraphUtils[\"default\"].bind(this, function (menu, parent) {\n    this.addMenuItems(menu, ['insertLink', 'insertImage'], parent);\n  })));\n  this.put('view', new _Menu[\"default\"](_mxGraphUtils[\"default\"].bind(this, function (menu, parent) {\n    this.addMenuItems(menu, (this.editorUi.format != null ? ['formatPanel'] : []).concat(['outline', 'layers', '-', 'pageView', 'pageScale', '-', 'scrollbars', 'tooltips', '-', 'grid', 'guides', '-', 'connectionArrows', 'connectionPoints', '-', 'resetView', 'zoomIn', 'zoomOut'], parent));\n  })));\n  // Two special dropdowns that are only used in the toolbar\n  this.put('viewPanels', new _Menu[\"default\"](_mxGraphUtils[\"default\"].bind(this, function (menu, parent) {\n    if (this.editorUi.format != null) {\n      this.addMenuItems(menu, ['formatPanel'], parent);\n    }\n    this.addMenuItems(menu, ['outline', 'layers'], parent);\n  })));\n  this.put('viewZoom', new _Menu[\"default\"](_mxGraphUtils[\"default\"].bind(this, function (menu, parent) {\n    this.addMenuItems(menu, ['resetView', '-'], parent);\n    var scales = [0.25, 0.5, 0.75, 1, 1.25, 1.5, 2, 3, 4];\n    for (var i = 0; i < scales.length; i++) {\n      (function (scale) {\n        menu.addItem(scale * 100 + '%', null, function () {\n          graph.zoomTo(scale);\n        }, parent);\n      })(scales[i]);\n    }\n    this.addMenuItems(menu, ['-', 'fitWindow', 'fitPageWidth', 'fitPage', 'fitTwoPages', '-', 'customZoom'], parent);\n  })));\n  this.put('file', new _Menu[\"default\"](_mxGraphUtils[\"default\"].bind(this, function (menu, parent) {\n    this.addMenuItems(menu, ['new', 'open', '-', 'save', 'saveAs', '-', 'import', 'export', '-', 'pageSetup', 'print'], parent);\n  })));\n  this.put('edit', new _Menu[\"default\"](_mxGraphUtils[\"default\"].bind(this, function (menu, parent) {\n    this.addMenuItems(menu, ['undo', 'redo', '-', 'cut', 'copy', 'paste', 'delete', '-', 'duplicate', '-', 'editData', 'editTooltip', 'editStyle', '-', 'editLink', 'openLink', '-', 'selectVertices', 'selectEdges', 'selectAll', 'selectNone', '-', 'lockUnlock']);\n  })));\n  this.put('extras', new _Menu[\"default\"](_mxGraphUtils[\"default\"].bind(this, function (menu, parent) {\n    this.addMenuItems(menu, ['copyConnect', 'collapseExpand', '-', 'editDiagram']);\n  })));\n  this.put('help', new _Menu[\"default\"](_mxGraphUtils[\"default\"].bind(this, function (menu, parent) {\n    this.addMenuItems(menu, ['help', '-', 'about']);\n  })));\n};\n\n/**\r\n * Adds the label menu items to the given menu and parent.\r\n */\nMenus.prototype.put = function (name, menu) {\n  this.menus[name] = menu;\n  return menu;\n};\n\n/**\r\n * Adds the label menu items to the given menu and parent.\r\n */\nMenus.prototype.get = function (name) {\n  return this.menus[name];\n};\n\n/**\r\n * Adds the given submenu.\r\n */\nMenus.prototype.addSubmenu = function (name, menu, parent) {\n  var enabled = this.get(name).isEnabled();\n  if (menu.showDisabled || enabled) {\n    var submenu = menu.addItem(_mxResources[\"default\"].get(name), null, null, parent, null, enabled);\n    this.addMenu(name, menu, submenu);\n  }\n};\n\n/**\r\n * Adds the label menu items to the given menu and parent.\r\n */\nMenus.prototype.addMenu = function (name, popupMenu, parent) {\n  var menu = this.get(name);\n  if (menu != null && (popupMenu.showDisabled || menu.isEnabled())) {\n    this.get(name).execute(popupMenu, parent);\n  }\n};\n\n/**\r\n * Adds a menu item to insert a table.\r\n */\nMenus.prototype.addInsertTableItem = function (menu) {\n  // KNOWN: Does not work in IE8 standards and quirks\n  var graph = this.editorUi.editor.graph;\n  function createTable(rows, cols) {\n    var html = ['<table>'];\n    for (var i = 0; i < rows; i++) {\n      html.push('<tr>');\n      for (var j = 0; j < cols; j++) {\n        html.push('<td><br></td>');\n      }\n      html.push('</tr>');\n    }\n    html.push('</table>');\n    return html.join('');\n  }\n  ;\n\n  // Show table size dialog\n  var elt2 = menu.addItem('', null, _mxGraphUtils[\"default\"].bind(this, function (evt) {\n    var td = graph.getParentByName(_mxEvent[\"default\"].getSource(evt), 'TD');\n    if (td != null) {\n      var row2 = graph.getParentByName(td, 'TR');\n\n      // To find the new link, we create a list of all existing links first\n      // LATER: Refactor for reuse with code for finding inserted image below\n      var tmp = graph.cellEditor.textarea.getElementsByTagName('table');\n      var oldTables = [];\n      for (var i = 0; i < tmp.length; i++) {\n        oldTables.push(tmp[i]);\n      }\n\n      // Finding the new table will work with insertHTML, but IE does not support that\n      graph.container.focus();\n      graph.pasteHtmlAtCaret(createTable(row2.sectionRowIndex + 1, td.cellIndex + 1));\n\n      // Moves cursor to first table cell\n      var newTables = graph.cellEditor.textarea.getElementsByTagName('table');\n      if (newTables.length == oldTables.length + 1) {\n        // Inverse order in favor of appended tables\n        for (var i = newTables.length - 1; i >= 0; i--) {\n          if (i == 0 || newTables[i] != oldTables[i - 1]) {\n            graph.selectNode(newTables[i].rows[0].cells[0]);\n            break;\n          }\n        }\n      }\n    }\n  }));\n\n  // Quirks mode does not add cell padding if cell is empty, needs good old spacer solution\n  var quirksCellHtml = '<img src=\"' + _mxClient[\"default\"].imageBasePath + '/transparent.gif' + '\" width=\"16\" height=\"16\"/>';\n  function createPicker(rows, cols) {\n    var table2 = document.createElement('table');\n    table2.setAttribute('border', '1');\n    table2.style.borderCollapse = 'collapse';\n    if (!_mxClient[\"default\"].IS_QUIRKS) {\n      table2.setAttribute('cellPadding', '8');\n    }\n    for (var i = 0; i < rows; i++) {\n      var row = table2.insertRow(i);\n      for (var j = 0; j < cols; j++) {\n        var cell = row.insertCell(-1);\n        if (_mxClient[\"default\"].IS_QUIRKS) {\n          cell.innerHTML = quirksCellHtml;\n        }\n      }\n    }\n    return table2;\n  }\n  ;\n  function extendPicker(picker, rows, cols) {\n    for (var i = picker.rows.length; i < rows; i++) {\n      var row = picker.insertRow(i);\n      for (var j = 0; j < picker.rows[0].cells.length; j++) {\n        var cell = row.insertCell(-1);\n        if (_mxClient[\"default\"].IS_QUIRKS) {\n          cell.innerHTML = quirksCellHtml;\n        }\n      }\n    }\n    for (var i = 0; i < picker.rows.length; i++) {\n      var row = picker.rows[i];\n      for (var j = row.cells.length; j < cols; j++) {\n        var cell = row.insertCell(-1);\n        if (_mxClient[\"default\"].IS_QUIRKS) {\n          cell.innerHTML = quirksCellHtml;\n        }\n      }\n    }\n  }\n  ;\n  elt2.firstChild.innerHTML = '';\n  var picker = createPicker(5, 5);\n  elt2.firstChild.appendChild(picker);\n  var label = document.createElement('div');\n  label.style.padding = '4px';\n  label.style.fontSize = Menus.prototype.defaultFontSize + 'px';\n  label.innerHTML = '1x1';\n  elt2.firstChild.appendChild(label);\n  _mxEvent[\"default\"].addListener(picker, 'mouseover', function (e) {\n    var td = graph.getParentByName(_mxEvent[\"default\"].getSource(e), 'TD');\n    if (td != null) {\n      var row2 = graph.getParentByName(td, 'TR');\n      extendPicker(picker, Math.min(20, row2.sectionRowIndex + 2), Math.min(20, td.cellIndex + 2));\n      label.innerHTML = td.cellIndex + 1 + 'x' + (row2.sectionRowIndex + 1);\n      for (var i = 0; i < picker.rows.length; i++) {\n        var r = picker.rows[i];\n        for (var j = 0; j < r.cells.length; j++) {\n          var cell = r.cells[j];\n          if (i <= row2.sectionRowIndex && j <= td.cellIndex) {\n            cell.style.backgroundColor = 'blue';\n          } else {\n            cell.style.backgroundColor = 'white';\n          }\n        }\n      }\n      _mxEvent[\"default\"].consume(e);\n    }\n  });\n};\n\n/**\r\n * Adds a style change item to the given menu.\r\n */\nMenus.prototype.edgeStyleChange = function (menu, label, keys, values, sprite, parent, reset) {\n  return menu.addItem(label, null, _mxGraphUtils[\"default\"].bind(this, function () {\n    var graph = this.editorUi.editor.graph;\n    graph.stopEditing(false);\n    graph.getModel().beginUpdate();\n    try {\n      var cells = graph.getSelectionCells();\n      var edges = [];\n      for (var i = 0; i < cells.length; i++) {\n        var cell = cells[i];\n        if (graph.getModel().isEdge(cell)) {\n          if (reset) {\n            var geo = graph.getCellGeometry(cell);\n\n            // Resets all edge points\n            if (geo != null) {\n              geo = geo.clone();\n              geo.points = null;\n              graph.getModel().setGeometry(cell, geo);\n            }\n          }\n          for (var j = 0; j < keys.length; j++) {\n            graph.setCellStyles(keys[j], values[j], [cell]);\n          }\n          edges.push(cell);\n        }\n      }\n      this.editorUi.fireEvent(new _mxEventObject[\"default\"]('styleChanged', 'keys', keys, 'values', values, 'cells', edges));\n    } finally {\n      graph.getModel().endUpdate();\n    }\n  }), parent, sprite);\n};\n\n/**\r\n * Adds a style change item to the given menu.\r\n */\nMenus.prototype.styleChange = function (menu, label, keys, values, sprite, parent, fn) {\n  var apply = this.createStyleChangeFunction(keys, values);\n  return menu.addItem(label, null, _mxGraphUtils[\"default\"].bind(this, function () {\n    var graph = this.editorUi.editor.graph;\n    if (fn != null && graph.cellEditor.isContentEditing()) {\n      fn();\n    } else {\n      apply();\n    }\n  }), parent, sprite);\n};\n\n/**\r\n *\r\n */\nMenus.prototype.createStyleChangeFunction = function (keys, values) {\n  return _mxGraphUtils[\"default\"].bind(this, function () {\n    var graph = this.editorUi.editor.graph;\n    graph.stopEditing(false);\n    graph.getModel().beginUpdate();\n    try {\n      for (var i = 0; i < keys.length; i++) {\n        graph.setCellStyles(keys[i], values[i]);\n      }\n      this.editorUi.fireEvent(new _mxEventObject[\"default\"]('styleChanged', 'keys', keys, 'values', values, 'cells', graph.getSelectionCells()));\n    } finally {\n      graph.getModel().endUpdate();\n    }\n  });\n};\n\n/**\r\n * Adds a style change item with a prompt to the given menu.\r\n */\nMenus.prototype.promptChange = function (menu, label, hint, defaultValue, key, parent, enabled, fn, sprite) {\n  return menu.addItem(label, null, _mxGraphUtils[\"default\"].bind(this, function () {\n    var graph = this.editorUi.editor.graph;\n    var value = defaultValue;\n    var state = graph.getView().getState(graph.getSelectionCell());\n    if (state != null) {\n      value = state.style[key] || value;\n    }\n    var dlg = new _FilenameDialog[\"default\"](this.editorUi, value, _mxResources[\"default\"].get('apply'), _mxGraphUtils[\"default\"].bind(this, function (newValue) {\n      if (newValue != null && newValue.length > 0) {\n        graph.getModel().beginUpdate();\n        try {\n          graph.stopEditing(false);\n          graph.setCellStyles(key, newValue);\n        } finally {\n          graph.getModel().endUpdate();\n        }\n        if (fn != null) {\n          fn(newValue);\n        }\n      }\n    }), _mxResources[\"default\"].get('enterValue') + (hint.length > 0 ? ' ' + hint : ''));\n    this.editorUi.showDialog(dlg.container, 300, 80, true, true);\n    dlg.init();\n  }), parent, sprite, enabled);\n};\n\n/**\r\n * Adds a handler for showing a menu in the given element.\r\n */\nMenus.prototype.pickColor = function (key, cmd, defaultValue) {\n  var graph = this.editorUi.editor.graph;\n  if (cmd != null && graph.cellEditor.isContentEditing()) {\n    // Saves and restores text selection for in-place editor\n    var selState = graph.cellEditor.saveSelection();\n    var dlg = new _ColorDialog[\"default\"](this.editorUi, defaultValue || '000000', _mxGraphUtils[\"default\"].bind(this, function (color) {\n      graph.cellEditor.restoreSelection(selState);\n      document.execCommand(cmd, false, color != _mxConstants[\"default\"].NONE ? color : 'transparent');\n    }), function () {\n      graph.cellEditor.restoreSelection(selState);\n    });\n    this.editorUi.showDialog(dlg.container, 220, 430, true, true);\n    dlg.init();\n  } else {\n    if (this.colorDialog == null) {\n      this.colorDialog = new _ColorDialog[\"default\"](this.editorUi);\n    }\n    this.colorDialog.currentColorKey = key;\n    var state = graph.getView().getState(graph.getSelectionCell());\n    var color = 'none';\n    if (state != null) {\n      color = state.style[key] || color;\n    }\n    if (color == 'none') {\n      color = 'ffffff';\n      this.colorDialog.picker.fromString('ffffff');\n      this.colorDialog.colorInput.value = 'none';\n    } else {\n      this.colorDialog.picker.fromString(color);\n    }\n    this.editorUi.showDialog(this.colorDialog.container, 220, 430, true, true);\n    this.colorDialog.init();\n  }\n};\n\n/**\r\n * Adds a handler for showing a menu in the given element.\r\n */\nMenus.prototype.toggleStyle = function (key, defaultValue) {\n  var graph = this.editorUi.editor.graph;\n  var value = graph.toggleCellStyles(key, defaultValue);\n  this.editorUi.fireEvent(new _mxEventObject[\"default\"]('styleChanged', 'keys', [key], 'values', [value], 'cells', graph.getSelectionCells()));\n};\n\n/**\r\n * Creates the keyboard event handler for the current graph and history.\r\n */\nMenus.prototype.addMenuItem = function (menu, key, parent, trigger, sprite) {\n  var action = this.editorUi.actions.get(key);\n  if (action != null && (menu.showDisabled || action.isEnabled()) && action.visible) {\n    var item = menu.addItem(action.label, null, function () {\n      action.funct(trigger);\n    }, parent, sprite, action.isEnabled());\n\n    // Adds checkmark image\n    if (action.toggleAction && action.isSelected()) {\n      menu.addCheckmark(item, Editor.checkmarkImage);\n    }\n    this.addShortcut(item, action);\n    return item;\n  }\n  return null;\n};\n\n/**\r\n * Adds a checkmark to the given menuitem.\r\n */\nMenus.prototype.addShortcut = function (item, action) {\n  if (action.shortcut != null) {\n    var td = item.firstChild.nextSibling.nextSibling;\n    var span = document.createElement('span');\n    span.style.color = 'gray';\n    _mxGraphUtils[\"default\"].write(span, action.shortcut);\n    td.appendChild(span);\n  }\n};\n\n/**\r\n * Creates the keyboard event handler for the current graph and history.\r\n */\nMenus.prototype.addMenuItems = function (menu, keys, parent, trigger, sprites) {\n  for (var i = 0; i < keys.length; i++) {\n    if (keys[i] == '-') {\n      menu.addSeparator(parent);\n    } else {\n      this.addMenuItem(menu, keys[i], parent, trigger, sprites != null ? sprites[i] : null);\n    }\n  }\n};\n\n/**\r\n * Creates the keyboard event handler for the current graph and history.\r\n */\nMenus.prototype.createPopupMenu = function (menu, cell, evt) {\n  var graph = this.editorUi.editor.graph;\n  menu.smartSeparators = true;\n  if (graph.isSelectionEmpty()) {\n    this.addMenuItems(menu, ['undo', 'redo', '-', 'pasteHere'], null, evt);\n  } else {\n    this.addMenuItems(menu, ['delete', '-', 'cut', 'copy', '-', 'duplicate'], null, evt);\n  }\n  if (graph.getSelectionCount() > 0) {\n    if (graph.getSelectionCount() == 1) {\n      this.addMenuItems(menu, ['setAsDefaultStyle'], null, evt);\n    }\n    menu.addSeparator();\n    cell = graph.getSelectionCell();\n    var state = graph.view.getState(cell);\n    if (state != null) {\n      if (graph.getSelectionCount() == 1) {\n        this.addMenuItems(menu, ['toFront', 'toBack', '-'], null, evt);\n      }\n      if (graph.getModel().isEdge(cell) && _mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_EDGE, null) != 'entityRelationEdgeStyle' && _mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_SHAPE, null) != 'arrow') {\n        var handler = graph.selectionCellsHandler.getHandler(cell);\n        var isWaypoint = false;\n        if (handler instanceof _mxEdgeHandler[\"default\"] && handler.bends != null && handler.bends.length > 2) {\n          var index = handler.getHandleForEvent(graph.updateMouseEvent(new _mxMouseEvent[\"default\"](evt)));\n\n          // Configures removeWaypoint action before execution\n          // Using trigger parameter is cleaner but have to find waypoint here anyway.\n          var rmWaypointAction = this.editorUi.actions.get('removeWaypoint');\n          rmWaypointAction.handler = handler;\n          rmWaypointAction.index = index;\n          isWaypoint = index > 0 && index < handler.bends.length - 1;\n        }\n        this.addMenuItems(menu, ['-', isWaypoint ? 'removeWaypoint' : 'addWaypoint'], null, evt);\n\n        // Adds reset waypoints option if waypoints exist\n        var geo = graph.getModel().getGeometry(cell);\n        if (geo != null && geo.points != null && geo.points.length > 0) {\n          this.addMenuItems(menu, ['clearWaypoints'], null, evt);\n        }\n      }\n      if (graph.getSelectionCount() > 1) {\n        menu.addSeparator();\n        this.addMenuItems(menu, ['group'], null, evt);\n      } else if (graph.getSelectionCount() == 1 && !graph.getModel().isEdge(cell) && !graph.isSwimlane(cell) && graph.getModel().getChildCount(cell) > 0) {\n        menu.addSeparator();\n        this.addMenuItems(menu, ['ungroup'], null, evt);\n      }\n      if (graph.getSelectionCount() == 1) {\n        menu.addSeparator();\n        this.addMenuItems(menu, ['editData', 'editLink'], null, evt);\n\n        // Shows edit image action if there is an image in the style\n        if (graph.getModel().isVertex(cell) && _mxGraphUtils[\"default\"].getValue(state.style, _mxConstants[\"default\"].STYLE_IMAGE, null) != null) {\n          menu.addSeparator();\n          this.addMenuItem(menu, 'image', null, evt).firstChild.nextSibling.innerHTML = _mxResources[\"default\"].get('editImage') + '...';\n        }\n      }\n    }\n  } else {\n    this.addMenuItems(menu, ['-', 'selectVertices', 'selectEdges', '-', 'selectAll'], null, evt);\n  }\n};\nvar _default = exports[\"default\"] = Menus;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxGraph/Menus.js?");

/***/ }),

/***/ "./src/workflow/mxGraph/OpenDialog.js":
/*!********************************************!*\
  !*** ./src/workflow/mxGraph/OpenDialog.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _mxClient = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxClient.js */ \"./src/workflow/mxClient/mxClient.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nvar OpenDialog = function OpenDialog() {\n  var iframe = document.createElement('iframe');\n  iframe.style.backgroundColor = 'transparent';\n  iframe.allowTransparency = 'true';\n  iframe.style.borderStyle = 'none';\n  iframe.style.borderWidth = '0px';\n  iframe.style.overflow = 'hidden';\n  iframe.frameBorder = '0';\n\n  // Adds padding as a workaround for box model in older IE versions\n  var dx = _mxClient[\"default\"].IS_VML && (document.documentMode == null || document.documentMode < 8) ? 20 : 0;\n  iframe.setAttribute('width', (Editor.useLocalStorage ? 640 : 320) + dx + 'px');\n  iframe.setAttribute('height', (Editor.useLocalStorage ? 480 : 220) + dx + 'px');\n  iframe.setAttribute('src', OPEN_FORM);\n  this.container = iframe;\n};\n\n/**\r\n * Constructs a new color dialog.\r\n */\nvar _default = exports[\"default\"] = OpenDialog;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxGraph/OpenDialog.js?");

/***/ }),

/***/ "./src/workflow/mxGraph/OpenFile.js":
/*!******************************************!*\
  !*** ./src/workflow/mxGraph/OpenFile.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.join.js */ \"../../node_modules/core-js/modules/es.array.join.js\");\n__webpack_require__(/*! core-js/modules/es.array.splice.js */ \"../../node_modules/core-js/modules/es.array.splice.js\");\n__webpack_require__(/*! core-js/modules/es.function.bind.js */ \"../../node_modules/core-js/modules/es.function.bind.js\");\nvar _mxPolyline = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxPolyline.js */ \"./src/workflow/mxClient/mxPolyline.js\"));\nvar _mxEvent = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxEvent.js */ \"./src/workflow/mxClient/mxEvent.js\"));\nvar _mxGraph = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxGraph.js */ \"./src/workflow/mxClient/mxGraph.js\"));\nvar _mxConnectionHandler = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxConnectionHandler.js */ \"./src/workflow/mxClient/mxConnectionHandler.js\"));\nvar _mxMouseEvent = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxMouseEvent.js */ \"./src/workflow/mxClient/mxMouseEvent.js\"));\nvar _mxPopupMenu = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxPopupMenu.js */ \"./src/workflow/mxClient/mxPopupMenu.js\"));\nvar _mxGraphModel = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxGraphModel.js */ \"./src/workflow/mxClient/mxGraphModel.js\"));\nvar _mxRectangle = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxRectangle.js */ \"./src/workflow/mxClient/mxRectangle.js\"));\nvar _mxRectangleShape = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxRectangleShape.js */ \"./src/workflow/mxClient/mxRectangleShape.js\"));\nvar _mxClient = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxClient.js */ \"./src/workflow/mxClient/mxClient.js\"));\nvar _mxPoint = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxPoint.js */ \"./src/workflow/mxClient/mxPoint.js\"));\nvar _mxPopupMenuHandler = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxPopupMenuHandler.js */ \"./src/workflow/mxClient/mxPopupMenuHandler.js\"));\nvar _mxGraphHandler = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxGraphHandler.js */ \"./src/workflow/mxClient/mxGraphHandler.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxText = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxText.js */ \"./src/workflow/mxClient/mxText.js\"));\nvar _mxCellMarker = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxCellMarker.js */ \"./src/workflow/mxClient/mxCellMarker.js\"));\nvar _mxGraphView = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxGraphView.js */ \"./src/workflow/mxClient/mxGraphView.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nvar _mxUtils = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxUtils.js */ \"./src/workflow/mxClient/mxUtils.js\"));\nvar _workflowUtil = __webpack_require__(/*! ../util/workflowUtil */ \"./src/workflow/util/workflowUtil.js\");\nvar _mxSvgCanvas2D = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxSvgCanvas2D.js */ \"./src/workflow/mxClient/mxSvgCanvas2D.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nvar OpenFile = function OpenFile(done) {\n  this.producer = null;\n  this.consumer = null;\n  this.done = done;\n};\n\n/**\r\n * Registers the editor from the new window.\r\n */\nOpenFile.prototype.setConsumer = function (value) {\n  this.consumer = value;\n  this.execute();\n};\n\n/**\r\n * Sets the data from the loaded file.\r\n */\nOpenFile.prototype.setData = function (value, filename) {\n  this.data = value;\n  this.filename = filename;\n  this.execute();\n};\n\n/**\r\n * Displays an error message.\r\n */\nOpenFile.prototype.error = function (msg) {\n  this.cancel(true);\n  _mxUtils[\"default\"].alert(msg);\n};\n\n/**\r\n * Consumes the data.\r\n */\nOpenFile.prototype.execute = function () {\n  if (this.consumer != null && this.data != null) {\n    this.cancel(false);\n    this.consumer(this.data, this.filename);\n  }\n};\n\n/**\r\n * Cancels the operation.\r\n */\nOpenFile.prototype.cancel = function (cancel) {\n  if (this.done != null) {\n    this.done(cancel != null ? cancel : true);\n  }\n};\n\n/**\r\n * Static overrides\r\n */\n(function () {\n  // Uses HTML for background pages (to support grid background image)\n  _mxGraphView[\"default\"].prototype.validateBackgroundPage = function () {\n    var graph = this.graph;\n    if (graph.container != null && !graph.transparentBackground) {\n      if (graph.pageVisible) {\n        var bounds = this.getBackgroundPageBounds();\n        if (this.backgroundPageShape == null) {\n          // Finds first element in graph container\n          var firstChild = graph.container.firstChild;\n          while (firstChild != null && firstChild.nodeType != _mxConstants[\"default\"].NODETYPE_ELEMENT) {\n            firstChild = firstChild.nextSibling;\n          }\n          if (firstChild != null) {\n            this.backgroundPageShape = this.createBackgroundPageShape(bounds);\n            this.backgroundPageShape.scale = 1;\n\n            // Shadow filter causes problems in outline window in quirks mode. IE8 standards\n            // also has known rendering issues inside mxWindow but not using shadow is worse.\n            this.backgroundPageShape.isShadow = !_mxClient[\"default\"].IS_QUIRKS;\n            this.backgroundPageShape.dialect = _mxConstants[\"default\"].DIALECT_STRICTHTML;\n            this.backgroundPageShape.init(graph.container);\n\n            // Required for the browser to render the background page in correct order\n            firstChild.style.position = 'absolute';\n            graph.container.insertBefore(this.backgroundPageShape.node, firstChild);\n            this.backgroundPageShape.redraw();\n            this.backgroundPageShape.node.className = 'geBackgroundPage';\n\n            // Adds listener for double click handling on background\n            _mxEvent[\"default\"].addListener(this.backgroundPageShape.node, 'dblclick', _mxGraphUtils[\"default\"].bind(this, function (evt) {\n              graph.dblClick(evt);\n            }));\n\n            // Adds basic listeners for graph event dispatching outside of the\n            // container and finishing the handling of a single gesture\n            _mxEvent[\"default\"].addGestureListeners(this.backgroundPageShape.node, _mxGraphUtils[\"default\"].bind(this, function (evt) {\n              graph.fireMouseEvent(_mxEvent[\"default\"].MOUSE_DOWN, new _mxMouseEvent[\"default\"](evt));\n            }), _mxGraphUtils[\"default\"].bind(this, function (evt) {\n              // Hides the tooltip if mouse is outside container\n              if (graph.tooltipHandler != null && graph.tooltipHandler.isHideOnHover()) {\n                graph.tooltipHandler.hide();\n              }\n              if (graph.isMouseDown && !_mxEvent[\"default\"].isConsumed(evt)) {\n                graph.fireMouseEvent(_mxEvent[\"default\"].MOUSE_MOVE, new _mxMouseEvent[\"default\"](evt));\n              }\n            }), _mxGraphUtils[\"default\"].bind(this, function (evt) {\n              graph.fireMouseEvent(_mxEvent[\"default\"].MOUSE_UP, new _mxMouseEvent[\"default\"](evt));\n            }));\n          }\n        } else {\n          this.backgroundPageShape.scale = 1;\n          this.backgroundPageShape.bounds = bounds;\n          this.backgroundPageShape.redraw();\n        }\n      } else if (this.backgroundPageShape != null) {\n        this.backgroundPageShape.destroy();\n        this.backgroundPageShape = null;\n      }\n      this.validateBackgroundStyles();\n    }\n  };\n\n  // Updates the CSS of the background to draw the grid\n  _mxGraphView[\"default\"].prototype.validateBackgroundStyles = function () {\n    var graph = this.graph;\n    var color = graph.background == null || graph.background == _mxConstants[\"default\"].NONE ? '#ffffff' : graph.background;\n    var gridColor = this.gridColor != color.toLowerCase() ? this.gridColor : '#ffffff';\n    var image = 'none';\n    var position = '';\n    if (graph.isGridEnabled()) {\n      var phase = 10;\n      if (_mxClient[\"default\"].IS_SVG) {\n        // Generates the SVG required for drawing the dynamic grid\n        image = unescape(encodeURIComponent(this.createSvgGrid(gridColor)));\n        image = window.btoa ? btoa(image) : Base64.encode(image, true);\n        image = 'url(' + 'data:image/svg+xml;base64,' + image + ')';\n        phase = graph.gridSize * this.scale * this.gridSteps;\n      } else {\n        // Fallback to grid wallpaper with fixed size\n        image = 'url(' + this.gridImage + ')';\n      }\n      var x0 = 0;\n      var y0 = 0;\n      if (graph.view.backgroundPageShape != null) {\n        var bds = this.getBackgroundPageBounds();\n        x0 = 1 + bds.x;\n        y0 = 1 + bds.y;\n      }\n\n      // Computes the offset to maintain origin for grid\n      position = -Math.round(phase - _mxGraphUtils[\"default\"].mod(this.translate.x * this.scale - x0, phase)) + 'px ' + -Math.round(phase - _mxGraphUtils[\"default\"].mod(this.translate.y * this.scale - y0, phase)) + 'px';\n    }\n    var canvas = graph.view.canvas;\n    if (canvas.ownerSVGElement != null) {\n      canvas = canvas.ownerSVGElement;\n    }\n    if (graph.view.backgroundPageShape != null) {\n      graph.view.backgroundPageShape.node.style.backgroundPosition = position;\n      graph.view.backgroundPageShape.node.style.backgroundImage = image;\n      graph.view.backgroundPageShape.node.style.backgroundColor = color;\n      // graph.container.className = 'geDiagramContainer geDiagramBackdrop';\n      canvas.style.backgroundImage = 'none';\n      canvas.style.backgroundColor = (0, _workflowUtil.isBizFlow)(graph.flowType) ? '#F9FBFF' : '';\n    } else {\n      // graph.container.className = 'geDiagramContainer';\n      canvas.style.backgroundPosition = position;\n      canvas.style.backgroundColor = color;\n      canvas.style.backgroundImage = image;\n    }\n  };\n\n  // Returns the SVG required for painting the background grid.\n  _mxGraphView[\"default\"].prototype.createSvgGrid = function (color) {\n    var tmp = this.graph.gridSize * this.scale;\n    while (tmp < this.minGridSize) {\n      tmp *= 2;\n    }\n    var tmp2 = this.gridSteps * tmp;\n\n    // Small grid lines\n    var d = [];\n    for (var i = 1; i < this.gridSteps; i++) {\n      var tmp3 = i * tmp;\n      d.push('M 0 ' + tmp3 + ' L ' + tmp2 + ' ' + tmp3 + ' M ' + tmp3 + ' 0 L ' + tmp3 + ' ' + tmp2);\n    }\n\n    // KNOWN: Rounding errors for certain scales (eg. 144%, 121% in Chrome, FF and Safari). Workaround\n    // in Chrome is to use 100% for the svg size, but this results in blurred grid for large diagrams.\n    var size = tmp2;\n    var svg = '<svg width=\"' + size + '\" height=\"' + size + '\" xmlns=\"' + _mxConstants[\"default\"].NS_SVG + '\">' + '<defs><pattern id=\"grid\" width=\"' + tmp2 + '\" height=\"' + tmp2 + '\" patternUnits=\"userSpaceOnUse\">' + '<path d=\"' + d.join(' ') + '\" fill=\"none\" stroke=\"' + color + '\" opacity=\"0.2\" stroke-width=\"1\"/>' + '<path d=\"M ' + tmp2 + ' 0 L 0 0 0 ' + tmp2 + '\" fill=\"none\" stroke=\"' + color + '\" stroke-width=\"1\"/>' + '</pattern></defs><rect width=\"100%\" height=\"100%\" fill=\"url(#grid)\"/></svg>';\n    return svg;\n  };\n\n  // Adds panning for the grid with no page view and disabled scrollbars\n  var mxGraphPanGraph = _mxGraph[\"default\"].prototype.panGraph;\n  _mxGraph[\"default\"].prototype.panGraph = function (dx, dy) {\n    mxGraphPanGraph.apply(this, arguments);\n    if (this.shiftPreview1 != null) {\n      var canvas = this.view.canvas;\n      if (canvas.ownerSVGElement != null) {\n        canvas = canvas.ownerSVGElement;\n      }\n      var phase = this.gridSize * this.view.scale * this.view.gridSteps;\n      var position = -Math.round(phase - _mxGraphUtils[\"default\"].mod(this.view.translate.x * this.view.scale + dx, phase)) + 'px ' + -Math.round(phase - _mxGraphUtils[\"default\"].mod(this.view.translate.y * this.view.scale + dy, phase)) + 'px';\n      canvas.style.backgroundPosition = position;\n    }\n  };\n\n  // Draws page breaks only within the page\n  _mxGraph[\"default\"].prototype.updatePageBreaks = function (visible, width, height) {\n    var scale = this.view.scale;\n    var tr = this.view.translate;\n    var fmt = this.pageFormat;\n    var ps = scale * this.pageScale;\n    var bounds2 = this.view.getBackgroundPageBounds();\n    width = bounds2.width;\n    height = bounds2.height;\n    var bounds = new _mxRectangle[\"default\"](scale * tr.x, scale * tr.y, fmt.width * ps, fmt.height * ps);\n\n    // Does not show page breaks if the scale is too small\n    visible = visible && Math.min(bounds.width, bounds.height) > this.minPageBreakDist;\n    var horizontalCount = visible ? Math.ceil(width / bounds.width) - 1 : 0;\n    var verticalCount = visible ? Math.ceil(height / bounds.height) - 1 : 0;\n    var right = bounds2.x + width;\n    var bottom = bounds2.y + height;\n    if (this.horizontalPageBreaks == null && horizontalCount > 0) {\n      this.horizontalPageBreaks = [];\n    }\n    if (this.horizontalPageBreaks != null) {\n      for (var i = 0; i <= horizontalCount; i++) {\n        var pts = [new _mxPoint[\"default\"](bounds2.x + (i + 1) * bounds.width, bounds2.y), new _mxPoint[\"default\"](bounds2.x + (i + 1) * bounds.width, bottom)];\n        if (this.horizontalPageBreaks[i] != null) {\n          this.horizontalPageBreaks[i].points = pts;\n          this.horizontalPageBreaks[i].redraw();\n        } else {\n          var pageBreak = new _mxPolyline[\"default\"](pts, this.pageBreakColor);\n          pageBreak.dialect = this.dialect;\n          pageBreak.isDashed = this.pageBreakDashed;\n          pageBreak.pointerEvents = false;\n          pageBreak.init(this.view.backgroundPane);\n          pageBreak.redraw();\n          this.horizontalPageBreaks[i] = pageBreak;\n        }\n      }\n      for (var i = horizontalCount; i < this.horizontalPageBreaks.length; i++) {\n        this.horizontalPageBreaks[i].destroy();\n      }\n      this.horizontalPageBreaks.splice(horizontalCount, this.horizontalPageBreaks.length - horizontalCount);\n    }\n    if (this.verticalPageBreaks == null && verticalCount > 0) {\n      this.verticalPageBreaks = [];\n    }\n    if (this.verticalPageBreaks != null) {\n      for (var i = 0; i <= verticalCount; i++) {\n        var pts = [new _mxPoint[\"default\"](bounds2.x, bounds2.y + (i + 1) * bounds.height), new _mxPoint[\"default\"](right, bounds2.y + (i + 1) * bounds.height)];\n        if (this.verticalPageBreaks[i] != null) {\n          this.verticalPageBreaks[i].points = pts;\n          this.verticalPageBreaks[i].redraw();\n        } else {\n          var pageBreak = new _mxPolyline[\"default\"](pts, this.pageBreakColor);\n          pageBreak.dialect = this.dialect;\n          pageBreak.isDashed = this.pageBreakDashed;\n          pageBreak.pointerEvents = false;\n          pageBreak.init(this.view.backgroundPane);\n          pageBreak.redraw();\n          this.verticalPageBreaks[i] = pageBreak;\n        }\n      }\n      for (var i = verticalCount; i < this.verticalPageBreaks.length; i++) {\n        this.verticalPageBreaks[i].destroy();\n      }\n      this.verticalPageBreaks.splice(verticalCount, this.verticalPageBreaks.length - verticalCount);\n    }\n  };\n\n  // Disables removing relative children from parents\n  var mxGraphHandlerShouldRemoveCellsFromParent = _mxGraphHandler[\"default\"].prototype.shouldRemoveCellsFromParent;\n  _mxGraphHandler[\"default\"].prototype.shouldRemoveCellsFromParent = function (parent, cells, evt) {\n    for (var i = 0; i < cells.length; i++) {\n      if (this.graph.getModel().isVertex(cells[i])) {\n        var geo = this.graph.getCellGeometry(cells[i]);\n        if (geo != null && geo.relative) {\n          return false;\n        }\n      }\n    }\n    return mxGraphHandlerShouldRemoveCellsFromParent.apply(this, arguments);\n  };\n\n  // Overrides to ignore hotspot only for target terminal\n  var mxConnectionHandlerCreateMarker = _mxConnectionHandler[\"default\"].prototype.createMarker;\n  _mxConnectionHandler[\"default\"].prototype.createMarker = function () {\n    var marker = mxConnectionHandlerCreateMarker.apply(this, arguments);\n    marker.intersects = _mxGraphUtils[\"default\"].bind(this, function (state, evt) {\n      if (this.isConnecting()) {\n        return true;\n      }\n      return _mxCellMarker[\"default\"].prototype.intersects.apply(marker, arguments);\n    });\n    return marker;\n  };\n\n  // Creates background page shape\n  _mxGraphView[\"default\"].prototype.createBackgroundPageShape = function (bounds) {\n    return new _mxRectangleShape[\"default\"](bounds, '#ffffff', this.graph.isGridEnabled() ? '#cacaca' : '#FFFFFF');\n  };\n\n  // Fits the number of background pages to the graph\n  _mxGraphView[\"default\"].prototype.getBackgroundPageBounds = function () {\n    var gb = this.getGraphBounds();\n\n    // Computes unscaled, untranslated graph bounds\n    var x = gb.width > 0 ? gb.x / this.scale - this.translate.x : 0;\n    var y = gb.height > 0 ? gb.y / this.scale - this.translate.y : 0;\n    var w = gb.width / this.scale;\n    var h = gb.height / this.scale;\n    var fmt = this.graph.pageFormat;\n    var ps = this.graph.pageScale;\n    var pw = fmt.width * ps;\n    var ph = fmt.height * ps;\n    var x0 = Math.floor(Math.min(0, x) / pw);\n    var y0 = Math.floor(Math.min(0, y) / ph);\n    var xe = Math.ceil(Math.max(1, x + w) / pw);\n    var ye = Math.ceil(Math.max(1, y + h) / ph);\n    var rows = xe - x0;\n    var cols = ye - y0;\n    var bounds = new _mxRectangle[\"default\"](this.scale * (this.translate.x + x0 * pw), this.scale * (this.translate.y + y0 * ph), this.scale * rows * pw, this.scale * cols * ph);\n    return bounds;\n  };\n\n  // Add panning for background page in VML\n  var graphPanGraph = _mxGraph[\"default\"].prototype.panGraph;\n  _mxGraph[\"default\"].prototype.panGraph = function (dx, dy) {\n    graphPanGraph.apply(this, arguments);\n    if (this.dialect != _mxConstants[\"default\"].DIALECT_SVG && this.view.backgroundPageShape != null && (!this.useScrollbarsForPanning || !_mxUtils[\"default\"].hasScrollbars(this.container))) {\n      this.view.backgroundPageShape.node.style.marginLeft = dx + 'px';\n      this.view.backgroundPageShape.node.style.marginTop = dy + 'px';\n    }\n  };\n\n  /**\r\n   * Consumes click events for disabled menu items.\r\n   */\n  var mxPopupMenuAddItem = _mxPopupMenu[\"default\"].prototype.addItem;\n  _mxPopupMenu[\"default\"].prototype.addItem = function (title, image, funct, parent, iconCls, enabled) {\n    var result = mxPopupMenuAddItem.apply(this, arguments);\n    if (enabled != null && !enabled) {\n      _mxEvent[\"default\"].addListener(result, 'mousedown', function (evt) {\n        _mxEvent[\"default\"].consume(evt);\n      });\n    }\n    return result;\n  };\n\n  // Selects ancestors before descendants\n  /*var graphHandlerGetInitialCellForEvent = mxGraphHandler.prototype.getInitialCellForEvent;\r\n  mxGraphHandler.prototype.getInitialCellForEvent = function(me)\r\n  {\r\n  \tvar model = this.graph.getModel();\r\n  \tvar psel = model.getParent(this.graph.getSelectionCell());\r\n  \tvar cell = graphHandlerGetInitialCellForEvent.apply(this, arguments);\r\n  \tvar parent = model.getParent(cell);\r\n  \t\r\n  \tif (psel == null || (psel != cell && psel != parent))\r\n  \t{\r\n  \t\twhile (!this.graph.isCellSelected(cell) && !this.graph.isCellSelected(parent) &&\r\n  \t\t\tmodel.isVertex(parent) && !this.graph.isContainer(parent))\r\n  \t\t{\r\n  \t\t\tcell = parent;\r\n  \t\t\tparent = this.graph.getModel().getParent(cell);\r\n  \t\t}\r\n  \t}\r\n  \t\r\n  \treturn cell;\r\n  };*/\n\n  // Selection is delayed to mouseup if ancestor is selected\n  var graphHandlerIsDelayedSelection = _mxGraphHandler[\"default\"].prototype.isDelayedSelection;\n  _mxGraphHandler[\"default\"].prototype.isDelayedSelection = function (cell, me) {\n    var result = graphHandlerIsDelayedSelection.apply(this, arguments);\n    if (!result) {\n      var model = this.graph.getModel();\n      var parent = model.getParent(cell);\n      while (parent != null) {\n        // Inconsistency for unselected parent swimlane is intended for easier moving\n        // of stack layouts where the container title section is too far away\n        if (this.graph.isCellSelected(parent) && model.isVertex(parent)) {\n          result = true;\n          break;\n        }\n        parent = model.getParent(parent);\n      }\n    }\n    return result;\n  };\n\n  // Delayed selection of parent group\n  _mxGraphHandler[\"default\"].prototype.selectDelayed = function (me) {\n    if (!this.graph.popupMenuHandler.isPopupTrigger(me)) {\n      var cell = me.getCell();\n      if (cell == null) {\n        cell = this.cell;\n      }\n\n      // Selects folded cell for hit on folding icon\n      var state = this.graph.view.getState(cell);\n      if (state != null && me.isSource(state.control)) {\n        this.graph.selectCellForEvent(cell, me.getEvent());\n      } else {\n        var model = this.graph.getModel();\n        var parent = model.getParent(cell);\n        while (!this.graph.isCellSelected(parent) && model.isVertex(parent)) {\n          cell = parent;\n          parent = model.getParent(cell);\n        }\n        this.graph.selectCellForEvent(cell, me.getEvent());\n      }\n    }\n  };\n\n  // Returns last selected ancestor\n  _mxPopupMenuHandler[\"default\"].prototype.getCellForPopupEvent = function (me) {\n    var cell = me.getCell();\n    var model = this.graph.getModel();\n    var parent = model.getParent(cell);\n    while (model.isVertex(parent) && !this.graph.isContainer(parent)) {\n      if (this.graph.isCellSelected(parent)) {\n        cell = parent;\n      }\n      parent = model.getParent(parent);\n    }\n    return cell;\n  };\n})();\n\n/**\r\n * Copyright (c) 2006-2012, JGraph Ltd\r\n */\n// Workaround for allowing target=\"_blank\" in HTML sanitizer\n// see https://code.google.com/p/google-caja/issues/detail?can=2&q=&colspec=ID%20Type%20Status%20Priority%20Owner%20Summary&groupby=&sort=&id=1296\nif (typeof html4 !== 'undefined') {\n  html4.ATTRIBS[\"a::target\"] = 0;\n}\n\n/**\r\n * Sets global constants.\r\n */\n// Changes default colors\n_mxConstants[\"default\"].SHADOW_OPACITY = 0.25;\n_mxConstants[\"default\"].SHADOWCOLOR = '#000000';\n_mxConstants[\"default\"].VML_SHADOWCOLOR = '#d0d0d0';\n//页面分隔符颜色\n_mxGraph[\"default\"].prototype.pageBreakColor = '#FFF'; //'#c0c0c0';\n_mxGraph[\"default\"].prototype.pageScale = 1;\n\n// Letter page format is default in US, Canada and Mexico\n(function () {\n  try {\n    if (navigator != null && navigator.language != null) {\n      var lang = navigator.language.toLowerCase();\n      _mxGraph[\"default\"].prototype.pageFormat = lang === 'en-us' || lang === 'en-ca' || lang === 'es-mx' ? _mxConstants[\"default\"].PAGE_FORMAT_LETTER_PORTRAIT : _mxConstants[\"default\"].PAGE_FORMAT_A4_PORTRAIT;\n    }\n  } catch (e) {\n    // ignore\n  }\n})();\n\n// Matches label positions of mxGraph 1.x\n_mxText[\"default\"].prototype.baseSpacingTop = 5;\n_mxText[\"default\"].prototype.baseSpacingBottom = 1;\n\n// Keeps edges between relative child cells inside parent\n_mxGraphModel[\"default\"].prototype.ignoreRelativeEdgeParent = false;\n\n// Defines grid properties\n_mxGraphView[\"default\"].prototype.gridImage = _mxClient[\"default\"].IS_SVG ? 'data:image/gif;base64,R0lGODlhCgAKAJEAAAAAAP///8zMzP///yH5BAEAAAMALAAAAAAKAAoAAAIJ1I6py+0Po2wFADs=' : IMAGE_PATH + '/grid.gif';\n_mxGraphView[\"default\"].prototype.gridSteps = 4;\n_mxGraphView[\"default\"].prototype.minGridSize = 4;\n\n// UrlParams is null in embed mode\n_mxGraphView[\"default\"].prototype.gridColor = '#e0e0e0';\n\n// Alternative text for unsupported foreignObjects\n_mxSvgCanvas2D[\"default\"].prototype.foAltText = '[Not supported by viewer]';\nvar _default = exports[\"default\"] = OpenFile;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxGraph/OpenFile.js?");

/***/ }),

/***/ "./src/workflow/mxGraph/OutlineWindow.js":
/*!***********************************************!*\
  !*** ./src/workflow/mxGraph/OutlineWindow.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.fill.js */ \"../../node_modules/core-js/modules/es.array.fill.js\");\n__webpack_require__(/*! core-js/modules/es.function.bind.js */ \"../../node_modules/core-js/modules/es.function.bind.js\");\nvar _mxEvent = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxEvent.js */ \"./src/workflow/mxClient/mxEvent.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxWindow = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxWindow.js */ \"./src/workflow/mxClient/mxWindow.js\"));\nvar _mxResources = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxResources.js */ \"./src/workflow/mxClient/mxResources.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nvar OutlineWindow = function OutlineWindow(editorUi, x, y, w, h) {\n  var graph = editorUi.editor.graph;\n  var div = document.createElement('div');\n  div.style.position = 'absolute';\n  div.style.width = '100%';\n  div.style.height = '100%';\n  div.style.border = '1px solid whiteSmoke';\n  div.style.overflow = 'hidden';\n  this.window = new _mxWindow[\"default\"](_mxResources[\"default\"].get('outline'), div, x, y, w, h, true, true);\n  this.window.destroyOnClose = false;\n  this.window.setMaximizable(false);\n  this.window.setResizable(true);\n  this.window.setClosable(true);\n  this.window.setVisible(true);\n  this.window.setLocation = function (x, y) {\n    x = Math.max(0, x);\n    y = Math.max(0, y);\n    _mxWindow[\"default\"].prototype.setLocation.apply(this, arguments);\n  };\n  _mxEvent[\"default\"].addListener(window, 'resize', _mxGraphUtils[\"default\"].bind(this, function () {\n    var iw = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;\n    var ih = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;\n    var x = this.window.getX();\n    var y = this.window.getY();\n    if (x + this.window.table.clientWidth > iw) {\n      x = Math.max(0, iw - this.window.table.clientWidth);\n    }\n    if (y + this.window.table.clientHeight > ih) {\n      y = Math.max(0, ih - this.window.table.clientHeight);\n    }\n    if (this.window.getX() != x || this.window.getY() != y) {\n      this.window.setLocation(x, y);\n    }\n  }));\n  var outline = editorUi.createOutline(this.window);\n  this.window.addListener(_mxEvent[\"default\"].RESIZE, _mxGraphUtils[\"default\"].bind(this, function () {\n    outline.update(false);\n    outline.outline.sizeDidChange();\n  }));\n  this.window.addListener(_mxEvent[\"default\"].SHOW, _mxGraphUtils[\"default\"].bind(this, function () {\n    outline.suspended = false;\n    outline.outline.refresh();\n    outline.update();\n  }));\n  this.window.addListener(_mxEvent[\"default\"].HIDE, _mxGraphUtils[\"default\"].bind(this, function () {\n    outline.suspended = true;\n  }));\n  this.window.addListener(_mxEvent[\"default\"].NORMALIZE, _mxGraphUtils[\"default\"].bind(this, function () {\n    outline.suspended = false;\n    outline.update();\n  }));\n  this.window.addListener(_mxEvent[\"default\"].MINIMIZE, _mxGraphUtils[\"default\"].bind(this, function () {\n    outline.suspended = true;\n  }));\n  var outlineCreateGraph = outline.createGraph;\n  outline.createGraph = function (container) {\n    var g = outlineCreateGraph.apply(this, arguments);\n    g.gridEnabled = false;\n    g.pageScale = graph.pageScale;\n    g.pageFormat = graph.pageFormat;\n    g.background = graph.background;\n    g.pageVisible = graph.pageVisible;\n    var current = _mxGraphUtils[\"default\"].getCurrentStyle(graph.container);\n    div.style.backgroundColor = current.backgroundColor;\n    return g;\n  };\n  function update() {\n    outline.outline.pageScale = graph.pageScale;\n    outline.outline.pageFormat = graph.pageFormat;\n    outline.outline.pageVisible = graph.pageVisible;\n    outline.outline.background = graph.background;\n    var current = _mxGraphUtils[\"default\"].getCurrentStyle(graph.container);\n    div.style.backgroundColor = current.backgroundColor;\n    if (graph.view.backgroundPageShape != null && outline.outline.view.backgroundPageShape != null) {\n      outline.outline.view.backgroundPageShape.fill = graph.view.backgroundPageShape.fill;\n    }\n    outline.outline.refresh();\n  }\n  ;\n  outline.init(div);\n  editorUi.editor.addListener('resetGraphView', update);\n  editorUi.addListener('pageFormatChanged', update);\n  editorUi.addListener('backgroundColorChanged', update);\n  editorUi.addListener('backgroundImageChanged', update);\n  editorUi.addListener('pageViewChanged', function () {\n    update();\n    outline.update(true);\n  });\n  if (outline.outline.dialect == _mxConstants[\"default\"].DIALECT_SVG) {\n    var zoomInAction = editorUi.actions.get('zoomIn');\n    var zoomOutAction = editorUi.actions.get('zoomOut');\n    _mxEvent[\"default\"].addMouseWheelListener(function (evt, up) {\n      var outlineWheel = false;\n      var source = _mxEvent[\"default\"].getSource(evt);\n      while (source != null) {\n        if (source == outline.outline.view.canvas.ownerSVGElement) {\n          outlineWheel = true;\n          break;\n        }\n        source = source.parentNode;\n      }\n      if (outlineWheel) {\n        if (up) {\n          zoomInAction.funct();\n        } else {\n          zoomOutAction.funct();\n        }\n        _mxEvent[\"default\"].consume(evt);\n      }\n    });\n  }\n};\n\n/**\r\n * \r\n */\nvar _default = exports[\"default\"] = OutlineWindow;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxGraph/OutlineWindow.js?");

/***/ }),

/***/ "./src/workflow/mxGraph/PageSetupDialog.js":
/*!*************************************************!*\
  !*** ./src/workflow/mxGraph/PageSetupDialog.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.parse-float.js */ \"../../node_modules/core-js/modules/es.parse-float.js\");\n__webpack_require__(/*! core-js/modules/es.parse-int.js */ \"../../node_modules/core-js/modules/es.parse-int.js\");\nvar _mxEvent = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxEvent.js */ \"./src/workflow/mxClient/mxEvent.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxResources = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxResources.js */ \"./src/workflow/mxClient/mxResources.js\"));\nvar _mxRectangle = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxRectangle.js */ \"./src/workflow/mxClient/mxRectangle.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nvar _mxUtils = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxUtils.js */ \"./src/workflow/mxClient/mxUtils.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nvar PageSetupDialog = function PageSetupDialog(editorUi) {\n  var graph = editorUi.editor.graph;\n  var row, td;\n  var table = document.createElement('table');\n  table.style.width = '100%';\n  table.style.height = '100%';\n  var tbody = document.createElement('tbody');\n  row = document.createElement('tr');\n  td = document.createElement('td');\n  td.style.fontSize = '10pt';\n  _mxGraphUtils[\"default\"].write(td, _mxResources[\"default\"].get('paperSize') + ':');\n  row.appendChild(td);\n  var portraitCheckBox = document.createElement('input');\n  portraitCheckBox.setAttribute('name', 'format');\n  portraitCheckBox.setAttribute('type', 'radio');\n  portraitCheckBox.setAttribute('value', 'portrait');\n  var landscapeCheckBox = document.createElement('input');\n  landscapeCheckBox.setAttribute('name', 'format');\n  landscapeCheckBox.setAttribute('type', 'radio');\n  landscapeCheckBox.setAttribute('value', 'landscape');\n  var formatRow = document.createElement('tr');\n  formatRow.style.display = 'none';\n  var customRow = document.createElement('tr');\n  customRow.style.display = 'none';\n\n  // Adds all papersize options\n  var paperSizeSelect = document.createElement('select');\n  var detected = false;\n  var pf = new Object();\n  var formats = PageSetupDialog.getFormats();\n  for (var i = 0; i < formats.length; i++) {\n    var f = formats[i];\n    pf[f.key] = f;\n    var paperSizeOption = document.createElement('option');\n    paperSizeOption.setAttribute('value', f.key);\n    _mxGraphUtils[\"default\"].write(paperSizeOption, f.title);\n    paperSizeSelect.appendChild(paperSizeOption);\n    if (f.format != null) {\n      if (graph.pageFormat.width == f.format.width && graph.pageFormat.height == f.format.height) {\n        paperSizeOption.setAttribute('selected', 'selected');\n        portraitCheckBox.setAttribute('checked', 'checked');\n        portraitCheckBox.defaultChecked = true;\n        formatRow.style.display = '';\n        detected = true;\n      } else if (graph.pageFormat.width == f.format.height && graph.pageFormat.height == f.format.width) {\n        paperSizeOption.setAttribute('selected', 'selected');\n        landscapeCheckBox.setAttribute('checked', 'checked');\n        portraitCheckBox.defaultChecked = true;\n        formatRow.style.display = '';\n        detected = true;\n      }\n    }\n    // Selects custom format which is last in list\n    else if (!detected) {\n      paperSizeOption.setAttribute('selected', 'selected');\n      customRow.style.display = '';\n    }\n  }\n  td = document.createElement('td');\n  td.style.fontSize = '10pt';\n  td.appendChild(paperSizeSelect);\n  row.appendChild(td);\n  tbody.appendChild(row);\n  formatRow = document.createElement('tr');\n  formatRow.style.height = '40px';\n  td = document.createElement('td');\n  formatRow.appendChild(td);\n  td = document.createElement('td');\n  td.style.fontSize = '10pt';\n  td.appendChild(portraitCheckBox);\n  var span = document.createElement('span');\n  _mxGraphUtils[\"default\"].write(span, ' ' + _mxResources[\"default\"].get('portrait'));\n  td.appendChild(span);\n  _mxEvent[\"default\"].addListener(span, 'click', function (evt) {\n    portraitCheckBox.checked = true;\n    _mxEvent[\"default\"].consume(evt);\n  });\n  landscapeCheckBox.style.marginLeft = '10px';\n  td.appendChild(landscapeCheckBox);\n  var span = document.createElement('span');\n  _mxGraphUtils[\"default\"].write(span, ' ' + _mxResources[\"default\"].get('landscape'));\n  td.appendChild(span);\n  _mxEvent[\"default\"].addListener(span, 'click', function (evt) {\n    landscapeCheckBox.checked = true;\n    _mxEvent[\"default\"].consume(evt);\n  });\n  formatRow.appendChild(td);\n  tbody.appendChild(formatRow);\n  row = document.createElement('tr');\n  td = document.createElement('td');\n  customRow.appendChild(td);\n  td = document.createElement('td');\n  td.style.fontSize = '10pt';\n  var widthInput = document.createElement('input');\n  widthInput.setAttribute('size', '6');\n  widthInput.setAttribute('value', graph.pageFormat.width);\n  td.appendChild(widthInput);\n  _mxGraphUtils[\"default\"].write(td, ' x ');\n  var heightInput = document.createElement('input');\n  heightInput.setAttribute('size', '6');\n  heightInput.setAttribute('value', graph.pageFormat.height);\n  td.appendChild(heightInput);\n  _mxGraphUtils[\"default\"].write(td, ' pt');\n  customRow.appendChild(td);\n  customRow.style.height = formatRow.style.height;\n  tbody.appendChild(customRow);\n  var updateInputs = function updateInputs() {\n    var f = pf[paperSizeSelect.value];\n    if (f.format != null) {\n      widthInput.value = f.format.width;\n      heightInput.value = f.format.height;\n      customRow.style.display = 'none';\n      formatRow.style.display = '';\n    } else {\n      formatRow.style.display = 'none';\n      customRow.style.display = '';\n    }\n  };\n  _mxEvent[\"default\"].addListener(paperSizeSelect, 'change', updateInputs);\n  updateInputs();\n  row = document.createElement('tr');\n  td = document.createElement('td');\n  _mxGraphUtils[\"default\"].write(td, _mxResources[\"default\"].get('background') + ':');\n  row.appendChild(td);\n  td = document.createElement('td');\n  td.style.whiteSpace = 'nowrap';\n  var backgroundInput = document.createElement('input');\n  backgroundInput.setAttribute('type', 'text');\n  var backgroundButton = document.createElement('button');\n  backgroundButton.style.width = '18px';\n  backgroundButton.style.height = '18px';\n  backgroundButton.style.marginRight = '20px';\n  backgroundButton.style.backgroundPosition = 'center center';\n  backgroundButton.style.backgroundRepeat = 'no-repeat';\n  var newBackgroundColor = graph.background;\n  function updateBackgroundColor() {\n    if (newBackgroundColor == null || newBackgroundColor == _mxConstants[\"default\"].NONE) {\n      backgroundButton.style.backgroundColor = '';\n      backgroundButton.style.backgroundImage = 'url(\\'' + Dialog.prototype.noColorImage + '\\')';\n    } else {\n      backgroundButton.style.backgroundColor = newBackgroundColor;\n      backgroundButton.style.backgroundImage = '';\n    }\n  }\n  ;\n  updateBackgroundColor();\n  _mxEvent[\"default\"].addListener(backgroundButton, 'click', function (evt) {\n    editorUi.pickColor(newBackgroundColor || 'none', function (color) {\n      newBackgroundColor = color;\n      updateBackgroundColor();\n    });\n    _mxEvent[\"default\"].consume(evt);\n  });\n  td.appendChild(backgroundButton);\n  _mxGraphUtils[\"default\"].write(td, _mxResources[\"default\"].get('gridSize') + ':');\n  var gridSizeInput = document.createElement('input');\n  gridSizeInput.setAttribute('type', 'number');\n  gridSizeInput.setAttribute('min', '0');\n  gridSizeInput.style.width = '40px';\n  gridSizeInput.style.marginLeft = '6px';\n  gridSizeInput.value = graph.getGridSize();\n  td.appendChild(gridSizeInput);\n  row.appendChild(td);\n  tbody.appendChild(row);\n  row = document.createElement('tr');\n  td = document.createElement('td');\n  _mxGraphUtils[\"default\"].write(td, _mxResources[\"default\"].get('image') + ':');\n  row.appendChild(td);\n  td = document.createElement('td');\n  var changeImageLink = document.createElement('a');\n  changeImageLink.style.textDecoration = 'underline';\n  changeImageLink.style.cursor = 'pointer';\n  changeImageLink.style.color = '#a0a0a0';\n  var newBackgroundImage = graph.backgroundImage;\n  function updateBackgroundImage() {\n    if (newBackgroundImage == null) {\n      changeImageLink.removeAttribute('title');\n      changeImageLink.style.fontSize = '';\n      changeImageLink.innerHTML = _mxResources[\"default\"].get('change') + '...';\n    } else {\n      changeImageLink.setAttribute('title', newBackgroundImage.src);\n      changeImageLink.style.fontSize = '11px';\n      changeImageLink.innerHTML = newBackgroundImage.src.substring(0, 42) + '...';\n    }\n  }\n  ;\n  _mxEvent[\"default\"].addListener(changeImageLink, 'click', function (evt) {\n    editorUi.showBackgroundImageDialog(function (image) {\n      newBackgroundImage = image;\n      updateBackgroundImage();\n    });\n    _mxEvent[\"default\"].consume(evt);\n  });\n  updateBackgroundImage();\n  td.appendChild(changeImageLink);\n  row.appendChild(td);\n  tbody.appendChild(row);\n  row = document.createElement('tr');\n  td = document.createElement('td');\n  td.colSpan = 2;\n  td.style.paddingTop = '16px';\n  td.setAttribute('align', 'right');\n  var cancelBtn = _mxUtils[\"default\"].button(_mxResources[\"default\"].get('cancel'), function () {\n    editorUi.hideDialog();\n  });\n  cancelBtn.className = 'geBtn';\n  if (editorUi.editor.cancelFirst) {\n    td.appendChild(cancelBtn);\n  }\n  var applyBtn = _mxUtils[\"default\"].button(_mxResources[\"default\"].get('apply'), function () {\n    editorUi.hideDialog();\n    var ls = landscapeCheckBox.checked;\n    var f = pf[paperSizeSelect.value];\n    var size = f.format;\n    if (size == null) {\n      size = new _mxRectangle[\"default\"](0, 0, parseInt(widthInput.value), parseInt(heightInput.value));\n    }\n    if (ls) {\n      size = new _mxRectangle[\"default\"](0, 0, size.height, size.width);\n    }\n    editorUi.setPageFormat(size);\n    if (graph.background != newBackgroundColor) {\n      editorUi.setBackgroundColor(newBackgroundColor);\n    }\n    if (graph.backgroundImage !== newBackgroundImage) {\n      editorUi.setBackgroundImage(newBackgroundImage);\n    }\n    if (graph.gridSize !== gridSizeInput.value) {\n      graph.setGridSize(parseFloat(gridSizeInput.value));\n    }\n  });\n  applyBtn.className = 'geBtn gePrimaryBtn';\n  td.appendChild(applyBtn);\n  if (!editorUi.editor.cancelFirst) {\n    td.appendChild(cancelBtn);\n  }\n  row.appendChild(td);\n  tbody.appendChild(row);\n  table.appendChild(tbody);\n  this.container = table;\n};\n\n/**\r\n * \r\n */\nPageSetupDialog.getFormats = function () {\n  return [{\n    key: 'letter',\n    title: 'US-Letter (8,5\" x 11\")',\n    format: _mxConstants[\"default\"].PAGE_FORMAT_LETTER_PORTRAIT\n  }, {\n    key: 'legal',\n    title: 'US-Legal (8,5\" x 14\")',\n    format: new _mxRectangle[\"default\"](0, 0, 850, 1400)\n  }, {\n    key: 'tabloid',\n    title: 'US-Tabloid (279 mm x 432 mm)',\n    format: new _mxRectangle[\"default\"](0, 0, 1100, 1700)\n  }, {\n    key: 'a3',\n    title: 'A3 (297 mm x 420 mm)',\n    format: new _mxRectangle[\"default\"](0, 0, 1169, 1652)\n  }, {\n    key: 'a4',\n    title: 'A4 (210 mm x 297 mm)',\n    format: _mxConstants[\"default\"].PAGE_FORMAT_A4_PORTRAIT\n  }, {\n    key: 'a5',\n    title: 'A5 (148 mm x 210 mm)',\n    format: new _mxRectangle[\"default\"](0, 0, 584, 826)\n  }, {\n    key: 'custom',\n    title: _mxResources[\"default\"].get('custom'),\n    format: null\n  }];\n};\n\n/**\r\n * Constructs a new print dialog.\r\n */\nvar _default = exports[\"default\"] = PageSetupDialog;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxGraph/PageSetupDialog.js?");

/***/ }),

/***/ "./src/workflow/mxGraph/PrintDialog.js":
/*!*********************************************!*\
  !*** ./src/workflow/mxGraph/PrintDialog.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.parse-int.js */ \"../../node_modules/core-js/modules/es.parse-int.js\");\n__webpack_require__(/*! core-js/modules/web.timers.js */ \"../../node_modules/core-js/modules/web.timers.js\");\nvar _mxClient = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxClient.js */ \"./src/workflow/mxClient/mxClient.js\"));\nvar _mxEvent = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxEvent.js */ \"./src/workflow/mxClient/mxEvent.js\"));\nvar _mxPrintPreview = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxPrintPreview.js */ \"./src/workflow/mxClient/mxPrintPreview.js\"));\nvar _mxResources = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxResources.js */ \"./src/workflow/mxClient/mxResources.js\"));\nvar _mxRectangle = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxRectangle.js */ \"./src/workflow/mxClient/mxRectangle.js\"));\nvar _mxConstants = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxConstants.js */ \"./src/workflow/mxClient/mxConstants.js\"));\nvar _mxUtils = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxUtils.js */ \"./src/workflow/mxClient/mxUtils.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nvar PrintDialog = function PrintDialog(editorUi) {\n  this.create(editorUi);\n};\n\n/**\r\n * Constructs a new print dialog.\r\n */\nPrintDialog.prototype.create = function (editorUi) {\n  var graph = editorUi.editor.graph;\n  var row, td;\n  var table = document.createElement('table');\n  table.style.width = '100%';\n  table.style.height = '100%';\n  var tbody = document.createElement('tbody');\n  row = document.createElement('tr');\n  var onePageCheckBox = document.createElement('input');\n  onePageCheckBox.setAttribute('type', 'checkbox');\n  td = document.createElement('td');\n  td.setAttribute('colspan', '2');\n  td.style.fontSize = '10pt';\n  td.appendChild(onePageCheckBox);\n  var span = document.createElement('span');\n  _mxGraphUtils[\"default\"].write(span, ' ' + _mxResources[\"default\"].get('fitPage'));\n  td.appendChild(span);\n  _mxEvent[\"default\"].addListener(span, 'click', function (evt) {\n    onePageCheckBox.checked = !onePageCheckBox.checked;\n    pageCountCheckBox.checked = !onePageCheckBox.checked;\n    _mxEvent[\"default\"].consume(evt);\n  });\n  _mxEvent[\"default\"].addListener(onePageCheckBox, 'change', function () {\n    pageCountCheckBox.checked = !onePageCheckBox.checked;\n  });\n  row.appendChild(td);\n  tbody.appendChild(row);\n  row = row.cloneNode(false);\n  var pageCountCheckBox = document.createElement('input');\n  pageCountCheckBox.setAttribute('type', 'checkbox');\n  td = document.createElement('td');\n  td.style.fontSize = '10pt';\n  td.appendChild(pageCountCheckBox);\n  var span = document.createElement('span');\n  _mxGraphUtils[\"default\"].write(span, ' ' + _mxResources[\"default\"].get('posterPrint') + ':');\n  td.appendChild(span);\n  _mxEvent[\"default\"].addListener(span, 'click', function (evt) {\n    pageCountCheckBox.checked = !pageCountCheckBox.checked;\n    onePageCheckBox.checked = !pageCountCheckBox.checked;\n    _mxEvent[\"default\"].consume(evt);\n  });\n  row.appendChild(td);\n  var pageCountInput = document.createElement('input');\n  pageCountInput.setAttribute('value', '1');\n  pageCountInput.setAttribute('type', 'number');\n  pageCountInput.setAttribute('min', '1');\n  pageCountInput.setAttribute('size', '4');\n  pageCountInput.setAttribute('disabled', 'disabled');\n  pageCountInput.style.width = '50px';\n  td = document.createElement('td');\n  td.style.fontSize = '10pt';\n  td.appendChild(pageCountInput);\n  _mxGraphUtils[\"default\"].write(td, ' ' + _mxResources[\"default\"].get('pages') + ' (max)');\n  row.appendChild(td);\n  tbody.appendChild(row);\n  _mxEvent[\"default\"].addListener(pageCountCheckBox, 'change', function () {\n    if (pageCountCheckBox.checked) {\n      pageCountInput.removeAttribute('disabled');\n    } else {\n      pageCountInput.setAttribute('disabled', 'disabled');\n    }\n    onePageCheckBox.checked = !pageCountCheckBox.checked;\n  });\n  row = row.cloneNode(false);\n  td = document.createElement('td');\n  _mxGraphUtils[\"default\"].write(td, _mxResources[\"default\"].get('pageScale') + ':');\n  row.appendChild(td);\n  td = document.createElement('td');\n  var pageScaleInput = document.createElement('input');\n  pageScaleInput.setAttribute('value', '100 %');\n  pageScaleInput.setAttribute('size', '5');\n  pageScaleInput.style.width = '50px';\n  td.appendChild(pageScaleInput);\n  row.appendChild(td);\n  tbody.appendChild(row);\n  row = document.createElement('tr');\n  td = document.createElement('td');\n  td.colSpan = 2;\n  td.style.paddingTop = '20px';\n  td.setAttribute('align', 'right');\n\n  // Overall scale for print-out to account for print borders in dialogs etc\n  function preview(print) {\n    var autoOrigin = onePageCheckBox.checked || pageCountCheckBox.checked;\n    var printScale = parseInt(pageScaleInput.value) / 100;\n    if (isNaN(printScale)) {\n      printScale = 1;\n      pageScaleInput.value = '100%';\n    }\n\n    // Workaround to match available paper size in actual print output\n    printScale *= 0.75;\n    var pf = graph.pageFormat || _mxConstants[\"default\"].PAGE_FORMAT_A4_PORTRAIT;\n    var scale = 1 / graph.pageScale;\n    if (autoOrigin) {\n      var pageCount = onePageCheckBox.checked ? 1 : parseInt(pageCountInput.value);\n      if (!isNaN(pageCount)) {\n        scale = _mxUtils[\"default\"].getScaleForPageCount(pageCount, graph, pf);\n      }\n    }\n\n    // Negative coordinates are cropped or shifted if page visible\n    var gb = graph.getGraphBounds();\n    var border = 0;\n    var x0 = 0;\n    var y0 = 0;\n\n    // Applies print scale\n    pf = _mxRectangle[\"default\"].fromRectangle(pf);\n    pf.width = Math.ceil(pf.width * printScale);\n    pf.height = Math.ceil(pf.height * printScale);\n    scale *= printScale;\n\n    // Starts at first visible page\n    if (!autoOrigin && graph.pageVisible) {\n      var layout = graph.getPageLayout();\n      x0 -= layout.x * pf.width;\n      y0 -= layout.y * pf.height;\n    } else {\n      autoOrigin = true;\n    }\n    return PrintDialog.showPreview(PrintDialog.createPrintPreview(graph, scale, pf, border, x0, y0, autoOrigin, print), print);\n  }\n  ;\n  var cancelBtn = _mxUtils[\"default\"].button(_mxResources[\"default\"].get('cancel'), function () {\n    editorUi.hideDialog();\n  });\n  cancelBtn.className = 'geBtn';\n  if (editorUi.editor.cancelFirst) {\n    td.appendChild(cancelBtn);\n  }\n  if (!_mxClient[\"default\"].IS_CHROMEAPP) {\n    var previewBtn = _mxUtils[\"default\"].button(_mxResources[\"default\"].get('preview'), function () {\n      editorUi.hideDialog();\n      preview(false);\n    });\n    previewBtn.className = 'geBtn';\n    td.appendChild(previewBtn);\n  }\n  var printBtn = _mxUtils[\"default\"].button(_mxResources[\"default\"].get(_mxClient[\"default\"].IS_CHROMEAPP ? 'ok' : 'print'), function () {\n    editorUi.hideDialog();\n    preview(true);\n  });\n  printBtn.className = 'geBtn gePrimaryBtn';\n  td.appendChild(printBtn);\n  if (!editorUi.editor.cancelFirst) {\n    td.appendChild(cancelBtn);\n  }\n  row.appendChild(td);\n  tbody.appendChild(row);\n  table.appendChild(tbody);\n  this.container = table;\n};\n\n/**\r\n * Constructs a new print dialog.\r\n */\nPrintDialog.showPreview = function (preview, print) {\n  var result = preview.open();\n  if (print && result != null) {\n    var print = function print() {\n      result.focus();\n      result.print();\n      result.close();\n    };\n\n    // Workaround for Google Chrome which needs a bit of a\n    // delay in order to render the SVG contents\n    // Needs testing in production\n    if (_mxClient[\"default\"].IS_GC) {\n      window.setTimeout(print, 500);\n    } else {\n      print();\n    }\n  }\n  return result;\n};\n\n/**\r\n * Constructs a new print dialog.\r\n */\nPrintDialog.createPrintPreview = function (graph, scale, pf, border, x0, y0, autoOrigin) {\n  var preview = new _mxPrintPreview[\"default\"](graph, scale, pf, border, x0, y0);\n  preview.title = _mxResources[\"default\"].get('preview');\n  preview.printBackgroundImage = true;\n  preview.autoOrigin = autoOrigin;\n  var bg = graph.background;\n  if (bg == null || bg == '' || bg == _mxConstants[\"default\"].NONE) {\n    bg = '#ffffff';\n  }\n  preview.backgroundColor = bg;\n  var writeHead = preview.writeHead;\n\n  // Adds a border in the preview\n  preview.writeHead = function (doc) {\n    writeHead.apply(this, arguments);\n    doc.writeln('<style type=\"text/css\">');\n    doc.writeln('@media screen {');\n    doc.writeln('  body > div { padding:30px;box-sizing:content-box; }');\n    doc.writeln('}');\n    doc.writeln('</style>');\n  };\n  return preview;\n};\n\n/**\r\n * Constructs a new filename dialog.\r\n */\nvar _default = exports[\"default\"] = PrintDialog;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxGraph/PrintDialog.js?");

/***/ }),

/***/ "./src/workflow/mxGraph/StackedCard.js":
/*!*********************************************!*\
  !*** ./src/workflow/mxGraph/StackedCard.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.function.name.js */ \"../../node_modules/core-js/modules/es.function.name.js\");\nvar _lodash = _interopRequireDefault(__webpack_require__(/*! lodash */ \"../../node_modules/lodash/lodash.js\"));\nvar _HtmlCard = _interopRequireDefault(__webpack_require__(/*! ./HtmlCard.js */ \"./src/workflow/mxGraph/HtmlCard.js\"));\nvar _mxUtils = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxUtils.js */ \"./src/workflow/mxClient/mxUtils.js\"));\nvar _BillCard = _interopRequireDefault(__webpack_require__(/*! ../css/BillCard.less */ \"./src/workflow/css/BillCard.less\"));\nvar _StackedCard = _interopRequireDefault(__webpack_require__(/*! ../css/StackedCard.less */ \"./src/workflow/css/StackedCard.less\"));\nvar _templateWeb = _interopRequireDefault(__webpack_require__(/*! art-template/lib/template-web.js */ \"../../node_modules/art-template/lib/template-web.js\"));\nvar _HtmlTemplates = __webpack_require__(/*! ./HtmlTemplates.js */ \"./src/workflow/mxGraph/HtmlTemplates.js\");\nvar _icon_receiving_note = _interopRequireDefault(__webpack_require__(/*! ../images/icon_receiving_note.png */ \"./src/workflow/images/icon_receiving_note.png\"));\nvar _noPermission = _interopRequireDefault(__webpack_require__(/*! ../images/no-permission.png */ \"./src/workflow/images/no-permission.png\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction StackedCard() {\n  _HtmlCard[\"default\"].call(this);\n}\n_mxUtils[\"default\"].extend(StackedCard, _HtmlCard[\"default\"]);\nStackedCard.prototype.getCardHTML = function (props) {\n  var data = {};\n  var tpl = null;\n  if (props.lock) {\n    tpl = _HtmlTemplates.stackedCardLockedTpl;\n    data = {\n      lock: props.lock,\n      title: props.title,\n      lockIcon: _noPermission[\"default\"],\n      lockTip: props.lockTip\n    };\n  } else {\n    tpl = _HtmlTemplates.stackedCardTpl;\n    data = {\n      title: props.title,\n      subtitle: props.subtitle,\n      linktitle: props.linktitle,\n      billIcon: _icon_receiving_note[\"default\"],\n      name: props.name,\n      department: props.department,\n      note: props.status\n    };\n  }\n  return _templateWeb[\"default\"].render(tpl, {\n    styles: _lodash[\"default\"].assign({}, _BillCard[\"default\"], _StackedCard[\"default\"]),\n    data: data\n  });\n};\nStackedCard.prototype.getActivatedStyleClass = function () {\n  return _StackedCard[\"default\"].activatedCard;\n};\nvar _default = exports[\"default\"] = StackedCard;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxGraph/StackedCard.js?");

/***/ }),

/***/ "./src/workflow/mxGraph/StatusTip.js":
/*!*******************************************!*\
  !*** ./src/workflow/mxGraph/StatusTip.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\n__webpack_require__(/*! core-js/modules/es.symbol.js */ \"../../node_modules/core-js/modules/es.symbol.js\");\n__webpack_require__(/*! core-js/modules/es.symbol.description.js */ \"../../node_modules/core-js/modules/es.symbol.description.js\");\n__webpack_require__(/*! core-js/modules/es.symbol.iterator.js */ \"../../node_modules/core-js/modules/es.symbol.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.symbol.to-primitive.js */ \"../../node_modules/core-js/modules/es.symbol.to-primitive.js\");\n__webpack_require__(/*! core-js/modules/es.array.iterator.js */ \"../../node_modules/core-js/modules/es.array.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.date.to-primitive.js */ \"../../node_modules/core-js/modules/es.date.to-primitive.js\");\n__webpack_require__(/*! core-js/modules/es.number.constructor.js */ \"../../node_modules/core-js/modules/es.number.constructor.js\");\n__webpack_require__(/*! core-js/modules/es.object.create.js */ \"../../node_modules/core-js/modules/es.object.create.js\");\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\n__webpack_require__(/*! core-js/modules/es.object.get-own-property-descriptor.js */ \"../../node_modules/core-js/modules/es.object.get-own-property-descriptor.js\");\n__webpack_require__(/*! core-js/modules/es.object.get-prototype-of.js */ \"../../node_modules/core-js/modules/es.object.get-prototype-of.js\");\n__webpack_require__(/*! core-js/modules/es.object.to-string.js */ \"../../node_modules/core-js/modules/es.object.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.reflect.construct.js */ \"../../node_modules/core-js/modules/es.reflect.construct.js\");\n__webpack_require__(/*! core-js/modules/es.string.iterator.js */ \"../../node_modules/core-js/modules/es.string.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.weak-map.js */ \"../../node_modules/core-js/modules/es.weak-map.js\");\n__webpack_require__(/*! core-js/modules/web.dom-collections.iterator.js */ \"../../node_modules/core-js/modules/web.dom-collections.iterator.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.function.bind.js */ \"../../node_modules/core-js/modules/es.function.bind.js\");\n__webpack_require__(/*! core-js/modules/es.object.set-prototype-of.js */ \"../../node_modules/core-js/modules/es.object.set-prototype-of.js\");\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"webpack/sharing/consume/default/react/react?dca2\"));\nvar _StatusTip = _interopRequireDefault(__webpack_require__(/*! ../css/StatusTip.less */ \"./src/workflow/css/StatusTip.less\"));\nvar _classnames = _interopRequireDefault(__webpack_require__(/*! classnames */ \"../../node_modules/classnames/index.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nfunction _getRequireWildcardCache(e) { if (\"function\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return { \"default\": e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\"default\" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n[\"default\"] = e, t && t.set(e, n), n; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nvar StatusTip = /*#__PURE__*/function (_Component) {\n  _inherits(StatusTip, _Component);\n  function StatusTip(props) {\n    _classCallCheck(this, StatusTip);\n    return _callSuper(this, StatusTip, [props]);\n  }\n  _createClass(StatusTip, [{\n    key: \"render\",\n    value: function render() {\n      var datas = this.props.datas;\n      var cls = datas.type == 'complete' ? _StatusTip[\"default\"].complete : _StatusTip[\"default\"].underway;\n      return /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _StatusTip[\"default\"].box\n      }, /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _StatusTip[\"default\"].arrow\n      }), /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: _StatusTip[\"default\"].header\n      }, /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n        className: (0, _classnames[\"default\"])(_StatusTip[\"default\"].line, cls)\n      }), /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n        className: (0, _classnames[\"default\"])(_StatusTip[\"default\"].title, _StatusTip[\"default\"].ellipsis),\n        title: datas.title\n      }, datas.title)), /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: (0, _classnames[\"default\"])(_StatusTip[\"default\"].subtitle, _StatusTip[\"default\"].ellipsis),\n        title: datas.first\n      }, datas.first), /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: (0, _classnames[\"default\"])(_StatusTip[\"default\"].tip, _StatusTip[\"default\"].ellipsis),\n        title: datas.second\n      }, datas.second), /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: (0, _classnames[\"default\"])(_StatusTip[\"default\"].tip, _StatusTip[\"default\"].ellipsis),\n        title: datas.third\n      }, datas.third));\n    }\n  }]);\n  return StatusTip;\n}(_react.Component);\nvar _default = exports[\"default\"] = StatusTip;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxGraph/StatusTip.js?");

/***/ }),

/***/ "./src/workflow/mxGraph/TextareaDialog.js":
/*!************************************************!*\
  !*** ./src/workflow/mxGraph/TextareaDialog.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _mxResources = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxResources.js */ \"./src/workflow/mxClient/mxResources.js\"));\nvar _mxGraphUtils = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxGraphUtils.js */ \"./src/workflow/mxClient/mxGraphUtils.js\"));\nvar _mxUtils = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxUtils.js */ \"./src/workflow/mxClient/mxUtils.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nvar TextareaDialog = function TextareaDialog(editorUi, title, url, fn, cancelFn, cancelTitle, w, h, addButtons, noHide) {\n  w = w != null ? w : 300;\n  h = h != null ? h : 120;\n  noHide = noHide != null ? noHide : false;\n  var row, td;\n  var table = document.createElement('table');\n  var tbody = document.createElement('tbody');\n  row = document.createElement('tr');\n  td = document.createElement('td');\n  td.style.fontSize = '10pt';\n  td.style.width = '100px';\n  _mxGraphUtils[\"default\"].write(td, title);\n  row.appendChild(td);\n  tbody.appendChild(row);\n  row = document.createElement('tr');\n  td = document.createElement('td');\n  var nameInput = document.createElement('textarea');\n  _mxGraphUtils[\"default\"].write(nameInput, url || '');\n  nameInput.style.resize = 'none';\n  nameInput.style.width = w + 'px';\n  nameInput.style.height = h + 'px';\n  this.textarea = nameInput;\n  this.init = function () {\n    nameInput.focus();\n    nameInput.scrollTop = 0;\n  };\n  td.appendChild(nameInput);\n  row.appendChild(td);\n  tbody.appendChild(row);\n  row = document.createElement('tr');\n  td = document.createElement('td');\n  td.style.paddingTop = '14px';\n  td.style.whiteSpace = 'nowrap';\n  td.setAttribute('align', 'right');\n  var cancelBtn = _mxUtils[\"default\"].button(cancelTitle || _mxResources[\"default\"].get('cancel'), function () {\n    editorUi.hideDialog();\n    if (cancelFn != null) {\n      cancelFn();\n    }\n  });\n  cancelBtn.className = 'geBtn';\n  if (editorUi.editor.cancelFirst) {\n    td.appendChild(cancelBtn);\n  }\n  if (addButtons != null) {\n    addButtons(td);\n  }\n  if (fn != null) {\n    var genericBtn = _mxUtils[\"default\"].button(_mxResources[\"default\"].get('apply'), function () {\n      if (!noHide) {\n        editorUi.hideDialog();\n      }\n      fn(nameInput.value);\n    });\n    genericBtn.className = 'geBtn gePrimaryBtn';\n    td.appendChild(genericBtn);\n  }\n  if (!editorUi.editor.cancelFirst) {\n    td.appendChild(cancelBtn);\n  }\n  row.appendChild(td);\n  tbody.appendChild(row);\n  table.appendChild(tbody);\n  this.container = table;\n};\n\n/**\r\n * Constructs a new edit file dialog.\r\n */\nvar _default = exports[\"default\"] = TextareaDialog;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/mxGraph/TextareaDialog.js?");

/***/ }),

/***/ "./src/workflow/reducers/index.js":
/*!****************************************!*\
  !*** ./src/workflow/reducers/index.js ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _redux = __webpack_require__(/*! redux */ \"../../node_modules/redux/es/index.js\");\nvar _metadata = _interopRequireDefault(__webpack_require__(/*! ./metadata */ \"./src/workflow/reducers/metadata.js\"));\nvar _ui = _interopRequireDefault(__webpack_require__(/*! ./ui */ \"./src/workflow/reducers/ui.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\nvar _default = exports[\"default\"] = (0, _redux.combineReducers)({\n  metadata: _metadata[\"default\"],\n  ui: _ui[\"default\"]\n});\n\n//# sourceURL=webpack://bos-platform/./src/workflow/reducers/index.js?");

/***/ }),

/***/ "./src/workflow/reducers/metadata.js":
/*!*******************************************!*\
  !*** ./src/workflow/reducers/metadata.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\n__webpack_require__(/*! core-js/modules/es.symbol.js */ \"../../node_modules/core-js/modules/es.symbol.js\");\n__webpack_require__(/*! core-js/modules/es.symbol.description.js */ \"../../node_modules/core-js/modules/es.symbol.description.js\");\n__webpack_require__(/*! core-js/modules/es.symbol.iterator.js */ \"../../node_modules/core-js/modules/es.symbol.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\n__webpack_require__(/*! core-js/modules/es.object.get-own-property-descriptor.js */ \"../../node_modules/core-js/modules/es.object.get-own-property-descriptor.js\");\n__webpack_require__(/*! core-js/modules/es.weak-map.js */ \"../../node_modules/core-js/modules/es.weak-map.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.concat.js */ \"../../node_modules/core-js/modules/es.array.concat.js\");\n__webpack_require__(/*! core-js/modules/es.array.for-each.js */ \"../../node_modules/core-js/modules/es.array.for-each.js\");\n__webpack_require__(/*! core-js/modules/es.array.iterator.js */ \"../../node_modules/core-js/modules/es.array.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.map.js */ \"../../node_modules/core-js/modules/es.map.js\");\n__webpack_require__(/*! core-js/modules/es.object.to-string.js */ \"../../node_modules/core-js/modules/es.object.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.string.iterator.js */ \"../../node_modules/core-js/modules/es.string.iterator.js\");\n__webpack_require__(/*! core-js/modules/web.dom-collections.for-each.js */ \"../../node_modules/core-js/modules/web.dom-collections.for-each.js\");\n__webpack_require__(/*! core-js/modules/web.dom-collections.iterator.js */ \"../../node_modules/core-js/modules/web.dom-collections.iterator.js\");\nvar _immutable = _interopRequireWildcard(__webpack_require__(/*! immutable */ \"webpack/sharing/consume/default/immutable/immutable?f2ca\"));\nvar _actionNames = __webpack_require__(/*! ../constants/actionNames */ \"./src/workflow/constants/actionNames.js\");\nvar _index = __webpack_require__(/*! ../actions/index */ \"./src/workflow/actions/index.js\");\nfunction _getRequireWildcardCache(e) { if (\"function\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return { \"default\": e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\"default\" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n[\"default\"] = e, t && t.set(e, n), n; }\nvar metadataReducer = function metadataReducer() {\n  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _immutable[\"default\"].Map();\n  var action = arguments.length > 1 ? arguments[1] : undefined;\n  switch (action.type) {\n    case _actionNames.set_ui_metadata:\n      return setModelConfigMap(state, action.metadata).set('domainModel', (0, _immutable.fromJS)(action.metadata || {}));\n    case _actionNames.update_ui_metadata:\n      return updateModelConfigMap(state, action.metadata);\n    default:\n      return state;\n  }\n};\n\n//将metadata中的数据转换为map，方便按key获取element的配置(properties...)\nvar setModelConfigMap = function setModelConfigMap(state) {\n  var metadata = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (metadata.Categories) {\n    var map = state.get('modelConfig') || new Map();\n    metadata.Categories.forEach(function (category) {\n      category.ElementTypes && category.ElementTypes.forEach(function (element) {\n        map.set(\"\".concat(category.Id, \"_\").concat(element.Id), element);\n      });\n    });\n    return state.set('modelConfig', map);\n  }\n  return state;\n};\nvar updateModelConfigMap = function updateModelConfigMap(state) {\n  var metadata = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var categories = state.getIn(['domainModel', 'Categories']);\n  return setModelConfigMap(state, metadata).setIn(['domainModel', 'Categories'], categories.concat((0, _immutable.fromJS)(metadata.Categories || [])));\n};\nvar _default = exports[\"default\"] = metadataReducer;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/reducers/metadata.js?");

/***/ }),

/***/ "./src/workflow/reducers/ui.js":
/*!*************************************!*\
  !*** ./src/workflow/reducers/ui.js ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\n__webpack_require__(/*! core-js/modules/es.symbol.js */ \"../../node_modules/core-js/modules/es.symbol.js\");\n__webpack_require__(/*! core-js/modules/es.symbol.description.js */ \"../../node_modules/core-js/modules/es.symbol.description.js\");\n__webpack_require__(/*! core-js/modules/es.symbol.iterator.js */ \"../../node_modules/core-js/modules/es.symbol.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.array.iterator.js */ \"../../node_modules/core-js/modules/es.array.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\n__webpack_require__(/*! core-js/modules/es.object.get-own-property-descriptor.js */ \"../../node_modules/core-js/modules/es.object.get-own-property-descriptor.js\");\n__webpack_require__(/*! core-js/modules/es.object.to-string.js */ \"../../node_modules/core-js/modules/es.object.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.string.iterator.js */ \"../../node_modules/core-js/modules/es.string.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.weak-map.js */ \"../../node_modules/core-js/modules/es.weak-map.js\");\n__webpack_require__(/*! core-js/modules/web.dom-collections.iterator.js */ \"../../node_modules/core-js/modules/web.dom-collections.iterator.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _immutable = __webpack_require__(/*! immutable */ \"webpack/sharing/consume/default/immutable/immutable?f2ca\");\nvar _actionNames = __webpack_require__(/*! ../constants/actionNames */ \"./src/workflow/constants/actionNames.js\");\nvar action = _interopRequireWildcard(__webpack_require__(/*! ../../action/action */ \"./src/action/action.js\"));\nvar _appModelFunction = __webpack_require__(/*! ../../model/appModelFunction */ \"./src/model/appModelFunction.js\");\nvar _mxGraphConstant = __webpack_require__(/*! ../constants/mxGraphConstant */ \"./src/workflow/constants/mxGraphConstant.js\");\nfunction _getRequireWildcardCache(e) { if (\"function\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return { \"default\": e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\"default\" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n[\"default\"] = e, t && t.set(e, n), n; }\nvar uiReducer = function uiReducer() {\n  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : (0, _immutable.Map)();\n  var action = arguments.length > 1 ? arguments[1] : undefined;\n  switch (action.type) {\n    case _actionNames.set_select_control:\n      return state.set('selected_control', (0, _immutable.fromJS)({\n        id: action.id,\n        group: action.group,\n        type: action.ctrlType,\n        collapsed: action.collapsed\n      }));\n    case _actionNames.set_update_control:\n      return state.set('updated_control', (0, _immutable.fromJS)({\n        id: action.id,\n        propName: action.propName,\n        value: action.value\n      }));\n    case _actionNames.activate_cell:\n      return state.set('showApprovalRecords', action.showRecords).set('activatedCell', (0, _immutable.fromJS)({\n        id: action.id,\n        procInstId: action.procInstId,\n        billId: action.billId,\n        title: action.title\n      }));\n    case _actionNames.clean_activated:\n      return state.set('activatedCell', (0, _immutable.Map)({}));\n    case _actionNames.show_floatlayer:\n      return state.set('showFloatLayer', action.showFloatLayer).set('updateFloatLayer', (0, _immutable.fromJS)({\n        id: action.id,\n        procInstId: action.procInstId,\n        billId: action.billId,\n        title: action.title,\n        left: action.left,\n        top: action.top,\n        pageId: action.pageId\n      }));\n    case _actionNames.hide_floatlayer:\n      return state.set('showFloatLayer', action.showFloatLayer).set('updateFloatLayer', (0, _immutable.fromJS)({}));\n    default:\n      return state;\n  }\n};\n\n//设计器打开时由后台发送指令调用\nfunction opendesigner_reduce(state, _ref) {\n  var pageId = _ref.pageId,\n    data = _ref.data;\n  return (0, _appModelFunction.setDataProperty)(pageId, 'workflowdesigner', ['open_args', data[0].key], data[0].args)(state);\n}\nfunction loadSubProcessData(state, _ref2) {\n  var pageId = _ref2.pageId,\n    data = _ref2.data;\n  var procData = data[0].args[0];\n  var id = procData.id;\n  var key = procData.key;\n  var xml = procData.graph_xml;\n  var newState = (0, _appModelFunction.setDataProperty)(pageId, 'workflowdesigner', ['subprocess', key], xml)(state);\n  newState = (0, _appModelFunction.setDataProperty)(pageId, 'workflowdesigner', ['subprocess', _mxGraphConstant.CURRENT_SUBPROCESS_KEY], key)(newState);\n  return (0, _appModelFunction.setDataProperty)(pageId, 'workflowdesigner', ['subprocess', _mxGraphConstant.CURRENT_SUBPROCESS_ID], id)(newState);\n}\nfunction loadApprovalRecords(state, _ref3) {\n  var pageId = _ref3.pageId,\n    data = _ref3.data;\n  var record = data[0].args[0];\n  var newState = (0, _appModelFunction.setDataProperty)(pageId, 'workflowdesigner', 'userOpenId', record.userOpenId)(state);\n  return (0, _appModelFunction.setDataProperty)(pageId, 'workflowdesigner', [\"approvalRecords\", record.key], record)(newState);\n}\nfunction cleanRecordsState(state, _ref4) {\n  var pageId = _ref4.pageId,\n    data = _ref4.data;\n  var newState = (0, _appModelFunction.setDataProperty)(pageId, 'workflowdesigner', 'showCoordinateInfo', {})(state);\n  return (0, _appModelFunction.setDataProperty)(pageId, 'workflowdesigner', \"approvalRecords\", (0, _immutable.Map)({}))(newState);\n}\nfunction showCoordinateState(state, _ref5) {\n  var pageId = _ref5.pageId,\n    data = _ref5.data;\n  var record = data[0].args[0];\n  var existRecord = (0, _appModelFunction.getDataProperty)(pageId, 'workflowdesigner', \"showCoordinateInfo\")(state);\n  if (existRecord == undefined) {\n    existRecord = {};\n  }\n  for (var key in record) {\n    existRecord[key] = record[key];\n  }\n  return (0, _appModelFunction.setDataProperty)(pageId, 'workflowdesigner', \"showCoordinateInfo\", existRecord)(state);\n}\nfunction showBillSummaryInfo_reduce(state, _ref6) {\n  var pageId = _ref6.pageId,\n    data = _ref6.data;\n  return (0, _appModelFunction.setDataProperty)(pageId, 'workflowdesigner', \"showBillSummaryInfo\", data[0].args[0])(state);\n}\naction.addControlReducer('workflowdesigner', 'open', opendesigner_reduce);\naction.addControlReducer('workflowdesigner', 'loadSubProcessData', loadSubProcessData);\naction.addControlReducer('workflowdesigner', 'loadApprovalRecords', loadApprovalRecords);\naction.addControlReducer('workflowdesigner', 'cleanRecordsState', cleanRecordsState);\naction.addControlReducer('workflowdesigner', 'showCoordinateInfo', showCoordinateState);\naction.addControlReducer('workflowdesigner', 'showBillSummaryInfo', showBillSummaryInfo_reduce);\nvar _default = exports[\"default\"] = uiReducer;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/reducers/ui.js?");

/***/ }),

/***/ "./src/workflow/util/graphUtil.js":
/*!****************************************!*\
  !*** ./src/workflow/util/graphUtil.js ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.isDesignGroupNode = isDesignGroupNode;\nexports.selectCell = selectCell;\nexports.selectNode = selectNode;\nexports.selectProcess = selectProcess;\nvar _mxEventObject = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxEventObject */ \"./src/workflow/mxClient/mxEventObject.js\"));\nvar _mxGraphConstant = __webpack_require__(/*! ../constants/mxGraphConstant */ \"./src/workflow/constants/mxGraphConstant.js\");\nvar _mxClient = _interopRequireDefault(__webpack_require__(/*! ../mxClient/mxClient */ \"./src/workflow/mxClient/mxClient.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n//判断是否是“设计”分类下的节点\nfunction isDesignGroupNode(group) {\n  return group === 'DesignControl';\n}\n;\n\n//选中流程\nfunction selectProcess(graph) {\n  graph.getSelectionModel().fireEvent(new _mxEventObject[\"default\"](_mxGraphConstant.EVENT.CHANGE, 'isProcess', true));\n}\n;\n\n//设计器选中节点\nfunction selectNode(graph, cellId) {\n  var cell = null;\n  if (cellId && (cell = graph.getModel().getCell(cellId))) {\n    var isSelected = graph.isCellSelected(cell);\n    var handler = graph.graphHandler;\n    if (handler.isSelectEnabled() && !handler.delayedSelection && (!isSelected || graph.getSelectionCount() != 1)) {\n      graph.setSelectionCell(cell);\n    }\n  }\n}\n;\n\n//查看流程图选中节点\nfunction selectCell(graph, cellId) {\n  var cell = graph.getModel().getCell(cellId);\n  if (cell && cell.isVertex()) {\n    var downEvent = document.createEvent('Event');\n    var upEvent = document.createEvent('Event');\n    downEvent.initEvent(_mxClient[\"default\"].IS_POINTER ? 'pointerdown' : 'mousedown', true, true);\n    upEvent.initEvent(_mxClient[\"default\"].IS_POINTER ? 'pointerup' : 'mouseup', true, true);\n    var state = graph.getView().getState(cell);\n    var node = state.shape.node;\n    //手动触发事件选中节点\n    if (node) {\n      node.dispatchEvent(downEvent);\n      node.dispatchEvent(upEvent);\n    }\n  }\n}\n;\n\n//# sourceURL=webpack://bos-platform/./src/workflow/util/graphUtil.js?");

/***/ }),

/***/ "./src/workflow/util/workflowUtil.js":
/*!*******************************************!*\
  !*** ./src/workflow/util/workflowUtil.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.crateCoordinateInviteOpinions = crateCoordinateInviteOpinions;\nexports.createCustomizedLinks = createCustomizedLinks;\nexports.createSignatureApprovalRecord = createSignatureApprovalRecord;\nexports.getImageUrl = getImageUrl;\nexports.isBizFlow = isBizFlow;\nexports.sanitize = sanitize;\n__webpack_require__(/*! core-js/modules/es.array.concat.js */ \"../../node_modules/core-js/modules/es.array.concat.js\");\n__webpack_require__(/*! core-js/modules/es.array.includes.js */ \"../../node_modules/core-js/modules/es.array.includes.js\");\n__webpack_require__(/*! core-js/modules/es.array.index-of.js */ \"../../node_modules/core-js/modules/es.array.index-of.js\");\n__webpack_require__(/*! core-js/modules/es.regexp.exec.js */ \"../../node_modules/core-js/modules/es.regexp.exec.js\");\n__webpack_require__(/*! core-js/modules/es.string.includes.js */ \"../../node_modules/core-js/modules/es.string.includes.js\");\n__webpack_require__(/*! core-js/modules/es.string.match.js */ \"../../node_modules/core-js/modules/es.string.match.js\");\n__webpack_require__(/*! core-js/modules/es.string.replace.js */ \"../../node_modules/core-js/modules/es.string.replace.js\");\n__webpack_require__(/*! core-js/modules/es.string.search.js */ \"../../node_modules/core-js/modules/es.string.search.js\");\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"webpack/sharing/consume/default/react/react?dca2\"));\nvar _lodash = _interopRequireDefault(__webpack_require__(/*! lodash */ \"../../node_modules/lodash/lodash.js\"));\nvar _sanitizeHtml = _interopRequireDefault(__webpack_require__(/*! sanitize-html */ \"./node_modules/sanitize-html/dist/sanitize-html.js\"));\nvar _imageUtil = __webpack_require__(/*! ../../util/imageUtil */ \"./src/util/imageUtil.js\");\nvar _intlApi = __webpack_require__(/*! ../../i18n/intlApi */ \"./src/i18n/intlApi.js\");\nvar _AbsApprovalRecord = _interopRequireDefault(__webpack_require__(/*! ../css/AbsApprovalRecord.less */ \"./src/workflow/css/AbsApprovalRecord.less\"));\nvar _window$location$sear;\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n/**\n * 获得完整URL\n * @param {string} imgKey 图片原始地址\n */\nfunction getImageUrl(imgKey, fileServer) {\n  return (0, _imageUtil.getImageUrl)(fileServer, imgKey);\n}\n;\nfunction isBizFlow(flowType) {\n  return flowType == \"BizFlow\";\n}\n\n/**\n * 创建审批详情(记录)自定义链接\n * @param item 审批详情(记录)\n * @param 链接点击时的监听\n */\nfunction createCustomizedLinks(item, listener) {\n  var ret = [];\n  var links = item.links,\n    taskId = item.taskId,\n    userStr = item.userStr;\n  if (links && links.length) {\n    var _loop = function _loop() {\n      var link = links[i];\n      link.taskId = taskId;\n      link.userId = userStr;\n      ret.push( /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n        onClick: function onClick(e) {\n          listener(e, link);\n        },\n        title: link.text\n      }, link.text));\n    };\n    //目前只显示两个自定义链接\n    for (var i = 0; i < Math.min(2, links.length); i++) {\n      _loop();\n    }\n  }\n  return ret;\n}\nfunction sanitize(text) {\n  //santize配置\n  var SANITIZE_OPTIONS = {\n    allowedTags: _sanitizeHtml[\"default\"].defaults.allowedTags.concat(['img', 'span', 'colgroup', 'col', 'h1', 'h2']),\n    allowedAttributes: _lodash[\"default\"].extend({}, _sanitizeHtml[\"default\"].defaults.allowedAttributes, {\n      '*': ['style'],\n      'col': ['span'],\n      'table': ['border'],\n      'th': ['colspan', 'rowspan'],\n      'td': ['colspan', 'rowspan'],\n      'img': ['src', 'alt', 'width', 'height'],\n      'iframe': ['src', 'width', 'height']\n    })\n  };\n  text = text || \"\";\n  if (text) {\n    text = text.replace(/<(\\s*\\d+)/g, '&lt;$1').replace(/<(\\s*(\\(|（)+)/g, '&lt;$1');\n  }\n  if (text.indexOf('<') < 0) {\n    text = text.replace(/\\n/g, '<br/>');\n  }\n  return (0, _sanitizeHtml[\"default\"])(text, SANITIZE_OPTIONS);\n}\nfunction crateCoordinateInviteOpinions(params) {\n  var coordInviteOpinion = params.coordInviteOpinion,\n    message = params.message,\n    ownerName = params.ownerName;\n  var coordinateInviteOpinions = \"\";\n  var opinion = coordInviteOpinion && sanitize(coordInviteOpinion);\n  var style = {\n    borderBottom: \"1px solid #DDDDDD\",\n    wordWrap: \"break-word\",\n    wordBreak: \"break-all\"\n  };\n  if (!message) {\n    message = \"\";\n  } else {\n    message = sanitize(message);\n  }\n  if (!opinion) {\n    coordinateInviteOpinions = /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n      dangerouslySetInnerHTML: {\n        __html: message\n      }\n    });\n  } else {\n    coordinateInviteOpinions = /*#__PURE__*/_react[\"default\"].createElement(\"div\", null, /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n      style: style\n    }, /*#__PURE__*/_react[\"default\"].createElement(\"span\", null, ownerName, \"\\uFF1A\"), /*#__PURE__*/_react[\"default\"].createElement(\"span\", {\n      dangerouslySetInnerHTML: {\n        __html: opinion\n      }\n    })), /*#__PURE__*/_react[\"default\"].createElement(\"div\", null, \" \", (0, _intlApi.getLangMsg)({\n      key: \"ApprovalHistoryRecord.xiebanhuifu\"\n    }), \"\\uFF1A\", /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n      dangerouslySetInnerHTML: {\n        __html: message\n      }\n    }), \" \"));\n  }\n  return coordinateInviteOpinions;\n}\nvar KD_DATA_CENTER = (_window$location$sear = window.location.search) === null || _window$location$sear === void 0 || (_window$location$sear = _window$location$sear.match(/(^|&|\\?)kdcdc=([^&]*)(&|$)/i)) === null || _window$location$sear === void 0 ? void 0 : _window$location$sear[2]; // 数据中心\n\n/**\n * @param {boolean} isNew 是否新版\n * @param {String} isPC 是否PC端\n * @param {String} signature 签名\n * @return JSX.Element 手写签名dom\n */\nfunction createSignatureApprovalRecord(isNew, isPC, signature) {\n  if (_lodash[\"default\"].isEmpty(signature)) {\n    return undefined;\n  }\n  var signatureMargin;\n  var isMob = _lodash[\"default\"].isEqual(isPC, 'false');\n  if (isNew) {\n    signatureMargin = '6px 0 10px -9px';\n  } else if (isMob) {\n    signatureMargin = '6px 0 10px -1px';\n  } else {\n    signatureMargin = '4px 0 8px 6px';\n  }\n  var signatureUrl = signature;\n  if (_lodash[\"default\"].isString(signature) && !(signature !== null && signature !== void 0 && signature.includes('kdcdc=')) && KD_DATA_CENTER) {\n    var str = signature.includes('?') ? '&' : '?';\n    signatureUrl = signature + str + 'kdcdc=' + KD_DATA_CENTER;\n  }\n  return /*#__PURE__*/_react[\"default\"].createElement(\"img\", {\n    style: {\n      margin: signatureMargin\n    },\n    className: _AbsApprovalRecord[\"default\"].signature,\n    src: signatureUrl,\n    alt: \"\"\n  });\n}\n\n//# sourceURL=webpack://bos-platform/./src/workflow/util/workflowUtil.js?");

/***/ }),

/***/ "./src/workflow/vendor/sanitizer.min.js":
/*!**********************************************!*\
  !*** ./src/workflow/vendor/sanitizer.min.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! core-js/modules/es.symbol.js */ \"../../node_modules/core-js/modules/es.symbol.js\");\n__webpack_require__(/*! core-js/modules/es.symbol.description.js */ \"../../node_modules/core-js/modules/es.symbol.description.js\");\n__webpack_require__(/*! core-js/modules/es.symbol.iterator.js */ \"../../node_modules/core-js/modules/es.symbol.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.array.iterator.js */ \"../../node_modules/core-js/modules/es.array.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.object.define-property.js */ \"../../node_modules/core-js/modules/es.object.define-property.js\");\n__webpack_require__(/*! core-js/modules/es.string.iterator.js */ \"../../node_modules/core-js/modules/es.string.iterator.js\");\n__webpack_require__(/*! core-js/modules/web.dom-collections.iterator.js */ \"../../node_modules/core-js/modules/web.dom-collections.iterator.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.index-of.js */ \"../../node_modules/core-js/modules/es.array.index-of.js\");\n__webpack_require__(/*! core-js/modules/es.array.join.js */ \"../../node_modules/core-js/modules/es.array.join.js\");\n__webpack_require__(/*! core-js/modules/es.array.last-index-of.js */ \"../../node_modules/core-js/modules/es.array.last-index-of.js\");\n__webpack_require__(/*! core-js/modules/es.array.slice.js */ \"../../node_modules/core-js/modules/es.array.slice.js\");\n__webpack_require__(/*! core-js/modules/es.array.splice.js */ \"../../node_modules/core-js/modules/es.array.splice.js\");\n__webpack_require__(/*! core-js/modules/es.date.to-string.js */ \"../../node_modules/core-js/modules/es.date.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.function.name.js */ \"../../node_modules/core-js/modules/es.function.name.js\");\n__webpack_require__(/*! core-js/modules/es.number.constructor.js */ \"../../node_modules/core-js/modules/es.number.constructor.js\");\n__webpack_require__(/*! core-js/modules/es.object.to-string.js */ \"../../node_modules/core-js/modules/es.object.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.parse-int.js */ \"../../node_modules/core-js/modules/es.parse-int.js\");\n__webpack_require__(/*! core-js/modules/es.regexp.constructor.js */ \"../../node_modules/core-js/modules/es.regexp.constructor.js\");\n__webpack_require__(/*! core-js/modules/es.regexp.exec.js */ \"../../node_modules/core-js/modules/es.regexp.exec.js\");\n__webpack_require__(/*! core-js/modules/es.regexp.to-string.js */ \"../../node_modules/core-js/modules/es.regexp.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.string.match.js */ \"../../node_modules/core-js/modules/es.string.match.js\");\n__webpack_require__(/*! core-js/modules/es.string.replace.js */ \"../../node_modules/core-js/modules/es.string.replace.js\");\n__webpack_require__(/*! core-js/modules/es.string.split.js */ \"../../node_modules/core-js/modules/es.string.split.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\n// NOTE: Modified to support data URIs for images, ie. data:image/*\n(function () {\n  var c = void 0,\n    n = !0,\n    s = null,\n    C = !1,\n    J = [\"aliceblue,antiquewhite,aqua,aquamarine,azure,beige,bisque,black,blanchedalmond,blue,blueviolet,brown,burlywood,cadetblue,chartreuse,chocolate,coral,cornflowerblue,cornsilk,crimson,cyan,darkblue,darkcyan,darkgoldenrod,darkgray,darkgreen,darkkhaki,darkmagenta,darkolivegreen,darkorange,darkorchid,darkred,darksalmon,darkseagreen,darkslateblue,darkslategray,darkturquoise,darkviolet,deeppink,deepskyblue,dimgray,dodgerblue,firebrick,floralwhite,forestgreen,fuchsia,gainsboro,ghostwhite,gold,goldenrod,gray,green,greenyellow,honeydew,hotpink,indianred,indigo,ivory,khaki,lavender,lavenderblush,lawngreen,lemonchiffon,lightblue,lightcoral,lightcyan,lightgoldenrodyellow,lightgreen,lightgrey,lightpink,lightsalmon,lightseagreen,lightskyblue,lightslategray,lightsteelblue,lightyellow,lime,limegreen,linen,magenta,maroon,mediumaquamarine,mediumblue,mediumorchid,mediumpurple,mediumseagreen,mediumslateblue,mediumspringgreen,mediumturquoise,mediumvioletred,midnightblue,mintcream,mistyrose,moccasin,navajowhite,navy,oldlace,olive,olivedrab,orange,orangered,orchid,palegoldenrod,palegreen,paleturquoise,palevioletred,papayawhip,peachpuff,peru,pink,plum,powderblue,purple,red,rosybrown,royalblue,saddlebrown,salmon,sandybrown,seagreen,seashell,sienna,silver,skyblue,slateblue,slategray,snow,springgreen,steelblue,tan,teal,thistle,tomato,transparent,turquoise,violet,wheat,white,whitesmoke,yellow,yellowgreen\".split(\",\"), \"all-scroll,col-resize,crosshair,default,e-resize,hand,help,move,n-resize,ne-resize,no-drop,not-allowed,nw-resize,pointer,progress,row-resize,s-resize,se-resize,sw-resize,text,vertical-text,w-resize,wait\".split(\",\"), \"armenian,decimal,decimal-leading-zero,disc,georgian,lower-alpha,lower-greek,lower-latin,lower-roman,square,upper-alpha,upper-latin,upper-roman\".split(\",\"), \"100,200,300,400,500,600,700,800,900,bold,bolder,lighter\".split(\",\"), \"block-level,inline-level,table-caption,table-cell,table-column,table-column-group,table-footer-group,table-header-group,table-row,table-row-group\".split(\",\"), \"condensed,expanded,extra-condensed,extra-expanded,narrower,semi-condensed,semi-expanded,ultra-condensed,ultra-expanded,wider\".split(\",\"), \"inherit,inline,inline-block,inline-box,inline-flex,inline-grid,inline-list-item,inline-stack,inline-table,run-in\".split(\",\"), \"behind,center-left,center-right,far-left,far-right,left-side,leftwards,right-side,rightwards\".split(\",\"), \"large,larger,small,smaller,x-large,x-small,xx-large,xx-small\".split(\",\"), \"dashed,dotted,double,groove,outset,ridge,solid\".split(\",\"), \"ease,ease-in,ease-in-out,ease-out,linear,step-end,step-start\".split(\",\"), \"at,closest-corner,closest-side,ellipse,farthest-corner,farthest-side\".split(\",\"), \"baseline,middle,sub,super,text-bottom,text-top\".split(\",\"), \"caption,icon,menu,message-box,small-caption,status-bar\".split(\",\"), \"fast,faster,slow,slower,x-fast,x-slow\".split(\",\"), [\"above\", \"below\", \"higher\", \"level\", \"lower\"], [\"cursive\", \"fantasy\", \"monospace\", \"sans-serif\", \"serif\"], [\"loud\", \"silent\", \"soft\", \"x-loud\", \"x-soft\"], [\"no-repeat\", \"repeat-x\", \"repeat-y\", \"round\", \"space\"], [\"blink\", \"line-through\", \"overline\", \"underline\"], [\"block\", \"flex\", \"grid\", \"table\"], [\"high\", \"low\", \"x-high\", \"x-low\"], [\"nowrap\", \"pre\", \"pre-line\", \"pre-wrap\"], [\"absolute\", \"relative\", \"static\"], [\"alternate\", \"alternate-reverse\", \"reverse\"], [\"border-box\", \"content-box\", \"padding-box\"], [\"capitalize\", \"lowercase\", \"uppercase\"], [\"child\", \"female\", \"male\"], [\"=\", \"opacity\"], [\"backwards\", \"forwards\"], [\"bidi-override\", \"embed\"], [\"bottom\", \"top\"], [\"break-all\", \"keep-all\"], [\"clip\", \"ellipsis\"], [\"contain\", \"cover\"], [\"continuous\", \"digits\"], [\"end\", \"start\"], [\"flat\", \"preserve-3d\"], [\"hide\", \"show\"], [\"horizontal\", \"vertical\"], [\"inside\", \"outside\"], [\"italic\", \"oblique\"], [\"left\", \"right\"], [\"ltr\", \"rtl\"], [\"no-content\", \"no-display\"], [\"paused\", \"running\"], [\"suppress\", \"unrestricted\"], [\"thick\", \"thin\"], [\",\"], [\"/\"], [\"all\"], [\"always\"], [\"auto\"], [\"avoid\"], [\"both\"], [\"break-word\"], [\"center\"], [\"circle\"], [\"code\"], [\"collapse\"], [\"contents\"], [\"fixed\"], [\"hidden\"], [\"infinite\"], [\"inset\"], [\"invert\"], [\"justify\"], [\"list-item\"], [\"local\"], [\"medium\"], [\"mix\"], [\"none\"], [\"normal\"], [\"once\"], [\"repeat\"], [\"scroll\"], [\"separate\"], [\"small-caps\"], [\"spell-out\"], [\"to\"], [\"visible\"]],\n    L = {\n      animation: {\n        cssPropBits: 517,\n        cssLitGroup: [J[10], J[24], J[29], J[45], J[48], J[54], J[63], J[71], J[72]],\n        cssFns: [\"cubic-bezier()\", \"steps()\"]\n      },\n      \"animation-delay\": {\n        cssPropBits: 5,\n        cssLitGroup: [J[48]],\n        cssFns: []\n      },\n      \"animation-direction\": {\n        cssPropBits: 0,\n        cssLitGroup: [J[24], J[48], J[72]],\n        cssFns: []\n      },\n      \"animation-duration\": \"animation-delay\",\n      \"animation-fill-mode\": {\n        cssPropBits: 0,\n        cssLitGroup: [J[29], J[48], J[54], J[71]],\n        cssFns: []\n      },\n      \"animation-iteration-count\": {\n        cssPropBits: 5,\n        cssLitGroup: [J[48], J[63]],\n        cssFns: []\n      },\n      \"animation-name\": {\n        cssPropBits: 512,\n        cssLitGroup: [J[48], J[71]],\n        cssFns: []\n      },\n      \"animation-play-state\": {\n        cssPropBits: 0,\n        cssLitGroup: [J[45], J[48]],\n        cssFns: []\n      },\n      \"animation-timing-function\": {\n        cssPropBits: 0,\n        cssLitGroup: [J[10], J[48]],\n        cssFns: [\"cubic-bezier()\", \"steps()\"]\n      },\n      appearance: {\n        cssPropBits: 0,\n        cssLitGroup: [J[71]],\n        cssFns: []\n      },\n      azimuth: {\n        cssPropBits: 5,\n        cssLitGroup: [J[7], J[42], J[56]],\n        cssFns: []\n      },\n      \"backface-visibility\": {\n        cssPropBits: 0,\n        cssLitGroup: [J[59], J[62], J[80]],\n        cssFns: []\n      },\n      background: {\n        cssPropBits: 23,\n        cssLitGroup: [J[0], J[18], J[25], J[31], J[34], J[42], J[48], J[49], J[52], J[56], J[61], J[68], J[71], J[74], J[75]],\n        cssFns: \"image(),linear-gradient(),radial-gradient(),repeating-linear-gradient(),repeating-radial-gradient(),rgb(),rgba()\".split(\",\")\n      },\n      \"background-attachment\": {\n        cssPropBits: 0,\n        cssLitGroup: [J[48], J[61], J[68], J[75]],\n        cssFns: []\n      },\n      \"background-color\": {\n        cssPropBits: 2,\n        cssLitGroup: [J[0]],\n        cssFns: [\"rgb()\", \"rgba()\"]\n      },\n      \"background-image\": {\n        cssPropBits: 16,\n        cssLitGroup: [J[48], J[71]],\n        cssFns: [\"image()\", \"linear-gradient()\", \"radial-gradient()\", \"repeating-linear-gradient()\", \"repeating-radial-gradient()\"]\n      },\n      \"background-position\": {\n        cssPropBits: 5,\n        cssLitGroup: [J[31], J[42], J[48], J[56]],\n        cssFns: []\n      },\n      \"background-repeat\": {\n        cssPropBits: 0,\n        cssLitGroup: [J[18], J[48], J[74]],\n        cssFns: []\n      },\n      \"background-size\": {\n        cssPropBits: 5,\n        cssLitGroup: [J[34], J[48], J[52]],\n        cssFns: []\n      },\n      border: {\n        cssPropBits: 7,\n        cssLitGroup: [J[0], J[9], J[47], J[62], J[64], J[69], J[71]],\n        cssFns: [\"rgb()\", \"rgba()\"]\n      },\n      \"border-bottom\": \"border\",\n      \"border-bottom-color\": \"background-color\",\n      \"border-bottom-left-radius\": {\n        cssPropBits: 5,\n        cssFns: []\n      },\n      \"border-bottom-right-radius\": \"border-bottom-left-radius\",\n      \"border-bottom-style\": {\n        cssPropBits: 0,\n        cssLitGroup: [J[9], J[62], J[64], J[71]],\n        cssFns: []\n      },\n      \"border-bottom-width\": {\n        cssPropBits: 5,\n        cssLitGroup: [J[47], J[69]],\n        cssFns: []\n      },\n      \"border-collapse\": {\n        cssPropBits: 0,\n        cssLitGroup: [J[59], J[76]],\n        cssFns: []\n      },\n      \"border-color\": \"background-color\",\n      \"border-left\": \"border\",\n      \"border-left-color\": \"background-color\",\n      \"border-left-style\": \"border-bottom-style\",\n      \"border-left-width\": \"border-bottom-width\",\n      \"border-radius\": {\n        cssPropBits: 5,\n        cssLitGroup: [J[49]],\n        cssFns: []\n      },\n      \"border-right\": \"border\",\n      \"border-right-color\": \"background-color\",\n      \"border-right-style\": \"border-bottom-style\",\n      \"border-right-width\": \"border-bottom-width\",\n      \"border-spacing\": \"border-bottom-left-radius\",\n      \"border-style\": \"border-bottom-style\",\n      \"border-top\": \"border\",\n      \"border-top-color\": \"background-color\",\n      \"border-top-left-radius\": \"border-bottom-left-radius\",\n      \"border-top-right-radius\": \"border-bottom-left-radius\",\n      \"border-top-style\": \"border-bottom-style\",\n      \"border-top-width\": \"border-bottom-width\",\n      \"border-width\": \"border-bottom-width\",\n      bottom: {\n        cssPropBits: 5,\n        cssLitGroup: [J[52]],\n        cssFns: []\n      },\n      box: {\n        cssPropBits: 0,\n        cssLitGroup: [J[60], J[71], J[72]],\n        cssFns: []\n      },\n      \"box-shadow\": {\n        cssPropBits: 7,\n        cssLitGroup: [J[0], J[48], J[64], J[71]],\n        cssFns: [\"rgb()\", \"rgba()\"]\n      },\n      \"box-sizing\": {\n        cssPropBits: 0,\n        cssLitGroup: [J[25]],\n        cssFns: []\n      },\n      \"caption-side\": {\n        cssPropBits: 0,\n        cssLitGroup: [J[31]],\n        cssFns: []\n      },\n      clear: {\n        cssPropBits: 0,\n        cssLitGroup: [J[42], J[54], J[71]],\n        cssFns: []\n      },\n      clip: {\n        cssPropBits: 0,\n        cssLitGroup: [J[52]],\n        cssFns: [\"rect()\"]\n      },\n      color: \"background-color\",\n      content: {\n        cssPropBits: 8,\n        cssLitGroup: [J[71], J[72]],\n        cssFns: []\n      },\n      cue: {\n        cssPropBits: 16,\n        cssLitGroup: [J[71]],\n        cssFns: []\n      },\n      \"cue-after\": \"cue\",\n      \"cue-before\": \"cue\",\n      cursor: {\n        cssPropBits: 16,\n        cssLitGroup: [J[1], J[48], J[52]],\n        cssFns: []\n      },\n      direction: {\n        cssPropBits: 0,\n        cssLitGroup: [J[43]],\n        cssFns: []\n      },\n      display: {\n        cssPropBits: 0,\n        cssLitGroup: [J[4], J[6], J[20], J[52], J[67], J[71]],\n        cssFns: []\n      },\n      \"display-extras\": {\n        cssPropBits: 0,\n        cssLitGroup: [J[67], J[71]],\n        cssFns: []\n      },\n      \"display-inside\": {\n        cssPropBits: 0,\n        cssLitGroup: [J[20], J[52]],\n        cssFns: []\n      },\n      \"display-outside\": {\n        cssPropBits: 0,\n        cssLitGroup: [J[4], J[71]],\n        cssFns: []\n      },\n      elevation: {\n        cssPropBits: 5,\n        cssLitGroup: [J[15]],\n        cssFns: []\n      },\n      \"empty-cells\": {\n        cssPropBits: 0,\n        cssLitGroup: [J[38]],\n        cssFns: []\n      },\n      filter: {\n        cssPropBits: 0,\n        cssFns: [\"alpha()\"]\n      },\n      \"float\": {\n        cssPropBits: 0,\n        cssLitGroup: [J[42], J[71]],\n        cssFns: []\n      },\n      font: {\n        cssPropBits: 73,\n        cssLitGroup: [J[3], J[8], J[13], J[16], J[41], J[48], J[49], J[69], J[72], J[77]],\n        cssFns: []\n      },\n      \"font-family\": {\n        cssPropBits: 72,\n        cssLitGroup: [J[16], J[48]],\n        cssFns: []\n      },\n      \"font-size\": {\n        cssPropBits: 1,\n        cssLitGroup: [J[8], J[69]],\n        cssFns: []\n      },\n      \"font-stretch\": {\n        cssPropBits: 0,\n        cssLitGroup: [J[5], J[72]],\n        cssFns: []\n      },\n      \"font-style\": {\n        cssPropBits: 0,\n        cssLitGroup: [J[41], J[72]],\n        cssFns: []\n      },\n      \"font-variant\": {\n        cssPropBits: 0,\n        cssLitGroup: [J[72], J[77]],\n        cssFns: []\n      },\n      \"font-weight\": {\n        cssPropBits: 0,\n        cssLitGroup: [J[3], J[72]],\n        cssFns: []\n      },\n      height: \"bottom\",\n      left: \"bottom\",\n      \"letter-spacing\": {\n        cssPropBits: 5,\n        cssLitGroup: [J[72]],\n        cssFns: []\n      },\n      \"line-height\": {\n        cssPropBits: 1,\n        cssLitGroup: [J[72]],\n        cssFns: []\n      },\n      \"list-style\": {\n        cssPropBits: 16,\n        cssLitGroup: [J[2], J[40], J[57], J[71]],\n        cssFns: [\"image()\", \"linear-gradient()\", \"radial-gradient()\", \"repeating-linear-gradient()\", \"repeating-radial-gradient()\"]\n      },\n      \"list-style-image\": {\n        cssPropBits: 16,\n        cssLitGroup: [J[71]],\n        cssFns: [\"image()\", \"linear-gradient()\", \"radial-gradient()\", \"repeating-linear-gradient()\", \"repeating-radial-gradient()\"]\n      },\n      \"list-style-position\": {\n        cssPropBits: 0,\n        cssLitGroup: [J[40]],\n        cssFns: []\n      },\n      \"list-style-type\": {\n        cssPropBits: 0,\n        cssLitGroup: [J[2], J[57], J[71]],\n        cssFns: []\n      },\n      margin: \"bottom\",\n      \"margin-bottom\": \"bottom\",\n      \"margin-left\": \"bottom\",\n      \"margin-right\": \"bottom\",\n      \"margin-top\": \"bottom\",\n      \"max-height\": {\n        cssPropBits: 1,\n        cssLitGroup: [J[52], J[71]],\n        cssFns: []\n      },\n      \"max-width\": \"max-height\",\n      \"min-height\": {\n        cssPropBits: 1,\n        cssLitGroup: [J[52]],\n        cssFns: []\n      },\n      \"min-width\": \"min-height\",\n      opacity: {\n        cssPropBits: 1,\n        cssFns: []\n      },\n      outline: {\n        cssPropBits: 7,\n        cssLitGroup: [J[0], J[9], J[47], J[62], J[64], J[65], J[69], J[71]],\n        cssFns: [\"rgb()\", \"rgba()\"]\n      },\n      \"outline-color\": {\n        cssPropBits: 2,\n        cssLitGroup: [J[0], J[65]],\n        cssFns: [\"rgb()\", \"rgba()\"]\n      },\n      \"outline-style\": \"border-bottom-style\",\n      \"outline-width\": \"border-bottom-width\",\n      overflow: {\n        cssPropBits: 0,\n        cssLitGroup: [J[52], J[62], J[75], J[80]],\n        cssFns: []\n      },\n      \"overflow-wrap\": {\n        cssPropBits: 0,\n        cssLitGroup: [J[55], J[72]],\n        cssFns: []\n      },\n      \"overflow-x\": {\n        cssPropBits: 0,\n        cssLitGroup: [J[44], J[52], J[62], J[75], J[80]],\n        cssFns: []\n      },\n      \"overflow-y\": \"overflow-x\",\n      padding: \"opacity\",\n      \"padding-bottom\": \"opacity\",\n      \"padding-left\": \"opacity\",\n      \"padding-right\": \"opacity\",\n      \"padding-top\": \"opacity\",\n      \"page-break-after\": {\n        cssPropBits: 0,\n        cssLitGroup: [J[42], J[51], J[52], J[53]],\n        cssFns: []\n      },\n      \"page-break-before\": \"page-break-after\",\n      \"page-break-inside\": {\n        cssPropBits: 0,\n        cssLitGroup: [J[52], J[53]],\n        cssFns: []\n      },\n      pause: \"border-bottom-left-radius\",\n      \"pause-after\": \"border-bottom-left-radius\",\n      \"pause-before\": \"border-bottom-left-radius\",\n      perspective: {\n        cssPropBits: 5,\n        cssLitGroup: [J[71]],\n        cssFns: []\n      },\n      \"perspective-origin\": {\n        cssPropBits: 5,\n        cssLitGroup: [J[31], J[42], J[56]],\n        cssFns: []\n      },\n      pitch: {\n        cssPropBits: 5,\n        cssLitGroup: [J[21], J[69]],\n        cssFns: []\n      },\n      \"pitch-range\": \"border-bottom-left-radius\",\n      \"play-during\": {\n        cssPropBits: 16,\n        cssLitGroup: [J[52], J[70], J[71], J[74]],\n        cssFns: []\n      },\n      position: {\n        cssPropBits: 0,\n        cssLitGroup: [J[23]],\n        cssFns: []\n      },\n      quotes: {\n        cssPropBits: 8,\n        cssLitGroup: [J[71]],\n        cssFns: []\n      },\n      resize: {\n        cssPropBits: 0,\n        cssLitGroup: [J[39], J[54], J[71]],\n        cssFns: []\n      },\n      richness: \"border-bottom-left-radius\",\n      right: \"bottom\",\n      speak: {\n        cssPropBits: 0,\n        cssLitGroup: [J[71], J[72], J[78]],\n        cssFns: []\n      },\n      \"speak-header\": {\n        cssPropBits: 0,\n        cssLitGroup: [J[51], J[73]],\n        cssFns: []\n      },\n      \"speak-numeral\": {\n        cssPropBits: 0,\n        cssLitGroup: [J[35]],\n        cssFns: []\n      },\n      \"speak-punctuation\": {\n        cssPropBits: 0,\n        cssLitGroup: [J[58], J[71]],\n        cssFns: []\n      },\n      \"speech-rate\": {\n        cssPropBits: 5,\n        cssLitGroup: [J[14], J[69]],\n        cssFns: []\n      },\n      stress: \"border-bottom-left-radius\",\n      \"table-layout\": {\n        cssPropBits: 0,\n        cssLitGroup: [J[52], J[61]],\n        cssFns: []\n      },\n      \"text-align\": {\n        cssPropBits: 0,\n        cssLitGroup: [J[42], J[56], J[66]],\n        cssFns: []\n      },\n      \"text-decoration\": {\n        cssPropBits: 0,\n        cssLitGroup: [J[19], J[71]],\n        cssFns: []\n      },\n      \"text-indent\": \"border-bottom-left-radius\",\n      \"text-overflow\": {\n        cssPropBits: 8,\n        cssLitGroup: [J[33]],\n        cssFns: []\n      },\n      \"text-shadow\": \"box-shadow\",\n      \"text-transform\": {\n        cssPropBits: 0,\n        cssLitGroup: [J[26], J[71]],\n        cssFns: []\n      },\n      \"text-wrap\": {\n        cssPropBits: 0,\n        cssLitGroup: [J[46], J[71], J[72]],\n        cssFns: []\n      },\n      top: \"bottom\",\n      transform: {\n        cssPropBits: 0,\n        cssLitGroup: [J[71]],\n        cssFns: \"matrix(),perspective(),rotate(),rotate3d(),rotatex(),rotatey(),rotatez(),scale(),scale3d(),scalex(),scaley(),scalez(),skew(),skewx(),skewy(),translate(),translate3d(),translatex(),translatey(),translatez()\".split(\",\")\n      },\n      \"transform-origin\": \"perspective-origin\",\n      \"transform-style\": {\n        cssPropBits: 0,\n        cssLitGroup: [J[37]],\n        cssFns: []\n      },\n      transition: {\n        cssPropBits: 1029,\n        cssLitGroup: [J[10], J[48], J[50], J[71]],\n        cssFns: [\"cubic-bezier()\", \"steps()\"]\n      },\n      \"transition-delay\": \"animation-delay\",\n      \"transition-duration\": \"animation-delay\",\n      \"transition-property\": {\n        cssPropBits: 1024,\n        cssLitGroup: [J[48], J[50]],\n        cssFns: []\n      },\n      \"transition-timing-function\": \"animation-timing-function\",\n      \"unicode-bidi\": {\n        cssPropBits: 0,\n        cssLitGroup: [J[30], J[72]],\n        cssFns: []\n      },\n      \"vertical-align\": {\n        cssPropBits: 5,\n        cssLitGroup: [J[12], J[31]],\n        cssFns: []\n      },\n      visibility: \"backface-visibility\",\n      \"voice-family\": {\n        cssPropBits: 8,\n        cssLitGroup: [J[27], J[48]],\n        cssFns: []\n      },\n      volume: {\n        cssPropBits: 1,\n        cssLitGroup: [J[17], J[69]],\n        cssFns: []\n      },\n      \"white-space\": {\n        cssPropBits: 0,\n        cssLitGroup: [J[22], J[72]],\n        cssFns: []\n      },\n      width: \"min-height\",\n      \"word-break\": {\n        cssPropBits: 0,\n        cssLitGroup: [J[32], J[72]],\n        cssFns: []\n      },\n      \"word-spacing\": \"letter-spacing\",\n      \"word-wrap\": \"overflow-wrap\",\n      \"z-index\": \"bottom\",\n      zoom: \"line-height\",\n      \"cubic-bezier()\": \"animation-delay\",\n      \"steps()\": {\n        cssPropBits: 5,\n        cssLitGroup: [J[36], J[48]],\n        cssFns: []\n      },\n      \"image()\": {\n        cssPropBits: 18,\n        cssLitGroup: [J[0], J[48]],\n        cssFns: [\"rgb()\", \"rgba()\"]\n      },\n      \"linear-gradient()\": {\n        cssPropBits: 7,\n        cssLitGroup: [J[0], J[31], J[42], J[48], J[79]],\n        cssFns: [\"rgb()\", \"rgba()\"]\n      },\n      \"radial-gradient()\": {\n        cssPropBits: 7,\n        cssLitGroup: [J[0], J[11], J[31], J[42], J[48], J[56], J[57]],\n        cssFns: [\"rgb()\", \"rgba()\"]\n      },\n      \"repeating-linear-gradient()\": \"linear-gradient()\",\n      \"repeating-radial-gradient()\": \"radial-gradient()\",\n      \"rgb()\": {\n        cssPropBits: 1,\n        cssLitGroup: [J[48]],\n        cssFns: []\n      },\n      \"rgba()\": \"rgb()\",\n      \"rect()\": {\n        cssPropBits: 5,\n        cssLitGroup: [J[48], J[52]],\n        cssFns: []\n      },\n      \"alpha()\": {\n        cssPropBits: 1,\n        cssLitGroup: [J[28]],\n        cssFns: []\n      },\n      \"matrix()\": \"animation-delay\",\n      \"perspective()\": \"border-bottom-left-radius\",\n      \"rotate()\": \"border-bottom-left-radius\",\n      \"rotate3d()\": \"animation-delay\",\n      \"rotatex()\": \"border-bottom-left-radius\",\n      \"rotatey()\": \"border-bottom-left-radius\",\n      \"rotatez()\": \"border-bottom-left-radius\",\n      \"scale()\": \"animation-delay\",\n      \"scale3d()\": \"animation-delay\",\n      \"scalex()\": \"border-bottom-left-radius\",\n      \"scaley()\": \"border-bottom-left-radius\",\n      \"scalez()\": \"border-bottom-left-radius\",\n      \"skew()\": \"animation-delay\",\n      \"skewx()\": \"border-bottom-left-radius\",\n      \"skewy()\": \"border-bottom-left-radius\",\n      \"translate()\": \"animation-delay\",\n      \"translate3d()\": \"animation-delay\",\n      \"translatex()\": \"border-bottom-left-radius\",\n      \"translatey()\": \"border-bottom-left-radius\",\n      \"translatez()\": \"border-bottom-left-radius\"\n    },\n    O;\n  for (O in L) \"string\" === typeof L[O] && Object.hasOwnProperty.call(L, O) && (L[O] = L[L[O]]);\n  \"undefined\" !== typeof window && (window.cssSchema = L);\n  var U, X;\n  (function () {\n    function g(a) {\n      var f = parseInt(a.substring(1), 16);\n      return 65535 < f ? (f -= 65536, String.fromCharCode(55296 + (f >> 10), 56320 + (f & 1023))) : f == f ? String.fromCharCode(f) : \" \" > a[1] ? \"\" : a[1];\n    }\n    function w(a, f) {\n      return '\"' + a.replace(/[\\u0000-\\u001f\\\\\\\"<>]/g, f) + '\"';\n    }\n    function M(a) {\n      return E[a] || (E[a] = \"\\\\\" + a.charCodeAt(0).toString(16) + \" \");\n    }\n    function x(a) {\n      return e[a] || (e[a] = (\"\\x10\" > a ? \"%0\" : \"%\") + a.charCodeAt(0).toString(16));\n    }\n    var E = {\n        \"\\\\\": \"\\\\\\\\\"\n      },\n      e = {\n        \"\\\\\": \"%5c\"\n      },\n      v = RegExp(\"\\\\uFEFF|U[+][0-9A-F?]{1,6}(?:-[0-9A-F]{1,6})?|url[(][\\\\t\\\\n\\\\f ]*(?:\\\"(?:'|[^'\\\"\\\\n\\\\f\\\\\\\\]|\\\\\\\\[\\\\s\\\\S])*\\\"|'(?:\\\"|[^'\\\"\\\\n\\\\f\\\\\\\\]|\\\\\\\\[\\\\s\\\\S])*'|(?:[\\\\t\\\\x21\\\\x23-\\\\x26\\\\x28-\\\\x5b\\\\x5d-\\\\x7e]|[\\\\u0080-\\\\ud7ff\\\\ue000-\\\\ufffd]|[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]|\\\\\\\\(?:[0-9a-fA-F]{1,6}[\\\\t\\\\n\\\\f ]?|[\\\\u0020-\\\\u007e\\\\u0080-\\\\ud7ff\\\\ue000\\\\ufffd]|[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]))*)[\\\\t\\\\n\\\\f ]*[)]|(?!url[(])-?(?:[a-zA-Z_]|[\\\\u0080-\\\\ud7ff\\\\ue000-\\\\ufffd]|[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]|\\\\\\\\(?:[0-9a-fA-F]{1,6}[\\\\t\\\\n\\\\f ]?|[\\\\u0020-\\\\u007e\\\\u0080-\\\\ud7ff\\\\ue000\\\\ufffd]|[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]))(?:[a-zA-Z0-9_-]|[\\\\u0080-\\\\ud7ff\\\\ue000-\\\\ufffd]|[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]|\\\\\\\\(?:[0-9a-fA-F]{1,6}[\\\\t\\\\n\\\\f ]?|[\\\\u0020-\\\\u007e\\\\u0080-\\\\ud7ff\\\\ue000\\\\ufffd]|[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]))*[(]|(?:@?-?(?:[a-zA-Z_]|[\\\\u0080-\\\\ud7ff\\\\ue000-\\\\ufffd]|[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]|\\\\\\\\(?:[0-9a-fA-F]{1,6}[\\\\t\\\\n\\\\f ]?|[\\\\u0020-\\\\u007e\\\\u0080-\\\\ud7ff\\\\ue000\\\\ufffd]|[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]))|#)(?:[a-zA-Z0-9_-]|[\\\\u0080-\\\\ud7ff\\\\ue000-\\\\ufffd]|[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]|\\\\\\\\(?:[0-9a-fA-F]{1,6}[\\\\t\\\\n\\\\f ]?|[\\\\u0020-\\\\u007e\\\\u0080-\\\\ud7ff\\\\ue000\\\\ufffd]|[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]))*|\\\"(?:'|[^'\\\"\\\\n\\\\f\\\\\\\\]|\\\\\\\\[\\\\s\\\\S])*\\\"|'(?:\\\"|[^'\\\"\\\\n\\\\f\\\\\\\\]|\\\\\\\\[\\\\s\\\\S])*'|[-+]?(?:[0-9]+(?:[.][0-9]+)?|[.][0-9]+)(?:%|-?(?:[a-zA-Z_]|[\\\\u0080-\\\\ud7ff\\\\ue000-\\\\ufffd]|[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]|\\\\\\\\(?:[0-9a-fA-F]{1,6}[\\\\t\\\\n\\\\f ]?|[\\\\u0020-\\\\u007e\\\\u0080-\\\\ud7ff\\\\ue000\\\\ufffd]|[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]))(?:[a-zA-Z0-9_-]|[\\\\u0080-\\\\ud7ff\\\\ue000-\\\\ufffd]|[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]|\\\\\\\\(?:[0-9a-fA-F]{1,6}[\\\\t\\\\n\\\\f ]?|[\\\\u0020-\\\\u007e\\\\u0080-\\\\ud7ff\\\\ue000\\\\ufffd]|[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]))*)?|<!--|-->|[\\\\t\\\\n\\\\f ]+|/(?:[*][^*]*[*]+(?:[^/][^*]*[*]+)*/|/[^\\\\n\\\\f]*)|[~|^$*]=|[^\\\"'\\\\\\\\/]|/(?![/*])\", \"gi\"),\n      b = RegExp(\"\\\\\\\\(?:(?:[0-9a-fA-F]{1,6}[\\\\t\\\\n\\\\f ]?|[\\\\u0020-\\\\u007e\\\\u0080-\\\\ud7ff\\\\ue000\\\\ufffd]|[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff])|[\\\\n\\\\f])\", \"g\"),\n      a = RegExp(\"^url\\\\([\\\\t\\\\n\\\\f ]*[\\\"']?|[\\\"']?[\\\\t\\\\n\\\\f ]*\\\\)$\", \"gi\");\n    X = function X(a) {\n      return a.replace(b, g);\n    };\n    U = function U(b) {\n      for (var b = (\"\" + b).replace(/\\r\\n?/g, \"\\n\").match(v) || [], f = 0, h = \" \", d = 0, y = b.length; d < y; ++d) {\n        var l = X(b[d]),\n          V = l.length,\n          g = l.charCodeAt(0),\n          l = 34 == g || 39 == g ? w(l.substring(1, V - 1), M) : 47 == g && 1 < V || \"\\\\\" == l || \"--\\>\" == l || \"<\\!--\" == l || \"\\uFEFF\" == l || 32 >= g ? \" \" : /url\\(/i.test(l) ? \"url(\" + w(l.replace(a, \"\"), x) + \")\" : l;\n        if (h != l || \" \" != l) b[f++] = h = l;\n      }\n      b.length = f;\n      return b;\n    };\n  })();\n  \"undefined\" !== typeof window && (window.lexCss = U, window.decodeCss = X);\n  var Y = function () {\n    function g(d) {\n      d = (\"\" + d).match(k);\n      return !d ? s : new e(v(d[1]), v(d[2]), v(d[3]), v(d[4]), v(d[5]), v(d[6]), v(d[7]));\n    }\n    function w(d, a) {\n      return \"string\" == typeof d ? encodeURI(d).replace(a, M) : s;\n    }\n    function M(d) {\n      d = d.charCodeAt(0);\n      return \"%\" + \"0123456789ABCDEF\".charAt(d >> 4 & 15) + \"0123456789ABCDEF\".charAt(d & 15);\n    }\n    function x(d) {\n      if (d === s) return s;\n      for (var d = d.replace(/(^|\\/)\\.(?:\\/|$)/g, \"$1\").replace(/\\/{2,}/g, \"/\"), a = b, h; (h = d.replace(a, \"$1\")) != d; d = h);\n      return d;\n    }\n    function E(d, h) {\n      var b = d.T(),\n        f = h.K();\n      f ? b.ga(h.j) : f = h.X();\n      f ? b.da(h.n) : f = h.Y();\n      f ? b.ea(h.k) : f = h.$();\n      var g = h.g,\n        k = x(g);\n      if (f) b.ca(h.V()), k = k && k.replace(a, \"\");else if (f = !!g) {\n        if (47 !== k.charCodeAt(0)) var k = x(b.g || \"\").replace(a, \"\"),\n          e = k.lastIndexOf(\"/\") + 1,\n          k = x((e ? k.substring(0, e) : \"\") + x(g)).replace(a, \"\");\n      } else k = k && k.replace(a, \"\"), k !== g && b.G(k);\n      f ? b.G(k) : f = h.aa();\n      f ? b.O(h.l) : f = h.Z();\n      f && b.fa(h.o);\n      return b;\n    }\n    function e(d, a, h, f, b, g, k) {\n      this.j = d;\n      this.n = a;\n      this.k = h;\n      this.h = f;\n      this.g = b;\n      this.l = g;\n      this.o = k;\n    }\n    function v(d) {\n      return \"string\" == typeof d && 0 < d.length ? d : s;\n    }\n    var b = RegExp(/(\\/|^)(?:[^./][^/]*|\\.{2,}(?:[^./][^/]*)|\\.{3,}[^/]*)\\/\\.\\.(?:\\/|$)/),\n      a = /^(?:\\.\\.\\/)*(?:\\.\\.$)?/;\n    e.prototype.toString = function () {\n      var d = [];\n      s !== this.j && d.push(this.j, \":\");\n      s !== this.k && (d.push(\"//\"), s !== this.n && d.push(this.n, \"@\"), d.push(this.k), s !== this.h && d.push(\":\", this.h.toString()));\n      s !== this.g && d.push(this.g);\n      s !== this.l && d.push(\"?\", this.l);\n      s !== this.o && d.push(\"#\", this.o);\n      return d.join(\"\");\n    };\n    e.prototype.T = function () {\n      return new e(this.j, this.n, this.k, this.h, this.g, this.l, this.o);\n    };\n    e.prototype.W = function () {\n      return this.j && decodeURIComponent(this.j).toLowerCase();\n    };\n    e.prototype.ga = function (d) {\n      this.j = d ? d : s;\n    };\n    e.prototype.K = function () {\n      return s !== this.j;\n    };\n    e.prototype.da = function (d) {\n      this.n = d ? d : s;\n    };\n    e.prototype.X = function () {\n      return s !== this.n;\n    };\n    e.prototype.ea = function (d) {\n      this.k = d ? d : s;\n      this.G(this.g);\n    };\n    e.prototype.Y = function () {\n      return s !== this.k;\n    };\n    e.prototype.V = function () {\n      return this.h && decodeURIComponent(this.h);\n    };\n    e.prototype.ca = function (d) {\n      if (d) {\n        d = Number(d);\n        if (d !== (d & 65535)) throw Error(\"Bad port number \" + d);\n        this.h = \"\" + d;\n      } else this.h = s;\n    };\n    e.prototype.$ = function () {\n      return s !== this.h;\n    };\n    e.prototype.U = function () {\n      return this.g && decodeURIComponent(this.g);\n    };\n    e.prototype.G = function (d) {\n      d ? (d = \"\" + d, this.g = !this.k || /^\\//.test(d) ? d : \"/\" + d) : this.g = s;\n    };\n    e.prototype.O = function (d) {\n      this.l = d ? d : s;\n    };\n    e.prototype.aa = function () {\n      return s !== this.l;\n    };\n    e.prototype.ba = function (d) {\n      if (\"object\" === _typeof(d) && !(d instanceof Array) && (d instanceof Object || \"[object Array]\" !== Object.prototype.toString.call(d))) {\n        var a = [],\n          h = -1,\n          f;\n        for (f in d) {\n          var b = d[f];\n          \"string\" === typeof b && (a[++h] = f, a[++h] = b);\n        }\n        d = a;\n      }\n      for (var a = [], h = \"\", g = 0; g < d.length;) f = d[g++], b = d[g++], a.push(h, encodeURIComponent(f.toString())), h = \"&\", b && a.push(\"=\", encodeURIComponent(b.toString()));\n      this.l = a.join(\"\");\n    };\n    e.prototype.fa = function (d) {\n      this.o = d ? d : s;\n    };\n    e.prototype.Z = function () {\n      return s !== this.o;\n    };\n    var k = /^(?:([^:/?#]+):)?(?:\\/\\/(?:([^/?#]*)@)?([^/?#:@]*)(?::([0-9]+))?)?([^?#]+)?(?:\\?([^#]*))?(?:#(.*))?$/,\n      f = /[#\\/\\?@]/g,\n      h = /[\\#\\?]/g;\n    e.parse = g;\n    e.create = function (d, a, b, g, k, Q, N) {\n      d = new e(w(d, f), w(a, f), \"string\" == typeof b ? encodeURIComponent(b) : s, 0 < g ? g.toString() : s, w(k, h), s, \"string\" == typeof N ? encodeURIComponent(N) : s);\n      Q && (\"string\" === typeof Q ? d.O(Q.replace(/[^?&=0-9A-Za-z_\\-~.%]/g, M)) : d.ba(Q));\n      return d;\n    };\n    e.N = E;\n    e.ma = x;\n    e.ha = {\n      ua: function ua(d) {\n        return /\\.html$/.test(g(d).U()) ? \"text/html\" : \"application/javascript\";\n      },\n      N: function N(d, a) {\n        return d ? E(g(d), g(a)).toString() : \"\" + a;\n      }\n    };\n    return e;\n  }();\n  \"undefined\" !== typeof window && (window.URI = Y);\n  var aa = c,\n    ba = c,\n    da = c,\n    Z = c;\n  (function () {\n    function g(a) {\n      return \"string\" === typeof a ? 'url(\"' + a.replace(e, w) + '\")' : 'url(\"about:blank\")';\n    }\n    function w(a) {\n      return v[a];\n    }\n    function M(a, d) {\n      return a ? Y.ha.N(a, d) : d;\n    }\n    function x(h, d, f) {\n      if (!f) return s;\n      var g = (\"\" + h).match(b);\n      return g && (!g[1] || a.test(g[1])) ? f(h, d) : s;\n    }\n    function E(a) {\n      return a.replace(/^-(?:apple|css|epub|khtml|moz|mso?|o|rim|wap|webkit|xv)-(?=[a-z])/, \"\");\n    }\n    var e = /[\\n\\f\\r\\\"\\'()*<>]/g,\n      v = {\n        \"\\n\": \"%0a\",\n        \"\\f\": \"%0c\",\n        \"\\r\": \"%0d\",\n        '\"': \"%22\",\n        \"'\": \"%27\",\n        \"(\": \"%28\",\n        \")\": \"%29\",\n        \"*\": \"%2a\",\n        \"<\": \"%3c\",\n        \">\": \"%3e\"\n      },\n      b = /^(?:([^:/?# ]+):)?/,\n      a = /^(?:https?|mailto|data)$/i;\n    aa = function () {\n      var a = {};\n      return function y(f, b, k, e, N) {\n        var f = E(f),\n          u = L[f];\n        if (!u || \"object\" !== _typeof(u)) b.length = 0;else {\n          for (var i = u.cssPropBits, q = i & 80, B = i & 1536, F = NaN, r = 0, o = 0; r < b.length; ++r) {\n            var j = b[r].toLowerCase(),\n              I = j.charCodeAt(0),\n              R,\n              v,\n              P,\n              S,\n              D,\n              w;\n            if (32 === I) j = \"\";else if (34 === I) j = 16 === q ? k ? g(x(M(e, X(b[r].substring(1, j.length - 1))), f, k)) : \"\" : i & 8 && !(q & q - 1) ? j : \"\";else if (\"inherit\" !== j) {\n              if (D = u.cssLitGroup) {\n                var G;\n                if (!(G = u.cssLitMap)) {\n                  G = {};\n                  for (var K = D.length; 0 <= --K;) for (var A = D[K], T = A.length; 0 <= --T;) G[A[T]] = a;\n                  G = u.cssLitMap = G;\n                }\n                D = G;\n              } else D = a;\n              if (!(w = D, w[E(j)] === a)) if (35 === I && /^#(?:[0-9a-f]{3}){1,2}$/.test(j)) j = i & 2 ? j : \"\";else if (48 <= I && 57 >= I) j = i & 1 ? j : \"\";else if (R = j.charCodeAt(1), v = j.charCodeAt(2), P = 48 <= R && 57 >= R, S = 48 <= v && 57 >= v, 43 === I && (P || 46 === R && S)) j = i & 1 ? (P ? \"\" : \"0\") + j.substring(1) : \"\";else if (45 === I && (P || 46 === R && S)) j = i & 4 ? (P ? \"-\" : \"-0\") + j.substring(1) : i & 1 ? \"0\" : \"\";else if (46 === I && P) j = i & 1 ? \"0\" + j : \"\";else if ('url(\"' === j.substring(0, 5)) j = k && i & 16 ? g(x(M(e, b[r].substring(5, j.length - 2)), f, k)) : \"\";else if (\"(\" === j.charAt(j.length - 1)) a: {\n                D = b;\n                G = r;\n                j = 1;\n                K = G + 1;\n                for (I = D.length; K < I && j;) A = D[K++], j += \")\" === A ? -1 : /^[^\"']*\\($/.test(A);\n                if (!j) {\n                  j = D[G].toLowerCase();\n                  I = E(j);\n                  D = D.splice(G, K - G, \"\");\n                  G = u.cssFns;\n                  K = 0;\n                  for (A = G.length; K < A; ++K) if (G[K].substring(0, I.length) == I) {\n                    D[0] = D[D.length - 1] = \"\";\n                    y(G[K], D, k, e);\n                    j = j + D.join(\" \") + \")\";\n                    break a;\n                  }\n                }\n                j = \"\";\n              } else j = B && /^-?[a-z_][\\w\\-]*$/.test(j) && !/__$/.test(j) ? N && 512 === B ? b[r] + N : 1024 === B && L[j] && \"number\" === typeof L[j].oa ? j : \"\" : /^\\w+$/.test(j) && 64 === q && i & 8 ? F + 1 === o ? (b[F] = b[F].substring(0, b[F].length - 1) + \" \" + j + '\"', \"\") : (F = o, '\"' + j + '\"') : \"\";\n            }\n            j && (b[o++] = j);\n          }\n          1 === o && 'url(\"about:blank\")' === b[0] && (o = 0);\n          b.length = o;\n        }\n      };\n    }();\n    var k = RegExp(\"^(active|after|before|blank|checked|default|disabled|drop|empty|enabled|first|first-child|first-letter|first-line|first-of-type|fullscreen|focus|hover|in-range|indeterminate|invalid|last-child|last-of-type|left|link|only-child|only-of-type|optional|out-of-range|placeholder-shown|read-only|read-write|required|right|root|scope|user-error|valid|visited)$\"),\n      f = {};\n    f[\">\"] = f[\"+\"] = f[\"~\"] = f;\n    ba = function ba(a, d, b) {\n      function g(i, r) {\n        function o(b, f, g) {\n          var y,\n            e,\n            i,\n            l,\n            o,\n            m = n;\n          y = \"\";\n          if (b < f) if (o = a[b], \"*\" === o) ++b, y = o;else if (/^[a-zA-Z]/.test(o) && (e = x(o.toLowerCase(), []))) \"tagName\" in e && (o = e.tagName), ++b, y = o;\n          for (l = i = e = \"\"; m && b < f; ++b) if (o = a[b], \"#\" === o.charAt(0)) /^#_|__$|[^\\w#:\\-]/.test(o) ? m = C : e += o + v;else if (\".\" === o) ++b < f && /^[0-9A-Za-z:_\\-]+$/.test(o = a[b]) && !/^_|__$/.test(o) ? e += \".\" + o : m = C;else if (b + 1 < f && \"[\" === a[b]) {\n            ++b;\n            var H = a[b++].toLowerCase();\n            o = $.m[y + \"::\" + H];\n            o !== +o && (o = $.m[\"*::\" + H]);\n            var W;\n            d.ia ? (W = d.ia(y, H), \"string\" !== typeof W && (m = C, W = H), m && o !== +o && (o = $.d.NONE)) : (W = H, o !== +o && (m = C));\n            var p = H = \"\",\n              ca = C;\n            /^[~^$*|]?=$/.test(a[b]) && (H = a[b++], p = a[b++], /^[0-9A-Za-z:_\\-]+$/.test(p) ? p = '\"' + p + '\"' : \"]\" === p && (p = '\"\"', --b), /^\"([^\\\"\\\\]|\\\\.)*\"$/.test(p) || (m = C), (ca = \"i\" === a[b]) && ++b);\n            \"]\" !== a[b] && (++b, m = C);\n            switch (o) {\n              case $.d.CLASSES:\n              case $.d.LOCAL_NAME:\n              case $.d.NONE:\n                break;\n              case $.d.GLOBAL_NAME:\n              case $.d.ID:\n              case $.d.IDREF:\n                (\"=\" === H || \"~=\" === H || \"$=\" === H) && '\"\"' != p && !ca ? p = '\"' + p.substring(1, p.length - 1) + v + '\"' : \"|=\" === H || \"\" === H || (m = C);\n                break;\n              case $.d.URI:\n              case $.d.URI_FRAGMENT:\n                \"\" !== H && (m = C);\n                break;\n              default:\n                m = C;\n            }\n            m && (i += \"[\" + W.replace(/[^\\w-]/g, \"\\\\$&\") + H + p + (ca ? \" i]\" : \"]\"));\n          } else if (b < f && \":\" === a[b]) {\n            if (o = a[++b], k.test(o)) l += \":\" + o;else break;\n          } else break;\n          b !== f && (m = C);\n          m && (b = (y + e).replace(/[^ .*#\\w-]/g, \"\\\\$&\") + i + l + g) && j.push(b);\n          return m;\n        }\n        \" \" === a[i] && ++i;\n        r - 1 !== i && \" \" === a[r] && --r;\n        for (var j = [], l = i, q = n, u = i; q && u < r; ++u) {\n          var B = a[u];\n          if (f[B] === f || \" \" === B) o(l, u, B) ? l = u + 1 : q = C;\n        }\n        o(l, r, \"\") || (q = C);\n        return q ? (j.length && (l = j.join(\"\"), e !== s && (l = \".\" + e + \" \" + l), N.push(l)), n) : !b || b(a.slice(i, r));\n      }\n      var e = d.na,\n        v = d.L,\n        x = d.Aa,\n        N = [],\n        u = 0,\n        i,\n        q = 0,\n        B;\n      for (i = 0; i < a.length; ++i) if (B = a[i], \"(\" == B || \"[\" == B ? (++q, n) : \")\" == B || \"]\" == B ? (q && --q, n) : !(\" \" == a[i] && (q || f[a[i - 1]] === f || f[a[i + 1]] === f))) a[u++] = a[i];\n      a.length = u;\n      u = a.length;\n      for (i = q = 0; i < u; ++i) if (\",\" === a[i]) {\n        if (!g(q, i)) return s;\n        q = i + 1;\n      }\n      return !g(q, u) ? s : N;\n    };\n    (function () {\n      var a = /^\\w/,\n        d = RegExp(\"^(?:(?:(?:(?:only|not) )?(?:all|aural|braille|embossed|handheld|print|projection|screen|speech|tty|tv)|\\\\( (?:(?:min-|max-)?(?:(?:device-)?(?:aspect-ratio|height|width)|color(?:-index)?|monochrome|orientation|resolution)|grid|hover|luminosity|pointer|scan|script) (?:: -?(?:[a-z]\\\\w+(?:-\\\\w+)*|\\\\d+(?: / \\\\d+|(?:\\\\.\\\\d+)?(?:p[cxt]|[cem]m|in|dpi|dppx|dpcm|%)?)) )?\\\\))(?: and ?\\\\( (?:(?:min-|max-)?(?:(?:device-)?(?:aspect-ratio|height|width)|color(?:-index)?|monochrome|orientation|resolution)|grid|hover|luminosity|pointer|scan|script) (?:: -?(?:[a-z]\\\\w+(?:-\\\\w+)*|\\\\d+(?: / \\\\d+|(?:\\\\.\\\\d+)?(?:p[cxt]|[cem]m|in|dpi|dppx|dpcm|%)?)) )?\\\\))*)(?: , (?:(?:(?:(?:only|not) )?(?:all|aural|braille|embossed|handheld|print|projection|screen|speech|tty|tv)|\\\\( (?:(?:min-|max-)?(?:(?:device-)?(?:aspect-ratio|height|width)|color(?:-index)?|monochrome|orientation|resolution)|grid|hover|luminosity|pointer|scan|script) (?:: -?(?:[a-z]\\\\w+(?:-\\\\w+)*|\\\\d+(?: / \\\\d+|(?:\\\\.\\\\d+)?(?:p[cxt]|[cem]m|in|dpi|dppx|dpcm|%)?)) )?\\\\))(?: and ?\\\\( (?:(?:min-|max-)?(?:(?:device-)?(?:aspect-ratio|height|width)|color(?:-index)?|monochrome|orientation|resolution)|grid|hover|luminosity|pointer|scan|script) (?:: -?(?:[a-z]\\\\w+(?:-\\\\w+)*|\\\\d+(?: / \\\\d+|(?:\\\\.\\\\d+)?(?:p[cxt]|[cem]m|in|dpi|dppx|dpcm|%)?)) )?\\\\))*))*$\", \"i\");\n      Z = function Z(b) {\n        for (var b = b.slice(), f = b.length, g = 0, k = 0; k < f; ++k) {\n          var e = b[k];\n          \" \" != e && (b[g++] = e);\n        }\n        b.length = g;\n        b = b.join(\" \");\n        return b = !b.length ? \"\" : !d.test(b) ? \"not all\" : a.test(b) ? b : \"not all , \" + b;\n      };\n    })();\n    (function () {\n      function a(b) {\n        var d = /^\\s*[']([^']*)[']\\s*$/,\n          f = /^\\s*url\\s*[(][\"]([^\"]*)[\"][)]\\s*$/,\n          g = /^\\s*url\\s*[(][']([^']*)['][)]\\s*$/,\n          h = /^\\s*url\\s*[(]([^)]*)[)]\\s*$/,\n          k;\n        return (k = /^\\s*[\"]([^\"]*)[\"]\\s*$/.exec(b)) || (k = d.exec(b)) || (k = f.exec(b)) || (k = g.exec(b)) || (k = h.exec(b)) ? k[1] : s;\n      }\n      function b(f, g, k, e, v, w, u) {\n        function i() {\n          r = F.length && F[F.length - 1] === s;\n        }\n        var q = c,\n          B = u || [0],\n          F = [],\n          r = C;\n        fa(g, {\n          startStylesheet: function startStylesheet() {\n            q = [];\n          },\n          endStylesheet: function endStylesheet() {},\n          startAtrule: function startAtrule(g, j) {\n            if (r) g = s;else if (\"@media\" === g) q.push(\"@media\", \" \", Z(j));else if (\"@keyframes\" === g || \"@-webkit-keyframes\" === g) {\n              var i = j[0];\n              1 === j.length && !/__$|[^\\w\\-]/.test(i) ? (q.push(g, \" \", i + k.L), g = \"@keyframes\") : g = s;\n            } else if (\"@import\" === g && 0 < j.length) if (g = s, \"function\" === typeof w) {\n              var l = Z(j.slice(1));\n              if (\"not all\" !== l) {\n                ++B[0];\n                var u = [];\n                q.push(u);\n                var E = x(M(f, a(j[0])), function (a) {\n                  var f = b(E, a.qa, k, e, v, w, B);\n                  --B[0];\n                  a = l ? {\n                    toString: function toString() {\n                      return \"@media \" + l + \" {\" + f.result + \"}\";\n                    }\n                  } : f.result;\n                  u[0] = a;\n                  w(a, !!B[0]);\n                }, v);\n              }\n            } else window.console && window.console.log(\"@import \" + j.join(\" \") + \" elided\");\n            r = !g;\n            F.push(g);\n          },\n          endAtrule: function endAtrule() {\n            F.pop();\n            r || q.push(\";\");\n            i();\n          },\n          startBlock: function startBlock() {\n            r || q.push(\"{\");\n          },\n          endBlock: function endBlock() {\n            r || (q.push(\"}\"), r = n);\n          },\n          startRuleset: function startRuleset(a) {\n            if (!r) {\n              var b = c;\n              \"@keyframes\" === F[F.length - 1] ? (b = a.join(\" \").match(/^ *(?:from|to|\\d+(?:\\.\\d+)?%) *(?:, *(?:from|to|\\d+(?:\\.\\d+)?%) *)*$/i), r = !b, b && (b = b[0].replace(/ +/g, \"\"))) : (a = ba(a, k), !a || !a.length ? r = n : b = a.join(\", \"));\n              r || q.push(b, \"{\");\n            }\n            F.push(s);\n          },\n          endRuleset: function endRuleset() {\n            F.pop();\n            r || q.push(\"}\");\n            i();\n          },\n          declaration: function declaration(a, b) {\n            if (!r) {\n              var d = C,\n                g = b.length;\n              2 <= g && \"!\" === b[g - 2] && \"important\" === b[g - 1].toLowerCase() && (d = n, b.length -= 2);\n              aa(a, b, e, f, k.L);\n              b.length && q.push(a, \":\", b.join(\" \"), d ? \" !important;\" : \";\");\n            }\n          }\n        });\n        return {\n          result: {\n            toString: function toString() {\n              return q.join(\"\");\n            }\n          },\n          va: !!B[0]\n        };\n      }\n      da = function da(a, f, g, k) {\n        return b(a, f, g, k, c, c).result.toString();\n      };\n    })();\n  })();\n  \"undefined\" !== typeof window && (window.sanitizeCssProperty = aa, window.sanitizeCssSelectorList = ba, window.sanitizeStylesheet = da, window.sanitizeMediaQuery = Z);\n  var fa, ga;\n  (function () {\n    function g(b, a, g, f, h) {\n      for (var d = a++; a < g && \"{\" !== b[a] && \";\" !== b[a];) ++a;\n      if (a < g && (h || \";\" === b[a])) {\n        var h = d + 1,\n          e = a;\n        h < g && \" \" === b[h] && ++h;\n        e > h && \" \" === b[e - 1] && --e;\n        f.startAtrule && f.startAtrule(b[d].toLowerCase(), b.slice(h, e));\n        a = \"{\" === b[a] ? w(b, a, g, f) : a + 1;\n        f.endAtrule && f.endAtrule();\n      }\n      return a;\n    }\n    function w(b, a, k, f) {\n      ++a;\n      for (f.startBlock && f.startBlock(); a < k;) {\n        var h = b[a].charAt(0);\n        if (\"}\" == h) {\n          ++a;\n          break;\n        }\n        a = \" \" === h || \";\" === h ? a + 1 : \"@\" === h ? g(b, a, k, f, C) : \"{\" === h ? w(b, a, k, f) : M(b, a, k, f);\n      }\n      f.endBlock && f.endBlock();\n      return a;\n    }\n    function M(b, a, g, f) {\n      var h = a,\n        d = x(b, a, g, n);\n      if (0 > d) return d = ~d, d === h ? d + 1 : d;\n      var y = b[d];\n      if (\"{\" !== y) return d === h ? d + 1 : d;\n      a = d + 1;\n      d > h && \" \" === b[d - 1] && --d;\n      for (f.startRuleset && f.startRuleset(b.slice(h, d)); a < g;) {\n        y = b[a];\n        if (\"}\" === y) {\n          ++a;\n          break;\n        }\n        a = \" \" === y ? a + 1 : e(b, a, g, f);\n      }\n      f.endRuleset && f.endRuleset();\n      return a;\n    }\n    function x(b, a, g, f) {\n      for (var h, d = [], e = -1; a < g; ++a) if (h = b[a].charAt(0), \"[\" === h || \"(\" === h) d[++e] = h;else if (\"]\" === h && \"[\" === d[e] || \")\" === h && \"(\" === d[e]) --e;else if (\"{\" === h || \"}\" === h || \";\" === h || \"@\" === h || \":\" === h && !f) break;\n      0 <= e && (a = ~(a + 1));\n      return a;\n    }\n    function E(b, a, g) {\n      for (; a < g && \";\" !== b[a] && \"}\" !== b[a];) ++a;\n      return a < g && \";\" === b[a] ? a + 1 : a;\n    }\n    function e(b, a, g, f) {\n      var h = b[a++];\n      if (!v.test(h)) return E(b, a, g);\n      a < g && \" \" === b[a] && ++a;\n      if (a == g || \":\" !== b[a]) return E(b, a, g);\n      ++a;\n      a < g && \" \" === b[a] && ++a;\n      var d = x(b, a, g, C);\n      if (0 > d) d = ~d;else {\n        for (var e = [], l = 0, w = a; w < d; ++w) a = b[w], \" \" !== a && (e[l++] = a);\n        if (d < g) {\n          do {\n            a = b[d];\n            if (\";\" === a || \"}\" === a) break;\n            l = 0;\n          } while (++d < g);\n          \";\" === a && ++d;\n        }\n        l && f.declaration && f.declaration(h.toLowerCase(), e);\n      }\n      return d;\n    }\n    fa = function fa(b, a) {\n      var e = U(b);\n      a.startStylesheet && a.startStylesheet();\n      for (var f = 0, h = e.length; f < h;) f = \" \" === e[f] ? f + 1 : f < h ? \"@\" === e[f].charAt(0) ? g(e, f, h, a, n) : M(e, f, h, a) : f;\n      a.endStylesheet && a.endStylesheet();\n    };\n    var v = /^-?[a-z]/i;\n    ga = function ga(b, a) {\n      for (var g = U(b), f = 0, h = g.length; f < h;) f = \" \" !== g[f] ? e(g, f, h, a) : f + 1;\n    };\n  })();\n  \"undefined\" !== typeof window && (window.parseCssStylesheet = fa, window.parseCssDeclarations = ga);\n  var $ = {\n    d: {\n      NONE: 0,\n      URI: 1,\n      URI_FRAGMENT: 11,\n      SCRIPT: 2,\n      STYLE: 3,\n      HTML: 12,\n      ID: 4,\n      IDREF: 5,\n      IDREFS: 6,\n      GLOBAL_NAME: 7,\n      LOCAL_NAME: 8,\n      CLASSES: 9,\n      FRAME_TARGET: 10,\n      MEDIA_QUERY: 13\n    }\n  };\n  $.atype = $.d;\n  $.m = {\n    \"*::class\": 9,\n    \"*::dir\": 0,\n    \"*::draggable\": 0,\n    \"*::hidden\": 0,\n    \"*::id\": 4,\n    \"*::inert\": 0,\n    \"*::itemprop\": 0,\n    \"*::itemref\": 6,\n    \"*::itemscope\": 0,\n    \"*::lang\": 0,\n    \"*::onblur\": 2,\n    \"*::onchange\": 2,\n    \"*::onclick\": 2,\n    \"*::ondblclick\": 2,\n    \"*::onerror\": 2,\n    \"*::onfocus\": 2,\n    \"*::onkeydown\": 2,\n    \"*::onkeypress\": 2,\n    \"*::onkeyup\": 2,\n    \"*::onload\": 2,\n    \"*::onmousedown\": 2,\n    \"*::onmousemove\": 2,\n    \"*::onmouseout\": 2,\n    \"*::onmouseover\": 2,\n    \"*::onmouseup\": 2,\n    \"*::onreset\": 2,\n    \"*::onscroll\": 2,\n    \"*::onselect\": 2,\n    \"*::onsubmit\": 2,\n    \"*::ontouchcancel\": 2,\n    \"*::ontouchend\": 2,\n    \"*::ontouchenter\": 2,\n    \"*::ontouchleave\": 2,\n    \"*::ontouchmove\": 2,\n    \"*::ontouchstart\": 2,\n    \"*::onunload\": 2,\n    \"*::spellcheck\": 0,\n    \"*::style\": 3,\n    \"*::tabindex\": 0,\n    \"*::title\": 0,\n    \"*::translate\": 0,\n    \"a::accesskey\": 0,\n    \"a::coords\": 0,\n    \"a::href\": 1,\n    \"a::hreflang\": 0,\n    \"a::name\": 7,\n    \"a::onblur\": 2,\n    \"a::onfocus\": 2,\n    \"a::shape\": 0,\n    \"a::target\": 10,\n    \"a::type\": 0,\n    \"area::accesskey\": 0,\n    \"area::alt\": 0,\n    \"area::coords\": 0,\n    \"area::href\": 1,\n    \"area::nohref\": 0,\n    \"area::onblur\": 2,\n    \"area::onfocus\": 2,\n    \"area::shape\": 0,\n    \"area::target\": 10,\n    \"audio::controls\": 0,\n    \"audio::loop\": 0,\n    \"audio::mediagroup\": 5,\n    \"audio::muted\": 0,\n    \"audio::preload\": 0,\n    \"audio::src\": 1,\n    \"bdo::dir\": 0,\n    \"blockquote::cite\": 1,\n    \"br::clear\": 0,\n    \"button::accesskey\": 0,\n    \"button::disabled\": 0,\n    \"button::name\": 8,\n    \"button::onblur\": 2,\n    \"button::onfocus\": 2,\n    \"button::type\": 0,\n    \"button::value\": 0,\n    \"canvas::height\": 0,\n    \"canvas::width\": 0,\n    \"caption::align\": 0,\n    \"col::align\": 0,\n    \"col::char\": 0,\n    \"col::charoff\": 0,\n    \"col::span\": 0,\n    \"col::valign\": 0,\n    \"col::width\": 0,\n    \"colgroup::align\": 0,\n    \"colgroup::char\": 0,\n    \"colgroup::charoff\": 0,\n    \"colgroup::span\": 0,\n    \"colgroup::valign\": 0,\n    \"colgroup::width\": 0,\n    \"command::checked\": 0,\n    \"command::command\": 5,\n    \"command::disabled\": 0,\n    \"command::icon\": 1,\n    \"command::label\": 0,\n    \"command::radiogroup\": 0,\n    \"command::type\": 0,\n    \"data::value\": 0,\n    \"del::cite\": 1,\n    \"del::datetime\": 0,\n    \"details::open\": 0,\n    \"dir::compact\": 0,\n    \"div::align\": 0,\n    \"dl::compact\": 0,\n    \"fieldset::disabled\": 0,\n    \"font::color\": 0,\n    \"font::face\": 0,\n    \"font::size\": 0,\n    \"form::accept\": 0,\n    \"form::action\": 1,\n    \"form::autocomplete\": 0,\n    \"form::enctype\": 0,\n    \"form::method\": 0,\n    \"form::name\": 7,\n    \"form::novalidate\": 0,\n    \"form::onreset\": 2,\n    \"form::onsubmit\": 2,\n    \"form::target\": 10,\n    \"h1::align\": 0,\n    \"h2::align\": 0,\n    \"h3::align\": 0,\n    \"h4::align\": 0,\n    \"h5::align\": 0,\n    \"h6::align\": 0,\n    \"hr::align\": 0,\n    \"hr::noshade\": 0,\n    \"hr::size\": 0,\n    \"hr::width\": 0,\n    \"iframe::align\": 0,\n    \"iframe::frameborder\": 0,\n    \"iframe::height\": 0,\n    \"iframe::marginheight\": 0,\n    \"iframe::marginwidth\": 0,\n    \"iframe::width\": 0,\n    \"img::align\": 0,\n    \"img::alt\": 0,\n    \"img::border\": 0,\n    \"img::height\": 0,\n    \"img::hspace\": 0,\n    \"img::ismap\": 0,\n    \"img::name\": 7,\n    \"img::src\": 1,\n    \"img::usemap\": 11,\n    \"img::vspace\": 0,\n    \"img::width\": 0,\n    \"input::accept\": 0,\n    \"input::accesskey\": 0,\n    \"input::align\": 0,\n    \"input::alt\": 0,\n    \"input::autocomplete\": 0,\n    \"input::checked\": 0,\n    \"input::disabled\": 0,\n    \"input::inputmode\": 0,\n    \"input::ismap\": 0,\n    \"input::list\": 5,\n    \"input::max\": 0,\n    \"input::maxlength\": 0,\n    \"input::min\": 0,\n    \"input::multiple\": 0,\n    \"input::name\": 8,\n    \"input::onblur\": 2,\n    \"input::onchange\": 2,\n    \"input::onfocus\": 2,\n    \"input::onselect\": 2,\n    \"input::pattern\": 0,\n    \"input::placeholder\": 0,\n    \"input::readonly\": 0,\n    \"input::required\": 0,\n    \"input::size\": 0,\n    \"input::src\": 1,\n    \"input::step\": 0,\n    \"input::type\": 0,\n    \"input::usemap\": 11,\n    \"input::value\": 0,\n    \"ins::cite\": 1,\n    \"ins::datetime\": 0,\n    \"label::accesskey\": 0,\n    \"label::for\": 5,\n    \"label::onblur\": 2,\n    \"label::onfocus\": 2,\n    \"legend::accesskey\": 0,\n    \"legend::align\": 0,\n    \"li::type\": 0,\n    \"li::value\": 0,\n    \"map::name\": 7,\n    \"menu::compact\": 0,\n    \"menu::label\": 0,\n    \"menu::type\": 0,\n    \"meter::high\": 0,\n    \"meter::low\": 0,\n    \"meter::max\": 0,\n    \"meter::min\": 0,\n    \"meter::value\": 0,\n    \"ol::compact\": 0,\n    \"ol::reversed\": 0,\n    \"ol::start\": 0,\n    \"ol::type\": 0,\n    \"optgroup::disabled\": 0,\n    \"optgroup::label\": 0,\n    \"option::disabled\": 0,\n    \"option::label\": 0,\n    \"option::selected\": 0,\n    \"option::value\": 0,\n    \"output::for\": 6,\n    \"output::name\": 8,\n    \"p::align\": 0,\n    \"pre::width\": 0,\n    \"progress::max\": 0,\n    \"progress::min\": 0,\n    \"progress::value\": 0,\n    \"q::cite\": 1,\n    \"select::autocomplete\": 0,\n    \"select::disabled\": 0,\n    \"select::multiple\": 0,\n    \"select::name\": 8,\n    \"select::onblur\": 2,\n    \"select::onchange\": 2,\n    \"select::onfocus\": 2,\n    \"select::required\": 0,\n    \"select::size\": 0,\n    \"source::type\": 0,\n    \"table::align\": 0,\n    \"table::bgcolor\": 0,\n    \"table::border\": 0,\n    \"table::cellpadding\": 0,\n    \"table::cellspacing\": 0,\n    \"table::frame\": 0,\n    \"table::rules\": 0,\n    \"table::summary\": 0,\n    \"table::width\": 0,\n    \"tbody::align\": 0,\n    \"tbody::char\": 0,\n    \"tbody::charoff\": 0,\n    \"tbody::valign\": 0,\n    \"td::abbr\": 0,\n    \"td::align\": 0,\n    \"td::axis\": 0,\n    \"td::bgcolor\": 0,\n    \"td::char\": 0,\n    \"td::charoff\": 0,\n    \"td::colspan\": 0,\n    \"td::headers\": 6,\n    \"td::height\": 0,\n    \"td::nowrap\": 0,\n    \"td::rowspan\": 0,\n    \"td::scope\": 0,\n    \"td::valign\": 0,\n    \"td::width\": 0,\n    \"textarea::accesskey\": 0,\n    \"textarea::autocomplete\": 0,\n    \"textarea::cols\": 0,\n    \"textarea::disabled\": 0,\n    \"textarea::inputmode\": 0,\n    \"textarea::name\": 8,\n    \"textarea::onblur\": 2,\n    \"textarea::onchange\": 2,\n    \"textarea::onfocus\": 2,\n    \"textarea::onselect\": 2,\n    \"textarea::placeholder\": 0,\n    \"textarea::readonly\": 0,\n    \"textarea::required\": 0,\n    \"textarea::rows\": 0,\n    \"textarea::wrap\": 0,\n    \"tfoot::align\": 0,\n    \"tfoot::char\": 0,\n    \"tfoot::charoff\": 0,\n    \"tfoot::valign\": 0,\n    \"th::abbr\": 0,\n    \"th::align\": 0,\n    \"th::axis\": 0,\n    \"th::bgcolor\": 0,\n    \"th::char\": 0,\n    \"th::charoff\": 0,\n    \"th::colspan\": 0,\n    \"th::headers\": 6,\n    \"th::height\": 0,\n    \"th::nowrap\": 0,\n    \"th::rowspan\": 0,\n    \"th::scope\": 0,\n    \"th::valign\": 0,\n    \"th::width\": 0,\n    \"thead::align\": 0,\n    \"thead::char\": 0,\n    \"thead::charoff\": 0,\n    \"thead::valign\": 0,\n    \"tr::align\": 0,\n    \"tr::bgcolor\": 0,\n    \"tr::char\": 0,\n    \"tr::charoff\": 0,\n    \"tr::valign\": 0,\n    \"track::default\": 0,\n    \"track::kind\": 0,\n    \"track::label\": 0,\n    \"track::srclang\": 0,\n    \"ul::compact\": 0,\n    \"ul::type\": 0,\n    \"video::controls\": 0,\n    \"video::height\": 0,\n    \"video::loop\": 0,\n    \"video::mediagroup\": 5,\n    \"video::muted\": 0,\n    \"video::poster\": 1,\n    \"video::preload\": 0,\n    \"video::src\": 1,\n    \"video::width\": 0\n  };\n  $.ATTRIBS = $.m;\n  $.c = {\n    OPTIONAL_ENDTAG: 1,\n    EMPTY: 2,\n    CDATA: 4,\n    RCDATA: 8,\n    UNSAFE: 16,\n    FOLDABLE: 32,\n    SCRIPT: 64,\n    STYLE: 128,\n    VIRTUALIZED: 256\n  };\n  $.eflags = $.c;\n  $.f = {\n    a: 0,\n    abbr: 0,\n    acronym: 0,\n    address: 0,\n    applet: 272,\n    area: 2,\n    article: 0,\n    aside: 0,\n    audio: 0,\n    b: 0,\n    base: 274,\n    basefont: 274,\n    bdi: 0,\n    bdo: 0,\n    big: 0,\n    blockquote: 0,\n    body: 305,\n    br: 2,\n    button: 0,\n    canvas: 0,\n    caption: 0,\n    center: 0,\n    cite: 0,\n    code: 0,\n    col: 2,\n    colgroup: 1,\n    command: 2,\n    data: 0,\n    datalist: 0,\n    dd: 1,\n    del: 0,\n    details: 0,\n    dfn: 0,\n    dialog: 272,\n    dir: 0,\n    div: 0,\n    dl: 0,\n    dt: 1,\n    em: 0,\n    fieldset: 0,\n    figcaption: 0,\n    figure: 0,\n    font: 0,\n    footer: 0,\n    form: 0,\n    frame: 274,\n    frameset: 272,\n    h1: 0,\n    h2: 0,\n    h3: 0,\n    h4: 0,\n    h5: 0,\n    h6: 0,\n    head: 305,\n    header: 0,\n    hgroup: 0,\n    hr: 2,\n    html: 305,\n    i: 0,\n    iframe: 4,\n    img: 2,\n    input: 2,\n    ins: 0,\n    isindex: 274,\n    kbd: 0,\n    keygen: 274,\n    label: 0,\n    legend: 0,\n    li: 1,\n    link: 274,\n    map: 0,\n    mark: 0,\n    menu: 0,\n    meta: 274,\n    meter: 0,\n    nav: 0,\n    nobr: 0,\n    noembed: 276,\n    noframes: 276,\n    noscript: 276,\n    object: 272,\n    ol: 0,\n    optgroup: 0,\n    option: 1,\n    output: 0,\n    p: 1,\n    param: 274,\n    pre: 0,\n    progress: 0,\n    q: 0,\n    s: 0,\n    samp: 0,\n    script: 84,\n    section: 0,\n    select: 0,\n    small: 0,\n    source: 2,\n    span: 0,\n    strike: 0,\n    strong: 0,\n    style: 148,\n    sub: 0,\n    summary: 0,\n    sup: 0,\n    table: 0,\n    tbody: 1,\n    td: 1,\n    textarea: 8,\n    tfoot: 1,\n    th: 1,\n    thead: 1,\n    time: 0,\n    title: 280,\n    tr: 1,\n    track: 2,\n    tt: 0,\n    u: 0,\n    ul: 0,\n    \"var\": 0,\n    video: 0,\n    wbr: 2\n  };\n  $.ELEMENTS = $.f;\n  $.Q = {\n    a: \"HTMLAnchorElement\",\n    abbr: \"HTMLElement\",\n    acronym: \"HTMLElement\",\n    address: \"HTMLElement\",\n    applet: \"HTMLAppletElement\",\n    area: \"HTMLAreaElement\",\n    article: \"HTMLElement\",\n    aside: \"HTMLElement\",\n    audio: \"HTMLAudioElement\",\n    b: \"HTMLElement\",\n    base: \"HTMLBaseElement\",\n    basefont: \"HTMLBaseFontElement\",\n    bdi: \"HTMLElement\",\n    bdo: \"HTMLElement\",\n    big: \"HTMLElement\",\n    blockquote: \"HTMLQuoteElement\",\n    body: \"HTMLBodyElement\",\n    br: \"HTMLBRElement\",\n    button: \"HTMLButtonElement\",\n    canvas: \"HTMLCanvasElement\",\n    caption: \"HTMLTableCaptionElement\",\n    center: \"HTMLElement\",\n    cite: \"HTMLElement\",\n    code: \"HTMLElement\",\n    col: \"HTMLTableColElement\",\n    colgroup: \"HTMLTableColElement\",\n    command: \"HTMLCommandElement\",\n    data: \"HTMLElement\",\n    datalist: \"HTMLDataListElement\",\n    dd: \"HTMLElement\",\n    del: \"HTMLModElement\",\n    details: \"HTMLDetailsElement\",\n    dfn: \"HTMLElement\",\n    dialog: \"HTMLDialogElement\",\n    dir: \"HTMLDirectoryElement\",\n    div: \"HTMLDivElement\",\n    dl: \"HTMLDListElement\",\n    dt: \"HTMLElement\",\n    em: \"HTMLElement\",\n    fieldset: \"HTMLFieldSetElement\",\n    figcaption: \"HTMLElement\",\n    figure: \"HTMLElement\",\n    font: \"HTMLFontElement\",\n    footer: \"HTMLElement\",\n    form: \"HTMLFormElement\",\n    frame: \"HTMLFrameElement\",\n    frameset: \"HTMLFrameSetElement\",\n    h1: \"HTMLHeadingElement\",\n    h2: \"HTMLHeadingElement\",\n    h3: \"HTMLHeadingElement\",\n    h4: \"HTMLHeadingElement\",\n    h5: \"HTMLHeadingElement\",\n    h6: \"HTMLHeadingElement\",\n    head: \"HTMLHeadElement\",\n    header: \"HTMLElement\",\n    hgroup: \"HTMLElement\",\n    hr: \"HTMLHRElement\",\n    html: \"HTMLHtmlElement\",\n    i: \"HTMLElement\",\n    iframe: \"HTMLIFrameElement\",\n    img: \"HTMLImageElement\",\n    input: \"HTMLInputElement\",\n    ins: \"HTMLModElement\",\n    isindex: \"HTMLUnknownElement\",\n    kbd: \"HTMLElement\",\n    keygen: \"HTMLKeygenElement\",\n    label: \"HTMLLabelElement\",\n    legend: \"HTMLLegendElement\",\n    li: \"HTMLLIElement\",\n    link: \"HTMLLinkElement\",\n    map: \"HTMLMapElement\",\n    mark: \"HTMLElement\",\n    menu: \"HTMLMenuElement\",\n    meta: \"HTMLMetaElement\",\n    meter: \"HTMLMeterElement\",\n    nav: \"HTMLElement\",\n    nobr: \"HTMLElement\",\n    noembed: \"HTMLElement\",\n    noframes: \"HTMLElement\",\n    noscript: \"HTMLElement\",\n    object: \"HTMLObjectElement\",\n    ol: \"HTMLOListElement\",\n    optgroup: \"HTMLOptGroupElement\",\n    option: \"HTMLOptionElement\",\n    output: \"HTMLOutputElement\",\n    p: \"HTMLParagraphElement\",\n    param: \"HTMLParamElement\",\n    pre: \"HTMLPreElement\",\n    progress: \"HTMLProgressElement\",\n    q: \"HTMLQuoteElement\",\n    s: \"HTMLElement\",\n    samp: \"HTMLElement\",\n    script: \"HTMLScriptElement\",\n    section: \"HTMLElement\",\n    select: \"HTMLSelectElement\",\n    small: \"HTMLElement\",\n    source: \"HTMLSourceElement\",\n    span: \"HTMLSpanElement\",\n    strike: \"HTMLElement\",\n    strong: \"HTMLElement\",\n    style: \"HTMLStyleElement\",\n    sub: \"HTMLElement\",\n    summary: \"HTMLElement\",\n    sup: \"HTMLElement\",\n    table: \"HTMLTableElement\",\n    tbody: \"HTMLTableSectionElement\",\n    td: \"HTMLTableDataCellElement\",\n    textarea: \"HTMLTextAreaElement\",\n    tfoot: \"HTMLTableSectionElement\",\n    th: \"HTMLTableHeaderCellElement\",\n    thead: \"HTMLTableSectionElement\",\n    time: \"HTMLTimeElement\",\n    title: \"HTMLTitleElement\",\n    tr: \"HTMLTableRowElement\",\n    track: \"HTMLTrackElement\",\n    tt: \"HTMLElement\",\n    u: \"HTMLElement\",\n    ul: \"HTMLUListElement\",\n    \"var\": \"HTMLElement\",\n    video: \"HTMLVideoElement\",\n    wbr: \"HTMLElement\"\n  };\n  $.ELEMENT_DOM_INTERFACES = $.Q;\n  $.P = {\n    NOT_LOADED: 0,\n    SAME_DOCUMENT: 1,\n    NEW_DOCUMENT: 2\n  };\n  $.ueffects = $.P;\n  $.J = {\n    \"a::href\": 2,\n    \"area::href\": 2,\n    \"audio::src\": 1,\n    \"blockquote::cite\": 0,\n    \"command::icon\": 1,\n    \"del::cite\": 0,\n    \"form::action\": 2,\n    \"img::src\": 1,\n    \"input::src\": 1,\n    \"ins::cite\": 0,\n    \"q::cite\": 0,\n    \"video::poster\": 1,\n    \"video::src\": 1\n  };\n  $.URIEFFECTS = $.J;\n  $.M = {\n    UNSANDBOXED: 2,\n    SANDBOXED: 1,\n    DATA: 0\n  };\n  $.ltypes = $.M;\n  $.I = {\n    \"a::href\": 2,\n    \"area::href\": 2,\n    \"audio::src\": 2,\n    \"blockquote::cite\": 2,\n    \"command::icon\": 1,\n    \"del::cite\": 2,\n    \"form::action\": 2,\n    \"img::src\": 1,\n    \"input::src\": 1,\n    \"ins::cite\": 2,\n    \"q::cite\": 2,\n    \"video::poster\": 1,\n    \"video::src\": 2\n  };\n  $.LOADERTYPES = $.I;\n  \"undefined\" !== typeof window && (window.html4 = $);\n  var ha = function (g) {\n      function w(a) {\n        if (i.hasOwnProperty(a)) return i[a];\n        var b = a.match(q);\n        return b ? String.fromCharCode(parseInt(b[1], 10)) : (b = a.match(B)) ? String.fromCharCode(parseInt(b[1], 16)) : r && F.test(a) ? (r.innerHTML = \"&\" + a + \";\", b = r.textContent, i[a] = b) : \"&\" + a + \";\";\n      }\n      function M(a, b) {\n        return w(b);\n      }\n      function x(a) {\n        return a.replace(j, M);\n      }\n      function E(a) {\n        return (\"\" + a).replace(R, \"&amp;\").replace(P, \"&lt;\").replace(S, \"&gt;\").replace(D, \"&#34;\");\n      }\n      function e(a) {\n        return a.replace(ia, \"&amp;$1\").replace(P, \"&lt;\").replace(S, \"&gt;\");\n      }\n      function v(b) {\n        var d = {\n          z: b.z || b.cdata,\n          A: b.A || b.comment,\n          B: b.B || b.endDoc,\n          t: b.t || b.endTag,\n          e: b.e || b.pcdata,\n          F: b.F || b.rcdata,\n          H: b.H || b.startDoc,\n          w: b.w || b.startTag\n        };\n        return function (b, g) {\n          var f;\n          var H = /(<\\/|<\\!--|<[!?]|[&<>])/g;\n          f = b + \"\";\n          if (G) f = f.split(H);else {\n            for (var e = [], h = 0, j; (j = H.exec(f)) !== s;) e.push(f.substring(h, j.index)), e.push(j[0]), h = j.index + j[0].length;\n            e.push(f.substring(h));\n            f = e;\n          }\n          a(d, f, 0, {\n            r: C,\n            C: C\n          }, g);\n        };\n      }\n      function b(b, d, g, f, t) {\n        return function () {\n          a(b, d, g, f, t);\n        };\n      }\n      function a(a, d, p, e, t) {\n        try {\n          a.H && 0 == p && a.H(t);\n          for (var h, z, j, i = d.length; p < i;) {\n            var o = d[p++],\n              l = d[p];\n            switch (o) {\n              case \"&\":\n                I.test(l) ? (a.e && a.e(\"&\" + l, t, A, b(a, d, p, e, t)), p++) : a.e && a.e(\"&amp;\", t, A, b(a, d, p, e, t));\n                break;\n              case \"</\":\n                if (h = /^([-\\w:]+)[^\\'\\\"]*/.exec(l)) {\n                  if (h[0].length === l.length && \">\" === d[p + 1]) p += 2, j = h[1].toLowerCase(), a.t && a.t(j, t, A, b(a, d, p, e, t));else {\n                    var m = d,\n                      q = p,\n                      r = a,\n                      u = t,\n                      v = A,\n                      y = e,\n                      w = f(m, q);\n                    w ? (r.t && r.t(w.name, u, v, b(r, m, q, y, u)), p = w.next) : p = m.length;\n                  }\n                } else a.e && a.e(\"&lt;/\", t, A, b(a, d, p, e, t));\n                break;\n              case \"<\":\n                if (h = /^([-\\w:]+)\\s*\\/?/.exec(l)) {\n                  if (h[0].length === l.length && \">\" === d[p + 1]) {\n                    p += 2;\n                    j = h[1].toLowerCase();\n                    a.w && a.w(j, [], t, A, b(a, d, p, e, t));\n                    var B = g.f[j];\n                    B & K && (p = k(d, {\n                      name: j,\n                      next: p,\n                      c: B\n                    }, a, t, A, e));\n                  } else {\n                    var m = d,\n                      q = a,\n                      r = t,\n                      u = A,\n                      v = e,\n                      x = f(m, p);\n                    x ? (q.w && q.w(x.name, x.R, r, u, b(q, m, x.next, v, r)), p = x.c & K ? k(m, x, q, r, u, v) : x.next) : p = m.length;\n                  }\n                } else a.e && a.e(\"&lt;\", t, A, b(a, d, p, e, t));\n                break;\n              case \"<\\!--\":\n                if (!e.C) {\n                  for (z = p + 1; z < i && !(\">\" === d[z] && /--$/.test(d[z - 1])); z++);\n                  if (z < i) {\n                    if (a.A) {\n                      var D = d.slice(p, z).join(\"\");\n                      a.A(D.substr(0, D.length - 2), t, A, b(a, d, z + 1, e, t));\n                    }\n                    p = z + 1;\n                  } else e.C = n;\n                }\n                e.C && a.e && a.e(\"&lt;!--\", t, A, b(a, d, p, e, t));\n                break;\n              case \"<!\":\n                if (/^\\w/.test(l)) {\n                  if (!e.r) {\n                    for (z = p + 1; z < i && \">\" !== d[z]; z++);\n                    z < i ? p = z + 1 : e.r = n;\n                  }\n                  e.r && a.e && a.e(\"&lt;!\", t, A, b(a, d, p, e, t));\n                } else a.e && a.e(\"&lt;!\", t, A, b(a, d, p, e, t));\n                break;\n              case \"<?\":\n                if (!e.r) {\n                  for (z = p + 1; z < i && \">\" !== d[z]; z++);\n                  z < i ? p = z + 1 : e.r = n;\n                }\n                e.r && a.e && a.e(\"&lt;?\", t, A, b(a, d, p, e, t));\n                break;\n              case \">\":\n                a.e && a.e(\"&gt;\", t, A, b(a, d, p, e, t));\n                break;\n              case \"\":\n                break;\n              default:\n                a.e && a.e(o, t, A, b(a, d, p, e, t));\n            }\n          }\n          a.B && a.B(t);\n        } catch (E) {\n          if (E !== A) throw E;\n        }\n      }\n      function k(a, d, f, h, t, j) {\n        var z = a.length;\n        T.hasOwnProperty(d.name) || (T[d.name] = RegExp(\"^\" + d.name + \"(?:[\\\\s\\\\/]|$)\", \"i\"));\n        for (var i = T[d.name], k = d.next, l = d.next + 1; l < z && !(\"</\" === a[l - 1] && i.test(a[l])); l++);\n        l < z && (l -= 1);\n        z = a.slice(k, l).join(\"\");\n        if (d.c & g.c.CDATA) f.z && f.z(z, h, t, b(f, a, l, j, h));else if (d.c & g.c.RCDATA) f.F && f.F(e(z), h, t, b(f, a, l, j, h));else throw Error(\"bug\");\n        return l;\n      }\n      function f(a, b) {\n        var d = /^([-\\w:]+)/.exec(a[b]),\n          f = {};\n        f.name = d[1].toLowerCase();\n        f.c = g.f[f.name];\n        for (var e = a[b].substr(d[0].length), h = b + 1, j = a.length; h < j && \">\" !== a[h]; h++) e += a[h];\n        if (!(j <= h)) {\n          for (var l = []; \"\" !== e;) if (d = ja.exec(e)) {\n            if (d[4] && !d[5] || d[6] && !d[7]) {\n              for (var d = d[4] || d[6], i = C, e = [e, a[h++]]; h < j; h++) {\n                if (i) {\n                  if (\">\" === a[h]) break;\n                } else 0 <= a[h].indexOf(d) && (i = n);\n                e.push(a[h]);\n              }\n              if (j <= h) break;\n              e = e.join(\"\");\n            } else {\n              var i = d[1].toLowerCase(),\n                k;\n              if (d[2]) {\n                k = d[3];\n                var m = k.charCodeAt(0);\n                if (34 === m || 39 === m) k = k.substr(1, k.length - 2);\n                k = x(k.replace(o, \"\"));\n              } else k = \"\";\n              l.push(i, k);\n              e = e.substr(d[0].length);\n            }\n          } else e = e.replace(/^[\\s\\S][^a-z\\s]*/, \"\");\n          f.R = l;\n          f.next = h + 1;\n          return f;\n        }\n      }\n      function h(a) {\n        function b(a, d) {\n          f || d.push(a);\n        }\n        var d, f;\n        return v({\n          startDoc: function startDoc() {\n            d = [];\n            f = C;\n          },\n          startTag: function startTag(b, e, h) {\n            if (!f && g.f.hasOwnProperty(b)) {\n              var j = g.f[b];\n              if (!(j & g.c.FOLDABLE)) {\n                var k = a(b, e);\n                if (k) {\n                  if (\"object\" !== _typeof(k)) throw Error(\"tagPolicy did not return object (old API?)\");\n                  if (\"attribs\" in k) e = k.attribs;else throw Error(\"tagPolicy gave no attribs\");\n                  var i;\n                  \"tagName\" in k ? (i = k.tagName, k = g.f[i]) : (i = b, k = j);\n                  if (j & g.c.OPTIONAL_ENDTAG) {\n                    var l = d[d.length - 1];\n                    l && l.D === b && (l.v !== i || b !== i) && h.push(\"</\", l.v, \">\");\n                  }\n                  j & g.c.EMPTY || d.push({\n                    D: b,\n                    v: i\n                  });\n                  h.push(\"<\", i);\n                  b = 0;\n                  for (l = e.length; b < l; b += 2) {\n                    var m = e[b],\n                      o = e[b + 1];\n                    o !== s && o !== c && h.push(\" \", m, '=\"', E(o), '\"');\n                  }\n                  h.push(\">\");\n                  j & g.c.EMPTY && !(k & g.c.EMPTY) && h.push(\"</\", i, \">\");\n                } else f = !(j & g.c.EMPTY);\n              }\n            }\n          },\n          endTag: function endTag(a, b) {\n            if (f) f = C;else if (g.f.hasOwnProperty(a)) {\n              var e = g.f[a];\n              if (!(e & (g.c.EMPTY | g.c.FOLDABLE))) {\n                if (e & g.c.OPTIONAL_ENDTAG) for (e = d.length; 0 <= --e;) {\n                  var h = d[e].D;\n                  if (h === a) break;\n                  if (!(g.f[h] & g.c.OPTIONAL_ENDTAG)) return;\n                } else for (e = d.length; 0 <= --e && d[e].D !== a;);\n                if (!(0 > e)) {\n                  for (h = d.length; --h > e;) {\n                    var j = d[h].v;\n                    g.f[j] & g.c.OPTIONAL_ENDTAG || b.push(\"</\", j, \">\");\n                  }\n                  e < d.length && (a = d[e].v);\n                  d.length = e;\n                  b.push(\"</\", a, \">\");\n                }\n              }\n            }\n          },\n          pcdata: b,\n          rcdata: b,\n          cdata: b,\n          endDoc: function endDoc(a) {\n            for (; d.length; d.length--) a.push(\"</\", d[d.length - 1].v, \">\");\n          }\n        });\n      }\n      function d(a, b, d, f, e) {\n        if (!e) return s;\n        try {\n          var g = Y.parse(\"\" + a);\n          if (g && (!g.K() || ka.test(g.W()))) {\n            var h = e(g, b, d, f);\n            return h ? h.toString() : s;\n          }\n        } catch (j) {}\n        return s;\n      }\n      function y(a, b, d, f, e) {\n        d || a(b + \" removed\", {\n          S: \"removed\",\n          tagName: b\n        });\n        if (f !== e) {\n          var g = \"changed\";\n          f && !e ? g = \"removed\" : !f && e && (g = \"added\");\n          a(b + \".\" + d + \" \" + g, {\n            S: g,\n            tagName: b,\n            la: d,\n            oldValue: f,\n            newValue: e\n          });\n        }\n      }\n      function l(a, b, d) {\n        b = b + \"::\" + d;\n        if (a.hasOwnProperty(b)) return a[b];\n        b = \"*::\" + d;\n        if (a.hasOwnProperty(b)) return a[b];\n      }\n      function V(a, b, f, e, h) {\n        for (var j = 0; j < b.length; j += 2) {\n          var k = b[j],\n            i = b[j + 1],\n            m = i,\n            o = s,\n            q;\n          if ((q = a + \"::\" + k, g.m.hasOwnProperty(q)) || (q = \"*::\" + k, g.m.hasOwnProperty(q))) o = g.m[q];\n          if (o !== s) switch (o) {\n            case g.d.NONE:\n              break;\n            case g.d.SCRIPT:\n              i = s;\n              h && y(h, a, k, m, i);\n              break;\n            case g.d.STYLE:\n              if (\"undefined\" === typeof N) {\n                i = s;\n                h && y(h, a, k, m, i);\n                break;\n              }\n              var r = [];\n              N(i, {\n                declaration: function declaration(a, b) {\n                  var e = a.toLowerCase();\n                  u(e, b, f ? function (a) {\n                    return d(a, g.P.ja, g.M.ka, {\n                      TYPE: \"CSS\",\n                      CSS_PROP: e\n                    }, f);\n                  } : s);\n                  b.length && r.push(e + \": \" + b.join(\" \"));\n                }\n              });\n              i = 0 < r.length ? r.join(\" ; \") : s;\n              h && y(h, a, k, m, i);\n              break;\n            case g.d.ID:\n            case g.d.IDREF:\n            case g.d.IDREFS:\n            case g.d.GLOBAL_NAME:\n            case g.d.LOCAL_NAME:\n            case g.d.CLASSES:\n              i = e ? e(i) : i;\n              h && y(h, a, k, m, i);\n              break;\n            case g.d.URI:\n              i = d(i, l(g.J, a, k), l(g.I, a, k), {\n                TYPE: \"MARKUP\",\n                XML_ATTR: k,\n                XML_TAG: a\n              }, f);\n              h && y(h, a, k, m, i);\n              break;\n            case g.d.URI_FRAGMENT:\n              i && \"#\" === i.charAt(0) ? (i = i.substring(1), i = e ? e(i) : i, i !== s && i !== c && (i = \"#\" + i)) : i = s;\n              h && y(h, a, k, m, i);\n              break;\n            default:\n              i = s, h && y(h, a, k, m, i);\n          } else i = s, h && y(h, a, k, m, i);\n          b[j + 1] = i;\n        }\n        return b;\n      }\n      function ea(a, b, d) {\n        return function (e, f) {\n          if (g.f[e] & g.c.UNSAFE) d && y(d, e, c, c, c);else return {\n            attribs: V(e, f, a, b, d)\n          };\n        };\n      }\n      function Q(a, b) {\n        var d = [];\n        h(b)(a, d);\n        return d.join(\"\");\n      }\n      var N, u;\n      \"undefined\" !== typeof window && (N = window.parseCssDeclarations, u = window.sanitizeCssProperty);\n      var i = {\n          lt: \"<\",\n          LT: \"<\",\n          gt: \">\",\n          GT: \">\",\n          amp: \"&\",\n          AMP: \"&\",\n          quot: '\"',\n          apos: \"'\",\n          nbsp: \"\\xA0\"\n        },\n        q = /^#(\\d+)$/,\n        B = /^#x([0-9A-Fa-f]+)$/,\n        F = /^[A-Za-z][A-za-z0-9]+$/,\n        r = \"undefined\" !== typeof window && window.document ? window.document.createElement(\"textarea\") : s,\n        o = /\\0/g,\n        j = /&(#[0-9]+|#[xX][0-9A-Fa-f]+|\\w+);/g,\n        I = /^(#[0-9]+|#[xX][0-9A-Fa-f]+|\\w+);/,\n        R = /&/g,\n        ia = /&([^a-z#]|#(?:[^0-9x]|x(?:[^0-9a-f]|$)|$)|$)/gi,\n        P = /[<]/g,\n        S = />/g,\n        D = /\\\"/g,\n        ja = /^\\s*([-.:\\w]+)(?:\\s*(=)\\s*((\")[^\"]*(\"|$)|(')[^']*('|$)|(?=[a-z][-\\w]*\\s*=)|[^\"'\\s]*))?/i,\n        G = 3 === \"a,b\".split(/(,)/).length,\n        K = g.c.CDATA | g.c.RCDATA,\n        A = {},\n        T = {},\n        ka = /^(?:https?|mailto|data)$/i,\n        m = {};\n      m.pa = m.escapeAttrib = E;\n      m.ra = m.makeHtmlSanitizer = h;\n      m.sa = m.makeSaxParser = v;\n      m.ta = m.makeTagPolicy = ea;\n      m.wa = m.normalizeRCData = e;\n      m.xa = m.sanitize = function (a, b, d, e) {\n        return Q(a, ea(b, d, e));\n      };\n      m.ya = m.sanitizeAttribs = V;\n      m.za = m.sanitizeWithPolicy = Q;\n      m.Ba = m.unescapeEntities = x;\n      return m;\n    }($),\n    la = ha.sanitize;\n  \"undefined\" !== typeof window && (window.html = ha, window.html_sanitize = la);\n})();\nvar _default = exports[\"default\"] = {};\n\n//# sourceURL=webpack://bos-platform/./src/workflow/vendor/sanitizer.min.js?");

/***/ }),

/***/ "./src/workflow/css/AbsApprovalRecord.less":
/*!*************************************************!*\
  !*** ./src/workflow/css/AbsApprovalRecord.less ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"signature\":\"AbsApprovalRecord_signature_bvjE\"});\n\n//# sourceURL=webpack://bos-platform/./src/workflow/css/AbsApprovalRecord.less?");

/***/ }),

/***/ "./src/workflow/css/ApprovalHistoryRecord.less":
/*!*****************************************************!*\
  !*** ./src/workflow/css/ApprovalHistoryRecord.less ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"approval-history-record\":\"ApprovalHistoryRecord_approval-history-record_ZDR3\",\"record-header\":\"ApprovalHistoryRecord_record-header_KRdV\",\"record-title\":\"ApprovalHistoryRecord_record-title_2SqR\",\"backToParentProcess\":\"ApprovalHistoryRecord_backToParentProcess_1weR\",\"icon-retract\":\"ApprovalHistoryRecord_icon-retract_2muq\",\"latest-record\":\"ApprovalHistoryRecord_latest-record_1Xgc\",\"no-record\":\"ApprovalHistoryRecord_no-record_vQ1l\",\"records\":\"ApprovalHistoryRecord_records_2vsv\",\"record-item\":\"ApprovalHistoryRecord_record-item_NE9D\",\"avatar\":\"ApprovalHistoryRecord_avatar_5Xzr\",\"info\":\"ApprovalHistoryRecord_info_PIjW\",\"assignee\":\"ApprovalHistoryRecord_assignee_3oXr\",\"time\":\"ApprovalHistoryRecord_time_eELR\",\"result\":\"ApprovalHistoryRecord_result_3KYm\",\"icon-comment\":\"ApprovalHistoryRecord_icon-comment_2Q3V\",\"comment-content\":\"ApprovalHistoryRecord_comment-content_2nCl\",\"msg\":\"ApprovalHistoryRecord_msg_1Nev\",\"comment-callActivity\":\"ApprovalHistoryRecord_comment-callActivity_24t8\",\"procAttach\":\"ApprovalHistoryRecord_procAttach_4siu\",\"attachment\":\"ApprovalHistoryRecord_attachment_2sOv\",\"attach-icon\":\"ApprovalHistoryRecord_attach-icon_24Wk\",\"filename\":\"ApprovalHistoryRecord_filename_3NTj\",\"filesize\":\"ApprovalHistoryRecord_filesize_4guJ\",\"operate\":\"ApprovalHistoryRecord_operate_Hn3h\",\"fileyulan\":\"ApprovalHistoryRecord_fileyulan_1nzl\",\"filexiazai\":\"ApprovalHistoryRecord_filexiazai_1UKW\",\"auditpoints-title\":\"ApprovalHistoryRecord_auditpoints-title_2qf-\",\"link-control\":\"ApprovalHistoryRecord_link-control_372S\",\"record-auditpoints\":\"ApprovalHistoryRecord_record-auditpoints_Has4\",\"auditPointsItem\":\"ApprovalHistoryRecord_auditPointsItem_3hvI\",\"statusImage\":\"ApprovalHistoryRecord_statusImage_13kt\",\"displayName\":\"ApprovalHistoryRecord_displayName_ErLG\",\"failedReason\":\"ApprovalHistoryRecord_failedReason_3Yrl\",\"btn-panel\":\"ApprovalHistoryRecord_btn-panel_3FBW\",\"historic-coordinate\":\"ApprovalHistoryRecord_historic-coordinate_193S\",\"title\":\"ApprovalHistoryRecord_title_1VFN\",\"detail\":\"ApprovalHistoryRecord_detail_Fzek\",\"headline\":\"ApprovalHistoryRecord_headline_eT4f\",\"coordinateRecord\":\"ApprovalHistoryRecord_coordinateRecord_LliL\",\"left\":\"ApprovalHistoryRecord_left_IR-t\",\"right\":\"ApprovalHistoryRecord_right_eTiR\",\"coordinateName\":\"ApprovalHistoryRecord_coordinateName_8jPN\",\"message\":\"ApprovalHistoryRecord_message_29NH\",\"fujian\":\"ApprovalHistoryRecord_fujian_2onu\",\"historic-record\":\"ApprovalHistoryRecord_historic-record_293N\"});\n\n//# sourceURL=webpack://bos-platform/./src/workflow/css/ApprovalHistoryRecord.less?");

/***/ }),

/***/ "./src/workflow/css/ApprovalRecord.less":
/*!**********************************************!*\
  !*** ./src/workflow/css/ApprovalRecord.less ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"containerStyle\":\"ApprovalRecord_containerStyle_384r\",\"containerStyleNoLine\":\"ApprovalRecord_containerStyleNoLine_3i5h\",\"withoutApprovalRecord\":\"ApprovalRecord_withoutApprovalRecord_6dgy\",\"description\":\"ApprovalRecord_description_2C2t\",\"backToParentProcess\":\"ApprovalRecord_backToParentProcess_2kOx\",\"rowStyle\":\"ApprovalRecord_rowStyle_1-QI\",\"timeLine\":\"ApprovalRecord_timeLine_3a_d\",\"circle\":\"ApprovalRecord_circle_kEVi\",\"content\":\"ApprovalRecord_content_2QHP\",\"contentMobile\":\"ApprovalRecord_contentMobile_2Bjs\",\"userImg\":\"ApprovalRecord_userImg_7KLH\",\"textWrap\":\"ApprovalRecord_textWrap_bSoj\",\"option\":\"ApprovalRecord_option_3aIX\",\"textContent\":\"ApprovalRecord_textContent_2Odt\",\"textContenth\":\"ApprovalRecord_textContenth_3Mr1\",\"textContenthMobile\":\"ApprovalRecord_textContenthMobile_3zo7\",\"talkImg\":\"ApprovalRecord_talkImg_1Brq\",\"talkImgPhone\":\"ApprovalRecord_talkImgPhone_2Kcm\",\"time\":\"ApprovalRecord_time_zPG-\",\"procAttach\":\"ApprovalRecord_procAttach_JceA\",\"attachment\":\"ApprovalRecord_attachment_tGWS\",\"attach-icon\":\"ApprovalRecord_attach-icon_E1BN\",\"filename\":\"ApprovalRecord_filename_2W4F\",\"filesize\":\"ApprovalRecord_filesize_bqAw\",\"operate\":\"ApprovalRecord_operate_3I99\",\"fileyulan\":\"ApprovalRecord_fileyulan_1upL\",\"filexiazai\":\"ApprovalRecord_filexiazai_3ITb\",\"attachmentForMob\":\"ApprovalRecord_attachmentForMob_csEN\",\"option-callActivity\":\"ApprovalRecord_option-callActivity_JB6F\",\"lastNode\":\"ApprovalRecord_lastNode_1P6q\",\"showTransferRecord\":\"ApprovalRecord_showTransferRecord_GHYZ\",\"showCoordinateTransfer\":\"ApprovalRecord_showCoordinateTransfer_1Fwl\",\"coordinate-record\":\"ApprovalRecord_coordinate-record_34Ud\",\"coordinate\":\"ApprovalRecord_coordinate_atZN\",\"title\":\"ApprovalRecord_title_bBQn\",\"coordinateRecord\":\"ApprovalRecord_coordinateRecord_3eKu\",\"left\":\"ApprovalRecord_left_3Kfk\",\"avatar\":\"ApprovalRecord_avatar_3BS4\",\"right\":\"ApprovalRecord_right_2Lnz\",\"coordinateName\":\"ApprovalRecord_coordinateName_cbHN\",\"message\":\"ApprovalRecord_message_iAZy\",\"fujian\":\"ApprovalRecord_fujian_2WsU\",\"groupChat\":\"ApprovalRecord_groupChat_1Dc5\",\"aGroup\":\"ApprovalRecord_aGroup_18C0\",\"aGroupMobile\":\"ApprovalRecord_aGroupMobile_1Si7\",\"chatPosition\":\"ApprovalRecord_chatPosition_1b1R\",\"groupChatMobile\":\"ApprovalRecord_groupChatMobile_20xE\",\"btn-panel\":\"ApprovalRecord_btn-panel_3KbU\",\"addSignMsg\":\"ApprovalRecord_addSignMsg_3Wzn\"});\n\n//# sourceURL=webpack://bos-platform/./src/workflow/css/ApprovalRecord.less?");

/***/ }),

/***/ "./src/workflow/css/ApprovalRecordNew.less":
/*!*************************************************!*\
  !*** ./src/workflow/css/ApprovalRecordNew.less ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"containerStyle\":\"ApprovalRecordNew_containerStyle_1tGi\",\"containerStyleNoLine\":\"ApprovalRecordNew_containerStyleNoLine_2XRS\",\"backToParentProcess\":\"ApprovalRecordNew_backToParentProcess_6sNr\",\"rowStyle\":\"ApprovalRecordNew_rowStyle_2rUi\",\"timeLine\":\"ApprovalRecordNew_timeLine_1Xvw\",\"timeLineWait\":\"ApprovalRecordNew_timeLineWait_Tg5u\",\"timeLineRefuse\":\"ApprovalRecordNew_timeLineRefuse_duV4\",\"timeLineAgree\":\"ApprovalRecordNew_timeLineAgree_2WtG\",\"circle\":\"ApprovalRecordNew_circle_3sV1\",\"firstCircle\":\"ApprovalRecordNew_firstCircle_3y6Y\",\"waiting\":\"ApprovalRecordNew_waiting_2ZRA\",\"agree\":\"ApprovalRecordNew_agree_2nn9\",\"refuse\":\"ApprovalRecordNew_refuse_16ce\",\"content\":\"ApprovalRecordNew_content_2TAW\",\"contentMobile\":\"ApprovalRecordNew_contentMobile_2lOK\",\"userImg\":\"ApprovalRecordNew_userImg_19t6\",\"textWrap\":\"ApprovalRecordNew_textWrap_1-fo\",\"textWrap1\":\"ApprovalRecordNew_textWrap1_1i2y\",\"unvisible\":\"ApprovalRecordNew_unvisible_3oPk\",\"textContent\":\"ApprovalRecordNew_textContent_GkWv\",\"textContenth\":\"ApprovalRecordNew_textContenth_P7Br\",\"textContenthMobile\":\"ApprovalRecordNew_textContenthMobile_2r_D\",\"textContextState\":\"ApprovalRecordNew_textContextState_3GT1\",\"stateInfoClassWait\":\"ApprovalRecordNew_stateInfoClassWait_2omk\",\"stateInfoClassReject\":\"ApprovalRecordNew_stateInfoClassReject_2viG\",\"stateInfoClassApprove\":\"ApprovalRecordNew_stateInfoClassApprove_MiHS\",\"textContextArrow\":\"ApprovalRecordNew_textContextArrow_1hbP\",\"assignee\":\"ApprovalRecordNew_assignee_1-Ju\",\"callActivityName\":\"ApprovalRecordNew_callActivityName_2zy2\",\"callActivityResult\":\"ApprovalRecordNew_callActivityResult_2Ouj\",\"firstAssigneeClass\":\"ApprovalRecordNew_firstAssigneeClass_1Yxr\",\"result\":\"ApprovalRecordNew_result_3sSw\",\"procAttach\":\"ApprovalRecordNew_procAttach_QVKc\",\"attachment\":\"ApprovalRecordNew_attachment_3K6G\",\"attach-icon\":\"ApprovalRecordNew_attach-icon_7fv_\",\"filename\":\"ApprovalRecordNew_filename_171w\",\"filesize\":\"ApprovalRecordNew_filesize_3O6H\",\"stateInfoDismissedClass\":\"ApprovalRecordNew_stateInfoDismissedClass_1A6_\",\"assigneeDismissedClass\":\"ApprovalRecordNew_assigneeDismissedClass_3i3b\",\"firstResultInfoClass\":\"ApprovalRecordNew_firstResultInfoClass_2tWV\",\"assigneeState\":\"ApprovalRecordNew_assigneeState_3Azz\",\"assigneeStateAgree\":\"ApprovalRecordNew_assigneeStateAgree_3UO0\",\"assigneeStateRefuse\":\"ApprovalRecordNew_assigneeStateRefuse_1bbI\",\"assigneeStateTerminate\":\"ApprovalRecordNew_assigneeStateTerminate_1HmT\",\"talkImg\":\"ApprovalRecordNew_talkImg_1Mm_\",\"talkImgPhone\":\"ApprovalRecordNew_talkImgPhone_2y70\",\"time\":\"ApprovalRecordNew_time_3A-t\",\"firstTimeClass\":\"ApprovalRecordNew_firstTimeClass_3jKo\",\"option\":\"ApprovalRecordNew_option_2iMy\",\"lastNode\":\"ApprovalRecordNew_lastNode_2Uyr\",\"groupChat\":\"ApprovalRecordNew_groupChat_1H_3\",\"aGroup\":\"ApprovalRecordNew_aGroup_2g4u\",\"aGroupMobile\":\"ApprovalRecordNew_aGroupMobile_1odX\",\"chatPosition\":\"ApprovalRecordNew_chatPosition_MmNK\",\"groupChatMobile\":\"ApprovalRecordNew_groupChatMobile_1abB\",\"showTransferRecord\":\"ApprovalRecordNew_showTransferRecord_DXrD\",\"coordinate-record\":\"ApprovalRecordNew_coordinate-record_xrWV\",\"coordinate\":\"ApprovalRecordNew_coordinate_2Onj\",\"arrow\":\"ApprovalRecordNew_arrow_2Tec\",\"arrowleft\":\"ApprovalRecordNew_arrowleft_ji2N\",\"arrowdown\":\"ApprovalRecordNew_arrowdown_2hoh\",\"coordinateRecord\":\"ApprovalRecordNew_coordinateRecord_20hf\",\"left\":\"ApprovalRecordNew_left_19nB\",\"avatar\":\"ApprovalRecordNew_avatar_2vv3\",\"right\":\"ApprovalRecordNew_right_6s16\",\"coordinateName\":\"ApprovalRecordNew_coordinateName_2WJo\",\"coordinating\":\"ApprovalRecordNew_coordinating_Cc77\",\"message\":\"ApprovalRecordNew_message_oZul\",\"fujian\":\"ApprovalRecordNew_fujian_zWit\",\"links-panel\":\"ApprovalRecordNew_links-panel_2ZHa\",\"panel-title\":\"ApprovalRecordNew_panel-title_KGzS\",\"panel\":\"ApprovalRecordNew_panel_1Ebf\",\"text\":\"ApprovalRecordNew_text_3B9E\",\"links\":\"ApprovalRecordNew_links_2Zxh\",\"addSignMsg\":\"ApprovalRecordNew_addSignMsg_dEDF\"});\n\n//# sourceURL=webpack://bos-platform/./src/workflow/css/ApprovalRecordNew.less?");

/***/ }),

/***/ "./src/workflow/css/BillCard.less":
/*!****************************************!*\
  !*** ./src/workflow/css/BillCard.less ***!
  \****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"box\":\"BillCard_box_1dcR\",\"activatedCard\":\"BillCard_activatedCard_1hfu\",\"commonHeader\":\"BillCard_commonHeader_3SVW\",\"header\":\"BillCard_header_1hL0\",\"lockHeader\":\"BillCard_lockHeader_230l\",\"title\":\"BillCard_title_2Tbc\",\"subtitle\":\"BillCard_subtitle_38uF\",\"link\":\"BillCard_link_3Z3a\",\"icon\":\"BillCard_icon_16dD\",\"commonContent\":\"BillCard_commonContent_2yFF\",\"content\":\"BillCard_content_3sm6\",\"lockContent\":\"BillCard_lockContent_1iLV\",\"note\":\"BillCard_note_2KRw\"});\n\n//# sourceURL=webpack://bos-platform/./src/workflow/css/BillCard.less?");

/***/ }),

/***/ "./src/workflow/css/BillSummaryInfo.less":
/*!***********************************************!*\
  !*** ./src/workflow/css/BillSummaryInfo.less ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"billSummaryInfo\":\"BillSummaryInfo_billSummaryInfo_3eOO\"});\n\n//# sourceURL=webpack://bos-platform/./src/workflow/css/BillSummaryInfo.less?");

/***/ }),

/***/ "./src/workflow/css/Diagram.less":
/*!***************************************!*\
  !*** ./src/workflow/css/Diagram.less ***!
  \***************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"geDiagramContainer\":\"Diagram_geDiagramContainer_3RgD\",\"geDiagramBackdrop\":\"Diagram_geDiagramBackdrop_D5Ev\",\"geBackgroundPage\":\"Diagram_geBackgroundPage_btyU\",\"rubberband\":\"Diagram_rubberband_26L6\",\"activatedCell\":\"Diagram_activatedCell_3K6f\"});\n\n//# sourceURL=webpack://bos-platform/./src/workflow/css/Diagram.less?");

/***/ }),

/***/ "./src/workflow/css/FloatLayer.less":
/*!******************************************!*\
  !*** ./src/workflow/css/FloatLayer.less ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"floatlayer\":\"FloatLayer_floatlayer_17YS\"});\n\n//# sourceURL=webpack://bos-platform/./src/workflow/css/FloatLayer.less?");

/***/ }),

/***/ "./src/workflow/css/FloatToolbar.less":
/*!********************************************!*\
  !*** ./src/workflow/css/FloatToolbar.less ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"floatToolbar\":\"FloatToolbar_floatToolbar_1b3T\",\"item\":\"FloatToolbar_item_1A9E\",\"icon\":\"FloatToolbar_icon_1CPV\",\"download\":\"FloatToolbar_download_1s3J\",\"tip\":\"FloatToolbar_tip_L_Ns\",\"text\":\"FloatToolbar_text_6bEg\",\"triangle\":\"FloatToolbar_triangle_3vkS\",\"zoom-out\":\"FloatToolbar_zoom-out_1NRF\",\"zoom-in\":\"FloatToolbar_zoom-in_Zqwc\",\"visible\":\"FloatToolbar_visible_1PZj\",\"notvisible\":\"FloatToolbar_notvisible_33I2\",\"floatButtons\":\"FloatToolbar_floatButtons_lV_c\",\"button\":\"FloatToolbar_button_3ZQ7\",\"right\":\"FloatToolbar_right_3HJ9\",\"clickable\":\"FloatToolbar_clickable_1xr6\"});\n\n//# sourceURL=webpack://bos-platform/./src/workflow/css/FloatToolbar.less?");

/***/ }),

/***/ "./src/workflow/css/StackedCard.less":
/*!*******************************************!*\
  !*** ./src/workflow/css/StackedCard.less ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"box\":\"StackedCard_box_2DAy\",\"activatedStyle\":\"StackedCard_activatedStyle_21wn\",\"activatedCard\":\"StackedCard_activatedCard_21BU\",\"left\":\"StackedCard_left_oBlB\",\"right\":\"StackedCard_right_TjK-\",\"main\":\"StackedCard_main_2j3r\",\"lockedLeft\":\"StackedCard_lockedLeft_tfoV\",\"lockedRight\":\"StackedCard_lockedRight_3VXH\",\"layer\":\"StackedCard_layer_1jvP\",\"commonHeader\":\"StackedCard_commonHeader_1a6j\",\"header\":\"StackedCard_header_13u7\",\"lockHeader\":\"StackedCard_lockHeader_YX56\",\"lockContent\":\"StackedCard_lockContent_17d8\"});\n\n//# sourceURL=webpack://bos-platform/./src/workflow/css/StackedCard.less?");

/***/ }),

/***/ "./src/workflow/css/StatusTip.less":
/*!*****************************************!*\
  !*** ./src/workflow/css/StatusTip.less ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"box\":\"StatusTip_box_12kP\",\"arrow\":\"StatusTip_arrow_2imx\",\"header\":\"StatusTip_header_33LG\",\"line\":\"StatusTip_line_1zbA\",\"complete\":\"StatusTip_complete_2DZk\",\"underway\":\"StatusTip_underway_FP3P\",\"title\":\"StatusTip_title_1ARM\",\"ellipsis\":\"StatusTip_ellipsis_1eW6\",\"subtitle\":\"StatusTip_subtitle_2P3T\",\"tip\":\"StatusTip_tip_RahE\"});\n\n//# sourceURL=webpack://bos-platform/./src/workflow/css/StatusTip.less?");

/***/ }),

/***/ "./src/workflow/images/agree.png":
/*!***************************************!*\
  !*** ./src/workflow/images/agree.png ***!
  \***************************************/
/***/ (function(module) {

eval("module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA0AAAANCAYAAABy6+R8AAAAAXNSR0IArs4c6QAAAUtJREFUKBWdUktKxEAQreokICOIYMAbRBA32Yu49jcrN17AEziKCEYE8XMCLyDB3eDoAcSFC4dBGATnBkIWbhShJ13260xDxoWIBUl1v3qv6HrdTLWYv9tLh9q0mGjJwrH9CiG6DyN1/rJy2vNUhcWmXAfJTeuw1OaWlTxyoDbCqcYMMvbAUc8kc/wQoufO0wGLLEcUpf31kzdgo+ja3F1o7+dadH7V+QR8xDgSOkUUpv3mmGCkq5IVzmoa9oJIrSrMQErOfhMk7R1xdcsDX2Fo5uBhrG1tA8GgeWFpROCBj8HiYHLiFSAIyD7qAmAybQY2xRAV5cfXHEB09MKfAtT5XSU2FQr3IFIuAkR4oT9ShVZ/8MD/n3u4aVF0qVnnsLXe2a+d3bYOHvjOFbwId8GGtmE/XII5mNUd3fAuBFtrjeOMM+NEvuNf3943A7W5/KIRFgcAAAAASUVORK5CYII=\"\n\n//# sourceURL=webpack://bos-platform/./src/workflow/images/agree.png?");

/***/ }),

/***/ "./src/workflow/images/agree2.png":
/*!****************************************!*\
  !*** ./src/workflow/images/agree2.png ***!
  \****************************************/
/***/ (function(module) {

eval("module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABoAAAAaCAYAAACpSkzOAAAAAXNSR0IArs4c6QAAAuNJREFUSA29VktrU0EUPjM3trFipTubgMukKOKiiivBihWkxRT8A65d2YVpxU13tnFhV/4LIdEWwYIRXIl2JUrTZaGtu9KIsQ2593i+iSck1+Z1rV64zOuc75szcx5jqMs3tvooxbVghimYNGTOiXjit8oOE28ZsmsmZvMbU082O0GZdotjK/PjHPg5ZrrRTqZ53hh6a6yX3ZheXG+e1/4fRNeLC7Fv5R/LgaH7xGTk25OdF6RXsNb76g0N7kDZrxwmTMAXfPbviKUZZh4hQ2yZnp8dPvXg3cRCTUnQthBdXJkfqfrBCwGeEOADWX12Om6W1ieX9puVwv3xtbkz3w94TjY2S8xxIS4OePbu5+nFPZVtEMGS3XLlTZ2Eto1nZkpTuU8q2EubXs1eZp/zQpgE2ejw0C21zCoAjktJTpqBq/2SAAc60JWT2AYWMBXfWYSLDwL/o5zkofHoWhQSBURbt4zeE/Gg3OsVOIizCN6Fi8ed/C0JiByGYAHTYcucTb/OpuHC8C5cPASjfKnCQ8avusByHivYiEVLVZPBopxpoZt3KUgvLbCA6bAl4GOIeKcocdILQFhGrdjMPG14sMp4xnspcXYPHFYuBmmFEIwqcFwtW/MFWOCISetyl0a8knTaKWS6rUMGmEHZJYhEI46wcNxf7URFj5NhEXJXCrlL2kYG1jMP7zw87rQ5s++NMjmLdiUH8haEJWDPd1KKsoakCz1wxFBPxCtuSjKEm+fDgO0sC8sdNUZmxzw4LA3UfV08I4MsfJRClDlgAdMRSWG0pdu5EooW6olL9W1QYZla10akZRpYwAQ2qq/zOlRGsU+OkmaREFs0IgwcBmqTYDpswXBELrtKZUTRQj259OpxMgK+U4FuvSZxHNVWS3sjjlB+5UyLYlXyJ1c/RLEMOtAFBrCAqRvWgHLj/1LKlbmfx4mLPQkLeFdfjxMlQ/vPn1vNZOijMKJmdXpAIhYRJmHd5vEvwLagT6u5y/QAAAAASUVORK5CYII=\"\n\n//# sourceURL=webpack://bos-platform/./src/workflow/images/agree2.png?");

/***/ }),

/***/ "./src/workflow/images/auto_audit.png":
/*!********************************************!*\
  !*** ./src/workflow/images/auto_audit.png ***!
  \********************************************/
/***/ (function(module) {

eval("module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACYAAAAmCAYAAAHfOtk4AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAJqADAAQAAAABAAAAJgAAAACE8iBbAAAHnklEQVRYCbVYCWxURRj+5+12t2+LilJarlDkEGLBQKUF5BQNTRAIR1qg9CIqEBIRTYwRRZuYEKNoABMDxsR222JpgwEiRKMRIofcNHIJolJIS1sIh8huj90d/3/em7dv33tbtgQn2Z3jP+abf2b+/58HoJe88sDewkrel7qM/vLK7/HSnCQoP9pJXWDEAcCniZ7+p3hdaoEcyB3uFk1DXBIUhS2WbcivCFyQHdR5j8sO1XWlKUyRA9OGuESTmMRgbYkP9v0Z1uiMcdtEJC4GicWqWxPT5qB2jPS8UW5oDwHsOR+CL/NVWFYb1PgZO8IIMuf8KamhfLEKRxrCsPt8JzyhMqhvighSjEbJbK1jMBIxryJwBDjPEYy4qroSn2ECYzFEXFhxb3kE2HrGYWdtqa9QCOCfYMqvCkzkIX5ADho1g9a6kpR0Vsa5crYioFvPIEcbjB2PYcjqb8AAlwTC+Vhj9O3pXjjZGIGPZycLLeMytP2ijsHUK0UTPXQ5JIAOSTVIdKSi27/uJS+s2d0exaO3FFCUYjnqxEA0MQcash0N6ZHM5to4WGhdb580n4ZY52AKe50YqCsXaggLu/mDf6HmDGPQqYEw64rVSjPJUBZ3d8zcTm3GOggxkeQaLzsh6fMIg8/mJsPxq2HYdSYES/HmvrvHbk1SRMtX6DBZFSk4xYJn3NB8l0NBZRBuBzlcuhExFNUUqSQfU5pbA20KncqYUexULVFh+294pbAMxU2vq++EmuKogsLqIAzoaVhI8NGfQsfb6OmNN3e2GUMkchdXtsgfhIG6glVTPBDoMFiMhmYz0ymTlI9mJcPNgHZt95wLQU+8xq+M90DZ921w+VaMTxIidEQMrHkV91qAQ5pU1q1aUTLwmFwxlElhPL3HcEPGyn6Xta5E8tiUSQJ59I5w8BM8PNm4qH6I+jgauGZbScoWyWOtbcry/MEiiET8VsaYPmMNmcXq4DLGNKPqxBhl3bUbc7NJtYW+g3IiQ1lXN10yO9VmhcIN6Ua3uYw1L3rBl+SkIjpG3rYMnSqNKK/t4d54u3czwKG8wCckKYSNMTnWqDqAs+RlSFnz9eAvZoJs05XafKgDrtzSbIxxSdzRVZNtC8BArbmrGB8rFW1AT7F6R/RKLRqTBDWntDifM9AFV29H4No/sbcAncMKsVapRNb1jdGYMifTDVMGR8PA0SthWDtDuC/JLuoIZ4sclR3GsCoLoSr7oR3S0bfJkpriIMYgGpQkI9UDemrMHgT048UQPPekCz7Q0VQXqtAZ5lCaHbvNOFWTlsaYNWH70nUNGSn9Ws+JLrZqG7GkKggrJ3qg/JhmQ0OUwzEFMKYbA6bGNnSGMmWi4XMtmrIZmEZ9cdDuzDwu9S03pjerOYeNJj0wuJcCy+uCsCVPhT9uuKHxTgSeH+qGfo8xeC9ODKgqYteEVc0h2Kw04bYe9jRLo19KWNDKSImKHj+FMvKSMZmjVSBeX8TMlHRJjh4eHEFfNhB9WYMkdlljRoTBN9vME6NMEvL9gVW4KRvwztnpjB3t01ud8vlMZovGdmap0VKTd2m5EVyOk1C2neM4kUVGdLWjdxRPzdb0VHWLEwhHMadBOSZMyPn2eO5O8nW7RnPjXVlA+x5P1tFiC/2BRREOFQjIwQ/GU/UA43iw0AuWbCv21VilY4BpFopgOH/AHMGqPdE+XiFgSrbZgtq9RAUIiqJ4Q3dAjUhTYOO8ZPEimjBIc+tu1JiqJ/WJ4hJz4twCgy4kgNHNuW9qYZpl1tNu2IpZ6GyMM9UnOkFF530Hs1QqIXSfjyYzWDbBA5UYKQufjfXsJjX2JqY3AgtSGCVN7ZFgYyK3bDy+ecjzr/upHX7Xo0FaDyaANTjkkTQz0ctyvXDg7zBsPWmJGHZoiIhxr6L2VxDU+kRATcWH89IcD7yKj1gJivS2/suFtb5BC/oLVPBaAh3RV25vA9r2l8clYD30d4SJ3g0J5a2Ls5Kgtr5DvLStC30/Nxn8GD+/w2z8nRfsKQPxb9rfAbkjknCbrdL2PmFS0GH2tZPsI0m4hBZ89VgLnSV6wWYNcMEwfMQM663AwtFRywx6nMHckW5A9yOKK/r5warK6BMmMvwJ/E0zRuM09l4KwUw89GeaownBJExj6HFeujWIF0srtJX03eJcSxhOX4uIN8xIXPpmzAmobJqfjK+xTthxWnuRaVK2/xNMfGTgsNlGchigrwKUUyXhXXahBe+0caCM72EXVL1COFhM1w/jBRh3vwlGo3XemOoV54wesV8d7oCL17X0yirbA49aQZYHJmPa+um+dqjHLxoJFfwyhNnBeAGMAjRm7RcQXEZXwqP6KkBfQOQ2DMHUjSYe2dclnCrdJHouENhf8YvJqUTByEnxGYbZxnAK9AIYjZfRlx9/kD4yJXRLpa6HVmNgzyxWx8m3oQFMTiC+joThZwT4/wZwOSEGcuaC6ea3JZFswCS/BpB/253YKWUTqjFwMxebbwUkZeMCkwxiiyvblqAFP8Rfl2dQysSt8QxhyFmbWZRcLbcsHu99gTkJUnztjATmYPSYjP6rP/rMflj3I15U2IQOsgnrRgx7+5MU3y56qzjp6WrsP6+23ss/4XNRAAAAAElFTkSuQmCC\"\n\n//# sourceURL=webpack://bos-platform/./src/workflow/images/auto_audit.png?");

/***/ }),

/***/ "./src/workflow/images/callActivity.png":
/*!**********************************************!*\
  !*** ./src/workflow/images/callActivity.png ***!
  \**********************************************/
/***/ (function(module) {

eval("module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEwAAABMCAYAAAGwkGG9AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAATKADAAQAAAABAAAATAAAAAAWucfgAAAK90lEQVR4Ae1cb6gdRxWfmd2Xl5T8a2tokpIYv5giVKyWIoKxiFD/QEUbqB+sX333vkZTrESsxSevLQ1WG3159z6/qh8spFYLUQtBMELR0qIoaOoXawNJSmJNGyF/3u6O57d7Z52dndl/d/fl5qUL783MmTNnfnN2ZnbmzJnLmPHM9Je/P9ML/mmQGVeEmd6yVHE9XBpOxTzxPxeTKgDmDOMPDkVx3lf3C8WThgKY0lRBhCfA5a4CnjgrU7XO3Osl1Q+HCZw8GJ17FE8bg7Sr5Zzzi8OBf0NctRJiMisdqvxM2OsH5/r98Ms6MZVmSlJMKTYXg2Ik3SXvVb0JZJhvo5I6UkmQsHMnY6+/jlj2sUqC9tUbALsQ3L9DlbNJQZ7zXaqCqQoUQbU0Ls15RK/Fi+OKQQ9n+sFRJuWndZoZB8zBgP9Zp6dvBkS9Rp2pLK76Q9JGA4n+opQg84UpugpTXZiIbMJUIYQuwT56pZTWGUEv7xSgM3F070hGSzpRxc2epHcU8Kghq/jFYOD9SCXM0NWZTD6kaeRG6ds09WYr4KJxwReGi/5XUmGKsY5QJUSVzQlTGQhnZ+WeUAaHmeS7aaAcWzft7X36aX5R59HjVmFV0KmO6hTW6y2/TJ3kQzpDUdwT/q7FRf4vxZMio/72H+pvm1VG1dD3/PcfPsz/Cv548pmdDT7XRBAEBGHwF4R4YmS6jlxDyTWEEjGMQYeiNxt+SxHGDTMTMYS5kKmKzp1jbP4xy9TM2XFfMZWFqpnOyiTbY6miTKw7P4dMIcAMYc4KbjFJTk6Yq4Cafk68im9WfvpBufaaycWcWDvtv8eGpm4Tlwbed8ShQ/w1mzCT9uabJkVP8xCpdGzqo0BnqxJXM0iqM+77e6oUNHmUINBTZEjMzck1Z94ILiNe5dEFgT8jTAno9YIjksn7VDoX+v4Hlxb4n0y6VZjJpKcxMcgomtdpZXFaYv9jeo1/T9WXDXmlwDBvhpH8eVnldfLpE3uGVmHbiso4gTX9IhRVZstDhxwu8N+beTlgdb91psCm6a23+NNzc/yKKp8B5hqbO3ZI9vDXytdvp09z9uTBjEhVT6VQX7ekY9wFChKrgALftm3l4MHnemQk92EUIz8GVgTKJaQrOqaWffvkXaLXkx/rqhIl1/nFVgxGuBwEfxSSBwsGfSKSIl7zlkBBp17ph1fZUZqgsNo4ejSybqXBu2ULY3v3puMqUxyf8GeeSewZmQwjIbA7MGhjJ12gIPimm6qI51fid9TrL79K28z3VikCni/cL9iNlSqwSyxbVWF1EC8Wh4Op3XWmjJ+VvAq1sLTDKqHSagMcmV5N38fTtNHZWlK0s+xNG/3NBw/yt3LAQKAd6rvDKHgN8ZV6aLVxilYbt+r1ZTSmZzz4oLxd3+7peW3FbYCUbCcwxYCwNxv8EN8xndY8zsNNG72b1StzyakEzCyMb9lyGHyX0SbQzMumaRnD+RPYq2Tp5alGwCD2oYfkusuXoy9FTN5LAN9HpO20hL5AH+FTFD/mcf8XZJM4Dt4mTy1g+/fLXZevBC/UmfMAigvx6HDRe6wOwErA+n35gUgGuZ1MnYpiXs5/tTTwP1OlXCmwLuY2T/DPLy76zxUBdALrej6jil8ZDqfudIGzAuvtkx+VQdC447oqM+k0j52nifVGk450DthKTKw6EBe4zKIJNoKuZ3sdFOIwQmLLaNIzwOoYLkxB46Rhs8WOX5eR2shGnx09L41/44CstDV76nucnTyZ6x2pnKLIyAyRFk41VvQtrLpfrLr/dAGMl/mjzBiY2mS6CqwYXTvNioEV2q9WDFVSkbJ/C6wUVrjuwuqU7c2Ply+FrPUybbvupSXB/n6inhy/fE1VT6Ayo+ulANZG13n0OMwW6ajUM652nMwWn51IYKSYT0wkMM749laBtWV8oRXyhvSTVNSvzI7b5HyoSL4l71QlYJaChaT7ybahG0/UGRQKHTkSsbNnC4tjMfa3Vl+lqk4HpWgqLLIEKR7B+PME7P8mbJVxtcPpafFjAsefuNpAzPpxmh+vf+qYoCBkLDMTlS+yj+HcCWaxUefntIiU6SLNbIGZLhIM3nGA4zAMMpLO73uV3RFQqMtHndDFwJLzwuRstctKIbvofFf3vkpf34EDctNbbwfnuwbmkk/buMxRYTqPwV6FQyZXwa7p5vllCgwVx24/ZHbsGoQpH240Ji0DDJmwhZJanV5BpoBx0zhI1X17lLwcMGQQuBsIXOeag3+Q7XQXGKzARuBu7bLP4URXOS2hPvNJR6WZodLJaA3/TRNw7OKo6E1D/RS3SEYpMFV4Zp+8g9ypXqnzhVBlEdKq9Nnh0K98blUZmF7JTD/8Nplpvkkg1+j0XJz8pKY8/+sLC/ylXF4JoRGwEpnW7MQEH32Ksejj9Fn+cGmjrFJ0Ikz18g80TH475YlfN2m8Lq1qvBOFoTvyIHyE+hWcA50DvyrIOnw0y9HJA3tO+t7jNpehOrJsvK0oDBPK2/8N52XE+m1NKjawzWg85IINNq73Hi07vaoiv7HCYEV+42z4VJEZsgqAlebB7H7LFu9h3YmoDobaCsMZQBiFv6Ghtr1ORZPGiwWKJ7xPFn2rbZgrKwwnOCwM6TRQrrMJulZp8bLT8+5xrbzMdpUqDOdvkQxfvNZ7lNlwM40eJ7j3Eds6Wuct/ILh/AbOF6tdWVAI2oi2os26gsy4tYfFX70L4QkSctXcaEygK5mm3nZm4wbvNttXNaewxFEgpPPMenuOqieGdRo+rtdqnbryvDykIXqneTMsMySx4Ey8KuopC5VVPcnMA3NTupDprs3MkR50Ee8JtaxUYfCJSTaLWu47UcbD8OVYNyNdpAqDAxENw9wQvd51RvO4SHSTaCJWGHb5db2tridFQjexJYQazeErd/FSSGbgEpNIiYZsp98lRVrPPkfmsfn5dNC0LJ9fWbfW2+zDsXBcZbWMLCPOPBzNZGoJvLB33awRWo/KNdCViL0wWxe+OgVCV3ThIXZZXZ0tbLtVpCsM+Gva6tC2TkrkbRdwhi5hqpQNn7+2vD9QIWRB5iQ90JU/8hwfe7qEg+STB9E8eyPVmXjRFaFJUo4NC3QFh4Fj9He7jWGSaKYHjokNHjl4cDPcfKrexzLLWdLHBJf+Ly0ZE0cq8gwqAztOWV027m+I4ZD/jkbRcT3jnbhFA6QjXHaJfXhwqInbnha29ki4xkvT286dnK1f357YlZIEHaGudIZucmO/DtitZIq8+2665Wi9b1FHUjPeMketIqn6LaVUYShQ+nsKRVI7zlNf2abVNFWY6eOQ2anGzg90paopqFVXjnRhOoRkFIYG4/5Zl347TZUK590ijzyXXJRB2boPdGC7i5cZkrrQLn78Q5c/yfGie4G5HqYagouE8OIijZKP0/XxoK1oc9ElSmcP01U0cg84Tuba2r/3pcuZ1Dgdq50nt4E9VdwGKilMNXTkLvD8alEcFMU8796qbgLQQy2FKcXF7gNR8CyuPSratRRi6Anh31fmFmBrUyOF6YLwcYgkG1Cvm+hTcpxmC876RfOT3i5XfGyF6YLjU3MWPk6OCoW/NaqX6TRO6yjBvEfM0+tx6mxVYSaQ+AcTlqMvMhk90PUxHi640C8t/GR6SvxUXd0w8bSR7lRhLoA42rt0id1F7qi3RSzaTVMp/ckddI68gRq+AfftUBYWTopfIOdfsgrzk8RDVi9Bv9IjTqxdy14q+qFRV93j0v8HP34CtimTzZsAAAAASUVORK5CYII=\"\n\n//# sourceURL=webpack://bos-platform/./src/workflow/images/callActivity.png?");

/***/ }),

/***/ "./src/workflow/images/handle-rotate.png":
/*!***********************************************!*\
  !*** ./src/workflow/images/handle-rotate.png ***!
  \***********************************************/
/***/ (function(module) {

eval("module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABMAAAAVCAYAAACkCdXRAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAA6ZJREFUeNqM001IY1cUB/D/fYmm2sbR2lC1zYlgoRG6MpEyBlpxM9iFIGKFIm3s0lCKjOByhCLZCFqLBF1YFVJdSRbdFHRhBbULtRuFVBTzYRpJgo2mY5OX5N9Fo2TG+eiFA/dd3vvd8+65ByTxshARTdf1JySp6/oTEdFe9T5eg5lIcnBwkCSZyWS+exX40oyur68/KxaLf5Okw+H4X+A9JBaLfUySZ2dnnJqaosPhIAACeC34DJRKpb7IZrMcHx+nwWCgUopGo/EOKwf9fn/1CzERUevr6+9ls1mOjIwQAH0+H4PBIKPR6D2ofAQCgToRUeVYJUkuLy8TANfW1kiS8/PzCy84Mw4MDBAAZ2dnmc/nub+/X0MSEBF1cHDwMJVKsaGhgV6vl+l0mqOjo1+KyKfl1dze3l4NBoM/PZ+diFSLiIKIGBOJxA9bW1sEwNXVVSaTyQMRaRaRxrOzs+9J8ujoaE5EPhQRq67rcZ/PRwD0+/3Udf03EdEgIqZisZibnJykwWDg4eEhd3Z2xkXELCJvPpdBrYjUiEhL+Xo4HH4sIhUaAKNSqiIcDsNkMqG+vh6RSOQQQM7tdhsAQCkFAHC73UUATxcWFqypVApmsxnDw8OwWq2TADQNgAYAFosF+XweyWQSdru9BUBxcXFRB/4rEgDcPouIIx6P4+bmBi0tLSCpAzBqAIqnp6c/dnZ2IpfLYXNzE62traMADACKNputpr+/v8lms9UAKAAwiMjXe3t7KBQKqKurQy6Xi6K0i2l6evpROp1mbW0t29vbGY/Hb8/IVIqq2zlJXl1dsaOjg2azmefn5wwEAl+JSBVExCgi75PkzMwMlVJsbGxkIpFgPp8PX15ePopEIs3JZPITXdf/iEajbGpqolKKExMT1HWdHo/nIxGpgIgoEXnQ3d39kCTHxsYIgC6Xi3NzcwyHw8xkMozFYlxaWmJbWxuVUuzt7WUul6PX6/1cRN4WEe2uA0SkaWVl5XGpRVhdXU0A1DSNlZWVdz3qdDrZ09PDWCzG4+Pjn0XEWvp9KJKw2WwKwBsA3gHQHAqFfr24uMDGxgZ2d3cRiUQAAHa7HU6nE319fTg5Ofmlq6vrGwB/AngaCoWK6rbsNptNA1AJoA7Aux6Pp3NoaMhjsVg+QNmIRqO/u1yubwFEASRKUAEA7rASqABUAKgC8KAUb5XWCOAfAFcA/gJwDSB7C93DylCtdM8qABhLc5TumV6KQigUeubjfwcAHkQJ94ndWeYAAAAASUVORK5CYII=\"\n\n//# sourceURL=webpack://bos-platform/./src/workflow/images/handle-rotate.png?");

/***/ }),

/***/ "./src/workflow/images/icon_custom_relation.png":
/*!******************************************************!*\
  !*** ./src/workflow/images/icon_custom_relation.png ***!
  \******************************************************/
/***/ (function(module) {

eval("module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAACPklEQVR4AWIYGSB6yX8+QDtlDRxXDIThMFObPmRmZma2m1AbRjMzMzPb/YzdGPpwUoc56cJPWhk3WlsXMt9dGc188+/s/rsPpbg+aEnoEx8VLZQz2gXiusV4bLfAOIWKx40yPKZryjyqA3A5qGbwBcLb4GxEG2BEm0DSP2Oq6T04oQZ3hzZDqWQ6rFmgVCRdiJtAp9OhjVBK3g0Nt2vH7cGNYjKoAURQI2SHNMApGU8FNwASsja1kGucypaxkLVJ6ln3BQJroS+gDqaC6sFHlwuoF0f968RlgmJdPqgafMgbUAu96xruUz1t5VcN6Fsjzq/3hshLPdS7ptmrAoa9KuGNdx5u28grlX1vvCr48JpmjzJ46VHKazb6U3iViRpP2buqKaQBd7oVw5xbETu/0QtQj1sxn6MZK5pcirijcwFHlwLxyLmAFTrlrX0ckIe8su+RBF0LmMOyRoc88HTMg6+OuRwdJEqfWCbh3pWGW1biXsc8/oS8UpGUZtCspR8qiz20y+a4hCyeuNIFqCaRHoZKdfHDJWbrDKbZZHAkZKxTYsX/21bWFn2q73esLX3cVH7HMpXhIvyXWqTx1JUuQDXLNOVVqri91JwMXubJfFqCZkkMlUq0arvUzweXPPH1L4fMUrRqs2TlVUozTBLpGyyzzG5qViY3WadJIps0ucnLFmHM5CZ8NU1kIyaJvIIwTeQjlJN1ZnqDlxLSNyHpOJ6kWW7o/za5zg4fv8YKj11jo5IXilHKUW2Toev/+gljMdTkqNJScQAAAABJRU5ErkJggg==\"\n\n//# sourceURL=webpack://bos-platform/./src/workflow/images/icon_custom_relation.png?");

/***/ }),

/***/ "./src/workflow/images/icon_receiving_note.png":
/*!*****************************************************!*\
  !*** ./src/workflow/images/icon_receiving_note.png ***!
  \*****************************************************/
/***/ (function(module) {

eval("module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAB30lEQVRIS9WU3UcEYRTGnzNt0a5E3XafRERKREokIsXuX7EqSx+W1a6IbVl9LJFuoqv6AxIpKpZE2b6ULrvrqrLT1+6cTDuzM7uzM+/uRdF7NTPvmfN7z/Oc8xJ+edEv58ffA7yb78esoMe5Ms5vX5wr4YcVT8Qu3lLB6MYbk1YYw0hkTmD+6TKlqFG2EAtgZP2tdFabI95cKT87dhALYHitMsDdbQ5gB7EAhhKqRIWruCSn/V1/bcG2BTC4XFkFxcrtTQgAA3GZoXcvIUmMRyOJ1R4magJzdy6GsB8QAPpiagW5RMTwHUy7d5xatn9R9rKEbd2Ewym3s0S9UZlZOyjlQ/WH0g1m/no0IwD0LKgS2bhcxtyfBAWA7vkCQBJk9sAqFjE1MXQPgGRIAOgKGwAm+E7nnD3ojMhesOYBgNOwANARSpu7KD9BTkbrmqoKns0LAO1BFVDpMprgfMHj3EVts2njjivDVL099SOlogJA65S1ArurodT365gA0BJIM4OeiFgCozE3cfQMhgRwnTaxMsDvABq091cQq/d2/W1cAGielLc+UOv30IuUUapXQexmIr822UtM5KYq+D+/snINSQkAroyEcZeLs/yBxP2yZ8zsYLkqV+p6Pv7/A74BRZatGXoUJZMAAAAASUVORK5CYII=\"\n\n//# sourceURL=webpack://bos-platform/./src/workflow/images/icon_receiving_note.png?");

/***/ }),

/***/ "./src/workflow/images/moren.png":
/*!***************************************!*\
  !*** ./src/workflow/images/moren.png ***!
  \***************************************/
/***/ (function(module) {

eval("module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACYAAAAmCAYAAACoPemuAAAAAXNSR0IArs4c6QAABDBJREFUWAm9WE1PFEEQrZ5Z2AURBITAEvnQKHpXMCF48Adw0IuR4NWb/8CTv8KrRm964Ad4MSai3hWNskhYEeRDFPYDdtr3Zplxd92Z6QHWSpodpqteve6uqakaJYeQTGanP6cLU0o7k6JkQGtJA4aDklVKsqJlWSvrZYtKzg4Pn/hWnjL/q0xVP2mdLGXW72pRt2E0prU2slVKgbe8UaKf2sPdD88rVTDxGQkOAtbHha1pRzkPROshE9BAHaUWLW3dvzBy6gkIO4F6mAgl9jm7MbiXd55hxZfDQOLOwem7ppR181y662uQbSCxD4sbE1JynoNUb5DxUe7D8arY1o2LQ12v6uFY9W7OL2zc0iX9olGk6JPY9EFf9Tj8s2PcKRrAtLmewfHfU0Vlq+u1O1dF7CCm3jZyp+otjMeKmLtSGXMJT5FP3/zCOgPdOKZsS0lne0raWpulucl2oYp7Jfm9W5TN7TxCFGgGQp/uQ6b1uPe0+js2/2VzxpHSIwMcV+UkyPT1nED81g1TkHJkZW1HfoGkqVhi3xk92/mY+i4xJs/9zMa8aZ4iqXRvm2B1oT5xCpJd/W1ODnkuMdw1yiTsLpcZ3ZQUj487FUXKXTWIl3c1fAH+6pDAXS64UT4Hrab9yYgLxlTQ8dUzpS5tTIWvPOpafCHjQK+YGjLQ40ocG+ztGDklWCXgGA33WvynLw4574k1sWFxkJPCFCLGuWZi8D91yIkx5tVRRr6Zp+LKIWzS1kGRZ+yLyTOuxLUhp9g7Vs7ooaVUFW8mWtrElDRijC96c+FrhhmdyTNKqENd01eTh0dOFuBj1+N8zTCjczeChHOxsn4FEDkl2DhgYRcq7htdktzu0t6xvMRrHZJTgt1M7YTp/zyiH1s5d5jaGOmBk8UWy0j5PyqRk2L6z+v8MjNuHN/JZltYZbSkmiSJWsy2y+alkpYCcl0uv+dWFYVivLyH4kCnVGrARXu/sP4aj9m4CbFWEOnpbHEJmeiT4NpmTnbxayRKzV0a6b7qVhdsRqOMLERkuqdNBvvbjUkRkztKG9oSI0o8Lq5mVKGYsC0509cuPL6jCI91aWVb9ksBaaa2UHQrRnTI9Zwydoaw4qOSIjYxuHtePNb6Y5fufULw9xbBz2ZkDsmtquseSndIS9LvWWqxDvV/rrAvi9mfVbYg8m50pNtvRsoVLFTYnbBth8KqZ3GaQX7MpIhNTGJ7Qp+u74rvGT4xKrl9Hdp20Cw2JSzp7vhr7IEc1y+x6YO++KmgsqcM9MG2fWs7X8DxNlToI+gTQSA5MJrA+N5AZsSeCCQQNgHDQYy3DSBHzMEw35FzAECVq2cwMhhHFWIQqyq2I0mEKQAsiXEPYw7DwTAV6tKGtskwH5Vzfh6rvBl1DQf90JnCmMQYwGBD4zU1WVxzsJxi5TKLVBS7GP0Dhd5psFvc4hkAAAAASUVORK5CYII=\"\n\n//# sourceURL=webpack://bos-platform/./src/workflow/images/moren.png?");

/***/ }),

/***/ "./src/workflow/images/moren2.png":
/*!****************************************!*\
  !*** ./src/workflow/images/moren2.png ***!
  \****************************************/
/***/ (function(module) {

eval("module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACYAAAAmCAYAAACoPemuAAAAAXNSR0IArs4c6QAABnlJREFUWAnNWGlsVFUU/t6baaftMC20shWkoLKoBAmhoLIYWQ0CRoiEJQFcAn+UqD/0B8GMEP/oDyP4x2qiSKiCURMgkVUDRIFS0Ui0bEJbugClQ2k7nbazPM93p2/2N22xEE4yc+8795xzv3fuuefe8zTcAa37wDvUH2hbbBjaDFEfZsAolJY/Up0GrU7aWk0zjmfYc/aUbHTWq5Fe/Gk9lX1jq+Fo9jSuF4WVBjAFgqpHuoJOBMtEpzQ3v+CzbRu0jp7odWvc7Tb0Sq1xFQxsMQyjqCdGrWQ0TauChk0jjYKdbrcWspIjPy2wdW7PiA6EvhfvTE5npNdjmlbugL60xJ1fbaVrCWzNZs80hII/iKcGWSn/L76GG9BtS7a/l/9rKjt6KuZat2c5QqGf7xooTsoXljnUXClAJHks7CmCMjJTyPc9S9M6oeuzEj0XBywcU8HTd9VTqV5NltUBW3FszEWWkrsvHOh3KaZSATJ5sqycmxhMlt3sqJQQ6v3umzQuE/OfysaIITZlqvpaEAdO+HDmXKdpumet7PxKXdISsIMKaimZPFs8jed7k6ds8m6rF/bDM5OyUHM9gAvVfgVgbFEGhg2y49iZdmzf14pg2mylVCJ/zHOu/IKxTMLKY8zoEuxpk+dDw+yYMzUL+477UNcQxILp2Zgx0YGdP7Xi0Kn2iHF25j2ZheXznGhoCmLvMR8KB9qwUOQPl7Xjcm0gTjb2gY5RWICt5prShZY0XQBsei0PY0ZkCH6gIE/H4pk5OHDSlwSKRg6ebFdjlKEsdehJ2qCtdCRLuJLjOg9kaYuthAcO0PHyon44cbYD7267hfqbQYwbmQG7hNSeoz4rNTVGGcpS5x3RPSk2aIs2rUjeYQox6bwlyCvFpY1YpWcnZ8HXYeCrvRIvwfBI0VA7rntCih8rG9unDmUoS6Lul2KDfNq0JMFCTLq0My2FZGC4BPKlmgA6w7EdEc2M7OcIK6lDmU6/+KCLaIO2aDMdERN9at6jUsoGgwacWfEOZfDn59kwINd6SThGmapr8cFOW15ft1u1UO+65KUERea5Kj9GyY7kzjKp7O8OdHQaWDHfabKSWo61toXwz+Woq2mDtv4Vr6UjYurWY7+Ut6NePPTmilwVyJo4r63dwO5DXkx53IFXX+gHR8ypmpWpKR7HSvd7xTsGqMNN8NbKXHhuh3BUclw3VKitdd9slvzhSif44GAb3l/fX85aDc3eELZ80YSGWyEsmpGNpbOdKo6q6sNeMIP9u8NelUqGFNiw8ZU8uJw6am8E8OnuFrVL080nibbFLm7jfdwS2ITRGWqLE1RdQwAVV/xoagmpJZk4NuwqGUJ/l45bzSGV8Y+cFi9LiiDdbg0JQJ+KNS5rQNgP9Ndxs8k6zojJzsJBOmOUlYQ/un/D8lyV6T/8OpzDKLJgWjZempMDnovbdjXjr4ud8KcIm1ynhvGPZGKPZH+Txj+cgbdX5eLj0macvRSNP3OcLTExxmpjmWafsfL6Mpc6QjZ/3hTxwMxJDiyb68R+OajdJU34vSI1KNrhsq570YXn5JA3qaLSj5obQaxf4kK2I363mzLS1uossWIYkS4BZIkiEyvdT2K8rJWD+0iZD7sOtqmjJjyS+p8eoeyyuTmSu8K7mom25McW8MVnFadOtMSks+6TbRPNgl1zTH7MgXMST8xZJj0vB7FH4qj0gNdkddt+I7KMvaWzcyKyNdeDKtHyypREgoWYdBaj4tCyRIHB+TZUy3XGJFeOhqcnOLD/N1/kaDLH0rX0Npf9idGZcGZHl66yLqBWIFGXWIhJpW5xV2miAO9Yf16IXvaGD7bDZtPwx/koL1HH6pmXRu7qR0dlRETKKzpwQZJ3IplYFDBWyKoYjZH6aEezKEY9xvjiudcoCbK3RB3q8gpk0qWrAXzybYv5qFpiIBY+KElVtkuFHCeV8EDDF68mv2GCmOUjdVvbkkI5Xl4wmJ8QIovOQuAKGk/JVuvbqjt+ausnqc5HoWCq+ekgAowa92X5RmCqrpOyXdJH7yOcBu6EVMFrWxJbU9JMNBq7jLIi1qCvuSfgBBTnSqzCCSVuKbuwqea+/KhCZHwLlu3iufJYwH3SV5+hbMWpPGXaT1pKc4At1507RdO11Yl5Llaup33aoC3aTIypRBuWS5koaH7qFP4q+RWnq6zidMPn8Gnh7ezTT51xk3Q93IuPw/8BmK7JJsFizR0AAAAASUVORK5CYII=\"\n\n//# sourceURL=webpack://bos-platform/./src/workflow/images/moren2.png?");

/***/ }),

/***/ "./src/workflow/images/no-permission.png":
/*!***********************************************!*\
  !*** ./src/workflow/images/no-permission.png ***!
  \***********************************************/
/***/ (function(module) {

eval("module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHQAAABECAYAAABQ4BGKAAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAdKADAAQAAAABAAAARAAAAAD5K2g4AAAMB0lEQVR4Ae0dS2wcS7F7Pvvf2LHjT4LjrD8Jz36QiCRCT0jonZAQEhA9yRzgACfOIC5wIQkHTkhwRkI8DgGhSChIOXAARZxAvCQQiD95TrJ+sXH8T+z9eXc+TdXOtj3bM7Pe9Y7tnWXLmqnqqurqnqrp78yOCelAW3mAttXV2C4mnX7TvUv0K8Q0zhFKz5VFjC0TSV6OEOXJyMjptzb1tiHbKqBra2uJzazxHcboDcLI+4QwxT1SVCeU/JVSdq83IX/Y39+fddcLHrctAsoYU2fTK9+ljP4Y6P5GwkApXWOU/WRiZPCXQGuN5G1F3cAHdH5pc0jfLf2REXK1GQeDIx4rkdDXLw71LjVj56TzBjqgM+mV94hJ7hHGBnxxJKWrRCI3JkcG/+6LvRMwEtiAzn+yOalr2t8YYac8/UbpPFzgRxDw12UdmBxBS74O6YteeSihO7KivHcpdWbWS6eV+YEM6OLidk+mWPgHTHrGROfCOGhA0H6jyMrPvIKCN4Omaz+Ai/82jLmyaIMQ+iIZjn7+/PmuLaestTmBDOjsi5U7EIhviq6FYC4osvTBxVT/P0WZW3p+Ye1zumH+AWylRDnY+u3E2OC3RH6rpwMX0JmF9avUMB5CEIS602kaib0/MXRqsxGnz7/O9On53F/A3mft+SCg0Hbl65Opvsd2fqvTUqtXUKwf1fWfisGEyK6HaegrjQYTbV88m1wnEvsa2Niwl4VlYFl2XhDoQAX05cvVAdj1+ZLoWCrRH42N9bwS+fWmJ0bOLoCNHzr0oaxymQ5B6zICFdBdwr4KLae6zjCT/fTIwK+bdTHY+JBS8rHdDpaFZdp5rU5XO6fFawuj2pfFKsIy4w6Md6bIbzQNNgwI6O/FfG5lijqtlA5UQGF/NiU6jzLyZ5F32DSTpD858rqU6dBpIUawAsqfmtgcKMdjVd2kTdQwyYiUdmRyKdOh00KMYAWUEMfGe3mW6pNDJy6cWXMx5SjTRadlWIEKKExSXHZ1/PMljqOitaMuUyyv2XSgAtrsxf4/5O8EtM2i3AloJ6Bt5oE2u5xOC+0EtM080GaX02mhnYC2mQfa7HI83ls9/qt8tZq7Ac8kLxNievYaxWLJUbHF1cwtB7MJRuNlSCa88vLv4YH4vSaK9S0r+PDk4dVa9ufEZN87+Zo0UQOJ/mK4P/H9Jiz4ktW3gOIW2dOn6TNSJHqGyCQOL3CFCby2zBS6GzZJPk9z65fHxjbcHnVBK9thjCR9uaITMgKP3jLnB5LebyAeU72aDuj09HRIivSnGDUvMNOELhy3W60tUQVoHWjECIbE9DCjC6OjfWkIrF5mwunVSgZ6reDD8GCyaX8264WmKvBseeeMWSx+hjAz5FYRwzCoLMsMMco5LStqsaDr01cvnl1Hfieg6AV/wHMCcpD5mZfLF/RC/opkGrLJmOF2qJKkIx+xnTYhT1iil1+82Bo+qJyOvDEPHGqW+2R+aQhe2BihBAIJ5XndFVzG3w9BPc7DapZIcXRu7tVe14u8DjTngYYDOje3nqSyNgLTHQMjgQZ4RDjNjdYll5TR5i6hk9vuAa/GZdfZo2EmSw25NG6a0DLhkEx5D9vphuSM8Qa8V067EuA/aXFxMfpweTl2VA/OG5oUzc4u9ZqyMk5UD5fjrytRxn9lyWmu7yFPnooH9tdedk+Is1xsAE/T6X6qhQYlSvtgiIrY9SVZKeiGvhlV1NcjI/1rMPNverbfUECfpZffgfaU4JXyiE/D8e6KJz/iNoOM7QF9/nyl36DSJcb0PX85rk2GwQkHLsDwC6tclLCPR0cHVh16DTDqDih2ETPPl2Frzn9IJk8F6vcjXh7AgGK3OvN8ZYLK0jkvvVp8GMyWJ8cH59zeb6qVj8scAS1XaGapm1IZdm6MyvpSLslySDcVvYdq0C+osK8DwGnE3KAdox7XqaUf6449secLKn1+IKHMfrJxhelGN14D32Lhb7bhdgvnucmRh2Ay8+3T8bNPvuHy0pql4X2uCsTc+npSLZKzuwW9POqFQiFWKpUoYjTBacSYFuXIqwVe+ZPJxNNa+Q4rg/JgzzFHtJI1qKshlcRicaz3YU3WzFcsZt/VTdJXU6leoUm34OeM/6lXnevtBRQ/A1Nkes2ftpc0jYZUlSFGA5xGjOmD5KjjBrFYZM6N3wwvm8uSbMb94yaJZIIk4t5D22HLLeQKX7Tn1WFBp8AfYjfgMsQI4jIvLtMXqVSf9etzNwMuvHJg0oxFjKX1IRd5NasIyTAciCvIliRhSBRBhrgsr9DIQxDlpVIRWn+YhdTovKXhzxlb5tbWVk1jPT09vrfUXCb/hZqFNiiEXTazsLP0+Pr161YXU0f+8q1RXNzoIbAfd6A+aqOWdUOVxwO8q/gYoYMMJ26IETiNGEGUS7IKPBNauiX364zd7EGAOn53vaZ8gA/FZYFYSXGZB3IlOYBv7v9XVPVKKw8fPlRVTauECpdJu3BYy6VdoCPwhxiB04gRnHJ77n3aym1Z3beOFnh5SPsHfMysZbEenVr53WTwqLuqUYjxU+HO12AbBbEr4BYLymxbLWFF7QFO/QFVh4ZC+rZSqQhawgmDZVEBWgcaMQKnESMoMZDnQQ4YQc8jz8KY5jRiBFFulRPyXLdauRo/17M6r0en0ZJNoZfjseHxQ69xXv22TXl+fj585864NjWFfeMMmZychHWF+yYEnYbPqZHc/mZB/QX5p5mMRl/7Z42QNzB+FmEcrQVhmOmehnHUT8jlcpc12CZTK7copxEjIJ/zMM3pfbm1yeYcgWgRhtMQpSGY82jwVR6VUZllzbi88a7wWTulFzZeM3p1V4GFBRli8fiBAUUdvwH3sGVoRCb8kBWB04gRkM95mOb0vtyzBYMBfEqJdtEWfJ1JJzGybQz/69ni9r3fDb2+dcv60TPFjeKoEbcGRSylCnYghW9VIEbgNGIEUW5x988H6VvypNq9uZ/HHyqTzZIcHG4QTyRIEg6/If92551aNnGyb18VhFRY52uwzgeM+TiNGNOinAKfgS5ilHOgNJy9dKl3Gbthmk6nI5umWV5onAaNN3AgdgMuQ4zg1Bc5Yg4rn3hW4/1H8qnTncwOyedgYLdBLB4jp47o1Z9iJj9eohAgZgVoL3qVZZy4sWKr1qFI+8aOpKkb8OGQbUXXdRYtdZUnRTgDjcLBZ6ViKVyGGMGpj4sYfNcLMQJqIM0t4iYKvnVSvZmi+t/7QRnw4J06nw668crKPpzyRsEMhcMsXyxYLcwIs5IBa23AaF7XYbseek7EmEbdUhHkgDHdKOTzhXJexIpqdEGXvEPhC05qaWnJ6uRFi4vAOA8HYjfgMsQIon6d8qHR7upmZFlr+pyFLhcPOySgq8XjKGA7uzOMN3uhYpzTvAE0XGYURsICNAbECJxG7AKyXFqnDx48UOADwM5b2SXDUbGSvcOVvSR/SzjugOZLu5/y9woas9YdMrbLj3vu3r1bGWSnwMJdOBAjcBqxE6amphjmRYxSTnvZg3UU6BPQt6aBXH9xNWs4rTfPOe6A6vn8oL3WOUjgaILYDbgM8WFAtC8VaE6BmZG1S3AYiz7lgdc4fbJ0smY0zai6MXG7BVeg1raLs25cZq1SnfKDOKL9XV3y+ib7QaY6cjcPFCOaQbZB0sWlSNgY20B3AQ8xgiB2Mnjeir6Vy/PcExvGN9074JcHoqWEUV4m7G1SYYPFCVil4UaBLgGNGAH1cMbkpb+Xt75JnK4stHcLxacp4ozW7ycsGBcO+SS00FVI8afKnEZ8GEA73Abm57SHPeVyyqzacThMmX7kaZefQhiFjajdH3oqxZSFBYoY+ZxGbNfzi06lUnqny/XLm2Bnc3OzalIEDMt6BV+7do09evSIInYrlssQu8nF/KI+BLS9u1w3pxwlDxzOt8hci7l9+za9efMmQ2wp3AR0Gw7EcL55DWQEdKyAi/oY0Pv37+/dEJxGjPlR7nonoPA4oV26XPt7ucfpP3tZJ7pDZK9Ih/bHA52A+uPHlrHSCWjLhMKfirREQOG9+8Dv/bXKNbREQOEfavzKn/vz5Ky0yjW0xCwXw1DPd4pOLly1Sm6t7xTVqmlHFkAP/A/vl0Vfys2toAAAAABJRU5ErkJggg==\"\n\n//# sourceURL=webpack://bos-platform/./src/workflow/images/no-permission.png?");

/***/ }),

/***/ "./src/workflow/images/refuse.png":
/*!****************************************!*\
  !*** ./src/workflow/images/refuse.png ***!
  \****************************************/
/***/ (function(module) {

eval("module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA0AAAANCAYAAABy6+R8AAAAAXNSR0IArs4c6QAAATJJREFUKBWdkjFrwlAQx+8lwUHI1EK/QTu7ORTpplLI5ldpl0ItdbHfwG+QWRB1lQ5ZxLn9BgW3gENQXv//Sy6m0KE08HLv3f3+uXt3cdJ4/HDYEe8fsHri3CXsHnaD9eaWy52hATd+NAr9YPAMaIGVSRQlEscXanmGn3E/HisfqTrPn2DvpNXquPn8S33lawuz9UmSSlGkkmX0vriqpMUvglJWvSG8gnCHUu8DpOYdppbB9/u+SdtZ4+DIU9RD7e8GuvXaGUjLs8WUAx9ol9rtjzqAjQl/CAiE4Sd5ZtrL4XDTFFkGy1jHTqdr8sy0kePx1gIm4NkyWkw58P/rXjXpGeegba0/e95U7U7hmZEvhxvHE8lz4RxQ3lS7xObwriy9KB4pkG73VVYrObcT3r/+e9+C4rui5W5tyQAAAABJRU5ErkJggg==\"\n\n//# sourceURL=webpack://bos-platform/./src/workflow/images/refuse.png?");

/***/ }),

/***/ "./src/workflow/images/refuse2.png":
/*!*****************************************!*\
  !*** ./src/workflow/images/refuse2.png ***!
  \*****************************************/
/***/ (function(module) {

eval("module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABoAAAAaCAYAAACpSkzOAAAAAXNSR0IArs4c6QAAAr9JREFUSA29VjFrFEEUfrO3oBCCpPQCBzYJaKliUlhEjAlJ8AKS3trKNNpeJWgTK/9EEO6EhMQjXmGRiFoa1EY4MJbBhIAHexm/783subvextydOrA782bmfd98+2bmrZE/FDs3Nybt9qIYM42pJbG2qC7G7KFuwq5LoVA16+ufT4IyeYN2fv4yCJ4A6EbenFS/Ma9A+MCsrb1P9XvjNyJbqYSys/MUBPcwx0DJPuoaaj67MjREJSJHR0U5Pr6E1m08ZcwfQW0x55lMTNw3lUoEu1NSRFAxIlH0HKNTeH7AaUWGhx+b1dXvHY8uDbu0dE4ODx+CbBnDZ/E0JAzvQB0XqaVDpEq2t1+idwoEXyUIFvHd3/l5p6oQzytQWQXhKBwaMjl5K1YWdBD4uWKSMLzWKwlx1Ae+ulBiOUylUEUa+Ch6i54WAnq9HxJF8y9V1m6/hnkGn/AqN4hTxN3lAr8yKAm5FIPxJabDFmNnZ8fxTT9C7j4CfyEbeDszY9V5c7MTT9pxyRv3G+SL7sZCYTxAo+ydalmSGKyf2mPV1BcHPoSSaZBBJM5Jl2K8kuzKs3YXV3a9wHOXHIxRiT0wdrX+m68g+ODhSiHUuLsrPvE5RHnKcqa7bmIeHOC+sMVf5+hEjz4HWy23gYyxjNEeGMf07hLJvYGzMcnaXZcSRed9/zcqaqph7cWukwfpdJcuEZqMUR2Nm6i5zavsTZa8lZ8yZrzZGaN6kNjWZT1kSZYB2h7LnVEkRoXC7bDFlaN+NAB2ypVYHnOLA27XITOibSFxWS/ElEvvhmK43GSZdYmgRJp+mRmZtJBP7MIC80lfRX2Zk4gFzDi1O0WERPrFuwFVo8iyb/pRpj7wVQxiOUyi4xpPlP+SymO+nn5OePbcsejt5yQmY/3Pf7eSZEroEmMZgc3/gUSKMRsbn7K+SfsnGeVjzs7LQI8AAAAASUVORK5CYII=\"\n\n//# sourceURL=webpack://bos-platform/./src/workflow/images/refuse2.png?");

/***/ }),

/***/ "./src/workflow/images/up.png":
/*!************************************!*\
  !*** ./src/workflow/images/up.png ***!
  \************************************/
/***/ (function(module) {

eval("module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAYAAABWdVznAAAAAXNSR0IArs4c6QAAAMVJREFUKBVjYKAWOHrxjtjh03fnnDnznxXZTCZkDowNUvz3J8O+//8ZOExMGH/DxEE0hga4YgbGi7amSvHIikFsRmQBZMV2pkpxjIyMf5HlUTQQoxikgQVmwp9fDN1AtgQzH58lNpNh6uB+YGFmqgO68PPfzx83njnzjAumAJ1G9cO5e/J//vw/wMD4/z43I5ePiYnUN7waQJJHCWiCOwlmkrWR0kMWFkYHhv+Mit/+f98IE4fRGBpAEnBNDAyX////j+JsAG2BVmvsLWXcAAAAAElFTkSuQmCC\"\n\n//# sourceURL=webpack://bos-platform/./src/workflow/images/up.png?");

/***/ }),

/***/ "./src/workflow/images/waiting.png":
/*!*****************************************!*\
  !*** ./src/workflow/images/waiting.png ***!
  \*****************************************/
/***/ (function(module) {

eval("module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA0AAAANCAYAAABy6+R8AAAAAXNSR0IArs4c6QAAAUlJREFUKBWNUrtOw0AQ3LucQQg3YEf0FFCnRxY9Ep+QBiT+ABeg4ARRmD+IBA1VlBp+wKKgiVIiKOgReTSgADZebnKcFRBYbLPnnRnf7O4Jmomd1riW5dk+kQiYyBdEAyJOlFSn542lvqVKHLpdrtSbw6OUsysW8oYkb7tVz0PGN+rAI+YpX0F0eTs6FMybjrNQOztwH1H7ip7Ovd2T506avnYeWiOUmwKW8Kc59V1Qj574Iqpqhya0cOU9m/Qdobak6UHGP26w3CIbXMbga48iECK/LtCSg+GJQGFKruff/caFRVuH1co83WcT8hXG+jIcrGsQTRcx248tfrzRGvjaHid6khsWKMuGx4nE4ojyENMpExg8D8GXZtOyjT38JUQdOJFsgz/dA14EFqxv3NNAjCkt6uGgV2MpDyFYbSwfRxoslgdr/317n9g/qZ9r4ir8AAAAAElFTkSuQmCC\"\n\n//# sourceURL=webpack://bos-platform/./src/workflow/images/waiting.png?");

/***/ }),

/***/ "./src/workflow/images/waiting2.png":
/*!******************************************!*\
  !*** ./src/workflow/images/waiting2.png ***!
  \******************************************/
/***/ (function(module) {

eval("module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABoAAAAaCAYAAACpSkzOAAAAAXNSR0IArs4c6QAAAr1JREFUSA29Vj1oFEEUfm/u4O4MIilN4OwinKVKKosEtMwF5FQUf2orbbRNq41W1kZR1EOIlgYuhVVQSwPaeWAso8X9wd0+v29u99isYe8SVx8sM7P73vfN23k/ozJGLq5250yDZTE7K6JlE5mhiYpsi1hTVNfV3NrL68WvaVDQ31tqj1snAXIfBIt7ayTeqjage6d+Y+pT4otf/kG0smH5rW+dh6ZyE4aqKjtm8kZzeILcVlAqwBMR1+nNBBKcgM4SdKrQmcbGTE0eVY6Vbq0saD9OuIvo8jOb7vc7r81sQUW74uyBFQ/dq1/QX3Gj5Lz2yo5ot31XAr1tYkXsbiOfL51/fkV3It0Rkfek2XlHEuzse05t+cW1qY+R4iTjpSetUwPTNXg5S7JKuXQu8sxFAP53hSR4N79fEuKENvPcKDdMzAjfexQe/Af8355zdiaNBLoIPBEc+uhvRGDRSM+CQN/jnAvw7jQDZOjRMLqUZ5JGEgGNGz0GsBhMPnJh4GpPu8fxYtFHFw5+HMik3xlExCQ2c9GpBVUaM4THRdekJNQjFjE5Z8I7MCDjkenIE46ZiupbjwcOnJGWuWAyZkoCMCfu8xBTy/modkUZPylZFH1J/Xg0esx2W8gxyqOkQRbrwwXWXgjKRR6zbTDOsXbhVWoFpk18x1ynSetn7yi/I/p+wCOUeoi5QYVjluKLrge0pgPdOuc2EB/mWRIhopc8HjicqfNhDfeqrMJZEfmKDkzisTG6+tXiF3jVYD/xpT4jJmKFParB7juMOnRGkBn7CQvi33J5DGB5TGJDPBGrKzsjmxb7SW21PXtQMtoSwzdAYBJ7RMQJ2y+bFQ6QJJsH8Sy02SSGb3zAJDZlV0/5L618yCuyn8sJc49pwYgND36yy0lExvGfX7fiZJ4QjdH3rJQLJHPRp0nSOLb+DXRWgKbEuiXfAAAAAElFTkSuQmCC\"\n\n//# sourceURL=webpack://bos-platform/./src/workflow/images/waiting2.png?");

/***/ }),

/***/ "./src/workflow/images/withnotapprovalrecord2.png":
/*!********************************************************!*\
  !*** ./src/workflow/images/withnotapprovalrecord2.png ***!
  \********************************************************/
/***/ (function(module) {

eval("module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAB+CAYAAADvPdXPAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAAZiS0dEAP8A/wD/oL2nkwAAHKVJREFUeJztfXuYVNWV72/tU/2obrqRBnm0yMPw6AeIQY2EEAMtIDQaEkFsDBqj811nnEwy+TTGTBKuM7lmbjJm8iWT+92J93p9BbtpFCVCN9hIY0ACCQakn9goT3k/u5p+VNXZ6/5xXvtUF911qqq70anf99V3nmuvXWedtfZ67HMO4TOAytqGQbKLJgnm0ZKRQ4wcFjKHmHIAgIkDJEWACQFBCEiiYyKDP1w2p7htoPve16CB7oBXVNY2jOROniOBL4FRSMyTAQwBcEQCpwXQyYI7SBcdLKgdAEhyFmvST5L8EsgUwHAAYwBcYKL9IDQJ4D3KpNplc4pPDuT/SzauegHX1rLvdGfTfGa5EEAJmPOZsJdA9ZCiCZnaX8rmTv5LPG1XbN5/Kzr1WyG4kCGnEOMmEB0HsIVIVA/PLHx7zhwKJ/cf9S8GRMDMrAF4HMAyAJMB7AdQCeCXRKQDQMXGxumQ/CBDLgfoEwjeSezbfN+CgjeIiPuoX7R6Y/PXmcJzIWkGwNcRRDkEvVy2oOivfcGzr9HvAjaFuxnA7O7H8O7amuYXwuHwEwzKgUAtdPp/y+8q3tbf/QSA8vUNX4bGD0NiDoEDIPq3Ef7iVz9NWj0QAn4SwM+vdLzxo7NHGppPP7PsruLn+rFbvaJyfcN/00k+QkTDiennOZT+QmnpxK6B7ldvGAgB7wZwcw+nvE9Et/RXf7yifGPD/ULy30ngBgh+avmCqa8MdJ96wkAIOABgUA+ntBEZ4c3VjNUb65axxE/AOO/TxGNLFxQ3DHSfomEgBPw+gOk9nPL+iQvYxIwnwEj31DghSIRn8/PoRwl1MkYYTlnDs2B+ECxeGJGVtXLOnPGd/cE7Voj+ZPba240TG1vOjOzltEpIfMezcAGAkQ6J78TXO+8gIi5bOOVxn0+bCeLpp9ov/+m1txsn9hf/WNBvAl5dXb88HNbfqz90rhzA1iucthXALyHwGxCCnpkQghD4Tfy9jA9L5xe1lJVOmUs+bXM4rL+3urp+eX/34UrocxNdyazJqobfgHiBIPG9ZQuL/xBLHGzhxDleKRn/HKXjPxo1FM8SkfcboQ9RWd3wVcnyV0xUrS0o/u6yiP/T30iqgJl5DIDnAcwAsLO1teux6vdafgGIkTJdfu3+uVNPeW3zeCsP4yDORO5PG4qc4URXZS751c11I0RQvMmQJ0b6B90/kONysk308wDmwvCS54akvgugrFwUzY5HuABAITwWbX/4HL7DzN7H6X7A/XOnnspF0WwCZZ9qb9tUWfPR4IHqS7I12BUC6boM+3xaWk80x8/zM3F5zBb62XP2itVVDWsk5KSMdF/JPXMLz/U3/2Rr8E51Q9PE1l4p4vWYLfSz5+wV95UW38tAXVeXvmHTppPZ/c0/qQLu6sKjFy51nNUlh2Hkmx+JoQfxecwWBshz9oL7S6euIEGnz4fPvrZ7N/do0ZINevrpWt+149JLAHGTsUvuPXMouOXpp+d4SqgzM62urn9FMq5fXjqlJNIb/q8OZtbKq+q3CMLR+xZOeaCvKmKRENeOSy8B0SwQDzJ+NMsQuDdUVjd8H4wp2eG0u1LC7Q4i0rPDaXeBMaWyuuH7/cVXWJqbBu33JOQqc/dNXhop31Q3U4If96WLby1eXBBIdic/K1i8uCDgSxffkuDHyzfVzewPnq4x2CfTPJuNtZubhlKYyonTfrZ0XvGe5HXts4ml84r3EKf9jMJUvnZz09C+5icAuRcAQtBXhKCvMHYb+2JBMKi/AMaOskUFv+6LDn4WUbao4Ndg7AgG9Rf6mpc4cyi4BZrYDqY2MLVBE9vPHApuiYW4orrhXmZMvLSo+MG+7uhnDZcWFT/IjIkV1Q339iWfuBMdlbUNg/QO2SRBP/pG6ZSXk9mp/ypYVVX/oAA/o/lFYV9N4Y07DpYd8mmSvC8l3PjxjdIpL5PkfbJDPt1XPHzxEFXU1BUihG/60n194gnuO8xDOi5jCYBJzBiwPG40EOESgA/92Xj9xrF0IdH2fOm+fwyH9R0VNXXPl82b2pSELroQnwaH6MfE4vWl84taktwf7DvMQ9oDWMmMW6824QIAMwYz49b2AFbuO8xDEm1v6fyiFjBeR4h+nIz+RcKzgCs3NkxgxvwcyvtJX3So4zKWgJDVF20nFYQs08okjFwa9hNmzK/c2DAhGe2p8CxgqeMpErS+tHRUtxptkjCpj9rtCySlr6Wlo86QoPVSx1OJtFOzW66veV++pu7zNAa/XtUyOoSur2fn5H0+kY70hGhmORhC9umLfFsohHwGZ5Hp+xMZYYBr27VOynF2b5NCjx7oyTpu0pOxtM75415eQQJb0xhPzphGx+L939k5Q/775dbze16vanl6SenEuNph8CLAPcPFkwYH0fUtAmrvnpV/JJ4OxIOuELKPnpFLOrt4gmTOYgDMbP5gLwGY2+o6g2GcayEqPQCQdSzaeQo9k4teMo+SEstDhA92fsCj4/2fd8/KPyIIW4Po+la8bRARE7tDX29eNOMBwb5+LayfusC36ToyiYwLSgxAkPMviAwBsaFRzDA1zBG8dYCZTe0lkHLMOo9MIRPM8xFBD+vqGZpsHgQzQ0rKCwn8AsD98f5X0n0VoPAzAH4aK03NbrmBwaUArBsx7e3dunnPUlXMGlxZ3fRFItC9dxWs8djvhNAV5HxjzTakbg2SxoVWtU9KS7iqWkbQwxCgNImYATbbkrZWmzQWPav8YWmwuQ9g2f15Ky+4966CNUSgyuqmLybSjgKOWYMlywcIojZJjGOGrnMWzHFQkHFxydxhaRuzo32AcS7bam1qtTmGgp0x1NhvtkMw9FPZZ51gitDhTwYXa926fSQwKtH/SxC1kuUDAP4Uy/nzbhGLrPWa3TIIgm/ezcJW3Jg0mJkJkEu1TH7ec48ThCE0ssdLkKWBtkmyNdnSKmXINGVkmmFb25zx12rb1lo4N4pNT9TtfIePaaIjxup4YVxjudS45t5guAduupg0eE1V8xRAtC0tKd7llWkywKbWWabV0SSCNJdpPkLhGMJ11wKD/Abd5Q7g+Dngw6MMXfZMT6aqRorIUHpWrD1DEMzxmCAl2942kiDgpSXFuyo2NLQZ1xx1XmgJWA9QhrovJgFLhEuY2ROzREAE7VIgMPHy5fZiKYfZYQ6gmE/rXAAjhgAzignZfvdNf02O8Rs7EtjdzDh70XHEDLAyzDrWQVgmHI4ZV0Mptu2+47Ja9MkAs14nSZbAo4Dn3Sy6JV5iEjATlWjp2p+9MPMCZvb98uX35rVfDj4ZaLuUP/LawSfBGTmDs9OPnj8EsyhuesYGgT2ODs8DSm4mezsasjMJt08Dtu1jnLkIOIIl06yybYbHjyLkZjscrRW19bYOxrEz0eiTM81Ky/D9WQ/JEgAJ19h7FTAzi9VV9bd3tYsnE2Wmtvm/X931+TMX2n84ODeTAGxaOHPiqNPnL9fnDc1NA4Asf3rAONea3mUIV1gOFjN8GuGLxaJH4VogItw8Gdi82zHXtlVwCSfCWzNY27GyFSa56K3tJM0y72oXr6X59CeYWRCRTKStXgW89p2WcRJoe2Bxwf54mTAzvfjm3rGHP7nwQ3+GNhrAuoVzCvLqPzzZOr0wvwkAiiYMP1EEnKg/iBujt6GMhzCEUjQOGOTv+apeamPsqNNxS6GGa68hTBwNNB02xk+O0DwhCAdPAIBlppXxFWrmjF0xtyVckSQJP7C4YP+rG+ra1r7TMg7Ax4m01auAQ8HQZEHCc+rsp//n3fF6l/43Po2+AKDynrmFGW+/13JN0cThfwaAcaMGnx83avDOXprplsRQw57rh/ccBJy+wNj2QRjDriEMG2xc/PyhQOMhy0mywxsIshwmx2smO4mi3AjkOGNW2lOyEY7Ibi5a/BAkjoWCocnoawEDPJmAT7w0ysyTtuz8+OETZ1sLbxg9dC8Ayh2UEVx655R3PPeQATY9K2vctC5vjlJz+lO9jhF5hBvyDaEfOSWx09z35Wk+WwsH+R3hADC9aDWmVoIlM+Nl568U58uml2w7Xkmy0AYv8CdsPHlZnUg7vY/B4MkEOhprg//yv955asfeI0NKZtzwERK8+wBDAAIEO7pTBaBc0qxMYFdDGB1dPvg0YM+HOkYONYQrlCvPAFg6pG5nyzG5JJx4WyjpUIOtw9tFnzwFBoCjDJ6caCO9JjoINJGliKmwz8zEoL/PHZTZkWjHXO3CSvy7r2Fru7M+bYKGyWM17DsQxl/3hzEyj3D7NB9ExD9si+iZk8DonuCwcgbd+Tt3jCvhEv9f7AaWooUYCdeHYzHRQ3wZvpge/SQi1nX+H0Ik77/a6UNrXIRzIY+cZAzNdS729EkahgwidASByWNEN+ECwPGzjhGw9ZAMrRZkjKMi0qu2nDHTEEelZ7gsRaLwZfhOhYP6kITb6f0UGhTsCF2ItcE9zZ9kTxwzLJQ7KCM575CyHStWnB9jd91BxsTr2eVJj8+/slG63MFoOqzmlxUe5mJCvhUHky08Jzgylm0dwKGTpnlW06IJ/1kHwY7QBeFL/G1DvZpoBnKy/CLm2Rsbtu6fu+uDY0WJdcvF38wTk7JtaEwoDGz7QMaUYGBm7GpkhHTHLKtLV75b4R1NalesRyf4X1Vk+cUZBhIWcK8aTEBOO4VPx9qggHi9KxyekVi3HFiaC3Y8XmsbAE6cAzbukvjyNHHFmLitg7GzQeLUBUsh1cyXZXKNtg98YppaMz1KAEgYUbNJas8MsXbYxjyJEm6n8GmBxDW4dxPN7A/cMeV8rA3++LHZLwLQEuhTBH9zQY6JVMu7zIaQ174rMfUGwtiRTvgUaAeOnWY0HgZ0nRQaZ3x1ig/mHjJvJFhhkRX0OuGZi54ZQjj0yULgjinnB1fV+xNtJ5YxuH3YtqZhAE7E0iAR6W/VNuVNL7ounD88pzXB/tleqqV5rmKA4nSFdWBPC2PvAbaHTSsRYZIa4RacPLaazOi5nqwI3LIortjZTZ8MDNvWNCwEau/9zJ7R+xhMCKSH5XAvjb7feLz4L/XHoqYcvUIdH43rHVnPhVnPhR3GqKEMm9JTQ5yo9D3Ukx3+3Ct9spAelsOZkPCjuDHEwRzo7KJhXhrN0MQqf6bvYty9iuyBuZRmYd0ZN8lVqAdgWFTz4ktbOGxrv01vtRk5vQeW1VDCKYWnVITs4p+kUqGFzi4aRuCEBRxDJgsB6Fqel0afenT2JhivzE8Y1ngIKFkjq2dMLnOrhlNkGm+H3nGS2CJQnCX7JlAK+JbWu+jtNdjbFt/k1YN5TEdX+N/TfWICM9cAeISI4prJGksm6zzS9N7eL+mmIeIX1+4Zsf/g2RHxdKobLA2zzKM0hAtEhCn2ec5kOqVXcIdCzo3hMsM2vcrb2W/5BO5tlT4peN6f4btR04QG471jcU+V6l2DCS1SCs8ps8MnLwzNbNKunzx+2Kb4umbyt66lkhcGAcXjgaGD7XgmQsutDdfCPG7d046zZY7sSgPOxD43PSHQDnx83C1ko3vsZpQYIsPMuMPO3jWYaT8gr/facEaG76XRI3KT9HCaE2s6E9HdV1MdRtm1E+5zLW9NGUedU60GlBgsQitV/vbSnIyQxHpSZBm117LqlRBDmCT3S4kVXhv+4d98ZQ8zfz42HleGZVKFMMZHmFWefR9JJ+kBJ3SyHi2xQyUyRKCGS/Z5AISAE3oRw5peG3leZNGfzTYJZj3YnMCXJDxy7mL7vrzB/nQieg+xvG/sCuhVg9MytP0kKK5HMv7jlT+N/XPdsRvioY2EnVywg1VnTFZ3dwt1uoU+pCzJNXHeWjrjLOw8h0qvhmHS1HJ1/E4URHRk886Dl9+obS4konnxOlhADAK+p6TwCDMy3qxpmuq18QuBznDDgdMJxcOuJw/MbZYAS3UecuS8ZYZV4ZHKDeCOdyPpTedNNb2R9BZ/i17CHhsin4FKBG/WNE1lRsY9JYUJPwPW+xhMxARs7QpKz8/CZuSkvzS9KD+mGfpXBEdONHf1zp1wgJrMULxb9EAP5cawG1ETI1BuiG7kDj0nz4vuCsolBGxNxtvwYns2ibBFCt3zl1CeenDWkWmTRyY0q0M1j6qVtrTLEIRpai1BwNFQV8ICTjvd6M2THIth0ivhk+Wf2fQS3eiTASn0W0CI6U1HvSE2Afu4lljEZWp/8fy24s07D9wUD60KNS0IwDUOWjutaXSWYNSYqRu9y+12j6NOebIHeqiH3eN4oiAWN/pEWlIEHJOHWzZvalN5Vb22pqZp9r3zCrd6YdDZGfzkwKHzM+fOwN54Omhnk8jKTRn7bppgzZS0vGeHJto8aQJ1TzSRdcTxxg0IwPa8rbhYAGRMwz0QZY5psia+r6lpmh0O6drSOyc3J9wYPIQwBFoTDuvfxJU/qBEVGcOv+f3dt0+M+33QrnowAGKOKkA1U3ilrKEV9kbJhRh8YIRK1hGDt0kER8sZUOfdmVodvV9eEQ7r3yRQ0h7RjT1GFfQywvINrwyeWnbLpR8wH4TxSdc44CQirLwRA9jbYl18ZS4UOeuu1y/Y8bASzyrrztwtNov9TnnQiqEj42hF5sbDaLaHliB0LoFPfD3xhgzE/AB42YKiv0JQYFVVvefXFj7zn1tvW7u58Ste6YDI0MaJO61jgDUeWjeCmqNWHS4nzAFgD79OOwq97Ug5D4lLpS246Lov48WqqvoHISiQzC+den3LzisasNQrE8lcd/zUpfFe6QAYSUBzRiPgjHXqxe4e3wJOcYGdJZtZZyWWtek5gt5OpBjrlgeNaPQw69Hx/EEF5rVN6rcQPQk4Kz3rRWae9cq6Zk8TskdouWseXX7bi556ZoGdMEUyG6GJcuFdF9YSAIwbI1rt2PKQnX2RgnFi40j6aPtchf4EJPzKuubJzDwrKz3rxfhb6Q5PAl4894ZTRLQqLS280gvdo4/eEiIpDrV1hDw7W9aT85FPDtjxrRqbQplZwaZjFknPlglmRSsVepcFcNNboZl1A6mhGne7UXoGM2vM/CQz72bmwOI7xu/4wtTrGr96x/izXq9RT/D8IjTW+BcAFry1/bingv7Pntty+x/eabzDKz8DBMfkumu9V5q2ammaE7CSberdVaTIerJJLxU3WekDM5tJlYgbJYK+J7Dzkeyfw/jU7qCc7PS8G64f8iUAm83jSYFnAS+/c+pRML1xOXDhn70xEtvPX+wY4pWfMy6yLVjXOAolV9HN+WJH2yzBqMkQRsSPlYQHIs5xzLP1lINiQBwrERseBzD7Csdmm8eTgrheRpqWkfYzZr77rY3102Kl+fFjszd9e8WMl+LhFzkOOuvG0gpXgAhBW8UAjl5PjpzZQbb5ddqy+fdEzwCzO3PWC5YleDxmxCXgJXMnfQzm37bp8t9jpSEiPnzy4qFjJwODvfBy8rxOCtIVtiCi4mSuW86TfdwuWhiOVTR6yTCnAzljqqWddgHDPM/xut38Y0RvTmrCTxVaiPuF4COzBv1PgMZVrG+M+m3BaHhp7d7pG95tLu3pHJ+GDjBEoK1zSCispztmU7165phqCQSqWVaqQlFyyZFtdDPLSvXJ3OEy306bUerRsQu4t7clxP02hUjELeA5c8Z3CqH9A4ifWLeuOaZHLDIz054LhcPdJtBLgPY2nRjTcvjctVmZOHj05Pkxp89dGt56OXhWdaCsqpFTKVLHVFXYTpwsZQS9EsPaYzKpZUNlKaPUo69YT452E10RlQkejxkJJ08rqupXsZSDlt914+JYzmfm9NbLwaUvvfH+YxPGDG1YePuk9196c8/sI8cvTs/JTv/pN775pXUt+7HAJ/EFZgyu/Wt4hS6RBThTZ1zPB9lTcpyig52GjExPulKWyrQci16Z7uNKaRq1B4W30wbsVCaBgBMr7tTyY7gG2sXWjpPX5PqjzTffCmBusj4ulvC3C/25vr8FicLy9ftiekE4EQUrVtWtuRjo+s+9TSc3ASg/FMp4aOXflxR876FZq4YTtX2pgF67rYienFFMj4Z1XueeluNoix2jghRNY9vEquuwlkwuDXbRszHvS/WKXfRw2rHGXtWygGIrxFRsqPunTe99fCEs5U8AvA+gzVz+AEkULpAEDQaAyrcbbtLDXJOuiSVL7iz6YzLatPDz3/PoYDj8AcB5dnHA1hzz/c1Qt+FatwsOiKLddjEhgp6j0bv3Ge05xQgQndcyxLQVc3p+Z/TrmxpvD0n9NaGJ+cvmF+9N5rWKhqR8fXTZ/OK9BF4ZCuu/e3VzXXImu5v4wQo6lu7zTQOhnEicABAxjprjZEQSQ41v1XSk5QU7VkD1kpV5WXDiYIOeotIz6ARA5bEI99XNdSNCYf13JMXK/hAukCQNtlBeXf9bAdx6/eDi2TNnUlLf0/Fpx44d7D96qWGrBP6yfOGUbw90f+ICM4vyDXWryzfse4fjeFvqZxHMPIaZa8K6DJ271H6Smcf2J/+kfiCaiKQ2TjxAJLhiY90byWz7U4znAczVBPnycv0jAPzf/mTeJ1q2bntzTkdruJoYgYulxV99lCjUF3yudvyOOe0Rye2aIHXmTBtR4q9miBV9ZkYrdxz1y4uXVgOcp+fk3v2NL4+90Fe8rkas2nZ4iBZofWv+zM9NGjLYf61yaDMRzbsS3fptPIQy9K8JQdcRiyNSx5ulMyjuNyUk1USrWDbz+o4R/uJ7AHyotbbWvvFO3ef6itfVhjfeqfuc1tpaC+BDf4b/NhilwTZz2eNzRpShf41A41kiXbKcAKHfnUhf+kzAADBnDoXLSqc+TER/6AzyH8urGx7qS35XA8qrGx7qDPIfiegPZaVTH/b76aD5fFFOLM8ZCUHXubbJve0VfSpgC/eVTlmpkfYISf7X1VWNz/UHz4HA6qrG50jyvwqIh+8rneJp1osFYuG6ARgioeeT+jWUWfd2c35HKFQOQjrSMr9XNm9i3M+9Xk2oqGmZgVDnr8AI+tPSli+eX3A83raqdnIuBO4WJK9jiCOZbVg/Zw7F/W3hfo9VK5k1ubHx+8z8BJjfHDtkyj98WpMiO3aw//CF+v8A0deI6FmxoOjfliUxj5wMDFgyorKmYYwMyV8DuBHgX5WV3vjbgepLPKio2vdtgL4HYJ9IE99dNq+43z735wUDnm2q3Ni4SNf1ZwVEJ0N7sWxRwa8Huk89oWJD83cJ+kMSMlPTtCeWLSjaMNB96gkDLmDASHGu3ti4BJJ/JAlpAuLVXBQ+W1pKyXljbYKoquKMVjQ9ISHvF4wQBD1z34Ki1xP9YEZ/4KoQsIqKDXV3MeEJAhUT8K6QvtX9/b1EC2vWN98rRfg+Br7C4AZiPFu2aOr6gehLvLjqBGyhclPzeF0PrwDjAQILSdipCbE9T8ssnzfvc5f6gmdNzUeDz+udy3UpZwnGDAZJEF7RNN/vl91ZcLAvePY1rloBq6ioapwByIUMlAD8eWI0E6FBSj7gy9D2abmDt99z2+hzXtpcu+vYUL310qxwl36jEDSBGcVMKABoDwFbAFFdVlr0qQ/jPhUCVvHW7uNZl0+fm0WgWRIoJPBkMCaAxHkAp8CyE0QdADoAK/xiPwA/mP0gkQlgBFjmgXCAQfsF0MTg7dnDh26/+5b8hN/wejXhUyfgaGBmUbGxeYwGOVoyckggR7LMITaqNkwcECQCLBEQhIAOcaxsQcGRT4OTlEIKKaSQQgoppJBCCimkkEIKKaSQQgoppJBCCimkkEIKKaSQQgoppJBCCimkkEIKKaSQQgoppJBCCimkkEIKKaSQQgpJx/8HHlESBD+5PGsAAAA+ZVhJZgAIAAGHaQAEAAAAAQAAABoAAAAAAAOgAQADAAAAAQABAACgAgAEAAAAAQAAAHigAwAEAAAAAQAAAH4AAAAAqIC9TgAAAABJRU5ErkJggg==\"\n\n//# sourceURL=webpack://bos-platform/./src/workflow/images/withnotapprovalrecord2.png?");

/***/ })

}]);