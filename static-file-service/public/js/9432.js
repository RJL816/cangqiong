/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackJsonp_bos-platform"] = self["webpackJsonp_bos-platform"] || []).push([[9432],{

/***/ "./src/util/UTIF.js":
/*!**************************!*\
  !*** ./src/util/UTIF.js ***!
  \**************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("/* module decorator */ module = __webpack_require__.nmd(module);\n/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"../../node_modules/process/browser.js\");\n\n\n__webpack_require__(/*! core-js/modules/es.symbol.js */ \"../../node_modules/core-js/modules/es.symbol.js\");\n__webpack_require__(/*! core-js/modules/es.symbol.description.js */ \"../../node_modules/core-js/modules/es.symbol.description.js\");\n__webpack_require__(/*! core-js/modules/es.symbol.iterator.js */ \"../../node_modules/core-js/modules/es.symbol.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.string.iterator.js */ \"../../node_modules/core-js/modules/es.string.iterator.js\");\n__webpack_require__(/*! core-js/modules/web.dom-collections.iterator.js */ \"../../node_modules/core-js/modules/web.dom-collections.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.array.concat.js */ \"../../node_modules/core-js/modules/es.array.concat.js\");\n__webpack_require__(/*! core-js/modules/es.array.fill.js */ \"../../node_modules/core-js/modules/es.array.fill.js\");\n__webpack_require__(/*! core-js/modules/es.array.index-of.js */ \"../../node_modules/core-js/modules/es.array.index-of.js\");\n__webpack_require__(/*! core-js/modules/es.array.iterator.js */ \"../../node_modules/core-js/modules/es.array.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.array.slice.js */ \"../../node_modules/core-js/modules/es.array.slice.js\");\n__webpack_require__(/*! core-js/modules/es.array.splice.js */ \"../../node_modules/core-js/modules/es.array.splice.js\");\n__webpack_require__(/*! core-js/modules/es.array-buffer.slice.js */ \"../../node_modules/core-js/modules/es.array-buffer.slice.js\");\n__webpack_require__(/*! core-js/modules/es.date.now.js */ \"../../node_modules/core-js/modules/es.date.now.js\");\n__webpack_require__(/*! core-js/modules/es.date.to-string.js */ \"../../node_modules/core-js/modules/es.date.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.function.name.js */ \"../../node_modules/core-js/modules/es.function.name.js\");\n__webpack_require__(/*! core-js/modules/es.math.log2.js */ \"../../node_modules/core-js/modules/es.math.log2.js\");\n__webpack_require__(/*! core-js/modules/es.math.sign.js */ \"../../node_modules/core-js/modules/es.math.sign.js\");\n__webpack_require__(/*! core-js/modules/es.object.keys.js */ \"../../node_modules/core-js/modules/es.object.keys.js\");\n__webpack_require__(/*! core-js/modules/es.object.to-string.js */ \"../../node_modules/core-js/modules/es.object.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.parse-int.js */ \"../../node_modules/core-js/modules/es.parse-int.js\");\n__webpack_require__(/*! core-js/modules/es.regexp.to-string.js */ \"../../node_modules/core-js/modules/es.regexp.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.string.ends-with.js */ \"../../node_modules/core-js/modules/es.string.ends-with.js\");\n__webpack_require__(/*! core-js/modules/es.string.repeat.js */ \"../../node_modules/core-js/modules/es.string.repeat.js\");\n__webpack_require__(/*! core-js/modules/es.typed-array.float32-array.js */ \"../../node_modules/core-js/modules/es.typed-array.float32-array.js\");\n__webpack_require__(/*! core-js/modules/es.typed-array.float64-array.js */ \"../../node_modules/core-js/modules/es.typed-array.float64-array.js\");\n__webpack_require__(/*! core-js/modules/es.typed-array.int8-array.js */ \"../../node_modules/core-js/modules/es.typed-array.int8-array.js\");\n__webpack_require__(/*! core-js/modules/es.typed-array.int16-array.js */ \"../../node_modules/core-js/modules/es.typed-array.int16-array.js\");\n__webpack_require__(/*! core-js/modules/es.typed-array.int32-array.js */ \"../../node_modules/core-js/modules/es.typed-array.int32-array.js\");\n__webpack_require__(/*! core-js/modules/es.typed-array.uint8-array.js */ \"../../node_modules/core-js/modules/es.typed-array.uint8-array.js\");\n__webpack_require__(/*! core-js/modules/es.typed-array.uint8-clamped-array.js */ \"../../node_modules/core-js/modules/es.typed-array.uint8-clamped-array.js\");\n__webpack_require__(/*! core-js/modules/es.typed-array.uint16-array.js */ \"../../node_modules/core-js/modules/es.typed-array.uint16-array.js\");\n__webpack_require__(/*! core-js/modules/es.typed-array.uint32-array.js */ \"../../node_modules/core-js/modules/es.typed-array.uint32-array.js\");\n__webpack_require__(/*! core-js/modules/es.typed-array.copy-within.js */ \"../../node_modules/core-js/modules/es.typed-array.copy-within.js\");\n__webpack_require__(/*! core-js/modules/es.typed-array.every.js */ \"../../node_modules/core-js/modules/es.typed-array.every.js\");\n__webpack_require__(/*! core-js/modules/es.typed-array.fill.js */ \"../../node_modules/core-js/modules/es.typed-array.fill.js\");\n__webpack_require__(/*! core-js/modules/es.typed-array.filter.js */ \"../../node_modules/core-js/modules/es.typed-array.filter.js\");\n__webpack_require__(/*! core-js/modules/es.typed-array.find.js */ \"../../node_modules/core-js/modules/es.typed-array.find.js\");\n__webpack_require__(/*! core-js/modules/es.typed-array.find-index.js */ \"../../node_modules/core-js/modules/es.typed-array.find-index.js\");\n__webpack_require__(/*! core-js/modules/es.typed-array.for-each.js */ \"../../node_modules/core-js/modules/es.typed-array.for-each.js\");\n__webpack_require__(/*! core-js/modules/es.typed-array.includes.js */ \"../../node_modules/core-js/modules/es.typed-array.includes.js\");\n__webpack_require__(/*! core-js/modules/es.typed-array.index-of.js */ \"../../node_modules/core-js/modules/es.typed-array.index-of.js\");\n__webpack_require__(/*! core-js/modules/es.typed-array.iterator.js */ \"../../node_modules/core-js/modules/es.typed-array.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.typed-array.join.js */ \"../../node_modules/core-js/modules/es.typed-array.join.js\");\n__webpack_require__(/*! core-js/modules/es.typed-array.last-index-of.js */ \"../../node_modules/core-js/modules/es.typed-array.last-index-of.js\");\n__webpack_require__(/*! core-js/modules/es.typed-array.map.js */ \"../../node_modules/core-js/modules/es.typed-array.map.js\");\n__webpack_require__(/*! core-js/modules/es.typed-array.reduce.js */ \"../../node_modules/core-js/modules/es.typed-array.reduce.js\");\n__webpack_require__(/*! core-js/modules/es.typed-array.reduce-right.js */ \"../../node_modules/core-js/modules/es.typed-array.reduce-right.js\");\n__webpack_require__(/*! core-js/modules/es.typed-array.reverse.js */ \"../../node_modules/core-js/modules/es.typed-array.reverse.js\");\n__webpack_require__(/*! core-js/modules/es.typed-array.set.js */ \"../../node_modules/core-js/modules/es.typed-array.set.js\");\n__webpack_require__(/*! core-js/modules/es.typed-array.slice.js */ \"../../node_modules/core-js/modules/es.typed-array.slice.js\");\n__webpack_require__(/*! core-js/modules/es.typed-array.some.js */ \"../../node_modules/core-js/modules/es.typed-array.some.js\");\n__webpack_require__(/*! core-js/modules/es.typed-array.sort.js */ \"../../node_modules/core-js/modules/es.typed-array.sort.js\");\n__webpack_require__(/*! core-js/modules/es.typed-array.subarray.js */ \"../../node_modules/core-js/modules/es.typed-array.subarray.js\");\n__webpack_require__(/*! core-js/modules/es.typed-array.to-locale-string.js */ \"../../node_modules/core-js/modules/es.typed-array.to-locale-string.js\");\n__webpack_require__(/*! core-js/modules/es.typed-array.to-string.js */ \"../../node_modules/core-js/modules/es.typed-array.to-string.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\n;\n(function () {\n  var UTIF = {};\n\n  // Make available for import by `require()`\n  if (( false ? 0 : _typeof(module)) == \"object\") {\n    module.exports = UTIF;\n  } else {\n    self.UTIF = UTIF;\n  }\n  function log() {\n    if (typeof process == \"undefined\" || \"development\" == \"development\") console.log.apply(console, arguments);\n  }\n  (function (UTIF) {\n    // Following lines add a JPEG decoder  to UTIF.JpegDecoder\n    (function () {\n      \"use strict\";\n\n      var W = function a1() {\n          function W(p) {\n            this.message = \"JPEG error: \" + p;\n          }\n          W.prototype = new Error();\n          W.prototype.name = \"JpegError\";\n          W.constructor = W;\n          return W;\n        }(),\n        ak = function ag() {\n          var p = new Uint8Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]),\n            t = 4017,\n            ac = 799,\n            ah = 3406,\n            ao = 2276,\n            ar = 1567,\n            ai = 3784,\n            s = 5793,\n            ad = 2896;\n          function ak(Q) {\n            if (Q == null) Q = {};\n            if (Q.w == null) Q.w = -1;\n            this.V = Q.n;\n            this.N = Q.w;\n          }\n          function a5(Q, h) {\n            var f = 0,\n              G = [],\n              n,\n              E,\n              a = 16,\n              F;\n            while (a > 0 && !Q[a - 1]) {\n              a--;\n            }\n            G.push({\n              children: [],\n              index: 0\n            });\n            var C = G[0];\n            for (n = 0; n < a; n++) {\n              for (E = 0; E < Q[n]; E++) {\n                C = G.pop();\n                C.children[C.index] = h[f];\n                while (C.index > 0) {\n                  C = G.pop();\n                }\n                C.index++;\n                G.push(C);\n                while (G.length <= n) {\n                  G.push(F = {\n                    children: [],\n                    index: 0\n                  });\n                  C.children[C.index] = F.children;\n                  C = F;\n                }\n                f++;\n              }\n              if (n + 1 < a) {\n                G.push(F = {\n                  children: [],\n                  index: 0\n                });\n                C.children[C.index] = F.children;\n                C = F;\n              }\n            }\n            return G[0].children;\n          }\n          function a2(Q, h, f) {\n            return 64 * ((Q.P + 1) * h + f);\n          }\n          function a7(Q, h, f, G, n, E, a, C, F, d) {\n            if (d == null) d = !1;\n            var T = f.m,\n              U = f.Z,\n              z = h,\n              J = 0,\n              V = 0,\n              r = 0,\n              D = 0,\n              a8,\n              q = 0,\n              X,\n              O,\n              _,\n              N,\n              e,\n              K,\n              x = 0,\n              k,\n              g,\n              R,\n              c;\n            function Y() {\n              if (V > 0) {\n                V--;\n                return J >> V & 1;\n              }\n              J = Q[h++];\n              if (J === 255) {\n                var I = Q[h++];\n                if (I) {\n                  if (I === 220 && d) {\n                    h += 2;\n                    var l = Z(Q, h);\n                    h += 2;\n                    if (l > 0 && l !== f.s) {\n                      throw new DNLMarkerError(\"Found DNL marker (0xFFDC) while parsing scan data\", l);\n                    }\n                  } else if (I === 217) {\n                    if (d) {\n                      var M = q * 8;\n                      if (M > 0 && M < f.s / 10) {\n                        throw new DNLMarkerError(\"Found EOI marker (0xFFD9) while parsing scan data, \" + \"possibly caused by incorrect `scanLines` parameter\", M);\n                      }\n                    }\n                    throw new EOIMarkerError(\"Found EOI marker (0xFFD9) while parsing scan data\");\n                  }\n                  throw new W(\"unexpected marker\");\n                }\n              }\n              V = 7;\n              return J >>> 7;\n            }\n            function u(I) {\n              var l = I;\n              while (!0) {\n                l = l[Y()];\n                switch (_typeof(l)) {\n                  case \"number\":\n                    return l;\n                  case \"object\":\n                    continue;\n                }\n                throw new W(\"invalid huffman sequence\");\n              }\n            }\n            function m(I) {\n              var e = 0;\n              while (I > 0) {\n                e = e << 1 | Y();\n                I--;\n              }\n              return e;\n            }\n            function j(I) {\n              if (I === 1) {\n                return Y() === 1 ? 1 : -1;\n              }\n              var e = m(I);\n              if (e >= 1 << I - 1) {\n                return e;\n              }\n              return e + (-1 << I) + 1;\n            }\n            function v(X, I) {\n              var l = u(X.J),\n                M = l === 0 ? 0 : j(l),\n                N = 1;\n              X.D[I] = X.Q += M;\n              while (N < 64) {\n                var S = u(X.i),\n                  i = S & 15,\n                  A = S >> 4;\n                if (i === 0) {\n                  if (A < 15) {\n                    break;\n                  }\n                  N += 16;\n                  continue;\n                }\n                N += A;\n                var o = p[N];\n                X.D[I + o] = j(i);\n                N++;\n              }\n            }\n            function $(X, I) {\n              var l = u(X.J),\n                M = l === 0 ? 0 : j(l) << F;\n              X.D[I] = X.Q += M;\n            }\n            function b(X, I) {\n              X.D[I] |= Y() << F;\n            }\n            function P(X, I) {\n              if (r > 0) {\n                r--;\n                return;\n              }\n              var N = E,\n                l = a;\n              while (N <= l) {\n                var M = u(X.i),\n                  S = M & 15,\n                  i = M >> 4;\n                if (S === 0) {\n                  if (i < 15) {\n                    r = m(i) + (1 << i) - 1;\n                    break;\n                  }\n                  N += 16;\n                  continue;\n                }\n                N += i;\n                var A = p[N];\n                X.D[I + A] = j(S) * (1 << F);\n                N++;\n              }\n            }\n            function a4(X, I) {\n              var N = E,\n                l = a,\n                M = 0,\n                S,\n                i;\n              while (N <= l) {\n                var A = I + p[N],\n                  o = X.D[A] < 0 ? -1 : 1;\n                switch (D) {\n                  case 0:\n                    i = u(X.i);\n                    S = i & 15;\n                    M = i >> 4;\n                    if (S === 0) {\n                      if (M < 15) {\n                        r = m(M) + (1 << M);\n                        D = 4;\n                      } else {\n                        M = 16;\n                        D = 1;\n                      }\n                    } else {\n                      if (S !== 1) {\n                        throw new W(\"invalid ACn encoding\");\n                      }\n                      a8 = j(S);\n                      D = M ? 2 : 3;\n                    }\n                    continue;\n                  case 1:\n                  case 2:\n                    if (X.D[A]) {\n                      X.D[A] += o * (Y() << F);\n                    } else {\n                      M--;\n                      if (M === 0) {\n                        D = D === 2 ? 3 : 0;\n                      }\n                    }\n                    break;\n                  case 3:\n                    if (X.D[A]) {\n                      X.D[A] += o * (Y() << F);\n                    } else {\n                      X.D[A] = a8 << F;\n                      D = 0;\n                    }\n                    break;\n                  case 4:\n                    if (X.D[A]) {\n                      X.D[A] += o * (Y() << F);\n                    }\n                    break;\n                }\n                N++;\n              }\n              if (D === 4) {\n                r--;\n                if (r === 0) {\n                  D = 0;\n                }\n              }\n            }\n            function H(X, I, x, l, M) {\n              var S = x / T | 0,\n                i = x % T;\n              q = S * X.A + l;\n              var A = i * X.h + M,\n                o = a2(X, q, A);\n              I(X, o);\n            }\n            function w(X, I, x) {\n              q = x / X.P | 0;\n              var l = x % X.P,\n                M = a2(X, q, l);\n              I(X, M);\n            }\n            var y = G.length;\n            if (U) {\n              if (E === 0) {\n                K = C === 0 ? $ : b;\n              } else {\n                K = C === 0 ? P : a4;\n              }\n            } else {\n              K = v;\n            }\n            if (y === 1) {\n              g = G[0].P * G[0].c;\n            } else {\n              g = T * f.R;\n            }\n            while (x <= g) {\n              var L = n ? Math.min(g - x, n) : g;\n              if (L > 0) {\n                for (O = 0; O < y; O++) {\n                  G[O].Q = 0;\n                }\n                r = 0;\n                if (y === 1) {\n                  X = G[0];\n                  for (e = 0; e < L; e++) {\n                    w(X, K, x);\n                    x++;\n                  }\n                } else {\n                  for (e = 0; e < L; e++) {\n                    for (O = 0; O < y; O++) {\n                      X = G[O];\n                      R = X.h;\n                      c = X.A;\n                      for (_ = 0; _ < c; _++) {\n                        for (N = 0; N < R; N++) {\n                          H(X, K, x, _, N);\n                        }\n                      }\n                    }\n                    x++;\n                  }\n                }\n              }\n              V = 0;\n              k = an(Q, h);\n              if (!k) {\n                break;\n              }\n              if (k.u) {\n                var a6 = L > 0 ? \"unexpected\" : \"excessive\";\n                h = k.offset;\n              }\n              if (k.M >= 65488 && k.M <= 65495) {\n                h += 2;\n              } else {\n                break;\n              }\n            }\n            return h - z;\n          }\n          function al(Q, h, f) {\n            var G = Q.$,\n              n = Q.D,\n              E,\n              a,\n              C,\n              F,\n              d,\n              T,\n              U,\n              z,\n              J,\n              V,\n              Y,\n              u,\n              m,\n              j,\n              v,\n              $,\n              b;\n            if (!G) {\n              throw new W(\"missing required Quantization Table.\");\n            }\n            for (var r = 0; r < 64; r += 8) {\n              J = n[h + r];\n              V = n[h + r + 1];\n              Y = n[h + r + 2];\n              u = n[h + r + 3];\n              m = n[h + r + 4];\n              j = n[h + r + 5];\n              v = n[h + r + 6];\n              $ = n[h + r + 7];\n              J *= G[r];\n              if ((V | Y | u | m | j | v | $) === 0) {\n                b = s * J + 512 >> 10;\n                f[r] = b;\n                f[r + 1] = b;\n                f[r + 2] = b;\n                f[r + 3] = b;\n                f[r + 4] = b;\n                f[r + 5] = b;\n                f[r + 6] = b;\n                f[r + 7] = b;\n                continue;\n              }\n              V *= G[r + 1];\n              Y *= G[r + 2];\n              u *= G[r + 3];\n              m *= G[r + 4];\n              j *= G[r + 5];\n              v *= G[r + 6];\n              $ *= G[r + 7];\n              E = s * J + 128 >> 8;\n              a = s * m + 128 >> 8;\n              C = Y;\n              F = v;\n              d = ad * (V - $) + 128 >> 8;\n              z = ad * (V + $) + 128 >> 8;\n              T = u << 4;\n              U = j << 4;\n              E = E + a + 1 >> 1;\n              a = E - a;\n              b = C * ai + F * ar + 128 >> 8;\n              C = C * ar - F * ai + 128 >> 8;\n              F = b;\n              d = d + U + 1 >> 1;\n              U = d - U;\n              z = z + T + 1 >> 1;\n              T = z - T;\n              E = E + F + 1 >> 1;\n              F = E - F;\n              a = a + C + 1 >> 1;\n              C = a - C;\n              b = d * ao + z * ah + 2048 >> 12;\n              d = d * ah - z * ao + 2048 >> 12;\n              z = b;\n              b = T * ac + U * t + 2048 >> 12;\n              T = T * t - U * ac + 2048 >> 12;\n              U = b;\n              f[r] = E + z;\n              f[r + 7] = E - z;\n              f[r + 1] = a + U;\n              f[r + 6] = a - U;\n              f[r + 2] = C + T;\n              f[r + 5] = C - T;\n              f[r + 3] = F + d;\n              f[r + 4] = F - d;\n            }\n            for (var P = 0; P < 8; ++P) {\n              J = f[P];\n              V = f[P + 8];\n              Y = f[P + 16];\n              u = f[P + 24];\n              m = f[P + 32];\n              j = f[P + 40];\n              v = f[P + 48];\n              $ = f[P + 56];\n              if ((V | Y | u | m | j | v | $) === 0) {\n                b = s * J + 8192 >> 14;\n                if (b < -2040) {\n                  b = 0;\n                } else if (b >= 2024) {\n                  b = 255;\n                } else {\n                  b = b + 2056 >> 4;\n                }\n                n[h + P] = b;\n                n[h + P + 8] = b;\n                n[h + P + 16] = b;\n                n[h + P + 24] = b;\n                n[h + P + 32] = b;\n                n[h + P + 40] = b;\n                n[h + P + 48] = b;\n                n[h + P + 56] = b;\n                continue;\n              }\n              E = s * J + 2048 >> 12;\n              a = s * m + 2048 >> 12;\n              C = Y;\n              F = v;\n              d = ad * (V - $) + 2048 >> 12;\n              z = ad * (V + $) + 2048 >> 12;\n              T = u;\n              U = j;\n              E = (E + a + 1 >> 1) + 4112;\n              a = E - a;\n              b = C * ai + F * ar + 2048 >> 12;\n              C = C * ar - F * ai + 2048 >> 12;\n              F = b;\n              d = d + U + 1 >> 1;\n              U = d - U;\n              z = z + T + 1 >> 1;\n              T = z - T;\n              E = E + F + 1 >> 1;\n              F = E - F;\n              a = a + C + 1 >> 1;\n              C = a - C;\n              b = d * ao + z * ah + 2048 >> 12;\n              d = d * ah - z * ao + 2048 >> 12;\n              z = b;\n              b = T * ac + U * t + 2048 >> 12;\n              T = T * t - U * ac + 2048 >> 12;\n              U = b;\n              J = E + z;\n              $ = E - z;\n              V = a + U;\n              v = a - U;\n              Y = C + T;\n              j = C - T;\n              u = F + d;\n              m = F - d;\n              if (J < 16) {\n                J = 0;\n              } else if (J >= 4080) {\n                J = 255;\n              } else {\n                J >>= 4;\n              }\n              if (V < 16) {\n                V = 0;\n              } else if (V >= 4080) {\n                V = 255;\n              } else {\n                V >>= 4;\n              }\n              if (Y < 16) {\n                Y = 0;\n              } else if (Y >= 4080) {\n                Y = 255;\n              } else {\n                Y >>= 4;\n              }\n              if (u < 16) {\n                u = 0;\n              } else if (u >= 4080) {\n                u = 255;\n              } else {\n                u >>= 4;\n              }\n              if (m < 16) {\n                m = 0;\n              } else if (m >= 4080) {\n                m = 255;\n              } else {\n                m >>= 4;\n              }\n              if (j < 16) {\n                j = 0;\n              } else if (j >= 4080) {\n                j = 255;\n              } else {\n                j >>= 4;\n              }\n              if (v < 16) {\n                v = 0;\n              } else if (v >= 4080) {\n                v = 255;\n              } else {\n                v >>= 4;\n              }\n              if ($ < 16) {\n                $ = 0;\n              } else if ($ >= 4080) {\n                $ = 255;\n              } else {\n                $ >>= 4;\n              }\n              n[h + P] = J;\n              n[h + P + 8] = V;\n              n[h + P + 16] = Y;\n              n[h + P + 24] = u;\n              n[h + P + 32] = m;\n              n[h + P + 40] = j;\n              n[h + P + 48] = v;\n              n[h + P + 56] = $;\n            }\n          }\n          function a0(Q, h) {\n            var f = h.P,\n              G = h.c,\n              n = new Int16Array(64);\n            for (var E = 0; E < G; E++) {\n              for (var a = 0; a < f; a++) {\n                var C = a2(h, E, a);\n                al(h, C, n);\n              }\n            }\n            return h.D;\n          }\n          function an(Q, h, f) {\n            if (f == null) f = h;\n            var G = Q.length - 1,\n              n = f < h ? f : h;\n            if (h >= G) {\n              return null;\n            }\n            var E = Z(Q, h);\n            if (E >= 65472 && E <= 65534) {\n              return {\n                u: null,\n                M: E,\n                offset: h\n              };\n            }\n            var a = Z(Q, n);\n            while (!(a >= 65472 && a <= 65534)) {\n              if (++n >= G) {\n                return null;\n              }\n              a = Z(Q, n);\n            }\n            return {\n              u: E.toString(16),\n              M: a,\n              offset: n\n            };\n          }\n          ak.prototype = {\n            parse: function parse(Q, h) {\n              if (h == null) h = {};\n              var f = h.F,\n                E = 0,\n                a = null,\n                C = null,\n                F,\n                d,\n                T = 0;\n              function G() {\n                var o = Z(Q, E);\n                E += 2;\n                var B = E + o - 2,\n                  V = an(Q, B, E);\n                if (V && V.u) {\n                  B = V.offset;\n                }\n                var ab = Q.subarray(E, B);\n                E += ab.length;\n                return ab;\n              }\n              function n(F) {\n                var o = Math.ceil(F.o / 8 / F.X),\n                  B = Math.ceil(F.s / 8 / F.B);\n                for (var Y = 0; Y < F.W.length; Y++) {\n                  R = F.W[Y];\n                  var ab = Math.ceil(Math.ceil(F.o / 8) * R.h / F.X),\n                    af = Math.ceil(Math.ceil(F.s / 8) * R.A / F.B),\n                    ap = o * R.h,\n                    aq = B * R.A,\n                    ae = 64 * aq * (ap + 1);\n                  R.D = new Int16Array(ae);\n                  R.P = ab;\n                  R.c = af;\n                }\n                F.m = o;\n                F.R = B;\n              }\n              var U = [],\n                z = [],\n                J = [],\n                V = Z(Q, E);\n              E += 2;\n              if (V !== 65496) {\n                throw new W(\"SOI not found\");\n              }\n              V = Z(Q, E);\n              E += 2;\n              markerLoop: while (V !== 65497) {\n                var Y, u, m;\n                switch (V) {\n                  case 65504:\n                  case 65505:\n                  case 65506:\n                  case 65507:\n                  case 65508:\n                  case 65509:\n                  case 65510:\n                  case 65511:\n                  case 65512:\n                  case 65513:\n                  case 65514:\n                  case 65515:\n                  case 65516:\n                  case 65517:\n                  case 65518:\n                  case 65519:\n                  case 65534:\n                    var j = G();\n                    if (V === 65504) {\n                      if (j[0] === 74 && j[1] === 70 && j[2] === 73 && j[3] === 70 && j[4] === 0) {\n                        a = {\n                          version: {\n                            d: j[5],\n                            T: j[6]\n                          },\n                          K: j[7],\n                          j: j[8] << 8 | j[9],\n                          H: j[10] << 8 | j[11],\n                          S: j[12],\n                          I: j[13],\n                          C: j.subarray(14, 14 + 3 * j[12] * j[13])\n                        };\n                      }\n                    }\n                    if (V === 65518) {\n                      if (j[0] === 65 && j[1] === 100 && j[2] === 111 && j[3] === 98 && j[4] === 101) {\n                        C = {\n                          version: j[5] << 8 | j[6],\n                          k: j[7] << 8 | j[8],\n                          q: j[9] << 8 | j[10],\n                          a: j[11]\n                        };\n                      }\n                    }\n                    break;\n                  case 65499:\n                    var v = Z(Q, E),\n                      b;\n                    E += 2;\n                    var $ = v + E - 2;\n                    while (E < $) {\n                      var r = Q[E++],\n                        P = new Uint16Array(64);\n                      if (r >> 4 === 0) {\n                        for (u = 0; u < 64; u++) {\n                          b = p[u];\n                          P[b] = Q[E++];\n                        }\n                      } else if (r >> 4 === 1) {\n                        for (u = 0; u < 64; u++) {\n                          b = p[u];\n                          P[b] = Z(Q, E);\n                          E += 2;\n                        }\n                      } else {\n                        throw new W(\"DQT - invalid table spec\");\n                      }\n                      U[r & 15] = P;\n                    }\n                    break;\n                  case 65472:\n                  case 65473:\n                  case 65474:\n                    if (F) {\n                      throw new W(\"Only single frame JPEGs supported\");\n                    }\n                    E += 2;\n                    F = {};\n                    F.G = V === 65473;\n                    F.Z = V === 65474;\n                    F.precision = Q[E++];\n                    var D = Z(Q, E),\n                      a4,\n                      q = 0,\n                      H = 0;\n                    E += 2;\n                    F.s = f || D;\n                    F.o = Z(Q, E);\n                    E += 2;\n                    F.W = [];\n                    F._ = {};\n                    var a8 = Q[E++];\n                    for (Y = 0; Y < a8; Y++) {\n                      a4 = Q[E];\n                      var w = Q[E + 1] >> 4,\n                        y = Q[E + 1] & 15;\n                      if (q < w) {\n                        q = w;\n                      }\n                      if (H < y) {\n                        H = y;\n                      }\n                      var X = Q[E + 2];\n                      m = F.W.push({\n                        h: w,\n                        A: y,\n                        L: X,\n                        $: null\n                      });\n                      F._[a4] = m - 1;\n                      E += 3;\n                    }\n                    F.X = q;\n                    F.B = H;\n                    n(F);\n                    break;\n                  case 65476:\n                    var O = Z(Q, E);\n                    E += 2;\n                    for (Y = 2; Y < O;) {\n                      var _ = Q[E++],\n                        N = new Uint8Array(16),\n                        e = 0;\n                      for (u = 0; u < 16; u++, E++) {\n                        e += N[u] = Q[E];\n                      }\n                      var K = new Uint8Array(e);\n                      for (u = 0; u < e; u++, E++) {\n                        K[u] = Q[E];\n                      }\n                      Y += 17 + e;\n                      (_ >> 4 === 0 ? J : z)[_ & 15] = a5(N, K);\n                    }\n                    break;\n                  case 65501:\n                    E += 2;\n                    d = Z(Q, E);\n                    E += 2;\n                    break;\n                  case 65498:\n                    var x = ++T === 1 && !f,\n                      R;\n                    E += 2;\n                    var k = Q[E++],\n                      g = [];\n                    for (Y = 0; Y < k; Y++) {\n                      var c = Q[E++],\n                        L = F._[c];\n                      R = F.W[L];\n                      R.index = c;\n                      var a6 = Q[E++];\n                      R.J = J[a6 >> 4];\n                      R.i = z[a6 & 15];\n                      g.push(R);\n                    }\n                    var I = Q[E++],\n                      l = Q[E++],\n                      M = Q[E++];\n                    try {\n                      var S = a7(Q, E, F, g, d, I, l, M >> 4, M & 15, x);\n                      E += S;\n                    } catch (ex) {\n                      if (ex instanceof DNLMarkerError) {\n                        return this.parse(Q, {\n                          F: ex.s\n                        });\n                      } else if (ex instanceof EOIMarkerError) {\n                        break markerLoop;\n                      }\n                      throw ex;\n                    }\n                    break;\n                  case 65500:\n                    E += 4;\n                    break;\n                  case 65535:\n                    if (Q[E] !== 255) {\n                      E--;\n                    }\n                    break;\n                  default:\n                    var i = an(Q, E - 2, E - 3);\n                    if (i && i.u) {\n                      E = i.offset;\n                      break;\n                    }\n                    if (E >= Q.length - 1) {\n                      break markerLoop;\n                    }\n                    throw new W(\"JpegImage.parse - unknown marker: \" + V.toString(16));\n                }\n                V = Z(Q, E);\n                E += 2;\n              }\n              this.width = F.o;\n              this.height = F.s;\n              this.g = a;\n              this.b = C;\n              this.W = [];\n              for (Y = 0; Y < F.W.length; Y++) {\n                R = F.W[Y];\n                var A = U[R.L];\n                if (A) {\n                  R.$ = A;\n                }\n                this.W.push({\n                  index: R.index,\n                  e: a0(F, R),\n                  l: R.h / F.X,\n                  t: R.A / F.B,\n                  P: R.P,\n                  c: R.c\n                });\n              }\n              this.p = this.W.length;\n              return undefined;\n            },\n            Y: function Y(Q, h, f) {\n              if (f == null) f = !1;\n              var G = this.width / Q,\n                n = this.height / h,\n                E,\n                a,\n                C,\n                F,\n                d,\n                T,\n                U,\n                z,\n                J,\n                V,\n                Y = 0,\n                u,\n                m = this.W.length,\n                j = Q * h * m,\n                v = new Uint8ClampedArray(j),\n                $ = new Uint32Array(Q),\n                b = 4294967288,\n                r;\n              for (U = 0; U < m; U++) {\n                E = this.W[U];\n                a = E.l * G;\n                C = E.t * n;\n                Y = U;\n                u = E.e;\n                F = E.P + 1 << 3;\n                if (a !== r) {\n                  for (d = 0; d < Q; d++) {\n                    z = 0 | d * a;\n                    $[d] = (z & b) << 3 | z & 7;\n                  }\n                  r = a;\n                }\n                for (T = 0; T < h; T++) {\n                  z = 0 | T * C;\n                  V = F * (z & b) | (z & 7) << 3;\n                  for (d = 0; d < Q; d++) {\n                    v[Y] = u[V + $[d]];\n                    Y += m;\n                  }\n                }\n              }\n              var P = this.V;\n              if (!f && m === 4 && !P) {\n                P = new Int32Array([-256, 255, -256, 255, -256, 255, -256, 255]);\n              }\n              if (P) {\n                for (U = 0; U < j;) {\n                  for (z = 0, J = 0; z < m; z++, U++, J += 2) {\n                    v[U] = (v[U] * P[J] >> 8) + P[J + 1];\n                  }\n                }\n              }\n              return v;\n            },\n            get f() {\n              if (this.b) {\n                return !!this.b.a;\n              }\n              if (this.p === 3) {\n                if (this.N === 0) {\n                  return !1;\n                } else if (this.W[0].index === 82 && this.W[1].index === 71 && this.W[2].index === 66) {\n                  return !1;\n                }\n                return !0;\n              }\n              if (this.N === 1) {\n                return !0;\n              }\n              return !1;\n            },\n            z: function aj(Q) {\n              var h, f, G;\n              for (var n = 0, E = Q.length; n < E; n += 3) {\n                h = Q[n];\n                f = Q[n + 1];\n                G = Q[n + 2];\n                Q[n] = h - 179.456 + 1.402 * G;\n                Q[n + 1] = h + 135.459 - .344 * f - .714 * G;\n                Q[n + 2] = h - 226.816 + 1.772 * f;\n              }\n              return Q;\n            },\n            O: function aa(Q) {\n              var h,\n                f,\n                G,\n                n,\n                E = 0;\n              for (var a = 0, C = Q.length; a < C; a += 4) {\n                h = Q[a];\n                f = Q[a + 1];\n                G = Q[a + 2];\n                n = Q[a + 3];\n                Q[E++] = -122.67195406894 + f * (-660635669420364e-19 * f + .000437130475926232 * G - 54080610064599e-18 * h + .00048449797120281 * n - .154362151871126) + G * (-.000957964378445773 * G + .000817076911346625 * h - .00477271405408747 * n + 1.53380253221734) + h * (.000961250184130688 * h - .00266257332283933 * n + .48357088451265) + n * (-.000336197177618394 * n + .484791561490776);\n                Q[E++] = 107.268039397724 + f * (219927104525741e-19 * f - .000640992018297945 * G + .000659397001245577 * h + .000426105652938837 * n - .176491792462875) + G * (-.000778269941513683 * G + .00130872261408275 * h + .000770482631801132 * n - .151051492775562) + h * (.00126935368114843 * h - .00265090189010898 * n + .25802910206845) + n * (-.000318913117588328 * n - .213742400323665);\n                Q[E++] = -20.810012546947 + f * (-.000570115196973677 * f - 263409051004589e-19 * G + .0020741088115012 * h - .00288260236853442 * n + .814272968359295) + G * (-153496057440975e-19 * G - .000132689043961446 * h + .000560833691242812 * n - .195152027534049) + h * (.00174418132927582 * h - .00255243321439347 * n + .116935020465145) + n * (-.000343531996510555 * n + .24165260232407);\n              }\n              return Q.subarray(0, E);\n            },\n            r: function a3(Q) {\n              var h, f, G;\n              for (var n = 0, E = Q.length; n < E; n += 4) {\n                h = Q[n];\n                f = Q[n + 1];\n                G = Q[n + 2];\n                Q[n] = 434.456 - h - 1.402 * G;\n                Q[n + 1] = 119.541 - h + .344 * f + .714 * G;\n                Q[n + 2] = 481.816 - h - 1.772 * f;\n              }\n              return Q;\n            },\n            U: function as(Q) {\n              var h,\n                f,\n                G,\n                n,\n                E = 0;\n              for (var a = 0, C = Q.length; a < C; a += 4) {\n                h = Q[a];\n                f = Q[a + 1];\n                G = Q[a + 2];\n                n = Q[a + 3];\n                Q[E++] = 255 + h * (-6747147073602441e-20 * h + .0008379262121013727 * f + .0002894718188643294 * G + .003264231057537806 * n - 1.1185611867203937) + f * (26374107616089404e-21 * f - 8626949158638572e-20 * G - .0002748769067499491 * n - .02155688794978967) + G * (-3878099212869363e-20 * G - .0003267808279485286 * n + .0686742238595345) - n * (.0003361971776183937 * n + .7430659151342254);\n                Q[E++] = 255 + h * (.00013596372813588848 * h + .000924537132573585 * f + .00010567359618683593 * G + .0004791864687436512 * n - .3109689587515875) + f * (-.00023545346108370344 * f + .0002702845253534714 * G + .0020200308977307156 * n - .7488052167015494) + G * (6834815998235662e-20 * G + .00015168452363460973 * n - .09751927774728933) - n * (.0003189131175883281 * n + .7364883807733168);\n                Q[E++] = 255 + h * (13598650411385308e-21 * h + .00012423956175490851 * f + .0004751985097583589 * G - 36729317476630424e-22 * n - .05562186980264034) + f * (.00016141380598724676 * f + .0009692239130725186 * G + .0007782692450036253 * n - .44015232367526463) + G * (5.068882914068769e-7 * G + .0017778369011375071 * n - .7591454649749609) - n * (.0003435319965105553 * n + .7063770186160144);\n              }\n              return Q.subarray(0, E);\n            },\n            getData: function getData(Q) {\n              var h = Q.width,\n                f = Q.height,\n                G = Q.forceRGB,\n                n = Q.isSourcePDF;\n              if (this.p > 4) {\n                throw new W(\"Unsupported color mode\");\n              }\n              var E = this.Y(h, f, n);\n              if (this.p === 1 && G) {\n                var a = E.length,\n                  C = new Uint8ClampedArray(a * 3),\n                  F = 0;\n                for (var d = 0; d < a; d++) {\n                  var T = E[d];\n                  C[F++] = T;\n                  C[F++] = T;\n                  C[F++] = T;\n                }\n                return C;\n              } else if (this.p === 3 && this.f) {\n                return this.z(E);\n              } else if (this.p === 4) {\n                if (this.f) {\n                  if (G) {\n                    return this.O(E);\n                  }\n                  return this.r(E);\n                } else if (G) {\n                  return this.U(E);\n                }\n              }\n              return E;\n            }\n          };\n          return ak;\n        }();\n      function a9(p, t) {\n        return p[t] << 24 >> 24;\n      }\n      function Z(p, t) {\n        return p[t] << 8 | p[t + 1];\n      }\n      function am(p, t) {\n        return (p[t] << 24 | p[t + 1] << 16 | p[t + 2] << 8 | p[t + 3]) >>> 0;\n      }\n      UTIF.JpegDecoder = ak;\n    })();\n\n    //UTIF.JpegDecoder = PDFJS.JpegImage;\n\n    UTIF.encodeImage = function (rgba, w, h, metadata) {\n      var idf = {\n        \"t256\": [w],\n        \"t257\": [h],\n        \"t258\": [8, 8, 8, 8],\n        \"t259\": [1],\n        \"t262\": [2],\n        \"t273\": [1000],\n        // strips offset\n        \"t277\": [4],\n        \"t278\": [h],\n        /* rows per strip */\"t279\": [w * h * 4],\n        // strip byte counts\n        \"t282\": [[72, 1]],\n        \"t283\": [[72, 1]],\n        \"t284\": [1],\n        \"t286\": [[0, 1]],\n        \"t287\": [[0, 1]],\n        \"t296\": [1],\n        \"t305\": [\"Photopea (UTIF.js)\"],\n        \"t338\": [1]\n      };\n      if (metadata) for (var i in metadata) idf[i] = metadata[i];\n      var prfx = new Uint8Array(UTIF.encode([idf]));\n      var img = new Uint8Array(rgba);\n      var data = new Uint8Array(1000 + w * h * 4);\n      for (var i = 0; i < prfx.length; i++) data[i] = prfx[i];\n      for (var i = 0; i < img.length; i++) data[1000 + i] = img[i];\n      return data.buffer;\n    };\n    UTIF.encode = function (ifds) {\n      var LE = false;\n      var data = new Uint8Array(20000),\n        offset = 4,\n        bin = LE ? UTIF._binLE : UTIF._binBE;\n      data[0] = data[1] = LE ? 73 : 77;\n      bin.writeUshort(data, 2, 42);\n      var ifdo = 8;\n      bin.writeUint(data, offset, ifdo);\n      offset += 4;\n      for (var i = 0; i < ifds.length; i++) {\n        var noffs = UTIF._writeIFD(bin, UTIF._types.basic, data, ifdo, ifds[i]);\n        ifdo = noffs[1];\n        if (i < ifds.length - 1) {\n          if ((ifdo & 3) != 0) ifdo += 4 - (ifdo & 3); // make each IFD start at multiple of 4\n          bin.writeUint(data, noffs[0], ifdo);\n        }\n      }\n      return data.slice(0, ifdo).buffer;\n    };\n    UTIF.decode = function (buff, prm) {\n      if (prm == null) prm = {\n        parseMN: true,\n        debug: false\n      }; // read MakerNote, debug\n      var data = new Uint8Array(buff),\n        offset = 0;\n      var id = UTIF._binBE.readASCII(data, offset, 2);\n      offset += 2;\n      var bin = id == \"II\" ? UTIF._binLE : UTIF._binBE;\n      var num = bin.readUshort(data, offset);\n      offset += 2;\n      var ifdo = bin.readUint(data, offset);\n      offset += 4;\n      var ifds = [];\n      while (true) {\n        var cnt = bin.readUshort(data, ifdo),\n          typ = bin.readUshort(data, ifdo + 4);\n        if (cnt != 0) if (typ < 1 || 13 < typ) {\n          log(\"error in TIFF\");\n          break;\n        }\n        ;\n        UTIF._readIFD(bin, data, ifdo, ifds, 0, prm);\n        ifdo = bin.readUint(data, ifdo + 2 + cnt * 12);\n        if (ifdo == 0) break;\n      }\n      return ifds;\n    };\n    UTIF.decodeImage = function (buff, img, ifds) {\n      if (img.data) return;\n      var data = new Uint8Array(buff);\n      var id = UTIF._binBE.readASCII(data, 0, 2);\n      if (img[\"t256\"] == null) return; // No width => probably not an image\n      img.isLE = id == \"II\";\n      img.width = img[\"t256\"][0]; //delete img[\"t256\"];\n      img.height = img[\"t257\"][0]; //delete img[\"t257\"];\n\n      var cmpr = img[\"t259\"] ? img[\"t259\"][0] : 1; //delete img[\"t259\"];\n      var fo = img[\"t266\"] ? img[\"t266\"][0] : 1; //delete img[\"t266\"];\n      if (img[\"t284\"] && img[\"t284\"][0] == 2) log(\"PlanarConfiguration 2 should not be used!\");\n      if (cmpr == 7 && img[\"t258\"] && img[\"t258\"].length > 3) img[\"t258\"] = img[\"t258\"].slice(0, 3);\n      var spp = img[\"t277\"] ? img[\"t277\"][0] : 1;\n      var bps = img[\"t258\"] ? img[\"t258\"][0] : 1;\n      var bipp = bps * spp; // bits per pixel\n      /*\r\n      var bipp;  // bits per pixel\r\n      if(img[\"t258\"]) bipp = Math.min(32,img[\"t258\"][0])*img[\"t258\"].length;\r\n      else            bipp = (img[\"t277\"]?img[\"t277\"][0]:1);\r\n      */\n      // Some .NEF files have t258==14, even though they use 16 bits per pixel\n      if (cmpr == 1 && img[\"t279\"] != null && img[\"t278\"] && img[\"t262\"][0] == 32803) {\n        bipp = Math.round(img[\"t279\"][0] * 8 / (img.width * img[\"t278\"][0]));\n      }\n      if (img[\"t50885\"] && img[\"t50885\"][0] == 4) bipp = img[\"t258\"][0] * 3; // RAW_CANON_40D_SRAW_V103.CR2\n      var bipl = Math.ceil(img.width * bipp / 8) * 8;\n      var soff = img[\"t273\"];\n      if (soff == null || img[\"t322\"]) soff = img[\"t324\"];\n      var bcnt = img[\"t279\"];\n      if (cmpr == 1 && soff.length == 1) bcnt = [img.height * (bipl >>> 3)];\n      if (bcnt == null || img[\"t322\"]) bcnt = img[\"t325\"];\n      //bcnt[0] = Math.min(bcnt[0], data.length);  // Hasselblad, \"RAW_HASSELBLAD_H3D39II.3FR\"\n      var bytes = new Uint8Array(img.height * (bipl >>> 3)),\n        bilen = 0;\n      if (img[\"t322\"] != null)\n        // tiled\n        {\n          var tw = img[\"t322\"][0],\n            th = img[\"t323\"][0];\n          var tx = Math.floor((img.width + tw - 1) / tw);\n          var ty = Math.floor((img.height + th - 1) / th);\n          var tbuff = new Uint8Array(Math.ceil(tw * th * bipp / 8) | 0);\n          console.log(\"====\", tx, ty);\n          for (var y = 0; y < ty; y++) for (var x = 0; x < tx; x++) {\n            var i = y * tx + x;\n            tbuff.fill(0);\n            UTIF.decode._decompress(img, ifds, data, soff[i], bcnt[i], cmpr, tbuff, 0, fo, tw, th);\n            // Might be required for 7 too. Need to check\n            if (cmpr == 6) bytes = tbuff;else UTIF._copyTile(tbuff, Math.ceil(tw * bipp / 8) | 0, th, bytes, Math.ceil(img.width * bipp / 8) | 0, img.height, Math.ceil(x * tw * bipp / 8) | 0, y * th);\n          }\n          bilen = bytes.length * 8;\n        } else\n        // stripped\n        {\n          if (soff == null) return;\n          var rps = img[\"t278\"] ? img[\"t278\"][0] : img.height;\n          rps = Math.min(rps, img.height);\n          //console.log(\"====\", img.width, rps);\n          for (var i = 0; i < soff.length; i++) {\n            UTIF.decode._decompress(img, ifds, data, soff[i], bcnt[i], cmpr, bytes, Math.ceil(bilen / 8) | 0, fo, img.width, rps);\n            bilen += bipl * rps;\n          }\n          bilen = Math.min(bilen, bytes.length * 8);\n        }\n      img.data = new Uint8Array(bytes.buffer, 0, Math.ceil(bilen / 8) | 0);\n    };\n    UTIF.decode._decompress = function (img, ifds, data, off, len, cmpr, tgt, toff, fo, w, h)\n    // fill order\n    {\n      if (img[\"t271\"] && img[\"t271\"][0] == \"Panasonic\" && img[\"t45\"] && img[\"t45\"][0] == 6) cmpr = 34316;\n      //console.log(\"compression\", cmpr);\n      //var time = Date.now();\n      if (false) {} else if (cmpr == 1 /* || (len==tgt.length && cmpr!=32767)*/) for (var j = 0; j < len; j++) tgt[toff + j] = data[off + j];else if (cmpr == 2) UTIF.decode._decodeG2(data, off, len, tgt, toff, w, fo);else if (cmpr == 3) UTIF.decode._decodeG3(data, off, len, tgt, toff, w, fo, img[\"t292\"] ? (img[\"t292\"][0] & 1) == 1 : false);else if (cmpr == 4) UTIF.decode._decodeG4(data, off, len, tgt, toff, w, fo);else if (cmpr == 5) UTIF.decode._decodeLZW(data, off, len, tgt, toff, 8);else if (cmpr == 6) UTIF.decode._decodeOldJPEG(img, data, off, len, tgt, toff);else if (cmpr == 7 || cmpr == 34892) UTIF.decode._decodeNewJPEG(img, data, off, len, tgt, toff);else if (cmpr == 8 || cmpr == 32946) {\n        var src = new Uint8Array(data.buffer, off + 2, len - 6);\n        var bin = UTIF._inflateRaw(src);\n        if (toff + bin.length <= tgt.length) tgt.set(bin, toff);\n      } else if (cmpr == 9) UTIF.decode._decodeVC5(data, off, len, tgt, toff, img[\"t33422\"]);else if (cmpr == 32767) UTIF.decode._decodeARW(img, data, off, len, tgt, toff);else if (cmpr == 32773) UTIF.decode._decodePackBits(data, off, len, tgt, toff);else if (cmpr == 32809) UTIF.decode._decodeThunder(data, off, len, tgt, toff);else if (cmpr == 34316) UTIF.decode._decodePanasonic(img, data, off, len, tgt, toff);else if (cmpr == 34713)\n        //for(var j=0; j<len; j++) tgt[toff+j] = data[off+j];\n        UTIF.decode._decodeNikon(img, ifds, data, off, len, tgt, toff);else if (cmpr == 34676) UTIF.decode._decodeLogLuv32(img, data, off, len, tgt, toff);else log(\"Unknown compression\", cmpr);\n\n      //console.log(Date.now()-time);\n\n      var bps = img[\"t258\"] ? Math.min(32, img[\"t258\"][0]) : 1;\n      var noc = img[\"t277\"] ? img[\"t277\"][0] : 1,\n        bpp = bps * noc >>> 3,\n        bpl = Math.ceil(bps * noc * w / 8);\n\n      // convert to Little Endian  /*\n      if (bps == 16 && !img.isLE && img[\"t33422\"] == null)\n        // not DNG\n        for (var y = 0; y < h; y++) {\n          //console.log(\"fixing endianity\");\n          var roff = toff + y * bpl;\n          for (var x = 1; x < bpl; x += 2) {\n            var t = tgt[roff + x];\n            tgt[roff + x] = tgt[roff + x - 1];\n            tgt[roff + x - 1] = t;\n          }\n        } //*/\n\n      if (img[\"t317\"] && img[\"t317\"][0] == 2) {\n        for (var y = 0; y < h; y++) {\n          var ntoff = toff + y * bpl;\n          if (bps == 16) for (var j = bpp; j < bpl; j += 2) {\n            var nv = (tgt[ntoff + j + 1] << 8 | tgt[ntoff + j]) + (tgt[ntoff + j - bpp + 1] << 8 | tgt[ntoff + j - bpp]);\n            tgt[ntoff + j] = nv & 255;\n            tgt[ntoff + j + 1] = nv >>> 8 & 255;\n          } else if (noc == 3) for (var j = 3; j < bpl; j += 3) {\n            tgt[ntoff + j] = tgt[ntoff + j] + tgt[ntoff + j - 3] & 255;\n            tgt[ntoff + j + 1] = tgt[ntoff + j + 1] + tgt[ntoff + j - 2] & 255;\n            tgt[ntoff + j + 2] = tgt[ntoff + j + 2] + tgt[ntoff + j - 1] & 255;\n          } else for (var j = bpp; j < bpl; j++) tgt[ntoff + j] = tgt[ntoff + j] + tgt[ntoff + j - bpp] & 255;\n        }\n      }\n    };\n    UTIF.decode._decodePanasonic = function (img, data, off, len, tgt, toff) {\n      var img_buffer = data.buffer;\n      var rawWidth = img[\"t2\"][0];\n      var rawHeight = img[\"t3\"][0];\n      var bitsPerSample = img[\"t10\"][0];\n      var RW2_Format = img[\"t45\"][0];\n      var bidx = 0;\n      var imageIndex = 0;\n      var vpos = 0;\n      var _byte = 0;\n      var arr_a, arr_b;\n      var bytes = RW2_Format == 6 ? new Uint32Array(18) : new Uint8Array(16);\n      var i,\n        j,\n        sh,\n        pred = [0, 0],\n        nonz = [0, 0],\n        isOdd,\n        idx = 0,\n        pixel_base;\n      var row, col, crow;\n      var buffer = new Uint8Array(0x4000);\n      var result = new Uint16Array(tgt.buffer);\n      function getDataRaw(bits) {\n        if (vpos == 0) {\n          var arr_a = new Uint8Array(img_buffer, off + imageIndex + 0x1ff8, 0x4000 - 0x1ff8);\n          var arr_b = new Uint8Array(img_buffer, off + imageIndex, 0x1ff8);\n          buffer.set(arr_a);\n          buffer.set(arr_b, arr_a.length);\n          imageIndex += 0x4000;\n        }\n        if (RW2_Format == 5) {\n          for (i = 0; i < 16; i++) {\n            bytes[i] = buffer[vpos++];\n            vpos &= 0x3FFF;\n          }\n        } else {\n          vpos = vpos - bits & 0x1ffff;\n          _byte = vpos >> 3 ^ 0x3ff0;\n          return (buffer[_byte] | buffer[_byte + 1] << 8) >> (vpos & 7) & ~(-1 << bits);\n        }\n      }\n      // Raw Format 6\n      function getBufferDataRW6(i) {\n        return buffer[vpos + 15 - i];\n      }\n      function readPageRW6() {\n        bytes[0] = getBufferDataRW6(0) << 6 | getBufferDataRW6(1) >> 2; // 14 bit\n        bytes[1] = ((getBufferDataRW6(1) & 0x3) << 12 | getBufferDataRW6(2) << 4 | getBufferDataRW6(3) >> 4) & 0x3fff;\n        bytes[2] = getBufferDataRW6(3) >> 2 & 0x3;\n        bytes[3] = (getBufferDataRW6(3) & 0x3) << 8 | getBufferDataRW6(4);\n        bytes[4] = getBufferDataRW6(5) << 2 | getBufferDataRW6(6) >> 6;\n        bytes[5] = (getBufferDataRW6(6) & 0x3f) << 4 | getBufferDataRW6(7) >> 4;\n        bytes[6] = getBufferDataRW6(7) >> 2 & 0x3;\n        bytes[7] = (getBufferDataRW6(7) & 0x3) << 8 | getBufferDataRW6(8);\n        bytes[8] = getBufferDataRW6(9) << 2 & 0x3fc | getBufferDataRW6(10) >> 6;\n        bytes[9] = (getBufferDataRW6(10) << 4 | getBufferDataRW6(11) >> 4) & 0x3ff;\n        bytes[10] = getBufferDataRW6(11) >> 2 & 0x3;\n        bytes[11] = (getBufferDataRW6(11) & 0x3) << 8 | getBufferDataRW6(12);\n        bytes[12] = (getBufferDataRW6(13) << 2 & 0x3fc | getBufferDataRW6(14) >> 6) & 0x3ff;\n        bytes[13] = (getBufferDataRW6(14) << 4 | getBufferDataRW6(15) >> 4) & 0x3ff;\n        vpos += 16;\n        _byte = 0;\n      }\n      function readPageRw6_bps12() {\n        bytes[0] = getBufferDataRW6(0) << 4 | getBufferDataRW6(1) >> 4;\n        bytes[1] = ((getBufferDataRW6(1) & 0xf) << 8 | getBufferDataRW6(2)) & 0xfff;\n        bytes[2] = getBufferDataRW6(3) >> 6 & 0x3;\n        bytes[3] = (getBufferDataRW6(3) & 0x3f) << 2 | getBufferDataRW6(4) >> 6;\n        bytes[4] = (getBufferDataRW6(4) & 0x3f) << 2 | getBufferDataRW6(5) >> 6;\n        bytes[5] = (getBufferDataRW6(5) & 0x3f) << 2 | getBufferDataRW6(6) >> 6;\n        bytes[6] = getBufferDataRW6(6) >> 4 & 0x3;\n        bytes[7] = (getBufferDataRW6(6) & 0xf) << 4 | getBufferDataRW6(7) >> 4;\n        bytes[8] = (getBufferDataRW6(7) & 0xf) << 4 | getBufferDataRW6(8) >> 4;\n        bytes[9] = (getBufferDataRW6(8) & 0xf) << 4 | getBufferDataRW6(9) >> 4;\n        bytes[10] = getBufferDataRW6(9) >> 2 & 0x3;\n        bytes[11] = (getBufferDataRW6(9) & 0x3) << 6 | getBufferDataRW6(10) >> 2;\n        bytes[12] = (getBufferDataRW6(10) & 0x3) << 6 | getBufferDataRW6(11) >> 2;\n        bytes[13] = (getBufferDataRW6(11) & 0x3) << 6 | getBufferDataRW6(12) >> 2;\n        bytes[14] = getBufferDataRW6(12) & 0x3;\n        bytes[15] = getBufferDataRW6(13);\n        bytes[16] = getBufferDataRW6(14);\n        bytes[17] = getBufferDataRW6(15);\n        vpos += 16;\n        _byte = 0;\n      }\n      // Main loop\n      function resetPredNonzeros() {\n        pred[0] = 0;\n        pred[1] = 0;\n        nonz[0] = 0;\n        nonz[1] = 0;\n      }\n      if (RW2_Format == 7) {\n        throw RW2_Format;\n\n        // Skatch of version 7\n        /*\r\n        var pixels_per_block = bitsPerSample == 14 ? 9 : 10;\r\n            rowbytes = 0|(rawWidth / pixels_per_block * 16);\r\n        for (row = 0; row < rawHeight - 15; row += 16) {\r\n            var rowstoread = Math.min(16, rawHeight - row);\r\n            var readlen = rowbytes*rowstoread;\r\n            buffer = new Uint8Array(image.slice(bidx, bidx+readlen));\r\n            vpos = 0;\r\n            bidx += readlen;\r\n            i = 0;\r\n            for (crow = 0; crow < rowstoread; crow++) {\r\n                idx = (row + crow) * rawWidth;\r\n                for (col = 0; col <= rawWidth - pixels_per_block; col += pixels_per_block) {\r\n                    for(j=0; j < pixels_per_block; j++) bytes[j] = buffer[i++];\r\n                    if (bitsPerSample == 12) {\r\n                        result[idx ] = ((bytes[1] & 0xF) << 8) + bytes[0];\r\n                        result[idx + 1] = 16 * bytes[2] + (bytes[1] >> 4);\r\n                        result[idx + 2] = ((bytes[4] & 0xF) << 8) + bytes[3];\r\n                        result[idx + 3] = 16 * bytes[5] + (bytes[4] >> 4);\r\n                        result[idx + 4] = ((bytes[7] & 0xF) << 8) + bytes[6];\r\n                        result[idx + 5] = 16 * bytes[8] + (bytes[7] >> 4);\r\n                        result[idx + 6] = ((bytes[10] & 0xF) << 8) + bytes[9];\r\n                        result[idx + 7] = 16 * bytes[11] + (bytes[10] >> 4);\r\n                        result[idx + 8] = ((bytes[13] & 0xF) << 8) + bytes[12];\r\n                        result[idx + 9] = 16 * bytes[14] + (bytes[13] >> 4);\r\n                    } else if (bitsPerSample == 14) {\r\n                        result[idx] = bytes[0] + ((bytes[1] & 0x3F) << 8);\r\n                        result[idx + 1] = (bytes[1] >> 6) + 4 * (bytes[2]) + ((bytes[3] & 0xF) << 10);\r\n                        result[idx + 2] = (bytes[3] >> 4) + 16 * (bytes[4]) + ((bytes[5] & 3) << 12);\r\n                        result[idx + 3] = ((bytes[5] & 0xFC) >> 2) + (bytes[6] << 6);\r\n                        result[idx + 4] = bytes[7] + ((bytes[8] & 0x3F) << 8);\r\n                        result[idx + 5] = (bytes[8] >> 6) + 4 * bytes[9] + ((bytes[10] & 0xF) << 10);\r\n                        result[idx + 6] = (bytes[10] >> 4) + 16 * bytes[11] + ((bytes[12] & 3) << 12);\r\n                        result[idx + 7] = ((bytes[12] & 0xFC) >> 2) + (bytes[13] << 6);\r\n                        result[idx + 8] = bytes[14] + ((bytes[15] & 0x3F) << 8);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        */\n      } else if (RW2_Format == 6) {\n        var is12bit = bitsPerSample == 12,\n          readPageRw6Fn = is12bit ? readPageRw6_bps12 : readPageRW6,\n          pixelsPerBlock = is12bit ? 14 : 11,\n          pixelbase0 = is12bit ? 0x80 : 0x200,\n          pixelbase_compare = is12bit ? 0x800 : 0x2000,\n          spix_compare = is12bit ? 0x3fff : 0xffff,\n          pixel_mask = is12bit ? 0xfff : 0x3fff,\n          blocksperrow = rawWidth / pixelsPerBlock,\n          rowbytes = blocksperrow * 16,\n          bufferSize = is12bit ? 18 : 14;\n        for (row = 0; row < rawHeight - 15; row += 16) {\n          var rowstoread = Math.min(16, rawHeight - row);\n          var readlen = rowbytes * rowstoread;\n          buffer = new Uint8Array(img_buffer, off + bidx, readlen); //new Uint8Array(image.slice(bidx, bidx+readlen));\n          vpos = 0;\n          bidx += readlen;\n          for (crow = 0, col = 0; crow < rowstoread; crow++, col = 0) {\n            idx = (row + crow) * rawWidth;\n            for (var rblock = 0; rblock < blocksperrow; rblock++) {\n              readPageRw6Fn();\n              resetPredNonzeros();\n              sh = 0;\n              pixel_base = 0;\n              for (i = 0; i < pixelsPerBlock; i++) {\n                isOdd = i & 1;\n                if (i % 3 == 2) {\n                  var base = _byte < bufferSize ? bytes[_byte++] : 0;\n                  if (base == 3) base = 4;\n                  pixel_base = pixelbase0 << base;\n                  sh = 1 << base;\n                }\n                var epixel = _byte < bufferSize ? bytes[_byte++] : 0;\n                if (pred[isOdd]) {\n                  epixel *= sh;\n                  if (pixel_base < pixelbase_compare && nonz[isOdd] > pixel_base) epixel += nonz[isOdd] - pixel_base;\n                  nonz[isOdd] = epixel;\n                } else {\n                  pred[isOdd] = epixel;\n                  if (epixel) nonz[isOdd] = epixel;else epixel = nonz[isOdd];\n                }\n                result[idx + col++] = epixel - 0xf <= spix_compare ? epixel - 0xf & spix_compare : epixel + 0x7ffffff1 >> 0x1f & pixel_mask;\n              }\n            }\n          }\n        }\n      } else if (RW2_Format == 5) {\n        var blockSize = bitsPerSample == 12 ? 10 : 9;\n        for (row = 0; row < rawHeight; row++) {\n          for (col = 0; col < rawWidth; col += blockSize) {\n            getDataRaw(0);\n            // Tuhle podminku pouziva i RW2_Format 7\n            if (bitsPerSample == 12) {\n              result[idx++] = ((bytes[1] & 0xF) << 8) + bytes[0];\n              result[idx++] = 16 * bytes[2] + (bytes[1] >> 4);\n              result[idx++] = ((bytes[4] & 0xF) << 8) + bytes[3];\n              result[idx++] = 16 * bytes[5] + (bytes[4] >> 4);\n              result[idx++] = ((bytes[7] & 0xF) << 8) + bytes[6];\n              result[idx++] = 16 * bytes[8] + (bytes[7] >> 4);\n              result[idx++] = ((bytes[10] & 0xF) << 8) + bytes[9];\n              result[idx++] = 16 * bytes[11] + (bytes[10] >> 4);\n              result[idx++] = ((bytes[13] & 0xF) << 8) + bytes[12];\n              result[idx++] = 16 * bytes[14] + (bytes[13] >> 4);\n            } else if (bitsPerSample == 14) {\n              result[idx++] = bytes[0] + ((bytes[1] & 0x3F) << 8);\n              result[idx++] = (bytes[1] >> 6) + 4 * bytes[2] + ((bytes[3] & 0xF) << 10);\n              result[idx++] = (bytes[3] >> 4) + 16 * bytes[4] + ((bytes[5] & 3) << 12);\n              result[idx++] = ((bytes[5] & 0xFC) >> 2) + (bytes[6] << 6);\n              result[idx++] = bytes[7] + ((bytes[8] & 0x3F) << 8);\n              result[idx++] = (bytes[8] >> 6) + 4 * bytes[9] + ((bytes[10] & 0xF) << 10);\n              result[idx++] = (bytes[10] >> 4) + 16 * bytes[11] + ((bytes[12] & 3) << 12);\n              result[idx++] = ((bytes[12] & 0xFC) >> 2) + (bytes[13] << 6);\n              result[idx++] = bytes[14] + ((bytes[15] & 0x3F) << 8);\n            }\n          }\n        }\n        //console.log(result[1000000 - 1])\n      } else if (RW2_Format == 4) {\n        for (row = 0; row < rawHeight; row++) {\n          for (col = 0; col < rawWidth; col++) {\n            i = col % 14;\n            isOdd = i & 1;\n            if (i == 0) resetPredNonzeros();\n            if (i % 3 == 2) sh = 4 >> 3 - getDataRaw(2);\n            if (nonz[isOdd]) {\n              j = getDataRaw(8);\n              if (j != 0) {\n                pred[isOdd] -= 0x80 << sh;\n                if (pred[isOdd] < 0 || sh == 4) pred[isOdd] &= ~(-1 << sh);\n                pred[isOdd] += j << sh;\n              }\n            } else {\n              nonz[isOdd] = getDataRaw(8);\n              if (nonz[isOdd] || i > 11) pred[isOdd] = nonz[isOdd] << 4 | getDataRaw(4);\n            }\n            result[idx++] = pred[col & 1];\n          }\n        }\n      } else throw RW2_Format;\n    };\n    UTIF.decode._decodeVC5 = function () {\n      var x = [1, 0, 1, 0, 2, 2, 1, 1, 3, 7, 1, 2, 5, 25, 1, 3, 6, 48, 1, 4, 6, 54, 1, 5, 7, 111, 1, 8, 7, 99, 1, 6, 7, 105, 12, 0, 7, 107, 1, 7, 8, 209, 20, 0, 8, 212, 1, 9, 8, 220, 1, 10, 9, 393, 1, 11, 9, 394, 32, 0, 9, 416, 1, 12, 9, 427, 1, 13, 10, 887, 1, 18, 10, 784, 1, 14, 10, 790, 1, 15, 10, 835, 60, 0, 10, 852, 1, 16, 10, 885, 1, 17, 11, 1571, 1, 19, 11, 1668, 1, 20, 11, 1669, 100, 0, 11, 1707, 1, 21, 11, 1772, 1, 22, 12, 3547, 1, 29, 12, 3164, 1, 24, 12, 3166, 1, 25, 12, 3140, 1, 23, 12, 3413, 1, 26, 12, 3537, 1, 27, 12, 3539, 1, 28, 13, 7093, 1, 35, 13, 6283, 1, 30, 13, 6331, 1, 31, 13, 6335, 180, 0, 13, 6824, 1, 32, 13, 7072, 1, 33, 13, 7077, 320, 0, 13, 7076, 1, 34, 14, 12565, 1, 36, 14, 12661, 1, 37, 14, 12669, 1, 38, 14, 13651, 1, 39, 14, 14184, 1, 40, 15, 28295, 1, 46, 15, 28371, 1, 47, 15, 25320, 1, 42, 15, 25336, 1, 43, 15, 25128, 1, 41, 15, 27300, 1, 44, 15, 28293, 1, 45, 16, 50259, 1, 48, 16, 50643, 1, 49, 16, 50675, 1, 50, 16, 56740, 1, 53, 16, 56584, 1, 51, 16, 56588, 1, 52, 17, 113483, 1, 61, 17, 113482, 1, 60, 17, 101285, 1, 55, 17, 101349, 1, 56, 17, 109205, 1, 57, 17, 109207, 1, 58, 17, 100516, 1, 54, 17, 113171, 1, 59, 18, 202568, 1, 62, 18, 202696, 1, 63, 18, 218408, 1, 64, 18, 218412, 1, 65, 18, 226340, 1, 66, 18, 226356, 1, 67, 18, 226358, 1, 68, 19, 402068, 1, 69, 19, 405138, 1, 70, 19, 405394, 1, 71, 19, 436818, 1, 72, 19, 436826, 1, 73, 19, 452714, 1, 75, 19, 452718, 1, 76, 19, 452682, 1, 74, 20, 804138, 1, 77, 20, 810279, 1, 78, 20, 810790, 1, 79, 20, 873638, 1, 80, 20, 873654, 1, 81, 20, 905366, 1, 82, 20, 905430, 1, 83, 20, 905438, 1, 84, 21, 1608278, 1, 85, 21, 1620557, 1, 86, 21, 1621582, 1, 87, 21, 1621583, 1, 88, 21, 1747310, 1, 89, 21, 1810734, 1, 90, 21, 1810735, 1, 91, 21, 1810863, 1, 92, 21, 1810879, 1, 93, 22, 3621725, 1, 99, 22, 3621757, 1, 100, 22, 3241112, 1, 94, 22, 3494556, 1, 95, 22, 3494557, 1, 96, 22, 3494622, 1, 97, 22, 3494623, 1, 98, 23, 6482227, 1, 102, 23, 6433117, 1, 101, 23, 6989117, 1, 103, 23, 6989119, 1, 105, 23, 6989118, 1, 104, 23, 7243449, 1, 106, 23, 7243512, 1, 107, 24, 13978233, 1, 111, 24, 12964453, 1, 109, 24, 12866232, 1, 108, 24, 14486897, 1, 113, 24, 13978232, 1, 110, 24, 14486896, 1, 112, 24, 14487026, 1, 114, 24, 14487027, 1, 115, 25, 25732598, 1, 225, 25, 25732597, 1, 189, 25, 25732596, 1, 188, 25, 25732595, 1, 203, 25, 25732594, 1, 202, 25, 25732593, 1, 197, 25, 25732592, 1, 207, 25, 25732591, 1, 169, 25, 25732590, 1, 223, 25, 25732589, 1, 159, 25, 25732522, 1, 235, 25, 25732579, 1, 152, 25, 25732575, 1, 192, 25, 25732489, 1, 179, 25, 25732573, 1, 201, 25, 25732472, 1, 172, 25, 25732576, 1, 149, 25, 25732488, 1, 178, 25, 25732566, 1, 120, 25, 25732571, 1, 219, 25, 25732577, 1, 150, 25, 25732487, 1, 127, 25, 25732506, 1, 211, 25, 25732548, 1, 125, 25, 25732588, 1, 158, 25, 25732486, 1, 247, 25, 25732467, 1, 238, 25, 25732508, 1, 163, 25, 25732552, 1, 228, 25, 25732603, 1, 183, 25, 25732513, 1, 217, 25, 25732587, 1, 168, 25, 25732520, 1, 122, 25, 25732484, 1, 128, 25, 25732562, 1, 249, 25, 25732505, 1, 187, 25, 25732504, 1, 186, 25, 25732483, 1, 136, 25, 25928905, 1, 181, 25, 25732560, 1, 255, 25, 25732500, 1, 230, 25, 25732482, 1, 135, 25, 25732555, 1, 233, 25, 25732568, 1, 222, 25, 25732583, 1, 145, 25, 25732481, 1, 134, 25, 25732586, 1, 167, 25, 25732521, 1, 248, 25, 25732518, 1, 209, 25, 25732480, 1, 243, 25, 25732512, 1, 216, 25, 25732509, 1, 164, 25, 25732547, 1, 140, 25, 25732479, 1, 157, 25, 25732544, 1, 239, 25, 25732574, 1, 191, 25, 25732564, 1, 251, 25, 25732478, 1, 156, 25, 25732546, 1, 139, 25, 25732498, 1, 242, 25, 25732557, 1, 133, 25, 25732477, 1, 162, 25, 25732515, 1, 213, 25, 25732584, 1, 165, 25, 25732514, 1, 212, 25, 25732476, 1, 227, 25, 25732494, 1, 198, 25, 25732531, 1, 236, 25, 25732530, 1, 234, 25, 25732529, 1, 117, 25, 25732528, 1, 215, 25, 25732527, 1, 124, 25, 25732526, 1, 123, 25, 25732525, 1, 254, 25, 25732524, 1, 253, 25, 25732523, 1, 148, 25, 25732570, 1, 218, 25, 25732580, 1, 146, 25, 25732581, 1, 147, 25, 25732569, 1, 224, 25, 25732533, 1, 143, 25, 25732540, 1, 184, 25, 25732541, 1, 185, 25, 25732585, 1, 166, 25, 25732556, 1, 132, 25, 25732485, 1, 129, 25, 25732563, 1, 250, 25, 25732578, 1, 151, 25, 25732501, 1, 119, 25, 25732502, 1, 193, 25, 25732536, 1, 176, 25, 25732496, 1, 245, 25, 25732553, 1, 229, 25, 25732516, 1, 206, 25, 25732582, 1, 144, 25, 25732517, 1, 208, 25, 25732558, 1, 137, 25, 25732543, 1, 241, 25, 25732466, 1, 237, 25, 25732507, 1, 190, 25, 25732542, 1, 240, 25, 25732551, 1, 131, 25, 25732554, 1, 232, 25, 25732565, 1, 252, 25, 25732475, 1, 171, 25, 25732493, 1, 205, 25, 25732492, 1, 204, 25, 25732491, 1, 118, 25, 25732490, 1, 214, 25, 25928904, 1, 180, 25, 25732549, 1, 126, 25, 25732602, 1, 182, 25, 25732539, 1, 175, 25, 25732545, 1, 141, 25, 25732559, 1, 138, 25, 25732537, 1, 177, 25, 25732534, 1, 153, 25, 25732503, 1, 194, 25, 25732606, 1, 160, 25, 25732567, 1, 121, 25, 25732538, 1, 174, 25, 25732497, 1, 246, 25, 25732550, 1, 130, 25, 25732572, 1, 200, 25, 25732474, 1, 170, 25, 25732511, 1, 221, 25, 25732601, 1, 196, 25, 25732532, 1, 142, 25, 25732519, 1, 210, 25, 25732495, 1, 199, 25, 25732605, 1, 155, 25, 25732535, 1, 154, 25, 25732499, 1, 244, 25, 25732510, 1, 220, 25, 25732600, 1, 195, 25, 25732607, 1, 161, 25, 25732604, 1, 231, 25, 25732473, 1, 173, 25, 25732599, 1, 226, 26, 51465122, 1, 116, 26, 51465123, 0, 1],\n        o,\n        C,\n        k,\n        P = [3, 3, 3, 3, 2, 2, 2, 1, 1, 1],\n        V = 24576,\n        ar = 16384,\n        H = 8192,\n        az = ar | H;\n      function d(t) {\n        var E = t[1],\n          h = t[0][E >>> 3] >>> 7 - (E & 7) & 1;\n        t[1]++;\n        return h;\n      }\n      function ag(t, E) {\n        if (o == null) {\n          o = {};\n          for (var h = 0; h < x.length; h += 4) o[x[h + 1]] = x.slice(h, h + 4);\n        }\n        var L = d(t),\n          g = o[L];\n        while (g == null) {\n          L = L << 1 | d(t);\n          g = o[L];\n        }\n        var n = g[3];\n        if (n != 0) n = d(t) == 0 ? n : -n;\n        E[0] = g[2];\n        E[1] = n;\n      }\n      function m(t, E) {\n        for (var h = 0; h < E; h++) {\n          if ((t & 1) == 1) t++;\n          t = t >>> 1;\n        }\n        return t;\n      }\n      function A(t, E) {\n        return t >> E;\n      }\n      function O(t, E, h, L, g, n) {\n        E[h] = A(A(11 * t[g] - 4 * t[g + n] + t[g + n + n] + 4, 3) + t[L], 1);\n        E[h + n] = A(A(5 * t[g] + 4 * t[g + n] - t[g + n + n] + 4, 3) - t[L], 1);\n      }\n      function J(t, E, h, L, g, n) {\n        var W = t[g - n] - t[g + n],\n          j = t[g],\n          $ = t[L];\n        E[h] = A(A(W + 4, 3) + j + $, 1);\n        E[h + n] = A(A(-W + 4, 3) + j - $, 1);\n      }\n      function y(t, E, h, L, g, n) {\n        E[h] = A(A(5 * t[g] + 4 * t[g - n] - t[g - n - n] + 4, 3) + t[L], 1);\n        E[h + n] = A(A(11 * t[g] - 4 * t[g - n] + t[g - n - n] + 4, 3) - t[L], 1);\n      }\n      function q(t) {\n        t = t < 0 ? 0 : t > 4095 ? 4095 : t;\n        t = k[t] >>> 2;\n        return t;\n      }\n      function av(t, E, h, L, g, n) {\n        L = new Uint16Array(L.buffer);\n        var W = Date.now(),\n          j = UTIF._binBE,\n          $ = E + h,\n          r,\n          u,\n          X,\n          I,\n          ax,\n          a3,\n          R,\n          ai,\n          aa,\n          ap,\n          ah,\n          ae,\n          aD,\n          al,\n          i,\n          aE,\n          T,\n          B;\n        E += 4;\n        var a5 = n[0] == 1;\n        while (E < $) {\n          var S = j.readShort(t, E),\n            s = j.readUshort(t, E + 2);\n          E += 4;\n          if (S == 12) r = s;else if (S == 20) u = s;else if (S == 21) X = s;else if (S == 48) I = s;else if (S == 53) ax = s;else if (S == 35) a3 = s;else if (S == 62) R = s;else if (S == 101) ai = s;else if (S == 109) aa = s;else if (S == 84) ap = s;else if (S == 106) ah = s;else if (S == 107) ae = s;else if (S == 108) aD = s;else if (S == 102) al = s;else if (S == 104) i = s;else if (S == 105) aE = s;else {\n            var F = S < 0 ? -S : S,\n              D = F & 65280,\n              _ = 0;\n            if (F & az) {\n              if (F & H) {\n                _ = s & 65535;\n                _ += (F & 255) << 16;\n              } else {\n                _ = s & 65535;\n              }\n            }\n            if ((F & V) == V) {\n              if (T == null) {\n                T = [];\n                for (var M = 0; M < 4; M++) T[M] = new Int16Array((u >>> 1) * (X >>> 1));\n                B = new Int16Array((u >>> 1) * (X >>> 1));\n                C = new Int16Array(1024);\n                for (var M = 0; M < 1024; M++) {\n                  var aG = M - 512,\n                    p = Math.abs(aG),\n                    r = Math.floor(768 * p * p * p / (255 * 255 * 255)) + p;\n                  C[M] = Math.sign(aG) * r;\n                }\n                k = new Uint16Array(4096);\n                var aA = (1 << 16) - 1;\n                for (var M = 0; M < 4096; M++) {\n                  var at = M,\n                    a1 = aA * (Math.pow(113, at / 4095) - 1) / 112;\n                  k[M] = Math.min(a1, aA);\n                }\n              }\n              var w = T[R],\n                v = m(u, 1 + P[I]),\n                N = m(X, 1 + P[I]);\n              if (I == 0) {\n                for (var b = 0; b < N; b++) for (var G = 0; G < v; G++) {\n                  var c = E + (b * v + G) * 2;\n                  w[b * (u >>> 1) + G] = t[c] << 8 | t[c + 1];\n                }\n              } else {\n                var a7 = [t, E * 8],\n                  a4 = [],\n                  ay = 0,\n                  aw = v * N,\n                  f = [0, 0],\n                  Q = 0,\n                  s = 0;\n                while (ay < aw) {\n                  ag(a7, f);\n                  Q = f[0];\n                  s = f[1];\n                  while (Q > 0) {\n                    a4[ay++] = s;\n                    Q--;\n                  }\n                }\n                var l = (I - 1) % 3,\n                  aF = l != 1 ? v : 0,\n                  a2 = l != 0 ? N : 0;\n                for (var b = 0; b < N; b++) {\n                  var af = (b + a2) * (u >>> 1) + aF,\n                    au = b * v;\n                  for (var G = 0; G < v; G++) w[af + G] = C[a4[au + G] + 512] * ax;\n                }\n                if (l == 2) {\n                  var i = u >>> 1,\n                    an = v * 2,\n                    a9 = N * 2;\n                  for (var b = 0; b < N; b++) {\n                    for (var G = 0; G < an; G++) {\n                      var M = b * 2 * i + G,\n                        a = b * i + G,\n                        e = N * i + a;\n                      if (b == 0) O(w, B, M, e, a, i);else if (b == N - 1) y(w, B, M, e, a, i);else J(w, B, M, e, a, i);\n                    }\n                  }\n                  var Z = w;\n                  w = B;\n                  B = Z;\n                  for (var b = 0; b < a9; b++) {\n                    for (var G = 0; G < v; G++) {\n                      var M = b * i + 2 * G,\n                        a = b * i + G,\n                        e = v + a;\n                      if (G == 0) O(w, B, M, e, a, 1);else if (G == v - 1) y(w, B, M, e, a, 1);else J(w, B, M, e, a, 1);\n                    }\n                  }\n                  var Z = w;\n                  w = B;\n                  B = Z;\n                  var aC = [],\n                    aB = 2 - ~~((I - 1) / 3);\n                  for (var K = 0; K < 3; K++) aC[K] = aa >> 14 - K * 2 & 3;\n                  var a6 = aC[aB];\n                  if (a6 != 0) for (var b = 0; b < a9; b++) for (var G = 0; G < an; G++) {\n                    var M = b * i + G;\n                    w[M] = w[M] << a6;\n                  }\n                }\n              }\n              if (I == 9 && R == 3) {\n                var a8 = T[0],\n                  ab = T[1],\n                  aq = T[2],\n                  as = T[3];\n                for (var b = 0; b < X; b += 2) for (var G = 0; G < u; G += 2) {\n                  var U = b * u + G,\n                    c = (b >>> 1) * (u >>> 1) + (G >>> 1),\n                    z = a8[c],\n                    ao = ab[c] - 2048,\n                    ak = aq[c] - 2048,\n                    ad = as[c] - 2048,\n                    aj = (ao << 1) + z,\n                    a0 = (ak << 1) + z,\n                    aH = z + ad,\n                    am = z - ad;\n                  if (a5) {\n                    L[U] = q(aH);\n                    L[U + 1] = q(a0);\n                    L[U + u] = q(aj);\n                    L[U + u + 1] = q(am);\n                  } else {\n                    L[U] = q(aj);\n                    L[U + 1] = q(aH);\n                    L[U + u] = q(am);\n                    L[U + u + 1] = q(a0);\n                  }\n                }\n              }\n              E += _ * 4;\n            } else if (F == 16388) {\n              E += _ * 4;\n            } else if (D == 8192 || D == 8448 || D == 9216) {} else throw F.toString(16);\n          }\n        }\n        console.log(Date.now() - W);\n      }\n      return av;\n    }();\n    UTIF.decode._decodeLogLuv32 = function (img, data, off, len, tgt, toff) {\n      var w = img.width,\n        qw = w * 4;\n      var io = 0,\n        out = new Uint8Array(qw);\n      while (io < len) {\n        var oo = 0;\n        while (oo < qw) {\n          var c = data[off + io];\n          io++;\n          if (c < 128) {\n            for (var j = 0; j < c; j++) out[oo + j] = data[off + io + j];\n            oo += c;\n            io += c;\n          } else {\n            c = c - 126;\n            for (var j = 0; j < c; j++) out[oo + j] = data[off + io];\n            oo += c;\n            io++;\n          }\n        }\n        for (var x = 0; x < w; x++) {\n          tgt[toff + 0] = out[x];\n          tgt[toff + 1] = out[x + w];\n          tgt[toff + 2] = out[x + w * 2];\n          tgt[toff + 4] = out[x + w * 3];\n          toff += 6;\n        }\n      }\n    };\n    UTIF.decode._ljpeg_diff = function (data, prm, huff) {\n      var getbithuff = UTIF.decode._getbithuff;\n      var len, diff;\n      len = getbithuff(data, prm, huff[0], huff);\n      diff = getbithuff(data, prm, len, 0);\n      if ((diff & 1 << len - 1) == 0) diff -= (1 << len) - 1;\n      return diff;\n    };\n    UTIF.decode._decodeARW = function (img, inp, off, src_length, tgt, toff) {\n      var raw_width = img[\"t256\"][0],\n        height = img[\"t257\"][0],\n        tiff_bps = img[\"t258\"][0];\n      var bin = img.isLE ? UTIF._binLE : UTIF._binBE;\n      //console.log(raw_width, height, tiff_bps, raw_width*height, src_length);\n      var arw2 = raw_width * height == src_length || raw_width * height * 1.5 == src_length;\n      //arw2 = true;\n      //console.log(\"ARW2: \", arw2, raw_width*height, src_length, tgt.length);\n      if (!arw2) {\n        //\"sony_arw_load_raw\"; // not arw2\n        height += 8;\n        var prm = [off, 0, 0, 0];\n        var huff = new Uint16Array(32770);\n        var tab = [0xf11, 0xf10, 0xe0f, 0xd0e, 0xc0d, 0xb0c, 0xa0b, 0x90a, 0x809, 0x708, 0x607, 0x506, 0x405, 0x304, 0x303, 0x300, 0x202, 0x201];\n        var i,\n          c,\n          n,\n          col,\n          row,\n          sum = 0;\n        var ljpeg_diff = UTIF.decode._ljpeg_diff;\n        huff[0] = 15;\n        for (n = i = 0; i < 18; i++) {\n          var lim = 32768 >>> (tab[i] >>> 8);\n          for (var c = 0; c < lim; c++) huff[++n] = tab[i];\n        }\n        for (col = raw_width; col--;) for (row = 0; row < height + 1; row += 2) {\n          if (row == height) row = 1;\n          sum += ljpeg_diff(inp, prm, huff);\n          if (row < height) {\n            var clr = sum & 4095;\n            UTIF.decode._putsF(tgt, (row * raw_width + col) * tiff_bps, clr << 16 - tiff_bps);\n          }\n        }\n        return;\n      }\n      if (raw_width * height * 1.5 == src_length) {\n        //console.log(\"weird compression\");\n        for (var i = 0; i < src_length; i += 3) {\n          var b0 = inp[off + i + 0],\n            b1 = inp[off + i + 1],\n            b2 = inp[off + i + 2];\n          tgt[toff + i] = b1 << 4 | b0 >>> 4;\n          tgt[toff + i + 1] = b0 << 4 | b2 >>> 4;\n          tgt[toff + i + 2] = b2 << 4 | b1 >>> 4;\n        }\n        return;\n      }\n      var pix = new Uint16Array(16);\n      var row, col, val, max, min, imax, imin, sh, bit, i, dp;\n      var data = new Uint8Array(raw_width + 1);\n      for (row = 0; row < height; row++) {\n        //fread (data, 1, raw_width, ifp);\n        for (var j = 0; j < raw_width; j++) data[j] = inp[off++];\n        for (dp = 0, col = 0; col < raw_width - 30; dp += 16) {\n          max = 0x7ff & (val = bin.readUint(data, dp));\n          min = 0x7ff & val >>> 11;\n          imax = 0x0f & val >>> 22;\n          imin = 0x0f & val >>> 26;\n          for (sh = 0; sh < 4 && 0x80 << sh <= max - min; sh++);\n          for (bit = 30, i = 0; i < 16; i++) if (i == imax) pix[i] = max;else if (i == imin) pix[i] = min;else {\n            pix[i] = ((bin.readUshort(data, dp + (bit >> 3)) >>> (bit & 7) & 0x7f) << sh) + min;\n            if (pix[i] > 0x7ff) pix[i] = 0x7ff;\n            bit += 7;\n          }\n          for (i = 0; i < 16; i++, col += 2) {\n            //RAW(row,col) = curve[pix[i] << 1] >> 2;\n            var clr = pix[i] << 1; //clr = 0xffff;\n            UTIF.decode._putsF(tgt, (row * raw_width + col) * tiff_bps, clr << 16 - tiff_bps);\n          }\n          col -= col & 1 ? 1 : 31;\n        }\n      }\n    };\n    UTIF.decode._decodeNikon = function (img, imgs, data, off, src_length, tgt, toff) {\n      var nikon_tree = [[0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0, 0, /* 12-bit lossy */\n      5, 4, 3, 6, 2, 7, 1, 0, 8, 9, 11, 10, 12], [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0, 0, /* 12-bit lossy after split */\n      0x39, 0x5a, 0x38, 0x27, 0x16, 5, 4, 3, 2, 1, 0, 11, 12, 12], [0, 0, 1, 4, 2, 3, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 12-bit lossless */\n      5, 4, 6, 3, 7, 2, 8, 1, 9, 0, 10, 11, 12], [0, 0, 1, 4, 3, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0, 0, /* 14-bit lossy */\n      5, 6, 4, 7, 8, 3, 9, 2, 1, 0, 10, 11, 12, 13, 14], [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0, /* 14-bit lossy after split */\n      8, 0x5c, 0x4b, 0x3a, 0x29, 7, 6, 5, 4, 3, 2, 1, 0, 13, 14], [0, 0, 1, 4, 2, 2, 3, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, /* 14-bit lossless */\n      7, 6, 8, 5, 9, 4, 10, 3, 11, 12, 2, 0, 1, 13, 14]];\n      var raw_width = img[\"t256\"][0],\n        height = img[\"t257\"][0],\n        tiff_bps = img[\"t258\"][0];\n      var tree = 0,\n        split = 0;\n      var make_decoder = UTIF.decode._make_decoder;\n      var getbithuff = UTIF.decode._getbithuff;\n      var mn = imgs[0].exifIFD.makerNote,\n        md = mn[\"t150\"] ? mn[\"t150\"] : mn[\"t140\"],\n        mdo = 0; //console.log(mn,md);\n      //console.log(md[0].toString(16), md[1].toString(16), tiff_bps);\n      var ver0 = md[mdo++],\n        ver1 = md[mdo++];\n      if (ver0 == 0x49 || ver1 == 0x58) mdo += 2110;\n      if (ver0 == 0x46) tree = 2;\n      if (tiff_bps == 14) tree += 3;\n      var vpred = [[0, 0], [0, 0]],\n        bin = img.isLE ? UTIF._binLE : UTIF._binBE;\n      for (var i = 0; i < 2; i++) for (var j = 0; j < 2; j++) {\n        vpred[i][j] = bin.readShort(md, mdo);\n        mdo += 2;\n      } // not sure here ... [i][j] or [j][i]\n      //console.log(vpred);\n\n      var max = 1 << tiff_bps & 0x7fff,\n        step = 0;\n      var csize = bin.readShort(md, mdo);\n      mdo += 2;\n      if (csize > 1) step = Math.floor(max / (csize - 1));\n      if (ver0 == 0x44 && ver1 == 0x20 && step > 0) split = bin.readShort(md, 562);\n      var i;\n      var row, col;\n      var len, shl, diff;\n      var min_v = 0;\n      var hpred = [0, 0];\n      var huff = make_decoder(nikon_tree[tree]);\n\n      //var g_input_offset=0, bitbuf=0, vbits=0, reset=0;\n      var prm = [off, 0, 0, 0];\n      //console.log(split);  split = 170;\n\n      for (min_v = row = 0; row < height; row++) {\n        if (split && row == split) {\n          //free (huff);\n          huff = make_decoder(nikon_tree[tree + 1]);\n          //max_v += (min_v = 16) << 1;\n        }\n        for (col = 0; col < raw_width; col++) {\n          i = getbithuff(data, prm, huff[0], huff);\n          len = i & 15;\n          shl = i >>> 4;\n          diff = (getbithuff(data, prm, len - shl, 0) << 1) + 1 << shl >>> 1;\n          if ((diff & 1 << len - 1) == 0) diff -= (1 << len) - (shl == 0 ? 1 : 0);\n          if (col < 2) hpred[col] = vpred[row & 1][col] += diff;else hpred[col & 1] += diff;\n          var clr = Math.min(Math.max(hpred[col & 1], 0), (1 << tiff_bps) - 1);\n          var bti = (row * raw_width + col) * tiff_bps;\n          UTIF.decode._putsF(tgt, bti, clr << 16 - tiff_bps);\n        }\n      }\n    };\n    // put 16 bits\n    UTIF.decode._putsF = function (dt, pos, val) {\n      val = val << 8 - (pos & 7);\n      var o = pos >>> 3;\n      dt[o] |= val >>> 16;\n      dt[o + 1] |= val >>> 8;\n      dt[o + 2] |= val;\n    };\n    UTIF.decode._getbithuff = function (data, prm, nbits, huff) {\n      var zero_after_ff = 0;\n      var get_byte = UTIF.decode._get_byte;\n      var c;\n      var off = prm[0],\n        bitbuf = prm[1],\n        vbits = prm[2],\n        reset = prm[3];\n\n      //if (nbits > 25) return 0;\n      //if (nbits <  0) return bitbuf = vbits = reset = 0;\n      if (nbits == 0 || vbits < 0) return 0;\n      while (!reset && vbits < nbits && (c = data[off++]) != -1 && !(reset = zero_after_ff && c == 0xff && data[off++])) {\n        //console.log(\"byte read into c\");\n        bitbuf = (bitbuf << 8) + c;\n        vbits += 8;\n      }\n      c = bitbuf << 32 - vbits >>> 32 - nbits;\n      if (huff) {\n        vbits -= huff[c + 1] >>> 8; //console.log(c, huff[c]>>8);\n        c = huff[c + 1] & 255;\n      } else vbits -= nbits;\n      if (vbits < 0) throw \"e\";\n      prm[0] = off;\n      prm[1] = bitbuf;\n      prm[2] = vbits;\n      prm[3] = reset;\n      return c;\n    };\n    UTIF.decode._make_decoder = function (source) {\n      var max, len, h, i, j;\n      var huff = [];\n      for (max = 16; max != 0 && !source[max]; max--);\n      var si = 17;\n      huff[0] = max;\n      for (h = len = 1; len <= max; len++) for (i = 0; i < source[len]; i++, ++si) for (j = 0; j < 1 << max - len; j++) if (h <= 1 << max) huff[h++] = len << 8 | source[si];\n      return huff;\n    };\n    UTIF.decode._decodeNewJPEG = function (img, data, off, len, tgt, toff) {\n      len = Math.min(len, data.length - off);\n      var tables = img[\"t347\"],\n        tlen = tables ? tables.length : 0,\n        buff = new Uint8Array(tlen + len);\n      if (tables) {\n        var SOI = 216,\n          EOI = 217,\n          boff = 0;\n        for (var i = 0; i < tlen - 1; i++) {\n          // Skip EOI marker from JPEGTables\n          if (tables[i] == 255 && tables[i + 1] == EOI) break;\n          buff[boff++] = tables[i];\n        }\n\n        // Skip SOI marker from data\n        var byte1 = data[off],\n          byte2 = data[off + 1];\n        if (byte1 != 255 || byte2 != SOI) {\n          buff[boff++] = byte1;\n          buff[boff++] = byte2;\n        }\n        for (var i = 2; i < len; i++) buff[boff++] = data[off + i];\n      } else for (var i = 0; i < len; i++) buff[i] = data[off + i];\n      if (img[\"t262\"][0] == 32803 || img[\"t259\"][0] == 7 && img[\"t262\"][0] == 34892)\n        // lossless JPEG (used in DNG files)\n        {\n          var bps = img[\"t258\"][0]; //, dcdr = new LosslessJpegDecoder();\n          //var time = Date.now();\n          var out = UTIF.LosslessJpegDecode(buff),\n            olen = out.length; //console.log(olen);\n          //var out = ULLJPG(buff), olen=out.length;  //console.log(olen);\n          //console.log(Date.now()-time);\n\n          if (false) {} else if (bps == 16) {\n            if (img.isLE) for (var i = 0; i < olen; i++) {\n              tgt[toff + (i << 1)] = out[i] & 255;\n              tgt[toff + (i << 1) + 1] = out[i] >>> 8;\n            } else for (var i = 0; i < olen; i++) {\n              tgt[toff + (i << 1)] = out[i] >>> 8;\n              tgt[toff + (i << 1) + 1] = out[i] & 255;\n            }\n          } else if (bps == 14 || bps == 12 || bps == 10) {\n            // 4 * 14 == 56 == 7 * 8\n            var rst = 16 - bps;\n            for (var i = 0; i < olen; i++) UTIF.decode._putsF(tgt, i * bps, out[i] << rst);\n          } else if (bps == 8) {\n            for (var i = 0; i < olen; i++) tgt[toff + i] = out[i];\n          } else throw new Error(\"unsupported bit depth \" + bps);\n        } else {\n        var parser = new UTIF.JpegDecoder();\n        parser.parse(buff);\n        var decoded = parser.getData({\n          \"width\": parser.width,\n          \"height\": parser.height,\n          \"forceRGB\": true,\n          \"isSourcePDF\": false\n        });\n        for (var i = 0; i < decoded.length; i++) tgt[toff + i] = decoded[i];\n      }\n\n      // PhotometricInterpretation is 6 (YCbCr) for JPEG, but after decoding we populate data in\n      // RGB format, so updating the tag value\n      if (img[\"t262\"][0] == 6) img[\"t262\"][0] = 2;\n    };\n    UTIF.decode._decodeOldJPEGInit = function (img, data, off, len) {\n      var SOI = 216,\n        EOI = 217,\n        DQT = 219,\n        DHT = 196,\n        DRI = 221,\n        SOF0 = 192,\n        SOS = 218;\n      var joff = 0,\n        soff = 0,\n        tables,\n        sosMarker,\n        isTiled = false,\n        i,\n        j,\n        k;\n      var jpgIchgFmt = img[\"t513\"],\n        jifoff = jpgIchgFmt ? jpgIchgFmt[0] : 0;\n      var jpgIchgFmtLen = img[\"t514\"],\n        jiflen = jpgIchgFmtLen ? jpgIchgFmtLen[0] : 0;\n      var soffTag = img[\"t324\"] || img[\"t273\"] || jpgIchgFmt;\n      var ycbcrss = img[\"t530\"],\n        ssx = 0,\n        ssy = 0;\n      var spp = img[\"t277\"] ? img[\"t277\"][0] : 1;\n      var jpgresint = img[\"t515\"];\n      if (soffTag) {\n        soff = soffTag[0];\n        isTiled = soffTag.length > 1;\n      }\n      if (!isTiled) {\n        if (data[off] == 255 && data[off + 1] == SOI) return {\n          jpegOffset: off\n        };\n        if (jpgIchgFmt != null) {\n          if (data[off + jifoff] == 255 && data[off + jifoff + 1] == SOI) joff = off + jifoff;else log(\"JPEGInterchangeFormat does not point to SOI\");\n          if (jpgIchgFmtLen == null) log(\"JPEGInterchangeFormatLength field is missing\");else if (jifoff >= soff || jifoff + jiflen <= soff) log(\"JPEGInterchangeFormatLength field value is invalid\");\n          if (joff != null) return {\n            jpegOffset: joff\n          };\n        }\n      }\n      if (ycbcrss != null) {\n        ssx = ycbcrss[0];\n        ssy = ycbcrss[1];\n      }\n      if (jpgIchgFmt != null) if (jpgIchgFmtLen != null) if (jiflen >= 2 && jifoff + jiflen <= soff) {\n        if (data[off + jifoff + jiflen - 2] == 255 && data[off + jifoff + jiflen - 1] == SOI) tables = new Uint8Array(jiflen - 2);else tables = new Uint8Array(jiflen);\n        for (i = 0; i < tables.length; i++) tables[i] = data[off + jifoff + i];\n        log(\"Incorrect JPEG interchange format: using JPEGInterchangeFormat offset to derive tables\");\n      } else log(\"JPEGInterchangeFormat+JPEGInterchangeFormatLength > offset to first strip or tile\");\n      if (tables == null) {\n        var ooff = 0,\n          out = [];\n        out[ooff++] = 255;\n        out[ooff++] = SOI;\n        var qtables = img[\"t519\"];\n        if (qtables == null) throw new Error(\"JPEGQTables tag is missing\");\n        for (i = 0; i < qtables.length; i++) {\n          out[ooff++] = 255;\n          out[ooff++] = DQT;\n          out[ooff++] = 0;\n          out[ooff++] = 67;\n          out[ooff++] = i;\n          for (j = 0; j < 64; j++) out[ooff++] = data[off + qtables[i] + j];\n        }\n        for (k = 0; k < 2; k++) {\n          var htables = img[k == 0 ? \"t520\" : \"t521\"];\n          if (htables == null) throw new Error((k == 0 ? \"JPEGDCTables\" : \"JPEGACTables\") + \" tag is missing\");\n          for (i = 0; i < htables.length; i++) {\n            out[ooff++] = 255;\n            out[ooff++] = DHT;\n            //out[ooff++] = 0; out[ooff++] = 67; out[ooff++] = i;\n            var nc = 19;\n            for (j = 0; j < 16; j++) nc += data[off + htables[i] + j];\n            out[ooff++] = nc >>> 8;\n            out[ooff++] = nc & 255;\n            out[ooff++] = i | k << 4;\n            for (j = 0; j < 16; j++) out[ooff++] = data[off + htables[i] + j];\n            for (j = 0; j < nc; j++) out[ooff++] = data[off + htables[i] + 16 + j];\n          }\n        }\n        out[ooff++] = 255;\n        out[ooff++] = SOF0;\n        out[ooff++] = 0;\n        out[ooff++] = 8 + 3 * spp;\n        out[ooff++] = 8;\n        out[ooff++] = img.height >>> 8 & 255;\n        out[ooff++] = img.height & 255;\n        out[ooff++] = img.width >>> 8 & 255;\n        out[ooff++] = img.width & 255;\n        out[ooff++] = spp;\n        if (spp == 1) {\n          out[ooff++] = 1;\n          out[ooff++] = 17;\n          out[ooff++] = 0;\n        } else for (i = 0; i < 3; i++) {\n          out[ooff++] = i + 1;\n          out[ooff++] = i != 0 ? 17 : (ssx & 15) << 4 | ssy & 15;\n          out[ooff++] = i;\n        }\n        if (jpgresint != null && jpgresint[0] != 0) {\n          out[ooff++] = 255;\n          out[ooff++] = DRI;\n          out[ooff++] = 0;\n          out[ooff++] = 4;\n          out[ooff++] = jpgresint[0] >>> 8 & 255;\n          out[ooff++] = jpgresint[0] & 255;\n        }\n        tables = new Uint8Array(out);\n      }\n      var sofpos = -1;\n      i = 0;\n      while (i < tables.length - 1) {\n        if (tables[i] == 255 && tables[i + 1] == SOF0) {\n          sofpos = i;\n          break;\n        }\n        i++;\n      }\n      if (sofpos == -1) {\n        var tmptab = new Uint8Array(tables.length + 10 + 3 * spp);\n        tmptab.set(tables);\n        var tmpoff = tables.length;\n        sofpos = tables.length;\n        tables = tmptab;\n        tables[tmpoff++] = 255;\n        tables[tmpoff++] = SOF0;\n        tables[tmpoff++] = 0;\n        tables[tmpoff++] = 8 + 3 * spp;\n        tables[tmpoff++] = 8;\n        tables[tmpoff++] = img.height >>> 8 & 255;\n        tables[tmpoff++] = img.height & 255;\n        tables[tmpoff++] = img.width >>> 8 & 255;\n        tables[tmpoff++] = img.width & 255;\n        tables[tmpoff++] = spp;\n        if (spp == 1) {\n          tables[tmpoff++] = 1;\n          tables[tmpoff++] = 17;\n          tables[tmpoff++] = 0;\n        } else for (i = 0; i < 3; i++) {\n          tables[tmpoff++] = i + 1;\n          tables[tmpoff++] = i != 0 ? 17 : (ssx & 15) << 4 | ssy & 15;\n          tables[tmpoff++] = i;\n        }\n      }\n      if (data[soff] == 255 && data[soff + 1] == SOS) {\n        var soslen = data[soff + 2] << 8 | data[soff + 3];\n        sosMarker = new Uint8Array(soslen + 2);\n        sosMarker[0] = data[soff];\n        sosMarker[1] = data[soff + 1];\n        sosMarker[2] = data[soff + 2];\n        sosMarker[3] = data[soff + 3];\n        for (i = 0; i < soslen - 2; i++) sosMarker[i + 4] = data[soff + i + 4];\n      } else {\n        sosMarker = new Uint8Array(2 + 6 + 2 * spp);\n        var sosoff = 0;\n        sosMarker[sosoff++] = 255;\n        sosMarker[sosoff++] = SOS;\n        sosMarker[sosoff++] = 0;\n        sosMarker[sosoff++] = 6 + 2 * spp;\n        sosMarker[sosoff++] = spp;\n        if (spp == 1) {\n          sosMarker[sosoff++] = 1;\n          sosMarker[sosoff++] = 0;\n        } else for (i = 0; i < 3; i++) {\n          sosMarker[sosoff++] = i + 1;\n          sosMarker[sosoff++] = i << 4 | i;\n        }\n        sosMarker[sosoff++] = 0;\n        sosMarker[sosoff++] = 63;\n        sosMarker[sosoff++] = 0;\n      }\n      return {\n        jpegOffset: off,\n        tables: tables,\n        sosMarker: sosMarker,\n        sofPosition: sofpos\n      };\n    };\n    UTIF.decode._decodeOldJPEG = function (img, data, off, len, tgt, toff) {\n      var i, dlen, tlen, buff, buffoff;\n      var jpegData = UTIF.decode._decodeOldJPEGInit(img, data, off, len);\n      if (jpegData.jpegOffset != null) {\n        dlen = off + len - jpegData.jpegOffset;\n        buff = new Uint8Array(dlen);\n        for (i = 0; i < dlen; i++) buff[i] = data[jpegData.jpegOffset + i];\n      } else {\n        tlen = jpegData.tables.length;\n        buff = new Uint8Array(tlen + jpegData.sosMarker.length + len + 2);\n        buff.set(jpegData.tables);\n        buffoff = tlen;\n        buff[jpegData.sofPosition + 5] = img.height >>> 8 & 255;\n        buff[jpegData.sofPosition + 6] = img.height & 255;\n        buff[jpegData.sofPosition + 7] = img.width >>> 8 & 255;\n        buff[jpegData.sofPosition + 8] = img.width & 255;\n        if (data[off] != 255 || data[off + 1] != SOS) {\n          buff.set(jpegData.sosMarker, buffoff);\n          buffoff += sosMarker.length;\n        }\n        for (i = 0; i < len; i++) buff[buffoff++] = data[off + i];\n        buff[buffoff++] = 255;\n        buff[buffoff++] = EOI;\n      }\n      var parser = new UTIF.JpegDecoder();\n      parser.parse(buff);\n      var decoded = parser.getData({\n        \"width\": parser.width,\n        \"height\": parser.height,\n        \"forceRGB\": true,\n        \"isSourcePDF\": false\n      });\n      for (var i = 0; i < decoded.length; i++) tgt[toff + i] = decoded[i];\n\n      // PhotometricInterpretation is 6 (YCbCr) for JPEG, but after decoding we populate data in\n      // RGB format, so updating the tag value\n      if (img[\"t262\"] && img[\"t262\"][0] == 6) img[\"t262\"][0] = 2;\n    };\n    UTIF.decode._decodePackBits = function (data, off, len, tgt, toff) {\n      var sa = new Int8Array(data.buffer),\n        ta = new Int8Array(tgt.buffer),\n        lim = off + len;\n      while (off < lim) {\n        var n = sa[off];\n        off++;\n        if (n >= 0 && n < 128) for (var i = 0; i < n + 1; i++) {\n          ta[toff] = sa[off];\n          toff++;\n          off++;\n        }\n        if (n >= -127 && n < 0) {\n          for (var i = 0; i < -n + 1; i++) {\n            ta[toff] = sa[off];\n            toff++;\n          }\n          off++;\n        }\n      }\n      return toff;\n    };\n    UTIF.decode._decodeThunder = function (data, off, len, tgt, toff) {\n      var d2 = [0, 1, 0, -1],\n        d3 = [0, 1, 2, 3, 0, -3, -2, -1];\n      var lim = off + len,\n        qoff = toff * 2,\n        px = 0;\n      while (off < lim) {\n        var b = data[off],\n          msk = b >>> 6,\n          n = b & 63;\n        off++;\n        if (msk == 3) {\n          px = n & 15;\n          tgt[qoff >>> 1] |= px << 4 * (1 - qoff & 1);\n          qoff++;\n        }\n        if (msk == 0) for (var i = 0; i < n; i++) {\n          tgt[qoff >>> 1] |= px << 4 * (1 - qoff & 1);\n          qoff++;\n        }\n        if (msk == 2) for (var i = 0; i < 2; i++) {\n          var d = n >>> 3 * (1 - i) & 7;\n          if (d != 4) {\n            px += d3[d];\n            tgt[qoff >>> 1] |= px << 4 * (1 - qoff & 1);\n            qoff++;\n          }\n        }\n        if (msk == 1) for (var i = 0; i < 3; i++) {\n          var d = n >>> 2 * (2 - i) & 3;\n          if (d != 2) {\n            px += d2[d];\n            tgt[qoff >>> 1] |= px << 4 * (1 - qoff & 1);\n            qoff++;\n          }\n        }\n      }\n    };\n    UTIF.decode._dmap = {\n      \"1\": 0,\n      \"011\": 1,\n      \"000011\": 2,\n      \"0000011\": 3,\n      \"010\": -1,\n      \"000010\": -2,\n      \"0000010\": -3\n    };\n    UTIF.decode._lens = function () {\n      var addKeys = function addKeys(lens, arr, i0, inc) {\n        for (var i = 0; i < arr.length; i++) lens[arr[i]] = i0 + i * inc;\n      };\n      var termW = \"00110101,000111,0111,1000,1011,1100,1110,1111,10011,10100,00111,01000,001000,000011,110100,110101,\" // 15\n      + \"101010,101011,0100111,0001100,0001000,0010111,0000011,0000100,0101000,0101011,0010011,0100100,0011000,00000010,00000011,00011010,\" // 31\n      + \"00011011,00010010,00010011,00010100,00010101,00010110,00010111,00101000,00101001,00101010,00101011,00101100,00101101,00000100,00000101,00001010,\" // 47\n      + \"00001011,01010010,01010011,01010100,01010101,00100100,00100101,01011000,01011001,01011010,01011011,01001010,01001011,00110010,00110011,00110100\";\n      var termB = \"0000110111,010,11,10,011,0011,0010,00011,000101,000100,0000100,0000101,0000111,00000100,00000111,000011000,\" // 15\n      + \"0000010111,0000011000,0000001000,00001100111,00001101000,00001101100,00000110111,00000101000,00000010111,00000011000,000011001010,000011001011,000011001100,000011001101,000001101000,000001101001,\" // 31\n      + \"000001101010,000001101011,000011010010,000011010011,000011010100,000011010101,000011010110,000011010111,000001101100,000001101101,000011011010,000011011011,000001010100,000001010101,000001010110,000001010111,\" // 47\n      + \"000001100100,000001100101,000001010010,000001010011,000000100100,000000110111,000000111000,000000100111,000000101000,000001011000,000001011001,000000101011,000000101100,000001011010,000001100110,000001100111\";\n      var makeW = \"11011,10010,010111,0110111,00110110,00110111,01100100,01100101,01101000,01100111,011001100,011001101,011010010,011010011,011010100,011010101,011010110,\" + \"011010111,011011000,011011001,011011010,011011011,010011000,010011001,010011010,011000,010011011\";\n      var makeB = \"0000001111,000011001000,000011001001,000001011011,000000110011,000000110100,000000110101,0000001101100,0000001101101,0000001001010,0000001001011,0000001001100,\" + \"0000001001101,0000001110010,0000001110011,0000001110100,0000001110101,0000001110110,0000001110111,0000001010010,0000001010011,0000001010100,0000001010101,0000001011010,\" + \"0000001011011,0000001100100,0000001100101\";\n      var makeA = \"00000001000,00000001100,00000001101,000000010010,000000010011,000000010100,000000010101,000000010110,000000010111,000000011100,000000011101,000000011110,000000011111\";\n      termW = termW.split(\",\");\n      termB = termB.split(\",\");\n      makeW = makeW.split(\",\");\n      makeB = makeB.split(\",\");\n      makeA = makeA.split(\",\");\n      var lensW = {},\n        lensB = {};\n      addKeys(lensW, termW, 0, 1);\n      addKeys(lensW, makeW, 64, 64);\n      addKeys(lensW, makeA, 1792, 64);\n      addKeys(lensB, termB, 0, 1);\n      addKeys(lensB, makeB, 64, 64);\n      addKeys(lensB, makeA, 1792, 64);\n      return [lensW, lensB];\n    }();\n    UTIF.decode._decodeG4 = function (data, off, slen, tgt, toff, w, fo) {\n      var U = UTIF.decode,\n        boff = off << 3,\n        len = 0,\n        wrd = \"\"; // previous starts with 1\n      var line = [],\n        pline = [];\n      for (var i = 0; i < w; i++) pline.push(0);\n      pline = U._makeDiff(pline);\n      var a0 = 0,\n        a1 = 0,\n        a2 = 0,\n        b1 = 0,\n        b2 = 0,\n        clr = 0;\n      var y = 0,\n        mode = \"\",\n        toRead = 0;\n      var bipl = Math.ceil(w / 8) * 8;\n      while (boff >>> 3 < off + slen) {\n        b1 = U._findDiff(pline, a0 + (a0 == 0 ? 0 : 1), 1 - clr), b2 = U._findDiff(pline, b1, clr); // could be precomputed\n        var bit = 0;\n        if (fo == 1) bit = data[boff >>> 3] >>> 7 - (boff & 7) & 1;\n        if (fo == 2) bit = data[boff >>> 3] >>> (boff & 7) & 1;\n        boff++;\n        wrd += bit;\n        if (mode == \"H\") {\n          if (U._lens[clr][wrd] != null) {\n            var dl = U._lens[clr][wrd];\n            wrd = \"\";\n            len += dl;\n            if (dl < 64) {\n              U._addNtimes(line, len, clr);\n              a0 += len;\n              clr = 1 - clr;\n              len = 0;\n              toRead--;\n              if (toRead == 0) mode = \"\";\n            }\n          }\n        } else {\n          if (wrd == \"0001\") {\n            wrd = \"\";\n            U._addNtimes(line, b2 - a0, clr);\n            a0 = b2;\n          }\n          if (wrd == \"001\") {\n            wrd = \"\";\n            mode = \"H\";\n            toRead = 2;\n          }\n          if (U._dmap[wrd] != null) {\n            a1 = b1 + U._dmap[wrd];\n            U._addNtimes(line, a1 - a0, clr);\n            a0 = a1;\n            wrd = \"\";\n            clr = 1 - clr;\n          }\n        }\n        if (line.length == w && mode == \"\") {\n          U._writeBits(line, tgt, toff * 8 + y * bipl);\n          clr = 0;\n          y++;\n          a0 = 0;\n          pline = U._makeDiff(line);\n          line = [];\n        }\n        //if(wrd.length>150) {  log(wrd);  break;  throw \"e\";  }\n      }\n    };\n    UTIF.decode._findDiff = function (line, x, clr) {\n      for (var i = 0; i < line.length; i += 2) if (line[i] >= x && line[i + 1] == clr) return line[i];\n    };\n    UTIF.decode._makeDiff = function (line) {\n      var out = [];\n      if (line[0] == 1) out.push(0, 1);\n      for (var i = 1; i < line.length; i++) if (line[i - 1] != line[i]) out.push(i, line[i]);\n      out.push(line.length, 0, line.length, 1);\n      return out;\n    };\n    UTIF.decode._decodeG2 = function (data, off, slen, tgt, toff, w, fo) {\n      var U = UTIF.decode,\n        boff = off << 3,\n        len = 0,\n        wrd = \"\";\n      var line = [];\n      var clr = 0;\n      var y = 0;\n      var bipl = Math.ceil(w / 8) * 8;\n      while (boff >>> 3 < off + slen) {\n        var bit = 0;\n        if (fo == 1) bit = data[boff >>> 3] >>> 7 - (boff & 7) & 1;\n        if (fo == 2) bit = data[boff >>> 3] >>> (boff & 7) & 1;\n        boff++;\n        wrd += bit;\n        len = U._lens[clr][wrd];\n        if (len != null) {\n          U._addNtimes(line, len, clr);\n          wrd = \"\";\n          if (len < 64) clr = 1 - clr;\n          if (line.length == w) {\n            U._writeBits(line, tgt, toff * 8 + y * bipl);\n            line = [];\n            y++;\n            clr = 0;\n            if ((boff & 7) != 0) boff += 8 - (boff & 7);\n            if (len >= 64) boff += 8;\n          }\n        }\n      }\n    };\n    UTIF.decode._decodeG3 = function (data, off, slen, tgt, toff, w, fo, twoDim) {\n      var U = UTIF.decode,\n        boff = off << 3,\n        len = 0,\n        wrd = \"\";\n      var line = [],\n        pline = [];\n      for (var i = 0; i < w; i++) line.push(0);\n      var a0 = 0,\n        a1 = 0,\n        a2 = 0,\n        b1 = 0,\n        b2 = 0,\n        clr = 0;\n      var y = -1,\n        mode = \"\",\n        toRead = 0,\n        is1D = true;\n      var bipl = Math.ceil(w / 8) * 8;\n      while (boff >>> 3 < off + slen) {\n        b1 = U._findDiff(pline, a0 + (a0 == 0 ? 0 : 1), 1 - clr), b2 = U._findDiff(pline, b1, clr); // could be precomputed\n        var bit = 0;\n        if (fo == 1) bit = data[boff >>> 3] >>> 7 - (boff & 7) & 1;\n        if (fo == 2) bit = data[boff >>> 3] >>> (boff & 7) & 1;\n        boff++;\n        wrd += bit;\n        if (is1D) {\n          if (U._lens[clr][wrd] != null) {\n            var dl = U._lens[clr][wrd];\n            wrd = \"\";\n            len += dl;\n            if (dl < 64) {\n              U._addNtimes(line, len, clr);\n              clr = 1 - clr;\n              len = 0;\n            }\n          }\n        } else {\n          if (mode == \"H\") {\n            if (U._lens[clr][wrd] != null) {\n              var dl = U._lens[clr][wrd];\n              wrd = \"\";\n              len += dl;\n              if (dl < 64) {\n                U._addNtimes(line, len, clr);\n                a0 += len;\n                clr = 1 - clr;\n                len = 0;\n                toRead--;\n                if (toRead == 0) mode = \"\";\n              }\n            }\n          } else {\n            if (wrd == \"0001\") {\n              wrd = \"\";\n              U._addNtimes(line, b2 - a0, clr);\n              a0 = b2;\n            }\n            if (wrd == \"001\") {\n              wrd = \"\";\n              mode = \"H\";\n              toRead = 2;\n            }\n            if (U._dmap[wrd] != null) {\n              a1 = b1 + U._dmap[wrd];\n              U._addNtimes(line, a1 - a0, clr);\n              a0 = a1;\n              wrd = \"\";\n              clr = 1 - clr;\n            }\n          }\n        }\n        if (wrd.endsWith(\"000000000001\"))\n          // needed for some files\n          {\n            if (y >= 0) U._writeBits(line, tgt, toff * 8 + y * bipl);\n            if (twoDim) {\n              if (fo == 1) is1D = (data[boff >>> 3] >>> 7 - (boff & 7) & 1) == 1;\n              if (fo == 2) is1D = (data[boff >>> 3] >>> (boff & 7) & 1) == 1;\n              boff++;\n            }\n            //log(\"EOL\",y, \"next 1D:\", is1D);\n            wrd = \"\";\n            clr = 0;\n            y++;\n            a0 = 0;\n            pline = U._makeDiff(line);\n            line = [];\n          }\n      }\n      if (line.length == w) U._writeBits(line, tgt, toff * 8 + y * bipl);\n    };\n    UTIF.decode._addNtimes = function (arr, n, val) {\n      for (var i = 0; i < n; i++) arr.push(val);\n    };\n    UTIF.decode._writeBits = function (bits, tgt, boff) {\n      for (var i = 0; i < bits.length; i++) tgt[boff + i >>> 3] |= bits[i] << 7 - (boff + i & 7);\n    };\n    UTIF.decode._decodeLZW = UTIF.decode._decodeLZW = function () {\n      var e,\n        U,\n        Z,\n        u,\n        K = 0,\n        V = 0,\n        g = 0,\n        N = 0,\n        O = function O() {\n          var S = e >>> 3,\n            A = U[S] << 16 | U[S + 1] << 8 | U[S + 2],\n            j = A >>> 24 - (e & 7) - V & (1 << V) - 1;\n          e += V;\n          return j;\n        },\n        h = new Uint32Array(4096 * 4),\n        w = 0,\n        m = function m(S) {\n          if (S == w) return;\n          w = S;\n          g = 1 << S;\n          N = g + 1;\n          for (var A = 0; A < N + 1; A++) {\n            h[4 * A] = h[4 * A + 3] = A;\n            h[4 * A + 1] = 65535;\n            h[4 * A + 2] = 1;\n          }\n        },\n        i = function i(S) {\n          V = S + 1;\n          K = N + 1;\n        },\n        D = function D(S) {\n          var A = S << 2,\n            j = h[A + 2],\n            a = u + j - 1;\n          while (A != 65535) {\n            Z[a--] = h[A];\n            A = h[A + 1];\n          }\n          u += j;\n        },\n        L = function L(S, A) {\n          var j = K << 2,\n            a = S << 2;\n          h[j] = h[(A << 2) + 3];\n          h[j + 1] = a;\n          h[j + 2] = h[a + 2] + 1;\n          h[j + 3] = h[a + 3];\n          K++;\n          if (K + 1 == 1 << V && V != 12) V++;\n        },\n        T = function T(S, A, j, a, n, q) {\n          e = A << 3;\n          U = S;\n          Z = a;\n          u = n;\n          var B = A + j << 3,\n            _ = 0,\n            t = 0;\n          m(q);\n          i(q);\n          while (e < B && (_ = O()) != N) {\n            if (_ == g) {\n              i(q);\n              _ = O();\n              if (_ == N) break;\n              D(_);\n            } else {\n              if (_ < K) {\n                D(_);\n                L(t, _);\n              } else {\n                L(t, t);\n                D(K - 1);\n              }\n            }\n            t = _;\n          }\n          return u;\n        };\n      return T;\n    }();\n    UTIF.tags = {};\n    //UTIF.ttypes = {  256:3,257:3,258:3,   259:3, 262:3,  273:4,  274:3, 277:3,278:4,279:4, 282:5, 283:5, 284:3, 286:5,287:5, 296:3, 305:2, 306:2, 338:3, 513:4, 514:4, 34665:4  };\n    // start at tag 250\n    UTIF._types = function () {\n      var main = new Array(250);\n      main.fill(0);\n      main = main.concat([0, 0, 0, 0, 4, 3, 3, 3, 3, 3, 0, 0, 3, 0, 0, 0, 3, 0, 0, 2, 2, 2, 2, 4, 3, 0, 0, 3, 4, 4, 3, 3, 5, 5, 3, 2, 5, 5, 0, 0, 0, 0, 4, 4, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 3, 5, 5, 3, 0, 3, 3, 4, 4, 4, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n      var rest = {\n        33432: 2,\n        33434: 5,\n        33437: 5,\n        34665: 4,\n        34850: 3,\n        34853: 4,\n        34855: 3,\n        34864: 3,\n        34866: 4,\n        36864: 7,\n        36867: 2,\n        36868: 2,\n        37121: 7,\n        37377: 10,\n        37378: 5,\n        37380: 10,\n        37381: 5,\n        37383: 3,\n        37384: 3,\n        37385: 3,\n        37386: 5,\n        37510: 7,\n        37520: 2,\n        37521: 2,\n        37522: 2,\n        40960: 7,\n        40961: 3,\n        40962: 4,\n        40963: 4,\n        40965: 4,\n        41486: 5,\n        41487: 5,\n        41488: 3,\n        41985: 3,\n        41986: 3,\n        41987: 3,\n        41988: 5,\n        41989: 3,\n        41990: 3,\n        41993: 3,\n        41994: 3,\n        41995: 7,\n        41996: 3,\n        42032: 2,\n        42033: 2,\n        42034: 5,\n        42036: 2,\n        42037: 2,\n        59932: 7\n      };\n      return {\n        basic: {\n          main: main,\n          rest: rest\n        },\n        gps: {\n          main: [1, 2, 5, 2, 5, 1, 5, 5, 0, 9],\n          rest: {\n            18: 2,\n            29: 2\n          }\n        }\n      };\n    }();\n    UTIF._readIFD = function (bin, data, offset, ifds, depth, prm) {\n      var cnt = bin.readUshort(data, offset);\n      offset += 2;\n      var ifd = {};\n      if (prm.debug) log(\"   \".repeat(depth), ifds.length - 1, \">>>----------------\");\n      for (var i = 0; i < cnt; i++) {\n        var tag = bin.readUshort(data, offset);\n        offset += 2;\n        var type = bin.readUshort(data, offset);\n        offset += 2;\n        var num = bin.readUint(data, offset);\n        offset += 4;\n        var voff = bin.readUint(data, offset);\n        offset += 4;\n        var arr = [];\n        //ifd[\"t\"+tag+\"-\"+UTIF.tags[tag]] = arr;\n        if (type == 1 || type == 7) {\n          var no = num < 5 ? offset - 4 : voff;\n          if (no + num > data.buffer.byteLength) num = data.buffer.byteLength - no;\n          arr = new Uint8Array(data.buffer, no, num);\n        }\n        if (type == 2) {\n          var o0 = num < 5 ? offset - 4 : voff,\n            c = data[o0],\n            len = Math.max(0, Math.min(num - 1, data.length - o0));\n          if (c < 128 || len == 0) arr.push(bin.readASCII(data, o0, len));else arr = new Uint8Array(data.buffer, o0, len);\n        }\n        if (type == 3) {\n          for (var j = 0; j < num; j++) arr.push(bin.readUshort(data, (num < 3 ? offset - 4 : voff) + 2 * j));\n        }\n        if (type == 4 || type == 13) {\n          for (var j = 0; j < num; j++) arr.push(bin.readUint(data, (num < 2 ? offset - 4 : voff) + 4 * j));\n        }\n        if (type == 5 || type == 10) {\n          var ri = type == 5 ? bin.readUint : bin.readInt;\n          for (var j = 0; j < num; j++) arr.push([ri(data, voff + j * 8), ri(data, voff + j * 8 + 4)]);\n        }\n        if (type == 8) {\n          for (var j = 0; j < num; j++) arr.push(bin.readShort(data, (num < 3 ? offset - 4 : voff) + 2 * j));\n        }\n        if (type == 9) {\n          for (var j = 0; j < num; j++) arr.push(bin.readInt(data, (num < 2 ? offset - 4 : voff) + 4 * j));\n        }\n        if (type == 11) {\n          for (var j = 0; j < num; j++) arr.push(bin.readFloat(data, voff + j * 4));\n        }\n        if (type == 12) {\n          for (var j = 0; j < num; j++) arr.push(bin.readDouble(data, voff + j * 8));\n        }\n        if (num != 0 && arr.length == 0) {\n          log(tag, \"unknown TIFF tag type: \", type, \"num:\", num);\n          if (i == 0) return;\n          continue;\n        }\n        if (prm.debug) log(\"   \".repeat(depth), tag, type, UTIF.tags[tag], arr);\n        ifd[\"t\" + tag] = arr;\n        if (tag == 330 && ifd[\"t272\"] && ifd[\"t272\"][0] == \"DSLR-A100\") {} else if (tag == 330 || tag == 34665 || tag == 34853 || tag == 50740 && bin.readUshort(data, bin.readUint(arr, 0)) < 300 || tag == 61440) {\n          var oarr = tag == 50740 ? [bin.readUint(arr, 0)] : arr;\n          var subfd = [];\n          for (var j = 0; j < oarr.length; j++) UTIF._readIFD(bin, data, oarr[j], subfd, depth + 1, prm);\n          if (tag == 330) ifd.subIFD = subfd;\n          if (tag == 34665) ifd.exifIFD = subfd[0];\n          if (tag == 34853) ifd.gpsiIFD = subfd[0]; //console.log(\"gps\", subfd[0]);  }\n          if (tag == 50740) ifd.dngPrvt = subfd[0];\n          if (tag == 61440) ifd.fujiIFD = subfd[0];\n        }\n        if (tag == 37500 && prm.parseMN) {\n          var mn = arr;\n          //console.log(bin.readASCII(mn,0,mn.length), mn);\n          if (bin.readASCII(mn, 0, 5) == \"Nikon\") ifd.makerNote = UTIF[\"decode\"](mn.slice(10).buffer)[0];else if (bin.readASCII(mn, 0, 5) == \"OLYMP\" || bin.readASCII(mn, 0, 9) == \"OM SYSTEM\") {\n            // ???\n            var inds = [8208, 8224, 8240, 8256, 8272];\n            var subsub = [];\n            UTIF._readIFD(bin, mn, mn[1] == 77 ? 16 : mn[5] == 85 ? 12 : 8, subsub, depth + 1, prm);\n            var obj = ifd.makerNote = subsub.pop();\n            for (var j = 0; j < inds.length; j++) {\n              var k = \"t\" + inds[j];\n              if (obj[k] == null) continue;\n              UTIF._readIFD(bin, mn, obj[k][0], subsub, depth + 1, prm);\n              obj[k] = subsub.pop();\n            }\n            if (obj[\"t12288\"]) {\n              UTIF._readIFD(bin, obj[\"t12288\"], 0, subsub, depth + 1, prm);\n              obj[\"t12288\"] = subsub.pop();\n            }\n          } else if (bin.readUshort(data, voff) < 300 && bin.readUshort(data, voff + 4) <= 12) {\n            var subsub = [];\n            UTIF._readIFD(bin, data, voff, subsub, depth + 1, prm);\n            ifd.makerNote = subsub[0];\n          }\n        }\n      }\n      ifds.push(ifd);\n      if (prm.debug) log(\"   \".repeat(depth), \"<<<---------------\");\n      return offset;\n    };\n    UTIF._writeIFD = function (bin, types, data, offset, ifd) {\n      var keys = Object.keys(ifd),\n        knum = keys.length;\n      if (ifd[\"exifIFD\"]) knum--;\n      if (ifd[\"gpsiIFD\"]) knum--;\n      bin.writeUshort(data, offset, knum);\n      offset += 2;\n      var eoff = offset + knum * 12 + 4;\n      for (var ki = 0; ki < keys.length; ki++) {\n        var key = keys[ki];\n        if (key == \"t34665\" || key == \"t34853\") continue;\n        if (key == \"exifIFD\") key = \"t34665\";\n        if (key == \"gpsiIFD\") key = \"t34853\";\n        var tag = parseInt(key.slice(1)),\n          type = types.main[tag];\n        if (type == null) type = types.rest[tag];\n        if (type == null || type == 0) throw new Error(\"unknown type of tag: \" + tag);\n        //console.log(offset+\":\", tag, type, eoff);\n        var val = ifd[key];\n        if (tag == 34665) {\n          var outp = UTIF._writeIFD(bin, types, data, eoff, ifd[\"exifIFD\"]);\n          val = [eoff];\n          eoff = outp[1];\n        }\n        if (tag == 34853) {\n          var outp = UTIF._writeIFD(bin, UTIF._types.gps, data, eoff, ifd[\"gpsiIFD\"]);\n          val = [eoff];\n          eoff = outp[1];\n        }\n        if (type == 2) val = val[0] + \"\\0\";\n        var num = val.length;\n        bin.writeUshort(data, offset, tag);\n        offset += 2;\n        bin.writeUshort(data, offset, type);\n        offset += 2;\n        bin.writeUint(data, offset, num);\n        offset += 4;\n        var dlen = [-1, 1, 1, 2, 4, 8, 0, 1, 0, 4, 8, 0, 8][type] * num; //if(dlen<1) throw \"e\";\n        var toff = offset;\n        if (dlen > 4) {\n          bin.writeUint(data, offset, eoff);\n          toff = eoff;\n        }\n        if (type == 1 || type == 7) {\n          for (var i = 0; i < num; i++) data[toff + i] = val[i];\n        } else if (type == 2) {\n          bin.writeASCII(data, toff, val);\n        } else if (type == 3) {\n          for (var i = 0; i < num; i++) bin.writeUshort(data, toff + 2 * i, val[i]);\n        } else if (type == 4) {\n          for (var i = 0; i < num; i++) bin.writeUint(data, toff + 4 * i, val[i]);\n        } else if (type == 5 || type == 10) {\n          var wr = type == 5 ? bin.writeUint : bin.writeInt;\n          for (var i = 0; i < num; i++) {\n            var v = val[i],\n              nu = v[0],\n              de = v[1];\n            if (nu == null) throw \"e\";\n            wr(data, toff + 8 * i, nu);\n            wr(data, toff + 8 * i + 4, de);\n          }\n        } else if (type == 9) {\n          for (var i = 0; i < num; i++) bin.writeInt(data, toff + 4 * i, val[i]);\n        } else if (type == 12) {\n          for (var i = 0; i < num; i++) bin.writeDouble(data, toff + 8 * i, val[i]);\n        } else throw type;\n        if (dlen > 4) {\n          dlen += dlen & 1;\n          eoff += dlen;\n        }\n        offset += 4;\n      }\n      return [offset, eoff];\n    };\n    UTIF.toRGBA8 = function (out, scl) {\n      function gamma(x) {\n        return x < 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1.0 / 2.4) - 0.055;\n      }\n      var w = out.width,\n        h = out.height,\n        area = w * h,\n        qarea = area * 4,\n        data = out.data;\n      var img = new Uint8Array(area * 4);\n      //console.log(out);\n      // 0: WhiteIsZero, 1: BlackIsZero, 2: RGB, 3: Palette color, 4: Transparency mask, 5: CMYK\n      var intp = out[\"t262\"] ? out[\"t262\"][0] : 2,\n        bps = out[\"t258\"] ? Math.min(32, out[\"t258\"][0]) : 1;\n      if (out[\"t262\"] == null && bps == 1) intp = 0;\n      var smpls = out[\"t277\"] ? out[\"t277\"][0] : out[\"t258\"] ? out[\"t258\"].length : [1, 1, 3, 1, 1, 4, 3][intp];\n      var sfmt = out[\"t339\"] ? out[\"t339\"][0] : null;\n      if (intp == 1 && bps == 32 && sfmt != 3) throw \"e\"; // sample format\n      var bpl = Math.ceil(smpls * bps * w / 8);\n\n      //log(\"interpretation: \", intp, \"smpls\", smpls, \"bps\", bps, \"sample format\",sfmt, out);\n\n      if (false) {} else if (intp == 0) {\n        scl = 1 / 256; // \"Photopeatest.tif\"\n        for (var y = 0; y < h; y++) {\n          var off = y * bpl,\n            io = y * w;\n          if (bps == 1) for (var i = 0; i < w; i++) {\n            var qi = io + i << 2,\n              px = data[off + (i >> 3)] >> 7 - (i & 7) & 1;\n            img[qi] = img[qi + 1] = img[qi + 2] = (1 - px) * 255;\n            img[qi + 3] = 255;\n          }\n          if (bps == 4) for (var i = 0; i < w; i++) {\n            var qi = io + i << 2,\n              px = data[off + (i >> 1)] >> 4 - 4 * (i & 1) & 15;\n            img[qi] = img[qi + 1] = img[qi + 2] = (15 - px) * 17;\n            img[qi + 3] = 255;\n          }\n          if (bps == 8) for (var i = 0; i < w; i++) {\n            var qi = io + i << 2,\n              px = data[off + i];\n            img[qi] = img[qi + 1] = img[qi + 2] = 255 - px;\n            img[qi + 3] = 255;\n          }\n          if (bps == 16) for (var i = 0; i < w; i++) {\n            var qi = io + i << 2,\n              o = off + 2 * i,\n              px = data[o + 1] << 8 | data[o];\n            img[qi] = img[qi + 1] = img[qi + 2] = Math.min(255, 255 - ~~(px * scl));\n            img[qi + 3] = 255;\n          } // ladoga.tif\n        }\n      } else if (intp == 1) {\n        if (scl == null) scl = 1 / 256;\n        var f32 = (data.length & 3) == 0 ? new Float32Array(data.buffer) : null;\n        for (var y = 0; y < h; y++) {\n          var off = y * bpl,\n            io = y * w;\n          if (bps == 1) for (var i = 0; i < w; i++) {\n            var qi = io + i << 2,\n              px = data[off + (i >> 3)] >> 7 - (i & 7) & 1;\n            img[qi] = img[qi + 1] = img[qi + 2] = px * 255;\n            img[qi + 3] = 255;\n          }\n          if (bps == 2) for (var i = 0; i < w; i++) {\n            var qi = io + i << 2,\n              px = data[off + (i >> 2)] >> 6 - 2 * (i & 3) & 3;\n            img[qi] = img[qi + 1] = img[qi + 2] = px * 85;\n            img[qi + 3] = 255;\n          }\n          if (bps == 8) for (var i = 0; i < w; i++) {\n            var qi = io + i << 2,\n              px = data[off + i * smpls];\n            img[qi] = img[qi + 1] = img[qi + 2] = px;\n            img[qi + 3] = 255;\n          }\n          if (bps == 16) for (var i = 0; i < w; i++) {\n            var qi = io + i << 2,\n              o = off + 2 * i,\n              px = data[o + 1] << 8 | data[o];\n            img[qi] = img[qi + 1] = img[qi + 2] = Math.min(255, ~~(px * scl));\n            img[qi + 3] = 255;\n          } // ladoga.tif\n          if (bps == 32) for (var i = 0; i < w; i++) {\n            var qi = io + i << 2,\n              o = (off >>> 2) + i,\n              px = f32[o];\n            img[qi] = img[qi + 1] = img[qi + 2] = ~~(0.5 + 255 * px);\n            img[qi + 3] = 255;\n          }\n        }\n      } else if (intp == 2) {\n        if (bps == 8) {\n          if (smpls == 1) for (var i = 0; i < area; i++) {\n            img[4 * i] = img[4 * i + 1] = img[4 * i + 2] = data[i];\n            img[4 * i + 3] = 255;\n          }\n          if (smpls == 3) for (var i = 0; i < area; i++) {\n            var qi = i << 2,\n              ti = i * 3;\n            img[qi] = data[ti];\n            img[qi + 1] = data[ti + 1];\n            img[qi + 2] = data[ti + 2];\n            img[qi + 3] = 255;\n          }\n          if (smpls >= 4) for (var i = 0; i < area; i++) {\n            var qi = i << 2,\n              ti = i * smpls;\n            img[qi] = data[ti];\n            img[qi + 1] = data[ti + 1];\n            img[qi + 2] = data[ti + 2];\n            img[qi + 3] = data[ti + 3];\n          }\n        } else if (bps == 16) {\n          // 3x 16-bit channel\n          if (smpls == 4) for (var i = 0; i < area; i++) {\n            var qi = i << 2,\n              ti = i * 8 + 1;\n            img[qi] = data[ti];\n            img[qi + 1] = data[ti + 2];\n            img[qi + 2] = data[ti + 4];\n            img[qi + 3] = data[ti + 6];\n          }\n          if (smpls == 3) for (var i = 0; i < area; i++) {\n            var qi = i << 2,\n              ti = i * 6 + 1;\n            img[qi] = data[ti];\n            img[qi + 1] = data[ti + 2];\n            img[qi + 2] = data[ti + 4];\n            img[qi + 3] = 255;\n          }\n        } else if (bps == 32) {\n          var ndt = new Float32Array(data.buffer); // t339 is [3,3,3]\n          // check the endianity\n          var min = 0;\n          for (var i = 0; i < ndt.length; i++) min = Math.min(min, ndt[i]);\n          if (min < 0) for (var i = 0; i < data.length; i += 4) {\n            var t = data[i];\n            data[i] = data[i + 3];\n            data[i + 3] = t;\n            t = data[i + 1];\n            data[i + 1] = data[i + 2];\n            data[i + 2] = t;\n          }\n          // gamma correction\n          var pmap = [];\n          for (var i = 0; i < 65536; i++) pmap.push(gamma(i / 65535));\n          for (var i = 0; i < ndt.length; i++) {\n            var cv = Math.max(0, Math.min(1, ndt[i]));\n            ndt[i] = pmap[~~(0.5 + cv * 65535)];\n          }\n          if (smpls == 3) for (var i = 0; i < area; i++) {\n            var qi = i << 2,\n              ti = i * 3;\n            img[qi] = ~~(0.5 + ndt[ti] * 255);\n            img[qi + 1] = ~~(0.5 + ndt[ti + 1] * 255);\n            img[qi + 2] = ~~(0.5 + ndt[ti + 2] * 255);\n            img[qi + 3] = 255;\n          } else if (smpls == 4) for (var i = 0; i < area; i++) {\n            var qi = i << 2,\n              ti = i * 4;\n            img[qi] = ~~(0.5 + ndt[ti] * 255);\n            img[qi + 1] = ~~(0.5 + ndt[ti + 1] * 255);\n            img[qi + 2] = ~~(0.5 + ndt[ti + 2] * 255);\n            img[qi + 3] = ~~(0.5 + ndt[ti + 3] * 255);\n          } else throw smpls;\n        } else throw bps;\n      } else if (intp == 3) {\n        var map = out[\"t320\"];\n        var cn = 1 << bps;\n        var nexta = bps == 8 && smpls > 1 && out[\"t338\"] && out[\"t338\"][0] != 0;\n        for (var y = 0; y < h; y++) for (var x = 0; x < w; x++) {\n          var i = y * w + x;\n          var qi = i << 2,\n            mi = 0;\n          var dof = y * bpl;\n          if (false) {} else if (bps == 1) mi = data[dof + (x >>> 3)] >>> 7 - (x & 7) & 1;else if (bps == 2) mi = data[dof + (x >>> 2)] >>> 6 - 2 * (x & 3) & 3;else if (bps == 4) mi = data[dof + (x >>> 1)] >>> 4 - 4 * (x & 1) & 15;else if (bps == 8) mi = data[dof + x * smpls];else throw bps;\n          img[qi] = map[mi] >> 8;\n          img[qi + 1] = map[cn + mi] >> 8;\n          img[qi + 2] = map[cn + cn + mi] >> 8;\n          img[qi + 3] = nexta ? data[dof + x * smpls + 1] : 255;\n        }\n      } else if (intp == 5) {\n        var gotAlpha = smpls > 4 ? 1 : 0;\n        for (var i = 0; i < area; i++) {\n          var qi = i << 2,\n            si = i * smpls;\n          if (window.UDOC) {\n            var C = data[si],\n              M = data[si + 1],\n              Y = data[si + 2],\n              K = data[si + 3];\n            var c = UDOC.C.cmykToRgb([C * (1 / 255), M * (1 / 255), Y * (1 / 255), K * (1 / 255)]);\n            img[qi] = ~~(0.5 + 255 * c[0]);\n            img[qi + 1] = ~~(0.5 + 255 * c[1]);\n            img[qi + 2] = ~~(0.5 + 255 * c[2]);\n          } else {\n            var C = 255 - data[si],\n              M = 255 - data[si + 1],\n              Y = 255 - data[si + 2],\n              K = (255 - data[si + 3]) * (1 / 255);\n            img[qi] = ~~(C * K + 0.5);\n            img[qi + 1] = ~~(M * K + 0.5);\n            img[qi + 2] = ~~(Y * K + 0.5);\n          }\n          img[qi + 3] = 255 * (1 - gotAlpha) + data[si + 4] * gotAlpha;\n        }\n      } else if (intp == 6 && out[\"t278\"]) {\n        // only for DSC_1538.TIF\n        var rps = out[\"t278\"][0];\n        for (var y = 0; y < h; y += rps) {\n          var i = y * w,\n            len = rps * w;\n          for (var j = 0; j < len; j++) {\n            var qi = 4 * (i + j),\n              si = 3 * i + 4 * (j >>> 1);\n            var Y = data[si + (j & 1)],\n              Cb = data[si + 2] - 128,\n              Cr = data[si + 3] - 128;\n            var r = Y + ((Cr >> 2) + (Cr >> 3) + (Cr >> 5));\n            var g = Y - ((Cb >> 2) + (Cb >> 4) + (Cb >> 5)) - ((Cr >> 1) + (Cr >> 3) + (Cr >> 4) + (Cr >> 5));\n            var b = Y + (Cb + (Cb >> 1) + (Cb >> 2) + (Cb >> 6));\n            img[qi] = Math.max(0, Math.min(255, r));\n            img[qi + 1] = Math.max(0, Math.min(255, g));\n            img[qi + 2] = Math.max(0, Math.min(255, b));\n            img[qi + 3] = 255;\n          }\n        }\n      } else if (intp == 32845) {\n        for (var y = 0; y < h; y++) for (var x = 0; x < w; x++) {\n          var si = (y * w + x) * 6,\n            qi = (y * w + x) * 4;\n          var L = data[si + 1] << 8 | data[si];\n          var L = Math.pow(2, (L + 0.5) / 256 - 64);\n          var u = (data[si + 3] + 0.5) / 410;\n          var v = (data[si + 5] + 0.5) / 410;\n\n          // Luv to xyY\n          var sX = 9 * u / (6 * u - 16 * v + 12);\n          var sY = 4 * v / (6 * u - 16 * v + 12);\n          var bY = L;\n\n          // xyY to XYZ\n          var X = sX * bY / sY,\n            Y = bY,\n            Z = (1 - sX - sY) * bY / sY;\n          var r = 2.690 * X - 1.276 * Y - 0.414 * Z;\n          var g = -1.022 * X + 1.978 * Y + 0.044 * Z;\n          var b = 0.061 * X - 0.224 * Y + 1.163 * Z;\n          img[qi] = gamma(Math.min(r, 1)) * 255;\n          img[qi + 1] = gamma(Math.min(g, 1)) * 255;\n          img[qi + 2] = gamma(Math.min(b, 1)) * 255;\n          img[qi + 3] = 255;\n        }\n      } else log(\"Unknown Photometric interpretation: \" + intp);\n      return img;\n    };\n    UTIF.replaceIMG = function (imgs) {\n      if (imgs == null) imgs = document.getElementsByTagName(\"img\");\n      var sufs = [\"tif\", \"tiff\", \"dng\", \"cr2\", \"nef\"];\n      for (var i = 0; i < imgs.length; i++) {\n        var img = imgs[i],\n          src = img.getAttribute(\"src\");\n        if (src == null) continue;\n        var suff = src.split(\".\").pop().toLowerCase();\n        if (sufs.indexOf(suff) == -1) continue;\n        var xhr = new XMLHttpRequest();\n        UTIF._xhrs.push(xhr);\n        UTIF._imgs.push(img);\n        xhr.open(\"GET\", src);\n        xhr.responseType = \"arraybuffer\";\n        xhr.onload = UTIF._imgLoaded;\n        xhr.send();\n      }\n    };\n    UTIF._xhrs = [];\n    UTIF._imgs = [];\n    UTIF._imgLoaded = function (e) {\n      var ind = UTIF._xhrs.indexOf(e.target),\n        img = UTIF._imgs[ind];\n      UTIF._xhrs.splice(ind, 1);\n      UTIF._imgs.splice(ind, 1);\n      img.setAttribute(\"src\", UTIF.bufferToURI(e.target.response));\n    };\n    UTIF.bufferToURI = function (buff) {\n      var ifds = UTIF.decode(buff); //console.log(ifds);\n      var vsns = ifds,\n        ma = 0,\n        page = vsns[0];\n      if (ifds[0].subIFD) vsns = vsns.concat(ifds[0].subIFD);\n      for (var i = 0; i < vsns.length; i++) {\n        var img = vsns[i];\n        if (img[\"t258\"] == null || img[\"t258\"].length < 3) continue;\n        var ar = img[\"t256\"] * img[\"t257\"];\n        if (ar > ma) {\n          ma = ar;\n          page = img;\n        }\n      }\n      UTIF.decodeImage(buff, page, ifds);\n      var rgba = UTIF.toRGBA8(page),\n        w = page.width,\n        h = page.height;\n      var cnv = document.createElement(\"canvas\");\n      cnv.width = w;\n      cnv.height = h;\n      var ctx = cnv.getContext(\"2d\");\n      var imgd = new ImageData(new Uint8ClampedArray(rgba.buffer), w, h);\n      ctx.putImageData(imgd, 0, 0);\n      return cnv.toDataURL();\n    };\n    UTIF._binBE = {\n      nextZero: function nextZero(data, o) {\n        while (data[o] != 0) o++;\n        return o;\n      },\n      readUshort: function readUshort(buff, p) {\n        return buff[p] << 8 | buff[p + 1];\n      },\n      readShort: function readShort(buff, p) {\n        var a = UTIF._binBE.ui8;\n        a[0] = buff[p + 1];\n        a[1] = buff[p + 0];\n        return UTIF._binBE.i16[0];\n      },\n      readInt: function readInt(buff, p) {\n        var a = UTIF._binBE.ui8;\n        a[0] = buff[p + 3];\n        a[1] = buff[p + 2];\n        a[2] = buff[p + 1];\n        a[3] = buff[p + 0];\n        return UTIF._binBE.i32[0];\n      },\n      readUint: function readUint(buff, p) {\n        var a = UTIF._binBE.ui8;\n        a[0] = buff[p + 3];\n        a[1] = buff[p + 2];\n        a[2] = buff[p + 1];\n        a[3] = buff[p + 0];\n        return UTIF._binBE.ui32[0];\n      },\n      readASCII: function readASCII(buff, p, l) {\n        var s = \"\";\n        for (var i = 0; i < l; i++) s += String.fromCharCode(buff[p + i]);\n        return s;\n      },\n      readFloat: function readFloat(buff, p) {\n        var a = UTIF._binBE.ui8;\n        for (var i = 0; i < 4; i++) a[i] = buff[p + 3 - i];\n        return UTIF._binBE.fl32[0];\n      },\n      readDouble: function readDouble(buff, p) {\n        var a = UTIF._binBE.ui8;\n        for (var i = 0; i < 8; i++) a[i] = buff[p + 7 - i];\n        return UTIF._binBE.fl64[0];\n      },\n      writeUshort: function writeUshort(buff, p, n) {\n        buff[p] = n >> 8 & 255;\n        buff[p + 1] = n & 255;\n      },\n      writeInt: function writeInt(buff, p, n) {\n        var a = UTIF._binBE.ui8;\n        UTIF._binBE.i32[0] = n;\n        buff[p + 3] = a[0];\n        buff[p + 2] = a[1];\n        buff[p + 1] = a[2];\n        buff[p + 0] = a[3];\n      },\n      writeUint: function writeUint(buff, p, n) {\n        buff[p] = n >> 24 & 255;\n        buff[p + 1] = n >> 16 & 255;\n        buff[p + 2] = n >> 8 & 255;\n        buff[p + 3] = n >> 0 & 255;\n      },\n      writeASCII: function writeASCII(buff, p, s) {\n        for (var i = 0; i < s.length; i++) buff[p + i] = s.charCodeAt(i);\n      },\n      writeDouble: function writeDouble(buff, p, n) {\n        UTIF._binBE.fl64[0] = n;\n        for (var i = 0; i < 8; i++) buff[p + i] = UTIF._binBE.ui8[7 - i];\n      }\n    };\n    UTIF._binBE.ui8 = new Uint8Array(8);\n    UTIF._binBE.i16 = new Int16Array(UTIF._binBE.ui8.buffer);\n    UTIF._binBE.i32 = new Int32Array(UTIF._binBE.ui8.buffer);\n    UTIF._binBE.ui32 = new Uint32Array(UTIF._binBE.ui8.buffer);\n    UTIF._binBE.fl32 = new Float32Array(UTIF._binBE.ui8.buffer);\n    UTIF._binBE.fl64 = new Float64Array(UTIF._binBE.ui8.buffer);\n    UTIF._binLE = {\n      nextZero: UTIF._binBE.nextZero,\n      readUshort: function readUshort(buff, p) {\n        return buff[p + 1] << 8 | buff[p];\n      },\n      readShort: function readShort(buff, p) {\n        var a = UTIF._binBE.ui8;\n        a[0] = buff[p + 0];\n        a[1] = buff[p + 1];\n        return UTIF._binBE.i16[0];\n      },\n      readInt: function readInt(buff, p) {\n        var a = UTIF._binBE.ui8;\n        a[0] = buff[p + 0];\n        a[1] = buff[p + 1];\n        a[2] = buff[p + 2];\n        a[3] = buff[p + 3];\n        return UTIF._binBE.i32[0];\n      },\n      readUint: function readUint(buff, p) {\n        var a = UTIF._binBE.ui8;\n        a[0] = buff[p + 0];\n        a[1] = buff[p + 1];\n        a[2] = buff[p + 2];\n        a[3] = buff[p + 3];\n        return UTIF._binBE.ui32[0];\n      },\n      readASCII: UTIF._binBE.readASCII,\n      readFloat: function readFloat(buff, p) {\n        var a = UTIF._binBE.ui8;\n        for (var i = 0; i < 4; i++) a[i] = buff[p + i];\n        return UTIF._binBE.fl32[0];\n      },\n      readDouble: function readDouble(buff, p) {\n        var a = UTIF._binBE.ui8;\n        for (var i = 0; i < 8; i++) a[i] = buff[p + i];\n        return UTIF._binBE.fl64[0];\n      },\n      writeUshort: function writeUshort(buff, p, n) {\n        buff[p] = n & 255;\n        buff[p + 1] = n >> 8 & 255;\n      },\n      writeInt: function writeInt(buff, p, n) {\n        var a = UTIF._binBE.ui8;\n        UTIF._binBE.i32[0] = n;\n        buff[p + 0] = a[0];\n        buff[p + 1] = a[1];\n        buff[p + 2] = a[2];\n        buff[p + 3] = a[3];\n      },\n      writeUint: function writeUint(buff, p, n) {\n        buff[p] = n >>> 0 & 255;\n        buff[p + 1] = n >>> 8 & 255;\n        buff[p + 2] = n >>> 16 & 255;\n        buff[p + 3] = n >>> 24 & 255;\n      },\n      writeASCII: UTIF._binBE.writeASCII\n    };\n    UTIF._copyTile = function (tb, tw, th, b, w, h, xoff, yoff) {\n      //log(\"copyTile\", tw, th,  w, h, xoff, yoff);\n      var xlim = Math.min(tw, w - xoff);\n      var ylim = Math.min(th, h - yoff);\n      for (var y = 0; y < ylim; y++) {\n        var tof = (yoff + y) * w + xoff;\n        var sof = y * tw;\n        for (var x = 0; x < xlim; x++) b[tof + x] = tb[sof + x];\n      }\n    };\n    UTIF._inflateRaw = function () {\n      var H = {};\n      H.H = {};\n      H.H.N = function (N, W) {\n        var R = Uint8Array,\n          i = 0,\n          m = 0,\n          J = 0,\n          h = 0,\n          Q = 0,\n          X = 0,\n          u = 0,\n          w = 0,\n          d = 0,\n          v,\n          C;\n        if (N[0] == 3 && N[1] == 0) return W ? W : new R(0);\n        var V = H.H,\n          n = V.b,\n          A = V.e,\n          l = V.R,\n          M = V.n,\n          I = V.A,\n          e = V.Z,\n          b = V.m,\n          Z = W == null;\n        if (Z) W = new R(N.length >>> 2 << 5);\n        while (i == 0) {\n          i = n(N, d, 1);\n          m = n(N, d + 1, 2);\n          d += 3;\n          if (m == 0) {\n            if ((d & 7) != 0) d += 8 - (d & 7);\n            var D = (d >>> 3) + 4,\n              q = N[D - 4] | N[D - 3] << 8;\n            if (Z) W = H.H.W(W, w + q);\n            W.set(new R(N.buffer, N.byteOffset + D, q), w);\n            d = D + q << 3;\n            w += q;\n            continue;\n          }\n          if (Z) W = H.H.W(W, w + (1 << 17));\n          if (m == 1) {\n            v = b.J;\n            C = b.h;\n            X = (1 << 9) - 1;\n            u = (1 << 5) - 1;\n          }\n          if (m == 2) {\n            J = A(N, d, 5) + 257;\n            h = A(N, d + 5, 5) + 1;\n            Q = A(N, d + 10, 4) + 4;\n            d += 14;\n            var E = d,\n              j = 1;\n            for (var c = 0; c < 38; c += 2) {\n              b.Q[c] = 0;\n              b.Q[c + 1] = 0;\n            }\n            for (var c = 0; c < Q; c++) {\n              var K = A(N, d + c * 3, 3);\n              b.Q[(b.X[c] << 1) + 1] = K;\n              if (K > j) j = K;\n            }\n            d += 3 * Q;\n            M(b.Q, j);\n            I(b.Q, j, b.u);\n            v = b.w;\n            C = b.d;\n            d = l(b.u, (1 << j) - 1, J + h, N, d, b.v);\n            var r = V.V(b.v, 0, J, b.C);\n            X = (1 << r) - 1;\n            var S = V.V(b.v, J, h, b.D);\n            u = (1 << S) - 1;\n            M(b.C, r);\n            I(b.C, r, v);\n            M(b.D, S);\n            I(b.D, S, C);\n          }\n          while (!0) {\n            var T = v[e(N, d) & X];\n            d += T & 15;\n            var p = T >>> 4;\n            if (p >>> 8 == 0) {\n              W[w++] = p;\n            } else if (p == 256) {\n              break;\n            } else {\n              var z = w + p - 254;\n              if (p > 264) {\n                var _ = b.q[p - 257];\n                z = w + (_ >>> 3) + A(N, d, _ & 7);\n                d += _ & 7;\n              }\n              var $ = C[e(N, d) & u];\n              d += $ & 15;\n              var s = $ >>> 4,\n                Y = b.c[s],\n                a = (Y >>> 4) + n(N, d, Y & 15);\n              d += Y & 15;\n              while (w < z) {\n                W[w] = W[w++ - a];\n                W[w] = W[w++ - a];\n                W[w] = W[w++ - a];\n                W[w] = W[w++ - a];\n              }\n              w = z;\n            }\n          }\n        }\n        return W.length == w ? W : W.slice(0, w);\n      };\n      H.H.W = function (N, W) {\n        var R = N.length;\n        if (W <= R) return N;\n        var V = new Uint8Array(R << 1);\n        V.set(N, 0);\n        return V;\n      };\n      H.H.R = function (N, W, R, V, n, A) {\n        var l = H.H.e,\n          M = H.H.Z,\n          I = 0;\n        while (I < R) {\n          var e = N[M(V, n) & W];\n          n += e & 15;\n          var b = e >>> 4;\n          if (b <= 15) {\n            A[I] = b;\n            I++;\n          } else {\n            var Z = 0,\n              m = 0;\n            if (b == 16) {\n              m = 3 + l(V, n, 2);\n              n += 2;\n              Z = A[I - 1];\n            } else if (b == 17) {\n              m = 3 + l(V, n, 3);\n              n += 3;\n            } else if (b == 18) {\n              m = 11 + l(V, n, 7);\n              n += 7;\n            }\n            var J = I + m;\n            while (I < J) {\n              A[I] = Z;\n              I++;\n            }\n          }\n        }\n        return n;\n      };\n      H.H.V = function (N, W, R, V) {\n        var n = 0,\n          A = 0,\n          l = V.length >>> 1;\n        while (A < R) {\n          var M = N[A + W];\n          V[A << 1] = 0;\n          V[(A << 1) + 1] = M;\n          if (M > n) n = M;\n          A++;\n        }\n        while (A < l) {\n          V[A << 1] = 0;\n          V[(A << 1) + 1] = 0;\n          A++;\n        }\n        return n;\n      };\n      H.H.n = function (N, W) {\n        var R = H.H.m,\n          V = N.length,\n          n,\n          A,\n          l,\n          M,\n          I,\n          e = R.j;\n        for (var M = 0; M <= W; M++) e[M] = 0;\n        for (M = 1; M < V; M += 2) e[N[M]]++;\n        var b = R.K;\n        n = 0;\n        e[0] = 0;\n        for (A = 1; A <= W; A++) {\n          n = n + e[A - 1] << 1;\n          b[A] = n;\n        }\n        for (l = 0; l < V; l += 2) {\n          I = N[l + 1];\n          if (I != 0) {\n            N[l] = b[I];\n            b[I]++;\n          }\n        }\n      };\n      H.H.A = function (N, W, R) {\n        var V = N.length,\n          n = H.H.m,\n          A = n.r;\n        for (var l = 0; l < V; l += 2) if (N[l + 1] != 0) {\n          var M = l >> 1,\n            I = N[l + 1],\n            e = M << 4 | I,\n            b = W - I,\n            Z = N[l] << b,\n            m = Z + (1 << b);\n          while (Z != m) {\n            var J = A[Z] >>> 15 - W;\n            R[J] = e;\n            Z++;\n          }\n        }\n      };\n      H.H.l = function (N, W) {\n        var R = H.H.m.r,\n          V = 15 - W;\n        for (var n = 0; n < N.length; n += 2) {\n          var A = N[n] << W - N[n + 1];\n          N[n] = R[A] >>> V;\n        }\n      };\n      H.H.M = function (N, W, R) {\n        R = R << (W & 7);\n        var V = W >>> 3;\n        N[V] |= R;\n        N[V + 1] |= R >>> 8;\n      };\n      H.H.I = function (N, W, R) {\n        R = R << (W & 7);\n        var V = W >>> 3;\n        N[V] |= R;\n        N[V + 1] |= R >>> 8;\n        N[V + 2] |= R >>> 16;\n      };\n      H.H.e = function (N, W, R) {\n        return (N[W >>> 3] | N[(W >>> 3) + 1] << 8) >>> (W & 7) & (1 << R) - 1;\n      };\n      H.H.b = function (N, W, R) {\n        return (N[W >>> 3] | N[(W >>> 3) + 1] << 8 | N[(W >>> 3) + 2] << 16) >>> (W & 7) & (1 << R) - 1;\n      };\n      H.H.Z = function (N, W) {\n        return (N[W >>> 3] | N[(W >>> 3) + 1] << 8 | N[(W >>> 3) + 2] << 16) >>> (W & 7);\n      };\n      H.H.i = function (N, W) {\n        return (N[W >>> 3] | N[(W >>> 3) + 1] << 8 | N[(W >>> 3) + 2] << 16 | N[(W >>> 3) + 3] << 24) >>> (W & 7);\n      };\n      H.H.m = function () {\n        var N = Uint16Array,\n          W = Uint32Array;\n        return {\n          K: new N(16),\n          j: new N(16),\n          X: [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],\n          S: [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 999, 999, 999],\n          T: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0],\n          q: new N(32),\n          p: [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 65535, 65535],\n          z: [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0],\n          c: new W(32),\n          J: new N(512),\n          _: [],\n          h: new N(32),\n          $: [],\n          w: new N(32768),\n          C: [],\n          v: [],\n          d: new N(32768),\n          D: [],\n          u: new N(512),\n          Q: [],\n          r: new N(1 << 15),\n          s: new W(286),\n          Y: new W(30),\n          a: new W(19),\n          t: new W(15e3),\n          k: new N(1 << 16),\n          g: new N(1 << 15)\n        };\n      }();\n      (function () {\n        var N = H.H.m,\n          W = 1 << 15;\n        for (var R = 0; R < W; R++) {\n          var V = R;\n          V = (V & 2863311530) >>> 1 | (V & 1431655765) << 1;\n          V = (V & 3435973836) >>> 2 | (V & 858993459) << 2;\n          V = (V & 4042322160) >>> 4 | (V & 252645135) << 4;\n          V = (V & 4278255360) >>> 8 | (V & 16711935) << 8;\n          N.r[R] = (V >>> 16 | V << 16) >>> 17;\n        }\n        function n(A, l, M) {\n          while (l-- != 0) A.push(0, M);\n        }\n        for (var R = 0; R < 32; R++) {\n          N.q[R] = N.S[R] << 3 | N.T[R];\n          N.c[R] = N.p[R] << 4 | N.z[R];\n        }\n        n(N._, 144, 8);\n        n(N._, 255 - 143, 9);\n        n(N._, 279 - 255, 7);\n        n(N._, 287 - 279, 8);\n        H.H.n(N._, 9);\n        H.H.A(N._, 9, N.J);\n        H.H.l(N._, 9);\n        n(N.$, 32, 5);\n        H.H.n(N.$, 5);\n        H.H.A(N.$, 5, N.h);\n        H.H.l(N.$, 5);\n        n(N.Q, 19, 0);\n        n(N.C, 286, 0);\n        n(N.D, 30, 0);\n        n(N.v, 320, 0);\n      })();\n      return H.H.N;\n    }();\n    UTIF.LosslessJpegDecode = function () {\n      var b, O;\n      function l() {\n        return b[O++];\n      }\n      function m() {\n        return b[O++] << 8 | b[O++];\n      }\n      function a0(h) {\n        var V = l(),\n          I = [0, 0, 0, 255],\n          f = [],\n          G = 8;\n        for (var w = 0; w < 16; w++) f[w] = l();\n        for (var w = 0; w < 16; w++) {\n          for (var x = 0; x < f[w]; x++) {\n            var T = z(I, 0, w + 1, 1);\n            I[T + 3] = l();\n          }\n        }\n        var E = new Uint8Array(1 << G);\n        h[V] = [new Uint8Array(I), E];\n        for (var w = 0; w < 1 << G; w++) {\n          var s = G,\n            _ = w,\n            Y = 0,\n            F = 0;\n          while (I[Y + 3] == 255 && s != 0) {\n            F = _ >> --s & 1;\n            Y = I[Y + F];\n          }\n          E[w] = Y;\n        }\n      }\n      function z(h, V, I, f) {\n        if (h[V + 3] != 255) return 0;\n        if (I == 0) return V;\n        for (var w = 0; w < 2; w++) {\n          if (h[V + w] == 0) {\n            h[V + w] = h.length;\n            h.push(0, 0, f, 255);\n          }\n          var x = z(h, h[V + w], I - 1, f + 1);\n          if (x != 0) return x;\n        }\n        return 0;\n      }\n      function i(h) {\n        var V = h.b,\n          I = h.f;\n        while (V < 25 && h.a < h.d) {\n          var f = h.data[h.a++];\n          if (f == 255 && !h.c) h.a++;\n          I = I << 8 | f;\n          V += 8;\n        }\n        if (V < 0) throw \"e\";\n        h.b = V;\n        h.f = I;\n      }\n      function H(h, V) {\n        if (V.b < h) i(V);\n        return V.f >> (V.b -= h) & 65535 >> 16 - h;\n      }\n      function g(h, V) {\n        var I = h[0],\n          f = 0,\n          w = 255,\n          x = 0;\n        if (V.b < 16) i(V);\n        var T = V.f >> V.b - 8 & 255;\n        f = h[1][T];\n        w = I[f + 3];\n        V.b -= I[f + 2];\n        while (w == 255) {\n          x = V.f >> --V.b & 1;\n          f = I[f + x];\n          w = I[f + 3];\n        }\n        return w;\n      }\n      function P(h, V) {\n        if (h < 32768 >> 16 - V) h += -(1 << V) + 1;\n        return h;\n      }\n      function a2(h, V) {\n        var I = g(h, V);\n        if (I == 0) return 0;\n        if (I == 16) return -32768;\n        var f = H(I, V);\n        return P(f, I);\n      }\n      function X(h, V, I, f, w, x) {\n        var T = 0;\n        for (var G = 0; G < x; G++) {\n          var s = G * V;\n          for (var _ = 0; _ < V; _ += w) {\n            T++;\n            for (var Y = 0; Y < w; Y++) h[s + _ + Y] = a2(f[Y], I);\n          }\n          if (I.e != 0 && T % I.e == 0 && G != 0) {\n            var F = I.a,\n              t = I.data;\n            while (t[F] != 255 || !(208 <= t[F + 1] && t[F + 1] <= 215)) F--;\n            I.a = F + 2;\n            I.f = 0;\n            I.b = 0;\n          }\n        }\n      }\n      function o(h, V) {\n        return P(H(h, V), h);\n      }\n      function a1(h, V, I, f, w) {\n        var x = b.length - O;\n        for (var T = 0; T < x; T += 4) {\n          var G = b[O + T];\n          b[O + T] = b[O + T + 3];\n          b[O + T + 3] = G;\n          var G = b[O + T + 1];\n          b[O + T + 1] = b[O + T + 2];\n          b[O + T + 2] = G;\n        }\n        for (var E = 0; E < w; E++) {\n          var s = 32768,\n            _ = 32768;\n          for (var Y = 0; Y < V; Y += 2) {\n            var F = g(f, I),\n              t = g(f, I);\n            if (F != 0) s += o(F, I);\n            if (t != 0) _ += o(t, I);\n            h[E * V + Y] = s & 65535;\n            h[E * V + Y + 1] = _ & 65535;\n          }\n        }\n      }\n      function C(h) {\n        b = h;\n        O = 0;\n        if (m() != 65496) throw \"e\";\n        var V = [],\n          I = 0,\n          f = 0,\n          w = 0,\n          x = [],\n          T = [],\n          G = [],\n          E = 0,\n          s = 0,\n          _ = 0;\n        while (!0) {\n          var Y = m();\n          if (Y == 65535) {\n            O--;\n            continue;\n          }\n          var F = m();\n          if (Y == 65475) {\n            f = l();\n            s = m();\n            _ = m();\n            E = l();\n            for (var t = 0; t < E; t++) {\n              var a = l(),\n                J = l(),\n                r = l();\n              if (r != 0) throw \"e\";\n              V[a] = [t, J >> 4, J & 15];\n            }\n          } else if (Y == 65476) {\n            var a3 = O + F - 2;\n            while (O < a3) a0(T);\n          } else if (Y == 65498) {\n            O++;\n            for (var t = 0; t < E; t++) {\n              var a5 = l(),\n                v = V[a5];\n              G[v[0]] = T[l() >>> 4];\n              x[v[0]] = v.slice(1);\n            }\n            I = l();\n            O += 2;\n            break;\n          } else if (Y == 65501) {\n            w = m();\n          } else {\n            O += F - 2;\n          }\n        }\n        var a4 = f > 8 ? Uint16Array : Uint8Array,\n          $ = new a4(s * _ * E),\n          M = {\n            b: 0,\n            f: 0,\n            c: I == 8,\n            a: O,\n            data: b,\n            d: b.length,\n            e: w\n          };\n        if (M.c) a1($, _ * E, M, G[0], s);else {\n          var c = [],\n            p = 0,\n            D = 0;\n          for (var t = 0; t < E; t++) {\n            var N = x[t],\n              S = N[0],\n              K = N[1];\n            if (S > p) p = S;\n            if (K > D) D = K;\n            c.push(S * K);\n          }\n          if (p != 1 || D != 1) {\n            if (E != 3 || c[1] != 1 || c[2] != 1) throw \"e\";\n            if (p != 2 || D != 1 && D != 2) throw \"e\";\n            var u = [],\n              Z = 0;\n            for (var t = 0; t < E; t++) {\n              for (var R = 0; R < c[t]; R++) u.push(G[t]);\n              Z += c[t];\n            }\n            var B = _ / p,\n              e = s / D,\n              d = B * e;\n            X($, B * Z, M, u, Z, e);\n            j($, I, B, e, Z - 2, Z, Z, f);\n            var A = new Uint16Array(d * c[0]);\n            if (p == 2 && D == 2) {\n              for (var t = 0; t < d; t++) {\n                A[4 * t] = $[6 * t];\n                A[4 * t + 1] = $[6 * t + 1];\n                A[4 * t + 2] = $[6 * t + 2];\n                A[4 * t + 3] = $[6 * t + 3];\n              }\n              j(A, I, B * 4, e, 0, 1, 1, f);\n              for (var t = 0; t < d; t++) {\n                $[6 * t] = A[4 * t];\n                $[6 * t + 1] = A[4 * t + 1];\n                $[6 * t + 2] = A[4 * t + 2];\n                $[6 * t + 3] = A[4 * t + 3];\n              }\n            }\n            if (p == 2 && D == 1) {\n              for (var t = 0; t < d; t++) {\n                A[2 * t] = $[4 * t];\n                A[2 * t + 1] = $[4 * t + 1];\n              }\n              j(A, I, B * 2, e, 0, 1, 1, f);\n              for (var t = 0; t < d; t++) {\n                $[4 * t] = A[2 * t];\n                $[4 * t + 1] = A[2 * t + 1];\n              }\n            }\n            var n = $.slice(0);\n            for (var K = 0; K < s; K++) {\n              if (D == 2) for (var S = 0; S < _; S++) {\n                var q = (K * _ + S) * E,\n                  k = ((K >>> 1) * B + (S >>> 1)) * Z,\n                  y = (K & 1) * 2 + (S & 1);\n                $[q] = n[k + y];\n                $[q + 1] = n[k + 4];\n                $[q + 2] = n[k + 5];\n              } else for (var S = 0; S < _; S++) {\n                var q = (K * _ + S) * E,\n                  k = (K * B + (S >>> 1)) * Z,\n                  y = S & 1;\n                $[q] = n[k + y];\n                $[q + 1] = n[k + 2];\n                $[q + 2] = n[k + 3];\n              }\n            }\n          } else {\n            X($, _ * E, M, G, E, s);\n            if (w == 0) j($, I, _, s, 0, E, E, f);else {\n              var U = Math.floor(w / _);\n              for (var K = 0; K < s; K += U) {\n                var L = $.slice(K * _ * E, (K + U) * _ * E);\n                j(L, I, _, U, 0, E, E, f);\n                $.set(L, K * _ * E);\n              }\n            }\n          }\n        }\n        return $;\n      }\n      function j(h, V, I, f, w, x, G, E) {\n        var s = I * G;\n        for (var _ = w; _ < x; _++) h[_] += 1 << E - 1;\n        for (var Y = G; Y < s; Y += G) for (var _ = w; _ < x; _++) h[Y + _] += h[Y + _ - G];\n        for (var F = 1; F < f; F++) {\n          var t = F * s;\n          for (var _ = w; _ < x; _++) h[t + _] += h[t + _ - s];\n          for (var Y = G; Y < s; Y += G) {\n            for (var _ = w; _ < x; _++) {\n              var a = t + Y + _,\n                J = a - s,\n                r = h[a - G],\n                Q = 0;\n              if (V == 0) Q = 0;else if (V == 1) Q = r;else if (V == 2) Q = h[J];else if (V == 3) Q = h[J - G];else if (V == 4) Q = r + (h[J] - h[J - G]);else if (V == 5) Q = r + (h[J] - h[J - G] >>> 1);else if (V == 6) Q = h[J] + (r - h[J - G] >>> 1);else if (V == 7) Q = r + h[J] >>> 1;else throw V;\n              h[a] += Q;\n            }\n          }\n        }\n      }\n      return C;\n    }();\n    (function () {\n      var G = 0,\n        F = 1,\n        i = 2,\n        b = 3,\n        J = 4,\n        N = 5,\n        E = 6,\n        s = 7,\n        c = 8,\n        T = 9,\n        a3 = 10,\n        f = 11,\n        q = 12,\n        M = 13,\n        m = 14,\n        x = 15,\n        L = 16,\n        $ = 17,\n        p = 18;\n      function a5(t) {\n        var Z = UTIF._binBE.readUshort,\n          u = {\n            b: Z(t, 0),\n            i: t[2],\n            C: t[3],\n            u: t[4],\n            q: Z(t, 5),\n            k: Z(t, 7),\n            e: Z(t, 9),\n            l: Z(t, 11),\n            s: t[13],\n            d: Z(t, 14)\n          };\n        if (u.b != 18771 || u.i > 1 || u.q < 6 || u.q % 6 || u.e < 768 || u.e % 24 || u.l != 768 || u.k < u.l || u.k % u.l || u.k - u.e >= u.l || u.s > 16 || u.s != u.k / u.l || u.s != Math.ceil(u.e / u.l) || u.d != u.q / 6 || u.u != 12 && u.u != 14 && u.u != 16 || u.C != 16 && u.C != 0) {\n          throw \"Invalid data\";\n        }\n        if (u.i == 0) {\n          throw \"Not implemented. We need this file!\";\n        }\n        u.h = u.C == 16;\n        u.m = (u.h ? u.l * 2 / 3 : u.l >>> 1) | 0;\n        u.A = u.m + 2;\n        u.f = 64;\n        u.g = (1 << u.u) - 1;\n        u.n = 4 * u.u;\n        return u;\n      }\n      function a7(t, Z) {\n        var u = new Array(Z.s),\n          e = 4 * Z.s,\n          Q = 16 + e;\n        if (e & 12) Q += 16 - (e & 12);\n        for (var V = 0, O = 16; V < Z.s; O += 4) {\n          var o = UTIF._binBE.readUint(t, O);\n          u[V] = t.slice(Q, Q + o);\n          u[V].j = 0;\n          u[V].a = 0;\n          Q += o;\n          V++;\n        }\n        if (Q != t.length) throw \"Invalid data\";\n        return u;\n      }\n      function a6(t, Z) {\n        for (var u = -Z[4], e = 0; u <= Z[4]; e++, u++) {\n          t[e] = u <= -Z[3] ? -4 : u <= -Z[2] ? -3 : u <= -Z[1] ? -2 : u < -Z[0] ? -1 : u <= Z[0] ? 0 : u < Z[1] ? 1 : u < Z[2] ? 2 : u < Z[3] ? 3 : 4;\n        }\n      }\n      function a1(t, Z, u) {\n        var e = [Z, 3 * Z + 18, 5 * Z + 67, 7 * Z + 276, u];\n        t.o = Z;\n        t.w = (e[4] + 2 * Z) / (2 * Z + 1) + 1 | 0;\n        t.v = Math.ceil(Math.log2(t.w));\n        t.t = 9;\n        a6(t.c, e);\n      }\n      function a2(t) {\n        var Z = {\n          c: new Int8Array(2 << t.u)\n        };\n        a1(Z, 0, t.g);\n        return Z;\n      }\n      function D(t) {\n        var Z = [[], [], []],\n          u = Math.max(2, t.w + 32 >>> 6);\n        for (var e = 0; e < 3; e++) {\n          for (var Q = 0; Q < 41; Q++) {\n            Z[e][Q] = [u, 1];\n          }\n        }\n        return Z;\n      }\n      function a4(t) {\n        for (var Z = -1, u = 0; !u; Z++) {\n          u = t[t.j] >>> 7 - t.a & 1;\n          t.a++;\n          t.a &= 7;\n          if (!t.a) t.j++;\n        }\n        return Z;\n      }\n      function K(t, Z) {\n        var u = 0,\n          e = 8 - t.a,\n          Q = t.j,\n          V = t.a;\n        if (Z) {\n          if (Z >= e) {\n            do {\n              u <<= e;\n              Z -= e;\n              u |= t[t.j] & (1 << e) - 1;\n              t.j++;\n              e = 8;\n            } while (Z >= 8);\n          }\n          if (Z) {\n            u <<= Z;\n            e -= Z;\n            u |= t[t.j] >>> e & (1 << Z) - 1;\n          }\n          t.a = 8 - e;\n        }\n        return u;\n      }\n      function a0(t, Z) {\n        var u = 0;\n        if (Z < t) {\n          while (u <= 14 && Z << ++u < t);\n        }\n        return u;\n      }\n      function r(t, Z, u, e, Q, V, O, o) {\n        if (o == null) o = 0;\n        var X = V + 1,\n          k = X % 2,\n          j = 0,\n          I = 0,\n          a = 0,\n          l,\n          R,\n          w = e[Q],\n          S = e[Q - 1],\n          H = e[Q - 2][X],\n          g = S[X - 1],\n          Y = S[X],\n          P = S[X + 1],\n          A = w[X - 1],\n          v = w[X + 1],\n          y = Math.abs,\n          d,\n          C,\n          n,\n          h;\n        if (k) {\n          d = y(P - Y);\n          C = y(H - Y);\n          n = y(g - Y);\n        }\n        if (k) {\n          h = d > n && C < d ? H + g : d < n && C < n ? H + P : P + g;\n          h = h + 2 * Y >>> 2;\n          if (o) {\n            w[X] = h;\n            return;\n          }\n          l = Z.t * Z.c[t.g + Y - H] + Z.c[t.g + g - Y];\n        } else {\n          h = Y > g && Y > P || Y < g && Y < P ? v + A + 2 * Y >>> 2 : A + v >>> 1;\n          l = Z.t * Z.c[t.g + Y - g] + Z.c[t.g + g - A];\n        }\n        R = y(l);\n        var W = a4(u);\n        if (W < t.n - Z.v - 1) {\n          var z = a0(O[R][0], O[R][1]);\n          a = K(u, z) + (W << z);\n        } else {\n          a = K(u, Z.v) + 1;\n        }\n        a = a & 1 ? -1 - (a >>> 1) : a >>> 1;\n        O[R][0] += y(a);\n        if (O[R][1] == t.f) {\n          O[R][0] >>>= 1;\n          O[R][1] >>>= 1;\n        }\n        O[R][1]++;\n        h = l < 0 ? h - a : h + a;\n        if (t.i) {\n          if (h < 0) h += Z.w;else if (h > t.g) h -= Z.w;\n        }\n        w[X] = h >= 0 ? Math.min(h, t.g) : 0;\n      }\n      function U(t, Z, u) {\n        var e = t[0].length;\n        for (var Q = Z; Q <= u; Q++) {\n          t[Q][0] = t[Q - 1][1];\n          t[Q][e - 1] = t[Q - 1][e - 2];\n        }\n      }\n      function B(t) {\n        U(t, s, q);\n        U(t, i, J);\n        U(t, x, $);\n      }\n      function _(t, Z, u, e, Q, V, O, o, X, k, j, I, a) {\n        var l = 0,\n          R = 1,\n          w = Q < M && Q > J;\n        while (R < t.m) {\n          if (l < t.m) {\n            r(t, Z, u, e, Q, l, O[X], t.h && (w && k || !w && (j || (l & I) == a)));\n            r(t, Z, u, e, V, l, O[X], t.h && (!w && k || w && (j || (l & I) == a)));\n            l += 2;\n          }\n          if (l > 8) {\n            r(t, Z, u, e, Q, R, o[X]);\n            r(t, Z, u, e, V, R, o[X]);\n            R += 2;\n          }\n        }\n        B(e);\n      }\n      function a8(t, Z, u, e, Q, V) {\n        _(t, Z, u, e, i, s, Q, V, 0, 0, 1, 0, 8);\n        _(t, Z, u, e, c, x, Q, V, 1, 0, 1, 0, 8);\n        _(t, Z, u, e, b, T, Q, V, 2, 1, 0, 3, 0);\n        _(t, Z, u, e, a3, L, Q, V, 0, 0, 0, 3, 2);\n        _(t, Z, u, e, J, f, Q, V, 1, 0, 0, 3, 2);\n        _(t, Z, u, e, q, $, Q, V, 2, 1, 0, 3, 0);\n      }\n      function a9(t, Z, u, e, Q, V) {\n        var O = V.length,\n          o = t.l;\n        if (Q + 1 == t.s) o = t.e - Q * t.l;\n        var X = 6 * t.e * e + Q * t.l;\n        for (var k = 0; k < 6; k++) {\n          for (var j = 0; j < o; j++) {\n            var I = V[k % O][j % O],\n              a;\n            if (I == 0) {\n              a = i + (k >>> 1);\n            } else if (I == 2) {\n              a = x + (k >>> 1);\n            } else {\n              a = s + k;\n            }\n            var l = t.h ? (j * 2 / 3 & 2147483646 | j % 3 & 1) + (j % 3 >>> 1) : j >>> 1;\n            Z[X + j] = u[a][l + 1];\n          }\n          X += t.e;\n        }\n      }\n      UTIF._decompressRAF = function (t, Z) {\n        var u = a5(t),\n          e = a7(t, u),\n          Q = a2(u),\n          V = new Int16Array(u.e * u.q);\n        if (Z == null) {\n          Z = u.h ? [[1, 1, 0, 1, 1, 2], [1, 1, 2, 1, 1, 0], [2, 0, 1, 0, 2, 1], [1, 1, 2, 1, 1, 0], [1, 1, 0, 1, 1, 2], [0, 2, 1, 2, 0, 1]] : [[0, 1], [3, 2]];\n        }\n        var O = [[G, b], [F, J], [N, f], [E, q], [M, L], [m, $]],\n          o = [];\n        for (var X = 0; X < p; X++) {\n          o[X] = new Uint16Array(u.A);\n        }\n        for (var k = 0; k < u.s; k++) {\n          var j = D(Q),\n            I = D(Q);\n          for (var X = 0; X < p; X++) {\n            for (var a = 0; a < u.A; a++) {\n              o[X][a] = 0;\n            }\n          }\n          for (var l = 0; l < u.d; l++) {\n            a8(u, Q, e[k], o, j, I);\n            for (var X = 0; X < 6; X++) {\n              for (var a = 0; a < u.A; a++) {\n                o[O[X][0]][a] = o[O[X][1]][a];\n              }\n            }\n            a9(u, V, o, l, k, Z);\n            for (var X = i; X < p; X++) {\n              if ([N, E, M, m].indexOf(X) == -1) {\n                for (var a = 0; a < u.A; a++) {\n                  o[X][a] = 0;\n                }\n              }\n            }\n            B(o);\n          }\n        }\n        return V;\n      };\n    })();\n  })(UTIF);\n})();\n\n//# sourceURL=webpack://bos-platform/./src/util/UTIF.js?");

/***/ }),

/***/ "../../node_modules/core-js/internals/math-sign.js":
/*!*********************************************************!*\
  !*** ../../node_modules/core-js/internals/math-sign.js ***!
  \*********************************************************/
/***/ (function(module) {

eval("// `Math.sign` method implementation\n// https://tc39.github.io/ecma262/#sec-math.sign\nmodule.exports = Math.sign || function sign(x) {\n  // eslint-disable-next-line no-self-compare\n  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;\n};\n\n\n//# sourceURL=webpack://bos-platform/../../node_modules/core-js/internals/math-sign.js?");

/***/ }),

/***/ "../../node_modules/core-js/modules/es.math.log2.js":
/*!**********************************************************!*\
  !*** ../../node_modules/core-js/modules/es.math.log2.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval("var $ = __webpack_require__(/*! ../internals/export */ \"../../node_modules/core-js/internals/export.js\");\n\nvar log = Math.log;\nvar LN2 = Math.LN2;\n\n// `Math.log2` method\n// https://tc39.github.io/ecma262/#sec-math.log2\n$({ target: 'Math', stat: true }, {\n  log2: function log2(x) {\n    return log(x) / LN2;\n  }\n});\n\n\n//# sourceURL=webpack://bos-platform/../../node_modules/core-js/modules/es.math.log2.js?");

/***/ }),

/***/ "../../node_modules/core-js/modules/es.math.sign.js":
/*!**********************************************************!*\
  !*** ../../node_modules/core-js/modules/es.math.sign.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval("var $ = __webpack_require__(/*! ../internals/export */ \"../../node_modules/core-js/internals/export.js\");\nvar sign = __webpack_require__(/*! ../internals/math-sign */ \"../../node_modules/core-js/internals/math-sign.js\");\n\n// `Math.sign` method\n// https://tc39.github.io/ecma262/#sec-math.sign\n$({ target: 'Math', stat: true }, {\n  sign: sign\n});\n\n\n//# sourceURL=webpack://bos-platform/../../node_modules/core-js/modules/es.math.sign.js?");

/***/ }),

/***/ "../../node_modules/core-js/modules/es.string.repeat.js":
/*!**************************************************************!*\
  !*** ../../node_modules/core-js/modules/es.string.repeat.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval("var $ = __webpack_require__(/*! ../internals/export */ \"../../node_modules/core-js/internals/export.js\");\nvar repeat = __webpack_require__(/*! ../internals/string-repeat */ \"../../node_modules/core-js/internals/string-repeat.js\");\n\n// `String.prototype.repeat` method\n// https://tc39.github.io/ecma262/#sec-string.prototype.repeat\n$({ target: 'String', proto: true }, {\n  repeat: repeat\n});\n\n\n//# sourceURL=webpack://bos-platform/../../node_modules/core-js/modules/es.string.repeat.js?");

/***/ }),

/***/ "../../node_modules/core-js/modules/es.typed-array.float32-array.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/core-js/modules/es.typed-array.float32-array.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval("var createTypedArrayConstructor = __webpack_require__(/*! ../internals/typed-array-constructor */ \"../../node_modules/core-js/internals/typed-array-constructor.js\");\n\n// `Float32Array` constructor\n// https://tc39.github.io/ecma262/#sec-typedarray-objects\ncreateTypedArrayConstructor('Float32', function (init) {\n  return function Float32Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n\n\n//# sourceURL=webpack://bos-platform/../../node_modules/core-js/modules/es.typed-array.float32-array.js?");

/***/ }),

/***/ "../../node_modules/core-js/modules/es.typed-array.float64-array.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/core-js/modules/es.typed-array.float64-array.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval("var createTypedArrayConstructor = __webpack_require__(/*! ../internals/typed-array-constructor */ \"../../node_modules/core-js/internals/typed-array-constructor.js\");\n\n// `Float64Array` constructor\n// https://tc39.github.io/ecma262/#sec-typedarray-objects\ncreateTypedArrayConstructor('Float64', function (init) {\n  return function Float64Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n\n\n//# sourceURL=webpack://bos-platform/../../node_modules/core-js/modules/es.typed-array.float64-array.js?");

/***/ }),

/***/ "../../node_modules/core-js/modules/es.typed-array.int16-array.js":
/*!************************************************************************!*\
  !*** ../../node_modules/core-js/modules/es.typed-array.int16-array.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval("var createTypedArrayConstructor = __webpack_require__(/*! ../internals/typed-array-constructor */ \"../../node_modules/core-js/internals/typed-array-constructor.js\");\n\n// `Int16Array` constructor\n// https://tc39.github.io/ecma262/#sec-typedarray-objects\ncreateTypedArrayConstructor('Int16', function (init) {\n  return function Int16Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n\n\n//# sourceURL=webpack://bos-platform/../../node_modules/core-js/modules/es.typed-array.int16-array.js?");

/***/ }),

/***/ "../../node_modules/core-js/modules/es.typed-array.int32-array.js":
/*!************************************************************************!*\
  !*** ../../node_modules/core-js/modules/es.typed-array.int32-array.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval("var createTypedArrayConstructor = __webpack_require__(/*! ../internals/typed-array-constructor */ \"../../node_modules/core-js/internals/typed-array-constructor.js\");\n\n// `Int32Array` constructor\n// https://tc39.github.io/ecma262/#sec-typedarray-objects\ncreateTypedArrayConstructor('Int32', function (init) {\n  return function Int32Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n\n\n//# sourceURL=webpack://bos-platform/../../node_modules/core-js/modules/es.typed-array.int32-array.js?");

/***/ }),

/***/ "../../node_modules/core-js/modules/es.typed-array.int8-array.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/core-js/modules/es.typed-array.int8-array.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval("var createTypedArrayConstructor = __webpack_require__(/*! ../internals/typed-array-constructor */ \"../../node_modules/core-js/internals/typed-array-constructor.js\");\n\n// `Int8Array` constructor\n// https://tc39.github.io/ecma262/#sec-typedarray-objects\ncreateTypedArrayConstructor('Int8', function (init) {\n  return function Int8Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n\n\n//# sourceURL=webpack://bos-platform/../../node_modules/core-js/modules/es.typed-array.int8-array.js?");

/***/ }),

/***/ "../../node_modules/core-js/modules/es.typed-array.uint16-array.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/core-js/modules/es.typed-array.uint16-array.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval("var createTypedArrayConstructor = __webpack_require__(/*! ../internals/typed-array-constructor */ \"../../node_modules/core-js/internals/typed-array-constructor.js\");\n\n// `Uint16Array` constructor\n// https://tc39.github.io/ecma262/#sec-typedarray-objects\ncreateTypedArrayConstructor('Uint16', function (init) {\n  return function Uint16Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n\n\n//# sourceURL=webpack://bos-platform/../../node_modules/core-js/modules/es.typed-array.uint16-array.js?");

/***/ }),

/***/ "../../node_modules/core-js/modules/es.typed-array.uint32-array.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/core-js/modules/es.typed-array.uint32-array.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval("var createTypedArrayConstructor = __webpack_require__(/*! ../internals/typed-array-constructor */ \"../../node_modules/core-js/internals/typed-array-constructor.js\");\n\n// `Uint32Array` constructor\n// https://tc39.github.io/ecma262/#sec-typedarray-objects\ncreateTypedArrayConstructor('Uint32', function (init) {\n  return function Uint32Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n\n\n//# sourceURL=webpack://bos-platform/../../node_modules/core-js/modules/es.typed-array.uint32-array.js?");

/***/ }),

/***/ "../../node_modules/core-js/modules/es.typed-array.uint8-clamped-array.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/core-js/modules/es.typed-array.uint8-clamped-array.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval("var createTypedArrayConstructor = __webpack_require__(/*! ../internals/typed-array-constructor */ \"../../node_modules/core-js/internals/typed-array-constructor.js\");\n\n// `Uint8ClampedArray` constructor\n// https://tc39.github.io/ecma262/#sec-typedarray-objects\ncreateTypedArrayConstructor('Uint8', function (init) {\n  return function Uint8ClampedArray(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n}, true);\n\n\n//# sourceURL=webpack://bos-platform/../../node_modules/core-js/modules/es.typed-array.uint8-clamped-array.js?");

/***/ })

}]);