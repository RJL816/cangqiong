/*!
 * kderd
 * @version 2.1.0 | Thu Nov 25 2021
 * @author azer<linguoren@kingdee. com>
 * @license MIT
 */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.kderd = {}));
}(this, (function (exports) { 'use strict';

    /**
     * The Ease class provides a collection of easing functions for use with tween.js.
     */
    var Easing = {
        Linear: {
            None: function (amount) {
                return amount;
            },
        },
        Quadratic: {
            In: function (amount) {
                return amount * amount;
            },
            Out: function (amount) {
                return amount * (2 - amount);
            },
            InOut: function (amount) {
                if ((amount *= 2) < 1) {
                    return 0.5 * amount * amount;
                }
                return -0.5 * (--amount * (amount - 2) - 1);
            },
        },
        Cubic: {
            In: function (amount) {
                return amount * amount * amount;
            },
            Out: function (amount) {
                return --amount * amount * amount + 1;
            },
            InOut: function (amount) {
                if ((amount *= 2) < 1) {
                    return 0.5 * amount * amount * amount;
                }
                return 0.5 * ((amount -= 2) * amount * amount + 2);
            },
        },
        Quartic: {
            In: function (amount) {
                return amount * amount * amount * amount;
            },
            Out: function (amount) {
                return 1 - --amount * amount * amount * amount;
            },
            InOut: function (amount) {
                if ((amount *= 2) < 1) {
                    return 0.5 * amount * amount * amount * amount;
                }
                return -0.5 * ((amount -= 2) * amount * amount * amount - 2);
            },
        },
        Quintic: {
            In: function (amount) {
                return amount * amount * amount * amount * amount;
            },
            Out: function (amount) {
                return --amount * amount * amount * amount * amount + 1;
            },
            InOut: function (amount) {
                if ((amount *= 2) < 1) {
                    return 0.5 * amount * amount * amount * amount * amount;
                }
                return 0.5 * ((amount -= 2) * amount * amount * amount * amount + 2);
            },
        },
        Sinusoidal: {
            In: function (amount) {
                return 1 - Math.cos((amount * Math.PI) / 2);
            },
            Out: function (amount) {
                return Math.sin((amount * Math.PI) / 2);
            },
            InOut: function (amount) {
                return 0.5 * (1 - Math.cos(Math.PI * amount));
            },
        },
        Exponential: {
            In: function (amount) {
                return amount === 0 ? 0 : Math.pow(1024, amount - 1);
            },
            Out: function (amount) {
                return amount === 1 ? 1 : 1 - Math.pow(2, -10 * amount);
            },
            InOut: function (amount) {
                if (amount === 0) {
                    return 0;
                }
                if (amount === 1) {
                    return 1;
                }
                if ((amount *= 2) < 1) {
                    return 0.5 * Math.pow(1024, amount - 1);
                }
                return 0.5 * (-Math.pow(2, -10 * (amount - 1)) + 2);
            },
        },
        Circular: {
            In: function (amount) {
                return 1 - Math.sqrt(1 - amount * amount);
            },
            Out: function (amount) {
                return Math.sqrt(1 - --amount * amount);
            },
            InOut: function (amount) {
                if ((amount *= 2) < 1) {
                    return -0.5 * (Math.sqrt(1 - amount * amount) - 1);
                }
                return 0.5 * (Math.sqrt(1 - (amount -= 2) * amount) + 1);
            },
        },
        Elastic: {
            In: function (amount) {
                if (amount === 0) {
                    return 0;
                }
                if (amount === 1) {
                    return 1;
                }
                return -Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);
            },
            Out: function (amount) {
                if (amount === 0) {
                    return 0;
                }
                if (amount === 1) {
                    return 1;
                }
                return Math.pow(2, -10 * amount) * Math.sin((amount - 0.1) * 5 * Math.PI) + 1;
            },
            InOut: function (amount) {
                if (amount === 0) {
                    return 0;
                }
                if (amount === 1) {
                    return 1;
                }
                amount *= 2;
                if (amount < 1) {
                    return -0.5 * Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);
                }
                return 0.5 * Math.pow(2, -10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI) + 1;
            },
        },
        Back: {
            In: function (amount) {
                var s = 1.70158;
                return amount * amount * ((s + 1) * amount - s);
            },
            Out: function (amount) {
                var s = 1.70158;
                return --amount * amount * ((s + 1) * amount + s) + 1;
            },
            InOut: function (amount) {
                var s = 1.70158 * 1.525;
                if ((amount *= 2) < 1) {
                    return 0.5 * (amount * amount * ((s + 1) * amount - s));
                }
                return 0.5 * ((amount -= 2) * amount * ((s + 1) * amount + s) + 2);
            },
        },
        Bounce: {
            In: function (amount) {
                return 1 - Easing.Bounce.Out(1 - amount);
            },
            Out: function (amount) {
                if (amount < 1 / 2.75) {
                    return 7.5625 * amount * amount;
                }
                else if (amount < 2 / 2.75) {
                    return 7.5625 * (amount -= 1.5 / 2.75) * amount + 0.75;
                }
                else if (amount < 2.5 / 2.75) {
                    return 7.5625 * (amount -= 2.25 / 2.75) * amount + 0.9375;
                }
                else {
                    return 7.5625 * (amount -= 2.625 / 2.75) * amount + 0.984375;
                }
            },
            InOut: function (amount) {
                if (amount < 0.5) {
                    return Easing.Bounce.In(amount * 2) * 0.5;
                }
                return Easing.Bounce.Out(amount * 2 - 1) * 0.5 + 0.5;
            },
        },
    };

    var now;
    // Include a performance.now polyfill.
    // In node.js, use process.hrtime.
    // eslint-disable-next-line
    // @ts-ignore
    if (typeof self === 'undefined' && typeof process !== 'undefined' && process.hrtime) {
        now = function () {
            // eslint-disable-next-line
            // @ts-ignore
            var time = process.hrtime();
            // Convert [seconds, nanoseconds] to milliseconds.
            return time[0] * 1000 + time[1] / 1000000;
        };
    }
    // In a browser, use self.performance.now if it is available.
    else if (typeof self !== 'undefined' && self.performance !== undefined && self.performance.now !== undefined) {
        // This must be bound, because directly assigning this function
        // leads to an invocation exception in Chrome.
        now = self.performance.now.bind(self.performance);
    }
    // Use Date.now if it is available.
    else if (Date.now !== undefined) {
        now = Date.now;
    }
    // Otherwise, use 'new Date().getTime()'.
    else {
        now = function () {
            return new Date().getTime();
        };
    }
    var now$1 = now;

    /**
     * Controlling groups of tweens
     *
     * Using the TWEEN singleton to manage your tweens can cause issues in large apps with many components.
     * In these cases, you may want to create your own smaller groups of tween
     */
    var Group = /** @class */ (function () {
        function Group() {
            this._tweens = {};
            this._tweensAddedDuringUpdate = {};
        }
        Group.prototype.getAll = function () {
            var _this = this;
            return Object.keys(this._tweens).map(function (tweenId) {
                return _this._tweens[tweenId];
            });
        };
        Group.prototype.removeAll = function () {
            this._tweens = {};
        };
        Group.prototype.add = function (tween) {
            this._tweens[tween.getId()] = tween;
            this._tweensAddedDuringUpdate[tween.getId()] = tween;
        };
        Group.prototype.remove = function (tween) {
            delete this._tweens[tween.getId()];
            delete this._tweensAddedDuringUpdate[tween.getId()];
        };
        Group.prototype.update = function (time, preserve) {
            if (time === void 0) { time = now$1(); }
            if (preserve === void 0) { preserve = false; }
            var tweenIds = Object.keys(this._tweens);
            if (tweenIds.length === 0) {
                return false;
            }
            // Tweens are updated in "batches". If you add a new tween during an
            // update, then the new tween will be updated in the next batch.
            // If you remove a tween during an update, it may or may not be updated.
            // However, if the removed tween was added during the current batch,
            // then it will not be updated.
            while (tweenIds.length > 0) {
                this._tweensAddedDuringUpdate = {};
                for (var i = 0; i < tweenIds.length; i++) {
                    var tween = this._tweens[tweenIds[i]];
                    var autoStart = !preserve;
                    if (tween && tween.update(time, autoStart) === false && !preserve) {
                        delete this._tweens[tweenIds[i]];
                    }
                }
                tweenIds = Object.keys(this._tweensAddedDuringUpdate);
            }
            return true;
        };
        return Group;
    }());

    /**
     *
     */
    var Interpolation = {
        Linear: function (v, k) {
            var m = v.length - 1;
            var f = m * k;
            var i = Math.floor(f);
            var fn = Interpolation.Utils.Linear;
            if (k < 0) {
                return fn(v[0], v[1], f);
            }
            if (k > 1) {
                return fn(v[m], v[m - 1], m - f);
            }
            return fn(v[i], v[i + 1 > m ? m : i + 1], f - i);
        },
        Bezier: function (v, k) {
            var b = 0;
            var n = v.length - 1;
            var pw = Math.pow;
            var bn = Interpolation.Utils.Bernstein;
            for (var i = 0; i <= n; i++) {
                b += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);
            }
            return b;
        },
        CatmullRom: function (v, k) {
            var m = v.length - 1;
            var f = m * k;
            var i = Math.floor(f);
            var fn = Interpolation.Utils.CatmullRom;
            if (v[0] === v[m]) {
                if (k < 0) {
                    i = Math.floor((f = m * (1 + k)));
                }
                return fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);
            }
            else {
                if (k < 0) {
                    return v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);
                }
                if (k > 1) {
                    return v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);
                }
                return fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);
            }
        },
        Utils: {
            Linear: function (p0, p1, t) {
                return (p1 - p0) * t + p0;
            },
            Bernstein: function (n, i) {
                var fc = Interpolation.Utils.Factorial;
                return fc(n) / fc(i) / fc(n - i);
            },
            Factorial: (function () {
                var a = [1];
                return function (n) {
                    var s = 1;
                    if (a[n]) {
                        return a[n];
                    }
                    for (var i = n; i > 1; i--) {
                        s *= i;
                    }
                    a[n] = s;
                    return s;
                };
            })(),
            CatmullRom: function (p0, p1, p2, p3, t) {
                var v0 = (p2 - p0) * 0.5;
                var v1 = (p3 - p1) * 0.5;
                var t2 = t * t;
                var t3 = t * t2;
                return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
            },
        },
    };

    /**
     * Utils
     */
    var Sequence = /** @class */ (function () {
        function Sequence() {
        }
        Sequence.nextId = function () {
            return Sequence._nextId++;
        };
        Sequence._nextId = 0;
        return Sequence;
    }());

    var mainGroup = new Group();

    /**
     * Tween.js - Licensed under the MIT license
     * https://github.com/tweenjs/tween.js
     * ----------------------------------------------
     *
     * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.
     * Thank you all, you're awesome!
     */
    var Tween = /** @class */ (function () {
        function Tween(_object, _group) {
            if (_group === void 0) { _group = mainGroup; }
            this._object = _object;
            this._group = _group;
            this._isPaused = false;
            this._pauseStart = 0;
            this._valuesStart = {};
            this._valuesEnd = {};
            this._valuesStartRepeat = {};
            this._duration = 1000;
            this._initialRepeat = 0;
            this._repeat = 0;
            this._yoyo = false;
            this._isPlaying = false;
            this._reversed = false;
            this._delayTime = 0;
            this._startTime = 0;
            this._easingFunction = Easing.Linear.None;
            this._interpolationFunction = Interpolation.Linear;
            this._chainedTweens = [];
            this._onStartCallbackFired = false;
            this._id = Sequence.nextId();
            this._isChainStopped = false;
            this._goToEnd = false;
        }
        Tween.prototype.getId = function () {
            return this._id;
        };
        Tween.prototype.isPlaying = function () {
            return this._isPlaying;
        };
        Tween.prototype.isPaused = function () {
            return this._isPaused;
        };
        Tween.prototype.to = function (properties, duration) {
            // TODO? restore this, then update the 07_dynamic_to example to set fox
            // tween's to on each update. That way the behavior is opt-in (there's
            // currently no opt-out).
            // for (const prop in properties) this._valuesEnd[prop] = properties[prop]
            this._valuesEnd = Object.create(properties);
            if (duration !== undefined) {
                this._duration = duration;
            }
            return this;
        };
        Tween.prototype.duration = function (d) {
            this._duration = d;
            return this;
        };
        Tween.prototype.start = function (time) {
            if (this._isPlaying) {
                return this;
            }
            // eslint-disable-next-line
            this._group && this._group.add(this);
            this._repeat = this._initialRepeat;
            if (this._reversed) {
                // If we were reversed (f.e. using the yoyo feature) then we need to
                // flip the tween direction back to forward.
                this._reversed = false;
                for (var property in this._valuesStartRepeat) {
                    this._swapEndStartRepeatValues(property);
                    this._valuesStart[property] = this._valuesStartRepeat[property];
                }
            }
            this._isPlaying = true;
            this._isPaused = false;
            this._onStartCallbackFired = false;
            this._isChainStopped = false;
            this._startTime = time !== undefined ? (typeof time === 'string' ? now$1() + parseFloat(time) : time) : now$1();
            this._startTime += this._delayTime;
            this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat);
            return this;
        };
        Tween.prototype._setupProperties = function (_object, _valuesStart, _valuesEnd, _valuesStartRepeat) {
            for (var property in _valuesEnd) {
                var startValue = _object[property];
                var startValueIsArray = Array.isArray(startValue);
                var propType = startValueIsArray ? 'array' : typeof startValue;
                var isInterpolationList = !startValueIsArray && Array.isArray(_valuesEnd[property]);
                // If `to()` specifies a property that doesn't exist in the source object,
                // we should not set that property in the object
                if (propType === 'undefined' || propType === 'function') {
                    continue;
                }
                // Check if an Array was provided as property value
                if (isInterpolationList) {
                    var endValues = _valuesEnd[property];
                    if (endValues.length === 0) {
                        continue;
                    }
                    // handle an array of relative values
                    endValues = endValues.map(this._handleRelativeValue.bind(this, startValue));
                    // Create a local copy of the Array with the start value at the front
                    _valuesEnd[property] = [startValue].concat(endValues);
                }
                // handle the deepness of the values
                if ((propType === 'object' || startValueIsArray) && startValue && !isInterpolationList) {
                    _valuesStart[property] = startValueIsArray ? [] : {};
                    // eslint-disable-next-line
                    for (var prop in startValue) {
                        // eslint-disable-next-line
                        // @ts-ignore FIXME?
                        _valuesStart[property][prop] = startValue[prop];
                    }
                    _valuesStartRepeat[property] = startValueIsArray ? [] : {}; // TODO? repeat nested values? And yoyo? And array values?
                    // eslint-disable-next-line
                    // @ts-ignore FIXME?
                    this._setupProperties(startValue, _valuesStart[property], _valuesEnd[property], _valuesStartRepeat[property]);
                }
                else {
                    // Save the starting value, but only once.
                    if (typeof _valuesStart[property] === 'undefined') {
                        _valuesStart[property] = startValue;
                    }
                    if (!startValueIsArray) {
                        // eslint-disable-next-line
                        // @ts-ignore FIXME?
                        _valuesStart[property] *= 1.0; // Ensures we're using numbers, not strings
                    }
                    if (isInterpolationList) {
                        // eslint-disable-next-line
                        // @ts-ignore FIXME?
                        _valuesStartRepeat[property] = _valuesEnd[property].slice().reverse();
                    }
                    else {
                        _valuesStartRepeat[property] = _valuesStart[property] || 0;
                    }
                }
            }
        };
        Tween.prototype.stop = function () {
            if (!this._isChainStopped) {
                this._isChainStopped = true;
                this.stopChainedTweens();
            }
            if (!this._isPlaying) {
                return this;
            }
            // eslint-disable-next-line
            this._group && this._group.remove(this);
            this._isPlaying = false;
            this._isPaused = false;
            if (this._onStopCallback) {
                this._onStopCallback(this._object);
            }
            return this;
        };
        Tween.prototype.end = function () {
            this._goToEnd = true;
            this.update(Infinity);
            return this;
        };
        Tween.prototype.pause = function (time) {
            if (time === void 0) { time = now$1(); }
            if (this._isPaused || !this._isPlaying) {
                return this;
            }
            this._isPaused = true;
            this._pauseStart = time;
            // eslint-disable-next-line
            this._group && this._group.remove(this);
            return this;
        };
        Tween.prototype.resume = function (time) {
            if (time === void 0) { time = now$1(); }
            if (!this._isPaused || !this._isPlaying) {
                return this;
            }
            this._isPaused = false;
            this._startTime += time - this._pauseStart;
            this._pauseStart = 0;
            // eslint-disable-next-line
            this._group && this._group.add(this);
            return this;
        };
        Tween.prototype.stopChainedTweens = function () {
            for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
                this._chainedTweens[i].stop();
            }
            return this;
        };
        Tween.prototype.group = function (group) {
            this._group = group;
            return this;
        };
        Tween.prototype.delay = function (amount) {
            this._delayTime = amount;
            return this;
        };
        Tween.prototype.repeat = function (times) {
            this._initialRepeat = times;
            this._repeat = times;
            return this;
        };
        Tween.prototype.repeatDelay = function (amount) {
            this._repeatDelayTime = amount;
            return this;
        };
        Tween.prototype.yoyo = function (yoyo) {
            this._yoyo = yoyo;
            return this;
        };
        Tween.prototype.easing = function (easingFunction) {
            this._easingFunction = easingFunction;
            return this;
        };
        Tween.prototype.interpolation = function (interpolationFunction) {
            this._interpolationFunction = interpolationFunction;
            return this;
        };
        Tween.prototype.chain = function () {
            var tweens = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                tweens[_i] = arguments[_i];
            }
            this._chainedTweens = tweens;
            return this;
        };
        Tween.prototype.onStart = function (callback) {
            this._onStartCallback = callback;
            return this;
        };
        Tween.prototype.onUpdate = function (callback) {
            this._onUpdateCallback = callback;
            return this;
        };
        Tween.prototype.onRepeat = function (callback) {
            this._onRepeatCallback = callback;
            return this;
        };
        Tween.prototype.onComplete = function (callback) {
            this._onCompleteCallback = callback;
            return this;
        };
        Tween.prototype.onStop = function (callback) {
            this._onStopCallback = callback;
            return this;
        };
        /**
         * @returns true if the tween is still playing after the update, false
         * otherwise (calling update on a paused tween still returns true because
         * it is still playing, just paused).
         */
        Tween.prototype.update = function (time, autoStart) {
            if (time === void 0) { time = now$1(); }
            if (autoStart === void 0) { autoStart = true; }
            if (this._isPaused)
                return true;
            var property;
            var elapsed;
            var endTime = this._startTime + this._duration;
            if (!this._goToEnd && !this._isPlaying) {
                if (time > endTime)
                    return false;
                if (autoStart)
                    this.start(time);
            }
            this._goToEnd = false;
            if (time < this._startTime) {
                return true;
            }
            if (this._onStartCallbackFired === false) {
                if (this._onStartCallback) {
                    this._onStartCallback(this._object);
                }
                this._onStartCallbackFired = true;
            }
            elapsed = (time - this._startTime) / this._duration;
            elapsed = this._duration === 0 || elapsed > 1 ? 1 : elapsed;
            var value = this._easingFunction(elapsed);
            // properties transformations
            this._updateProperties(this._object, this._valuesStart, this._valuesEnd, value);
            if (this._onUpdateCallback) {
                this._onUpdateCallback(this._object, elapsed);
            }
            if (elapsed === 1) {
                if (this._repeat > 0) {
                    if (isFinite(this._repeat)) {
                        this._repeat--;
                    }
                    // Reassign starting values, restart by making startTime = now
                    for (property in this._valuesStartRepeat) {
                        if (!this._yoyo && typeof this._valuesEnd[property] === 'string') {
                            this._valuesStartRepeat[property] =
                                // eslint-disable-next-line
                                // @ts-ignore FIXME?
                                this._valuesStartRepeat[property] + parseFloat(this._valuesEnd[property]);
                        }
                        if (this._yoyo) {
                            this._swapEndStartRepeatValues(property);
                        }
                        this._valuesStart[property] = this._valuesStartRepeat[property];
                    }
                    if (this._yoyo) {
                        this._reversed = !this._reversed;
                    }
                    if (this._repeatDelayTime !== undefined) {
                        this._startTime = time + this._repeatDelayTime;
                    }
                    else {
                        this._startTime = time + this._delayTime;
                    }
                    if (this._onRepeatCallback) {
                        this._onRepeatCallback(this._object);
                    }
                    return true;
                }
                else {
                    if (this._onCompleteCallback) {
                        this._onCompleteCallback(this._object);
                    }
                    for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
                        // Make the chained tweens start exactly at the time they should,
                        // even if the `update()` method was called way past the duration of the tween
                        this._chainedTweens[i].start(this._startTime + this._duration);
                    }
                    this._isPlaying = false;
                    return false;
                }
            }
            return true;
        };
        Tween.prototype._updateProperties = function (_object, _valuesStart, _valuesEnd, value) {
            for (var property in _valuesEnd) {
                // Don't update properties that do not exist in the source object
                if (_valuesStart[property] === undefined) {
                    continue;
                }
                var start = _valuesStart[property] || 0;
                var end = _valuesEnd[property];
                var startIsArray = Array.isArray(_object[property]);
                var endIsArray = Array.isArray(end);
                var isInterpolationList = !startIsArray && endIsArray;
                if (isInterpolationList) {
                    _object[property] = this._interpolationFunction(end, value);
                }
                else if (typeof end === 'object' && end) {
                    // eslint-disable-next-line
                    // @ts-ignore FIXME?
                    this._updateProperties(_object[property], start, end, value);
                }
                else {
                    // Parses relative end values with start as base (e.g.: +10, -3)
                    end = this._handleRelativeValue(start, end);
                    // Protect against non numeric properties.
                    if (typeof end === 'number') {
                        // eslint-disable-next-line
                        // @ts-ignore FIXME?
                        _object[property] = start + (end - start) * value;
                    }
                }
            }
        };
        Tween.prototype._handleRelativeValue = function (start, end) {
            if (typeof end !== 'string') {
                return end;
            }
            if (end.charAt(0) === '+' || end.charAt(0) === '-') {
                return start + parseFloat(end);
            }
            else {
                return parseFloat(end);
            }
        };
        Tween.prototype._swapEndStartRepeatValues = function (property) {
            var tmp = this._valuesStartRepeat[property];
            var endValue = this._valuesEnd[property];
            if (typeof endValue === 'string') {
                this._valuesStartRepeat[property] = this._valuesStartRepeat[property] + parseFloat(endValue);
            }
            else {
                this._valuesStartRepeat[property] = this._valuesEnd[property];
            }
            this._valuesEnd[property] = tmp;
        };
        return Tween;
    }());

    var VERSION = '18.6.4';

    /**
     * Tween.js - Licensed under the MIT license
     * https://github.com/tweenjs/tween.js
     * ----------------------------------------------
     *
     * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.
     * Thank you all, you're awesome!
     */
    var nextId = Sequence.nextId;
    /**
     * Controlling groups of tweens
     *
     * Using the TWEEN singleton to manage your tweens can cause issues in large apps with many components.
     * In these cases, you may want to create your own smaller groups of tweens.
     */
    var TWEEN = mainGroup;
    // This is the best way to export things in a way that's compatible with both ES
    // Modules and CommonJS, without build hacks, and so as not to break the
    // existing API.
    // https://github.com/rollup/rollup/issues/1961#issuecomment-423037881
    var getAll = TWEEN.getAll.bind(TWEEN);
    var removeAll = TWEEN.removeAll.bind(TWEEN);
    var add = TWEEN.add.bind(TWEEN);
    var remove$2 = TWEEN.remove.bind(TWEEN);
    var update$2 = TWEEN.update.bind(TWEEN);
    var exports$1 = {
        Easing: Easing,
        Group: Group,
        Interpolation: Interpolation,
        now: now$1,
        Sequence: Sequence,
        nextId: nextId,
        Tween: Tween,
        VERSION: VERSION,
        getAll: getAll,
        removeAll: removeAll,
        add: add,
        remove: remove$2,
        update: update$2,
    };

    function animate(time) {
        requestAnimationFrame(animate);
        exports$1.update(time);
    }
    requestAnimationFrame(animate);

    var commonjsGlobal$1 = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function deepFreeze(obj) {
        if (obj instanceof Map) {
            obj.clear = obj.delete = obj.set = function () {
                throw new Error('map is read-only');
            };
        } else if (obj instanceof Set) {
            obj.add = obj.clear = obj.delete = function () {
                throw new Error('set is read-only');
            };
        }

        // Freeze self
        Object.freeze(obj);

        Object.getOwnPropertyNames(obj).forEach(function (name) {
            var prop = obj[name];

            // Freeze prop if it is an object
            if (typeof prop == 'object' && !Object.isFrozen(prop)) {
                deepFreeze(prop);
            }
        });

        return obj;
    }

    var deepFreezeEs6 = deepFreeze;
    var _default = deepFreeze;
    deepFreezeEs6.default = _default;

    /** @implements CallbackResponse */
    class Response {
      /**
       * @param {CompiledMode} mode
       */
      constructor(mode) {
        // eslint-disable-next-line no-undefined
        if (mode.data === undefined) mode.data = {};

        this.data = mode.data;
        this.isMatchIgnored = false;
      }

      ignoreMatch() {
        this.isMatchIgnored = true;
      }
    }

    /**
     * @param {string} value
     * @returns {string}
     */
    function escapeHTML(value) {
      return value
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#x27;');
    }

    /**
     * performs a shallow merge of multiple objects into one
     *
     * @template T
     * @param {T} original
     * @param {Record<string,any>[]} objects
     * @returns {T} a single new object
     */
    function inherit(original, ...objects) {
      /** @type Record<string,any> */
      const result = Object.create(null);

      for (const key in original) {
        result[key] = original[key];
      }
      objects.forEach(function(obj) {
        for (const key in obj) {
          result[key] = obj[key];
        }
      });
      return /** @type {T} */ (result);
    }

    /**
     * @typedef {object} Renderer
     * @property {(text: string) => void} addText
     * @property {(node: Node) => void} openNode
     * @property {(node: Node) => void} closeNode
     * @property {() => string} value
     */

    /** @typedef {{kind?: string, sublanguage?: boolean}} Node */
    /** @typedef {{walk: (r: Renderer) => void}} Tree */
    /** */

    const SPAN_CLOSE = '</span>';

    /**
     * Determines if a node needs to be wrapped in <span>
     *
     * @param {Node} node */
    const emitsWrappingTags = (node) => {
      return !!node.kind;
    };

    /** @type {Renderer} */
    class HTMLRenderer {
      /**
       * Creates a new HTMLRenderer
       *
       * @param {Tree} parseTree - the parse tree (must support `walk` API)
       * @param {{classPrefix: string}} options
       */
      constructor(parseTree, options) {
        this.buffer = "";
        this.classPrefix = options.classPrefix;
        parseTree.walk(this);
      }

      /**
       * Adds texts to the output stream
       *
       * @param {string} text */
      addText(text) {
        this.buffer += escapeHTML(text);
      }

      /**
       * Adds a node open to the output stream (if needed)
       *
       * @param {Node} node */
      openNode(node) {
        if (!emitsWrappingTags(node)) return;

        let className = node.kind;
        if (!node.sublanguage) {
          className = `${this.classPrefix}${className}`;
        }
        this.span(className);
      }

      /**
       * Adds a node close to the output stream (if needed)
       *
       * @param {Node} node */
      closeNode(node) {
        if (!emitsWrappingTags(node)) return;

        this.buffer += SPAN_CLOSE;
      }

      /**
       * returns the accumulated buffer
      */
      value() {
        return this.buffer;
      }

      // helpers

      /**
       * Builds a span element
       *
       * @param {string} className */
      span(className) {
        this.buffer += `<span class="${className}">`;
      }
    }

    /** @typedef {{kind?: string, sublanguage?: boolean, children: Node[]} | string} Node */
    /** @typedef {{kind?: string, sublanguage?: boolean, children: Node[]} } DataNode */
    /**  */

    class TokenTree {
      constructor() {
        /** @type DataNode */
        this.rootNode = { children: [] };
        this.stack = [this.rootNode];
      }

      get top() {
        return this.stack[this.stack.length - 1];
      }

      get root() { return this.rootNode; }

      /** @param {Node} node */
      add(node) {
        this.top.children.push(node);
      }

      /** @param {string} kind */
      openNode(kind) {
        /** @type Node */
        const node = { kind, children: [] };
        this.add(node);
        this.stack.push(node);
      }

      closeNode() {
        if (this.stack.length > 1) {
          return this.stack.pop();
        }
        // eslint-disable-next-line no-undefined
        return undefined;
      }

      closeAllNodes() {
        while (this.closeNode());
      }

      toJSON() {
        return JSON.stringify(this.rootNode, null, 4);
      }

      /**
       * @typedef { import("./html_renderer").Renderer } Renderer
       * @param {Renderer} builder
       */
      walk(builder) {
        // this does not
        return this.constructor._walk(builder, this.rootNode);
        // this works
        // return TokenTree._walk(builder, this.rootNode);
      }

      /**
       * @param {Renderer} builder
       * @param {Node} node
       */
      static _walk(builder, node) {
        if (typeof node === "string") {
          builder.addText(node);
        } else if (node.children) {
          builder.openNode(node);
          node.children.forEach((child) => this._walk(builder, child));
          builder.closeNode(node);
        }
        return builder;
      }

      /**
       * @param {Node} node
       */
      static _collapse(node) {
        if (typeof node === "string") return;
        if (!node.children) return;

        if (node.children.every(el => typeof el === "string")) {
          // node.text = node.children.join("");
          // delete node.children;
          node.children = [node.children.join("")];
        } else {
          node.children.forEach((child) => {
            TokenTree._collapse(child);
          });
        }
      }
    }

    /**
      Currently this is all private API, but this is the minimal API necessary
      that an Emitter must implement to fully support the parser.

      Minimal interface:

      - addKeyword(text, kind)
      - addText(text)
      - addSublanguage(emitter, subLanguageName)
      - finalize()
      - openNode(kind)
      - closeNode()
      - closeAllNodes()
      - toHTML()

    */

    /**
     * @implements {Emitter}
     */
    class TokenTreeEmitter extends TokenTree {
      /**
       * @param {*} options
       */
      constructor(options) {
        super();
        this.options = options;
      }

      /**
       * @param {string} text
       * @param {string} kind
       */
      addKeyword(text, kind) {
        if (text === "") { return; }

        this.openNode(kind);
        this.addText(text);
        this.closeNode();
      }

      /**
       * @param {string} text
       */
      addText(text) {
        if (text === "") { return; }

        this.add(text);
      }

      /**
       * @param {Emitter & {root: DataNode}} emitter
       * @param {string} name
       */
      addSublanguage(emitter, name) {
        /** @type DataNode */
        const node = emitter.root;
        node.kind = name;
        node.sublanguage = true;
        this.add(node);
      }

      toHTML() {
        const renderer = new HTMLRenderer(this, this.options);
        return renderer.value();
      }

      finalize() {
        return true;
      }
    }

    /**
     * @param {string} value
     * @returns {RegExp}
     * */
    function escape(value) {
      return new RegExp(value.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&'), 'm');
    }

    /**
     * @param {RegExp | string } re
     * @returns {string}
     */
    function source$2(re) {
      if (!re) return null;
      if (typeof re === "string") return re;

      return re.source;
    }

    /**
     * @param {...(RegExp | string) } args
     * @returns {string}
     */
    function concat$2(...args) {
      const joined = args.map((x) => source$2(x)).join("");
      return joined;
    }

    /**
     * Any of the passed expresssions may match
     *
     * Creates a huge this | this | that | that match
     * @param {(RegExp | string)[] } args
     * @returns {string}
     */
    function either$1(...args) {
      const joined = '(' + args.map((x) => source$2(x)).join("|") + ")";
      return joined;
    }

    /**
     * @param {RegExp} re
     * @returns {number}
     */
    function countMatchGroups(re) {
      return (new RegExp(re.toString() + '|')).exec('').length - 1;
    }

    /**
     * Does lexeme start with a regular expression match at the beginning
     * @param {RegExp} re
     * @param {string} lexeme
     */
    function startsWith(re, lexeme) {
      const match = re && re.exec(lexeme);
      return match && match.index === 0;
    }

    // BACKREF_RE matches an open parenthesis or backreference. To avoid
    // an incorrect parse, it additionally matches the following:
    // - [...] elements, where the meaning of parentheses and escapes change
    // - other escape sequences, so we do not misparse escape sequences as
    //   interesting elements
    // - non-matching or lookahead parentheses, which do not capture. These
    //   follow the '(' with a '?'.
    const BACKREF_RE = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;

    // join logically computes regexps.join(separator), but fixes the
    // backreferences so they continue to match.
    // it also places each individual regular expression into it's own
    // match group, keeping track of the sequencing of those match groups
    // is currently an exercise for the caller. :-)
    /**
     * @param {(string | RegExp)[]} regexps
     * @param {string} separator
     * @returns {string}
     */
    function join(regexps, separator = "|") {
      let numCaptures = 0;

      return regexps.map((regex) => {
        numCaptures += 1;
        const offset = numCaptures;
        let re = source$2(regex);
        let out = '';

        while (re.length > 0) {
          const match = BACKREF_RE.exec(re);
          if (!match) {
            out += re;
            break;
          }
          out += re.substring(0, match.index);
          re = re.substring(match.index + match[0].length);
          if (match[0][0] === '\\' && match[1]) {
            // Adjust the backreference.
            out += '\\' + String(Number(match[1]) + offset);
          } else {
            out += match[0];
            if (match[0] === '(') {
              numCaptures++;
            }
          }
        }
        return out;
      }).map(re => `(${re})`).join(separator);
    }

    // Common regexps
    const MATCH_NOTHING_RE = /\b\B/;
    const IDENT_RE$1 = '[a-zA-Z]\\w*';
    const UNDERSCORE_IDENT_RE = '[a-zA-Z_]\\w*';
    const NUMBER_RE = '\\b\\d+(\\.\\d+)?';
    const C_NUMBER_RE = '(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)'; // 0x..., 0..., decimal, float
    const BINARY_NUMBER_RE = '\\b(0b[01]+)'; // 0b...
    const RE_STARTERS_RE = '!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~';

    /**
    * @param { Partial<Mode> & {binary?: string | RegExp} } opts
    */
    const SHEBANG = (opts = {}) => {
      const beginShebang = /^#![ ]*\//;
      if (opts.binary) {
        opts.begin = concat$2(
          beginShebang,
          /.*\b/,
          opts.binary,
          /\b.*/);
      }
      return inherit({
        className: 'meta',
        begin: beginShebang,
        end: /$/,
        relevance: 0,
        /** @type {ModeCallback} */
        "on:begin": (m, resp) => {
          if (m.index !== 0) resp.ignoreMatch();
        }
      }, opts);
    };

    // Common modes
    const BACKSLASH_ESCAPE = {
      begin: '\\\\[\\s\\S]', relevance: 0
    };
    const APOS_STRING_MODE = {
      className: 'string',
      begin: '\'',
      end: '\'',
      illegal: '\\n',
      contains: [BACKSLASH_ESCAPE]
    };
    const QUOTE_STRING_MODE = {
      className: 'string',
      begin: '"',
      end: '"',
      illegal: '\\n',
      contains: [BACKSLASH_ESCAPE]
    };
    const PHRASAL_WORDS_MODE = {
      begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
    };
    /**
     * Creates a comment mode
     *
     * @param {string | RegExp} begin
     * @param {string | RegExp} end
     * @param {Mode | {}} [modeOptions]
     * @returns {Partial<Mode>}
     */
    const COMMENT = function(begin, end, modeOptions = {}) {
      const mode = inherit(
        {
          className: 'comment',
          begin,
          end,
          contains: []
        },
        modeOptions
      );
      mode.contains.push(PHRASAL_WORDS_MODE);
      mode.contains.push({
        className: 'doctag',
        begin: '(?:TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):',
        relevance: 0
      });
      return mode;
    };
    const C_LINE_COMMENT_MODE = COMMENT('//', '$');
    const C_BLOCK_COMMENT_MODE = COMMENT('/\\*', '\\*/');
    const HASH_COMMENT_MODE = COMMENT('#', '$');
    const NUMBER_MODE = {
      className: 'number',
      begin: NUMBER_RE,
      relevance: 0
    };
    const C_NUMBER_MODE = {
      className: 'number',
      begin: C_NUMBER_RE,
      relevance: 0
    };
    const BINARY_NUMBER_MODE = {
      className: 'number',
      begin: BINARY_NUMBER_RE,
      relevance: 0
    };
    const CSS_NUMBER_MODE = {
      className: 'number',
      begin: NUMBER_RE + '(' +
        '%|em|ex|ch|rem' +
        '|vw|vh|vmin|vmax' +
        '|cm|mm|in|pt|pc|px' +
        '|deg|grad|rad|turn' +
        '|s|ms' +
        '|Hz|kHz' +
        '|dpi|dpcm|dppx' +
        ')?',
      relevance: 0
    };
    const REGEXP_MODE = {
      // this outer rule makes sure we actually have a WHOLE regex and not simply
      // an expression such as:
      //
      //     3 / something
      //
      // (which will then blow up when regex's `illegal` sees the newline)
      begin: /(?=\/[^/\n]*\/)/,
      contains: [{
        className: 'regexp',
        begin: /\//,
        end: /\/[gimuy]*/,
        illegal: /\n/,
        contains: [
          BACKSLASH_ESCAPE,
          {
            begin: /\[/,
            end: /\]/,
            relevance: 0,
            contains: [BACKSLASH_ESCAPE]
          }
        ]
      }]
    };
    const TITLE_MODE = {
      className: 'title',
      begin: IDENT_RE$1,
      relevance: 0
    };
    const UNDERSCORE_TITLE_MODE = {
      className: 'title',
      begin: UNDERSCORE_IDENT_RE,
      relevance: 0
    };
    const METHOD_GUARD = {
      // excludes method names from keyword processing
      begin: '\\.\\s*' + UNDERSCORE_IDENT_RE,
      relevance: 0
    };

    /**
     * Adds end same as begin mechanics to a mode
     *
     * Your mode must include at least a single () match group as that first match
     * group is what is used for comparison
     * @param {Partial<Mode>} mode
     */
    const END_SAME_AS_BEGIN = function(mode) {
      return Object.assign(mode,
        {
          /** @type {ModeCallback} */
          'on:begin': (m, resp) => { resp.data._beginMatch = m[1]; },
          /** @type {ModeCallback} */
          'on:end': (m, resp) => { if (resp.data._beginMatch !== m[1]) resp.ignoreMatch(); }
        });
    };

    var MODES = /*#__PURE__*/Object.freeze({
        __proto__: null,
        MATCH_NOTHING_RE: MATCH_NOTHING_RE,
        IDENT_RE: IDENT_RE$1,
        UNDERSCORE_IDENT_RE: UNDERSCORE_IDENT_RE,
        NUMBER_RE: NUMBER_RE,
        C_NUMBER_RE: C_NUMBER_RE,
        BINARY_NUMBER_RE: BINARY_NUMBER_RE,
        RE_STARTERS_RE: RE_STARTERS_RE,
        SHEBANG: SHEBANG,
        BACKSLASH_ESCAPE: BACKSLASH_ESCAPE,
        APOS_STRING_MODE: APOS_STRING_MODE,
        QUOTE_STRING_MODE: QUOTE_STRING_MODE,
        PHRASAL_WORDS_MODE: PHRASAL_WORDS_MODE,
        COMMENT: COMMENT,
        C_LINE_COMMENT_MODE: C_LINE_COMMENT_MODE,
        C_BLOCK_COMMENT_MODE: C_BLOCK_COMMENT_MODE,
        HASH_COMMENT_MODE: HASH_COMMENT_MODE,
        NUMBER_MODE: NUMBER_MODE,
        C_NUMBER_MODE: C_NUMBER_MODE,
        BINARY_NUMBER_MODE: BINARY_NUMBER_MODE,
        CSS_NUMBER_MODE: CSS_NUMBER_MODE,
        REGEXP_MODE: REGEXP_MODE,
        TITLE_MODE: TITLE_MODE,
        UNDERSCORE_TITLE_MODE: UNDERSCORE_TITLE_MODE,
        METHOD_GUARD: METHOD_GUARD,
        END_SAME_AS_BEGIN: END_SAME_AS_BEGIN
    });

    // Grammar extensions / plugins
    // See: https://github.com/highlightjs/highlight.js/issues/2833

    // Grammar extensions allow "syntactic sugar" to be added to the grammar modes
    // without requiring any underlying changes to the compiler internals.

    // `compileMatch` being the perfect small example of now allowing a grammar
    // author to write `match` when they desire to match a single expression rather
    // than being forced to use `begin`.  The extension then just moves `match` into
    // `begin` when it runs.  Ie, no features have been added, but we've just made
    // the experience of writing (and reading grammars) a little bit nicer.

    // ------

    // TODO: We need negative look-behind support to do this properly
    /**
     * Skip a match if it has a preceding dot
     *
     * This is used for `beginKeywords` to prevent matching expressions such as
     * `bob.keyword.do()`. The mode compiler automatically wires this up as a
     * special _internal_ 'on:begin' callback for modes with `beginKeywords`
     * @param {RegExpMatchArray} match
     * @param {CallbackResponse} response
     */
    function skipIfhasPrecedingDot(match, response) {
      const before = match.input[match.index - 1];
      if (before === ".") {
        response.ignoreMatch();
      }
    }


    /**
     * `beginKeywords` syntactic sugar
     * @type {CompilerExt}
     */
    function beginKeywords(mode, parent) {
      if (!parent) return;
      if (!mode.beginKeywords) return;

      // for languages with keywords that include non-word characters checking for
      // a word boundary is not sufficient, so instead we check for a word boundary
      // or whitespace - this does no harm in any case since our keyword engine
      // doesn't allow spaces in keywords anyways and we still check for the boundary
      // first
      mode.begin = '\\b(' + mode.beginKeywords.split(' ').join('|') + ')(?!\\.)(?=\\b|\\s)';
      mode.__beforeBegin = skipIfhasPrecedingDot;
      mode.keywords = mode.keywords || mode.beginKeywords;
      delete mode.beginKeywords;

      // prevents double relevance, the keywords themselves provide
      // relevance, the mode doesn't need to double it
      // eslint-disable-next-line no-undefined
      if (mode.relevance === undefined) mode.relevance = 0;
    }

    /**
     * Allow `illegal` to contain an array of illegal values
     * @type {CompilerExt}
     */
    function compileIllegal(mode, _parent) {
      if (!Array.isArray(mode.illegal)) return;

      mode.illegal = either$1(...mode.illegal);
    }

    /**
     * `match` to match a single expression for readability
     * @type {CompilerExt}
     */
    function compileMatch(mode, _parent) {
      if (!mode.match) return;
      if (mode.begin || mode.end) throw new Error("begin & end are not supported with match");

      mode.begin = mode.match;
      delete mode.match;
    }

    /**
     * provides the default 1 relevance to all modes
     * @type {CompilerExt}
     */
    function compileRelevance(mode, _parent) {
      // eslint-disable-next-line no-undefined
      if (mode.relevance === undefined) mode.relevance = 1;
    }

    // keywords that should have no default relevance value
    const COMMON_KEYWORDS = [
      'of',
      'and',
      'for',
      'in',
      'not',
      'or',
      'if',
      'then',
      'parent', // common variable name
      'list', // common variable name
      'value' // common variable name
    ];

    const DEFAULT_KEYWORD_CLASSNAME = "keyword";

    /**
     * Given raw keywords from a language definition, compile them.
     *
     * @param {string | Record<string,string|string[]> | Array<string>} rawKeywords
     * @param {boolean} caseInsensitive
     */
    function compileKeywords(rawKeywords, caseInsensitive, className = DEFAULT_KEYWORD_CLASSNAME) {
      /** @type KeywordDict */
      const compiledKeywords = {};

      // input can be a string of keywords, an array of keywords, or a object with
      // named keys representing className (which can then point to a string or array)
      if (typeof rawKeywords === 'string') {
        compileList(className, rawKeywords.split(" "));
      } else if (Array.isArray(rawKeywords)) {
        compileList(className, rawKeywords);
      } else {
        Object.keys(rawKeywords).forEach(function(className) {
          // collapse all our objects back into the parent object
          Object.assign(
            compiledKeywords,
            compileKeywords(rawKeywords[className], caseInsensitive, className)
          );
        });
      }
      return compiledKeywords;

      // ---

      /**
       * Compiles an individual list of keywords
       *
       * Ex: "for if when while|5"
       *
       * @param {string} className
       * @param {Array<string>} keywordList
       */
      function compileList(className, keywordList) {
        if (caseInsensitive) {
          keywordList = keywordList.map(x => x.toLowerCase());
        }
        keywordList.forEach(function(keyword) {
          const pair = keyword.split('|');
          compiledKeywords[pair[0]] = [className, scoreForKeyword(pair[0], pair[1])];
        });
      }
    }

    /**
     * Returns the proper score for a given keyword
     *
     * Also takes into account comment keywords, which will be scored 0 UNLESS
     * another score has been manually assigned.
     * @param {string} keyword
     * @param {string} [providedScore]
     */
    function scoreForKeyword(keyword, providedScore) {
      // manual scores always win over common keywords
      // so you can force a score of 1 if you really insist
      if (providedScore) {
        return Number(providedScore);
      }

      return commonKeyword(keyword) ? 0 : 1;
    }

    /**
     * Determines if a given keyword is common or not
     *
     * @param {string} keyword */
    function commonKeyword(keyword) {
      return COMMON_KEYWORDS.includes(keyword.toLowerCase());
    }

    // compilation

    /**
     * Compiles a language definition result
     *
     * Given the raw result of a language definition (Language), compiles this so
     * that it is ready for highlighting code.
     * @param {Language} language
     * @param {{plugins: HLJSPlugin[]}} opts
     * @returns {CompiledLanguage}
     */
    function compileLanguage(language, { plugins }) {
      /**
       * Builds a regex with the case sensativility of the current language
       *
       * @param {RegExp | string} value
       * @param {boolean} [global]
       */
      function langRe(value, global) {
        return new RegExp(
          source$2(value),
          'm' + (language.case_insensitive ? 'i' : '') + (global ? 'g' : '')
        );
      }

      /**
        Stores multiple regular expressions and allows you to quickly search for
        them all in a string simultaneously - returning the first match.  It does
        this by creating a huge (a|b|c) regex - each individual item wrapped with ()
        and joined by `|` - using match groups to track position.  When a match is
        found checking which position in the array has content allows us to figure
        out which of the original regexes / match groups triggered the match.

        The match object itself (the result of `Regex.exec`) is returned but also
        enhanced by merging in any meta-data that was registered with the regex.
        This is how we keep track of which mode matched, and what type of rule
        (`illegal`, `begin`, end, etc).
      */
      class MultiRegex {
        constructor() {
          this.matchIndexes = {};
          // @ts-ignore
          this.regexes = [];
          this.matchAt = 1;
          this.position = 0;
        }

        // @ts-ignore
        addRule(re, opts) {
          opts.position = this.position++;
          // @ts-ignore
          this.matchIndexes[this.matchAt] = opts;
          this.regexes.push([opts, re]);
          this.matchAt += countMatchGroups(re) + 1;
        }

        compile() {
          if (this.regexes.length === 0) {
            // avoids the need to check length every time exec is called
            // @ts-ignore
            this.exec = () => null;
          }
          const terminators = this.regexes.map(el => el[1]);
          this.matcherRe = langRe(join(terminators), true);
          this.lastIndex = 0;
        }

        /** @param {string} s */
        exec(s) {
          this.matcherRe.lastIndex = this.lastIndex;
          const match = this.matcherRe.exec(s);
          if (!match) { return null; }

          // eslint-disable-next-line no-undefined
          const i = match.findIndex((el, i) => i > 0 && el !== undefined);
          // @ts-ignore
          const matchData = this.matchIndexes[i];
          // trim off any earlier non-relevant match groups (ie, the other regex
          // match groups that make up the multi-matcher)
          match.splice(0, i);

          return Object.assign(match, matchData);
        }
      }

      /*
        Created to solve the key deficiently with MultiRegex - there is no way to
        test for multiple matches at a single location.  Why would we need to do
        that?  In the future a more dynamic engine will allow certain matches to be
        ignored.  An example: if we matched say the 3rd regex in a large group but
        decided to ignore it - we'd need to started testing again at the 4th
        regex... but MultiRegex itself gives us no real way to do that.

        So what this class creates MultiRegexs on the fly for whatever search
        position they are needed.

        NOTE: These additional MultiRegex objects are created dynamically.  For most
        grammars most of the time we will never actually need anything more than the
        first MultiRegex - so this shouldn't have too much overhead.

        Say this is our search group, and we match regex3, but wish to ignore it.

          regex1 | regex2 | regex3 | regex4 | regex5    ' ie, startAt = 0

        What we need is a new MultiRegex that only includes the remaining
        possibilities:

          regex4 | regex5                               ' ie, startAt = 3

        This class wraps all that complexity up in a simple API... `startAt` decides
        where in the array of expressions to start doing the matching. It
        auto-increments, so if a match is found at position 2, then startAt will be
        set to 3.  If the end is reached startAt will return to 0.

        MOST of the time the parser will be setting startAt manually to 0.
      */
      class ResumableMultiRegex {
        constructor() {
          // @ts-ignore
          this.rules = [];
          // @ts-ignore
          this.multiRegexes = [];
          this.count = 0;

          this.lastIndex = 0;
          this.regexIndex = 0;
        }

        // @ts-ignore
        getMatcher(index) {
          if (this.multiRegexes[index]) return this.multiRegexes[index];

          const matcher = new MultiRegex();
          this.rules.slice(index).forEach(([re, opts]) => matcher.addRule(re, opts));
          matcher.compile();
          this.multiRegexes[index] = matcher;
          return matcher;
        }

        resumingScanAtSamePosition() {
          return this.regexIndex !== 0;
        }

        considerAll() {
          this.regexIndex = 0;
        }

        // @ts-ignore
        addRule(re, opts) {
          this.rules.push([re, opts]);
          if (opts.type === "begin") this.count++;
        }

        /** @param {string} s */
        exec(s) {
          const m = this.getMatcher(this.regexIndex);
          m.lastIndex = this.lastIndex;
          let result = m.exec(s);

          // The following is because we have no easy way to say "resume scanning at the
          // existing position but also skip the current rule ONLY". What happens is
          // all prior rules are also skipped which can result in matching the wrong
          // thing. Example of matching "booger":

          // our matcher is [string, "booger", number]
          //
          // ....booger....

          // if "booger" is ignored then we'd really need a regex to scan from the
          // SAME position for only: [string, number] but ignoring "booger" (if it
          // was the first match), a simple resume would scan ahead who knows how
          // far looking only for "number", ignoring potential string matches (or
          // future "booger" matches that might be valid.)

          // So what we do: We execute two matchers, one resuming at the same
          // position, but the second full matcher starting at the position after:

          //     /--- resume first regex match here (for [number])
          //     |/---- full match here for [string, "booger", number]
          //     vv
          // ....booger....

          // Which ever results in a match first is then used. So this 3-4 step
          // process essentially allows us to say "match at this position, excluding
          // a prior rule that was ignored".
          //
          // 1. Match "booger" first, ignore. Also proves that [string] does non match.
          // 2. Resume matching for [number]
          // 3. Match at index + 1 for [string, "booger", number]
          // 4. If #2 and #3 result in matches, which came first?
          if (this.resumingScanAtSamePosition()) {
            if (result && result.index === this.lastIndex) ; else { // use the second matcher result
              const m2 = this.getMatcher(0);
              m2.lastIndex = this.lastIndex + 1;
              result = m2.exec(s);
            }
          }

          if (result) {
            this.regexIndex += result.position + 1;
            if (this.regexIndex === this.count) {
              // wrap-around to considering all matches again
              this.considerAll();
            }
          }

          return result;
        }
      }

      /**
       * Given a mode, builds a huge ResumableMultiRegex that can be used to walk
       * the content and find matches.
       *
       * @param {CompiledMode} mode
       * @returns {ResumableMultiRegex}
       */
      function buildModeRegex(mode) {
        const mm = new ResumableMultiRegex();

        mode.contains.forEach(term => mm.addRule(term.begin, { rule: term, type: "begin" }));

        if (mode.terminatorEnd) {
          mm.addRule(mode.terminatorEnd, { type: "end" });
        }
        if (mode.illegal) {
          mm.addRule(mode.illegal, { type: "illegal" });
        }

        return mm;
      }

      /** skip vs abort vs ignore
       *
       * @skip   - The mode is still entered and exited normally (and contains rules apply),
       *           but all content is held and added to the parent buffer rather than being
       *           output when the mode ends.  Mostly used with `sublanguage` to build up
       *           a single large buffer than can be parsed by sublanguage.
       *
       *             - The mode begin ands ends normally.
       *             - Content matched is added to the parent mode buffer.
       *             - The parser cursor is moved forward normally.
       *
       * @abort  - A hack placeholder until we have ignore.  Aborts the mode (as if it
       *           never matched) but DOES NOT continue to match subsequent `contains`
       *           modes.  Abort is bad/suboptimal because it can result in modes
       *           farther down not getting applied because an earlier rule eats the
       *           content but then aborts.
       *
       *             - The mode does not begin.
       *             - Content matched by `begin` is added to the mode buffer.
       *             - The parser cursor is moved forward accordingly.
       *
       * @ignore - Ignores the mode (as if it never matched) and continues to match any
       *           subsequent `contains` modes.  Ignore isn't technically possible with
       *           the current parser implementation.
       *
       *             - The mode does not begin.
       *             - Content matched by `begin` is ignored.
       *             - The parser cursor is not moved forward.
       */

      /**
       * Compiles an individual mode
       *
       * This can raise an error if the mode contains certain detectable known logic
       * issues.
       * @param {Mode} mode
       * @param {CompiledMode | null} [parent]
       * @returns {CompiledMode | never}
       */
      function compileMode(mode, parent) {
        const cmode = /** @type CompiledMode */ (mode);
        if (mode.isCompiled) return cmode;

        [
          // do this early so compiler extensions generally don't have to worry about
          // the distinction between match/begin
          compileMatch
        ].forEach(ext => ext(mode, parent));

        language.compilerExtensions.forEach(ext => ext(mode, parent));

        // __beforeBegin is considered private API, internal use only
        mode.__beforeBegin = null;

        [
          beginKeywords,
          // do this later so compiler extensions that come earlier have access to the
          // raw array if they wanted to perhaps manipulate it, etc.
          compileIllegal,
          // default to 1 relevance if not specified
          compileRelevance
        ].forEach(ext => ext(mode, parent));

        mode.isCompiled = true;

        let keywordPattern = null;
        if (typeof mode.keywords === "object") {
          keywordPattern = mode.keywords.$pattern;
          delete mode.keywords.$pattern;
        }

        if (mode.keywords) {
          mode.keywords = compileKeywords(mode.keywords, language.case_insensitive);
        }

        // both are not allowed
        if (mode.lexemes && keywordPattern) {
          throw new Error("ERR: Prefer `keywords.$pattern` to `mode.lexemes`, BOTH are not allowed. (see mode reference) ");
        }

        // `mode.lexemes` was the old standard before we added and now recommend
        // using `keywords.$pattern` to pass the keyword pattern
        keywordPattern = keywordPattern || mode.lexemes || /\w+/;
        cmode.keywordPatternRe = langRe(keywordPattern, true);

        if (parent) {
          if (!mode.begin) mode.begin = /\B|\b/;
          cmode.beginRe = langRe(mode.begin);
          if (mode.endSameAsBegin) mode.end = mode.begin;
          if (!mode.end && !mode.endsWithParent) mode.end = /\B|\b/;
          if (mode.end) cmode.endRe = langRe(mode.end);
          cmode.terminatorEnd = source$2(mode.end) || '';
          if (mode.endsWithParent && parent.terminatorEnd) {
            cmode.terminatorEnd += (mode.end ? '|' : '') + parent.terminatorEnd;
          }
        }
        if (mode.illegal) cmode.illegalRe = langRe(/** @type {RegExp | string} */ (mode.illegal));
        if (!mode.contains) mode.contains = [];

        mode.contains = [].concat(...mode.contains.map(function(c) {
          return expandOrCloneMode(c === 'self' ? mode : c);
        }));
        mode.contains.forEach(function(c) { compileMode(/** @type Mode */ (c), cmode); });

        if (mode.starts) {
          compileMode(mode.starts, parent);
        }

        cmode.matcher = buildModeRegex(cmode);
        return cmode;
      }

      if (!language.compilerExtensions) language.compilerExtensions = [];

      // self is not valid at the top-level
      if (language.contains && language.contains.includes('self')) {
        throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
      }

      // we need a null object, which inherit will guarantee
      language.classNameAliases = inherit(language.classNameAliases || {});

      return compileMode(/** @type Mode */ (language));
    }

    /**
     * Determines if a mode has a dependency on it's parent or not
     *
     * If a mode does have a parent dependency then often we need to clone it if
     * it's used in multiple places so that each copy points to the correct parent,
     * where-as modes without a parent can often safely be re-used at the bottom of
     * a mode chain.
     *
     * @param {Mode | null} mode
     * @returns {boolean} - is there a dependency on the parent?
     * */
    function dependencyOnParent(mode) {
      if (!mode) return false;

      return mode.endsWithParent || dependencyOnParent(mode.starts);
    }

    /**
     * Expands a mode or clones it if necessary
     *
     * This is necessary for modes with parental dependenceis (see notes on
     * `dependencyOnParent`) and for nodes that have `variants` - which must then be
     * exploded into their own individual modes at compile time.
     *
     * @param {Mode} mode
     * @returns {Mode | Mode[]}
     * */
    function expandOrCloneMode(mode) {
      if (mode.variants && !mode.cachedVariants) {
        mode.cachedVariants = mode.variants.map(function(variant) {
          return inherit(mode, { variants: null }, variant);
        });
      }

      // EXPAND
      // if we have variants then essentially "replace" the mode with the variants
      // this happens in compileMode, where this function is called from
      if (mode.cachedVariants) {
        return mode.cachedVariants;
      }

      // CLONE
      // if we have dependencies on parents then we need a unique
      // instance of ourselves, so we can be reused with many
      // different parents without issue
      if (dependencyOnParent(mode)) {
        return inherit(mode, { starts: mode.starts ? inherit(mode.starts) : null });
      }

      if (Object.isFrozen(mode)) {
        return inherit(mode);
      }

      // no special dependency issues, just return ourselves
      return mode;
    }

    var version = "10.7.3";

    // @ts-nocheck

    function hasValueOrEmptyAttribute(value) {
      return Boolean(value || value === "");
    }

    function BuildVuePlugin(hljs) {
      const Component = {
        props: ["language", "code", "autodetect"],
        data: function() {
          return {
            detectedLanguage: "",
            unknownLanguage: false
          };
        },
        computed: {
          className() {
            if (this.unknownLanguage) return "";

            return "hljs " + this.detectedLanguage;
          },
          highlighted() {
            // no idea what language to use, return raw code
            if (!this.autoDetect && !hljs.getLanguage(this.language)) {
              console.warn(`The language "${this.language}" you specified could not be found.`);
              this.unknownLanguage = true;
              return escapeHTML(this.code);
            }

            let result = {};
            if (this.autoDetect) {
              result = hljs.highlightAuto(this.code);
              this.detectedLanguage = result.language;
            } else {
              result = hljs.highlight(this.language, this.code, this.ignoreIllegals);
              this.detectedLanguage = this.language;
            }
            return result.value;
          },
          autoDetect() {
            return !this.language || hasValueOrEmptyAttribute(this.autodetect);
          },
          ignoreIllegals() {
            return true;
          }
        },
        // this avoids needing to use a whole Vue compilation pipeline just
        // to build Highlight.js
        render(createElement) {
          return createElement("pre", {}, [
            createElement("code", {
              class: this.className,
              domProps: { innerHTML: this.highlighted }
            })
          ]);
        }
        // template: `<pre><code :class="className" v-html="highlighted"></code></pre>`
      };

      const VuePlugin = {
        install(Vue) {
          Vue.component('highlightjs', Component);
        }
      };

      return { Component, VuePlugin };
    }

    /* plugin itself */

    /** @type {HLJSPlugin} */
    const mergeHTMLPlugin = {
      "after:highlightElement": ({ el, result, text }) => {
        const originalStream = nodeStream(el);
        if (!originalStream.length) return;

        const resultNode = document.createElement('div');
        resultNode.innerHTML = result.value;
        result.value = mergeStreams(originalStream, nodeStream(resultNode), text);
      }
    };

    /* Stream merging support functions */

    /**
     * @typedef Event
     * @property {'start'|'stop'} event
     * @property {number} offset
     * @property {Node} node
     */

    /**
     * @param {Node} node
     */
    function tag(node) {
      return node.nodeName.toLowerCase();
    }

    /**
     * @param {Node} node
     */
    function nodeStream(node) {
      /** @type Event[] */
      const result = [];
      (function _nodeStream(node, offset) {
        for (let child = node.firstChild; child; child = child.nextSibling) {
          if (child.nodeType === 3) {
            offset += child.nodeValue.length;
          } else if (child.nodeType === 1) {
            result.push({
              event: 'start',
              offset: offset,
              node: child
            });
            offset = _nodeStream(child, offset);
            // Prevent void elements from having an end tag that would actually
            // double them in the output. There are more void elements in HTML
            // but we list only those realistically expected in code display.
            if (!tag(child).match(/br|hr|img|input/)) {
              result.push({
                event: 'stop',
                offset: offset,
                node: child
              });
            }
          }
        }
        return offset;
      })(node, 0);
      return result;
    }

    /**
     * @param {any} original - the original stream
     * @param {any} highlighted - stream of the highlighted source
     * @param {string} value - the original source itself
     */
    function mergeStreams(original, highlighted, value) {
      let processed = 0;
      let result = '';
      const nodeStack = [];

      function selectStream() {
        if (!original.length || !highlighted.length) {
          return original.length ? original : highlighted;
        }
        if (original[0].offset !== highlighted[0].offset) {
          return (original[0].offset < highlighted[0].offset) ? original : highlighted;
        }

        /*
        To avoid starting the stream just before it should stop the order is
        ensured that original always starts first and closes last:

        if (event1 == 'start' && event2 == 'start')
          return original;
        if (event1 == 'start' && event2 == 'stop')
          return highlighted;
        if (event1 == 'stop' && event2 == 'start')
          return original;
        if (event1 == 'stop' && event2 == 'stop')
          return highlighted;

        ... which is collapsed to:
        */
        return highlighted[0].event === 'start' ? original : highlighted;
      }

      /**
       * @param {Node} node
       */
      function open(node) {
        /** @param {Attr} attr */
        function attributeString(attr) {
          return ' ' + attr.nodeName + '="' + escapeHTML(attr.value) + '"';
        }
        // @ts-ignore
        result += '<' + tag(node) + [].map.call(node.attributes, attributeString).join('') + '>';
      }

      /**
       * @param {Node} node
       */
      function close(node) {
        result += '</' + tag(node) + '>';
      }

      /**
       * @param {Event} event
       */
      function render(event) {
        (event.event === 'start' ? open : close)(event.node);
      }

      while (original.length || highlighted.length) {
        let stream = selectStream();
        result += escapeHTML(value.substring(processed, stream[0].offset));
        processed = stream[0].offset;
        if (stream === original) {
          /*
          On any opening or closing tag of the original markup we first close
          the entire highlighted node stack, then render the original tag along
          with all the following original tags at the same offset and then
          reopen all the tags on the highlighted stack.
          */
          nodeStack.reverse().forEach(close);
          do {
            render(stream.splice(0, 1)[0]);
            stream = selectStream();
          } while (stream === original && stream.length && stream[0].offset === processed);
          nodeStack.reverse().forEach(open);
        } else {
          if (stream[0].event === 'start') {
            nodeStack.push(stream[0].node);
          } else {
            nodeStack.pop();
          }
          render(stream.splice(0, 1)[0]);
        }
      }
      return result + escapeHTML(value.substr(processed));
    }

    /*

    For the reasoning behind this please see:
    https://github.com/highlightjs/highlight.js/issues/2880#issuecomment-747275419

    */

    /**
     * @type {Record<string, boolean>}
     */
    const seenDeprecations = {};

    /**
     * @param {string} message
     */
    const error = (message) => {
      console.error(message);
    };

    /**
     * @param {string} message
     * @param {any} args
     */
    const warn = (message, ...args) => {
      console.log(`WARN: ${message}`, ...args);
    };

    /**
     * @param {string} version
     * @param {string} message
     */
    const deprecated = (version, message) => {
      if (seenDeprecations[`${version}/${message}`]) return;

      console.log(`Deprecated as of ${version}. ${message}`);
      seenDeprecations[`${version}/${message}`] = true;
    };

    /*
    Syntax highlighting with language autodetection.
    https://highlightjs.org/
    */

    const escape$1 = escapeHTML;
    const inherit$1 = inherit;
    const NO_MATCH = Symbol("nomatch");

    /**
     * @param {any} hljs - object that is extended (legacy)
     * @returns {HLJSApi}
     */
    const HLJS = function(hljs) {
      // Global internal variables used within the highlight.js library.
      /** @type {Record<string, Language>} */
      const languages = Object.create(null);
      /** @type {Record<string, string>} */
      const aliases = Object.create(null);
      /** @type {HLJSPlugin[]} */
      const plugins = [];

      // safe/production mode - swallows more errors, tries to keep running
      // even if a single syntax or parse hits a fatal error
      let SAFE_MODE = true;
      const fixMarkupRe = /(^(<[^>]+>|\t|)+|\n)/gm;
      const LANGUAGE_NOT_FOUND = "Could not find the language '{}', did you forget to load/include a language module?";
      /** @type {Language} */
      const PLAINTEXT_LANGUAGE = { disableAutodetect: true, name: 'Plain text', contains: [] };

      // Global options used when within external APIs. This is modified when
      // calling the `hljs.configure` function.
      /** @type HLJSOptions */
      let options = {
        noHighlightRe: /^(no-?highlight)$/i,
        languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
        classPrefix: 'hljs-',
        tabReplace: null,
        useBR: false,
        languages: null,
        // beta configuration options, subject to change, welcome to discuss
        // https://github.com/highlightjs/highlight.js/issues/1086
        __emitter: TokenTreeEmitter
      };

      /* Utility functions */

      /**
       * Tests a language name to see if highlighting should be skipped
       * @param {string} languageName
       */
      function shouldNotHighlight(languageName) {
        return options.noHighlightRe.test(languageName);
      }

      /**
       * @param {HighlightedHTMLElement} block - the HTML element to determine language for
       */
      function blockLanguage(block) {
        let classes = block.className + ' ';

        classes += block.parentNode ? block.parentNode.className : '';

        // language-* takes precedence over non-prefixed class names.
        const match = options.languageDetectRe.exec(classes);
        if (match) {
          const language = getLanguage(match[1]);
          if (!language) {
            warn(LANGUAGE_NOT_FOUND.replace("{}", match[1]));
            warn("Falling back to no-highlight mode for this block.", block);
          }
          return language ? match[1] : 'no-highlight';
        }

        return classes
          .split(/\s+/)
          .find((_class) => shouldNotHighlight(_class) || getLanguage(_class));
      }

      /**
       * Core highlighting function.
       *
       * OLD API
       * highlight(lang, code, ignoreIllegals, continuation)
       *
       * NEW API
       * highlight(code, {lang, ignoreIllegals})
       *
       * @param {string} codeOrlanguageName - the language to use for highlighting
       * @param {string | HighlightOptions} optionsOrCode - the code to highlight
       * @param {boolean} [ignoreIllegals] - whether to ignore illegal matches, default is to bail
       * @param {CompiledMode} [continuation] - current continuation mode, if any
       *
       * @returns {HighlightResult} Result - an object that represents the result
       * @property {string} language - the language name
       * @property {number} relevance - the relevance score
       * @property {string} value - the highlighted HTML code
       * @property {string} code - the original raw code
       * @property {CompiledMode} top - top of the current mode stack
       * @property {boolean} illegal - indicates whether any illegal matches were found
      */
      function highlight(codeOrlanguageName, optionsOrCode, ignoreIllegals, continuation) {
        let code = "";
        let languageName = "";
        if (typeof optionsOrCode === "object") {
          code = codeOrlanguageName;
          ignoreIllegals = optionsOrCode.ignoreIllegals;
          languageName = optionsOrCode.language;
          // continuation not supported at all via the new API
          // eslint-disable-next-line no-undefined
          continuation = undefined;
        } else {
          // old API
          deprecated("10.7.0", "highlight(lang, code, ...args) has been deprecated.");
          deprecated("10.7.0", "Please use highlight(code, options) instead.\nhttps://github.com/highlightjs/highlight.js/issues/2277");
          languageName = codeOrlanguageName;
          code = optionsOrCode;
        }

        /** @type {BeforeHighlightContext} */
        const context = {
          code,
          language: languageName
        };
        // the plugin can change the desired language or the code to be highlighted
        // just be changing the object it was passed
        fire("before:highlight", context);

        // a before plugin can usurp the result completely by providing it's own
        // in which case we don't even need to call highlight
        const result = context.result
          ? context.result
          : _highlight(context.language, context.code, ignoreIllegals, continuation);

        result.code = context.code;
        // the plugin can change anything in result to suite it
        fire("after:highlight", result);

        return result;
      }

      /**
       * private highlight that's used internally and does not fire callbacks
       *
       * @param {string} languageName - the language to use for highlighting
       * @param {string} codeToHighlight - the code to highlight
       * @param {boolean?} [ignoreIllegals] - whether to ignore illegal matches, default is to bail
       * @param {CompiledMode?} [continuation] - current continuation mode, if any
       * @returns {HighlightResult} - result of the highlight operation
      */
      function _highlight(languageName, codeToHighlight, ignoreIllegals, continuation) {
        /**
         * Return keyword data if a match is a keyword
         * @param {CompiledMode} mode - current mode
         * @param {RegExpMatchArray} match - regexp match data
         * @returns {KeywordData | false}
         */
        function keywordData(mode, match) {
          const matchText = language.case_insensitive ? match[0].toLowerCase() : match[0];
          return Object.prototype.hasOwnProperty.call(mode.keywords, matchText) && mode.keywords[matchText];
        }

        function processKeywords() {
          if (!top.keywords) {
            emitter.addText(modeBuffer);
            return;
          }

          let lastIndex = 0;
          top.keywordPatternRe.lastIndex = 0;
          let match = top.keywordPatternRe.exec(modeBuffer);
          let buf = "";

          while (match) {
            buf += modeBuffer.substring(lastIndex, match.index);
            const data = keywordData(top, match);
            if (data) {
              const [kind, keywordRelevance] = data;
              emitter.addText(buf);
              buf = "";

              relevance += keywordRelevance;
              if (kind.startsWith("_")) {
                // _ implied for relevance only, do not highlight
                // by applying a class name
                buf += match[0];
              } else {
                const cssClass = language.classNameAliases[kind] || kind;
                emitter.addKeyword(match[0], cssClass);
              }
            } else {
              buf += match[0];
            }
            lastIndex = top.keywordPatternRe.lastIndex;
            match = top.keywordPatternRe.exec(modeBuffer);
          }
          buf += modeBuffer.substr(lastIndex);
          emitter.addText(buf);
        }

        function processSubLanguage() {
          if (modeBuffer === "") return;
          /** @type HighlightResult */
          let result = null;

          if (typeof top.subLanguage === 'string') {
            if (!languages[top.subLanguage]) {
              emitter.addText(modeBuffer);
              return;
            }
            result = _highlight(top.subLanguage, modeBuffer, true, continuations[top.subLanguage]);
            continuations[top.subLanguage] = /** @type {CompiledMode} */ (result.top);
          } else {
            result = highlightAuto(modeBuffer, top.subLanguage.length ? top.subLanguage : null);
          }

          // Counting embedded language score towards the host language may be disabled
          // with zeroing the containing mode relevance. Use case in point is Markdown that
          // allows XML everywhere and makes every XML snippet to have a much larger Markdown
          // score.
          if (top.relevance > 0) {
            relevance += result.relevance;
          }
          emitter.addSublanguage(result.emitter, result.language);
        }

        function processBuffer() {
          if (top.subLanguage != null) {
            processSubLanguage();
          } else {
            processKeywords();
          }
          modeBuffer = '';
        }

        /**
         * @param {Mode} mode - new mode to start
         */
        function startNewMode(mode) {
          if (mode.className) {
            emitter.openNode(language.classNameAliases[mode.className] || mode.className);
          }
          top = Object.create(mode, { parent: { value: top } });
          return top;
        }

        /**
         * @param {CompiledMode } mode - the mode to potentially end
         * @param {RegExpMatchArray} match - the latest match
         * @param {string} matchPlusRemainder - match plus remainder of content
         * @returns {CompiledMode | void} - the next mode, or if void continue on in current mode
         */
        function endOfMode(mode, match, matchPlusRemainder) {
          let matched = startsWith(mode.endRe, matchPlusRemainder);

          if (matched) {
            if (mode["on:end"]) {
              const resp = new Response(mode);
              mode["on:end"](match, resp);
              if (resp.isMatchIgnored) matched = false;
            }

            if (matched) {
              while (mode.endsParent && mode.parent) {
                mode = mode.parent;
              }
              return mode;
            }
          }
          // even if on:end fires an `ignore` it's still possible
          // that we might trigger the end node because of a parent mode
          if (mode.endsWithParent) {
            return endOfMode(mode.parent, match, matchPlusRemainder);
          }
        }

        /**
         * Handle matching but then ignoring a sequence of text
         *
         * @param {string} lexeme - string containing full match text
         */
        function doIgnore(lexeme) {
          if (top.matcher.regexIndex === 0) {
            // no more regexs to potentially match here, so we move the cursor forward one
            // space
            modeBuffer += lexeme[0];
            return 1;
          } else {
            // no need to move the cursor, we still have additional regexes to try and
            // match at this very spot
            resumeScanAtSamePosition = true;
            return 0;
          }
        }

        /**
         * Handle the start of a new potential mode match
         *
         * @param {EnhancedMatch} match - the current match
         * @returns {number} how far to advance the parse cursor
         */
        function doBeginMatch(match) {
          const lexeme = match[0];
          const newMode = match.rule;

          const resp = new Response(newMode);
          // first internal before callbacks, then the public ones
          const beforeCallbacks = [newMode.__beforeBegin, newMode["on:begin"]];
          for (const cb of beforeCallbacks) {
            if (!cb) continue;
            cb(match, resp);
            if (resp.isMatchIgnored) return doIgnore(lexeme);
          }

          if (newMode && newMode.endSameAsBegin) {
            newMode.endRe = escape(lexeme);
          }

          if (newMode.skip) {
            modeBuffer += lexeme;
          } else {
            if (newMode.excludeBegin) {
              modeBuffer += lexeme;
            }
            processBuffer();
            if (!newMode.returnBegin && !newMode.excludeBegin) {
              modeBuffer = lexeme;
            }
          }
          startNewMode(newMode);
          // if (mode["after:begin"]) {
          //   let resp = new Response(mode);
          //   mode["after:begin"](match, resp);
          // }
          return newMode.returnBegin ? 0 : lexeme.length;
        }

        /**
         * Handle the potential end of mode
         *
         * @param {RegExpMatchArray} match - the current match
         */
        function doEndMatch(match) {
          const lexeme = match[0];
          const matchPlusRemainder = codeToHighlight.substr(match.index);

          const endMode = endOfMode(top, match, matchPlusRemainder);
          if (!endMode) { return NO_MATCH; }

          const origin = top;
          if (origin.skip) {
            modeBuffer += lexeme;
          } else {
            if (!(origin.returnEnd || origin.excludeEnd)) {
              modeBuffer += lexeme;
            }
            processBuffer();
            if (origin.excludeEnd) {
              modeBuffer = lexeme;
            }
          }
          do {
            if (top.className) {
              emitter.closeNode();
            }
            if (!top.skip && !top.subLanguage) {
              relevance += top.relevance;
            }
            top = top.parent;
          } while (top !== endMode.parent);
          if (endMode.starts) {
            if (endMode.endSameAsBegin) {
              endMode.starts.endRe = endMode.endRe;
            }
            startNewMode(endMode.starts);
          }
          return origin.returnEnd ? 0 : lexeme.length;
        }

        function processContinuations() {
          const list = [];
          for (let current = top; current !== language; current = current.parent) {
            if (current.className) {
              list.unshift(current.className);
            }
          }
          list.forEach(item => emitter.openNode(item));
        }

        /** @type {{type?: MatchType, index?: number, rule?: Mode}}} */
        let lastMatch = {};

        /**
         *  Process an individual match
         *
         * @param {string} textBeforeMatch - text preceeding the match (since the last match)
         * @param {EnhancedMatch} [match] - the match itself
         */
        function processLexeme(textBeforeMatch, match) {
          const lexeme = match && match[0];

          // add non-matched text to the current mode buffer
          modeBuffer += textBeforeMatch;

          if (lexeme == null) {
            processBuffer();
            return 0;
          }

          // we've found a 0 width match and we're stuck, so we need to advance
          // this happens when we have badly behaved rules that have optional matchers to the degree that
          // sometimes they can end up matching nothing at all
          // Ref: https://github.com/highlightjs/highlight.js/issues/2140
          if (lastMatch.type === "begin" && match.type === "end" && lastMatch.index === match.index && lexeme === "") {
            // spit the "skipped" character that our regex choked on back into the output sequence
            modeBuffer += codeToHighlight.slice(match.index, match.index + 1);
            if (!SAFE_MODE) {
              /** @type {AnnotatedError} */
              const err = new Error('0 width match regex');
              err.languageName = languageName;
              err.badRule = lastMatch.rule;
              throw err;
            }
            return 1;
          }
          lastMatch = match;

          if (match.type === "begin") {
            return doBeginMatch(match);
          } else if (match.type === "illegal" && !ignoreIllegals) {
            // illegal match, we do not continue processing
            /** @type {AnnotatedError} */
            const err = new Error('Illegal lexeme "' + lexeme + '" for mode "' + (top.className || '<unnamed>') + '"');
            err.mode = top;
            throw err;
          } else if (match.type === "end") {
            const processed = doEndMatch(match);
            if (processed !== NO_MATCH) {
              return processed;
            }
          }

          // edge case for when illegal matches $ (end of line) which is technically
          // a 0 width match but not a begin/end match so it's not caught by the
          // first handler (when ignoreIllegals is true)
          if (match.type === "illegal" && lexeme === "") {
            // advance so we aren't stuck in an infinite loop
            return 1;
          }

          // infinite loops are BAD, this is a last ditch catch all. if we have a
          // decent number of iterations yet our index (cursor position in our
          // parsing) still 3x behind our index then something is very wrong
          // so we bail
          if (iterations > 100000 && iterations > match.index * 3) {
            const err = new Error('potential infinite loop, way more iterations than matches');
            throw err;
          }

          /*
          Why might be find ourselves here?  Only one occasion now.  An end match that was
          triggered but could not be completed.  When might this happen?  When an `endSameasBegin`
          rule sets the end rule to a specific match.  Since the overall mode termination rule that's
          being used to scan the text isn't recompiled that means that any match that LOOKS like
          the end (but is not, because it is not an exact match to the beginning) will
          end up here.  A definite end match, but when `doEndMatch` tries to "reapply"
          the end rule and fails to match, we wind up here, and just silently ignore the end.

          This causes no real harm other than stopping a few times too many.
          */

          modeBuffer += lexeme;
          return lexeme.length;
        }

        const language = getLanguage(languageName);
        if (!language) {
          error(LANGUAGE_NOT_FOUND.replace("{}", languageName));
          throw new Error('Unknown language: "' + languageName + '"');
        }

        const md = compileLanguage(language, { plugins });
        let result = '';
        /** @type {CompiledMode} */
        let top = continuation || md;
        /** @type Record<string,CompiledMode> */
        const continuations = {}; // keep continuations for sub-languages
        const emitter = new options.__emitter(options);
        processContinuations();
        let modeBuffer = '';
        let relevance = 0;
        let index = 0;
        let iterations = 0;
        let resumeScanAtSamePosition = false;

        try {
          top.matcher.considerAll();

          for (;;) {
            iterations++;
            if (resumeScanAtSamePosition) {
              // only regexes not matched previously will now be
              // considered for a potential match
              resumeScanAtSamePosition = false;
            } else {
              top.matcher.considerAll();
            }
            top.matcher.lastIndex = index;

            const match = top.matcher.exec(codeToHighlight);
            // console.log("match", match[0], match.rule && match.rule.begin)

            if (!match) break;

            const beforeMatch = codeToHighlight.substring(index, match.index);
            const processedCount = processLexeme(beforeMatch, match);
            index = match.index + processedCount;
          }
          processLexeme(codeToHighlight.substr(index));
          emitter.closeAllNodes();
          emitter.finalize();
          result = emitter.toHTML();

          return {
            // avoid possible breakage with v10 clients expecting
            // this to always be an integer
            relevance: Math.floor(relevance),
            value: result,
            language: languageName,
            illegal: false,
            emitter: emitter,
            top: top
          };
        } catch (err) {
          if (err.message && err.message.includes('Illegal')) {
            return {
              illegal: true,
              illegalBy: {
                msg: err.message,
                context: codeToHighlight.slice(index - 100, index + 100),
                mode: err.mode
              },
              sofar: result,
              relevance: 0,
              value: escape$1(codeToHighlight),
              emitter: emitter
            };
          } else if (SAFE_MODE) {
            return {
              illegal: false,
              relevance: 0,
              value: escape$1(codeToHighlight),
              emitter: emitter,
              language: languageName,
              top: top,
              errorRaised: err
            };
          } else {
            throw err;
          }
        }
      }

      /**
       * returns a valid highlight result, without actually doing any actual work,
       * auto highlight starts with this and it's possible for small snippets that
       * auto-detection may not find a better match
       * @param {string} code
       * @returns {HighlightResult}
       */
      function justTextHighlightResult(code) {
        const result = {
          relevance: 0,
          emitter: new options.__emitter(options),
          value: escape$1(code),
          illegal: false,
          top: PLAINTEXT_LANGUAGE
        };
        result.emitter.addText(code);
        return result;
      }

      /**
      Highlighting with language detection. Accepts a string with the code to
      highlight. Returns an object with the following properties:

      - language (detected language)
      - relevance (int)
      - value (an HTML string with highlighting markup)
      - second_best (object with the same structure for second-best heuristically
        detected language, may be absent)

        @param {string} code
        @param {Array<string>} [languageSubset]
        @returns {AutoHighlightResult}
      */
      function highlightAuto(code, languageSubset) {
        languageSubset = languageSubset || options.languages || Object.keys(languages);
        const plaintext = justTextHighlightResult(code);

        const results = languageSubset.filter(getLanguage).filter(autoDetection).map(name =>
          _highlight(name, code, false)
        );
        results.unshift(plaintext); // plaintext is always an option

        const sorted = results.sort((a, b) => {
          // sort base on relevance
          if (a.relevance !== b.relevance) return b.relevance - a.relevance;

          // always award the tie to the base language
          // ie if C++ and Arduino are tied, it's more likely to be C++
          if (a.language && b.language) {
            if (getLanguage(a.language).supersetOf === b.language) {
              return 1;
            } else if (getLanguage(b.language).supersetOf === a.language) {
              return -1;
            }
          }

          // otherwise say they are equal, which has the effect of sorting on
          // relevance while preserving the original ordering - which is how ties
          // have historically been settled, ie the language that comes first always
          // wins in the case of a tie
          return 0;
        });

        const [best, secondBest] = sorted;

        /** @type {AutoHighlightResult} */
        const result = best;
        result.second_best = secondBest;

        return result;
      }

      /**
      Post-processing of the highlighted markup:

      - replace TABs with something more useful
      - replace real line-breaks with '<br>' for non-pre containers

        @param {string} html
        @returns {string}
      */
      function fixMarkup(html) {
        if (!(options.tabReplace || options.useBR)) {
          return html;
        }

        return html.replace(fixMarkupRe, match => {
          if (match === '\n') {
            return options.useBR ? '<br>' : match;
          } else if (options.tabReplace) {
            return match.replace(/\t/g, options.tabReplace);
          }
          return match;
        });
      }

      /**
       * Builds new class name for block given the language name
       *
       * @param {HTMLElement} element
       * @param {string} [currentLang]
       * @param {string} [resultLang]
       */
      function updateClassName(element, currentLang, resultLang) {
        const language = currentLang ? aliases[currentLang] : resultLang;

        element.classList.add("hljs");
        if (language) element.classList.add(language);
      }

      /** @type {HLJSPlugin} */
      const brPlugin = {
        "before:highlightElement": ({ el }) => {
          if (options.useBR) {
            el.innerHTML = el.innerHTML.replace(/\n/g, '').replace(/<br[ /]*>/g, '\n');
          }
        },
        "after:highlightElement": ({ result }) => {
          if (options.useBR) {
            result.value = result.value.replace(/\n/g, "<br>");
          }
        }
      };

      const TAB_REPLACE_RE = /^(<[^>]+>|\t)+/gm;
      /** @type {HLJSPlugin} */
      const tabReplacePlugin = {
        "after:highlightElement": ({ result }) => {
          if (options.tabReplace) {
            result.value = result.value.replace(TAB_REPLACE_RE, (m) =>
              m.replace(/\t/g, options.tabReplace)
            );
          }
        }
      };

      /**
       * Applies highlighting to a DOM node containing code. Accepts a DOM node and
       * two optional parameters for fixMarkup.
       *
       * @param {HighlightedHTMLElement} element - the HTML element to highlight
      */
      function highlightElement(element) {
        /** @type HTMLElement */
        let node = null;
        const language = blockLanguage(element);

        if (shouldNotHighlight(language)) return;

        // support for v10 API
        fire("before:highlightElement",
          { el: element, language: language });

        node = element;
        const text = node.textContent;
        const result = language ? highlight(text, { language, ignoreIllegals: true }) : highlightAuto(text);

        // support for v10 API
        fire("after:highlightElement", { el: element, result, text });

        element.innerHTML = result.value;
        updateClassName(element, language, result.language);
        element.result = {
          language: result.language,
          // TODO: remove with version 11.0
          re: result.relevance,
          relavance: result.relevance
        };
        if (result.second_best) {
          element.second_best = {
            language: result.second_best.language,
            // TODO: remove with version 11.0
            re: result.second_best.relevance,
            relavance: result.second_best.relevance
          };
        }
      }

      /**
       * Updates highlight.js global options with the passed options
       *
       * @param {Partial<HLJSOptions>} userOptions
       */
      function configure(userOptions) {
        if (userOptions.useBR) {
          deprecated("10.3.0", "'useBR' will be removed entirely in v11.0");
          deprecated("10.3.0", "Please see https://github.com/highlightjs/highlight.js/issues/2559");
        }
        options = inherit$1(options, userOptions);
      }

      /**
       * Highlights to all <pre><code> blocks on a page
       *
       * @type {Function & {called?: boolean}}
       */
      // TODO: remove v12, deprecated
      const initHighlighting = () => {
        if (initHighlighting.called) return;
        initHighlighting.called = true;

        deprecated("10.6.0", "initHighlighting() is deprecated.  Use highlightAll() instead.");

        const blocks = document.querySelectorAll('pre code');
        blocks.forEach(highlightElement);
      };

      // Higlights all when DOMContentLoaded fires
      // TODO: remove v12, deprecated
      function initHighlightingOnLoad() {
        deprecated("10.6.0", "initHighlightingOnLoad() is deprecated.  Use highlightAll() instead.");
        wantsHighlight = true;
      }

      let wantsHighlight = false;

      /**
       * auto-highlights all pre>code elements on the page
       */
      function highlightAll() {
        // if we are called too early in the loading process
        if (document.readyState === "loading") {
          wantsHighlight = true;
          return;
        }

        const blocks = document.querySelectorAll('pre code');
        blocks.forEach(highlightElement);
      }

      function boot() {
        // if a highlight was requested before DOM was loaded, do now
        if (wantsHighlight) highlightAll();
      }

      // make sure we are in the browser environment
      if (typeof window !== 'undefined' && window.addEventListener) {
        window.addEventListener('DOMContentLoaded', boot, false);
      }

      /**
       * Register a language grammar module
       *
       * @param {string} languageName
       * @param {LanguageFn} languageDefinition
       */
      function registerLanguage(languageName, languageDefinition) {
        let lang = null;
        try {
          lang = languageDefinition(hljs);
        } catch (error$1) {
          error("Language definition for '{}' could not be registered.".replace("{}", languageName));
          // hard or soft error
          if (!SAFE_MODE) { throw error$1; } else { error(error$1); }
          // languages that have serious errors are replaced with essentially a
          // "plaintext" stand-in so that the code blocks will still get normal
          // css classes applied to them - and one bad language won't break the
          // entire highlighter
          lang = PLAINTEXT_LANGUAGE;
        }
        // give it a temporary name if it doesn't have one in the meta-data
        if (!lang.name) lang.name = languageName;
        languages[languageName] = lang;
        lang.rawDefinition = languageDefinition.bind(null, hljs);

        if (lang.aliases) {
          registerAliases(lang.aliases, { languageName });
        }
      }

      /**
       * Remove a language grammar module
       *
       * @param {string} languageName
       */
      function unregisterLanguage(languageName) {
        delete languages[languageName];
        for (const alias of Object.keys(aliases)) {
          if (aliases[alias] === languageName) {
            delete aliases[alias];
          }
        }
      }

      /**
       * @returns {string[]} List of language internal names
       */
      function listLanguages() {
        return Object.keys(languages);
      }

      /**
        intended usage: When one language truly requires another

        Unlike `getLanguage`, this will throw when the requested language
        is not available.

        @param {string} name - name of the language to fetch/require
        @returns {Language | never}
      */
      function requireLanguage(name) {
        deprecated("10.4.0", "requireLanguage will be removed entirely in v11.");
        deprecated("10.4.0", "Please see https://github.com/highlightjs/highlight.js/pull/2844");

        const lang = getLanguage(name);
        if (lang) { return lang; }

        const err = new Error('The \'{}\' language is required, but not loaded.'.replace('{}', name));
        throw err;
      }

      /**
       * @param {string} name - name of the language to retrieve
       * @returns {Language | undefined}
       */
      function getLanguage(name) {
        name = (name || '').toLowerCase();
        return languages[name] || languages[aliases[name]];
      }

      /**
       *
       * @param {string|string[]} aliasList - single alias or list of aliases
       * @param {{languageName: string}} opts
       */
      function registerAliases(aliasList, { languageName }) {
        if (typeof aliasList === 'string') {
          aliasList = [aliasList];
        }
        aliasList.forEach(alias => { aliases[alias.toLowerCase()] = languageName; });
      }

      /**
       * Determines if a given language has auto-detection enabled
       * @param {string} name - name of the language
       */
      function autoDetection(name) {
        const lang = getLanguage(name);
        return lang && !lang.disableAutodetect;
      }

      /**
       * Upgrades the old highlightBlock plugins to the new
       * highlightElement API
       * @param {HLJSPlugin} plugin
       */
      function upgradePluginAPI(plugin) {
        // TODO: remove with v12
        if (plugin["before:highlightBlock"] && !plugin["before:highlightElement"]) {
          plugin["before:highlightElement"] = (data) => {
            plugin["before:highlightBlock"](
              Object.assign({ block: data.el }, data)
            );
          };
        }
        if (plugin["after:highlightBlock"] && !plugin["after:highlightElement"]) {
          plugin["after:highlightElement"] = (data) => {
            plugin["after:highlightBlock"](
              Object.assign({ block: data.el }, data)
            );
          };
        }
      }

      /**
       * @param {HLJSPlugin} plugin
       */
      function addPlugin(plugin) {
        upgradePluginAPI(plugin);
        plugins.push(plugin);
      }

      /**
       *
       * @param {PluginEvent} event
       * @param {any} args
       */
      function fire(event, args) {
        const cb = event;
        plugins.forEach(function(plugin) {
          if (plugin[cb]) {
            plugin[cb](args);
          }
        });
      }

      /**
      Note: fixMarkup is deprecated and will be removed entirely in v11

      @param {string} arg
      @returns {string}
      */
      function deprecateFixMarkup(arg) {
        deprecated("10.2.0", "fixMarkup will be removed entirely in v11.0");
        deprecated("10.2.0", "Please see https://github.com/highlightjs/highlight.js/issues/2534");

        return fixMarkup(arg);
      }

      /**
       *
       * @param {HighlightedHTMLElement} el
       */
      function deprecateHighlightBlock(el) {
        deprecated("10.7.0", "highlightBlock will be removed entirely in v12.0");
        deprecated("10.7.0", "Please use highlightElement now.");

        return highlightElement(el);
      }

      /* Interface definition */
      Object.assign(hljs, {
        highlight,
        highlightAuto,
        highlightAll,
        fixMarkup: deprecateFixMarkup,
        highlightElement,
        // TODO: Remove with v12 API
        highlightBlock: deprecateHighlightBlock,
        configure,
        initHighlighting,
        initHighlightingOnLoad,
        registerLanguage,
        unregisterLanguage,
        listLanguages,
        getLanguage,
        registerAliases,
        requireLanguage,
        autoDetection,
        inherit: inherit$1,
        addPlugin,
        // plugins for frameworks
        vuePlugin: BuildVuePlugin(hljs).VuePlugin
      });

      hljs.debugMode = function() { SAFE_MODE = false; };
      hljs.safeMode = function() { SAFE_MODE = true; };
      hljs.versionString = version;

      for (const key in MODES) {
        // @ts-ignore
        if (typeof MODES[key] === "object") {
          // @ts-ignore
          deepFreezeEs6(MODES[key]);
        }
      }

      // merge all the modes/regexs into our main object
      Object.assign(hljs, MODES);

      // built-in plugins, likely to be moved out of core in the future
      hljs.addPlugin(brPlugin); // slated to be removed in v11
      hljs.addPlugin(mergeHTMLPlugin);
      hljs.addPlugin(tabReplacePlugin);
      return hljs;
    };

    // export an "instance" of the highlighter
    var highlight = HLJS({});

    var core = highlight;

    /*
    Language: C#
    Author: Jason Diamond <jason@diamond.name>
    Contributor: Nicolas LLOBERA <nllobera@gmail.com>, Pieter Vantorre <pietervantorre@gmail.com>, David Pine <david.pine@microsoft.com>
    Website: https://docs.microsoft.com/en-us/dotnet/csharp/
    Category: common
    */

    /** @type LanguageFn */
    function csharp(hljs) {
      const BUILT_IN_KEYWORDS = [
        'bool',
        'byte',
        'char',
        'decimal',
        'delegate',
        'double',
        'dynamic',
        'enum',
        'float',
        'int',
        'long',
        'nint',
        'nuint',
        'object',
        'sbyte',
        'short',
        'string',
        'ulong',
        'uint',
        'ushort'
      ];
      const FUNCTION_MODIFIERS = [
        'public',
        'private',
        'protected',
        'static',
        'internal',
        'protected',
        'abstract',
        'async',
        'extern',
        'override',
        'unsafe',
        'virtual',
        'new',
        'sealed',
        'partial'
      ];
      const LITERAL_KEYWORDS = [
        'default',
        'false',
        'null',
        'true'
      ];
      const NORMAL_KEYWORDS = [
        'abstract',
        'as',
        'base',
        'break',
        'case',
        'class',
        'const',
        'continue',
        'do',
        'else',
        'event',
        'explicit',
        'extern',
        'finally',
        'fixed',
        'for',
        'foreach',
        'goto',
        'if',
        'implicit',
        'in',
        'interface',
        'internal',
        'is',
        'lock',
        'namespace',
        'new',
        'operator',
        'out',
        'override',
        'params',
        'private',
        'protected',
        'public',
        'readonly',
        'record',
        'ref',
        'return',
        'sealed',
        'sizeof',
        'stackalloc',
        'static',
        'struct',
        'switch',
        'this',
        'throw',
        'try',
        'typeof',
        'unchecked',
        'unsafe',
        'using',
        'virtual',
        'void',
        'volatile',
        'while'
      ];
      const CONTEXTUAL_KEYWORDS = [
        'add',
        'alias',
        'and',
        'ascending',
        'async',
        'await',
        'by',
        'descending',
        'equals',
        'from',
        'get',
        'global',
        'group',
        'init',
        'into',
        'join',
        'let',
        'nameof',
        'not',
        'notnull',
        'on',
        'or',
        'orderby',
        'partial',
        'remove',
        'select',
        'set',
        'unmanaged',
        'value|0',
        'var',
        'when',
        'where',
        'with',
        'yield'
      ];

      const KEYWORDS = {
        keyword: NORMAL_KEYWORDS.concat(CONTEXTUAL_KEYWORDS),
        built_in: BUILT_IN_KEYWORDS,
        literal: LITERAL_KEYWORDS
      };
      const TITLE_MODE = hljs.inherit(hljs.TITLE_MODE, {
        begin: '[a-zA-Z](\\.?\\w)*'
      });
      const NUMBERS = {
        className: 'number',
        variants: [
          {
            begin: '\\b(0b[01\']+)'
          },
          {
            begin: '(-?)\\b([\\d\']+(\\.[\\d\']*)?|\\.[\\d\']+)(u|U|l|L|ul|UL|f|F|b|B)'
          },
          {
            begin: '(-?)(\\b0[xX][a-fA-F0-9\']+|(\\b[\\d\']+(\\.[\\d\']*)?|\\.[\\d\']+)([eE][-+]?[\\d\']+)?)'
          }
        ],
        relevance: 0
      };
      const VERBATIM_STRING = {
        className: 'string',
        begin: '@"',
        end: '"',
        contains: [
          {
            begin: '""'
          }
        ]
      };
      const VERBATIM_STRING_NO_LF = hljs.inherit(VERBATIM_STRING, {
        illegal: /\n/
      });
      const SUBST = {
        className: 'subst',
        begin: /\{/,
        end: /\}/,
        keywords: KEYWORDS
      };
      const SUBST_NO_LF = hljs.inherit(SUBST, {
        illegal: /\n/
      });
      const INTERPOLATED_STRING = {
        className: 'string',
        begin: /\$"/,
        end: '"',
        illegal: /\n/,
        contains: [
          {
            begin: /\{\{/
          },
          {
            begin: /\}\}/
          },
          hljs.BACKSLASH_ESCAPE,
          SUBST_NO_LF
        ]
      };
      const INTERPOLATED_VERBATIM_STRING = {
        className: 'string',
        begin: /\$@"/,
        end: '"',
        contains: [
          {
            begin: /\{\{/
          },
          {
            begin: /\}\}/
          },
          {
            begin: '""'
          },
          SUBST
        ]
      };
      const INTERPOLATED_VERBATIM_STRING_NO_LF = hljs.inherit(INTERPOLATED_VERBATIM_STRING, {
        illegal: /\n/,
        contains: [
          {
            begin: /\{\{/
          },
          {
            begin: /\}\}/
          },
          {
            begin: '""'
          },
          SUBST_NO_LF
        ]
      });
      SUBST.contains = [
        INTERPOLATED_VERBATIM_STRING,
        INTERPOLATED_STRING,
        VERBATIM_STRING,
        hljs.APOS_STRING_MODE,
        hljs.QUOTE_STRING_MODE,
        NUMBERS,
        hljs.C_BLOCK_COMMENT_MODE
      ];
      SUBST_NO_LF.contains = [
        INTERPOLATED_VERBATIM_STRING_NO_LF,
        INTERPOLATED_STRING,
        VERBATIM_STRING_NO_LF,
        hljs.APOS_STRING_MODE,
        hljs.QUOTE_STRING_MODE,
        NUMBERS,
        hljs.inherit(hljs.C_BLOCK_COMMENT_MODE, {
          illegal: /\n/
        })
      ];
      const STRING = {
        variants: [
          INTERPOLATED_VERBATIM_STRING,
          INTERPOLATED_STRING,
          VERBATIM_STRING,
          hljs.APOS_STRING_MODE,
          hljs.QUOTE_STRING_MODE
        ]
      };

      const GENERIC_MODIFIER = {
        begin: "<",
        end: ">",
        contains: [
          {
            beginKeywords: "in out"
          },
          TITLE_MODE
        ]
      };
      const TYPE_IDENT_RE = hljs.IDENT_RE + '(<' + hljs.IDENT_RE + '(\\s*,\\s*' + hljs.IDENT_RE + ')*>)?(\\[\\])?';
      const AT_IDENTIFIER = {
        // prevents expressions like `@class` from incorrect flagging
        // `class` as a keyword
        begin: "@" + hljs.IDENT_RE,
        relevance: 0
      };

      return {
        name: 'C#',
        aliases: [
          'cs',
          'c#'
        ],
        keywords: KEYWORDS,
        illegal: /::/,
        contains: [
          hljs.COMMENT(
            '///',
            '$',
            {
              returnBegin: true,
              contains: [
                {
                  className: 'doctag',
                  variants: [
                    {
                      begin: '///',
                      relevance: 0
                    },
                    {
                      begin: '<!--|-->'
                    },
                    {
                      begin: '</?',
                      end: '>'
                    }
                  ]
                }
              ]
            }
          ),
          hljs.C_LINE_COMMENT_MODE,
          hljs.C_BLOCK_COMMENT_MODE,
          {
            className: 'meta',
            begin: '#',
            end: '$',
            keywords: {
              'meta-keyword': 'if else elif endif define undef warning error line region endregion pragma checksum'
            }
          },
          STRING,
          NUMBERS,
          {
            beginKeywords: 'class interface',
            relevance: 0,
            end: /[{;=]/,
            illegal: /[^\s:,]/,
            contains: [
              {
                beginKeywords: "where class"
              },
              TITLE_MODE,
              GENERIC_MODIFIER,
              hljs.C_LINE_COMMENT_MODE,
              hljs.C_BLOCK_COMMENT_MODE
            ]
          },
          {
            beginKeywords: 'namespace',
            relevance: 0,
            end: /[{;=]/,
            illegal: /[^\s:]/,
            contains: [
              TITLE_MODE,
              hljs.C_LINE_COMMENT_MODE,
              hljs.C_BLOCK_COMMENT_MODE
            ]
          },
          {
            beginKeywords: 'record',
            relevance: 0,
            end: /[{;=]/,
            illegal: /[^\s:]/,
            contains: [
              TITLE_MODE,
              GENERIC_MODIFIER,
              hljs.C_LINE_COMMENT_MODE,
              hljs.C_BLOCK_COMMENT_MODE
            ]
          },
          {
            // [Attributes("")]
            className: 'meta',
            begin: '^\\s*\\[',
            excludeBegin: true,
            end: '\\]',
            excludeEnd: true,
            contains: [
              {
                className: 'meta-string',
                begin: /"/,
                end: /"/
              }
            ]
          },
          {
            // Expression keywords prevent 'keyword Name(...)' from being
            // recognized as a function definition
            beginKeywords: 'new return throw await else',
            relevance: 0
          },
          {
            className: 'function',
            begin: '(' + TYPE_IDENT_RE + '\\s+)+' + hljs.IDENT_RE + '\\s*(<.+>\\s*)?\\(',
            returnBegin: true,
            end: /\s*[{;=]/,
            excludeEnd: true,
            keywords: KEYWORDS,
            contains: [
              // prevents these from being highlighted `title`
              {
                beginKeywords: FUNCTION_MODIFIERS.join(" "),
                relevance: 0
              },
              {
                begin: hljs.IDENT_RE + '\\s*(<.+>\\s*)?\\(',
                returnBegin: true,
                contains: [
                  hljs.TITLE_MODE,
                  GENERIC_MODIFIER
                ],
                relevance: 0
              },
              {
                className: 'params',
                begin: /\(/,
                end: /\)/,
                excludeBegin: true,
                excludeEnd: true,
                keywords: KEYWORDS,
                relevance: 0,
                contains: [
                  STRING,
                  NUMBERS,
                  hljs.C_BLOCK_COMMENT_MODE
                ]
              },
              hljs.C_LINE_COMMENT_MODE,
              hljs.C_BLOCK_COMMENT_MODE
            ]
          },
          AT_IDENTIFIER
        ]
      };
    }

    var csharp_1 = csharp;

    // https://docs.oracle.com/javase/specs/jls/se15/html/jls-3.html#jls-3.10
    var decimalDigits$1 = '[0-9](_*[0-9])*';
    var frac$1 = `\\.(${decimalDigits$1})`;
    var hexDigits$1 = '[0-9a-fA-F](_*[0-9a-fA-F])*';
    var NUMERIC$1 = {
      className: 'number',
      variants: [
        // DecimalFloatingPointLiteral
        // including ExponentPart
        { begin: `(\\b(${decimalDigits$1})((${frac$1})|\\.)?|(${frac$1}))` +
          `[eE][+-]?(${decimalDigits$1})[fFdD]?\\b` },
        // excluding ExponentPart
        { begin: `\\b(${decimalDigits$1})((${frac$1})[fFdD]?\\b|\\.([fFdD]\\b)?)` },
        { begin: `(${frac$1})[fFdD]?\\b` },
        { begin: `\\b(${decimalDigits$1})[fFdD]\\b` },

        // HexadecimalFloatingPointLiteral
        { begin: `\\b0[xX]((${hexDigits$1})\\.?|(${hexDigits$1})?\\.(${hexDigits$1}))` +
          `[pP][+-]?(${decimalDigits$1})[fFdD]?\\b` },

        // DecimalIntegerLiteral
        { begin: '\\b(0|[1-9](_*[0-9])*)[lL]?\\b' },

        // HexIntegerLiteral
        { begin: `\\b0[xX](${hexDigits$1})[lL]?\\b` },

        // OctalIntegerLiteral
        { begin: '\\b0(_*[0-7])*[lL]?\\b' },

        // BinaryIntegerLiteral
        { begin: '\\b0[bB][01](_*[01])*[lL]?\\b' },
      ],
      relevance: 0
    };

    /*
    Language: Java
    Author: Vsevolod Solovyov <vsevolod.solovyov@gmail.com>
    Category: common, enterprise
    Website: https://www.java.com/
    */

    function java(hljs) {
      var JAVA_IDENT_RE = '[\u00C0-\u02B8a-zA-Z_$][\u00C0-\u02B8a-zA-Z_$0-9]*';
      var GENERIC_IDENT_RE = JAVA_IDENT_RE + '(<' + JAVA_IDENT_RE + '(\\s*,\\s*' + JAVA_IDENT_RE + ')*>)?';
      var KEYWORDS = 'false synchronized int abstract float private char boolean var static null if const ' +
        'for true while long strictfp finally protected import native final void ' +
        'enum else break transient catch instanceof byte super volatile case assert short ' +
        'package default double public try this switch continue throws protected public private ' +
        'module requires exports do';

      var ANNOTATION = {
        className: 'meta',
        begin: '@' + JAVA_IDENT_RE,
        contains: [
          {
            begin: /\(/,
            end: /\)/,
            contains: ["self"] // allow nested () inside our annotation
          },
        ]
      };
      const NUMBER = NUMERIC$1;

      return {
        name: 'Java',
        aliases: ['jsp'],
        keywords: KEYWORDS,
        illegal: /<\/|#/,
        contains: [
          hljs.COMMENT(
            '/\\*\\*',
            '\\*/',
            {
              relevance: 0,
              contains: [
                {
                  // eat up @'s in emails to prevent them to be recognized as doctags
                  begin: /\w+@/, relevance: 0
                },
                {
                  className: 'doctag',
                  begin: '@[A-Za-z]+'
                }
              ]
            }
          ),
          // relevance boost
          {
            begin: /import java\.[a-z]+\./,
            keywords: "import",
            relevance: 2
          },
          hljs.C_LINE_COMMENT_MODE,
          hljs.C_BLOCK_COMMENT_MODE,
          hljs.APOS_STRING_MODE,
          hljs.QUOTE_STRING_MODE,
          {
            className: 'class',
            beginKeywords: 'class interface enum', end: /[{;=]/, excludeEnd: true,
            // TODO: can this be removed somehow?
            // an extra boost because Java is more popular than other languages with
            // this same syntax feature (this is just to preserve our tests passing
            // for now)
            relevance: 1,
            keywords: 'class interface enum',
            illegal: /[:"\[\]]/,
            contains: [
              { beginKeywords: 'extends implements' },
              hljs.UNDERSCORE_TITLE_MODE
            ]
          },
          {
            // Expression keywords prevent 'keyword Name(...)' from being
            // recognized as a function definition
            beginKeywords: 'new throw return else',
            relevance: 0
          },
          {
            className: 'class',
            begin: 'record\\s+' + hljs.UNDERSCORE_IDENT_RE + '\\s*\\(',
            returnBegin: true,
            excludeEnd: true,
            end: /[{;=]/,
            keywords: KEYWORDS,
            contains: [
              { beginKeywords: "record" },
              {
                begin: hljs.UNDERSCORE_IDENT_RE + '\\s*\\(',
                returnBegin: true,
                relevance: 0,
                contains: [hljs.UNDERSCORE_TITLE_MODE]
              },
              {
                className: 'params',
                begin: /\(/, end: /\)/,
                keywords: KEYWORDS,
                relevance: 0,
                contains: [
                  hljs.C_BLOCK_COMMENT_MODE
                ]
              },
              hljs.C_LINE_COMMENT_MODE,
              hljs.C_BLOCK_COMMENT_MODE
            ]
          },
          {
            className: 'function',
            begin: '(' + GENERIC_IDENT_RE + '\\s+)+' + hljs.UNDERSCORE_IDENT_RE + '\\s*\\(', returnBegin: true, end: /[{;=]/,
            excludeEnd: true,
            keywords: KEYWORDS,
            contains: [
              {
                begin: hljs.UNDERSCORE_IDENT_RE + '\\s*\\(', returnBegin: true,
                relevance: 0,
                contains: [hljs.UNDERSCORE_TITLE_MODE]
              },
              {
                className: 'params',
                begin: /\(/, end: /\)/,
                keywords: KEYWORDS,
                relevance: 0,
                contains: [
                  ANNOTATION,
                  hljs.APOS_STRING_MODE,
                  hljs.QUOTE_STRING_MODE,
                  NUMBER,
                  hljs.C_BLOCK_COMMENT_MODE
                ]
              },
              hljs.C_LINE_COMMENT_MODE,
              hljs.C_BLOCK_COMMENT_MODE
            ]
          },
          NUMBER,
          ANNOTATION
        ]
      };
    }

    var java_1 = java;

    // https://docs.oracle.com/javase/specs/jls/se15/html/jls-3.html#jls-3.10
    var decimalDigits = '[0-9](_*[0-9])*';
    var frac = `\\.(${decimalDigits})`;
    var hexDigits = '[0-9a-fA-F](_*[0-9a-fA-F])*';
    var NUMERIC = {
      className: 'number',
      variants: [
        // DecimalFloatingPointLiteral
        // including ExponentPart
        { begin: `(\\b(${decimalDigits})((${frac})|\\.)?|(${frac}))` +
          `[eE][+-]?(${decimalDigits})[fFdD]?\\b` },
        // excluding ExponentPart
        { begin: `\\b(${decimalDigits})((${frac})[fFdD]?\\b|\\.([fFdD]\\b)?)` },
        { begin: `(${frac})[fFdD]?\\b` },
        { begin: `\\b(${decimalDigits})[fFdD]\\b` },

        // HexadecimalFloatingPointLiteral
        { begin: `\\b0[xX]((${hexDigits})\\.?|(${hexDigits})?\\.(${hexDigits}))` +
          `[pP][+-]?(${decimalDigits})[fFdD]?\\b` },

        // DecimalIntegerLiteral
        { begin: '\\b(0|[1-9](_*[0-9])*)[lL]?\\b' },

        // HexIntegerLiteral
        { begin: `\\b0[xX](${hexDigits})[lL]?\\b` },

        // OctalIntegerLiteral
        { begin: '\\b0(_*[0-7])*[lL]?\\b' },

        // BinaryIntegerLiteral
        { begin: '\\b0[bB][01](_*[01])*[lL]?\\b' },
      ],
      relevance: 0
    };

    /*
     Language: Kotlin
     Description: Kotlin is an OSS statically typed programming language that targets the JVM, Android, JavaScript and Native.
     Author: Sergey Mashkov <cy6erGn0m@gmail.com>
     Website: https://kotlinlang.org
     Category: common
     */

    function kotlin(hljs) {
      const KEYWORDS = {
        keyword:
          'abstract as val var vararg get set class object open private protected public noinline ' +
          'crossinline dynamic final enum if else do while for when throw try catch finally ' +
          'import package is in fun override companion reified inline lateinit init ' +
          'interface annotation data sealed internal infix operator out by constructor super ' +
          'tailrec where const inner suspend typealias external expect actual',
        built_in:
          'Byte Short Char Int Long Boolean Float Double Void Unit Nothing',
        literal:
          'true false null'
      };
      const KEYWORDS_WITH_LABEL = {
        className: 'keyword',
        begin: /\b(break|continue|return|this)\b/,
        starts: {
          contains: [
            {
              className: 'symbol',
              begin: /@\w+/
            }
          ]
        }
      };
      const LABEL = {
        className: 'symbol',
        begin: hljs.UNDERSCORE_IDENT_RE + '@'
      };

      // for string templates
      const SUBST = {
        className: 'subst',
        begin: /\$\{/,
        end: /\}/,
        contains: [ hljs.C_NUMBER_MODE ]
      };
      const VARIABLE = {
        className: 'variable',
        begin: '\\$' + hljs.UNDERSCORE_IDENT_RE
      };
      const STRING = {
        className: 'string',
        variants: [
          {
            begin: '"""',
            end: '"""(?=[^"])',
            contains: [
              VARIABLE,
              SUBST
            ]
          },
          // Can't use built-in modes easily, as we want to use STRING in the meta
          // context as 'meta-string' and there's no syntax to remove explicitly set
          // classNames in built-in modes.
          {
            begin: '\'',
            end: '\'',
            illegal: /\n/,
            contains: [ hljs.BACKSLASH_ESCAPE ]
          },
          {
            begin: '"',
            end: '"',
            illegal: /\n/,
            contains: [
              hljs.BACKSLASH_ESCAPE,
              VARIABLE,
              SUBST
            ]
          }
        ]
      };
      SUBST.contains.push(STRING);

      const ANNOTATION_USE_SITE = {
        className: 'meta',
        begin: '@(?:file|property|field|get|set|receiver|param|setparam|delegate)\\s*:(?:\\s*' + hljs.UNDERSCORE_IDENT_RE + ')?'
      };
      const ANNOTATION = {
        className: 'meta',
        begin: '@' + hljs.UNDERSCORE_IDENT_RE,
        contains: [
          {
            begin: /\(/,
            end: /\)/,
            contains: [
              hljs.inherit(STRING, {
                className: 'meta-string'
              })
            ]
          }
        ]
      };

      // https://kotlinlang.org/docs/reference/whatsnew11.html#underscores-in-numeric-literals
      // According to the doc above, the number mode of kotlin is the same as java 8,
      // so the code below is copied from java.js
      const KOTLIN_NUMBER_MODE = NUMERIC;
      const KOTLIN_NESTED_COMMENT = hljs.COMMENT(
        '/\\*', '\\*/',
        {
          contains: [ hljs.C_BLOCK_COMMENT_MODE ]
        }
      );
      const KOTLIN_PAREN_TYPE = {
        variants: [
          {
            className: 'type',
            begin: hljs.UNDERSCORE_IDENT_RE
          },
          {
            begin: /\(/,
            end: /\)/,
            contains: [] // defined later
          }
        ]
      };
      const KOTLIN_PAREN_TYPE2 = KOTLIN_PAREN_TYPE;
      KOTLIN_PAREN_TYPE2.variants[1].contains = [ KOTLIN_PAREN_TYPE ];
      KOTLIN_PAREN_TYPE.variants[1].contains = [ KOTLIN_PAREN_TYPE2 ];

      return {
        name: 'Kotlin',
        aliases: [ 'kt', 'kts' ],
        keywords: KEYWORDS,
        contains: [
          hljs.COMMENT(
            '/\\*\\*',
            '\\*/',
            {
              relevance: 0,
              contains: [
                {
                  className: 'doctag',
                  begin: '@[A-Za-z]+'
                }
              ]
            }
          ),
          hljs.C_LINE_COMMENT_MODE,
          KOTLIN_NESTED_COMMENT,
          KEYWORDS_WITH_LABEL,
          LABEL,
          ANNOTATION_USE_SITE,
          ANNOTATION,
          {
            className: 'function',
            beginKeywords: 'fun',
            end: '[(]|$',
            returnBegin: true,
            excludeEnd: true,
            keywords: KEYWORDS,
            relevance: 5,
            contains: [
              {
                begin: hljs.UNDERSCORE_IDENT_RE + '\\s*\\(',
                returnBegin: true,
                relevance: 0,
                contains: [ hljs.UNDERSCORE_TITLE_MODE ]
              },
              {
                className: 'type',
                begin: /</,
                end: />/,
                keywords: 'reified',
                relevance: 0
              },
              {
                className: 'params',
                begin: /\(/,
                end: /\)/,
                endsParent: true,
                keywords: KEYWORDS,
                relevance: 0,
                contains: [
                  {
                    begin: /:/,
                    end: /[=,\/]/,
                    endsWithParent: true,
                    contains: [
                      KOTLIN_PAREN_TYPE,
                      hljs.C_LINE_COMMENT_MODE,
                      KOTLIN_NESTED_COMMENT
                    ],
                    relevance: 0
                  },
                  hljs.C_LINE_COMMENT_MODE,
                  KOTLIN_NESTED_COMMENT,
                  ANNOTATION_USE_SITE,
                  ANNOTATION,
                  STRING,
                  hljs.C_NUMBER_MODE
                ]
              },
              KOTLIN_NESTED_COMMENT
            ]
          },
          {
            className: 'class',
            beginKeywords: 'class interface trait', // remove 'trait' when removed from KEYWORDS
            end: /[:\{(]|$/,
            excludeEnd: true,
            illegal: 'extends implements',
            contains: [
              {
                beginKeywords: 'public protected internal private constructor'
              },
              hljs.UNDERSCORE_TITLE_MODE,
              {
                className: 'type',
                begin: /</,
                end: />/,
                excludeBegin: true,
                excludeEnd: true,
                relevance: 0
              },
              {
                className: 'type',
                begin: /[,:]\s*/,
                end: /[<\(,]|$/,
                excludeBegin: true,
                returnEnd: true
              },
              ANNOTATION_USE_SITE,
              ANNOTATION
            ]
          },
          STRING,
          {
            className: 'meta',
            begin: "^#!/usr/bin/env",
            end: '$',
            illegal: '\n'
          },
          KOTLIN_NUMBER_MODE
        ]
      };
    }

    var kotlin_1 = kotlin;

    /*
    Language: Scala
    Category: functional
    Author: Jan Berkel <jan.berkel@gmail.com>
    Contributors: Erik Osheim <d_m@plastic-idolatry.com>
    Website: https://www.scala-lang.org
    */

    function scala(hljs) {
      const ANNOTATION = {
        className: 'meta',
        begin: '@[A-Za-z]+'
      };

      // used in strings for escaping/interpolation/substitution
      const SUBST = {
        className: 'subst',
        variants: [
          {
            begin: '\\$[A-Za-z0-9_]+'
          },
          {
            begin: /\$\{/,
            end: /\}/
          }
        ]
      };

      const STRING = {
        className: 'string',
        variants: [
          {
            begin: '"""',
            end: '"""'
          },
          {
            begin: '"',
            end: '"',
            illegal: '\\n',
            contains: [ hljs.BACKSLASH_ESCAPE ]
          },
          {
            begin: '[a-z]+"',
            end: '"',
            illegal: '\\n',
            contains: [
              hljs.BACKSLASH_ESCAPE,
              SUBST
            ]
          },
          {
            className: 'string',
            begin: '[a-z]+"""',
            end: '"""',
            contains: [ SUBST ],
            relevance: 10
          }
        ]

      };

      const SYMBOL = {
        className: 'symbol',
        begin: '\'\\w[\\w\\d_]*(?!\')'
      };

      const TYPE = {
        className: 'type',
        begin: '\\b[A-Z][A-Za-z0-9_]*',
        relevance: 0
      };

      const NAME = {
        className: 'title',
        begin: /[^0-9\n\t "'(),.`{}\[\]:;][^\n\t "'(),.`{}\[\]:;]+|[^0-9\n\t "'(),.`{}\[\]:;=]/,
        relevance: 0
      };

      const CLASS = {
        className: 'class',
        beginKeywords: 'class object trait type',
        end: /[:={\[\n;]/,
        excludeEnd: true,
        contains: [
          hljs.C_LINE_COMMENT_MODE,
          hljs.C_BLOCK_COMMENT_MODE,
          {
            beginKeywords: 'extends with',
            relevance: 10
          },
          {
            begin: /\[/,
            end: /\]/,
            excludeBegin: true,
            excludeEnd: true,
            relevance: 0,
            contains: [ TYPE ]
          },
          {
            className: 'params',
            begin: /\(/,
            end: /\)/,
            excludeBegin: true,
            excludeEnd: true,
            relevance: 0,
            contains: [ TYPE ]
          },
          NAME
        ]
      };

      const METHOD = {
        className: 'function',
        beginKeywords: 'def',
        end: /[:={\[(\n;]/,
        excludeEnd: true,
        contains: [ NAME ]
      };

      return {
        name: 'Scala',
        keywords: {
          literal: 'true false null',
          keyword: 'type yield lazy override def with val var sealed abstract private trait object if forSome for while throw finally protected extends import final return else break new catch super class case package default try this match continue throws implicit'
        },
        contains: [
          hljs.C_LINE_COMMENT_MODE,
          hljs.C_BLOCK_COMMENT_MODE,
          STRING,
          SYMBOL,
          TYPE,
          METHOD,
          CLASS,
          hljs.C_NUMBER_MODE,
          ANNOTATION
        ]
      };
    }

    var scala_1 = scala;

    /**
     * @param {string} value
     * @returns {RegExp}
     * */

    /**
     * @param {RegExp | string } re
     * @returns {string}
     */
    function source$1(re) {
      if (!re) return null;
      if (typeof re === "string") return re;

      return re.source;
    }

    /**
     * @param {...(RegExp | string) } args
     * @returns {string}
     */
    function concat$1(...args) {
      const joined = args.map((x) => source$1(x)).join("");
      return joined;
    }

    /**
     * Any of the passed expresssions may match
     *
     * Creates a huge this | this | that | that match
     * @param {(RegExp | string)[] } args
     * @returns {string}
     */
    function either(...args) {
      const joined = '(' + args.map((x) => source$1(x)).join("|") + ")";
      return joined;
    }

    /*
     Language: SQL
     Website: https://en.wikipedia.org/wiki/SQL
     Category: common, database
     */

    function sql(hljs) {
      const COMMENT_MODE = hljs.COMMENT('--', '$');
      const STRING = {
        className: 'string',
        variants: [
          {
            begin: /'/,
            end: /'/,
            contains: [
              {begin: /''/ }
            ]
          }
        ]
      };
      const QUOTED_IDENTIFIER = {
        begin: /"/,
        end: /"/,
        contains: [ { begin: /""/ } ]
      };

      const LITERALS = [
        "true",
        "false",
        // Not sure it's correct to call NULL literal, and clauses like IS [NOT] NULL look strange that way.
        // "null",
        "unknown"
      ];

      const MULTI_WORD_TYPES = [
        "double precision",
        "large object",
        "with timezone",
        "without timezone"
      ];

      const TYPES = [
        'bigint',
        'binary',
        'blob',
        'boolean',
        'char',
        'character',
        'clob',
        'date',
        'dec',
        'decfloat',
        'decimal',
        'float',
        'int',
        'integer',
        'interval',
        'nchar',
        'nclob',
        'national',
        'numeric',
        'real',
        'row',
        'smallint',
        'time',
        'timestamp',
        'varchar',
        'varying', // modifier (character varying)
        'varbinary'
      ];

      const NON_RESERVED_WORDS = [
        "add",
        "asc",
        "collation",
        "desc",
        "final",
        "first",
        "last",
        "view"
      ];

      // https://jakewheat.github.io/sql-overview/sql-2016-foundation-grammar.html#reserved-word
      const RESERVED_WORDS = [
        "abs",
        "acos",
        "all",
        "allocate",
        "alter",
        "and",
        "any",
        "are",
        "array",
        "array_agg",
        "array_max_cardinality",
        "as",
        "asensitive",
        "asin",
        "asymmetric",
        "at",
        "atan",
        "atomic",
        "authorization",
        "avg",
        "begin",
        "begin_frame",
        "begin_partition",
        "between",
        "bigint",
        "binary",
        "blob",
        "boolean",
        "both",
        "by",
        "call",
        "called",
        "cardinality",
        "cascaded",
        "case",
        "cast",
        "ceil",
        "ceiling",
        "char",
        "char_length",
        "character",
        "character_length",
        "check",
        "classifier",
        "clob",
        "close",
        "coalesce",
        "collate",
        "collect",
        "column",
        "commit",
        "condition",
        "connect",
        "constraint",
        "contains",
        "convert",
        "copy",
        "corr",
        "corresponding",
        "cos",
        "cosh",
        "count",
        "covar_pop",
        "covar_samp",
        "create",
        "cross",
        "cube",
        "cume_dist",
        "current",
        "current_catalog",
        "current_date",
        "current_default_transform_group",
        "current_path",
        "current_role",
        "current_row",
        "current_schema",
        "current_time",
        "current_timestamp",
        "current_path",
        "current_role",
        "current_transform_group_for_type",
        "current_user",
        "cursor",
        "cycle",
        "date",
        "day",
        "deallocate",
        "dec",
        "decimal",
        "decfloat",
        "declare",
        "default",
        "define",
        "delete",
        "dense_rank",
        "deref",
        "describe",
        "deterministic",
        "disconnect",
        "distinct",
        "double",
        "drop",
        "dynamic",
        "each",
        "element",
        "else",
        "empty",
        "end",
        "end_frame",
        "end_partition",
        "end-exec",
        "equals",
        "escape",
        "every",
        "except",
        "exec",
        "execute",
        "exists",
        "exp",
        "external",
        "extract",
        "false",
        "fetch",
        "filter",
        "first_value",
        "float",
        "floor",
        "for",
        "foreign",
        "frame_row",
        "free",
        "from",
        "full",
        "function",
        "fusion",
        "get",
        "global",
        "grant",
        "group",
        "grouping",
        "groups",
        "having",
        "hold",
        "hour",
        "identity",
        "in",
        "indicator",
        "initial",
        "inner",
        "inout",
        "insensitive",
        "insert",
        "int",
        "integer",
        "intersect",
        "intersection",
        "interval",
        "into",
        "is",
        "join",
        "json_array",
        "json_arrayagg",
        "json_exists",
        "json_object",
        "json_objectagg",
        "json_query",
        "json_table",
        "json_table_primitive",
        "json_value",
        "lag",
        "language",
        "large",
        "last_value",
        "lateral",
        "lead",
        "leading",
        "left",
        "like",
        "like_regex",
        "listagg",
        "ln",
        "local",
        "localtime",
        "localtimestamp",
        "log",
        "log10",
        "lower",
        "match",
        "match_number",
        "match_recognize",
        "matches",
        "max",
        "member",
        "merge",
        "method",
        "min",
        "minute",
        "mod",
        "modifies",
        "module",
        "month",
        "multiset",
        "national",
        "natural",
        "nchar",
        "nclob",
        "new",
        "no",
        "none",
        "normalize",
        "not",
        "nth_value",
        "ntile",
        "null",
        "nullif",
        "numeric",
        "octet_length",
        "occurrences_regex",
        "of",
        "offset",
        "old",
        "omit",
        "on",
        "one",
        "only",
        "open",
        "or",
        "order",
        "out",
        "outer",
        "over",
        "overlaps",
        "overlay",
        "parameter",
        "partition",
        "pattern",
        "per",
        "percent",
        "percent_rank",
        "percentile_cont",
        "percentile_disc",
        "period",
        "portion",
        "position",
        "position_regex",
        "power",
        "precedes",
        "precision",
        "prepare",
        "primary",
        "procedure",
        "ptf",
        "range",
        "rank",
        "reads",
        "real",
        "recursive",
        "ref",
        "references",
        "referencing",
        "regr_avgx",
        "regr_avgy",
        "regr_count",
        "regr_intercept",
        "regr_r2",
        "regr_slope",
        "regr_sxx",
        "regr_sxy",
        "regr_syy",
        "release",
        "result",
        "return",
        "returns",
        "revoke",
        "right",
        "rollback",
        "rollup",
        "row",
        "row_number",
        "rows",
        "running",
        "savepoint",
        "scope",
        "scroll",
        "search",
        "second",
        "seek",
        "select",
        "sensitive",
        "session_user",
        "set",
        "show",
        "similar",
        "sin",
        "sinh",
        "skip",
        "smallint",
        "some",
        "specific",
        "specifictype",
        "sql",
        "sqlexception",
        "sqlstate",
        "sqlwarning",
        "sqrt",
        "start",
        "static",
        "stddev_pop",
        "stddev_samp",
        "submultiset",
        "subset",
        "substring",
        "substring_regex",
        "succeeds",
        "sum",
        "symmetric",
        "system",
        "system_time",
        "system_user",
        "table",
        "tablesample",
        "tan",
        "tanh",
        "then",
        "time",
        "timestamp",
        "timezone_hour",
        "timezone_minute",
        "to",
        "trailing",
        "translate",
        "translate_regex",
        "translation",
        "treat",
        "trigger",
        "trim",
        "trim_array",
        "true",
        "truncate",
        "uescape",
        "union",
        "unique",
        "unknown",
        "unnest",
        "update   ",
        "upper",
        "user",
        "using",
        "value",
        "values",
        "value_of",
        "var_pop",
        "var_samp",
        "varbinary",
        "varchar",
        "varying",
        "versioning",
        "when",
        "whenever",
        "where",
        "width_bucket",
        "window",
        "with",
        "within",
        "without",
        "year",
      ];

      // these are reserved words we have identified to be functions
      // and should only be highlighted in a dispatch-like context
      // ie, array_agg(...), etc.
      const RESERVED_FUNCTIONS = [
        "abs",
        "acos",
        "array_agg",
        "asin",
        "atan",
        "avg",
        "cast",
        "ceil",
        "ceiling",
        "coalesce",
        "corr",
        "cos",
        "cosh",
        "count",
        "covar_pop",
        "covar_samp",
        "cume_dist",
        "dense_rank",
        "deref",
        "element",
        "exp",
        "extract",
        "first_value",
        "floor",
        "json_array",
        "json_arrayagg",
        "json_exists",
        "json_object",
        "json_objectagg",
        "json_query",
        "json_table",
        "json_table_primitive",
        "json_value",
        "lag",
        "last_value",
        "lead",
        "listagg",
        "ln",
        "log",
        "log10",
        "lower",
        "max",
        "min",
        "mod",
        "nth_value",
        "ntile",
        "nullif",
        "percent_rank",
        "percentile_cont",
        "percentile_disc",
        "position",
        "position_regex",
        "power",
        "rank",
        "regr_avgx",
        "regr_avgy",
        "regr_count",
        "regr_intercept",
        "regr_r2",
        "regr_slope",
        "regr_sxx",
        "regr_sxy",
        "regr_syy",
        "row_number",
        "sin",
        "sinh",
        "sqrt",
        "stddev_pop",
        "stddev_samp",
        "substring",
        "substring_regex",
        "sum",
        "tan",
        "tanh",
        "translate",
        "translate_regex",
        "treat",
        "trim",
        "trim_array",
        "unnest",
        "upper",
        "value_of",
        "var_pop",
        "var_samp",
        "width_bucket",
      ];

      // these functions can
      const POSSIBLE_WITHOUT_PARENS = [
        "current_catalog",
        "current_date",
        "current_default_transform_group",
        "current_path",
        "current_role",
        "current_schema",
        "current_transform_group_for_type",
        "current_user",
        "session_user",
        "system_time",
        "system_user",
        "current_time",
        "localtime",
        "current_timestamp",
        "localtimestamp"
      ];

      // those exist to boost relevance making these very
      // "SQL like" keyword combos worth +1 extra relevance
      const COMBOS = [
        "create table",
        "insert into",
        "primary key",
        "foreign key",
        "not null",
        "alter table",
        "add constraint",
        "grouping sets",
        "on overflow",
        "character set",
        "respect nulls",
        "ignore nulls",
        "nulls first",
        "nulls last",
        "depth first",
        "breadth first"
      ];

      const FUNCTIONS = RESERVED_FUNCTIONS;

      const KEYWORDS = [...RESERVED_WORDS, ...NON_RESERVED_WORDS].filter((keyword) => {
        return !RESERVED_FUNCTIONS.includes(keyword);
      });

      const VARIABLE = {
        className: "variable",
        begin: /@[a-z0-9]+/,
      };

      const OPERATOR = {
        className: "operator",
        begin: /[-+*/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?/,
        relevance: 0,
      };

      const FUNCTION_CALL = {
        begin: concat$1(/\b/, either(...FUNCTIONS), /\s*\(/),
        keywords: {
          built_in: FUNCTIONS
        }
      };

      // keywords with less than 3 letters are reduced in relevancy
      function reduceRelevancy(list, {exceptions, when} = {}) {
        const qualifyFn = when;
        exceptions = exceptions || [];
        return list.map((item) => {
          if (item.match(/\|\d+$/) || exceptions.includes(item)) {
            return item;
          } else if (qualifyFn(item)) {
            return `${item}|0`;
          } else {
            return item;
          }
        });
      }

      return {
        name: 'SQL',
        case_insensitive: true,
        // does not include {} or HTML tags `</`
        illegal: /[{}]|<\//,
        keywords: {
          $pattern: /\b[\w\.]+/,
          keyword:
            reduceRelevancy(KEYWORDS, { when: (x) => x.length < 3 }),
          literal: LITERALS,
          type: TYPES,
          built_in: POSSIBLE_WITHOUT_PARENS
        },
        contains: [
          {
            begin: either(...COMBOS),
            keywords: {
              $pattern: /[\w\.]+/,
              keyword: KEYWORDS.concat(COMBOS),
              literal: LITERALS,
              type: TYPES
            },
          },
          {
            className: "type",
            begin: either(...MULTI_WORD_TYPES)
          },
          FUNCTION_CALL,
          VARIABLE,
          STRING,
          QUOTED_IDENTIFIER,
          hljs.C_NUMBER_MODE,
          hljs.C_BLOCK_COMMENT_MODE,
          COMMENT_MODE,
          OPERATOR
        ]
      };
    }

    var sql_1 = sql;

    const IDENT_RE = '[A-Za-z$_][0-9A-Za-z$_]*';
    const KEYWORDS = [
      "as", // for exports
      "in",
      "of",
      "if",
      "for",
      "while",
      "finally",
      "var",
      "new",
      "function",
      "do",
      "return",
      "void",
      "else",
      "break",
      "catch",
      "instanceof",
      "with",
      "throw",
      "case",
      "default",
      "try",
      "switch",
      "continue",
      "typeof",
      "delete",
      "let",
      "yield",
      "const",
      "class",
      // JS handles these with a special rule
      // "get",
      // "set",
      "debugger",
      "async",
      "await",
      "static",
      "import",
      "from",
      "export",
      "extends"
    ];
    const LITERALS = [
      "true",
      "false",
      "null",
      "undefined",
      "NaN",
      "Infinity"
    ];

    const TYPES = [
      "Intl",
      "DataView",
      "Number",
      "Math",
      "Date",
      "String",
      "RegExp",
      "Object",
      "Function",
      "Boolean",
      "Error",
      "Symbol",
      "Set",
      "Map",
      "WeakSet",
      "WeakMap",
      "Proxy",
      "Reflect",
      "JSON",
      "Promise",
      "Float64Array",
      "Int16Array",
      "Int32Array",
      "Int8Array",
      "Uint16Array",
      "Uint32Array",
      "Float32Array",
      "Array",
      "Uint8Array",
      "Uint8ClampedArray",
      "ArrayBuffer",
      "BigInt64Array",
      "BigUint64Array",
      "BigInt"
    ];

    const ERROR_TYPES = [
      "EvalError",
      "InternalError",
      "RangeError",
      "ReferenceError",
      "SyntaxError",
      "TypeError",
      "URIError"
    ];

    const BUILT_IN_GLOBALS = [
      "setInterval",
      "setTimeout",
      "clearInterval",
      "clearTimeout",

      "require",
      "exports",

      "eval",
      "isFinite",
      "isNaN",
      "parseFloat",
      "parseInt",
      "decodeURI",
      "decodeURIComponent",
      "encodeURI",
      "encodeURIComponent",
      "escape",
      "unescape"
    ];

    const BUILT_IN_VARIABLES = [
      "arguments",
      "this",
      "super",
      "console",
      "window",
      "document",
      "localStorage",
      "module",
      "global" // Node.js
    ];

    const BUILT_INS = [].concat(
      BUILT_IN_GLOBALS,
      BUILT_IN_VARIABLES,
      TYPES,
      ERROR_TYPES
    );

    /**
     * @param {string} value
     * @returns {RegExp}
     * */

    /**
     * @param {RegExp | string } re
     * @returns {string}
     */
    function source(re) {
      if (!re) return null;
      if (typeof re === "string") return re;

      return re.source;
    }

    /**
     * @param {RegExp | string } re
     * @returns {string}
     */
    function lookahead(re) {
      return concat('(?=', re, ')');
    }

    /**
     * @param {...(RegExp | string) } args
     * @returns {string}
     */
    function concat(...args) {
      const joined = args.map((x) => source(x)).join("");
      return joined;
    }

    /*
    Language: JavaScript
    Description: JavaScript (JS) is a lightweight, interpreted, or just-in-time compiled programming language with first-class functions.
    Category: common, scripting
    Website: https://developer.mozilla.org/en-US/docs/Web/JavaScript
    */

    /** @type LanguageFn */
    function javascript(hljs) {
      /**
       * Takes a string like "<Booger" and checks to see
       * if we can find a matching "</Booger" later in the
       * content.
       * @param {RegExpMatchArray} match
       * @param {{after:number}} param1
       */
      const hasClosingTag = (match, { after }) => {
        const tag = "</" + match[0].slice(1);
        const pos = match.input.indexOf(tag, after);
        return pos !== -1;
      };

      const IDENT_RE$1 = IDENT_RE;
      const FRAGMENT = {
        begin: '<>',
        end: '</>'
      };
      const XML_TAG = {
        begin: /<[A-Za-z0-9\\._:-]+/,
        end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
        /**
         * @param {RegExpMatchArray} match
         * @param {CallbackResponse} response
         */
        isTrulyOpeningTag: (match, response) => {
          const afterMatchIndex = match[0].length + match.index;
          const nextChar = match.input[afterMatchIndex];
          // nested type?
          // HTML should not include another raw `<` inside a tag
          // But a type might: `<Array<Array<number>>`, etc.
          if (nextChar === "<") {
            response.ignoreMatch();
            return;
          }
          // <something>
          // This is now either a tag or a type.
          if (nextChar === ">") {
            // if we cannot find a matching closing tag, then we
            // will ignore it
            if (!hasClosingTag(match, { after: afterMatchIndex })) {
              response.ignoreMatch();
            }
          }
        }
      };
      const KEYWORDS$1 = {
        $pattern: IDENT_RE,
        keyword: KEYWORDS,
        literal: LITERALS,
        built_in: BUILT_INS
      };

      // https://tc39.es/ecma262/#sec-literals-numeric-literals
      const decimalDigits = '[0-9](_?[0-9])*';
      const frac = `\\.(${decimalDigits})`;
      // DecimalIntegerLiteral, including Annex B NonOctalDecimalIntegerLiteral
      // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
      const decimalInteger = `0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*`;
      const NUMBER = {
        className: 'number',
        variants: [
          // DecimalLiteral
          { begin: `(\\b(${decimalInteger})((${frac})|\\.)?|(${frac}))` +
            `[eE][+-]?(${decimalDigits})\\b` },
          { begin: `\\b(${decimalInteger})\\b((${frac})\\b|\\.)?|(${frac})\\b` },

          // DecimalBigIntegerLiteral
          { begin: `\\b(0|[1-9](_?[0-9])*)n\\b` },

          // NonDecimalIntegerLiteral
          { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
          { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
          { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },

          // LegacyOctalIntegerLiteral (does not include underscore separators)
          // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
          { begin: "\\b0[0-7]+n?\\b" },
        ],
        relevance: 0
      };

      const SUBST = {
        className: 'subst',
        begin: '\\$\\{',
        end: '\\}',
        keywords: KEYWORDS$1,
        contains: [] // defined later
      };
      const HTML_TEMPLATE = {
        begin: 'html`',
        end: '',
        starts: {
          end: '`',
          returnEnd: false,
          contains: [
            hljs.BACKSLASH_ESCAPE,
            SUBST
          ],
          subLanguage: 'xml'
        }
      };
      const CSS_TEMPLATE = {
        begin: 'css`',
        end: '',
        starts: {
          end: '`',
          returnEnd: false,
          contains: [
            hljs.BACKSLASH_ESCAPE,
            SUBST
          ],
          subLanguage: 'css'
        }
      };
      const TEMPLATE_STRING = {
        className: 'string',
        begin: '`',
        end: '`',
        contains: [
          hljs.BACKSLASH_ESCAPE,
          SUBST
        ]
      };
      const JSDOC_COMMENT = hljs.COMMENT(
        /\/\*\*(?!\/)/,
        '\\*/',
        {
          relevance: 0,
          contains: [
            {
              className: 'doctag',
              begin: '@[A-Za-z]+',
              contains: [
                {
                  className: 'type',
                  begin: '\\{',
                  end: '\\}',
                  relevance: 0
                },
                {
                  className: 'variable',
                  begin: IDENT_RE$1 + '(?=\\s*(-)|$)',
                  endsParent: true,
                  relevance: 0
                },
                // eat spaces (not newlines) so we can find
                // types or variables
                {
                  begin: /(?=[^\n])\s/,
                  relevance: 0
                }
              ]
            }
          ]
        }
      );
      const COMMENT = {
        className: "comment",
        variants: [
          JSDOC_COMMENT,
          hljs.C_BLOCK_COMMENT_MODE,
          hljs.C_LINE_COMMENT_MODE
        ]
      };
      const SUBST_INTERNALS = [
        hljs.APOS_STRING_MODE,
        hljs.QUOTE_STRING_MODE,
        HTML_TEMPLATE,
        CSS_TEMPLATE,
        TEMPLATE_STRING,
        NUMBER,
        hljs.REGEXP_MODE
      ];
      SUBST.contains = SUBST_INTERNALS
        .concat({
          // we need to pair up {} inside our subst to prevent
          // it from ending too early by matching another }
          begin: /\{/,
          end: /\}/,
          keywords: KEYWORDS$1,
          contains: [
            "self"
          ].concat(SUBST_INTERNALS)
        });
      const SUBST_AND_COMMENTS = [].concat(COMMENT, SUBST.contains);
      const PARAMS_CONTAINS = SUBST_AND_COMMENTS.concat([
        // eat recursive parens in sub expressions
        {
          begin: /\(/,
          end: /\)/,
          keywords: KEYWORDS$1,
          contains: ["self"].concat(SUBST_AND_COMMENTS)
        }
      ]);
      const PARAMS = {
        className: 'params',
        begin: /\(/,
        end: /\)/,
        excludeBegin: true,
        excludeEnd: true,
        keywords: KEYWORDS$1,
        contains: PARAMS_CONTAINS
      };

      return {
        name: 'Javascript',
        aliases: ['js', 'jsx', 'mjs', 'cjs'],
        keywords: KEYWORDS$1,
        // this will be extended by TypeScript
        exports: { PARAMS_CONTAINS },
        illegal: /#(?![$_A-z])/,
        contains: [
          hljs.SHEBANG({
            label: "shebang",
            binary: "node",
            relevance: 5
          }),
          {
            label: "use_strict",
            className: 'meta',
            relevance: 10,
            begin: /^\s*['"]use (strict|asm)['"]/
          },
          hljs.APOS_STRING_MODE,
          hljs.QUOTE_STRING_MODE,
          HTML_TEMPLATE,
          CSS_TEMPLATE,
          TEMPLATE_STRING,
          COMMENT,
          NUMBER,
          { // object attr container
            begin: concat(/[{,\n]\s*/,
              // we need to look ahead to make sure that we actually have an
              // attribute coming up so we don't steal a comma from a potential
              // "value" container
              //
              // NOTE: this might not work how you think.  We don't actually always
              // enter this mode and stay.  Instead it might merely match `,
              // <comments up next>` and then immediately end after the , because it
              // fails to find any actual attrs. But this still does the job because
              // it prevents the value contain rule from grabbing this instead and
              // prevening this rule from firing when we actually DO have keys.
              lookahead(concat(
                // we also need to allow for multiple possible comments inbetween
                // the first key:value pairing
                /(((\/\/.*$)|(\/\*(\*[^/]|[^*])*\*\/))\s*)*/,
                IDENT_RE$1 + '\\s*:'))),
            relevance: 0,
            contains: [
              {
                className: 'attr',
                begin: IDENT_RE$1 + lookahead('\\s*:'),
                relevance: 0
              }
            ]
          },
          { // "value" container
            begin: '(' + hljs.RE_STARTERS_RE + '|\\b(case|return|throw)\\b)\\s*',
            keywords: 'return throw case',
            contains: [
              COMMENT,
              hljs.REGEXP_MODE,
              {
                className: 'function',
                // we have to count the parens to make sure we actually have the
                // correct bounding ( ) before the =>.  There could be any number of
                // sub-expressions inside also surrounded by parens.
                begin: '(\\(' +
                '[^()]*(\\(' +
                '[^()]*(\\(' +
                '[^()]*' +
                '\\)[^()]*)*' +
                '\\)[^()]*)*' +
                '\\)|' + hljs.UNDERSCORE_IDENT_RE + ')\\s*=>',
                returnBegin: true,
                end: '\\s*=>',
                contains: [
                  {
                    className: 'params',
                    variants: [
                      {
                        begin: hljs.UNDERSCORE_IDENT_RE,
                        relevance: 0
                      },
                      {
                        className: null,
                        begin: /\(\s*\)/,
                        skip: true
                      },
                      {
                        begin: /\(/,
                        end: /\)/,
                        excludeBegin: true,
                        excludeEnd: true,
                        keywords: KEYWORDS$1,
                        contains: PARAMS_CONTAINS
                      }
                    ]
                  }
                ]
              },
              { // could be a comma delimited list of params to a function call
                begin: /,/, relevance: 0
              },
              {
                className: '',
                begin: /\s/,
                end: /\s*/,
                skip: true
              },
              { // JSX
                variants: [
                  { begin: FRAGMENT.begin, end: FRAGMENT.end },
                  {
                    begin: XML_TAG.begin,
                    // we carefully check the opening tag to see if it truly
                    // is a tag and not a false positive
                    'on:begin': XML_TAG.isTrulyOpeningTag,
                    end: XML_TAG.end
                  }
                ],
                subLanguage: 'xml',
                contains: [
                  {
                    begin: XML_TAG.begin,
                    end: XML_TAG.end,
                    skip: true,
                    contains: ['self']
                  }
                ]
              }
            ],
            relevance: 0
          },
          {
            className: 'function',
            beginKeywords: 'function',
            end: /[{;]/,
            excludeEnd: true,
            keywords: KEYWORDS$1,
            contains: [
              'self',
              hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1 }),
              PARAMS
            ],
            illegal: /%/
          },
          {
            // prevent this from getting swallowed up by function
            // since they appear "function like"
            beginKeywords: "while if switch catch for"
          },
          {
            className: 'function',
            // we have to count the parens to make sure we actually have the correct
            // bounding ( ).  There could be any number of sub-expressions inside
            // also surrounded by parens.
            begin: hljs.UNDERSCORE_IDENT_RE +
              '\\(' + // first parens
              '[^()]*(\\(' +
                '[^()]*(\\(' +
                  '[^()]*' +
                '\\)[^()]*)*' +
              '\\)[^()]*)*' +
              '\\)\\s*\\{', // end parens
            returnBegin:true,
            contains: [
              PARAMS,
              hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1 }),
            ]
          },
          // hack: prevents detection of keywords in some circumstances
          // .keyword()
          // $keyword = x
          {
            variants: [
              { begin: '\\.' + IDENT_RE$1 },
              { begin: '\\$' + IDENT_RE$1 }
            ],
            relevance: 0
          },
          { // ES6 class
            className: 'class',
            beginKeywords: 'class',
            end: /[{;=]/,
            excludeEnd: true,
            illegal: /[:"[\]]/,
            contains: [
              { beginKeywords: 'extends' },
              hljs.UNDERSCORE_TITLE_MODE
            ]
          },
          {
            begin: /\b(?=constructor)/,
            end: /[{;]/,
            excludeEnd: true,
            contains: [
              hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1 }),
              'self',
              PARAMS
            ]
          },
          {
            begin: '(get|set)\\s+(?=' + IDENT_RE$1 + '\\()',
            end: /\{/,
            keywords: "get set",
            contains: [
              hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1 }),
              { begin: /\(\)/ }, // eat to avoid empty params
              PARAMS
            ]
          },
          {
            begin: /\$[(.]/ // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
          }
        ]
      };
    }

    /*
    Language: TypeScript
    Author: Panu Horsmalahti <panu.horsmalahti@iki.fi>
    Contributors: Ike Ku <dempfi@yahoo.com>
    Description: TypeScript is a strict superset of JavaScript
    Website: https://www.typescriptlang.org
    Category: common, scripting
    */

    /** @type LanguageFn */
    function typescript(hljs) {
      const IDENT_RE$1 = IDENT_RE;
      const NAMESPACE = {
        beginKeywords: 'namespace', end: /\{/, excludeEnd: true
      };
      const INTERFACE = {
        beginKeywords: 'interface', end: /\{/, excludeEnd: true,
        keywords: 'interface extends'
      };
      const USE_STRICT = {
        className: 'meta',
        relevance: 10,
        begin: /^\s*['"]use strict['"]/
      };
      const TYPES = [
        "any",
        "void",
        "number",
        "boolean",
        "string",
        "object",
        "never",
        "enum"
      ];
      const TS_SPECIFIC_KEYWORDS = [
        "type",
        "namespace",
        "typedef",
        "interface",
        "public",
        "private",
        "protected",
        "implements",
        "declare",
        "abstract",
        "readonly"
      ];
      const KEYWORDS$1 = {
        $pattern: IDENT_RE,
        keyword: KEYWORDS.concat(TS_SPECIFIC_KEYWORDS),
        literal: LITERALS,
        built_in: BUILT_INS.concat(TYPES)
      };
      const DECORATOR = {
        className: 'meta',
        begin: '@' + IDENT_RE$1,
      };

      const swapMode = (mode, label, replacement) => {
        const indx = mode.contains.findIndex(m => m.label === label);
        if (indx === -1) { throw new Error("can not find mode to replace"); }
        mode.contains.splice(indx, 1, replacement);
      };

      const tsLanguage = javascript(hljs);

      // this should update anywhere keywords is used since
      // it will be the same actual JS object
      Object.assign(tsLanguage.keywords, KEYWORDS$1);

      tsLanguage.exports.PARAMS_CONTAINS.push(DECORATOR);
      tsLanguage.contains = tsLanguage.contains.concat([
        DECORATOR,
        NAMESPACE,
        INTERFACE,
      ]);

      // TS gets a simpler shebang rule than JS
      swapMode(tsLanguage, "shebang", hljs.SHEBANG());
      // JS use strict rule purposely excludes `asm` which makes no sense
      swapMode(tsLanguage, "use_strict", USE_STRICT);

      const functionDeclaration = tsLanguage.contains.find(m => m.className === "function");
      functionDeclaration.relevance = 0; // () => {} is more typical in TypeScript

      Object.assign(tsLanguage, {
        name: 'TypeScript',
        aliases: ['ts', 'tsx']
      });

      return tsLanguage;
    }

    var typescript_1 = typescript;

    var graphql$1 = {exports: {}};

    /**
     * Highlight.js GraphQL syntax highlighting definition
     *
     * @see https://github.com/isagalaev/highlight.js
     *
     * @package: highlightjs-graphql
     * @author:  David Peek <mail@dpeek.com>
     */

    function hljsDefineGraphQL(hljs) {
      return {
        aliases: ["gql"],
        keywords: {
          keyword:
            "query mutation subscription|10 input schema implements type interface union scalar fragment|10 enum on ...",
          literal: "ID ID! String Float Int Boolean",
          variable: "true false null"
        },
        contains: [
          hljs.HASH_COMMENT_MODE,
          hljs.QUOTE_STRING_MODE,
          hljs.NUMBER_MODE,
          {
            className: "literal",
            begin: "[^\\w][A-Z][a-z]",
            end: "\\W",
            excludeEnd: true
          },
          {
            className: "literal",
            begin: ":\\s\\[",
            end: "[\\]!]{1,3}",
            excludeBegin: true,
            excludeEnd: true
          },
          {
            className: "type",
            begin: "[^\\w](?!ID)[A-Z][A-Z]",
            end: "\\W",
            excludeEnd: true
          },
          {
            className: "name",
            begin: "\\$",
            end: "\\W",
            excludeEnd: true
          },
          {
            className: "meta",
            begin: "@",
            end: "\\W",
            excludeEnd: true
          }
        ],
        illegal: /([;<']|BEGIN)/
      };
    }

    graphql$1.exports = function(hljs) {
      hljs.registerLanguage("graphql", hljsDefineGraphQL);
    };

    graphql$1.exports.definer = hljsDefineGraphQL;

    var graphql = graphql$1.exports;

    // @ts-ignore
    core.registerLanguage('sql', sql_1);
    core.registerLanguage('csharp', csharp_1);
    core.registerLanguage('java', java_1);
    core.registerLanguage('kotlin', kotlin_1);
    core.registerLanguage('typescript', typescript_1);
    core.registerLanguage('scala', scala_1);
    graphql(core);

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    const directives = new WeakMap();
    /**
     * Brands a function as a directive factory function so that lit-html will call
     * the function during template rendering, rather than passing as a value.
     *
     * A _directive_ is a function that takes a Part as an argument. It has the
     * signature: `(part: Part) => void`.
     *
     * A directive _factory_ is a function that takes arguments for data and
     * configuration and returns a directive. Users of directive usually refer to
     * the directive factory as the directive. For example, "The repeat directive".
     *
     * Usually a template author will invoke a directive factory in their template
     * with relevant arguments, which will then return a directive function.
     *
     * Here's an example of using the `repeat()` directive factory that takes an
     * array and a function to render an item:
     *
     * ```js
     * html`<ul><${repeat(items, (item) => html`<li>${item}</li>`)}</ul>`
     * ```
     *
     * When `repeat` is invoked, it returns a directive function that closes over
     * `items` and the template function. When the outer template is rendered, the
     * return directive function is called with the Part for the expression.
     * `repeat` then performs it's custom logic to render multiple items.
     *
     * @param f The directive factory function. Must be a function that returns a
     * function of the signature `(part: Part) => void`. The returned function will
     * be called with the part object.
     *
     * @example
     *
     * import {directive, html} from 'lit-html';
     *
     * const immutable = directive((v) => (part) => {
     *   if (part.value !== v) {
     *     part.setValue(v)
     *   }
     * });
     */
    const directive = (f) => ((...args) => {
        const d = f(...args);
        directives.set(d, true);
        return d;
    });
    const isDirective = (o) => {
        return typeof o === 'function' && directives.has(o);
    };

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    /**
     * True if the custom elements polyfill is in use.
     */
    const isCEPolyfill = typeof window !== 'undefined' &&
        window.customElements != null &&
        window.customElements.polyfillWrapFlushCallback !==
            undefined;
    /**
     * Reparents nodes, starting from `start` (inclusive) to `end` (exclusive),
     * into another container (could be the same container), before `before`. If
     * `before` is null, it appends the nodes to the container.
     */
    const reparentNodes = (container, start, end = null, before = null) => {
        while (start !== end) {
            const n = start.nextSibling;
            container.insertBefore(start, before);
            start = n;
        }
    };
    /**
     * Removes nodes, starting from `start` (inclusive) to `end` (exclusive), from
     * `container`.
     */
    const removeNodes = (container, start, end = null) => {
        while (start !== end) {
            const n = start.nextSibling;
            container.removeChild(start);
            start = n;
        }
    };

    /**
     * @license
     * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    /**
     * A sentinel value that signals that a value was handled by a directive and
     * should not be written to the DOM.
     */
    const noChange = {};
    /**
     * A sentinel value that signals a NodePart to fully clear its content.
     */
    const nothing = {};

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    /**
     * An expression marker with embedded unique key to avoid collision with
     * possible text in templates.
     */
    const marker = `{{lit-${String(Math.random()).slice(2)}}}`;
    /**
     * An expression marker used text-positions, multi-binding attributes, and
     * attributes with markup-like text values.
     */
    const nodeMarker = `<!--${marker}-->`;
    const markerRegex = new RegExp(`${marker}|${nodeMarker}`);
    /**
     * Suffix appended to all bound attribute names.
     */
    const boundAttributeSuffix = '$lit$';
    /**
     * An updatable Template that tracks the location of dynamic parts.
     */
    class Template {
        constructor(result, element) {
            this.parts = [];
            this.element = element;
            const nodesToRemove = [];
            const stack = [];
            // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null
            const walker = document.createTreeWalker(element.content, 133 /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */, null, false);
            // Keeps track of the last index associated with a part. We try to delete
            // unnecessary nodes, but we never want to associate two different parts
            // to the same index. They must have a constant node between.
            let lastPartIndex = 0;
            let index = -1;
            let partIndex = 0;
            const { strings, values: { length } } = result;
            while (partIndex < length) {
                const node = walker.nextNode();
                if (node === null) {
                    // We've exhausted the content inside a nested template element.
                    // Because we still have parts (the outer for-loop), we know:
                    // - There is a template in the stack
                    // - The walker will find a nextNode outside the template
                    walker.currentNode = stack.pop();
                    continue;
                }
                index++;
                if (node.nodeType === 1 /* Node.ELEMENT_NODE */) {
                    if (node.hasAttributes()) {
                        const attributes = node.attributes;
                        const { length } = attributes;
                        // Per
                        // https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap,
                        // attributes are not guaranteed to be returned in document order.
                        // In particular, Edge/IE can return them out of order, so we cannot
                        // assume a correspondence between part index and attribute index.
                        let count = 0;
                        for (let i = 0; i < length; i++) {
                            if (endsWith(attributes[i].name, boundAttributeSuffix)) {
                                count++;
                            }
                        }
                        while (count-- > 0) {
                            // Get the template literal section leading up to the first
                            // expression in this attribute
                            const stringForPart = strings[partIndex];
                            // Find the attribute name
                            const name = lastAttributeNameRegex.exec(stringForPart)[2];
                            // Find the corresponding attribute
                            // All bound attributes have had a suffix added in
                            // TemplateResult#getHTML to opt out of special attribute
                            // handling. To look up the attribute value we also need to add
                            // the suffix.
                            const attributeLookupName = name.toLowerCase() + boundAttributeSuffix;
                            const attributeValue = node.getAttribute(attributeLookupName);
                            node.removeAttribute(attributeLookupName);
                            const statics = attributeValue.split(markerRegex);
                            this.parts.push({ type: 'attribute', index, name, strings: statics });
                            partIndex += statics.length - 1;
                        }
                    }
                    if (node.tagName === 'TEMPLATE') {
                        stack.push(node);
                        walker.currentNode = node.content;
                    }
                }
                else if (node.nodeType === 3 /* Node.TEXT_NODE */) {
                    const data = node.data;
                    if (data.indexOf(marker) >= 0) {
                        const parent = node.parentNode;
                        const strings = data.split(markerRegex);
                        const lastIndex = strings.length - 1;
                        // Generate a new text node for each literal section
                        // These nodes are also used as the markers for node parts
                        for (let i = 0; i < lastIndex; i++) {
                            let insert;
                            let s = strings[i];
                            if (s === '') {
                                insert = createMarker();
                            }
                            else {
                                const match = lastAttributeNameRegex.exec(s);
                                if (match !== null && endsWith(match[2], boundAttributeSuffix)) {
                                    s = s.slice(0, match.index) + match[1] +
                                        match[2].slice(0, -boundAttributeSuffix.length) + match[3];
                                }
                                insert = document.createTextNode(s);
                            }
                            parent.insertBefore(insert, node);
                            this.parts.push({ type: 'node', index: ++index });
                        }
                        // If there's no text, we must insert a comment to mark our place.
                        // Else, we can trust it will stick around after cloning.
                        if (strings[lastIndex] === '') {
                            parent.insertBefore(createMarker(), node);
                            nodesToRemove.push(node);
                        }
                        else {
                            node.data = strings[lastIndex];
                        }
                        // We have a part for each match found
                        partIndex += lastIndex;
                    }
                }
                else if (node.nodeType === 8 /* Node.COMMENT_NODE */) {
                    if (node.data === marker) {
                        const parent = node.parentNode;
                        // Add a new marker node to be the startNode of the Part if any of
                        // the following are true:
                        //  * We don't have a previousSibling
                        //  * The previousSibling is already the start of a previous part
                        if (node.previousSibling === null || index === lastPartIndex) {
                            index++;
                            parent.insertBefore(createMarker(), node);
                        }
                        lastPartIndex = index;
                        this.parts.push({ type: 'node', index });
                        // If we don't have a nextSibling, keep this node so we have an end.
                        // Else, we can remove it to save future costs.
                        if (node.nextSibling === null) {
                            node.data = '';
                        }
                        else {
                            nodesToRemove.push(node);
                            index--;
                        }
                        partIndex++;
                    }
                    else {
                        let i = -1;
                        while ((i = node.data.indexOf(marker, i + 1)) !== -1) {
                            // Comment node has a binding marker inside, make an inactive part
                            // The binding won't work, but subsequent bindings will
                            // TODO (justinfagnani): consider whether it's even worth it to
                            // make bindings in comments work
                            this.parts.push({ type: 'node', index: -1 });
                            partIndex++;
                        }
                    }
                }
            }
            // Remove text binding nodes after the walk to not disturb the TreeWalker
            for (const n of nodesToRemove) {
                n.parentNode.removeChild(n);
            }
        }
    }
    const endsWith = (str, suffix) => {
        const index = str.length - suffix.length;
        return index >= 0 && str.slice(index) === suffix;
    };
    const isTemplatePartActive = (part) => part.index !== -1;
    // Allows `document.createComment('')` to be renamed for a
    // small manual size-savings.
    const createMarker = () => document.createComment('');
    /**
     * This regex extracts the attribute name preceding an attribute-position
     * expression. It does this by matching the syntax allowed for attributes
     * against the string literal directly preceding the expression, assuming that
     * the expression is in an attribute-value position.
     *
     * See attributes in the HTML spec:
     * https://www.w3.org/TR/html5/syntax.html#elements-attributes
     *
     * " \x09\x0a\x0c\x0d" are HTML space characters:
     * https://www.w3.org/TR/html5/infrastructure.html#space-characters
     *
     * "\0-\x1F\x7F-\x9F" are Unicode control characters, which includes every
     * space character except " ".
     *
     * So an attribute is:
     *  * The name: any character except a control character, space character, ('),
     *    ("), ">", "=", or "/"
     *  * Followed by zero or more space characters
     *  * Followed by "="
     *  * Followed by zero or more space characters
     *  * Followed by:
     *    * Any character except space, ('), ("), "<", ">", "=", (`), or
     *    * (") then any non-("), or
     *    * (') then any non-(')
     */
    const lastAttributeNameRegex = 
    // eslint-disable-next-line no-control-regex
    /([ \x09\x0a\x0c\x0d])([^\0-\x1F\x7F-\x9F "'>=/]+)([ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*))$/;

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    /**
     * An instance of a `Template` that can be attached to the DOM and updated
     * with new values.
     */
    class TemplateInstance {
        constructor(template, processor, options) {
            this.__parts = [];
            this.template = template;
            this.processor = processor;
            this.options = options;
        }
        update(values) {
            let i = 0;
            for (const part of this.__parts) {
                if (part !== undefined) {
                    part.setValue(values[i]);
                }
                i++;
            }
            for (const part of this.__parts) {
                if (part !== undefined) {
                    part.commit();
                }
            }
        }
        _clone() {
            // There are a number of steps in the lifecycle of a template instance's
            // DOM fragment:
            //  1. Clone - create the instance fragment
            //  2. Adopt - adopt into the main document
            //  3. Process - find part markers and create parts
            //  4. Upgrade - upgrade custom elements
            //  5. Update - set node, attribute, property, etc., values
            //  6. Connect - connect to the document. Optional and outside of this
            //     method.
            //
            // We have a few constraints on the ordering of these steps:
            //  * We need to upgrade before updating, so that property values will pass
            //    through any property setters.
            //  * We would like to process before upgrading so that we're sure that the
            //    cloned fragment is inert and not disturbed by self-modifying DOM.
            //  * We want custom elements to upgrade even in disconnected fragments.
            //
            // Given these constraints, with full custom elements support we would
            // prefer the order: Clone, Process, Adopt, Upgrade, Update, Connect
            //
            // But Safari does not implement CustomElementRegistry#upgrade, so we
            // can not implement that order and still have upgrade-before-update and
            // upgrade disconnected fragments. So we instead sacrifice the
            // process-before-upgrade constraint, since in Custom Elements v1 elements
            // must not modify their light DOM in the constructor. We still have issues
            // when co-existing with CEv0 elements like Polymer 1, and with polyfills
            // that don't strictly adhere to the no-modification rule because shadow
            // DOM, which may be created in the constructor, is emulated by being placed
            // in the light DOM.
            //
            // The resulting order is on native is: Clone, Adopt, Upgrade, Process,
            // Update, Connect. document.importNode() performs Clone, Adopt, and Upgrade
            // in one step.
            //
            // The Custom Elements v1 polyfill supports upgrade(), so the order when
            // polyfilled is the more ideal: Clone, Process, Adopt, Upgrade, Update,
            // Connect.
            const fragment = isCEPolyfill ?
                this.template.element.content.cloneNode(true) :
                document.importNode(this.template.element.content, true);
            const stack = [];
            const parts = this.template.parts;
            // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null
            const walker = document.createTreeWalker(fragment, 133 /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */, null, false);
            let partIndex = 0;
            let nodeIndex = 0;
            let part;
            let node = walker.nextNode();
            // Loop through all the nodes and parts of a template
            while (partIndex < parts.length) {
                part = parts[partIndex];
                if (!isTemplatePartActive(part)) {
                    this.__parts.push(undefined);
                    partIndex++;
                    continue;
                }
                // Progress the tree walker until we find our next part's node.
                // Note that multiple parts may share the same node (attribute parts
                // on a single element), so this loop may not run at all.
                while (nodeIndex < part.index) {
                    nodeIndex++;
                    if (node.nodeName === 'TEMPLATE') {
                        stack.push(node);
                        walker.currentNode = node.content;
                    }
                    if ((node = walker.nextNode()) === null) {
                        // We've exhausted the content inside a nested template element.
                        // Because we still have parts (the outer for-loop), we know:
                        // - There is a template in the stack
                        // - The walker will find a nextNode outside the template
                        walker.currentNode = stack.pop();
                        node = walker.nextNode();
                    }
                }
                // We've arrived at our part's node.
                if (part.type === 'node') {
                    const part = this.processor.handleTextExpression(this.options);
                    part.insertAfterNode(node.previousSibling);
                    this.__parts.push(part);
                }
                else {
                    this.__parts.push(...this.processor.handleAttributeExpressions(node, part.name, part.strings, this.options));
                }
                partIndex++;
            }
            if (isCEPolyfill) {
                document.adoptNode(fragment);
                customElements.upgrade(fragment);
            }
            return fragment;
        }
    }

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    /**
     * Our TrustedTypePolicy for HTML which is declared using the html template
     * tag function.
     *
     * That HTML is a developer-authored constant, and is parsed with innerHTML
     * before any untrusted expressions have been mixed in. Therefor it is
     * considered safe by construction.
     */
    const policy = window.trustedTypes &&
        trustedTypes.createPolicy('lit-html', { createHTML: (s) => s });
    const commentMarker = ` ${marker} `;
    /**
     * The return type of `html`, which holds a Template and the values from
     * interpolated expressions.
     */
    class TemplateResult {
        constructor(strings, values, type, processor) {
            this.strings = strings;
            this.values = values;
            this.type = type;
            this.processor = processor;
        }
        /**
         * Returns a string of HTML used to create a `<template>` element.
         */
        getHTML() {
            const l = this.strings.length - 1;
            let html = '';
            let isCommentBinding = false;
            for (let i = 0; i < l; i++) {
                const s = this.strings[i];
                // For each binding we want to determine the kind of marker to insert
                // into the template source before it's parsed by the browser's HTML
                // parser. The marker type is based on whether the expression is in an
                // attribute, text, or comment position.
                //   * For node-position bindings we insert a comment with the marker
                //     sentinel as its text content, like <!--{{lit-guid}}-->.
                //   * For attribute bindings we insert just the marker sentinel for the
                //     first binding, so that we support unquoted attribute bindings.
                //     Subsequent bindings can use a comment marker because multi-binding
                //     attributes must be quoted.
                //   * For comment bindings we insert just the marker sentinel so we don't
                //     close the comment.
                //
                // The following code scans the template source, but is *not* an HTML
                // parser. We don't need to track the tree structure of the HTML, only
                // whether a binding is inside a comment, and if not, if it appears to be
                // the first binding in an attribute.
                const commentOpen = s.lastIndexOf('<!--');
                // We're in comment position if we have a comment open with no following
                // comment close. Because <-- can appear in an attribute value there can
                // be false positives.
                isCommentBinding = (commentOpen > -1 || isCommentBinding) &&
                    s.indexOf('-->', commentOpen + 1) === -1;
                // Check to see if we have an attribute-like sequence preceding the
                // expression. This can match "name=value" like structures in text,
                // comments, and attribute values, so there can be false-positives.
                const attributeMatch = lastAttributeNameRegex.exec(s);
                if (attributeMatch === null) {
                    // We're only in this branch if we don't have a attribute-like
                    // preceding sequence. For comments, this guards against unusual
                    // attribute values like <div foo="<!--${'bar'}">. Cases like
                    // <!-- foo=${'bar'}--> are handled correctly in the attribute branch
                    // below.
                    html += s + (isCommentBinding ? commentMarker : nodeMarker);
                }
                else {
                    // For attributes we use just a marker sentinel, and also append a
                    // $lit$ suffix to the name to opt-out of attribute-specific parsing
                    // that IE and Edge do for style and certain SVG attributes.
                    html += s.substr(0, attributeMatch.index) + attributeMatch[1] +
                        attributeMatch[2] + boundAttributeSuffix + attributeMatch[3] +
                        marker;
                }
            }
            html += this.strings[l];
            return html;
        }
        getTemplateElement() {
            const template = document.createElement('template');
            let value = this.getHTML();
            if (policy !== undefined) {
                // this is secure because `this.strings` is a TemplateStringsArray.
                // TODO: validate this when
                // https://github.com/tc39/proposal-array-is-template-object is
                // implemented.
                value = policy.createHTML(value);
            }
            template.innerHTML = value;
            return template;
        }
    }
    /**
     * A TemplateResult for SVG fragments.
     *
     * This class wraps HTML in an `<svg>` tag in order to parse its contents in the
     * SVG namespace, then modifies the template to remove the `<svg>` tag so that
     * clones only container the original fragment.
     */
    class SVGTemplateResult extends TemplateResult {
        getHTML() {
            return `<svg>${super.getHTML()}</svg>`;
        }
        getTemplateElement() {
            const template = super.getTemplateElement();
            const content = template.content;
            const svgElement = content.firstChild;
            content.removeChild(svgElement);
            reparentNodes(content, svgElement.firstChild);
            return template;
        }
    }

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    const isPrimitive = (value) => {
        return (value === null ||
            !(typeof value === 'object' || typeof value === 'function'));
    };
    const isIterable$1 = (value) => {
        return Array.isArray(value) ||
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            !!(value && value[Symbol.iterator]);
    };
    /**
     * Writes attribute values to the DOM for a group of AttributeParts bound to a
     * single attribute. The value is only set once even if there are multiple parts
     * for an attribute.
     */
    class AttributeCommitter {
        constructor(element, name, strings) {
            this.dirty = true;
            this.element = element;
            this.name = name;
            this.strings = strings;
            this.parts = [];
            for (let i = 0; i < strings.length - 1; i++) {
                this.parts[i] = this._createPart();
            }
        }
        /**
         * Creates a single part. Override this to create a differnt type of part.
         */
        _createPart() {
            return new AttributePart(this);
        }
        _getValue() {
            const strings = this.strings;
            const l = strings.length - 1;
            const parts = this.parts;
            // If we're assigning an attribute via syntax like:
            //    attr="${foo}"  or  attr=${foo}
            // but not
            //    attr="${foo} ${bar}" or attr="${foo} baz"
            // then we don't want to coerce the attribute value into one long
            // string. Instead we want to just return the value itself directly,
            // so that sanitizeDOMValue can get the actual value rather than
            // String(value)
            // The exception is if v is an array, in which case we do want to smash
            // it together into a string without calling String() on the array.
            //
            // This also allows trusted values (when using TrustedTypes) being
            // assigned to DOM sinks without being stringified in the process.
            if (l === 1 && strings[0] === '' && strings[1] === '') {
                const v = parts[0].value;
                if (typeof v === 'symbol') {
                    return String(v);
                }
                if (typeof v === 'string' || !isIterable$1(v)) {
                    return v;
                }
            }
            let text = '';
            for (let i = 0; i < l; i++) {
                text += strings[i];
                const part = parts[i];
                if (part !== undefined) {
                    const v = part.value;
                    if (isPrimitive(v) || !isIterable$1(v)) {
                        text += typeof v === 'string' ? v : String(v);
                    }
                    else {
                        for (const t of v) {
                            text += typeof t === 'string' ? t : String(t);
                        }
                    }
                }
            }
            text += strings[l];
            return text;
        }
        commit() {
            if (this.dirty) {
                this.dirty = false;
                this.element.setAttribute(this.name, this._getValue());
            }
        }
    }
    /**
     * A Part that controls all or part of an attribute value.
     */
    class AttributePart {
        constructor(committer) {
            this.value = undefined;
            this.committer = committer;
        }
        setValue(value) {
            if (value !== noChange && (!isPrimitive(value) || value !== this.value)) {
                this.value = value;
                // If the value is a not a directive, dirty the committer so that it'll
                // call setAttribute. If the value is a directive, it'll dirty the
                // committer if it calls setValue().
                if (!isDirective(value)) {
                    this.committer.dirty = true;
                }
            }
        }
        commit() {
            while (isDirective(this.value)) {
                const directive = this.value;
                this.value = noChange;
                directive(this);
            }
            if (this.value === noChange) {
                return;
            }
            this.committer.commit();
        }
    }
    /**
     * A Part that controls a location within a Node tree. Like a Range, NodePart
     * has start and end locations and can set and update the Nodes between those
     * locations.
     *
     * NodeParts support several value types: primitives, Nodes, TemplateResults,
     * as well as arrays and iterables of those types.
     */
    class NodePart {
        constructor(options) {
            this.value = undefined;
            this.__pendingValue = undefined;
            this.options = options;
        }
        /**
         * Appends this part into a container.
         *
         * This part must be empty, as its contents are not automatically moved.
         */
        appendInto(container) {
            this.startNode = container.appendChild(createMarker());
            this.endNode = container.appendChild(createMarker());
        }
        /**
         * Inserts this part after the `ref` node (between `ref` and `ref`'s next
         * sibling). Both `ref` and its next sibling must be static, unchanging nodes
         * such as those that appear in a literal section of a template.
         *
         * This part must be empty, as its contents are not automatically moved.
         */
        insertAfterNode(ref) {
            this.startNode = ref;
            this.endNode = ref.nextSibling;
        }
        /**
         * Appends this part into a parent part.
         *
         * This part must be empty, as its contents are not automatically moved.
         */
        appendIntoPart(part) {
            part.__insert(this.startNode = createMarker());
            part.__insert(this.endNode = createMarker());
        }
        /**
         * Inserts this part after the `ref` part.
         *
         * This part must be empty, as its contents are not automatically moved.
         */
        insertAfterPart(ref) {
            ref.__insert(this.startNode = createMarker());
            this.endNode = ref.endNode;
            ref.endNode = this.startNode;
        }
        setValue(value) {
            this.__pendingValue = value;
        }
        commit() {
            if (this.startNode.parentNode === null) {
                return;
            }
            while (isDirective(this.__pendingValue)) {
                const directive = this.__pendingValue;
                this.__pendingValue = noChange;
                directive(this);
            }
            const value = this.__pendingValue;
            if (value === noChange) {
                return;
            }
            if (isPrimitive(value)) {
                if (value !== this.value) {
                    this.__commitText(value);
                }
            }
            else if (value instanceof TemplateResult) {
                this.__commitTemplateResult(value);
            }
            else if (value instanceof Node) {
                this.__commitNode(value);
            }
            else if (isIterable$1(value)) {
                this.__commitIterable(value);
            }
            else if (value === nothing) {
                this.value = nothing;
                this.clear();
            }
            else {
                // Fallback, will render the string representation
                this.__commitText(value);
            }
        }
        __insert(node) {
            this.endNode.parentNode.insertBefore(node, this.endNode);
        }
        __commitNode(value) {
            if (this.value === value) {
                return;
            }
            this.clear();
            this.__insert(value);
            this.value = value;
        }
        __commitText(value) {
            const node = this.startNode.nextSibling;
            value = value == null ? '' : value;
            // If `value` isn't already a string, we explicitly convert it here in case
            // it can't be implicitly converted - i.e. it's a symbol.
            const valueAsString = typeof value === 'string' ? value : String(value);
            if (node === this.endNode.previousSibling &&
                node.nodeType === 3 /* Node.TEXT_NODE */) {
                // If we only have a single text node between the markers, we can just
                // set its value, rather than replacing it.
                // TODO(justinfagnani): Can we just check if this.value is primitive?
                node.data = valueAsString;
            }
            else {
                this.__commitNode(document.createTextNode(valueAsString));
            }
            this.value = value;
        }
        __commitTemplateResult(value) {
            const template = this.options.templateFactory(value);
            if (this.value instanceof TemplateInstance &&
                this.value.template === template) {
                this.value.update(value.values);
            }
            else {
                // Make sure we propagate the template processor from the TemplateResult
                // so that we use its syntax extension, etc. The template factory comes
                // from the render function options so that it can control template
                // caching and preprocessing.
                const instance = new TemplateInstance(template, value.processor, this.options);
                const fragment = instance._clone();
                instance.update(value.values);
                this.__commitNode(fragment);
                this.value = instance;
            }
        }
        __commitIterable(value) {
            // For an Iterable, we create a new InstancePart per item, then set its
            // value to the item. This is a little bit of overhead for every item in
            // an Iterable, but it lets us recurse easily and efficiently update Arrays
            // of TemplateResults that will be commonly returned from expressions like:
            // array.map((i) => html`${i}`), by reusing existing TemplateInstances.
            // If _value is an array, then the previous render was of an
            // iterable and _value will contain the NodeParts from the previous
            // render. If _value is not an array, clear this part and make a new
            // array for NodeParts.
            if (!Array.isArray(this.value)) {
                this.value = [];
                this.clear();
            }
            // Lets us keep track of how many items we stamped so we can clear leftover
            // items from a previous render
            const itemParts = this.value;
            let partIndex = 0;
            let itemPart;
            for (const item of value) {
                // Try to reuse an existing part
                itemPart = itemParts[partIndex];
                // If no existing part, create a new one
                if (itemPart === undefined) {
                    itemPart = new NodePart(this.options);
                    itemParts.push(itemPart);
                    if (partIndex === 0) {
                        itemPart.appendIntoPart(this);
                    }
                    else {
                        itemPart.insertAfterPart(itemParts[partIndex - 1]);
                    }
                }
                itemPart.setValue(item);
                itemPart.commit();
                partIndex++;
            }
            if (partIndex < itemParts.length) {
                // Truncate the parts array so _value reflects the current state
                itemParts.length = partIndex;
                this.clear(itemPart && itemPart.endNode);
            }
        }
        clear(startNode = this.startNode) {
            removeNodes(this.startNode.parentNode, startNode.nextSibling, this.endNode);
        }
    }
    /**
     * Implements a boolean attribute, roughly as defined in the HTML
     * specification.
     *
     * If the value is truthy, then the attribute is present with a value of
     * ''. If the value is falsey, the attribute is removed.
     */
    class BooleanAttributePart {
        constructor(element, name, strings) {
            this.value = undefined;
            this.__pendingValue = undefined;
            if (strings.length !== 2 || strings[0] !== '' || strings[1] !== '') {
                throw new Error('Boolean attributes can only contain a single expression');
            }
            this.element = element;
            this.name = name;
            this.strings = strings;
        }
        setValue(value) {
            this.__pendingValue = value;
        }
        commit() {
            while (isDirective(this.__pendingValue)) {
                const directive = this.__pendingValue;
                this.__pendingValue = noChange;
                directive(this);
            }
            if (this.__pendingValue === noChange) {
                return;
            }
            const value = !!this.__pendingValue;
            if (this.value !== value) {
                if (value) {
                    this.element.setAttribute(this.name, '');
                }
                else {
                    this.element.removeAttribute(this.name);
                }
                this.value = value;
            }
            this.__pendingValue = noChange;
        }
    }
    /**
     * Sets attribute values for PropertyParts, so that the value is only set once
     * even if there are multiple parts for a property.
     *
     * If an expression controls the whole property value, then the value is simply
     * assigned to the property under control. If there are string literals or
     * multiple expressions, then the strings are expressions are interpolated into
     * a string first.
     */
    class PropertyCommitter extends AttributeCommitter {
        constructor(element, name, strings) {
            super(element, name, strings);
            this.single =
                (strings.length === 2 && strings[0] === '' && strings[1] === '');
        }
        _createPart() {
            return new PropertyPart(this);
        }
        _getValue() {
            if (this.single) {
                return this.parts[0].value;
            }
            return super._getValue();
        }
        commit() {
            if (this.dirty) {
                this.dirty = false;
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                this.element[this.name] = this._getValue();
            }
        }
    }
    class PropertyPart extends AttributePart {
    }
    // Detect event listener options support. If the `capture` property is read
    // from the options object, then options are supported. If not, then the third
    // argument to add/removeEventListener is interpreted as the boolean capture
    // value so we should only pass the `capture` property.
    let eventOptionsSupported = false;
    // Wrap into an IIFE because MS Edge <= v41 does not support having try/catch
    // blocks right into the body of a module
    (() => {
        try {
            const options = {
                get capture() {
                    eventOptionsSupported = true;
                    return false;
                }
            };
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            window.addEventListener('test', options, options);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            window.removeEventListener('test', options, options);
        }
        catch (_e) {
            // event options not supported
        }
    })();
    class EventPart {
        constructor(element, eventName, eventContext) {
            this.value = undefined;
            this.__pendingValue = undefined;
            this.element = element;
            this.eventName = eventName;
            this.eventContext = eventContext;
            this.__boundHandleEvent = (e) => this.handleEvent(e);
        }
        setValue(value) {
            this.__pendingValue = value;
        }
        commit() {
            while (isDirective(this.__pendingValue)) {
                const directive = this.__pendingValue;
                this.__pendingValue = noChange;
                directive(this);
            }
            if (this.__pendingValue === noChange) {
                return;
            }
            const newListener = this.__pendingValue;
            const oldListener = this.value;
            const shouldRemoveListener = newListener == null ||
                oldListener != null &&
                    (newListener.capture !== oldListener.capture ||
                        newListener.once !== oldListener.once ||
                        newListener.passive !== oldListener.passive);
            const shouldAddListener = newListener != null && (oldListener == null || shouldRemoveListener);
            if (shouldRemoveListener) {
                this.element.removeEventListener(this.eventName, this.__boundHandleEvent, this.__options);
            }
            if (shouldAddListener) {
                this.__options = getOptions(newListener);
                this.element.addEventListener(this.eventName, this.__boundHandleEvent, this.__options);
            }
            this.value = newListener;
            this.__pendingValue = noChange;
        }
        handleEvent(event) {
            if (typeof this.value === 'function') {
                this.value.call(this.eventContext || this.element, event);
            }
            else {
                this.value.handleEvent(event);
            }
        }
    }
    // We copy options because of the inconsistent behavior of browsers when reading
    // the third argument of add/removeEventListener. IE11 doesn't support options
    // at all. Chrome 41 only reads `capture` if the argument is an object.
    const getOptions = (o) => o &&
        (eventOptionsSupported ?
            { capture: o.capture, passive: o.passive, once: o.once } :
            o.capture);

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    /**
     * Creates Parts when a template is instantiated.
     */
    class DefaultTemplateProcessor {
        /**
         * Create parts for an attribute-position binding, given the event, attribute
         * name, and string literals.
         *
         * @param element The element containing the binding
         * @param name  The attribute name
         * @param strings The string literals. There are always at least two strings,
         *   event for fully-controlled bindings with a single expression.
         */
        handleAttributeExpressions(element, name, strings, options) {
            const prefix = name[0];
            if (prefix === '.') {
                const committer = new PropertyCommitter(element, name.slice(1), strings);
                return committer.parts;
            }
            if (prefix === '@') {
                return [new EventPart(element, name.slice(1), options.eventContext)];
            }
            if (prefix === '?') {
                return [new BooleanAttributePart(element, name.slice(1), strings)];
            }
            const committer = new AttributeCommitter(element, name, strings);
            return committer.parts;
        }
        /**
         * Create parts for a text-position binding.
         * @param templateFactory
         */
        handleTextExpression(options) {
            return new NodePart(options);
        }
    }
    const defaultTemplateProcessor = new DefaultTemplateProcessor();

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    /**
     * The default TemplateFactory which caches Templates keyed on
     * result.type and result.strings.
     */
    function templateFactory(result) {
        let templateCache = templateCaches$1.get(result.type);
        if (templateCache === undefined) {
            templateCache = {
                stringsArray: new WeakMap(),
                keyString: new Map()
            };
            templateCaches$1.set(result.type, templateCache);
        }
        let template = templateCache.stringsArray.get(result.strings);
        if (template !== undefined) {
            return template;
        }
        // If the TemplateStringsArray is new, generate a key from the strings
        // This key is shared between all templates with identical content
        const key = result.strings.join(marker);
        // Check if we already have a Template for this key
        template = templateCache.keyString.get(key);
        if (template === undefined) {
            // If we have not seen this key before, create a new Template
            template = new Template(result, result.getTemplateElement());
            // Cache the Template for this key
            templateCache.keyString.set(key, template);
        }
        // Cache all future queries for this TemplateStringsArray
        templateCache.stringsArray.set(result.strings, template);
        return template;
    }
    const templateCaches$1 = new Map();

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    const parts = new WeakMap();
    /**
     * Renders a template result or other value to a container.
     *
     * To update a container with new values, reevaluate the template literal and
     * call `render` with the new result.
     *
     * @param result Any value renderable by NodePart - typically a TemplateResult
     *     created by evaluating a template tag like `html` or `svg`.
     * @param container A DOM parent to render to. The entire contents are either
     *     replaced, or efficiently updated if the same result type was previous
     *     rendered there.
     * @param options RenderOptions for the entire render tree rendered to this
     *     container. Render options must *not* change between renders to the same
     *     container, as those changes will not effect previously rendered DOM.
     */
    const render$1 = (result, container, options) => {
        let part = parts.get(container);
        if (part === undefined) {
            removeNodes(container, container.firstChild);
            parts.set(container, part = new NodePart(Object.assign({ templateFactory }, options)));
            part.appendInto(container);
        }
        part.setValue(result);
        part.commit();
    };

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    // IMPORTANT: do not change the property name or the assignment expression.
    // This line will be used in regexes to search for lit-html usage.
    // TODO(justinfagnani): inject version number at build time
    if (typeof window !== 'undefined') {
        (window['litHtmlVersions'] || (window['litHtmlVersions'] = [])).push('1.4.1');
    }
    /**
     * Interprets a template literal as an HTML template that can efficiently
     * render to and update a container.
     */
    const html = (strings, ...values) => new TemplateResult(strings, values, 'html', defaultTemplateProcessor);
    /**
     * Interprets a template literal as an SVG template that can efficiently
     * render to and update a container.
     */
    const svg = (strings, ...values) => new SVGTemplateResult(strings, values, 'svg', defaultTemplateProcessor);

    /*!
     * @kderd/lit-observable
     * @version 0.2.1 | Wed Nov 17 2021
     * @author azer<linguoren@kingdee. com>
     * @license MIT
     */

    const isObject$3 = (obj) => !!obj && typeof obj === 'object';
    const isArray$2$1 = (obj) => Array.isArray(obj);
    const isUndefined$1 = (value) => value === undefined;
    const closestElement = (selector, el, target = el && el.closest(selector)) => !el || el === document || el === window
        ? null
        : target
            ? target
            : closestElement(selector, el.getRootNode().host);
    const queryShadowSelector = (selectors, el) => selectors.length
        ? selectors.reduce((element, selector) => {
            var _a;
            const target = element === null || element === void 0 ? void 0 : element.querySelector(selector);
            return target ? target : (_a = element === null || element === void 0 ? void 0 : element.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector(selector);
        }, el)
        : null;

    function getContext(selector, el) {
        const provider = closestElement(selector, el);
        return provider.value;
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    /** Detect free variable `global` from Node.js. */

    var freeGlobal$1$1 = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

    var _freeGlobal$1 = freeGlobal$1$1;

    var freeGlobal$2 = _freeGlobal$1;

    /** Detect free variable `self`. */
    var freeSelf$1 = typeof self == 'object' && self && self.Object === Object && self;

    /** Used as a reference to the global object. */
    var root$1$1 = freeGlobal$2 || freeSelf$1 || Function('return this')();

    var _root$1 = root$1$1;

    var root$3 = _root$1;

    /** Built-in value references. */
    var Symbol$4$1 = root$3.Symbol;

    var _Symbol$1 = Symbol$4$1;

    /**
     * A specialized version of `_.map` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */

    function arrayMap$1$1(array, iteratee) {
      var index = -1,
          length = array == null ? 0 : array.length,
          result = Array(length);

      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }

    var _arrayMap$1 = arrayMap$1$1;

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */

    var isArray$1$1 = Array.isArray;

    var isArray_1$1 = isArray$1$1;

    var Symbol$3$1 = _Symbol$1;

    /** Used for built-in method references. */
    var objectProto$1$1 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$1 = objectProto$1$1.hasOwnProperty;

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString$1$1 = objectProto$1$1.toString;

    /** Built-in value references. */
    var symToStringTag$1$1 = Symbol$3$1 ? Symbol$3$1.toStringTag : undefined;

    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */
    function getRawTag$1$1(value) {
      var isOwn = hasOwnProperty$1.call(value, symToStringTag$1$1),
          tag = value[symToStringTag$1$1];

      try {
        value[symToStringTag$1$1] = undefined;
        var unmasked = true;
      } catch (e) {}

      var result = nativeObjectToString$1$1.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag$1$1] = tag;
        } else {
          delete value[symToStringTag$1$1];
        }
      }
      return result;
    }

    var _getRawTag$1 = getRawTag$1$1;

    /** Used for built-in method references. */

    var objectProto$2 = Object.prototype;

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString$2 = objectProto$2.toString;

    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */
    function objectToString$1$1(value) {
      return nativeObjectToString$2.call(value);
    }

    var _objectToString$1 = objectToString$1$1;

    var Symbol$2$1 = _Symbol$1,
        getRawTag$2 = _getRawTag$1,
        objectToString$2 = _objectToString$1;

    /** `Object#toString` result references. */
    var nullTag$1 = '[object Null]',
        undefinedTag$1 = '[object Undefined]';

    /** Built-in value references. */
    var symToStringTag$2 = Symbol$2$1 ? Symbol$2$1.toStringTag : undefined;

    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    function baseGetTag$1$1(value) {
      if (value == null) {
        return value === undefined ? undefinedTag$1 : nullTag$1;
      }
      return (symToStringTag$2 && symToStringTag$2 in Object(value))
        ? getRawTag$2(value)
        : objectToString$2(value);
    }

    var _baseGetTag$1 = baseGetTag$1$1;

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */

    function isObjectLike$1$1(value) {
      return value != null && typeof value == 'object';
    }

    var isObjectLike_1$1 = isObjectLike$1$1;

    var baseGetTag$2 = _baseGetTag$1,
        isObjectLike$2 = isObjectLike_1$1;

    /** `Object#toString` result references. */
    var symbolTag$1 = '[object Symbol]';

    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol$1$1(value) {
      return typeof value == 'symbol' ||
        (isObjectLike$2(value) && baseGetTag$2(value) == symbolTag$1);
    }

    var isSymbol_1$1 = isSymbol$1$1;

    var Symbol$1$1 = _Symbol$1,
        arrayMap$2 = _arrayMap$1,
        isArray$4 = isArray_1$1,
        isSymbol$3 = isSymbol_1$1;

    /** Used as references for various `Number` constants. */
    var INFINITY$2 = 1 / 0;

    /** Used to convert symbols to primitives and strings. */
    var symbolProto$1 = Symbol$1$1 ? Symbol$1$1.prototype : undefined,
        symbolToString$1 = symbolProto$1 ? symbolProto$1.toString : undefined;

    /**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */
    function baseToString$1$1(value) {
      // Exit early for strings to avoid a performance hit in some environments.
      if (typeof value == 'string') {
        return value;
      }
      if (isArray$4(value)) {
        // Recursively convert values (susceptible to call stack limits).
        return arrayMap$2(value, baseToString$1$1) + '';
      }
      if (isSymbol$3(value)) {
        return symbolToString$1 ? symbolToString$1.call(value) : '';
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY$2) ? '-0' : result;
    }

    var _baseToString$1 = baseToString$1$1;

    var baseToString$2 = _baseToString$1;

    /**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */
    function toString$4$1(value) {
      return value == null ? '' : baseToString$2(value);
    }

    var toString_1$1 = toString$4$1;

    /**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */

    function baseSlice$1$1(array, start, end) {
      var index = -1,
          length = array.length;

      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : ((end - start) >>> 0);
      start >>>= 0;

      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }

    var _baseSlice$1 = baseSlice$1$1;

    var baseSlice$2 = _baseSlice$1;

    /**
     * Casts `array` to a slice if it's needed.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {number} start The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the cast slice.
     */
    function castSlice$1$1(array, start, end) {
      var length = array.length;
      end = end === undefined ? length : end;
      return (!start && end >= length) ? array : baseSlice$2(array, start, end);
    }

    var _castSlice$1 = castSlice$1$1;

    /** Used to compose unicode character classes. */

    var rsAstralRange$2$1 = '\\ud800-\\udfff',
        rsComboMarksRange$3$1 = '\\u0300-\\u036f',
        reComboHalfMarksRange$3$1 = '\\ufe20-\\ufe2f',
        rsComboSymbolsRange$3$1 = '\\u20d0-\\u20ff',
        rsComboRange$3$1 = rsComboMarksRange$3$1 + reComboHalfMarksRange$3$1 + rsComboSymbolsRange$3$1,
        rsVarRange$2$1 = '\\ufe0e\\ufe0f';

    /** Used to compose unicode capture groups. */
    var rsZWJ$2$1 = '\\u200d';

    /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
    var reHasUnicode$1 = RegExp('[' + rsZWJ$2$1 + rsAstralRange$2$1  + rsComboRange$3$1 + rsVarRange$2$1 + ']');

    /**
     * Checks if `string` contains Unicode symbols.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {boolean} Returns `true` if a symbol is found, else `false`.
     */
    function hasUnicode$2$1(string) {
      return reHasUnicode$1.test(string);
    }

    var _hasUnicode$1 = hasUnicode$2$1;

    /**
     * Converts an ASCII `string` to an array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the converted array.
     */

    function asciiToArray$1$1(string) {
      return string.split('');
    }

    var _asciiToArray$1 = asciiToArray$1$1;

    /** Used to compose unicode character classes. */

    var rsAstralRange$1$1 = '\\ud800-\\udfff',
        rsComboMarksRange$2$1 = '\\u0300-\\u036f',
        reComboHalfMarksRange$2$1 = '\\ufe20-\\ufe2f',
        rsComboSymbolsRange$2$1 = '\\u20d0-\\u20ff',
        rsComboRange$2$1 = rsComboMarksRange$2$1 + reComboHalfMarksRange$2$1 + rsComboSymbolsRange$2$1,
        rsVarRange$1$1 = '\\ufe0e\\ufe0f';

    /** Used to compose unicode capture groups. */
    var rsAstral$1 = '[' + rsAstralRange$1$1 + ']',
        rsCombo$2$1 = '[' + rsComboRange$2$1 + ']',
        rsFitz$1$1 = '\\ud83c[\\udffb-\\udfff]',
        rsModifier$1$1 = '(?:' + rsCombo$2$1 + '|' + rsFitz$1$1 + ')',
        rsNonAstral$1$1 = '[^' + rsAstralRange$1$1 + ']',
        rsRegional$1$1 = '(?:\\ud83c[\\udde6-\\uddff]){2}',
        rsSurrPair$1$1 = '[\\ud800-\\udbff][\\udc00-\\udfff]',
        rsZWJ$1$1 = '\\u200d';

    /** Used to compose unicode regexes. */
    var reOptMod$1$1 = rsModifier$1$1 + '?',
        rsOptVar$1$1 = '[' + rsVarRange$1$1 + ']?',
        rsOptJoin$1$1 = '(?:' + rsZWJ$1$1 + '(?:' + [rsNonAstral$1$1, rsRegional$1$1, rsSurrPair$1$1].join('|') + ')' + rsOptVar$1$1 + reOptMod$1$1 + ')*',
        rsSeq$1$1 = rsOptVar$1$1 + reOptMod$1$1 + rsOptJoin$1$1,
        rsSymbol$1 = '(?:' + [rsNonAstral$1$1 + rsCombo$2$1 + '?', rsCombo$2$1, rsRegional$1$1, rsSurrPair$1$1, rsAstral$1].join('|') + ')';

    /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
    var reUnicode$1 = RegExp(rsFitz$1$1 + '(?=' + rsFitz$1$1 + ')|' + rsSymbol$1 + rsSeq$1$1, 'g');

    /**
     * Converts a Unicode `string` to an array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the converted array.
     */
    function unicodeToArray$1$1(string) {
      return string.match(reUnicode$1) || [];
    }

    var _unicodeToArray$1 = unicodeToArray$1$1;

    var asciiToArray$2 = _asciiToArray$1,
        hasUnicode$1$1 = _hasUnicode$1,
        unicodeToArray$2 = _unicodeToArray$1;

    /**
     * Converts `string` to an array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the converted array.
     */
    function stringToArray$1$1(string) {
      return hasUnicode$1$1(string)
        ? unicodeToArray$2(string)
        : asciiToArray$2(string);
    }

    var _stringToArray$1 = stringToArray$1$1;

    var castSlice$2 = _castSlice$1,
        hasUnicode$3 = _hasUnicode$1,
        stringToArray$2 = _stringToArray$1,
        toString$3$1 = toString_1$1;

    /**
     * Creates a function like `_.lowerFirst`.
     *
     * @private
     * @param {string} methodName The name of the `String` case method to use.
     * @returns {Function} Returns the new case function.
     */
    function createCaseFirst$1$1(methodName) {
      return function(string) {
        string = toString$3$1(string);

        var strSymbols = hasUnicode$3(string)
          ? stringToArray$2(string)
          : undefined;

        var chr = strSymbols
          ? strSymbols[0]
          : string.charAt(0);

        var trailing = strSymbols
          ? castSlice$2(strSymbols, 1).join('')
          : string.slice(1);

        return chr[methodName]() + trailing;
      };
    }

    var _createCaseFirst$1 = createCaseFirst$1$1;

    var createCaseFirst$2 = _createCaseFirst$1;

    /**
     * Converts the first character of `string` to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.upperFirst('fred');
     * // => 'Fred'
     *
     * _.upperFirst('FRED');
     * // => 'FRED'
     */
    var upperFirst$1$1 = createCaseFirst$2('toUpperCase');

    var upperFirst_1$1 = upperFirst$1$1;

    var toString$2$1 = toString_1$1,
        upperFirst$2 = upperFirst_1$1;

    /**
     * Converts the first character of `string` to upper case and the remaining
     * to lower case.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('FRED');
     * // => 'Fred'
     */
    function capitalize$1$1(string) {
      return upperFirst$2(toString$2$1(string).toLowerCase());
    }

    var capitalize_1$1 = capitalize$1$1;

    /**
     * A specialized version of `_.reduce` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initAccum] Specify using the first element of `array` as
     *  the initial value.
     * @returns {*} Returns the accumulated value.
     */

    function arrayReduce$1$1(array, iteratee, accumulator, initAccum) {
      var index = -1,
          length = array == null ? 0 : array.length;

      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }

    var _arrayReduce$2 = arrayReduce$1$1;

    /**
     * The base implementation of `_.propertyOf` without support for deep paths.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     */

    function basePropertyOf$1$1(object) {
      return function(key) {
        return object == null ? undefined : object[key];
      };
    }

    var _basePropertyOf$1 = basePropertyOf$1$1;

    var basePropertyOf$2 = _basePropertyOf$1;

    /** Used to map Latin Unicode letters to basic Latin letters. */
    var deburredLetters$1 = {
      // Latin-1 Supplement block.
      '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
      '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
      '\xc7': 'C',  '\xe7': 'c',
      '\xd0': 'D',  '\xf0': 'd',
      '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
      '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
      '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
      '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
      '\xd1': 'N',  '\xf1': 'n',
      '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
      '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
      '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
      '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
      '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
      '\xc6': 'Ae', '\xe6': 'ae',
      '\xde': 'Th', '\xfe': 'th',
      '\xdf': 'ss',
      // Latin Extended-A block.
      '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
      '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
      '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
      '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
      '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
      '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
      '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
      '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
      '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
      '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
      '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
      '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
      '\u0134': 'J',  '\u0135': 'j',
      '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
      '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
      '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
      '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
      '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
      '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
      '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
      '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
      '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
      '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
      '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
      '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
      '\u0163': 't',  '\u0165': 't', '\u0167': 't',
      '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
      '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
      '\u0174': 'W',  '\u0175': 'w',
      '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
      '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
      '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
      '\u0132': 'IJ', '\u0133': 'ij',
      '\u0152': 'Oe', '\u0153': 'oe',
      '\u0149': "'n", '\u017f': 's'
    };

    /**
     * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
     * letters to basic Latin letters.
     *
     * @private
     * @param {string} letter The matched letter to deburr.
     * @returns {string} Returns the deburred letter.
     */
    var deburrLetter$1$1 = basePropertyOf$2(deburredLetters$1);

    var _deburrLetter$1 = deburrLetter$1$1;

    var deburrLetter$2 = _deburrLetter$1,
        toString$1$1 = toString_1$1;

    /** Used to match Latin Unicode letters (excluding mathematical operators). */
    var reLatin$1 = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

    /** Used to compose unicode character classes. */
    var rsComboMarksRange$1$1 = '\\u0300-\\u036f',
        reComboHalfMarksRange$1$1 = '\\ufe20-\\ufe2f',
        rsComboSymbolsRange$1$1 = '\\u20d0-\\u20ff',
        rsComboRange$1$1 = rsComboMarksRange$1$1 + reComboHalfMarksRange$1$1 + rsComboSymbolsRange$1$1;

    /** Used to compose unicode capture groups. */
    var rsCombo$1$1 = '[' + rsComboRange$1$1 + ']';

    /**
     * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
     * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
     */
    var reComboMark$1 = RegExp(rsCombo$1$1, 'g');

    /**
     * Deburrs `string` by converting
     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
     * letters to basic Latin letters and removing
     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('dj vu');
     * // => 'deja vu'
     */
    function deburr$1$1(string) {
      string = toString$1$1(string);
      return string && string.replace(reLatin$1, deburrLetter$2).replace(reComboMark$1, '');
    }

    var deburr_1$1 = deburr$1$1;

    /** Used to match words composed of alphanumeric characters. */

    var reAsciiWord$1 = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

    /**
     * Splits an ASCII `string` into an array of its words.
     *
     * @private
     * @param {string} The string to inspect.
     * @returns {Array} Returns the words of `string`.
     */
    function asciiWords$1$1(string) {
      return string.match(reAsciiWord$1) || [];
    }

    var _asciiWords$1 = asciiWords$1$1;

    /** Used to detect strings that need a more robust regexp to match words. */

    var reHasUnicodeWord$1 = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

    /**
     * Checks if `string` contains a word composed of Unicode symbols.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {boolean} Returns `true` if a word is found, else `false`.
     */
    function hasUnicodeWord$1$1(string) {
      return reHasUnicodeWord$1.test(string);
    }

    var _hasUnicodeWord$1 = hasUnicodeWord$1$1;

    /** Used to compose unicode character classes. */

    var rsAstralRange$3 = '\\ud800-\\udfff',
        rsComboMarksRange$4 = '\\u0300-\\u036f',
        reComboHalfMarksRange$4 = '\\ufe20-\\ufe2f',
        rsComboSymbolsRange$4 = '\\u20d0-\\u20ff',
        rsComboRange$4 = rsComboMarksRange$4 + reComboHalfMarksRange$4 + rsComboSymbolsRange$4,
        rsDingbatRange$1 = '\\u2700-\\u27bf',
        rsLowerRange$1 = 'a-z\\xdf-\\xf6\\xf8-\\xff',
        rsMathOpRange$1 = '\\xac\\xb1\\xd7\\xf7',
        rsNonCharRange$1 = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
        rsPunctuationRange$1 = '\\u2000-\\u206f',
        rsSpaceRange$1 = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
        rsUpperRange$1 = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
        rsVarRange$3 = '\\ufe0e\\ufe0f',
        rsBreakRange$1 = rsMathOpRange$1 + rsNonCharRange$1 + rsPunctuationRange$1 + rsSpaceRange$1;

    /** Used to compose unicode capture groups. */
    var rsApos$1$1 = "['\u2019]",
        rsBreak$1 = '[' + rsBreakRange$1 + ']',
        rsCombo$3 = '[' + rsComboRange$4 + ']',
        rsDigits$1 = '\\d+',
        rsDingbat$1 = '[' + rsDingbatRange$1 + ']',
        rsLower$1 = '[' + rsLowerRange$1 + ']',
        rsMisc$1 = '[^' + rsAstralRange$3 + rsBreakRange$1 + rsDigits$1 + rsDingbatRange$1 + rsLowerRange$1 + rsUpperRange$1 + ']',
        rsFitz$2 = '\\ud83c[\\udffb-\\udfff]',
        rsModifier$2 = '(?:' + rsCombo$3 + '|' + rsFitz$2 + ')',
        rsNonAstral$2 = '[^' + rsAstralRange$3 + ']',
        rsRegional$2 = '(?:\\ud83c[\\udde6-\\uddff]){2}',
        rsSurrPair$2 = '[\\ud800-\\udbff][\\udc00-\\udfff]',
        rsUpper$1 = '[' + rsUpperRange$1 + ']',
        rsZWJ$3 = '\\u200d';

    /** Used to compose unicode regexes. */
    var rsMiscLower$1 = '(?:' + rsLower$1 + '|' + rsMisc$1 + ')',
        rsMiscUpper$1 = '(?:' + rsUpper$1 + '|' + rsMisc$1 + ')',
        rsOptContrLower$1 = '(?:' + rsApos$1$1 + '(?:d|ll|m|re|s|t|ve))?',
        rsOptContrUpper$1 = '(?:' + rsApos$1$1 + '(?:D|LL|M|RE|S|T|VE))?',
        reOptMod$2 = rsModifier$2 + '?',
        rsOptVar$2 = '[' + rsVarRange$3 + ']?',
        rsOptJoin$2 = '(?:' + rsZWJ$3 + '(?:' + [rsNonAstral$2, rsRegional$2, rsSurrPair$2].join('|') + ')' + rsOptVar$2 + reOptMod$2 + ')*',
        rsOrdLower$1 = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
        rsOrdUpper$1 = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
        rsSeq$2 = rsOptVar$2 + reOptMod$2 + rsOptJoin$2,
        rsEmoji$1 = '(?:' + [rsDingbat$1, rsRegional$2, rsSurrPair$2].join('|') + ')' + rsSeq$2;

    /** Used to match complex or compound words. */
    var reUnicodeWord$1 = RegExp([
      rsUpper$1 + '?' + rsLower$1 + '+' + rsOptContrLower$1 + '(?=' + [rsBreak$1, rsUpper$1, '$'].join('|') + ')',
      rsMiscUpper$1 + '+' + rsOptContrUpper$1 + '(?=' + [rsBreak$1, rsUpper$1 + rsMiscLower$1, '$'].join('|') + ')',
      rsUpper$1 + '?' + rsMiscLower$1 + '+' + rsOptContrLower$1,
      rsUpper$1 + '+' + rsOptContrUpper$1,
      rsOrdUpper$1,
      rsOrdLower$1,
      rsDigits$1,
      rsEmoji$1
    ].join('|'), 'g');

    /**
     * Splits a Unicode `string` into an array of its words.
     *
     * @private
     * @param {string} The string to inspect.
     * @returns {Array} Returns the words of `string`.
     */
    function unicodeWords$1$1(string) {
      return string.match(reUnicodeWord$1) || [];
    }

    var _unicodeWords$1 = unicodeWords$1$1;

    var asciiWords$2 = _asciiWords$1,
        hasUnicodeWord$2 = _hasUnicodeWord$1,
        toString$7 = toString_1$1,
        unicodeWords$2 = _unicodeWords$1;

    /**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */
    function words$1$1(string, pattern, guard) {
      string = toString$7(string);
      pattern = guard ? undefined : pattern;

      if (pattern === undefined) {
        return hasUnicodeWord$2(string) ? unicodeWords$2(string) : asciiWords$2(string);
      }
      return string.match(pattern) || [];
    }

    var words_1$1 = words$1$1;

    var arrayReduce$2 = _arrayReduce$2,
        deburr$2 = deburr_1$1,
        words$2 = words_1$1;

    /** Used to compose unicode capture groups. */
    var rsApos$2 = "['\u2019]";

    /** Used to match apostrophes. */
    var reApos$1 = RegExp(rsApos$2, 'g');

    /**
     * Creates a function like `_.camelCase`.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */
    function createCompounder$2$1(callback) {
      return function(string) {
        return arrayReduce$2(words$2(deburr$2(string).replace(reApos$1, '')), callback, '');
      };
    }

    var _createCompounder$1 = createCompounder$2$1;

    var capitalize$2 = capitalize_1$1,
        createCompounder$1$1 = _createCompounder$1;

    /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar--');
     * // => 'fooBar'
     *
     * _.camelCase('__FOO_BAR__');
     * // => 'fooBar'
     */
    var camelCase$1 = createCompounder$1$1(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? capitalize$2(word) : word);
    });

    var camelCase_1$1 = camelCase$1;

    var createCompounder$3 = _createCompounder$1;

    /**
     * Converts `string` to
     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__FOO_BAR__');
     * // => 'foo-bar'
     */
    var kebabCase$1 = createCompounder$3(function(result, word, index) {
      return result + (index ? '-' : '') + word.toLowerCase();
    });

    var kebabCase_1$1 = kebabCase$1;

    const rawToProxy = new WeakMap();
    const rawToObservers = new WeakMap();
    const proxyToRaw = new WeakMap();
    const proxyToSubject = new WeakMap();
    const observerToTriggers = new WeakMap();
    const queue = [];
    const nextQueue = [];
    let currentObserver = null;
    let batch = false;
    let nextBatch = false;
    function observer(f) {
        currentObserver = f;
        f();
        currentObserver = null;
        return () => unobserve(f);
    }
    function unobserve(observer) {
        const triggers = observerToTriggers.get(observer);
        triggers === null || triggers === void 0 ? void 0 : triggers.forEach(({ raw }) => {
            const observers = rawToObservers.get(raw);
            observers &&
                observers.includes(observer) &&
                observers.splice(observers.indexOf(observer), 1);
        });
        triggers && observerToTriggers.delete(observer);
    }
    function addObserver(raw) {
        if (!currentObserver)
            return;
        const observers = rawToObservers.get(raw);
        if (!observers) {
            rawToObservers.set(raw, [currentObserver]);
        }
        else if (!observers.includes(currentObserver)) {
            observers.push(currentObserver);
        }
    }
    function addTrigger(raw, p) {
        if (!currentObserver)
            return;
        const triggers = observerToTriggers.get(currentObserver);
        if (triggers) {
            const trigger = triggers.find(trigger => trigger.raw === raw);
            if (!trigger) {
                triggers.push({ raw, keys: [p] });
            }
            else if (!trigger.keys.includes(p)) {
                trigger.keys.push(p);
            }
        }
        else {
            observerToTriggers.set(currentObserver, [{ raw, keys: [p] }]);
        }
    }
    function isTrigger(raw, p, observer) {
        const triggers = observerToTriggers.get(observer);
        return triggers
            ? triggers.some(trigger => trigger.raw === raw && trigger.keys.includes(p))
            : false;
    }
    const effect$3 = (raw, p) => {
        var _a;
        return (_a = rawToObservers.get(raw)) === null || _a === void 0 ? void 0 : _a.forEach(observer => {
            if (!isTrigger(raw, p, observer))
                return;
            queue.includes(observer) || queue.push(observer);
            if (!batch) {
                queueMicrotask(execute);
                batch = true;
            }
        });
    };
    function execute() {
        while (queue.length) {
            const target = queue.shift();
            unobserve(target);
            observer(target);
        }
        batch = false;
    }
    function observable$1(raw) {
        const proxy = new Proxy(raw, {
            get(target, p, receiver) {
                const value = Reflect.get(target, p, receiver);
                addObserver(raw);
                addTrigger(raw, p);
                if (isObject$3(value) && !proxyToRaw.has(value)) {
                    if (rawToProxy.has(value))
                        return rawToProxy.get(value);
                    return observable$1(value);
                }
                return value;
            },
            set(target, p, value, receiver) {
                const oldValue = Reflect.get(target, p, receiver);
                const res = Reflect.set(target, p, value, receiver);
                if (!isArray$2$1(target) && oldValue !== value) {
                    effect$3(target, p);
                    nextEffect(target, p);
                }
                else if (p === 'length') {
                    effect$3(target, p);
                    nextEffect(target, p);
                }
                return res;
            },
        });
        rawToProxy.set(raw, proxy);
        proxyToRaw.set(proxy, raw);
        return proxy;
    }
    function nextEffect(raw, p) {
        const proxy = rawToProxy.get(raw);
        if (!proxy)
            return;
        const subject = proxyToSubject.get(proxy);
        if (!subject)
            return;
        const trigger = nextQueue.find(trigger => trigger.proxy === proxy);
        if (!trigger) {
            nextQueue.push({ proxy, keys: [p] });
        }
        else if (!trigger.keys.includes(p)) {
            trigger.keys.push(p);
        }
        if (!nextBatch) {
            queueMicrotask(nextExecute);
            nextBatch = true;
        }
    }
    function nextExecute() {
        while (nextQueue.length) {
            const trigger = nextQueue.shift();
            const subject = proxyToSubject.get(trigger.proxy);
            trigger.keys.forEach(key => subject === null || subject === void 0 ? void 0 : subject.next(key));
        }
        nextBatch = false;
    }
    function createSubject() {
        const observers = [];
        const next = (value) => observers.forEach(observer => observer(value));
        const subscribe = (observer) => {
            observers.push(observer);
            return () => {
                observers.includes(observer) &&
                    observers.splice(observers.indexOf(observer), 1);
            };
        };
        return {
            next,
            subscribe,
        };
    }
    function watch(proxy, observer) {
        let subject = proxyToSubject.get(proxy);
        if (!subject) {
            subject = createSubject();
            proxyToSubject.set(proxy, subject);
        }
        return subject.subscribe(observer);
    }

    const supportsAdoptingStyleSheets = window.ShadowRoot &&
        'adoptedStyleSheets' in Document.prototype &&
        'replace' in CSSStyleSheet.prototype;
    const isSheet = (options) => supportsAdoptingStyleSheets && !!options.shadow && !!options.style;
    const isStyle = (options) => !isSheet(options) && !!options.style;

    const BEFORE_MOUNT = Symbol('beforeMount');
    const MOUNTED = Symbol('mounted');
    const UNMOUNTED = Symbol('unmounted');
    const BEFORE_FIRST_UPDATE = Symbol('beforeFirstUpdate');
    const FIRST_UPDATED = Symbol('firstUpdated');
    const BEFORE_UPDATE = Symbol('beforeUpdate');
    const UPDATED = Symbol('updated');
    const QUERY = Symbol('query');
    const QUERY_ALL = Symbol('queryAll');
    const UNSUBSCRIBE = Symbol('unsubscribe');
    const RENDER_ROOT = Symbol('renderRoot');
    const TEMPLATE = Symbol('template');
    const STYLE = Symbol('style');
    const PROPS = Symbol('props');
    let currentInstance = null;
    const createLifecycle = (name) => (f) => {
        var _a;
        currentInstance &&
            ((_a = currentInstance[name]) !== null && _a !== void 0 ? _a : (currentInstance[name] = [])).push(f);
    };
    const createQuery = (name) => (selector) => {
        var _a;
        const ref = { value: null };
        if (currentInstance) {
            const renderRoot = currentInstance[RENDER_ROOT];
            const f = () => (ref.value =
                name === QUERY
                    ? renderRoot.querySelector(selector)
                    : [...renderRoot.querySelectorAll(selector)]);
            ((_a = currentInstance[QUERY]) !== null && _a !== void 0 ? _a : (currentInstance[QUERY] = [])).push(f);
        }
        return ref;
    };
    const beforeMount = createLifecycle(BEFORE_MOUNT);
    const mounted = createLifecycle(MOUNTED);
    const unmounted = createLifecycle(UNMOUNTED);
    const beforeFirstUpdate = createLifecycle(BEFORE_FIRST_UPDATE);
    const firstUpdated = createLifecycle(FIRST_UPDATED);
    const beforeUpdate = createLifecycle(BEFORE_UPDATE);
    const updated = createLifecycle(UPDATED);
    const query = createQuery(QUERY);
    const queryAll = createQuery(QUERY_ALL);
    function defineComponent(name, options) {
        var _a, _b;
        var _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
        (_a = options.shadow) !== null && _a !== void 0 ? _a : (options.shadow = 'open');
        const observedProps = (_b = options.observedProps) !== null && _b !== void 0 ? _b : [];
        const observedPropNames = observedProps.map(prop => isObject$3(prop) ? prop.name : prop);
        const observedPropsOptions = observedProps.filter(prop => isObject$3(prop));
        const sheet = isSheet(options) ? new CSSStyleSheet() : null;
        sheet && sheet.replaceSync(options.style || '');
        const C = (_q = class extends HTMLElement {
                constructor() {
                    super();
                    this[_c] = null;
                    this[_d] = null;
                    this[_e] = null;
                    this[_f] = null;
                    this[_g] = null;
                    this[_h] = null;
                    this[_j] = null;
                    this[_k] = null;
                    this[_l] = [];
                    this[_m] = this;
                    this[_o] = null;
                    this[_p] = observable$1({});
                    observedPropsOptions.forEach(propOptions => isUndefined$1(propOptions.default) ||
                        Reflect.set(this[PROPS], camelCase_1$1(propOptions.name), propOptions.default));
                    options.shadow &&
                        (this[RENDER_ROOT] = this.attachShadow({ mode: options.shadow }));
                    if (isStyle(options)) {
                        const style = document.createElement('style');
                        style.textContent = options.style || '';
                        this[STYLE] = style;
                    }
                    sheet && (this[RENDER_ROOT].adoptedStyleSheets = [sheet]);
                    currentInstance = this;
                    this[TEMPLATE] = options.render.call(this, this[PROPS], this);
                    currentInstance = null;
                }
                static get observedAttributes() {
                    return Array.from(new Set([
                        ...observedPropNames,
                        ...observedPropNames.map(propName => kebabCase_1$1(propName)),
                    ]));
                }
                connectedCallback() {
                    var _a, _b;
                    options.styleMap && Object.assign(this.style, options.styleMap);
                    (_a = this[BEFORE_MOUNT]) === null || _a === void 0 ? void 0 : _a.forEach(f => f());
                    let isMounted = false;
                    this[UNSUBSCRIBE].push(observer(() => {
                        var _a, _b, _q, _r, _s;
                        isMounted
                            ? (_a = this[BEFORE_UPDATE]) === null || _a === void 0 ? void 0 : _a.forEach(f => f())
                            : (_b = this[BEFORE_FIRST_UPDATE]) === null || _b === void 0 ? void 0 : _b.forEach(f => f());
                        render$1(html `${this[STYLE]}${this[TEMPLATE]()}`, this[RENDER_ROOT]);
                        (_q = this[QUERY]) === null || _q === void 0 ? void 0 : _q.forEach(f => f());
                        if (isMounted) {
                            (_r = this[UPDATED]) === null || _r === void 0 ? void 0 : _r.forEach(f => f());
                        }
                        else {
                            (_s = this[FIRST_UPDATED]) === null || _s === void 0 ? void 0 : _s.forEach(f => f());
                            isMounted = true;
                        }
                    }));
                    (_b = this[MOUNTED]) === null || _b === void 0 ? void 0 : _b.forEach(f => f());
                }
                disconnectedCallback() {
                    var _a;
                    this[UNSUBSCRIBE].forEach(f => f());
                    this[UNSUBSCRIBE] = [];
                    (_a = this[UNMOUNTED]) === null || _a === void 0 ? void 0 : _a.forEach(f => f());
                }
                attributeChangedCallback(propName, oldValue, newValue) {
                    const propOptions = observedProps.find(prop => isObject$3(prop) &&
                        camelCase_1$1(prop.name) === camelCase_1$1(propName));
                    propOptions && propOptions.type
                        ? Reflect.set(this[PROPS], camelCase_1$1(propName), propOptions.type === Boolean
                            ? newValue === 'true' || newValue === ''
                            : propOptions.type(newValue))
                        : Reflect.set(this[PROPS], camelCase_1$1(propName), newValue);
                }
            },
            _c = BEFORE_MOUNT,
            _d = MOUNTED,
            _e = UNMOUNTED,
            _f = BEFORE_FIRST_UPDATE,
            _g = FIRST_UPDATED,
            _h = BEFORE_UPDATE,
            _j = UPDATED,
            _k = QUERY,
            _l = UNSUBSCRIBE,
            _m = RENDER_ROOT,
            _o = STYLE,
            _p = PROPS,
            _q);
        observedPropNames.forEach(propName => {
            Object.defineProperty(C.prototype, propName, {
                get() {
                    return Reflect.get(this[PROPS], propName);
                },
                set(value) {
                    Reflect.set(this[PROPS], propName, value);
                },
            });
        });
        customElements.define(name, C);
    }

    const RATIO_WIDTH = 16;
    const RATIO_HEIGHT = 9;
    const DEFAULT_WIDTH = 1200;
    const DEFAULT_HEIGHT = (DEFAULT_WIDTH / RATIO_WIDTH) * RATIO_HEIGHT;
    const SIZE_FONT_TABLE_HEAD = 14;
    const SIZE_FONT = 13;
    const SIZE_MIN_WIDTH = 60;
    const SIZE_MAX_ROW = 10;
    const SIZE_BORDER_BOTTOM = 1.5;
    const SIZE_COLUMN_OPTION_AI = 15;
    const SIZE_COLUMN_OPTION_UQ = 22;
    const SIZE_COLUMN_OPTION_NN = 34;
    const SIZE_COLUMN_CLOSE = 9;
    const SIZE_COLUMN_KEY = 12;
    const SIZE_COLUMN_MARGIN_RIGHT = 5;
    const SIZE_INPUT_EDIT_HEIGHT = 19;
    const SIZE_COLUMN_HEIGHT = SIZE_INPUT_EDIT_HEIGHT + SIZE_BORDER_BOTTOM;
    const SIZE_TABLE_BORDER = 1;
    const SIZE_TABLE_PADDING = 10;
    const SIZE_TABLE_HEADER_HEIGHT = 47;
    const SIZE_TABLE_HEADER_BODY_HEIGHT = 30;
    const SIZE_START_X = 200;
    const SIZE_START_Y = 100;
    const SIZE_START_ADD = 50;
    const SIZE_MEMO_WIDTH = 127;
    const SIZE_MEMO_HEIGHT = 100;
    const SIZE_MEMO_PADDING = 10;
    const SIZE_SASH = 5;
    const SIZE_CONTEXTMENU_HEIGHT = 40;
    const SIZE_MINIMAP_WIDTH = 150;
    const SIZE_MINIMAP_MARGIN = 15;
    const SIZE_MENUBAR_HEIGHT = 36;
    const SIZE_CANVAS_MIN = 2000;
    const SIZE_CANVAS_MAX = 20000;
    const SIZE_CANVAS_ZOOM_MAX = 1;
    const SIZE_CANVAS_ZOOM_MIN = 0.1;
    const SIZE_MAX_WIDTH_COMMENT = 180;

    /**
     * A specialized version of `_.reduce` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initAccum] Specify using the first element of `array` as
     *  the initial value.
     * @returns {*} Returns the accumulated value.
     */

    function arrayReduce$1(array, iteratee, accumulator, initAccum) {
      var index = -1,
          length = array == null ? 0 : array.length;

      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }

    var _arrayReduce$1 = arrayReduce$1;

    /**
     * The base implementation of `_.propertyOf` without support for deep paths.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     */

    function basePropertyOf$1(object) {
      return function(key) {
        return object == null ? undefined : object[key];
      };
    }

    var _basePropertyOf = basePropertyOf$1;

    var basePropertyOf = _basePropertyOf;

    /** Used to map Latin Unicode letters to basic Latin letters. */
    var deburredLetters = {
      // Latin-1 Supplement block.
      '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
      '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
      '\xc7': 'C',  '\xe7': 'c',
      '\xd0': 'D',  '\xf0': 'd',
      '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
      '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
      '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
      '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
      '\xd1': 'N',  '\xf1': 'n',
      '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
      '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
      '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
      '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
      '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
      '\xc6': 'Ae', '\xe6': 'ae',
      '\xde': 'Th', '\xfe': 'th',
      '\xdf': 'ss',
      // Latin Extended-A block.
      '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
      '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
      '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
      '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
      '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
      '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
      '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
      '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
      '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
      '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
      '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
      '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
      '\u0134': 'J',  '\u0135': 'j',
      '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
      '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
      '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
      '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
      '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
      '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
      '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
      '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
      '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
      '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
      '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
      '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
      '\u0163': 't',  '\u0165': 't', '\u0167': 't',
      '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
      '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
      '\u0174': 'W',  '\u0175': 'w',
      '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
      '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
      '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
      '\u0132': 'IJ', '\u0133': 'ij',
      '\u0152': 'Oe', '\u0153': 'oe',
      '\u0149': "'n", '\u017f': 's'
    };

    /**
     * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
     * letters to basic Latin letters.
     *
     * @private
     * @param {string} letter The matched letter to deburr.
     * @returns {string} Returns the deburred letter.
     */
    var deburrLetter$1 = basePropertyOf(deburredLetters);

    var _deburrLetter = deburrLetter$1;

    /** Detect free variable `global` from Node.js. */

    var freeGlobal$1 = typeof commonjsGlobal$1 == 'object' && commonjsGlobal$1 && commonjsGlobal$1.Object === Object && commonjsGlobal$1;

    var _freeGlobal = freeGlobal$1;

    var freeGlobal = _freeGlobal;

    /** Detect free variable `self`. */
    var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

    /** Used as a reference to the global object. */
    var root$2 = freeGlobal || freeSelf || Function('return this')();

    var _root = root$2;

    var root$1 = _root;

    /** Built-in value references. */
    var Symbol$4 = root$1.Symbol;

    var _Symbol = Symbol$4;

    /**
     * A specialized version of `_.map` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */

    function arrayMap$1(array, iteratee) {
      var index = -1,
          length = array == null ? 0 : array.length,
          result = Array(length);

      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }

    var _arrayMap = arrayMap$1;

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */

    var isArray$3 = Array.isArray;

    var isArray_1 = isArray$3;

    var Symbol$3 = _Symbol;

    /** Used for built-in method references. */
    var objectProto$1 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto$1.hasOwnProperty;

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString$1 = objectProto$1.toString;

    /** Built-in value references. */
    var symToStringTag$1 = Symbol$3 ? Symbol$3.toStringTag : undefined;

    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */
    function getRawTag$1(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag$1),
          tag = value[symToStringTag$1];

      try {
        value[symToStringTag$1] = undefined;
        var unmasked = true;
      } catch (e) {}

      var result = nativeObjectToString$1.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag$1] = tag;
        } else {
          delete value[symToStringTag$1];
        }
      }
      return result;
    }

    var _getRawTag = getRawTag$1;

    /** Used for built-in method references. */

    var objectProto = Object.prototype;

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString = objectProto.toString;

    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */
    function objectToString$1(value) {
      return nativeObjectToString.call(value);
    }

    var _objectToString = objectToString$1;

    var Symbol$2 = _Symbol,
        getRawTag = _getRawTag,
        objectToString = _objectToString;

    /** `Object#toString` result references. */
    var nullTag = '[object Null]',
        undefinedTag = '[object Undefined]';

    /** Built-in value references. */
    var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : undefined;

    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    function baseGetTag$1(value) {
      if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
      }
      return (symToStringTag && symToStringTag in Object(value))
        ? getRawTag(value)
        : objectToString(value);
    }

    var _baseGetTag = baseGetTag$1;

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */

    function isObjectLike$1(value) {
      return value != null && typeof value == 'object';
    }

    var isObjectLike_1 = isObjectLike$1;

    var baseGetTag = _baseGetTag,
        isObjectLike = isObjectLike_1;

    /** `Object#toString` result references. */
    var symbolTag = '[object Symbol]';

    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol$2(value) {
      return typeof value == 'symbol' ||
        (isObjectLike(value) && baseGetTag(value) == symbolTag);
    }

    var isSymbol_1 = isSymbol$2;

    var Symbol$1 = _Symbol,
        arrayMap = _arrayMap,
        isArray$2 = isArray_1,
        isSymbol$1 = isSymbol_1;

    /** Used as references for various `Number` constants. */
    var INFINITY$1 = 1 / 0;

    /** Used to convert symbols to primitives and strings. */
    var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined,
        symbolToString = symbolProto ? symbolProto.toString : undefined;

    /**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */
    function baseToString$1(value) {
      // Exit early for strings to avoid a performance hit in some environments.
      if (typeof value == 'string') {
        return value;
      }
      if (isArray$2(value)) {
        // Recursively convert values (susceptible to call stack limits).
        return arrayMap(value, baseToString$1) + '';
      }
      if (isSymbol$1(value)) {
        return symbolToString ? symbolToString.call(value) : '';
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY$1) ? '-0' : result;
    }

    var _baseToString = baseToString$1;

    var baseToString = _baseToString;

    /**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */
    function toString$6(value) {
      return value == null ? '' : baseToString(value);
    }

    var toString_1 = toString$6;

    var deburrLetter = _deburrLetter,
        toString$5 = toString_1;

    /** Used to match Latin Unicode letters (excluding mathematical operators). */
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

    /** Used to compose unicode character classes. */
    var rsComboMarksRange$3 = '\\u0300-\\u036f',
        reComboHalfMarksRange$3 = '\\ufe20-\\ufe2f',
        rsComboSymbolsRange$3 = '\\u20d0-\\u20ff',
        rsComboRange$3 = rsComboMarksRange$3 + reComboHalfMarksRange$3 + rsComboSymbolsRange$3;

    /** Used to compose unicode capture groups. */
    var rsCombo$2 = '[' + rsComboRange$3 + ']';

    /**
     * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
     * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
     */
    var reComboMark = RegExp(rsCombo$2, 'g');

    /**
     * Deburrs `string` by converting
     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
     * letters to basic Latin letters and removing
     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('dj vu');
     * // => 'deja vu'
     */
    function deburr$1(string) {
      string = toString$5(string);
      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
    }

    var deburr_1 = deburr$1;

    /** Used to match words composed of alphanumeric characters. */

    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

    /**
     * Splits an ASCII `string` into an array of its words.
     *
     * @private
     * @param {string} The string to inspect.
     * @returns {Array} Returns the words of `string`.
     */
    function asciiWords$1(string) {
      return string.match(reAsciiWord) || [];
    }

    var _asciiWords = asciiWords$1;

    /** Used to detect strings that need a more robust regexp to match words. */

    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

    /**
     * Checks if `string` contains a word composed of Unicode symbols.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {boolean} Returns `true` if a word is found, else `false`.
     */
    function hasUnicodeWord$1(string) {
      return reHasUnicodeWord.test(string);
    }

    var _hasUnicodeWord = hasUnicodeWord$1;

    /** Used to compose unicode character classes. */

    var rsAstralRange$2 = '\\ud800-\\udfff',
        rsComboMarksRange$2 = '\\u0300-\\u036f',
        reComboHalfMarksRange$2 = '\\ufe20-\\ufe2f',
        rsComboSymbolsRange$2 = '\\u20d0-\\u20ff',
        rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2,
        rsDingbatRange = '\\u2700-\\u27bf',
        rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
        rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
        rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
        rsPunctuationRange = '\\u2000-\\u206f',
        rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
        rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
        rsVarRange$2 = '\\ufe0e\\ufe0f',
        rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

    /** Used to compose unicode capture groups. */
    var rsApos$1 = "['\u2019]",
        rsBreak = '[' + rsBreakRange + ']',
        rsCombo$1 = '[' + rsComboRange$2 + ']',
        rsDigits = '\\d+',
        rsDingbat = '[' + rsDingbatRange + ']',
        rsLower = '[' + rsLowerRange + ']',
        rsMisc = '[^' + rsAstralRange$2 + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
        rsFitz$1 = '\\ud83c[\\udffb-\\udfff]',
        rsModifier$1 = '(?:' + rsCombo$1 + '|' + rsFitz$1 + ')',
        rsNonAstral$1 = '[^' + rsAstralRange$2 + ']',
        rsRegional$1 = '(?:\\ud83c[\\udde6-\\uddff]){2}',
        rsSurrPair$1 = '[\\ud800-\\udbff][\\udc00-\\udfff]',
        rsUpper = '[' + rsUpperRange + ']',
        rsZWJ$2 = '\\u200d';

    /** Used to compose unicode regexes. */
    var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
        rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
        rsOptContrLower = '(?:' + rsApos$1 + '(?:d|ll|m|re|s|t|ve))?',
        rsOptContrUpper = '(?:' + rsApos$1 + '(?:D|LL|M|RE|S|T|VE))?',
        reOptMod$1 = rsModifier$1 + '?',
        rsOptVar$1 = '[' + rsVarRange$2 + ']?',
        rsOptJoin$1 = '(?:' + rsZWJ$2 + '(?:' + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join('|') + ')' + rsOptVar$1 + reOptMod$1 + ')*',
        rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
        rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
        rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1,
        rsEmoji = '(?:' + [rsDingbat, rsRegional$1, rsSurrPair$1].join('|') + ')' + rsSeq$1;

    /** Used to match complex or compound words. */
    var reUnicodeWord = RegExp([
      rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
      rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
      rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
      rsUpper + '+' + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join('|'), 'g');

    /**
     * Splits a Unicode `string` into an array of its words.
     *
     * @private
     * @param {string} The string to inspect.
     * @returns {Array} Returns the words of `string`.
     */
    function unicodeWords$1(string) {
      return string.match(reUnicodeWord) || [];
    }

    var _unicodeWords = unicodeWords$1;

    var asciiWords = _asciiWords,
        hasUnicodeWord = _hasUnicodeWord,
        toString$4 = toString_1,
        unicodeWords = _unicodeWords;

    /**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */
    function words$1(string, pattern, guard) {
      string = toString$4(string);
      pattern = guard ? undefined : pattern;

      if (pattern === undefined) {
        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
      }
      return string.match(pattern) || [];
    }

    var words_1 = words$1;

    var arrayReduce = _arrayReduce$1,
        deburr = deburr_1,
        words = words_1;

    /** Used to compose unicode capture groups. */
    var rsApos = "['\u2019]";

    /** Used to match apostrophes. */
    var reApos = RegExp(rsApos, 'g');

    /**
     * Creates a function like `_.camelCase`.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */
    function createCompounder$2(callback) {
      return function(string) {
        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
      };
    }

    var _createCompounder = createCompounder$2;

    var createCompounder$1 = _createCompounder;

    /**
     * Converts `string` to
     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__FOO_BAR__');
     * // => 'foo-bar'
     */
    var kebabCase = createCompounder$1(function(result, word, index) {
      return result + (index ? '-' : '') + word.toLowerCase();
    });

    var kebabCase_1 = kebabCase;

    /**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */

    function baseSlice$1(array, start, end) {
      var index = -1,
          length = array.length;

      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : ((end - start) >>> 0);
      start >>>= 0;

      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }

    var _baseSlice = baseSlice$1;

    var baseSlice = _baseSlice;

    /**
     * Casts `array` to a slice if it's needed.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {number} start The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the cast slice.
     */
    function castSlice$1(array, start, end) {
      var length = array.length;
      end = end === undefined ? length : end;
      return (!start && end >= length) ? array : baseSlice(array, start, end);
    }

    var _castSlice = castSlice$1;

    /** Used to compose unicode character classes. */

    var rsAstralRange$1 = '\\ud800-\\udfff',
        rsComboMarksRange$1 = '\\u0300-\\u036f',
        reComboHalfMarksRange$1 = '\\ufe20-\\ufe2f',
        rsComboSymbolsRange$1 = '\\u20d0-\\u20ff',
        rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1,
        rsVarRange$1 = '\\ufe0e\\ufe0f';

    /** Used to compose unicode capture groups. */
    var rsZWJ$1 = '\\u200d';

    /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
    var reHasUnicode = RegExp('[' + rsZWJ$1 + rsAstralRange$1  + rsComboRange$1 + rsVarRange$1 + ']');

    /**
     * Checks if `string` contains Unicode symbols.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {boolean} Returns `true` if a symbol is found, else `false`.
     */
    function hasUnicode$2(string) {
      return reHasUnicode.test(string);
    }

    var _hasUnicode = hasUnicode$2;

    /**
     * Converts an ASCII `string` to an array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the converted array.
     */

    function asciiToArray$1(string) {
      return string.split('');
    }

    var _asciiToArray = asciiToArray$1;

    /** Used to compose unicode character classes. */

    var rsAstralRange = '\\ud800-\\udfff',
        rsComboMarksRange = '\\u0300-\\u036f',
        reComboHalfMarksRange = '\\ufe20-\\ufe2f',
        rsComboSymbolsRange = '\\u20d0-\\u20ff',
        rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
        rsVarRange = '\\ufe0e\\ufe0f';

    /** Used to compose unicode capture groups. */
    var rsAstral = '[' + rsAstralRange + ']',
        rsCombo = '[' + rsComboRange + ']',
        rsFitz = '\\ud83c[\\udffb-\\udfff]',
        rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
        rsNonAstral = '[^' + rsAstralRange + ']',
        rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
        rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
        rsZWJ = '\\u200d';

    /** Used to compose unicode regexes. */
    var reOptMod = rsModifier + '?',
        rsOptVar = '[' + rsVarRange + ']?',
        rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
        rsSeq = rsOptVar + reOptMod + rsOptJoin,
        rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

    /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
    var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

    /**
     * Converts a Unicode `string` to an array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the converted array.
     */
    function unicodeToArray$1(string) {
      return string.match(reUnicode) || [];
    }

    var _unicodeToArray = unicodeToArray$1;

    var asciiToArray = _asciiToArray,
        hasUnicode$1 = _hasUnicode,
        unicodeToArray = _unicodeToArray;

    /**
     * Converts `string` to an array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the converted array.
     */
    function stringToArray$1(string) {
      return hasUnicode$1(string)
        ? unicodeToArray(string)
        : asciiToArray(string);
    }

    var _stringToArray = stringToArray$1;

    var castSlice = _castSlice,
        hasUnicode = _hasUnicode,
        stringToArray = _stringToArray,
        toString$3 = toString_1;

    /**
     * Creates a function like `_.lowerFirst`.
     *
     * @private
     * @param {string} methodName The name of the `String` case method to use.
     * @returns {Function} Returns the new case function.
     */
    function createCaseFirst$1(methodName) {
      return function(string) {
        string = toString$3(string);

        var strSymbols = hasUnicode(string)
          ? stringToArray(string)
          : undefined;

        var chr = strSymbols
          ? strSymbols[0]
          : string.charAt(0);

        var trailing = strSymbols
          ? castSlice(strSymbols, 1).join('')
          : string.slice(1);

        return chr[methodName]() + trailing;
      };
    }

    var _createCaseFirst = createCaseFirst$1;

    var createCaseFirst = _createCaseFirst;

    /**
     * Converts the first character of `string` to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.upperFirst('fred');
     * // => 'Fred'
     *
     * _.upperFirst('FRED');
     * // => 'FRED'
     */
    var upperFirst$1 = createCaseFirst('toUpperCase');

    var upperFirst_1 = upperFirst$1;

    var toString$2 = toString_1,
        upperFirst = upperFirst_1;

    /**
     * Converts the first character of `string` to upper case and the remaining
     * to lower case.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('FRED');
     * // => 'Fred'
     */
    function capitalize$1(string) {
      return upperFirst(toString$2(string).toLowerCase());
    }

    var capitalize_1 = capitalize$1;

    var capitalize = capitalize_1,
        createCompounder = _createCompounder;

    /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar--');
     * // => 'fooBar'
     *
     * _.camelCase('__FOO_BAR__');
     * // => 'fooBar'
     */
    var camelCase = createCompounder(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? capitalize(word) : word);
    });

    var camelCase_1 = camelCase;

    function _isPlaceholder(a) {
      return a != null && typeof a === 'object' && a['@@functional/placeholder'] === true;
    }

    /**
     * Optimized internal one-arity curry function.
     *
     * @private
     * @category Function
     * @param {Function} fn The function to curry.
     * @return {Function} The curried function.
     */

    function _curry1(fn) {
      return function f1(a) {
        if (arguments.length === 0 || _isPlaceholder(a)) {
          return f1;
        } else {
          return fn.apply(this, arguments);
        }
      };
    }

    /**
     * Optimized internal two-arity curry function.
     *
     * @private
     * @category Function
     * @param {Function} fn The function to curry.
     * @return {Function} The curried function.
     */

    function _curry2(fn) {
      return function f2(a, b) {
        switch (arguments.length) {
          case 0:
            return f2;

          case 1:
            return _isPlaceholder(a) ? f2 : _curry1(function (_b) {
              return fn(a, _b);
            });

          default:
            return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function (_a) {
              return fn(_a, b);
            }) : _isPlaceholder(b) ? _curry1(function (_b) {
              return fn(a, _b);
            }) : fn(a, b);
        }
      };
    }

    /**
     * Private `concat` function to merge two array-like objects.
     *
     * @private
     * @param {Array|Arguments} [set1=[]] An array-like object.
     * @param {Array|Arguments} [set2=[]] An array-like object.
     * @return {Array} A new, merged array.
     * @example
     *
     *      _concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
     */
    function _concat(set1, set2) {
      set1 = set1 || [];
      set2 = set2 || [];
      var idx;
      var len1 = set1.length;
      var len2 = set2.length;
      var result = [];
      idx = 0;

      while (idx < len1) {
        result[result.length] = set1[idx];
        idx += 1;
      }

      idx = 0;

      while (idx < len2) {
        result[result.length] = set2[idx];
        idx += 1;
      }

      return result;
    }

    function _arity(n, fn) {
      /* eslint-disable no-unused-vars */
      switch (n) {
        case 0:
          return function () {
            return fn.apply(this, arguments);
          };

        case 1:
          return function (a0) {
            return fn.apply(this, arguments);
          };

        case 2:
          return function (a0, a1) {
            return fn.apply(this, arguments);
          };

        case 3:
          return function (a0, a1, a2) {
            return fn.apply(this, arguments);
          };

        case 4:
          return function (a0, a1, a2, a3) {
            return fn.apply(this, arguments);
          };

        case 5:
          return function (a0, a1, a2, a3, a4) {
            return fn.apply(this, arguments);
          };

        case 6:
          return function (a0, a1, a2, a3, a4, a5) {
            return fn.apply(this, arguments);
          };

        case 7:
          return function (a0, a1, a2, a3, a4, a5, a6) {
            return fn.apply(this, arguments);
          };

        case 8:
          return function (a0, a1, a2, a3, a4, a5, a6, a7) {
            return fn.apply(this, arguments);
          };

        case 9:
          return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
            return fn.apply(this, arguments);
          };

        case 10:
          return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
            return fn.apply(this, arguments);
          };

        default:
          throw new Error('First argument to _arity must be a non-negative integer no greater than ten');
      }
    }

    /**
     * Internal curryN function.
     *
     * @private
     * @category Function
     * @param {Number} length The arity of the curried function.
     * @param {Array} received An array of arguments received thus far.
     * @param {Function} fn The function to curry.
     * @return {Function} The curried function.
     */

    function _curryN(length, received, fn) {
      return function () {
        var combined = [];
        var argsIdx = 0;
        var left = length;
        var combinedIdx = 0;

        while (combinedIdx < received.length || argsIdx < arguments.length) {
          var result;

          if (combinedIdx < received.length && (!_isPlaceholder(received[combinedIdx]) || argsIdx >= arguments.length)) {
            result = received[combinedIdx];
          } else {
            result = arguments[argsIdx];
            argsIdx += 1;
          }

          combined[combinedIdx] = result;

          if (!_isPlaceholder(result)) {
            left -= 1;
          }

          combinedIdx += 1;
        }

        return left <= 0 ? fn.apply(this, combined) : _arity(left, _curryN(length, combined, fn));
      };
    }

    /**
     * Returns a curried equivalent of the provided function, with the specified
     * arity. The curried function has two unusual capabilities. First, its
     * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the
     * following are equivalent:
     *
     *   - `g(1)(2)(3)`
     *   - `g(1)(2, 3)`
     *   - `g(1, 2)(3)`
     *   - `g(1, 2, 3)`
     *
     * Secondly, the special placeholder value [`R.__`](#__) may be used to specify
     * "gaps", allowing partial application of any combination of arguments,
     * regardless of their positions. If `g` is as above and `_` is [`R.__`](#__),
     * the following are equivalent:
     *
     *   - `g(1, 2, 3)`
     *   - `g(_, 2, 3)(1)`
     *   - `g(_, _, 3)(1)(2)`
     *   - `g(_, _, 3)(1, 2)`
     *   - `g(_, 2)(1)(3)`
     *   - `g(_, 2)(1, 3)`
     *   - `g(_, 2)(_, 3)(1)`
     *
     * @func
     * @memberOf R
     * @since v0.5.0
     * @category Function
     * @sig Number -> (* -> a) -> (* -> a)
     * @param {Number} length The arity for the returned function.
     * @param {Function} fn The function to curry.
     * @return {Function} A new, curried function.
     * @see R.curry
     * @example
     *
     *      const sumArgs = (...args) => R.sum(args);
     *
     *      const curriedAddFourNumbers = R.curryN(4, sumArgs);
     *      const f = curriedAddFourNumbers(1, 2);
     *      const g = f(3);
     *      g(4); //=> 10
     */

    var curryN =
    /*#__PURE__*/
    _curry2(function curryN(length, fn) {
      if (length === 1) {
        return _curry1(fn);
      }

      return _arity(length, _curryN(length, [], fn));
    });

    var curryN$1 = curryN;

    /**
     * Optimized internal three-arity curry function.
     *
     * @private
     * @category Function
     * @param {Function} fn The function to curry.
     * @return {Function} The curried function.
     */

    function _curry3(fn) {
      return function f3(a, b, c) {
        switch (arguments.length) {
          case 0:
            return f3;

          case 1:
            return _isPlaceholder(a) ? f3 : _curry2(function (_b, _c) {
              return fn(a, _b, _c);
            });

          case 2:
            return _isPlaceholder(a) && _isPlaceholder(b) ? f3 : _isPlaceholder(a) ? _curry2(function (_a, _c) {
              return fn(_a, b, _c);
            }) : _isPlaceholder(b) ? _curry2(function (_b, _c) {
              return fn(a, _b, _c);
            }) : _curry1(function (_c) {
              return fn(a, b, _c);
            });

          default:
            return _isPlaceholder(a) && _isPlaceholder(b) && _isPlaceholder(c) ? f3 : _isPlaceholder(a) && _isPlaceholder(b) ? _curry2(function (_a, _b) {
              return fn(_a, _b, c);
            }) : _isPlaceholder(a) && _isPlaceholder(c) ? _curry2(function (_a, _c) {
              return fn(_a, b, _c);
            }) : _isPlaceholder(b) && _isPlaceholder(c) ? _curry2(function (_b, _c) {
              return fn(a, _b, _c);
            }) : _isPlaceholder(a) ? _curry1(function (_a) {
              return fn(_a, b, c);
            }) : _isPlaceholder(b) ? _curry1(function (_b) {
              return fn(a, _b, c);
            }) : _isPlaceholder(c) ? _curry1(function (_c) {
              return fn(a, b, _c);
            }) : fn(a, b, c);
        }
      };
    }

    /**
     * Applies a function to the value at the given index of an array, returning a
     * new copy of the array with the element at the given index replaced with the
     * result of the function application.
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category List
     * @sig Number -> (a -> a) -> [a] -> [a]
     * @param {Number} idx The index.
     * @param {Function} fn The function to apply.
     * @param {Array|Arguments} list An array-like object whose value
     *        at the supplied index will be replaced.
     * @return {Array} A copy of the supplied array-like object with
     *         the element at index `idx` replaced with the value
     *         returned by applying `fn` to the existing element.
     * @see R.update
     * @example
     *
     *      R.adjust(1, R.toUpper, ['a', 'b', 'c', 'd']);      //=> ['a', 'B', 'c', 'd']
     *      R.adjust(-1, R.toUpper, ['a', 'b', 'c', 'd']);     //=> ['a', 'b', 'c', 'D']
     * @symb R.adjust(-1, f, [a, b]) = [a, f(b)]
     * @symb R.adjust(0, f, [a, b]) = [f(a), b]
     */

    var adjust =
    /*#__PURE__*/
    _curry3(function adjust(idx, fn, list) {
      if (idx >= list.length || idx < -list.length) {
        return list;
      }

      var start = idx < 0 ? list.length : 0;

      var _idx = start + idx;

      var _list = _concat(list);

      _list[_idx] = fn(list[_idx]);
      return _list;
    });

    var adjust$1 = adjust;

    /**
     * Tests whether or not an object is an array.
     *
     * @private
     * @param {*} val The object to test.
     * @return {Boolean} `true` if `val` is an array, `false` otherwise.
     * @example
     *
     *      _isArray([]); //=> true
     *      _isArray(null); //=> false
     *      _isArray({}); //=> false
     */
    var _isArray = Array.isArray || function _isArray(val) {
      return val != null && val.length >= 0 && Object.prototype.toString.call(val) === '[object Array]';
    };

    function _isTransformer(obj) {
      return obj != null && typeof obj['@@transducer/step'] === 'function';
    }

    /**
     * Returns a function that dispatches with different strategies based on the
     * object in list position (last argument). If it is an array, executes [fn].
     * Otherwise, if it has a function with one of the given method names, it will
     * execute that function (functor case). Otherwise, if it is a transformer,
     * uses transducer [xf] to return a new transformer (transducer case).
     * Otherwise, it will default to executing [fn].
     *
     * @private
     * @param {Array} methodNames properties to check for a custom implementation
     * @param {Function} xf transducer to initialize if object is transformer
     * @param {Function} fn default ramda implementation
     * @return {Function} A function that dispatches on object in list position
     */

    function _dispatchable(methodNames, xf, fn) {
      return function () {
        if (arguments.length === 0) {
          return fn();
        }

        var args = Array.prototype.slice.call(arguments, 0);
        var obj = args.pop();

        if (!_isArray(obj)) {
          var idx = 0;

          while (idx < methodNames.length) {
            if (typeof obj[methodNames[idx]] === 'function') {
              return obj[methodNames[idx]].apply(obj, args);
            }

            idx += 1;
          }

          if (_isTransformer(obj)) {
            var transducer = xf.apply(null, args);
            return transducer(obj);
          }
        }

        return fn.apply(this, arguments);
      };
    }

    function _reduced(x) {
      return x && x['@@transducer/reduced'] ? x : {
        '@@transducer/value': x,
        '@@transducer/reduced': true
      };
    }

    var _xfBase = {
      init: function () {
        return this.xf['@@transducer/init']();
      },
      result: function (result) {
        return this.xf['@@transducer/result'](result);
      }
    };

    function _isString(x) {
      return Object.prototype.toString.call(x) === '[object String]';
    }

    /**
     * Tests whether or not an object is similar to an array.
     *
     * @private
     * @category Type
     * @category List
     * @sig * -> Boolean
     * @param {*} x The object to test.
     * @return {Boolean} `true` if `x` has a numeric length property and extreme indices defined; `false` otherwise.
     * @example
     *
     *      _isArrayLike([]); //=> true
     *      _isArrayLike(true); //=> false
     *      _isArrayLike({}); //=> false
     *      _isArrayLike({length: 10}); //=> false
     *      _isArrayLike({0: 'zero', 9: 'nine', length: 10}); //=> true
     */

    var _isArrayLike =
    /*#__PURE__*/
    _curry1(function isArrayLike(x) {
      if (_isArray(x)) {
        return true;
      }

      if (!x) {
        return false;
      }

      if (typeof x !== 'object') {
        return false;
      }

      if (_isString(x)) {
        return false;
      }

      if (x.nodeType === 1) {
        return !!x.length;
      }

      if (x.length === 0) {
        return true;
      }

      if (x.length > 0) {
        return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);
      }

      return false;
    });

    var _isArrayLike$1 = _isArrayLike;

    var XWrap =
    /*#__PURE__*/
    function () {
      function XWrap(fn) {
        this.f = fn;
      }

      XWrap.prototype['@@transducer/init'] = function () {
        throw new Error('init not implemented on XWrap');
      };

      XWrap.prototype['@@transducer/result'] = function (acc) {
        return acc;
      };

      XWrap.prototype['@@transducer/step'] = function (acc, x) {
        return this.f(acc, x);
      };

      return XWrap;
    }();

    function _xwrap(fn) {
      return new XWrap(fn);
    }

    /**
     * Creates a function that is bound to a context.
     * Note: `R.bind` does not provide the additional argument-binding capabilities of
     * [Function.prototype.bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
     *
     * @func
     * @memberOf R
     * @since v0.6.0
     * @category Function
     * @category Object
     * @sig (* -> *) -> {*} -> (* -> *)
     * @param {Function} fn The function to bind to context
     * @param {Object} thisObj The context to bind `fn` to
     * @return {Function} A function that will execute in the context of `thisObj`.
     * @see R.partial
     * @example
     *
     *      const log = R.bind(console.log, console);
     *      R.pipe(R.assoc('a', 2), R.tap(log), R.assoc('a', 3))({a: 1}); //=> {a: 3}
     *      // logs {a: 2}
     * @symb R.bind(f, o)(a, b) = f.call(o, a, b)
     */

    var bind =
    /*#__PURE__*/
    _curry2(function bind(fn, thisObj) {
      return _arity(fn.length, function () {
        return fn.apply(thisObj, arguments);
      });
    });

    var bind$1 = bind;

    function _arrayReduce(xf, acc, list) {
      var idx = 0;
      var len = list.length;

      while (idx < len) {
        acc = xf['@@transducer/step'](acc, list[idx]);

        if (acc && acc['@@transducer/reduced']) {
          acc = acc['@@transducer/value'];
          break;
        }

        idx += 1;
      }

      return xf['@@transducer/result'](acc);
    }

    function _iterableReduce(xf, acc, iter) {
      var step = iter.next();

      while (!step.done) {
        acc = xf['@@transducer/step'](acc, step.value);

        if (acc && acc['@@transducer/reduced']) {
          acc = acc['@@transducer/value'];
          break;
        }

        step = iter.next();
      }

      return xf['@@transducer/result'](acc);
    }

    function _methodReduce(xf, acc, obj, methodName) {
      return xf['@@transducer/result'](obj[methodName](bind$1(xf['@@transducer/step'], xf), acc));
    }

    var symIterator = typeof Symbol !== 'undefined' ? Symbol.iterator : '@@iterator';
    function _reduce(fn, acc, list) {
      if (typeof fn === 'function') {
        fn = _xwrap(fn);
      }

      if (_isArrayLike$1(list)) {
        return _arrayReduce(fn, acc, list);
      }

      if (typeof list['fantasy-land/reduce'] === 'function') {
        return _methodReduce(fn, acc, list, 'fantasy-land/reduce');
      }

      if (list[symIterator] != null) {
        return _iterableReduce(fn, acc, list[symIterator]());
      }

      if (typeof list.next === 'function') {
        return _iterableReduce(fn, acc, list);
      }

      if (typeof list.reduce === 'function') {
        return _methodReduce(fn, acc, list, 'reduce');
      }

      throw new TypeError('reduce: list must be array or iterable');
    }

    function _has(prop, obj) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }

    var toString$1 = Object.prototype.toString;

    var _isArguments =
    /*#__PURE__*/
    function () {
      return toString$1.call(arguments) === '[object Arguments]' ? function _isArguments(x) {
        return toString$1.call(x) === '[object Arguments]';
      } : function _isArguments(x) {
        return _has('callee', x);
      };
    }();

    var _isArguments$1 = _isArguments;

    var hasEnumBug = !
    /*#__PURE__*/
    {
      toString: null
    }.propertyIsEnumerable('toString');
    var nonEnumerableProps = ['constructor', 'valueOf', 'isPrototypeOf', 'toString', 'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString']; // Safari bug

    var hasArgsEnumBug =
    /*#__PURE__*/
    function () {

      return arguments.propertyIsEnumerable('length');
    }();

    var contains$1 = function contains(list, item) {
      var idx = 0;

      while (idx < list.length) {
        if (list[idx] === item) {
          return true;
        }

        idx += 1;
      }

      return false;
    };
    /**
     * Returns a list containing the names of all the enumerable own properties of
     * the supplied object.
     * Note that the order of the output array is not guaranteed to be consistent
     * across different JS platforms.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig {k: v} -> [k]
     * @param {Object} obj The object to extract properties from
     * @return {Array} An array of the object's own properties.
     * @see R.keysIn, R.values
     * @example
     *
     *      R.keys({a: 1, b: 2, c: 3}); //=> ['a', 'b', 'c']
     */


    var keys = typeof Object.keys === 'function' && !hasArgsEnumBug ?
    /*#__PURE__*/
    _curry1(function keys(obj) {
      return Object(obj) !== obj ? [] : Object.keys(obj);
    }) :
    /*#__PURE__*/
    _curry1(function keys(obj) {
      if (Object(obj) !== obj) {
        return [];
      }

      var prop, nIdx;
      var ks = [];

      var checkArgsLength = hasArgsEnumBug && _isArguments$1(obj);

      for (prop in obj) {
        if (_has(prop, obj) && (!checkArgsLength || prop !== 'length')) {
          ks[ks.length] = prop;
        }
      }

      if (hasEnumBug) {
        nIdx = nonEnumerableProps.length - 1;

        while (nIdx >= 0) {
          prop = nonEnumerableProps[nIdx];

          if (_has(prop, obj) && !contains$1(ks, prop)) {
            ks[ks.length] = prop;
          }

          nIdx -= 1;
        }
      }

      return ks;
    });
    var keys$1 = keys;

    /**
     * Determine if the passed argument is an integer.
     *
     * @private
     * @param {*} n
     * @category Type
     * @return {Boolean}
     */
    var _isInteger = Number.isInteger || function _isInteger(n) {
      return n << 0 === n;
    };

    /**
     * Returns a single item by iterating through the list, successively calling
     * the iterator function and passing it an accumulator value and the current
     * value from the array, and then passing the result to the next call.
     *
     * The iterator function receives two values: *(acc, value)*. It may use
     * [`R.reduced`](#reduced) to shortcut the iteration.
     *
     * The arguments' order of [`reduceRight`](#reduceRight)'s iterator function
     * is *(value, acc)*.
     *
     * Note: `R.reduce` does not skip deleted or unassigned indices (sparse
     * arrays), unlike the native `Array.prototype.reduce` method. For more details
     * on this behavior, see:
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description
     *
     * Dispatches to the `reduce` method of the third argument, if present. When
     * doing so, it is up to the user to handle the [`R.reduced`](#reduced)
     * shortcuting, as this is not implemented by `reduce`.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig ((a, b) -> a) -> a -> [b] -> a
     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
     *        current element from the array.
     * @param {*} acc The accumulator value.
     * @param {Array} list The list to iterate over.
     * @return {*} The final, accumulated value.
     * @see R.reduced, R.addIndex, R.reduceRight
     * @example
     *
     *      R.reduce(R.subtract, 0, [1, 2, 3, 4]) // => ((((0 - 1) - 2) - 3) - 4) = -10
     *      //          -               -10
     *      //         / \              / \
     *      //        -   4           -6   4
     *      //       / \              / \
     *      //      -   3   ==>     -3   3
     *      //     / \              / \
     *      //    -   2           -1   2
     *      //   / \              / \
     *      //  0   1            0   1
     *
     * @symb R.reduce(f, a, [b, c, d]) = f(f(f(a, b), c), d)
     */

    var reduce =
    /*#__PURE__*/
    _curry3(_reduce);

    var reduce$1 = reduce;

    /**
     * Returns a function that always returns the given value. Note that for
     * non-primitives the value returned is a reference to the original value.
     *
     * This function is known as `const`, `constant`, or `K` (for K combinator) in
     * other languages and libraries.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig a -> (* -> a)
     * @param {*} val The value to wrap in a function
     * @return {Function} A Function :: * -> val.
     * @example
     *
     *      const t = R.always('Tee');
     *      t(); //=> 'Tee'
     */

    var always =
    /*#__PURE__*/
    _curry1(function always(val) {
      return function () {
        return val;
      };
    });

    var always$1 = always;

    /**
     * Makes a shallow clone of an object, setting or overriding the specified
     * property with the given value. Note that this copies and flattens prototype
     * properties onto the new object as well. All non-primitive properties are
     * copied by reference.
     *
     * @func
     * @memberOf R
     * @since v0.8.0
     * @category Object
     * @sig String -> a -> {k: v} -> {k: v}
     * @param {String} prop The property name to set
     * @param {*} val The new value
     * @param {Object} obj The object to clone
     * @return {Object} A new object equivalent to the original except for the changed property.
     * @see R.dissoc, R.pick
     * @example
     *
     *      R.assoc('c', 3, {a: 1, b: 2}); //=> {a: 1, b: 2, c: 3}
     */

    var assoc =
    /*#__PURE__*/
    _curry3(function assoc(prop, val, obj) {
      var result = {};

      for (var p in obj) {
        result[p] = obj[p];
      }

      result[prop] = val;
      return result;
    });

    var assoc$1 = assoc;

    /**
     * Returns a curried equivalent of the provided function. The curried function
     * has two unusual capabilities. First, its arguments needn't be provided one
     * at a time. If `f` is a ternary function and `g` is `R.curry(f)`, the
     * following are equivalent:
     *
     *   - `g(1)(2)(3)`
     *   - `g(1)(2, 3)`
     *   - `g(1, 2)(3)`
     *   - `g(1, 2, 3)`
     *
     * Secondly, the special placeholder value [`R.__`](#__) may be used to specify
     * "gaps", allowing partial application of any combination of arguments,
     * regardless of their positions. If `g` is as above and `_` is [`R.__`](#__),
     * the following are equivalent:
     *
     *   - `g(1, 2, 3)`
     *   - `g(_, 2, 3)(1)`
     *   - `g(_, _, 3)(1)(2)`
     *   - `g(_, _, 3)(1, 2)`
     *   - `g(_, 2)(1)(3)`
     *   - `g(_, 2)(1, 3)`
     *   - `g(_, 2)(_, 3)(1)`
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (* -> a) -> (* -> a)
     * @param {Function} fn The function to curry.
     * @return {Function} A new, curried function.
     * @see R.curryN, R.partial
     * @example
     *
     *      const addFourNumbers = (a, b, c, d) => a + b + c + d;
     *
     *      const curriedAddFourNumbers = R.curry(addFourNumbers);
     *      const f = curriedAddFourNumbers(1, 2);
     *      const g = f(3);
     *      g(4); //=> 10
     */

    var curry =
    /*#__PURE__*/
    _curry1(function curry(fn) {
      return curryN$1(fn.length, fn);
    });

    var curry$1 = curry;

    /**
     * Gives a single-word string description of the (native) type of a value,
     * returning such answers as 'Object', 'Number', 'Array', or 'Null'. Does not
     * attempt to distinguish user Object types any further, reporting them all as
     * 'Object'.
     *
     * @func
     * @memberOf R
     * @since v0.8.0
     * @category Type
     * @sig (* -> {*}) -> String
     * @param {*} val The value to test
     * @return {String}
     * @example
     *
     *      R.type({}); //=> "Object"
     *      R.type(1); //=> "Number"
     *      R.type(false); //=> "Boolean"
     *      R.type('s'); //=> "String"
     *      R.type(null); //=> "Null"
     *      R.type([]); //=> "Array"
     *      R.type(/[A-z]/); //=> "RegExp"
     *      R.type(() => {}); //=> "Function"
     *      R.type(undefined); //=> "Undefined"
     */

    var type =
    /*#__PURE__*/
    _curry1(function type(val) {
      return val === null ? 'Null' : val === undefined ? 'Undefined' : Object.prototype.toString.call(val).slice(8, -1);
    });

    var type$1 = type;

    function _pipe(f, g) {
      return function () {
        return g.call(this, f.apply(this, arguments));
      };
    }

    /**
     * This checks whether a function has a [methodname] function. If it isn't an
     * array it will execute that function otherwise it will default to the ramda
     * implementation.
     *
     * @private
     * @param {Function} fn ramda implemtation
     * @param {String} methodname property to check for a custom implementation
     * @return {Object} Whatever the return value of the method is.
     */

    function _checkForMethod(methodname, fn) {
      return function () {
        var length = arguments.length;

        if (length === 0) {
          return fn();
        }

        var obj = arguments[length - 1];
        return _isArray(obj) || typeof obj[methodname] !== 'function' ? fn.apply(this, arguments) : obj[methodname].apply(obj, Array.prototype.slice.call(arguments, 0, length - 1));
      };
    }

    /**
     * Returns the elements of the given list or string (or object with a `slice`
     * method) from `fromIndex` (inclusive) to `toIndex` (exclusive).
     *
     * Dispatches to the `slice` method of the third argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.1.4
     * @category List
     * @sig Number -> Number -> [a] -> [a]
     * @sig Number -> Number -> String -> String
     * @param {Number} fromIndex The start index (inclusive).
     * @param {Number} toIndex The end index (exclusive).
     * @param {*} list
     * @return {*}
     * @example
     *
     *      R.slice(1, 3, ['a', 'b', 'c', 'd']);        //=> ['b', 'c']
     *      R.slice(1, Infinity, ['a', 'b', 'c', 'd']); //=> ['b', 'c', 'd']
     *      R.slice(0, -1, ['a', 'b', 'c', 'd']);       //=> ['a', 'b', 'c']
     *      R.slice(-3, -1, ['a', 'b', 'c', 'd']);      //=> ['b', 'c']
     *      R.slice(0, 3, 'ramda');                     //=> 'ram'
     */

    var slice =
    /*#__PURE__*/
    _curry3(
    /*#__PURE__*/
    _checkForMethod('slice', function slice(fromIndex, toIndex, list) {
      return Array.prototype.slice.call(list, fromIndex, toIndex);
    }));

    var slice$1 = slice;

    /**
     * Returns all but the first element of the given list or string (or object
     * with a `tail` method).
     *
     * Dispatches to the `slice` method of the first argument, if present.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig [a] -> [a]
     * @sig String -> String
     * @param {*} list
     * @return {*}
     * @see R.head, R.init, R.last
     * @example
     *
     *      R.tail([1, 2, 3]);  //=> [2, 3]
     *      R.tail([1, 2]);     //=> [2]
     *      R.tail([1]);        //=> []
     *      R.tail([]);         //=> []
     *
     *      R.tail('abc');  //=> 'bc'
     *      R.tail('ab');   //=> 'b'
     *      R.tail('a');    //=> ''
     *      R.tail('');     //=> ''
     */

    var tail =
    /*#__PURE__*/
    _curry1(
    /*#__PURE__*/
    _checkForMethod('tail',
    /*#__PURE__*/
    slice$1(1, Infinity)));

    var tail$1 = tail;

    /**
     * Performs left-to-right function composition. The first argument may have
     * any arity; the remaining arguments must be unary.
     *
     * In some libraries this function is named `sequence`.
     *
     * **Note:** The result of pipe is not automatically curried.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig (((a, b, ..., n) -> o), (o -> p), ..., (x -> y), (y -> z)) -> ((a, b, ..., n) -> z)
     * @param {...Function} functions
     * @return {Function}
     * @see R.compose
     * @example
     *
     *      const f = R.pipe(Math.pow, R.negate, R.inc);
     *
     *      f(3, 4); // -(3^4) + 1
     * @symb R.pipe(f, g, h)(a, b) = h(g(f(a, b)))
     */

    function pipe() {
      if (arguments.length === 0) {
        throw new Error('pipe requires at least one argument');
      }

      return _arity(arguments[0].length, reduce$1(_pipe, arguments[0], tail$1(arguments)));
    }

    function _identity(x) {
      return x;
    }

    /**
     * A function that does nothing but return the parameter supplied to it. Good
     * as a default or placeholder function.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Function
     * @sig a -> a
     * @param {*} x The value to return.
     * @return {*} The input value, `x`.
     * @example
     *
     *      R.identity(1); //=> 1
     *
     *      const obj = {};
     *      R.identity(obj) === obj; //=> true
     * @symb R.identity(a) = a
     */

    var identity$1 =
    /*#__PURE__*/
    _curry1(_identity);

    var identity$2 = identity$1;

    function _arrayFromIterator(iter) {
      var list = [];
      var next;

      while (!(next = iter.next()).done) {
        list.push(next.value);
      }

      return list;
    }

    function _includesWith(pred, x, list) {
      var idx = 0;
      var len = list.length;

      while (idx < len) {
        if (pred(x, list[idx])) {
          return true;
        }

        idx += 1;
      }

      return false;
    }

    function _functionName(f) {
      // String(x => x) evaluates to "x => x", so the pattern may not match.
      var match = String(f).match(/^function (\w*)/);
      return match == null ? '' : match[1];
    }

    // Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
    function _objectIs(a, b) {
      // SameValue algorithm
      if (a === b) {
        // Steps 1-5, 7-10
        // Steps 6.b-6.e: +0 != -0
        return a !== 0 || 1 / a === 1 / b;
      } else {
        // Step 6.a: NaN == NaN
        return a !== a && b !== b;
      }
    }

    var _objectIs$1 = typeof Object.is === 'function' ? Object.is : _objectIs;

    /**
     * private _uniqContentEquals function.
     * That function is checking equality of 2 iterator contents with 2 assumptions
     * - iterators lengths are the same
     * - iterators values are unique
     *
     * false-positive result will be returned for comparision of, e.g.
     * - [1,2,3] and [1,2,3,4]
     * - [1,1,1] and [1,2,3]
     * */

    function _uniqContentEquals(aIterator, bIterator, stackA, stackB) {
      var a = _arrayFromIterator(aIterator);

      var b = _arrayFromIterator(bIterator);

      function eq(_a, _b) {
        return _equals(_a, _b, stackA.slice(), stackB.slice());
      } // if *a* array contains any element that is not included in *b*


      return !_includesWith(function (b, aItem) {
        return !_includesWith(eq, aItem, b);
      }, b, a);
    }

    function _equals(a, b, stackA, stackB) {
      if (_objectIs$1(a, b)) {
        return true;
      }

      var typeA = type$1(a);

      if (typeA !== type$1(b)) {
        return false;
      }

      if (a == null || b == null) {
        return false;
      }

      if (typeof a['fantasy-land/equals'] === 'function' || typeof b['fantasy-land/equals'] === 'function') {
        return typeof a['fantasy-land/equals'] === 'function' && a['fantasy-land/equals'](b) && typeof b['fantasy-land/equals'] === 'function' && b['fantasy-land/equals'](a);
      }

      if (typeof a.equals === 'function' || typeof b.equals === 'function') {
        return typeof a.equals === 'function' && a.equals(b) && typeof b.equals === 'function' && b.equals(a);
      }

      switch (typeA) {
        case 'Arguments':
        case 'Array':
        case 'Object':
          if (typeof a.constructor === 'function' && _functionName(a.constructor) === 'Promise') {
            return a === b;
          }

          break;

        case 'Boolean':
        case 'Number':
        case 'String':
          if (!(typeof a === typeof b && _objectIs$1(a.valueOf(), b.valueOf()))) {
            return false;
          }

          break;

        case 'Date':
          if (!_objectIs$1(a.valueOf(), b.valueOf())) {
            return false;
          }

          break;

        case 'Error':
          return a.name === b.name && a.message === b.message;

        case 'RegExp':
          if (!(a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.sticky === b.sticky && a.unicode === b.unicode)) {
            return false;
          }

          break;
      }

      var idx = stackA.length - 1;

      while (idx >= 0) {
        if (stackA[idx] === a) {
          return stackB[idx] === b;
        }

        idx -= 1;
      }

      switch (typeA) {
        case 'Map':
          if (a.size !== b.size) {
            return false;
          }

          return _uniqContentEquals(a.entries(), b.entries(), stackA.concat([a]), stackB.concat([b]));

        case 'Set':
          if (a.size !== b.size) {
            return false;
          }

          return _uniqContentEquals(a.values(), b.values(), stackA.concat([a]), stackB.concat([b]));

        case 'Arguments':
        case 'Array':
        case 'Object':
        case 'Boolean':
        case 'Number':
        case 'String':
        case 'Date':
        case 'Error':
        case 'RegExp':
        case 'Int8Array':
        case 'Uint8Array':
        case 'Uint8ClampedArray':
        case 'Int16Array':
        case 'Uint16Array':
        case 'Int32Array':
        case 'Uint32Array':
        case 'Float32Array':
        case 'Float64Array':
        case 'ArrayBuffer':
          break;

        default:
          // Values of other types are only equal if identical.
          return false;
      }

      var keysA = keys$1(a);

      if (keysA.length !== keys$1(b).length) {
        return false;
      }

      var extendedStackA = stackA.concat([a]);
      var extendedStackB = stackB.concat([b]);
      idx = keysA.length - 1;

      while (idx >= 0) {
        var key = keysA[idx];

        if (!(_has(key, b) && _equals(b[key], a[key], extendedStackA, extendedStackB))) {
          return false;
        }

        idx -= 1;
      }

      return true;
    }

    /**
     * Returns `true` if its arguments are equivalent, `false` otherwise. Handles
     * cyclical data structures.
     *
     * Dispatches symmetrically to the `equals` methods of both arguments, if
     * present.
     *
     * @func
     * @memberOf R
     * @since v0.15.0
     * @category Relation
     * @sig a -> b -> Boolean
     * @param {*} a
     * @param {*} b
     * @return {Boolean}
     * @example
     *
     *      R.equals(1, 1); //=> true
     *      R.equals(1, '1'); //=> false
     *      R.equals([1, 2, 3], [1, 2, 3]); //=> true
     *
     *      const a = {}; a.v = a;
     *      const b = {}; b.v = b;
     *      R.equals(a, b); //=> true
     */

    var equals =
    /*#__PURE__*/
    _curry2(function equals(a, b) {
      return _equals(a, b, [], []);
    });

    var equals$1 = equals;

    function _indexOf(list, a, idx) {
      var inf, item; // Array.prototype.indexOf doesn't exist below IE9

      if (typeof list.indexOf === 'function') {
        switch (typeof a) {
          case 'number':
            if (a === 0) {
              // manually crawl the list to distinguish between +0 and -0
              inf = 1 / a;

              while (idx < list.length) {
                item = list[idx];

                if (item === 0 && 1 / item === inf) {
                  return idx;
                }

                idx += 1;
              }

              return -1;
            } else if (a !== a) {
              // NaN
              while (idx < list.length) {
                item = list[idx];

                if (typeof item === 'number' && item !== item) {
                  return idx;
                }

                idx += 1;
              }

              return -1;
            } // non-zero numbers can utilise Set


            return list.indexOf(a, idx);
          // all these types can utilise Set

          case 'string':
          case 'boolean':
          case 'function':
          case 'undefined':
            return list.indexOf(a, idx);

          case 'object':
            if (a === null) {
              // null can utilise Set
              return list.indexOf(a, idx);
            }

        }
      } // anything else not covered above, defer to R.equals


      while (idx < list.length) {
        if (equals$1(list[idx], a)) {
          return idx;
        }

        idx += 1;
      }

      return -1;
    }

    function _includes(a, list) {
      return _indexOf(list, a, 0) >= 0;
    }

    var _Set =
    /*#__PURE__*/
    function () {
      function _Set() {
        /* globals Set */
        this._nativeSet = typeof Set === 'function' ? new Set() : null;
        this._items = {};
      }

      // until we figure out why jsdoc chokes on this
      // @param item The item to add to the Set
      // @returns {boolean} true if the item did not exist prior, otherwise false
      //
      _Set.prototype.add = function (item) {
        return !hasOrAdd(item, true, this);
      }; //
      // @param item The item to check for existence in the Set
      // @returns {boolean} true if the item exists in the Set, otherwise false
      //


      _Set.prototype.has = function (item) {
        return hasOrAdd(item, false, this);
      }; //
      // Combines the logic for checking whether an item is a member of the set and
      // for adding a new item to the set.
      //
      // @param item       The item to check or add to the Set instance.
      // @param shouldAdd  If true, the item will be added to the set if it doesn't
      //                   already exist.
      // @param set        The set instance to check or add to.
      // @return {boolean} true if the item already existed, otherwise false.
      //


      return _Set;
    }();

    function hasOrAdd(item, shouldAdd, set) {
      var type = typeof item;
      var prevSize, newSize;

      switch (type) {
        case 'string':
        case 'number':
          // distinguish between +0 and -0
          if (item === 0 && 1 / item === -Infinity) {
            if (set._items['-0']) {
              return true;
            } else {
              if (shouldAdd) {
                set._items['-0'] = true;
              }

              return false;
            }
          } // these types can all utilise the native Set


          if (set._nativeSet !== null) {
            if (shouldAdd) {
              prevSize = set._nativeSet.size;

              set._nativeSet.add(item);

              newSize = set._nativeSet.size;
              return newSize === prevSize;
            } else {
              return set._nativeSet.has(item);
            }
          } else {
            if (!(type in set._items)) {
              if (shouldAdd) {
                set._items[type] = {};
                set._items[type][item] = true;
              }

              return false;
            } else if (item in set._items[type]) {
              return true;
            } else {
              if (shouldAdd) {
                set._items[type][item] = true;
              }

              return false;
            }
          }

        case 'boolean':
          // set._items['boolean'] holds a two element array
          // representing [ falseExists, trueExists ]
          if (type in set._items) {
            var bIdx = item ? 1 : 0;

            if (set._items[type][bIdx]) {
              return true;
            } else {
              if (shouldAdd) {
                set._items[type][bIdx] = true;
              }

              return false;
            }
          } else {
            if (shouldAdd) {
              set._items[type] = item ? [false, true] : [true, false];
            }

            return false;
          }

        case 'function':
          // compare functions for reference equality
          if (set._nativeSet !== null) {
            if (shouldAdd) {
              prevSize = set._nativeSet.size;

              set._nativeSet.add(item);

              newSize = set._nativeSet.size;
              return newSize === prevSize;
            } else {
              return set._nativeSet.has(item);
            }
          } else {
            if (!(type in set._items)) {
              if (shouldAdd) {
                set._items[type] = [item];
              }

              return false;
            }

            if (!_includes(item, set._items[type])) {
              if (shouldAdd) {
                set._items[type].push(item);
              }

              return false;
            }

            return true;
          }

        case 'undefined':
          if (set._items[type]) {
            return true;
          } else {
            if (shouldAdd) {
              set._items[type] = true;
            }

            return false;
          }

        case 'object':
          if (item === null) {
            if (!set._items['null']) {
              if (shouldAdd) {
                set._items['null'] = true;
              }

              return false;
            }

            return true;
          }

        /* falls through */

        default:
          // reduce the search size of heterogeneous sets by creating buckets
          // for each type.
          type = Object.prototype.toString.call(item);

          if (!(type in set._items)) {
            if (shouldAdd) {
              set._items[type] = [item];
            }

            return false;
          } // scan through all previously applied items


          if (!_includes(item, set._items[type])) {
            if (shouldAdd) {
              set._items[type].push(item);
            }

            return false;
          }

          return true;
      }
    } // A simple Set type that honours R.equals semantics


    var _Set$1 = _Set;

    /**
     * Returns a new object that does not contain a `prop` property.
     *
     * @func
     * @memberOf R
     * @since v0.10.0
     * @category Object
     * @sig String -> {k: v} -> {k: v}
     * @param {String} prop The name of the property to dissociate
     * @param {Object} obj The object to clone
     * @return {Object} A new object equivalent to the original but without the specified property
     * @see R.assoc, R.omit
     * @example
     *
     *      R.dissoc('b', {a: 1, b: 2, c: 3}); //=> {a: 1, c: 3}
     */

    var dissoc =
    /*#__PURE__*/
    _curry2(function dissoc(prop, obj) {
      var result = {};

      for (var p in obj) {
        result[p] = obj[p];
      }

      delete result[prop];
      return result;
    });

    var dissoc$1 = dissoc;

    /**
     * Removes the sub-list of `list` starting at index `start` and containing
     * `count` elements. _Note that this is not destructive_: it returns a copy of
     * the list with the changes.
     * <small>No lists have been harmed in the application of this function.</small>
     *
     * @func
     * @memberOf R
     * @since v0.2.2
     * @category List
     * @sig Number -> Number -> [a] -> [a]
     * @param {Number} start The position to start removing elements
     * @param {Number} count The number of elements to remove
     * @param {Array} list The list to remove from
     * @return {Array} A new Array with `count` elements from `start` removed.
     * @see R.without
     * @example
     *
     *      R.remove(2, 3, [1,2,3,4,5,6,7,8]); //=> [1,2,6,7,8]
     */

    var remove =
    /*#__PURE__*/
    _curry3(function remove(start, count, list) {
      var result = Array.prototype.slice.call(list, 0);
      result.splice(start, count);
      return result;
    });

    var remove$1 = remove;

    /**
     * Returns a new copy of the array with the element at the provided index
     * replaced with the given value.
     *
     * @func
     * @memberOf R
     * @since v0.14.0
     * @category List
     * @sig Number -> a -> [a] -> [a]
     * @param {Number} idx The index to update.
     * @param {*} x The value to exist at the given index of the returned array.
     * @param {Array|Arguments} list The source array-like object to be updated.
     * @return {Array} A copy of `list` with the value at index `idx` replaced with `x`.
     * @see R.adjust
     * @example
     *
     *      R.update(1, '_', ['a', 'b', 'c']);      //=> ['a', '_', 'c']
     *      R.update(-1, '_', ['a', 'b', 'c']);     //=> ['a', 'b', '_']
     * @symb R.update(-1, a, [b, c]) = [b, a]
     * @symb R.update(0, a, [b, c]) = [a, c]
     * @symb R.update(1, a, [b, c]) = [b, a]
     */

    var update =
    /*#__PURE__*/
    _curry3(function update(idx, x, list) {
      return adjust$1(idx, always$1(x), list);
    });

    var update$1 = update;

    /**
     * Makes a shallow clone of an object, omitting the property at the given path.
     * Note that this copies and flattens prototype properties onto the new object
     * as well. All non-primitive properties are copied by reference.
     *
     * @func
     * @memberOf R
     * @since v0.11.0
     * @category Object
     * @typedefn Idx = String | Int
     * @sig [Idx] -> {k: v} -> {k: v}
     * @param {Array} path The path to the value to omit
     * @param {Object} obj The object to clone
     * @return {Object} A new object without the property at path
     * @see R.assocPath
     * @example
     *
     *      R.dissocPath(['a', 'b', 'c'], {a: {b: {c: 42}}}); //=> {a: {b: {}}}
     */

    var dissocPath =
    /*#__PURE__*/
    _curry2(function dissocPath(path, obj) {
      switch (path.length) {
        case 0:
          return obj;

        case 1:
          return _isInteger(path[0]) && _isArray(obj) ? remove$1(path[0], 1, obj) : dissoc$1(path[0], obj);

        default:
          var head = path[0];
          var tail = Array.prototype.slice.call(path, 1);

          if (obj[head] == null) {
            return obj;
          } else if (_isInteger(head) && _isArray(obj)) {
            return update$1(head, dissocPath(tail, obj[head]), obj);
          } else {
            return assoc$1(head, dissocPath(tail, obj[head]), obj);
          }

      }
    });

    var dissocPath$1 = dissocPath;

    var XFindIndex =
    /*#__PURE__*/
    function () {
      function XFindIndex(f, xf) {
        this.xf = xf;
        this.f = f;
        this.idx = -1;
        this.found = false;
      }

      XFindIndex.prototype['@@transducer/init'] = _xfBase.init;

      XFindIndex.prototype['@@transducer/result'] = function (result) {
        if (!this.found) {
          result = this.xf['@@transducer/step'](result, -1);
        }

        return this.xf['@@transducer/result'](result);
      };

      XFindIndex.prototype['@@transducer/step'] = function (result, input) {
        this.idx += 1;

        if (this.f(input)) {
          this.found = true;
          result = _reduced(this.xf['@@transducer/step'](result, this.idx));
        }

        return result;
      };

      return XFindIndex;
    }();

    var _xfindIndex =
    /*#__PURE__*/
    _curry2(function _xfindIndex(f, xf) {
      return new XFindIndex(f, xf);
    });

    var _xfindIndex$1 = _xfindIndex;

    /**
     * Returns the index of the first element of the list which matches the
     * predicate, or `-1` if no element matches.
     *
     * Acts as a transducer if a transformer is given in list position.
     *
     * @func
     * @memberOf R
     * @since v0.1.1
     * @category List
     * @sig (a -> Boolean) -> [a] -> Number
     * @param {Function} fn The predicate function used to determine if the element is the
     * desired one.
     * @param {Array} list The array to consider.
     * @return {Number} The index of the element found, or `-1`.
     * @see R.transduce
     * @example
     *
     *      const xs = [{a: 1}, {a: 2}, {a: 3}];
     *      R.findIndex(R.propEq('a', 2))(xs); //=> 1
     *      R.findIndex(R.propEq('a', 4))(xs); //=> -1
     */

    var findIndex$3 =
    /*#__PURE__*/
    _curry2(
    /*#__PURE__*/
    _dispatchable([], _xfindIndex$1, function findIndex(fn, list) {
      var idx = 0;
      var len = list.length;

      while (idx < len) {
        if (fn(list[idx])) {
          return idx;
        }

        idx += 1;
      }

      return -1;
    }));

    var findIndex$4 = findIndex$3;

    /**
     * Returns a new list containing only one copy of each element in the original
     * list, based upon the value returned by applying the supplied function to
     * each list element. Prefers the first item if the supplied function produces
     * the same value on two items. [`R.equals`](#equals) is used for comparison.
     *
     * @func
     * @memberOf R
     * @since v0.16.0
     * @category List
     * @sig (a -> b) -> [a] -> [a]
     * @param {Function} fn A function used to produce a value to use during comparisons.
     * @param {Array} list The array to consider.
     * @return {Array} The list of unique items.
     * @example
     *
     *      R.uniqBy(Math.abs, [-1, -5, 2, 10, 1, 2]); //=> [-1, -5, 2, 10]
     */

    var uniqBy =
    /*#__PURE__*/
    _curry2(function uniqBy(fn, list) {
      var set = new _Set$1();
      var result = [];
      var idx = 0;
      var appliedItem, item;

      while (idx < list.length) {
        item = list[idx];
        appliedItem = fn(item);

        if (set.add(appliedItem)) {
          result.push(item);
        }

        idx += 1;
      }

      return result;
    });

    var uniqBy$1 = uniqBy;

    /**
     * Returns a new list containing only one copy of each element in the original
     * list. [`R.equals`](#equals) is used to determine equality.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig [a] -> [a]
     * @param {Array} list The array to consider.
     * @return {Array} The list of unique items.
     * @example
     *
     *      R.uniq([1, 1, 2, 1]); //=> [1, 2]
     *      R.uniq([1, '1']);     //=> [1, '1']
     *      R.uniq([[42], [42]]); //=> [[42]]
     */

    var uniq =
    /*#__PURE__*/
    uniqBy$1(identity$2);
    var uniq$1 = uniq;

    function _isNumber(x) {
      return Object.prototype.toString.call(x) === '[object Number]';
    }

    /**
     * Returns a partial copy of an object omitting the keys specified.
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Object
     * @sig [String] -> {String: *} -> {String: *}
     * @param {Array} names an array of String property names to omit from the new object
     * @param {Object} obj The object to copy from
     * @return {Object} A new object with properties from `names` not on it.
     * @see R.pick
     * @example
     *
     *      R.omit(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, c: 3}
     */

    var omit =
    /*#__PURE__*/
    _curry2(function omit(names, obj) {
      var result = {};
      var index = {};
      var idx = 0;
      var len = names.length;

      while (idx < len) {
        index[names[idx]] = 1;
        idx += 1;
      }

      for (var prop in obj) {
        if (!index.hasOwnProperty(prop)) {
          result[prop] = obj[prop];
        }
      }

      return result;
    });

    var omit$1 = omit;

    /**
     * Returns `true` if the specified object property is equal, in
     * [`R.equals`](#equals) terms, to the given value; `false` otherwise.
     * You can test multiple properties with [`R.whereEq`](#whereEq).
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category Relation
     * @sig String -> a -> Object -> Boolean
     * @param {String} name
     * @param {*} val
     * @param {*} obj
     * @return {Boolean}
     * @see R.whereEq, R.propSatisfies, R.equals
     * @example
     *
     *      const abby = {name: 'Abby', age: 7, hair: 'blond'};
     *      const fred = {name: 'Fred', age: 12, hair: 'brown'};
     *      const rusty = {name: 'Rusty', age: 10, hair: 'brown'};
     *      const alois = {name: 'Alois', age: 15, disposition: 'surly'};
     *      const kids = [abby, fred, rusty, alois];
     *      const hasBrownHair = R.propEq('hair', 'brown');
     *      R.filter(hasBrownHair, kids); //=> [fred, rusty]
     */

    var propEq =
    /*#__PURE__*/
    _curry3(function propEq(name, val, obj) {
      return equals$1(val, obj[name]);
    });

    var propEq$1 = propEq;

    /**
     * Returns a list of numbers from `from` (inclusive) to `to` (exclusive).
     *
     * @func
     * @memberOf R
     * @since v0.1.0
     * @category List
     * @sig Number -> Number -> [Number]
     * @param {Number} from The first number in the list.
     * @param {Number} to One more than the last number in the list.
     * @return {Array} The list of numbers in the set `[a, b)`.
     * @example
     *
     *      R.range(1, 5);    //=> [1, 2, 3, 4]
     *      R.range(50, 53);  //=> [50, 51, 52]
     */

    var range$1 =
    /*#__PURE__*/
    _curry2(function range(from, to) {
      if (!(_isNumber(from) && _isNumber(to))) {
        throw new TypeError('Both arguments to range must be numbers');
      }

      var result = [];
      var n = from;

      while (n < to) {
        result.push(n);
        n += 1;
      }

      return result;
    });

    var range$2 = range$1;

    // Unique ID creation requires a high quality random # generator. In the browser we therefore
    // require the crypto API and do not support built-in fallback to lower quality random number
    // generators (like Math.random()).
    var getRandomValues;
    var rnds8 = new Uint8Array(16);
    function rng() {
      // lazy load so that environments that need to polyfill have a chance to do so
      if (!getRandomValues) {
        // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
        // find the complete implementation of crypto (msCrypto) on IE11.
        getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);

        if (!getRandomValues) {
          throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
        }
      }

      return getRandomValues(rnds8);
    }

    var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

    function validate(uuid) {
      return typeof uuid === 'string' && REGEX.test(uuid);
    }

    /**
     * Convert array of 16 byte values to UUID string format of the form:
     * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
     */

    var byteToHex = [];

    for (var i = 0; i < 256; ++i) {
      byteToHex.push((i + 0x100).toString(16).substr(1));
    }

    function stringify(arr) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      // Note: Be careful editing this code!  It's been tuned for performance
      // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
      var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
      // of the following:
      // - One or more input array values don't map to a hex octet (leading to
      // "undefined" in the uuid)
      // - Invalid input values for the RFC `version` or `variant` fields

      if (!validate(uuid)) {
        throw TypeError('Stringified UUID is invalid');
      }

      return uuid;
    }

    function v4(options, buf, offset) {
      options = options || {};
      var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

      rnds[6] = rnds[6] & 0x0f | 0x40;
      rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

      if (buf) {
        offset = offset || 0;

        for (var i = 0; i < 16; ++i) {
          buf[offset + i] = rnds[i];
        }

        return buf;
      }

      return stringify(rnds);
    }

    pipe(camelCase_1, upperFirst_1);
    function createSubscriptionHelper() {
        const subscriptions = [];
        const push = (...args) => subscriptions.push(...args);
        const destroy = () => {
            while (subscriptions.length) {
                const f = subscriptions.shift();
                isFunction$1(f) ? f() : f.unsubscribe();
            }
        };
        return {
            push,
            destroy,
        };
    }
    const cloneDeep = (value) => JSON.parse(JSON.stringify(value));
    const isArray$1 = (value) => Array.isArray(value);
    const isEmpty = (value) => isNull$1(value) || isUndefined(value);
    const isTypeof = curry$1((name, value) => typeof value === name);
    const isObject$2 = (value) => !!value && isTypeof('object', value);
    const isFunction$1 = isTypeof('function');
    const isString$1 = isTypeof('string');
    const isUndefined = isTypeof('undefined');
    const isNumber = isTypeof('number');
    const isBoolean = isTypeof('boolean');
    const isNull$1 = (value) => value === null;
    const getData = (list, id) => list.find(data => data.id === id);
    const getIndex = (list, id) => findIndex$4(propEq$1('id', id))(list);
    const range = (a, b) => a < b ? range$2(a, b + 1) : range$2(b, a + 1);
    function* flat(iterator) {
        for (const value of iterator) {
            if (value && value[Symbol.iterator])
                yield* flat(value);
            else
                yield value;
        }
    }
    const createBalanceRange = (min, max) => (num) => Math.min(Math.max(num, min), max);
    function autoName(list, id, name, num = 1) {
        let result = true;
        for (const value of list) {
            if (name === value.name && value.id !== id && name !== '') {
                result = false;
                break;
            }
        }
        if (result) {
            return name;
        }
        return autoName(list, id, name.replace(/[0-9]/g, '') + num, num + 1);
    }

    const createTheme = () => ({
        canvas: '#ECEEF2',
        package: '#909399',
        packageActive: '#657b83',
        table: '#FFFFFF',
        tableActive: '#276ff5',
        focus: '#657b83',
        keyPK: '#E6A23C',
        keyFK: '#999999',
        keyPFK: '#60b9c4',
        font: '#212121',
        fontActive: '#212121',
        fontPlaceholder: '#212121',
        contextmenu: '#E5E5E5',
        contextmenuActive: '#91C0F1',
        edit: '#409EFF',
        columnSelect: '#91C0F1',
        columnActive: '#91C0F1',
        minimapShadow: '#a8a8a8',
        scrollbarThumb: 'rgba(100, 100, 100, 0.4)',
        scrollbarThumbActive: 'rgba(100, 100, 100, 0.7)',
        menubar: '#F2F2F2',
        visualization: '#fdf6e3',
    });
    const loadTheme = (theme, newTheme) => Object.keys(theme)
        .filter(key => isString$1(newTheme[key]))
        .forEach(key => (theme[key] = newTheme[key]));
    const themeToString = (theme) => Object.keys(theme)
        .map(key => `--kderd-color-${kebabCase_1(key)}: var(--kderd-theme-${kebabCase_1(key)}, ${theme[key]});`)
        .join('');

    defineComponent('kderd-provider', {
        render: (_, ctx) => () => html `
      <style type="text/css">
        /* @import url(kdfont.css); */
        :host {
          --kderd-font-family: 'kdfont', Microsoft YaHei;
          font-size: ${SIZE_FONT}px;
          font-family: var(--kderd-font-family) !important;
          ${themeToString(ctx.value.theme)}
        }
      </style>
      <slot></slot>
    `,
    });
    const getkderdContext = (ctx) => getContext('kderd-provider', ctx);

    /**
     * @license
     * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    /**
     * Stores the StyleInfo object applied to a given AttributePart.
     * Used to unset existing values when a new StyleInfo object is applied.
     */
    const previousStylePropertyCache = new WeakMap();
    /**
     * A directive that applies CSS properties to an element.
     *
     * `styleMap` can only be used in the `style` attribute and must be the only
     * expression in the attribute. It takes the property names in the `styleInfo`
     * object and adds the property values as CSS properties. Property names with
     * dashes (`-`) are assumed to be valid CSS property names and set on the
     * element's style object using `setProperty()`. Names without dashes are
     * assumed to be camelCased JavaScript property names and set on the element's
     * style object using property assignment, allowing the style object to
     * translate JavaScript-style names to CSS property names.
     *
     * For example `styleMap({backgroundColor: 'red', 'border-top': '5px', '--size':
     * '0'})` sets the `background-color`, `border-top` and `--size` properties.
     *
     * @param styleInfo {StyleInfo}
     */
    const styleMap = directive((styleInfo) => (part) => {
        if (!(part instanceof AttributePart) || (part instanceof PropertyPart) ||
            part.committer.name !== 'style' || part.committer.parts.length > 1) {
            throw new Error('The `styleMap` directive must be used in the style attribute ' +
                'and must be the only part in the attribute.');
        }
        const { committer } = part;
        const { style } = committer.element;
        let previousStyleProperties = previousStylePropertyCache.get(part);
        if (previousStyleProperties === undefined) {
            // Write static styles once
            style.cssText = committer.strings.join(' ');
            previousStylePropertyCache.set(part, previousStyleProperties = new Set());
        }
        // Remove old properties that no longer exist in styleInfo
        // We use forEach() instead of for-of so that re don't require down-level
        // iteration.
        previousStyleProperties.forEach((name) => {
            if (!(name in styleInfo)) {
                previousStyleProperties.delete(name);
                if (name.indexOf('-') === -1) {
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    style[name] = null;
                }
                else {
                    style.removeProperty(name);
                }
            }
        });
        // Add or update properties
        for (const name in styleInfo) {
            previousStyleProperties.add(name);
            if (name.indexOf('-') === -1) {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                style[name] = styleInfo[name];
            }
            else {
                style.setProperty(name, styleInfo[name]);
            }
        }
    });

    /*!
     * Font Awesome Free 5.15.3 by @fontawesome - https://fontawesome.com
     * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
     */
    var faAngleDoubleDown = {
      prefix: 'fas',
      iconName: 'angle-double-down',
      icon: [320, 512, [], "f103", "M143 256.3L7 120.3c-9.4-9.4-9.4-24.6 0-33.9l22.6-22.6c9.4-9.4 24.6-9.4 33.9 0l96.4 96.4 96.4-96.4c9.4-9.4 24.6-9.4 33.9 0L313 86.3c9.4 9.4 9.4 24.6 0 33.9l-136 136c-9.4 9.5-24.6 9.5-34 .1zm34 192l136-136c9.4-9.4 9.4-24.6 0-33.9l-22.6-22.6c-9.4-9.4-24.6-9.4-33.9 0L160 352.1l-96.4-96.4c-9.4-9.4-24.6-9.4-33.9 0L7 278.3c-9.4 9.4-9.4 24.6 0 33.9l136 136c9.4 9.5 24.6 9.5 34 .1z"]
    };
    var faAngleDoubleRight = {
      prefix: 'fas',
      iconName: 'angle-double-right',
      icon: [448, 512, [], "f101", "M224.3 273l-136 136c-9.4 9.4-24.6 9.4-33.9 0l-22.6-22.6c-9.4-9.4-9.4-24.6 0-33.9l96.4-96.4-96.4-96.4c-9.4-9.4-9.4-24.6 0-33.9L54.3 103c9.4-9.4 24.6-9.4 33.9 0l136 136c9.5 9.4 9.5 24.6.1 34zm192-34l-136-136c-9.4-9.4-24.6-9.4-33.9 0l-22.6 22.6c-9.4 9.4-9.4 24.6 0 33.9l96.4 96.4-96.4 96.4c-9.4 9.4-9.4 24.6 0 33.9l22.6 22.6c9.4 9.4 24.6 9.4 33.9 0l136-136c9.4-9.2 9.4-24.4 0-33.8z"]
    };
    var faCheck = {
      prefix: 'fas',
      iconName: 'check',
      icon: [512, 512, [], "f00c", "M173.898 439.404l-166.4-166.4c-9.997-9.997-9.997-26.206 0-36.204l36.203-36.204c9.997-9.998 26.207-9.998 36.204 0L192 312.69 432.095 72.596c9.997-9.997 26.207-9.997 36.204 0l36.203 36.204c9.997 9.997 9.997 26.206 0 36.204l-294.4 294.401c-9.998 9.997-26.207 9.997-36.204-.001z"]
    };
    var faChevronRight = {
      prefix: 'fas',
      iconName: 'chevron-right',
      icon: [320, 512, [], "f054", "M285.476 272.971L91.132 467.314c-9.373 9.373-24.569 9.373-33.941 0l-22.667-22.667c-9.357-9.357-9.375-24.522-.04-33.901L188.505 256 34.484 101.255c-9.335-9.379-9.317-24.544.04-33.901l22.667-22.667c9.373-9.373 24.569-9.373 33.941 0L285.475 239.03c9.373 9.372 9.373 24.568.001 33.941z"]
    };
    var faCode = {
      prefix: 'fas',
      iconName: 'code',
      icon: [640, 512, [], "f121", "M278.9 511.5l-61-17.7c-6.4-1.8-10-8.5-8.2-14.9L346.2 8.7c1.8-6.4 8.5-10 14.9-8.2l61 17.7c6.4 1.8 10 8.5 8.2 14.9L293.8 503.3c-1.9 6.4-8.5 10.1-14.9 8.2zm-114-112.2l43.5-46.4c4.6-4.9 4.3-12.7-.8-17.2L117 256l90.6-79.7c5.1-4.5 5.5-12.3.8-17.2l-43.5-46.4c-4.5-4.8-12.1-5.1-17-.5L3.8 247.2c-5.1 4.7-5.1 12.8 0 17.5l144.1 135.1c4.9 4.6 12.5 4.4 17-.5zm327.2.6l144.1-135.1c5.1-4.7 5.1-12.8 0-17.5L492.1 112.1c-4.8-4.5-12.4-4.3-17 .5L431.6 159c-4.6 4.9-4.3 12.7.8 17.2L523 256l-90.6 79.7c-5.1 4.5-5.5 12.3-.8 17.2l43.5 46.4c4.5 4.9 12.1 5.1 17 .6z"]
    };
    var faCog = {
      prefix: 'fas',
      iconName: 'cog',
      icon: [512, 512, [], "f013", "M487.4 315.7l-42.6-24.6c4.3-23.2 4.3-47 0-70.2l42.6-24.6c4.9-2.8 7.1-8.6 5.5-14-11.1-35.6-30-67.8-54.7-94.6-3.8-4.1-10-5.1-14.8-2.3L380.8 110c-17.9-15.4-38.5-27.3-60.8-35.1V25.8c0-5.6-3.9-10.5-9.4-11.7-36.7-8.2-74.3-7.8-109.2 0-5.5 1.2-9.4 6.1-9.4 11.7V75c-22.2 7.9-42.8 19.8-60.8 35.1L88.7 85.5c-4.9-2.8-11-1.9-14.8 2.3-24.7 26.7-43.6 58.9-54.7 94.6-1.7 5.4.6 11.2 5.5 14L67.3 221c-4.3 23.2-4.3 47 0 70.2l-42.6 24.6c-4.9 2.8-7.1 8.6-5.5 14 11.1 35.6 30 67.8 54.7 94.6 3.8 4.1 10 5.1 14.8 2.3l42.6-24.6c17.9 15.4 38.5 27.3 60.8 35.1v49.2c0 5.6 3.9 10.5 9.4 11.7 36.7 8.2 74.3 7.8 109.2 0 5.5-1.2 9.4-6.1 9.4-11.7v-49.2c22.2-7.9 42.8-19.8 60.8-35.1l42.6 24.6c4.9 2.8 11 1.9 14.8-2.3 24.7-26.7 43.6-58.9 54.7-94.6 1.5-5.5-.7-11.3-5.6-14.1zM256 336c-44.1 0-80-35.9-80-80s35.9-80 80-80 80 35.9 80 80-35.9 80-80 80z"]
    };
    var faEye = {
      prefix: 'fas',
      iconName: 'eye',
      icon: [576, 512, [], "f06e", "M572.52 241.4C518.29 135.59 410.93 64 288 64S57.68 135.64 3.48 241.41a32.35 32.35 0 0 0 0 29.19C57.71 376.41 165.07 448 288 448s230.32-71.64 284.52-177.41a32.35 32.35 0 0 0 0-29.19zM288 400a144 144 0 1 1 144-144 143.93 143.93 0 0 1-144 144zm0-240a95.31 95.31 0 0 0-25.31 3.79 47.85 47.85 0 0 1-66.9 66.9A95.78 95.78 0 1 0 288 160z"]
    };
    var faFileCode = {
      prefix: 'fas',
      iconName: 'file-code',
      icon: [384, 512, [], "f1c9", "M384 121.941V128H256V0h6.059c6.365 0 12.47 2.529 16.971 7.029l97.941 97.941A24.005 24.005 0 0 1 384 121.941zM248 160c-13.2 0-24-10.8-24-24V0H24C10.745 0 0 10.745 0 24v464c0 13.255 10.745 24 24 24h336c13.255 0 24-10.745 24-24V160H248zM123.206 400.505a5.4 5.4 0 0 1-7.633.246l-64.866-60.812a5.4 5.4 0 0 1 0-7.879l64.866-60.812a5.4 5.4 0 0 1 7.633.246l19.579 20.885a5.4 5.4 0 0 1-.372 7.747L101.65 336l40.763 35.874a5.4 5.4 0 0 1 .372 7.747l-19.579 20.884zm51.295 50.479l-27.453-7.97a5.402 5.402 0 0 1-3.681-6.692l61.44-211.626a5.402 5.402 0 0 1 6.692-3.681l27.452 7.97a5.4 5.4 0 0 1 3.68 6.692l-61.44 211.626a5.397 5.397 0 0 1-6.69 3.681zm160.792-111.045l-64.866 60.812a5.4 5.4 0 0 1-7.633-.246l-19.58-20.885a5.4 5.4 0 0 1 .372-7.747L284.35 336l-40.763-35.874a5.4 5.4 0 0 1-.372-7.747l19.58-20.885a5.4 5.4 0 0 1 7.633-.246l64.866 60.812a5.4 5.4 0 0 1-.001 7.879z"]
    };
    var faFileExport = {
      prefix: 'fas',
      iconName: 'file-export',
      icon: [576, 512, [], "f56e", "M384 121.9c0-6.3-2.5-12.4-7-16.9L279.1 7c-4.5-4.5-10.6-7-17-7H256v128h128zM571 308l-95.7-96.4c-10.1-10.1-27.4-3-27.4 11.3V288h-64v64h64v65.2c0 14.3 17.3 21.4 27.4 11.3L571 332c6.6-6.6 6.6-17.4 0-24zm-379 28v-32c0-8.8 7.2-16 16-16h176V160H248c-13.2 0-24-10.8-24-24V0H24C10.7 0 0 10.7 0 24v464c0 13.3 10.7 24 24 24h336c13.3 0 24-10.7 24-24V352H208c-8.8 0-16-7.2-16-16z"]
    };
    var faFileImage = {
      prefix: 'fas',
      iconName: 'file-image',
      icon: [384, 512, [], "f1c5", "M384 121.941V128H256V0h6.059a24 24 0 0 1 16.97 7.029l97.941 97.941a24.002 24.002 0 0 1 7.03 16.971zM248 160c-13.2 0-24-10.8-24-24V0H24C10.745 0 0 10.745 0 24v464c0 13.255 10.745 24 24 24h336c13.255 0 24-10.745 24-24V160H248zm-135.455 16c26.51 0 48 21.49 48 48s-21.49 48-48 48-48-21.49-48-48 21.491-48 48-48zm208 240h-256l.485-48.485L104.545 328c4.686-4.686 11.799-4.201 16.485.485L160.545 368 264.06 264.485c4.686-4.686 12.284-4.686 16.971 0L320.545 304v112z"]
    };
    var faFileImport = {
      prefix: 'fas',
      iconName: 'file-import',
      icon: [512, 512, [], "f56f", "M16 288c-8.8 0-16 7.2-16 16v32c0 8.8 7.2 16 16 16h112v-64zm489-183L407.1 7c-4.5-4.5-10.6-7-17-7H384v128h128v-6.1c0-6.3-2.5-12.4-7-16.9zm-153 31V0H152c-13.3 0-24 10.7-24 24v264h128v-65.2c0-14.3 17.3-21.4 27.4-11.3L379 308c6.6 6.7 6.6 17.4 0 24l-95.7 96.4c-10.1 10.1-27.4 3-27.4-11.3V352H128v136c0 13.3 10.7 24 24 24h336c13.3 0 24-10.7 24-24V160H376c-13.2 0-24-10.8-24-24z"]
    };
    var faFilter = {
      prefix: 'fas',
      iconName: 'filter',
      icon: [512, 512, [], "f0b0", "M487.976 0H24.028C2.71 0-8.047 25.866 7.058 40.971L192 225.941V432c0 7.831 3.821 15.17 10.237 19.662l80 55.98C298.02 518.69 320 507.493 320 487.98V225.941l184.947-184.97C520.021 25.896 509.338 0 487.976 0z"]
    };
    var faFolder = {
      prefix: 'fas',
      iconName: 'folder',
      icon: [512, 512, [], "f07b", "M464 128H272l-64-64H48C21.49 64 0 85.49 0 112v288c0 26.51 21.49 48 48 48h416c26.51 0 48-21.49 48-48V176c0-26.51-21.49-48-48-48z"]
    };
    var faKey = {
      prefix: 'fas',
      iconName: 'key',
      icon: [512, 512, [], "f084", "M512 176.001C512 273.203 433.202 352 336 352c-11.22 0-22.19-1.062-32.827-3.069l-24.012 27.014A23.999 23.999 0 0 1 261.223 384H224v40c0 13.255-10.745 24-24 24h-40v40c0 13.255-10.745 24-24 24H24c-13.255 0-24-10.745-24-24v-78.059c0-6.365 2.529-12.47 7.029-16.971l161.802-161.802C163.108 213.814 160 195.271 160 176 160 78.798 238.797.001 335.999 0 433.488-.001 512 78.511 512 176.001zM336 128c0 26.51 21.49 48 48 48s48-21.49 48-48-21.49-48-48-48-48 21.49-48 48z"]
    };
    var faLink = {
      prefix: 'fas',
      iconName: 'link',
      icon: [512, 512, [], "f0c1", "M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"]
    };
    var faList = {
      prefix: 'fas',
      iconName: 'list',
      icon: [512, 512, [], "f03a", "M80 368H16a16 16 0 0 0-16 16v64a16 16 0 0 0 16 16h64a16 16 0 0 0 16-16v-64a16 16 0 0 0-16-16zm0-320H16A16 16 0 0 0 0 64v64a16 16 0 0 0 16 16h64a16 16 0 0 0 16-16V64a16 16 0 0 0-16-16zm0 160H16a16 16 0 0 0-16 16v64a16 16 0 0 0 16 16h64a16 16 0 0 0 16-16v-64a16 16 0 0 0-16-16zm416 176H176a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h320a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16zm0-320H176a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h320a16 16 0 0 0 16-16V80a16 16 0 0 0-16-16zm0 160H176a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h320a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16z"]
    };
    var faMousePointer = {
      prefix: 'fas',
      iconName: 'mouse-pointer',
      icon: [320, 512, [], "f245", "M302.189 329.126H196.105l55.831 135.993c3.889 9.428-.555 19.999-9.444 23.999l-49.165 21.427c-9.165 4-19.443-.571-23.332-9.714l-53.053-129.136-86.664 89.138C18.729 472.71 0 463.554 0 447.977V18.299C0 1.899 19.921-6.096 30.277 5.443l284.412 292.542c11.472 11.179 3.007 31.141-12.5 31.141z"]
    };
    var faPlus = {
      prefix: 'fas',
      iconName: 'plus',
      icon: [448, 512, [], "f067", "M416 208H272V64c0-17.67-14.33-32-32-32h-32c-17.67 0-32 14.33-32 32v144H32c-17.67 0-32 14.33-32 32v32c0 17.67 14.33 32 32 32h144v144c0 17.67 14.33 32 32 32h32c17.67 0 32-14.33 32-32V304h144c17.67 0 32-14.33 32-32v-32c0-17.67-14.33-32-32-32z"]
    };
    var faProjectDiagram = {
      prefix: 'fas',
      iconName: 'project-diagram',
      icon: [640, 512, [], "f542", "M384 320H256c-17.67 0-32 14.33-32 32v128c0 17.67 14.33 32 32 32h128c17.67 0 32-14.33 32-32V352c0-17.67-14.33-32-32-32zM192 32c0-17.67-14.33-32-32-32H32C14.33 0 0 14.33 0 32v128c0 17.67 14.33 32 32 32h95.72l73.16 128.04C211.98 300.98 232.4 288 256 288h.28L192 175.51V128h224V64H192V32zM608 0H480c-17.67 0-32 14.33-32 32v128c0 17.67 14.33 32 32 32h128c17.67 0 32-14.33 32-32V32c0-17.67-14.33-32-32-32z"]
    };
    var faQuestion = {
      prefix: 'fas',
      iconName: 'question',
      icon: [384, 512, [], "f128", "M202.021 0C122.202 0 70.503 32.703 29.914 91.026c-7.363 10.58-5.093 25.086 5.178 32.874l43.138 32.709c10.373 7.865 25.132 6.026 33.253-4.148 25.049-31.381 43.63-49.449 82.757-49.449 30.764 0 68.816 19.799 68.816 49.631 0 22.552-18.617 34.134-48.993 51.164-35.423 19.86-82.299 44.576-82.299 106.405V320c0 13.255 10.745 24 24 24h72.471c13.255 0 24-10.745 24-24v-5.773c0-42.86 125.268-44.645 125.268-160.627C377.504 66.256 286.902 0 202.021 0zM192 373.459c-38.196 0-69.271 31.075-69.271 69.271 0 38.195 31.075 69.27 69.271 69.27s69.271-31.075 69.271-69.271-31.075-69.27-69.271-69.27z"]
    };
    var faRedoAlt = {
      prefix: 'fas',
      iconName: 'redo-alt',
      icon: [512, 512, [], "f2f9", "M256.455 8c66.269.119 126.437 26.233 170.859 68.685l35.715-35.715C478.149 25.851 504 36.559 504 57.941V192c0 13.255-10.745 24-24 24H345.941c-21.382 0-32.09-25.851-16.971-40.971l41.75-41.75c-30.864-28.899-70.801-44.907-113.23-45.273-92.398-.798-170.283 73.977-169.484 169.442C88.764 348.009 162.184 424 256 424c41.127 0 79.997-14.678 110.629-41.556 4.743-4.161 11.906-3.908 16.368.553l39.662 39.662c4.872 4.872 4.631 12.815-.482 17.433C378.202 479.813 319.926 504 256 504 119.034 504 8.001 392.967 8 256.002 7.999 119.193 119.646 7.755 256.455 8z"]
    };
    var faSearch = {
      prefix: 'fas',
      iconName: 'search',
      icon: [512, 512, [], "f002", "M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"]
    };
    var faStickyNote = {
      prefix: 'fas',
      iconName: 'sticky-note',
      icon: [448, 512, [], "f249", "M312 320h136V56c0-13.3-10.7-24-24-24H24C10.7 32 0 42.7 0 56v400c0 13.3 10.7 24 24 24h264V344c0-13.2 10.8-24 24-24zm129 55l-98 98c-4.5 4.5-10.6 7-17 7h-6V352h128v6.1c0 6.3-2.5 12.4-7 16.9z"]
    };
    var faSyncAlt = {
      prefix: 'fas',
      iconName: 'sync-alt',
      icon: [512, 512, [], "f2f1", "M370.72 133.28C339.458 104.008 298.888 87.962 255.848 88c-77.458.068-144.328 53.178-162.791 126.85-1.344 5.363-6.122 9.15-11.651 9.15H24.103c-7.498 0-13.194-6.807-11.807-14.176C33.933 94.924 134.813 8 256 8c66.448 0 126.791 26.136 171.315 68.685L463.03 40.97C478.149 25.851 504 36.559 504 57.941V192c0 13.255-10.745 24-24 24H345.941c-21.382 0-32.09-25.851-16.971-40.971l41.75-41.749zM32 296h134.059c21.382 0 32.09 25.851 16.971 40.971l-41.75 41.75c31.262 29.273 71.835 45.319 114.876 45.28 77.418-.07 144.315-53.144 162.787-126.849 1.344-5.363 6.122-9.15 11.651-9.15h57.304c7.498 0 13.194 6.807 11.807 14.176C478.067 417.076 377.187 504 256 504c-66.448 0-126.791-26.136-171.315-68.685L48.97 471.03C33.851 486.149 8 475.441 8 454.059V320c0-13.255 10.745-24 24-24z"]
    };
    var faTable = {
      prefix: 'fas',
      iconName: 'table',
      icon: [512, 512, [], "f0ce", "M464 32H48C21.49 32 0 53.49 0 80v352c0 26.51 21.49 48 48 48h416c26.51 0 48-21.49 48-48V80c0-26.51-21.49-48-48-48zM224 416H64v-96h160v96zm0-160H64v-96h160v96zm224 160H288v-96h160v96zm0-160H288v-96h160v96z"]
    };
    var faTimes = {
      prefix: 'fas',
      iconName: 'times',
      icon: [352, 512, [], "f00d", "M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"]
    };
    var faUndoAlt = {
      prefix: 'fas',
      iconName: 'undo-alt',
      icon: [512, 512, [], "f2ea", "M255.545 8c-66.269.119-126.438 26.233-170.86 68.685L48.971 40.971C33.851 25.851 8 36.559 8 57.941V192c0 13.255 10.745 24 24 24h134.059c21.382 0 32.09-25.851 16.971-40.971l-41.75-41.75c30.864-28.899 70.801-44.907 113.23-45.273 92.398-.798 170.283 73.977 169.484 169.442C423.236 348.009 349.816 424 256 424c-41.127 0-79.997-14.678-110.63-41.556-4.743-4.161-11.906-3.908-16.368.553L89.34 422.659c-4.872 4.872-4.631 12.815.482 17.433C133.798 479.813 192.074 504 256 504c136.966 0 247.999-111.033 248-247.998C504.001 119.193 392.354 7.755 255.545 8z"]
    };

    // Material Design Icons v5.9.55
    var mdiCodeBrackets = "M15,4V6H18V18H15V20H20V4M4,4V20H9V18H6V6H9V4H4Z";
    var mdiCodeJson = "M5,3H7V5H5V10A2,2 0 0,1 3,12A2,2 0 0,1 5,14V19H7V21H5C3.93,20.73 3,20.1 3,19V15A2,2 0 0,0 1,13H0V11H1A2,2 0 0,0 3,9V5A2,2 0 0,1 5,3M19,3A2,2 0 0,1 21,5V9A2,2 0 0,0 23,11H24V13H23A2,2 0 0,0 21,15V19A2,2 0 0,1 19,21H17V19H19V14A2,2 0 0,1 21,12A2,2 0 0,1 19,10V5H17V3H19M12,15A1,1 0 0,1 13,16A1,1 0 0,1 12,17A1,1 0 0,1 11,16A1,1 0 0,1 12,15M8,15A1,1 0 0,1 9,16A1,1 0 0,1 8,17A1,1 0 0,1 7,16A1,1 0 0,1 8,15M16,15A1,1 0 0,1 17,16A1,1 0 0,1 16,17A1,1 0 0,1 15,16A1,1 0 0,1 16,15Z";
    var mdiDatabase = "M12,3C7.58,3 4,4.79 4,7C4,9.21 7.58,11 12,11C16.42,11 20,9.21 20,7C20,4.79 16.42,3 12,3M4,9V12C4,14.21 7.58,16 12,16C16.42,16 20,14.21 20,12V9C20,11.21 16.42,13 12,13C7.58,13 4,11.21 4,9M4,14V17C4,19.21 7.58,21 12,21C16.42,21 20,19.21 20,17V14C20,16.21 16.42,18 12,18C7.58,18 4,16.21 4,14Z";
    var mdiDatabaseExport = "M12,3C7.58,3 4,4.79 4,7C4,9.21 7.58,11 12,11C12.5,11 13,10.97 13.5,10.92V9.5H16.39L15.39,8.5L18.9,5C17.5,3.8 14.94,3 12,3M18.92,7.08L17.5,8.5L20,11H15V13H20L17.5,15.5L18.92,16.92L23.84,12M4,9V12C4,14.21 7.58,16 12,16C13.17,16 14.26,15.85 15.25,15.63L16.38,14.5H13.5V12.92C13,12.97 12.5,13 12,13C7.58,13 4,11.21 4,9M4,14V17C4,19.21 7.58,21 12,21C14.94,21 17.5,20.2 18.9,19L17,17.1C15.61,17.66 13.9,18 12,18C7.58,18 4,16.21 4,14Z";
    var mdiDatabaseImport = "M12,3C8.59,3 5.69,4.07 4.54,5.57L9.79,10.82C10.5,10.93 11.22,11 12,11C16.42,11 20,9.21 20,7C20,4.79 16.42,3 12,3M3.92,7.08L2.5,8.5L5,11H0V13H5L2.5,15.5L3.92,16.92L8.84,12M20,9C20,11.21 16.42,13 12,13C11.34,13 10.7,12.95 10.09,12.87L7.62,15.34C8.88,15.75 10.38,16 12,16C16.42,16 20,14.21 20,12M20,14C20,16.21 16.42,18 12,18C9.72,18 7.67,17.5 6.21,16.75L4.53,18.43C5.68,19.93 8.59,21 12,21C16.42,21 20,19.21 20,17";
    var mdiFormatLetterCase = "M20.06,18C20,17.83 19.91,17.54 19.86,17.11C19.19,17.81 18.38,18.16 17.45,18.16C16.62,18.16 15.93,17.92 15.4,17.45C14.87,17 14.6,16.39 14.6,15.66C14.6,14.78 14.93,14.1 15.6,13.61C16.27,13.12 17.21,12.88 18.43,12.88H19.83V12.24C19.83,11.75 19.68,11.36 19.38,11.07C19.08,10.78 18.63,10.64 18.05,10.64C17.53,10.64 17.1,10.76 16.75,11C16.4,11.25 16.23,11.54 16.23,11.89H14.77C14.77,11.46 14.92,11.05 15.22,10.65C15.5,10.25 15.93,9.94 16.44,9.71C16.95,9.5 17.5,9.36 18.13,9.36C19.11,9.36 19.87,9.6 20.42,10.09C20.97,10.58 21.26,11.25 21.28,12.11V16C21.28,16.8 21.38,17.42 21.58,17.88V18H20.06M17.66,16.88C18.11,16.88 18.54,16.77 18.95,16.56C19.35,16.35 19.65,16.07 19.83,15.73V14.16H18.7C16.93,14.16 16.04,14.63 16.04,15.57C16.04,16 16.19,16.3 16.5,16.53C16.8,16.76 17.18,16.88 17.66,16.88M5.46,13.71H9.53L7.5,8.29L5.46,13.71M6.64,6H8.36L13.07,18H11.14L10.17,15.43H4.82L3.86,18H1.93L6.64,6Z";
    var mdiPalette = "M17.5,12A1.5,1.5 0 0,1 16,10.5A1.5,1.5 0 0,1 17.5,9A1.5,1.5 0 0,1 19,10.5A1.5,1.5 0 0,1 17.5,12M14.5,8A1.5,1.5 0 0,1 13,6.5A1.5,1.5 0 0,1 14.5,5A1.5,1.5 0 0,1 16,6.5A1.5,1.5 0 0,1 14.5,8M9.5,8A1.5,1.5 0 0,1 8,6.5A1.5,1.5 0 0,1 9.5,5A1.5,1.5 0 0,1 11,6.5A1.5,1.5 0 0,1 9.5,8M6.5,12A1.5,1.5 0 0,1 5,10.5A1.5,1.5 0 0,1 6.5,9A1.5,1.5 0 0,1 8,10.5A1.5,1.5 0 0,1 6.5,12M12,3A9,9 0 0,0 3,12A9,9 0 0,0 12,21A1.5,1.5 0 0,0 13.5,19.5C13.5,19.11 13.35,18.76 13.11,18.5C12.88,18.23 12.73,17.88 12.73,17.5A1.5,1.5 0 0,1 14.23,16H16A5,5 0 0,0 21,11C21,6.58 16.97,3 12,3Z";
    var mdiTableCog = "M3 3H17C18.11 3 19 3.9 19 5V12.08C17.45 11.82 15.92 12.18 14.68 13H11V17H12.08C11.97 17.68 11.97 18.35 12.08 19H3C1.9 19 1 18.11 1 17V5C1 3.9 1.9 3 3 3M3 7V11H9V7H3M11 7V11H17V7H11M3 13V17H9V13H3M22.78 19.32L21.71 18.5C21.73 18.33 21.75 18.17 21.75 18S21.74 17.67 21.71 17.5L22.77 16.68C22.86 16.6 22.89 16.47 22.83 16.36L21.83 14.63C21.77 14.5 21.64 14.5 21.5 14.5L20.28 15C20 14.82 19.74 14.65 19.43 14.53L19.24 13.21C19.23 13.09 19.12 13 19 13H17C16.88 13 16.77 13.09 16.75 13.21L16.56 14.53C16.26 14.66 15.97 14.82 15.71 15L14.47 14.5C14.36 14.5 14.23 14.5 14.16 14.63L13.16 16.36C13.1 16.47 13.12 16.6 13.22 16.68L14.28 17.5C14.26 17.67 14.25 17.83 14.25 18S14.26 18.33 14.28 18.5L13.22 19.32C13.13 19.4 13.1 19.53 13.16 19.64L14.16 21.37C14.22 21.5 14.35 21.5 14.47 21.5L15.71 21C15.97 21.18 16.25 21.35 16.56 21.47L16.75 22.79C16.77 22.91 16.87 23 17 23H19C19.12 23 19.23 22.91 19.25 22.79L19.44 21.47C19.74 21.34 20 21.18 20.28 21L21.5 21.5C21.64 21.5 21.77 21.5 21.84 21.37L22.84 19.64C22.9 19.53 22.87 19.4 22.78 19.32M18 19.5C17.17 19.5 16.5 18.83 16.5 18S17.18 16.5 18 16.5 19.5 17.17 19.5 18 18.84 19.5 18 19.5Z";
    var mdiVectorLine = "M15,3V7.59L7.59,15H3V21H9V16.42L16.42,9H21V3M17,5H19V7H17M5,17H7V19H5";
    var mdiXml = "M12.89,3L14.85,3.4L11.11,21L9.15,20.6L12.89,3M19.59,12L16,8.41V5.58L22.42,12L16,18.41V15.58L19.59,12M1.58,12L8,5.58V8.41L4.41,12L8,15.58V18.41L1.58,12Z";

    const createMDI = (name, icon) => ({
        prefix: 'mdi',
        iconName: name,
        icon: [24, 24, , , icon],
    });
    const icons = [
        faKey,
        faFolder,
        faTable,
        faStickyNote,
        faPlus,
        faTimes,
        faChevronRight,
        faCheck,
        faList,
        faRedoAlt,
        faUndoAlt,
        faSearch,
        faFilter,
        faQuestion,
        faProjectDiagram,
        faFileImage,
        faFileExport,
        faEye,
        faFileImport,
        faFileCode,
        faCog,
        faMousePointer,
        faCode,
        faSyncAlt,
        faLink,
        faAngleDoubleDown,
        faAngleDoubleRight,
        createMDI('vector-line', mdiVectorLine),
        createMDI('code-json', mdiCodeJson),
        createMDI('database', mdiDatabase),
        createMDI('database-import', mdiDatabaseImport),
        createMDI('database-export', mdiDatabaseExport),
        createMDI('palette', mdiPalette),
        createMDI('format-letter-case', mdiFormatLetterCase),
        createMDI('table-cog', mdiTableCog),
        createMDI('code-brackets', mdiCodeBrackets),
        createMDI('xml', mdiXml),
    ];
    const getIcon = (prefix, iconName) => icons.find(icon => icon.prefix === prefix && icon.iconName === iconName);
    const addIcon = (...newIcons) => icons.push(...newIcons);
    const base64Icons = {
        ZeroOneN: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyhpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTM4IDc5LjE1OTgyNCwgMjAxNi8wOS8xNC0wMTowOTowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTcgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6Q0RFRDI1RjI0ODY0MTFFN0JEQTA4NTA5QjY4NEI4MzAiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6Q0RFRDI1RjM0ODY0MTFFN0JEQTA4NTA5QjY4NEI4MzAiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpCQTE2QzQzRDQ4NjQxMUU3QkRBMDg1MDlCNjg0QjgzMCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpCQTE2QzQzRTQ4NjQxMUU3QkRBMDg1MDlCNjg0QjgzMCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PnTT5ywAAAJMSURBVHja7Fc9T2JBFB3MZq1IqLSgsRM6G6TcAmK7VNoRK4yBxE6XP/CsNxBohc6G5w+AoCU0aEWpBfAD4AeM55AZMjvvg2dClsRwkxOeb+7ce+6dmTPPmJRSbNP2xJZtR2DrBH6k0+ndEkSxBHAD9AGpMAJc4Lfh1zDGn4GLgHglNb8kqANhSKVSTiaTkY7jyMFgILWNx2PZ7XZluVyW8BkBJWA1PhwO+f7ZinUO9DmH8xl3XfIGnefzuQwzBsvlcjKIAH4PWAh9zCLq9Xp48mq16knGwASTmkaShULBQ0B1ZlSr1TyFtFqtwOS3xWLxH2eyZctUUOKVFTGRtslk4iHAODZZ/k2yLDKIwLsZjJ2gM3Bo+V0wieu6vsvCCu0ucS+RPHC1vId8kp+YrWRwvHsIWaosO7Nun3DDqn1yD+zr+RQiz3WYz+dXz6iCP82g84lKB4jxF0Rv0G7P+Gw2E6ha9Ho9/eoPsRJAucbUzl53Wi79NmwU25QSJuLx+ObugkqlInD+l8+oTsAny1aHxDlKJpOBgzhBot1ui8Vi4R3cwCY8jbIJeap4JOHvAmd6flDQj+l06ncMD/yktdPp+AoW59nEeBqUnjjAzyACd7YQUcnUxL7CyJZWk7QWIs6xdcLQg6cvSzETEl+Q4iyXkAWZBHU3/stlpLvKpaWkm0sb5Tq+19exqfvWdbyU1gjX8SGLIlnKNJ9jPGYRP0gugQLwS717Az6AB+DJ+CC5Vs8vSkEffeIdK79mVALf95swtvvXbEdg2wQ+BRgAvLABcxKvek4AAAAASUVORK5CYII=',
        ZeroOne: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyhpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTM4IDc5LjE1OTgyNCwgMjAxNi8wOS8xNC0wMTowOTowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTcgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6QkExNkM0M0I0ODY0MTFFN0JEQTA4NTA5QjY4NEI4MzAiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6QkExNkM0M0M0ODY0MTFFN0JEQTA4NTA5QjY4NEI4MzAiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpCQTE2QzQzOTQ4NjQxMUU3QkRBMDg1MDlCNjg0QjgzMCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpCQTE2QzQzQTQ4NjQxMUU3QkRBMDg1MDlCNjg0QjgzMCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PomEhhsAAAKSSURBVHja7FexbhpBED0ipFRI7ixBQwlV0nCUWKJIydEkFSRpHCGQ0iXgBqfBbQrAShXzA4BLJJCdEip3UDoSUFvwAZv30B5a1ncHBiSk2CONdrU3O/N2dt6w+IQQxiHllXFgeQFwcAD+aDT6zDPwBNsjaAoaVtbuoNcee46hOSi5/hd6pRv41vUBXJFJJ4FA4FMymTRCodDy22g0Mnq93gOml8Ph8Mxhb71QKOQYYzqdGq1W6zPsVkHwo5tGIpFvsVhMNJtN4Saz2UwUi0UB299QU9u/tBsMBrS51WN4BrcsS4zHY7GJEKQOYmsAMIzz5GrwyWQiSqWSwDXQkchms6LRaCwyoIPYB4Ar3NdyM+cEhPXv0LC0OYH+ZJZUEASG9fdbA2AAnlI9uQwedwF7waC29Pt92t5sCoCN6FzSZCmsdluq1aoxn8+LqN6+E0uwXoKPKNiQ4j7TNA0w5gRLZRdWraz7QZOyTkU6saXb7XL4taZH3IGSKRs4asVA5s5Vg2AwaOTz+QSmCZ2GniLTuI6uFpyLbcRfq9UeHYcZwL0v5mw8SFsYqb73yMBb9Tel3W4zA4s5gC1G2Yget2Lc8Q99MZ1Ol20AmLMOTjE9c7nT1xgstW4qlQrrhn7LNgACgp8/mN56dkKk84hVb1OLo+T+qUv66wi4QlnSeNc+cAG0y81IvyDfZaf7CE1Av5JubE6qSLDxXQEc05ib9HbLvp/JZARPTc6rQjDMyL5+Cz7wKkDDjapZD74zAOngHbRN57wGJyFAmfa6w/71ndCruyBoB0MHlf4FxZUDJd+o7wF8Z7Vfy/dAx8HFJWies1ng+CABqqe8oMIOL6KHDV5ElPt9APj/HqW+l/+Gzx7APwEGACfjkeXK58xsAAAAAElFTkSuQmCC',
        ZeroN: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyhpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTM4IDc5LjE1OTgyNCwgMjAxNi8wOS8xNC0wMTowOTowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTcgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NDc5MkNFMEM0ODY0MTFFN0JEQTA4NTA5QjY4NEI4MzAiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NDc5MkNFMEQ0ODY0MTFFN0JEQTA4NTA5QjY4NEI4MzAiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo0NzkyQ0UwQTQ4NjQxMUU3QkRBMDg1MDlCNjg0QjgzMCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo0NzkyQ0UwQjQ4NjQxMUU3QkRBMDg1MDlCNjg0QjgzMCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PpR0ImIAAALlSURBVHja7Fe/jxJBGF0MyVUk2HgJFJ6NQqUNWEoCkfKWxusozxBI7Eiw8ardKy/hxyVWQqcF8AdA9Eqg8DqwuwJI7Aj8AeN7OEuGhd09tCBRvuTLzA4z37z53rxvF58QQtunPdD2bAcA/mg0+p9nYMf5Qfhz5fnmbwH47iND0PQaTS4QCOiRSGQ1PhgMZmja8OvhcNi/z4aIdc5Ycs1HjQCcHJu9hH/KZrOi0+kIu83nc9FsNkUymRSYZ3jEegqv6bousLHI5/NcU3RbkIa3W62W8DICKZVKDFhziFWMxWKiXq+v1ozHY8Exv0OajpmmSqVyitOtxrvdrjYajZZ90KGlUiktFAot+4ZhcDiHtTOc8L1KHWLoAKiFw+FVrOl0+rvjgNjA5msnJA3MCPxC+hX8DhuvzZN0kDqDfTt1nCPT/w1+tm3zIFPDidYC8oZxc8vcI6ZdBUHKMPadY1YMy0gBY6uxfHhIMBEKAw+BvIUMLB+q1aqG/iXSWnKg6wjND9DzmHQsFgttMploqlpIm2maWr/fv8bj5zUZMrV2KWYymaXTyDMCPgGAOxdpXRQKhQ9I7cZv2FSzDrPVvG44TiLc5CWp0Mnrn5gfxWQDFG8r02nddpwwiAzMXOrLC6d3CtNPWhxLMSjYKKcYe0XZ0OLxOOVHOX1xA6Bybj8MKWg0GjdOFNjTeUL5WNbr9UjDV3jcIf3nVIllrHK8V2xVYxypphr8kbXeidO2ql+WWwnijQrU0rq6mdT4W/gta4ldiuVy2ZJi0Q1AmoHVxTyBDL50/m7XOkETvIxxTL1zHpSwBoJlWBa2mtvNNpky+wmcjJvIk6Vtcc5Y9QjeHovxveRlbiun9tLKVFul1S2W+kJiywx4fg9AXmm+UDD5lIqg3HizwftSYgBHmV1izhXGfnrEeobmHeLkuB7rIj4n+WyTGjwh2xP4rXR+kMx2/BBKyLWzXQD8mx+lvsNfswOAfQP4JcAAK/At0HQvwB8AAAAASUVORK5CYII=',
        OneOnly: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyhpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTM4IDc5LjE1OTgyNCwgMjAxNi8wOS8xNC0wMTowOTowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTcgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6QUJCNTBCRDA0ODY0MTFFN0JEQTA4NTA5QjY4NEI4MzAiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6QkExNkM0MzQ0ODY0MTFFN0JEQTA4NTA5QjY4NEI4MzAiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpBQkI1MEJDRTQ4NjQxMUU3QkRBMDg1MDlCNjg0QjgzMCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpBQkI1MEJDRjQ4NjQxMUU3QkRBMDg1MDlCNjg0QjgzMCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pur5d4QAAAE1SURBVHjaYvz//z/DQAImhgEGow4YcAewaGpqjvAQoJI5CUAsD2VPB+JXULY4EGcCMSivPwTiBRgOuH79OkU2A6MwITAwcL6UlBSYP3XqVHGgmVlQufqcnJxMUFnz7NkzhvXr1zMA5VAdAZKkBGtoaBw4derUfxgA8v8jycHFQWpAatH1j2bDUQeACqIGaDahGgClfmLlWIDZpJ7SKhmWBUEgOzsbRDVgUwOUswcy7ZHFGf8PcIOABVhwUGwIsCBiQCqIUOSgIQIviNABI7BwaKDQfodFixbZm5qawuIYRDVC5ephJe3p06cZ4uLiDgKZB0ZLwtGCaNg1SBYAs5c9MJExIDVI4GxgtgQ1SBiePn3KgK1BAsqG1GoRKSA54CVaiwgEHtDSAUM3DTCO9g1HvAMAAgwAvvwYPnW1JuQAAAAASUVORK5CYII=',
        OneN: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyhpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTM4IDc5LjE1OTgyNCwgMjAxNi8wOS8xNC0wMTowOTowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTcgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6QkExNkM0Mzc0ODY0MTFFN0JEQTA4NTA5QjY4NEI4MzAiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6QkExNkM0Mzg0ODY0MTFFN0JEQTA4NTA5QjY4NEI4MzAiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpCQTE2QzQzNTQ4NjQxMUU3QkRBMDg1MDlCNjg0QjgzMCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpCQTE2QzQzNjQ4NjQxMUU3QkRBMDg1MDlCNjg0QjgzMCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pt+BFx8AAAIISURBVHja7Fc9TwJBEF0MLYkdBgot4QdwLSaQSAmNdkCrR61CI9Ud1oCUIB0NYElBtJU/QIkmQKIVgcpqfXPekQNBYu7WM4FJJvs1x87Ovnk7uDjnzEnZYw7LzgHHHXAFAoHtjoDbpt9JQw/1fgX6vsH+CDohdVnlgWAwmE4kElWfz6eNy+Vypd/vX6yx9aK58fv959PplM1mswNGDlhRYOip1+txQzDma+wuoYNSqaTZUYvxnXAHMJag1WQyyYfDITdLJBLhbpEAQ8gVj8eThTBc03weoWeqqrLRaFQREgHoKfQRG3Pc9cKpW60WD4VCZKPS90IiAJA1FEVhkiTN58bjMaNIwNl7yhQA9VlLQ4Qpj9a2J1GWZZbJZBbmkBkMoHtFt6pPxbBvTGNCHZWWNqX7xalXriHkdNfrqZg7XBC4KTxWhSJgENGy0Onb7faPj1He4v7H9Xo9DGRrg1QqpaWY2SEAj+Vyua+0W6ZpQWn4YjCeWYrFIq0NiBWN70U54CWajcfj3LxGQmxIrEjsSCwplIrRP6N1cMI3Qmo2mxohCa0HQDYNNCfASAG8z7rd7nwtGo3+TUECJz6gWfB/DAT1QCAlViSgYq5gBxXXQDZhQrqpIFnlSAdNBwx4BWwUsPk15m7tqgnTepVjOPC2wX5fr4hse4xqv7Sf/J+yfPffcOsd+BRgAOvawAWTC+PMAAAAAElFTkSuQmCC',
        One: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyhpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTM4IDc5LjE1OTgyNCwgMjAxNi8wOS8xNC0wMTowOTowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTcgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6QUJCNTBCQ0M0ODY0MTFFN0JEQTA4NTA5QjY4NEI4MzAiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6QUJCNTBCQ0Q0ODY0MTFFN0JEQTA4NTA5QjY4NEI4MzAiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpBQkI1MEJDQTQ4NjQxMUU3QkRBMDg1MDlCNjg0QjgzMCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpBQkI1MEJDQjQ4NjQxMUU3QkRBMDg1MDlCNjg0QjgzMCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PnOhfCQAAADcSURBVHjaYvz//z/DQAImhgEGow4YcAewaGpqjvAQoJI5CUAsD2VPB+JXxGpkpLQcAEZhQmBg4HwpKSkwf+rUqdOvX7+eRbQBIAdQgjU0NA6cOnXqPwwA+f9J0T+aDUcdACqIGkBpkZqGAs2sJzobTpky5T+lWRGYDRmkpaXBbKB5JOll/D/ADQIWYMFBsSGgEEAqiEgLAWDB0UCh/Q6LFi2yNzU1hcU/iGocLQlHC6IR1SBZsH79entgQmRAapCQlA2p1SJSQHLAS3o3yRYM2TTAONo3HPEOAAgwAJh583IRUllDAAAAAElFTkSuQmCC',
        N: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyhpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTM4IDc5LjE1OTgyNCwgMjAxNi8wOS8xNC0wMTowOTowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTcgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NDc5MkNFMDg0ODY0MTFFN0JEQTA4NTA5QjY4NEI4MzAiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NDc5MkNFMDk0ODY0MTFFN0JEQTA4NTA5QjY4NEI4MzAiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDozNDQwRjc3NTQ4M0MxMUU3QkRBMDg1MDlCNjg0QjgzMCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDozNDQwRjc3NjQ4M0MxMUU3QkRBMDg1MDlCNjg0QjgzMCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PkbQDKwAAAGjSURBVHja7Jcxb4JQEMefLl272cjSUbYu0g+gSVemdpPZwKzRRSf4AGg70k8AfACTdqx+ibYJLp2MfoDr/wg0vJp2Al6TeskFeQ+4e/fufvdsEJFQKU2hWE4OKHeg0el0TlugQi6h5+kW1MkBXddbuMw0TRvu93txOBwumjUaH+Hy4jjOcLVaCcuyeHgmOAJVKpLcgAaDwYCSJKGi9Hq9yo273W6XwjCUDCP8NJlMCPP3VRm+hT6xETZWlCiKiJ3CvJfmX8mGW7wqDu16vZYMb7db4m3A/CP0On+HQTRHMpRVCiaS7Mq2bWlwuVyKxWLxjp/BEQkxQWWVYr/fF9/JipALrP5nFJPiA0EagbI+BsAI0zSlMV59HMe/NqN5mYg1DMPyPE+02+2vwc1mI6bTKTvzgNsP6Y0KSnAMfctySxLf97kKXqGj/PmqOJCWI7aDsHrJCaZhVo4BU7JqEt5Bn13XPQIS05GBVEcvOGPqsTE0IQnHtThQcOQGGnP4mYpZL/Bqc6CYpFkvGOcoVsEfPg3tVB7Jdn/nWH76b/jvHfgUYADeZNmzPgOYQQAAAABJRU5ErkJggg==',
    };
    const getBase64Icon = (relationshipType) => base64Icons[relationshipType];

    const SIZE = 24;
    const SIZE_REM = 1.5;
    defineComponent('kderd-icon', {
        observedProps: [
            {
                name: 'prefix',
                default: 'fas',
            },
            {
                name: 'name',
                default: '',
            },
            {
                name: 'size',
                type: Number,
                default: SIZE,
            },
            {
                name: 'color',
                default: null,
            },
        ],
        shadow: false,
        styleMap: {
            display: 'inline-flex',
            height: '100%',
            alignItems: 'center',
        },
        render: (props, ctx) => () => {
            const icon = getIcon(props.prefix, props.name);
            if (!icon)
                return svg ``;
            const [width, height, , , d] = icon.icon;
            const rem = SIZE_REM * (props.size / SIZE);
            return svg `
      <svg
        class="kderd-icon"
        style=${styleMap({
            width: `${rem}rem`,
            height: `${rem}rem`,
        })} 
        viewBox="0 0 ${width} ${height}"
      >
        ${props.color
            ? svg `<path d=${d} fill=${props.color}></path>`
            : svg `<path d=${d}></path>`}
      </svg>
    `;
        },
    });

    /**
     * @license
     * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    // IE11 doesn't support classList on SVG elements, so we emulate it with a Set
    class ClassList {
        constructor(element) {
            this.classes = new Set();
            this.changed = false;
            this.element = element;
            const classList = (element.getAttribute('class') || '').split(/\s+/);
            for (const cls of classList) {
                this.classes.add(cls);
            }
        }
        add(cls) {
            this.classes.add(cls);
            this.changed = true;
        }
        remove(cls) {
            this.classes.delete(cls);
            this.changed = true;
        }
        commit() {
            if (this.changed) {
                let classString = '';
                this.classes.forEach((cls) => classString += cls + ' ');
                this.element.setAttribute('class', classString);
            }
        }
    }
    /**
     * Stores the ClassInfo object applied to a given AttributePart.
     * Used to unset existing values when a new ClassInfo object is applied.
     */
    const previousClassesCache = new WeakMap();
    /**
     * A directive that applies CSS classes. This must be used in the `class`
     * attribute and must be the only part used in the attribute. It takes each
     * property in the `classInfo` argument and adds the property name to the
     * element's `class` if the property value is truthy; if the property value is
     * falsey, the property name is removed from the element's `class`. For example
     * `{foo: bar}` applies the class `foo` if the value of `bar` is truthy.
     * @param classInfo {ClassInfo}
     */
    const classMap = directive((classInfo) => (part) => {
        if (!(part instanceof AttributePart) || (part instanceof PropertyPart) ||
            part.committer.name !== 'class' || part.committer.parts.length > 1) {
            throw new Error('The `classMap` directive must be used in the `class` attribute ' +
                'and must be the only part in the attribute.');
        }
        const { committer } = part;
        const { element } = committer;
        let previousClasses = previousClassesCache.get(part);
        if (previousClasses === undefined) {
            // Write static classes once
            // Use setAttribute() because className isn't a string on SVG elements
            element.setAttribute('class', committer.strings.join(' '));
            previousClassesCache.set(part, previousClasses = new Set());
        }
        const classList = (element.classList || new ClassList(element));
        // Remove old classes that no longer apply
        // We use forEach() instead of for-of so that re don't require down-level
        // iteration.
        previousClasses.forEach((name) => {
            if (!(name in classInfo)) {
                classList.remove(name);
                previousClasses.delete(name);
            }
        });
        // Add or remove classes based on their classMap value
        for (const name in classInfo) {
            const value = classInfo[name];
            if (value != previousClasses.has(name)) {
                // We explicitly want a loose truthy check of `value` because it seems
                // more convenient that '' and 0 are skipped.
                if (value) {
                    classList.add(name);
                    previousClasses.add(name);
                }
                else {
                    classList.remove(name);
                    previousClasses.delete(name);
                }
            }
        }
        if (typeof classList.commit === 'function') {
            classList.commit();
        }
    });

    function useContext(ctx) {
        const ref = { value: null };
        beforeMount(() => (ref.value = getkderdContext(ctx)));
        return ref;
    }

    const css = (arr, ...values) => arr
        .reduce((acc, cur, i) => { var _a; return acc.concat(cur, `${(_a = values[i]) !== null && _a !== void 0 ? _a : ''}`); }, [])
        .join('');

    const SashStyle = css `
  .kderd-sash {
    position: absolute;
  }
  .kderd-sash.vertical {
    width: ${SIZE_SASH}px;
    height: 100%;
    cursor: ew-resize;
  }
  .kderd-sash.horizontal {
    width: 100%;
    height: ${SIZE_SASH}px;
    cursor: ns-resize;
  }
  .kderd-sash.edge {
    width: ${SIZE_SASH}px;
    height: ${SIZE_SASH}px;
  }
`;

    const classKeys = ['vertical', 'horizontal', 'edge'];
    const Sash = (props, ctx) => {
        const contextRef = useContext(ctx);
        const centerTop = () => props.top === 0 && !props.horizontal && !props.edge
            ? props.top
            : props.top - SIZE_SASH / 2;
        const centerLeft = () => props.left === 0 && !props.vertical && !props.edge
            ? props.left
            : props.left - SIZE_SASH / 2;
        const getClassMap = () => Object.assign({ 'kderd-sash': true }, classKeys.reduce((map, key) => {
            map[key] = props[key];
            return map;
        }, {}));
        const getStyleMap = () => ({
            top: `${centerTop()}px`,
            left: `${centerLeft()}px`,
            cursor: props.edge ? props.cursor : '',
        });
        const onMousedown = () => {
            const { drag$ } = contextRef.value.globalEvent;
            drag$.subscribe(move => {
                move.event.type === 'mousemove' && move.event.preventDefault();
                ctx.dispatchEvent(new CustomEvent('global-move', {
                    detail: {
                        movementX: move.movementX,
                        movementY: move.movementY,
                        x: move.x,
                        y: move.y,
                    },
                }));
            });
        };
        return () => html `
      <div
        class=${classMap(getClassMap())}
        style=${styleMap(getStyleMap())}
        @mousedown=${onMousedown}
      ></div>
    `;
    };
    defineComponent('kderd-sash', {
        observedProps: [
            {
                name: 'vertical',
                type: Boolean,
                default: false,
            },
            {
                name: 'horizontal',
                type: Boolean,
                default: false,
            },
            {
                name: 'edge',
                type: Boolean,
                default: false,
            },
            {
                name: 'cursor',
                default: 'default',
            },
            {
                name: 'top',
                type: Number,
                default: 0,
            },
            {
                name: 'left',
                type: Number,
                default: 0,
            },
        ],
        style: SashStyle,
        render: Sash,
    });

    var top = 'top';
    var bottom = 'bottom';
    var right = 'right';
    var left = 'left';
    var auto = 'auto';
    var basePlacements = [top, bottom, right, left];
    var start = 'start';
    var end = 'end';
    var clippingParents = 'clippingParents';
    var viewport = 'viewport';
    var popper = 'popper';
    var reference = 'reference';
    var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
      return acc.concat([placement + "-" + start, placement + "-" + end]);
    }, []);
    var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
      return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
    }, []); // modifiers that need to read the DOM

    var beforeRead = 'beforeRead';
    var read = 'read';
    var afterRead = 'afterRead'; // pure-logic modifiers

    var beforeMain = 'beforeMain';
    var main = 'main';
    var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

    var beforeWrite = 'beforeWrite';
    var write = 'write';
    var afterWrite = 'afterWrite';
    var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

    function getNodeName(element) {
      return element ? (element.nodeName || '').toLowerCase() : null;
    }

    function getWindow(node) {
      if (node == null) {
        return window;
      }

      if (node.toString() !== '[object Window]') {
        var ownerDocument = node.ownerDocument;
        return ownerDocument ? ownerDocument.defaultView || window : window;
      }

      return node;
    }

    function isElement$1(node) {
      var OwnElement = getWindow(node).Element;
      return node instanceof OwnElement || node instanceof Element;
    }

    function isHTMLElement(node) {
      var OwnElement = getWindow(node).HTMLElement;
      return node instanceof OwnElement || node instanceof HTMLElement;
    }

    function isShadowRoot(node) {
      // IE 11 has no ShadowRoot
      if (typeof ShadowRoot === 'undefined') {
        return false;
      }

      var OwnElement = getWindow(node).ShadowRoot;
      return node instanceof OwnElement || node instanceof ShadowRoot;
    }

    // and applies them to the HTMLElements such as popper and arrow

    function applyStyles(_ref) {
      var state = _ref.state;
      Object.keys(state.elements).forEach(function (name) {
        var style = state.styles[name] || {};
        var attributes = state.attributes[name] || {};
        var element = state.elements[name]; // arrow is optional + virtual elements

        if (!isHTMLElement(element) || !getNodeName(element)) {
          return;
        } // Flow doesn't support to extend this property, but it's the most
        // effective way to apply styles to an HTMLElement
        // $FlowFixMe[cannot-write]


        Object.assign(element.style, style);
        Object.keys(attributes).forEach(function (name) {
          var value = attributes[name];

          if (value === false) {
            element.removeAttribute(name);
          } else {
            element.setAttribute(name, value === true ? '' : value);
          }
        });
      });
    }

    function effect$2(_ref2) {
      var state = _ref2.state;
      var initialStyles = {
        popper: {
          position: state.options.strategy,
          left: '0',
          top: '0',
          margin: '0'
        },
        arrow: {
          position: 'absolute'
        },
        reference: {}
      };
      Object.assign(state.elements.popper.style, initialStyles.popper);
      state.styles = initialStyles;

      if (state.elements.arrow) {
        Object.assign(state.elements.arrow.style, initialStyles.arrow);
      }

      return function () {
        Object.keys(state.elements).forEach(function (name) {
          var element = state.elements[name];
          var attributes = state.attributes[name] || {};
          var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them

          var style = styleProperties.reduce(function (style, property) {
            style[property] = '';
            return style;
          }, {}); // arrow is optional + virtual elements

          if (!isHTMLElement(element) || !getNodeName(element)) {
            return;
          }

          Object.assign(element.style, style);
          Object.keys(attributes).forEach(function (attribute) {
            element.removeAttribute(attribute);
          });
        });
      };
    } // eslint-disable-next-line import/no-unused-modules


    var applyStyles$1 = {
      name: 'applyStyles',
      enabled: true,
      phase: 'write',
      fn: applyStyles,
      effect: effect$2,
      requires: ['computeStyles']
    };

    function getBasePlacement$1(placement) {
      return placement.split('-')[0];
    }

    function getBoundingClientRect(element) {
      var rect = element.getBoundingClientRect();
      return {
        width: rect.width,
        height: rect.height,
        top: rect.top,
        right: rect.right,
        bottom: rect.bottom,
        left: rect.left,
        x: rect.left,
        y: rect.top
      };
    }

    // means it doesn't take into account transforms.

    function getLayoutRect(element) {
      var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.
      // Fixes https://github.com/popperjs/popper-core/issues/1223

      var width = element.offsetWidth;
      var height = element.offsetHeight;

      if (Math.abs(clientRect.width - width) <= 1) {
        width = clientRect.width;
      }

      if (Math.abs(clientRect.height - height) <= 1) {
        height = clientRect.height;
      }

      return {
        x: element.offsetLeft,
        y: element.offsetTop,
        width: width,
        height: height
      };
    }

    function contains(parent, child) {
      var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method

      if (parent.contains(child)) {
        return true;
      } // then fallback to custom implementation with Shadow DOM support
      else if (rootNode && isShadowRoot(rootNode)) {
          var next = child;

          do {
            if (next && parent.isSameNode(next)) {
              return true;
            } // $FlowFixMe[prop-missing]: need a better way to handle this...


            next = next.parentNode || next.host;
          } while (next);
        } // Give up, the result is false


      return false;
    }

    function getComputedStyle(element) {
      return getWindow(element).getComputedStyle(element);
    }

    function isTableElement(element) {
      return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;
    }

    function getDocumentElement(element) {
      // $FlowFixMe[incompatible-return]: assume body is always available
      return ((isElement$1(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]
      element.document) || window.document).documentElement;
    }

    function getParentNode(element) {
      if (getNodeName(element) === 'html') {
        return element;
      }

      return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle
        // $FlowFixMe[incompatible-return]
        // $FlowFixMe[prop-missing]
        element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
        element.parentNode || ( // DOM Element detected
        isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
        // $FlowFixMe[incompatible-call]: HTMLElement is a Node
        getDocumentElement(element) // fallback

      );
    }

    function getTrueOffsetParent(element) {
      if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
      getComputedStyle(element).position === 'fixed') {
        return null;
      }

      return element.offsetParent;
    } // `.offsetParent` reports `null` for fixed elements, while absolute elements
    // return the containing block


    function getContainingBlock(element) {
      var isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') !== -1;
      var isIE = navigator.userAgent.indexOf('Trident') !== -1;

      if (isIE && isHTMLElement(element)) {
        // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
        var elementCss = getComputedStyle(element);

        if (elementCss.position === 'fixed') {
          return null;
        }
      }

      var currentNode = getParentNode(element);

      while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {
        var css = getComputedStyle(currentNode); // This is non-exhaustive but covers the most common CSS properties that
        // create a containing block.
        // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block

        if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {
          return currentNode;
        } else {
          currentNode = currentNode.parentNode;
        }
      }

      return null;
    } // Gets the closest ancestor positioned element. Handles some edge cases,
    // such as table ancestors and cross browser bugs.


    function getOffsetParent(element) {
      var window = getWindow(element);
      var offsetParent = getTrueOffsetParent(element);

      while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {
        offsetParent = getTrueOffsetParent(offsetParent);
      }

      if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static')) {
        return window;
      }

      return offsetParent || getContainingBlock(element) || window;
    }

    function getMainAxisFromPlacement(placement) {
      return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
    }

    var max = Math.max;
    var min = Math.min;
    var round$1 = Math.round;

    function within(min$1, value, max$1) {
      return max(min$1, min(value, max$1));
    }

    function getFreshSideObject() {
      return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      };
    }

    function mergePaddingObject(paddingObject) {
      return Object.assign({}, getFreshSideObject(), paddingObject);
    }

    function expandToHashMap(value, keys) {
      return keys.reduce(function (hashMap, key) {
        hashMap[key] = value;
        return hashMap;
      }, {});
    }

    var toPaddingObject = function toPaddingObject(padding, state) {
      padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {
        placement: state.placement
      })) : padding;
      return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
    };

    function arrow(_ref) {
      var _state$modifiersData$;

      var state = _ref.state,
          name = _ref.name,
          options = _ref.options;
      var arrowElement = state.elements.arrow;
      var popperOffsets = state.modifiersData.popperOffsets;
      var basePlacement = getBasePlacement$1(state.placement);
      var axis = getMainAxisFromPlacement(basePlacement);
      var isVertical = [left, right].indexOf(basePlacement) >= 0;
      var len = isVertical ? 'height' : 'width';

      if (!arrowElement || !popperOffsets) {
        return;
      }

      var paddingObject = toPaddingObject(options.padding, state);
      var arrowRect = getLayoutRect(arrowElement);
      var minProp = axis === 'y' ? top : left;
      var maxProp = axis === 'y' ? bottom : right;
      var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
      var startDiff = popperOffsets[axis] - state.rects.reference[axis];
      var arrowOffsetParent = getOffsetParent(arrowElement);
      var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
      var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
      // outside of the popper bounds

      var min = paddingObject[minProp];
      var max = clientSize - arrowRect[len] - paddingObject[maxProp];
      var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
      var offset = within(min, center, max); // Prevents breaking syntax highlighting...

      var axisProp = axis;
      state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
    }

    function effect$1(_ref2) {
      var state = _ref2.state,
          options = _ref2.options;
      var _options$element = options.element,
          arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;

      if (arrowElement == null) {
        return;
      } // CSS selector


      if (typeof arrowElement === 'string') {
        arrowElement = state.elements.popper.querySelector(arrowElement);

        if (!arrowElement) {
          return;
        }
      }

      if (!contains(state.elements.popper, arrowElement)) {

        return;
      }

      state.elements.arrow = arrowElement;
    } // eslint-disable-next-line import/no-unused-modules


    var arrow$1 = {
      name: 'arrow',
      enabled: true,
      phase: 'main',
      fn: arrow,
      effect: effect$1,
      requires: ['popperOffsets'],
      requiresIfExists: ['preventOverflow']
    };

    var unsetSides = {
      top: 'auto',
      right: 'auto',
      bottom: 'auto',
      left: 'auto'
    }; // Round the offsets to the nearest suitable subpixel based on the DPR.
    // Zooming can change the DPR, but it seems to report a value that will
    // cleanly divide the values into the appropriate subpixels.

    function roundOffsetsByDPR(_ref) {
      var x = _ref.x,
          y = _ref.y;
      var win = window;
      var dpr = win.devicePixelRatio || 1;
      return {
        x: round$1(round$1(x * dpr) / dpr) || 0,
        y: round$1(round$1(y * dpr) / dpr) || 0
      };
    }

    function mapToStyles(_ref2) {
      var _Object$assign2;

      var popper = _ref2.popper,
          popperRect = _ref2.popperRect,
          placement = _ref2.placement,
          offsets = _ref2.offsets,
          position = _ref2.position,
          gpuAcceleration = _ref2.gpuAcceleration,
          adaptive = _ref2.adaptive,
          roundOffsets = _ref2.roundOffsets;

      var _ref3 = roundOffsets === true ? roundOffsetsByDPR(offsets) : typeof roundOffsets === 'function' ? roundOffsets(offsets) : offsets,
          _ref3$x = _ref3.x,
          x = _ref3$x === void 0 ? 0 : _ref3$x,
          _ref3$y = _ref3.y,
          y = _ref3$y === void 0 ? 0 : _ref3$y;

      var hasX = offsets.hasOwnProperty('x');
      var hasY = offsets.hasOwnProperty('y');
      var sideX = left;
      var sideY = top;
      var win = window;

      if (adaptive) {
        var offsetParent = getOffsetParent(popper);
        var heightProp = 'clientHeight';
        var widthProp = 'clientWidth';

        if (offsetParent === getWindow(popper)) {
          offsetParent = getDocumentElement(popper);

          if (getComputedStyle(offsetParent).position !== 'static') {
            heightProp = 'scrollHeight';
            widthProp = 'scrollWidth';
          }
        } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it


        offsetParent = offsetParent;

        if (placement === top) {
          sideY = bottom; // $FlowFixMe[prop-missing]

          y -= offsetParent[heightProp] - popperRect.height;
          y *= gpuAcceleration ? 1 : -1;
        }

        if (placement === left) {
          sideX = right; // $FlowFixMe[prop-missing]

          x -= offsetParent[widthProp] - popperRect.width;
          x *= gpuAcceleration ? 1 : -1;
        }
      }

      var commonStyles = Object.assign({
        position: position
      }, adaptive && unsetSides);

      if (gpuAcceleration) {
        var _Object$assign;

        return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) < 2 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
      }

      return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
    }

    function computeStyles(_ref4) {
      var state = _ref4.state,
          options = _ref4.options;
      var _options$gpuAccelerat = options.gpuAcceleration,
          gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
          _options$adaptive = options.adaptive,
          adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
          _options$roundOffsets = options.roundOffsets,
          roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;

      var commonStyles = {
        placement: getBasePlacement$1(state.placement),
        popper: state.elements.popper,
        popperRect: state.rects.popper,
        gpuAcceleration: gpuAcceleration
      };

      if (state.modifiersData.popperOffsets != null) {
        state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
          offsets: state.modifiersData.popperOffsets,
          position: state.options.strategy,
          adaptive: adaptive,
          roundOffsets: roundOffsets
        })));
      }

      if (state.modifiersData.arrow != null) {
        state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
          offsets: state.modifiersData.arrow,
          position: 'absolute',
          adaptive: false,
          roundOffsets: roundOffsets
        })));
      }

      state.attributes.popper = Object.assign({}, state.attributes.popper, {
        'data-popper-placement': state.placement
      });
    } // eslint-disable-next-line import/no-unused-modules


    var computeStyles$1 = {
      name: 'computeStyles',
      enabled: true,
      phase: 'beforeWrite',
      fn: computeStyles,
      data: {}
    };

    var passive = {
      passive: true
    };

    function effect(_ref) {
      var state = _ref.state,
          instance = _ref.instance,
          options = _ref.options;
      var _options$scroll = options.scroll,
          scroll = _options$scroll === void 0 ? true : _options$scroll,
          _options$resize = options.resize,
          resize = _options$resize === void 0 ? true : _options$resize;
      var window = getWindow(state.elements.popper);
      var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);

      if (scroll) {
        scrollParents.forEach(function (scrollParent) {
          scrollParent.addEventListener('scroll', instance.update, passive);
        });
      }

      if (resize) {
        window.addEventListener('resize', instance.update, passive);
      }

      return function () {
        if (scroll) {
          scrollParents.forEach(function (scrollParent) {
            scrollParent.removeEventListener('scroll', instance.update, passive);
          });
        }

        if (resize) {
          window.removeEventListener('resize', instance.update, passive);
        }
      };
    } // eslint-disable-next-line import/no-unused-modules


    var eventListeners = {
      name: 'eventListeners',
      enabled: true,
      phase: 'write',
      fn: function fn() {},
      effect: effect,
      data: {}
    };

    var hash$1 = {
      left: 'right',
      right: 'left',
      bottom: 'top',
      top: 'bottom'
    };
    function getOppositePlacement(placement) {
      return placement.replace(/left|right|bottom|top/g, function (matched) {
        return hash$1[matched];
      });
    }

    var hash = {
      start: 'end',
      end: 'start'
    };
    function getOppositeVariationPlacement(placement) {
      return placement.replace(/start|end/g, function (matched) {
        return hash[matched];
      });
    }

    function getWindowScroll(node) {
      var win = getWindow(node);
      var scrollLeft = win.pageXOffset;
      var scrollTop = win.pageYOffset;
      return {
        scrollLeft: scrollLeft,
        scrollTop: scrollTop
      };
    }

    function getWindowScrollBarX(element) {
      // If <html> has a CSS width greater than the viewport, then this will be
      // incorrect for RTL.
      // Popper 1 is broken in this case and never had a bug report so let's assume
      // it's not an issue. I don't think anyone ever specifies width on <html>
      // anyway.
      // Browsers where the left scrollbar doesn't cause an issue report `0` for
      // this (e.g. Edge 2019, IE11, Safari)
      return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
    }

    function getViewportRect(element) {
      var win = getWindow(element);
      var html = getDocumentElement(element);
      var visualViewport = win.visualViewport;
      var width = html.clientWidth;
      var height = html.clientHeight;
      var x = 0;
      var y = 0; // NB: This isn't supported on iOS <= 12. If the keyboard is open, the popper
      // can be obscured underneath it.
      // Also, `html.clientHeight` adds the bottom bar height in Safari iOS, even
      // if it isn't open, so if this isn't available, the popper will be detected
      // to overflow the bottom of the screen too early.

      if (visualViewport) {
        width = visualViewport.width;
        height = visualViewport.height; // Uses Layout Viewport (like Chrome; Safari does not currently)
        // In Chrome, it returns a value very close to 0 (+/-) but contains rounding
        // errors due to floating point numbers, so we need to check precision.
        // Safari returns a number <= 0, usually < -1 when pinch-zoomed
        // Feature detection fails in mobile emulation mode in Chrome.
        // Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) <
        // 0.001
        // Fallback here: "Not Safari" userAgent

        if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
          x = visualViewport.offsetLeft;
          y = visualViewport.offsetTop;
        }
      }

      return {
        width: width,
        height: height,
        x: x + getWindowScrollBarX(element),
        y: y
      };
    }

    // of the `<html>` and `<body>` rect bounds if horizontally scrollable

    function getDocumentRect(element) {
      var _element$ownerDocumen;

      var html = getDocumentElement(element);
      var winScroll = getWindowScroll(element);
      var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
      var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
      var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
      var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
      var y = -winScroll.scrollTop;

      if (getComputedStyle(body || html).direction === 'rtl') {
        x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
      }

      return {
        width: width,
        height: height,
        x: x,
        y: y
      };
    }

    function isScrollParent(element) {
      // Firefox wants us to check `-x` and `-y` variations as well
      var _getComputedStyle = getComputedStyle(element),
          overflow = _getComputedStyle.overflow,
          overflowX = _getComputedStyle.overflowX,
          overflowY = _getComputedStyle.overflowY;

      return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
    }

    function getScrollParent(node) {
      if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {
        // $FlowFixMe[incompatible-return]: assume body is always available
        return node.ownerDocument.body;
      }

      if (isHTMLElement(node) && isScrollParent(node)) {
        return node;
      }

      return getScrollParent(getParentNode(node));
    }

    /*
    given a DOM element, return the list of all scroll parents, up the list of ancesors
    until we get to the top window object. This list is what we attach scroll listeners
    to, because if any of these parent elements scroll, we'll need to re-calculate the
    reference element's position.
    */

    function listScrollParents(element, list) {
      var _element$ownerDocumen;

      if (list === void 0) {
        list = [];
      }

      var scrollParent = getScrollParent(element);
      var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
      var win = getWindow(scrollParent);
      var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
      var updatedList = list.concat(target);
      return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
      updatedList.concat(listScrollParents(getParentNode(target)));
    }

    function rectToClientRect(rect) {
      return Object.assign({}, rect, {
        left: rect.x,
        top: rect.y,
        right: rect.x + rect.width,
        bottom: rect.y + rect.height
      });
    }

    function getInnerBoundingClientRect(element) {
      var rect = getBoundingClientRect(element);
      rect.top = rect.top + element.clientTop;
      rect.left = rect.left + element.clientLeft;
      rect.bottom = rect.top + element.clientHeight;
      rect.right = rect.left + element.clientWidth;
      rect.width = element.clientWidth;
      rect.height = element.clientHeight;
      rect.x = rect.left;
      rect.y = rect.top;
      return rect;
    }

    function getClientRectFromMixedType(element, clippingParent) {
      return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isHTMLElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
    } // A "clipping parent" is an overflowable container with the characteristic of
    // clipping (or hiding) overflowing elements with a position different from
    // `initial`


    function getClippingParents(element) {
      var clippingParents = listScrollParents(getParentNode(element));
      var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle(element).position) >= 0;
      var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;

      if (!isElement$1(clipperElement)) {
        return [];
      } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414


      return clippingParents.filter(function (clippingParent) {
        return isElement$1(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';
      });
    } // Gets the maximum area that the element is visible in due to any number of
    // clipping parents


    function getClippingRect(element, boundary, rootBoundary) {
      var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
      var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
      var firstClippingParent = clippingParents[0];
      var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
        var rect = getClientRectFromMixedType(element, clippingParent);
        accRect.top = max(rect.top, accRect.top);
        accRect.right = min(rect.right, accRect.right);
        accRect.bottom = min(rect.bottom, accRect.bottom);
        accRect.left = max(rect.left, accRect.left);
        return accRect;
      }, getClientRectFromMixedType(element, firstClippingParent));
      clippingRect.width = clippingRect.right - clippingRect.left;
      clippingRect.height = clippingRect.bottom - clippingRect.top;
      clippingRect.x = clippingRect.left;
      clippingRect.y = clippingRect.top;
      return clippingRect;
    }

    function getVariation(placement) {
      return placement.split('-')[1];
    }

    function computeOffsets(_ref) {
      var reference = _ref.reference,
          element = _ref.element,
          placement = _ref.placement;
      var basePlacement = placement ? getBasePlacement$1(placement) : null;
      var variation = placement ? getVariation(placement) : null;
      var commonX = reference.x + reference.width / 2 - element.width / 2;
      var commonY = reference.y + reference.height / 2 - element.height / 2;
      var offsets;

      switch (basePlacement) {
        case top:
          offsets = {
            x: commonX,
            y: reference.y - element.height
          };
          break;

        case bottom:
          offsets = {
            x: commonX,
            y: reference.y + reference.height
          };
          break;

        case right:
          offsets = {
            x: reference.x + reference.width,
            y: commonY
          };
          break;

        case left:
          offsets = {
            x: reference.x - element.width,
            y: commonY
          };
          break;

        default:
          offsets = {
            x: reference.x,
            y: reference.y
          };
      }

      var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;

      if (mainAxis != null) {
        var len = mainAxis === 'y' ? 'height' : 'width';

        switch (variation) {
          case start:
            offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
            break;

          case end:
            offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
            break;
        }
      }

      return offsets;
    }

    function detectOverflow(state, options) {
      if (options === void 0) {
        options = {};
      }

      var _options = options,
          _options$placement = _options.placement,
          placement = _options$placement === void 0 ? state.placement : _options$placement,
          _options$boundary = _options.boundary,
          boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,
          _options$rootBoundary = _options.rootBoundary,
          rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,
          _options$elementConte = _options.elementContext,
          elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,
          _options$altBoundary = _options.altBoundary,
          altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
          _options$padding = _options.padding,
          padding = _options$padding === void 0 ? 0 : _options$padding;
      var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
      var altContext = elementContext === popper ? reference : popper;
      var referenceElement = state.elements.reference;
      var popperRect = state.rects.popper;
      var element = state.elements[altBoundary ? altContext : elementContext];
      var clippingClientRect = getClippingRect(isElement$1(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);
      var referenceClientRect = getBoundingClientRect(referenceElement);
      var popperOffsets = computeOffsets({
        reference: referenceClientRect,
        element: popperRect,
        strategy: 'absolute',
        placement: placement
      });
      var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));
      var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
      // 0 or negative = within the clipping rect

      var overflowOffsets = {
        top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
        bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
        left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
        right: elementClientRect.right - clippingClientRect.right + paddingObject.right
      };
      var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

      if (elementContext === popper && offsetData) {
        var offset = offsetData[placement];
        Object.keys(overflowOffsets).forEach(function (key) {
          var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
          var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';
          overflowOffsets[key] += offset[axis] * multiply;
        });
      }

      return overflowOffsets;
    }

    function computeAutoPlacement(state, options) {
      if (options === void 0) {
        options = {};
      }

      var _options = options,
          placement = _options.placement,
          boundary = _options.boundary,
          rootBoundary = _options.rootBoundary,
          padding = _options.padding,
          flipVariations = _options.flipVariations,
          _options$allowedAutoP = _options.allowedAutoPlacements,
          allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
      var variation = getVariation(placement);
      var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {
        return getVariation(placement) === variation;
      }) : basePlacements;
      var allowedPlacements = placements$1.filter(function (placement) {
        return allowedAutoPlacements.indexOf(placement) >= 0;
      });

      if (allowedPlacements.length === 0) {
        allowedPlacements = placements$1;
      } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...


      var overflows = allowedPlacements.reduce(function (acc, placement) {
        acc[placement] = detectOverflow(state, {
          placement: placement,
          boundary: boundary,
          rootBoundary: rootBoundary,
          padding: padding
        })[getBasePlacement$1(placement)];
        return acc;
      }, {});
      return Object.keys(overflows).sort(function (a, b) {
        return overflows[a] - overflows[b];
      });
    }

    function getExpandedFallbackPlacements(placement) {
      if (getBasePlacement$1(placement) === auto) {
        return [];
      }

      var oppositePlacement = getOppositePlacement(placement);
      return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
    }

    function flip(_ref) {
      var state = _ref.state,
          options = _ref.options,
          name = _ref.name;

      if (state.modifiersData[name]._skip) {
        return;
      }

      var _options$mainAxis = options.mainAxis,
          checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
          _options$altAxis = options.altAxis,
          checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
          specifiedFallbackPlacements = options.fallbackPlacements,
          padding = options.padding,
          boundary = options.boundary,
          rootBoundary = options.rootBoundary,
          altBoundary = options.altBoundary,
          _options$flipVariatio = options.flipVariations,
          flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
          allowedAutoPlacements = options.allowedAutoPlacements;
      var preferredPlacement = state.options.placement;
      var basePlacement = getBasePlacement$1(preferredPlacement);
      var isBasePlacement = basePlacement === preferredPlacement;
      var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
      var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
        return acc.concat(getBasePlacement$1(placement) === auto ? computeAutoPlacement(state, {
          placement: placement,
          boundary: boundary,
          rootBoundary: rootBoundary,
          padding: padding,
          flipVariations: flipVariations,
          allowedAutoPlacements: allowedAutoPlacements
        }) : placement);
      }, []);
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var checksMap = new Map();
      var makeFallbackChecks = true;
      var firstFittingPlacement = placements[0];

      for (var i = 0; i < placements.length; i++) {
        var placement = placements[i];

        var _basePlacement = getBasePlacement$1(placement);

        var isStartVariation = getVariation(placement) === start;
        var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
        var len = isVertical ? 'width' : 'height';
        var overflow = detectOverflow(state, {
          placement: placement,
          boundary: boundary,
          rootBoundary: rootBoundary,
          altBoundary: altBoundary,
          padding: padding
        });
        var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;

        if (referenceRect[len] > popperRect[len]) {
          mainVariationSide = getOppositePlacement(mainVariationSide);
        }

        var altVariationSide = getOppositePlacement(mainVariationSide);
        var checks = [];

        if (checkMainAxis) {
          checks.push(overflow[_basePlacement] <= 0);
        }

        if (checkAltAxis) {
          checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
        }

        if (checks.every(function (check) {
          return check;
        })) {
          firstFittingPlacement = placement;
          makeFallbackChecks = false;
          break;
        }

        checksMap.set(placement, checks);
      }

      if (makeFallbackChecks) {
        // `2` may be desired in some cases  research later
        var numberOfChecks = flipVariations ? 3 : 1;

        var _loop = function _loop(_i) {
          var fittingPlacement = placements.find(function (placement) {
            var checks = checksMap.get(placement);

            if (checks) {
              return checks.slice(0, _i).every(function (check) {
                return check;
              });
            }
          });

          if (fittingPlacement) {
            firstFittingPlacement = fittingPlacement;
            return "break";
          }
        };

        for (var _i = numberOfChecks; _i > 0; _i--) {
          var _ret = _loop(_i);

          if (_ret === "break") break;
        }
      }

      if (state.placement !== firstFittingPlacement) {
        state.modifiersData[name]._skip = true;
        state.placement = firstFittingPlacement;
        state.reset = true;
      }
    } // eslint-disable-next-line import/no-unused-modules


    var flip$1 = {
      name: 'flip',
      enabled: true,
      phase: 'main',
      fn: flip,
      requiresIfExists: ['offset'],
      data: {
        _skip: false
      }
    };

    function getSideOffsets(overflow, rect, preventedOffsets) {
      if (preventedOffsets === void 0) {
        preventedOffsets = {
          x: 0,
          y: 0
        };
      }

      return {
        top: overflow.top - rect.height - preventedOffsets.y,
        right: overflow.right - rect.width + preventedOffsets.x,
        bottom: overflow.bottom - rect.height + preventedOffsets.y,
        left: overflow.left - rect.width - preventedOffsets.x
      };
    }

    function isAnySideFullyClipped(overflow) {
      return [top, right, bottom, left].some(function (side) {
        return overflow[side] >= 0;
      });
    }

    function hide(_ref) {
      var state = _ref.state,
          name = _ref.name;
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var preventedOffsets = state.modifiersData.preventOverflow;
      var referenceOverflow = detectOverflow(state, {
        elementContext: 'reference'
      });
      var popperAltOverflow = detectOverflow(state, {
        altBoundary: true
      });
      var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
      var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
      var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
      var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
      state.modifiersData[name] = {
        referenceClippingOffsets: referenceClippingOffsets,
        popperEscapeOffsets: popperEscapeOffsets,
        isReferenceHidden: isReferenceHidden,
        hasPopperEscaped: hasPopperEscaped
      };
      state.attributes.popper = Object.assign({}, state.attributes.popper, {
        'data-popper-reference-hidden': isReferenceHidden,
        'data-popper-escaped': hasPopperEscaped
      });
    } // eslint-disable-next-line import/no-unused-modules


    var hide$1 = {
      name: 'hide',
      enabled: true,
      phase: 'main',
      requiresIfExists: ['preventOverflow'],
      fn: hide
    };

    function distanceAndSkiddingToXY(placement, rects, offset) {
      var basePlacement = getBasePlacement$1(placement);
      var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;

      var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {
        placement: placement
      })) : offset,
          skidding = _ref[0],
          distance = _ref[1];

      skidding = skidding || 0;
      distance = (distance || 0) * invertDistance;
      return [left, right].indexOf(basePlacement) >= 0 ? {
        x: distance,
        y: skidding
      } : {
        x: skidding,
        y: distance
      };
    }

    function offset(_ref2) {
      var state = _ref2.state,
          options = _ref2.options,
          name = _ref2.name;
      var _options$offset = options.offset,
          offset = _options$offset === void 0 ? [0, 0] : _options$offset;
      var data = placements.reduce(function (acc, placement) {
        acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
        return acc;
      }, {});
      var _data$state$placement = data[state.placement],
          x = _data$state$placement.x,
          y = _data$state$placement.y;

      if (state.modifiersData.popperOffsets != null) {
        state.modifiersData.popperOffsets.x += x;
        state.modifiersData.popperOffsets.y += y;
      }

      state.modifiersData[name] = data;
    } // eslint-disable-next-line import/no-unused-modules


    var offset$1 = {
      name: 'offset',
      enabled: true,
      phase: 'main',
      requires: ['popperOffsets'],
      fn: offset
    };

    function popperOffsets(_ref) {
      var state = _ref.state,
          name = _ref.name;
      // Offsets are the actual position the popper needs to have to be
      // properly positioned near its reference element
      // This is the most basic placement, and will be adjusted by
      // the modifiers in the next step
      state.modifiersData[name] = computeOffsets({
        reference: state.rects.reference,
        element: state.rects.popper,
        strategy: 'absolute',
        placement: state.placement
      });
    } // eslint-disable-next-line import/no-unused-modules


    var popperOffsets$1 = {
      name: 'popperOffsets',
      enabled: true,
      phase: 'read',
      fn: popperOffsets,
      data: {}
    };

    function getAltAxis(axis) {
      return axis === 'x' ? 'y' : 'x';
    }

    function preventOverflow(_ref) {
      var state = _ref.state,
          options = _ref.options,
          name = _ref.name;
      var _options$mainAxis = options.mainAxis,
          checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
          _options$altAxis = options.altAxis,
          checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
          boundary = options.boundary,
          rootBoundary = options.rootBoundary,
          altBoundary = options.altBoundary,
          padding = options.padding,
          _options$tether = options.tether,
          tether = _options$tether === void 0 ? true : _options$tether,
          _options$tetherOffset = options.tetherOffset,
          tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
      var overflow = detectOverflow(state, {
        boundary: boundary,
        rootBoundary: rootBoundary,
        padding: padding,
        altBoundary: altBoundary
      });
      var basePlacement = getBasePlacement$1(state.placement);
      var variation = getVariation(state.placement);
      var isBasePlacement = !variation;
      var mainAxis = getMainAxisFromPlacement(basePlacement);
      var altAxis = getAltAxis(mainAxis);
      var popperOffsets = state.modifiersData.popperOffsets;
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
        placement: state.placement
      })) : tetherOffset;
      var data = {
        x: 0,
        y: 0
      };

      if (!popperOffsets) {
        return;
      }

      if (checkMainAxis || checkAltAxis) {
        var mainSide = mainAxis === 'y' ? top : left;
        var altSide = mainAxis === 'y' ? bottom : right;
        var len = mainAxis === 'y' ? 'height' : 'width';
        var offset = popperOffsets[mainAxis];
        var min$1 = popperOffsets[mainAxis] + overflow[mainSide];
        var max$1 = popperOffsets[mainAxis] - overflow[altSide];
        var additive = tether ? -popperRect[len] / 2 : 0;
        var minLen = variation === start ? referenceRect[len] : popperRect[len];
        var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
        // outside the reference bounds

        var arrowElement = state.elements.arrow;
        var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
          width: 0,
          height: 0
        };
        var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();
        var arrowPaddingMin = arrowPaddingObject[mainSide];
        var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
        // to include its full size in the calculation. If the reference is small
        // and near the edge of a boundary, the popper can overflow even if the
        // reference is not overflowing as well (e.g. virtual elements with no
        // width or height)

        var arrowLen = within(0, referenceRect[len], arrowRect[len]);
        var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue;
        var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue;
        var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
        var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
        var offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0;
        var tetherMin = popperOffsets[mainAxis] + minOffset - offsetModifierValue - clientOffset;
        var tetherMax = popperOffsets[mainAxis] + maxOffset - offsetModifierValue;

        if (checkMainAxis) {
          var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset, tether ? max(max$1, tetherMax) : max$1);
          popperOffsets[mainAxis] = preventedOffset;
          data[mainAxis] = preventedOffset - offset;
        }

        if (checkAltAxis) {
          var _mainSide = mainAxis === 'x' ? top : left;

          var _altSide = mainAxis === 'x' ? bottom : right;

          var _offset = popperOffsets[altAxis];

          var _min = _offset + overflow[_mainSide];

          var _max = _offset - overflow[_altSide];

          var _preventedOffset = within(tether ? min(_min, tetherMin) : _min, _offset, tether ? max(_max, tetherMax) : _max);

          popperOffsets[altAxis] = _preventedOffset;
          data[altAxis] = _preventedOffset - _offset;
        }
      }

      state.modifiersData[name] = data;
    } // eslint-disable-next-line import/no-unused-modules


    var preventOverflow$1 = {
      name: 'preventOverflow',
      enabled: true,
      phase: 'main',
      fn: preventOverflow,
      requiresIfExists: ['offset']
    };

    function getHTMLElementScroll(element) {
      return {
        scrollLeft: element.scrollLeft,
        scrollTop: element.scrollTop
      };
    }

    function getNodeScroll(node) {
      if (node === getWindow(node) || !isHTMLElement(node)) {
        return getWindowScroll(node);
      } else {
        return getHTMLElementScroll(node);
      }
    }

    // Composite means it takes into account transforms as well as layout.

    function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
      if (isFixed === void 0) {
        isFixed = false;
      }

      var documentElement = getDocumentElement(offsetParent);
      var rect = getBoundingClientRect(elementOrVirtualElement);
      var isOffsetParentAnElement = isHTMLElement(offsetParent);
      var scroll = {
        scrollLeft: 0,
        scrollTop: 0
      };
      var offsets = {
        x: 0,
        y: 0
      };

      if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
        if (getNodeName(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078
        isScrollParent(documentElement)) {
          scroll = getNodeScroll(offsetParent);
        }

        if (isHTMLElement(offsetParent)) {
          offsets = getBoundingClientRect(offsetParent);
          offsets.x += offsetParent.clientLeft;
          offsets.y += offsetParent.clientTop;
        } else if (documentElement) {
          offsets.x = getWindowScrollBarX(documentElement);
        }
      }

      return {
        x: rect.left + scroll.scrollLeft - offsets.x,
        y: rect.top + scroll.scrollTop - offsets.y,
        width: rect.width,
        height: rect.height
      };
    }

    function order(modifiers) {
      var map = new Map();
      var visited = new Set();
      var result = [];
      modifiers.forEach(function (modifier) {
        map.set(modifier.name, modifier);
      }); // On visiting object, check for its dependencies and visit them recursively

      function sort(modifier) {
        visited.add(modifier.name);
        var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
        requires.forEach(function (dep) {
          if (!visited.has(dep)) {
            var depModifier = map.get(dep);

            if (depModifier) {
              sort(depModifier);
            }
          }
        });
        result.push(modifier);
      }

      modifiers.forEach(function (modifier) {
        if (!visited.has(modifier.name)) {
          // check for visited object
          sort(modifier);
        }
      });
      return result;
    }

    function orderModifiers(modifiers) {
      // order based on dependencies
      var orderedModifiers = order(modifiers); // order based on phase

      return modifierPhases.reduce(function (acc, phase) {
        return acc.concat(orderedModifiers.filter(function (modifier) {
          return modifier.phase === phase;
        }));
      }, []);
    }

    function debounce$1(fn) {
      var pending;
      return function () {
        if (!pending) {
          pending = new Promise(function (resolve) {
            Promise.resolve().then(function () {
              pending = undefined;
              resolve(fn());
            });
          });
        }

        return pending;
      };
    }

    function mergeByName(modifiers) {
      var merged = modifiers.reduce(function (merged, current) {
        var existing = merged[current.name];
        merged[current.name] = existing ? Object.assign({}, existing, current, {
          options: Object.assign({}, existing.options, current.options),
          data: Object.assign({}, existing.data, current.data)
        }) : current;
        return merged;
      }, {}); // IE11 does not support Object.values

      return Object.keys(merged).map(function (key) {
        return merged[key];
      });
    }

    var DEFAULT_OPTIONS = {
      placement: 'bottom',
      modifiers: [],
      strategy: 'absolute'
    };

    function areValidElements() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return !args.some(function (element) {
        return !(element && typeof element.getBoundingClientRect === 'function');
      });
    }

    function popperGenerator(generatorOptions) {
      if (generatorOptions === void 0) {
        generatorOptions = {};
      }

      var _generatorOptions = generatorOptions,
          _generatorOptions$def = _generatorOptions.defaultModifiers,
          defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
          _generatorOptions$def2 = _generatorOptions.defaultOptions,
          defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
      return function createPopper(reference, popper, options) {
        if (options === void 0) {
          options = defaultOptions;
        }

        var state = {
          placement: 'bottom',
          orderedModifiers: [],
          options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
          modifiersData: {},
          elements: {
            reference: reference,
            popper: popper
          },
          attributes: {},
          styles: {}
        };
        var effectCleanupFns = [];
        var isDestroyed = false;
        var instance = {
          state: state,
          setOptions: function setOptions(options) {
            cleanupModifierEffects();
            state.options = Object.assign({}, defaultOptions, state.options, options);
            state.scrollParents = {
              reference: isElement$1(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
              popper: listScrollParents(popper)
            }; // Orders the modifiers based on their dependencies and `phase`
            // properties

            var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

            state.orderedModifiers = orderedModifiers.filter(function (m) {
              return m.enabled;
            }); // Validate the provided modifiers so that the consumer will get warned

            runModifierEffects();
            return instance.update();
          },
          // Sync update  it will always be executed, even if not necessary. This
          // is useful for low frequency updates where sync behavior simplifies the
          // logic.
          // For high frequency updates (e.g. `resize` and `scroll` events), always
          // prefer the async Popper#update method
          forceUpdate: function forceUpdate() {
            if (isDestroyed) {
              return;
            }

            var _state$elements = state.elements,
                reference = _state$elements.reference,
                popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
            // anymore

            if (!areValidElements(reference, popper)) {

              return;
            } // Store the reference and popper rects to be read by modifiers


            state.rects = {
              reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),
              popper: getLayoutRect(popper)
            }; // Modifiers have the ability to reset the current update cycle. The
            // most common use case for this is the `flip` modifier changing the
            // placement, which then needs to re-run all the modifiers, because the
            // logic was previously ran for the previous placement and is therefore
            // stale/incorrect

            state.reset = false;
            state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
            // is filled with the initial data specified by the modifier. This means
            // it doesn't persist and is fresh on each update.
            // To ensure persistent data, use `${name}#persistent`

            state.orderedModifiers.forEach(function (modifier) {
              return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
            });

            for (var index = 0; index < state.orderedModifiers.length; index++) {

              if (state.reset === true) {
                state.reset = false;
                index = -1;
                continue;
              }

              var _state$orderedModifie = state.orderedModifiers[index],
                  fn = _state$orderedModifie.fn,
                  _state$orderedModifie2 = _state$orderedModifie.options,
                  _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
                  name = _state$orderedModifie.name;

              if (typeof fn === 'function') {
                state = fn({
                  state: state,
                  options: _options,
                  name: name,
                  instance: instance
                }) || state;
              }
            }
          },
          // Async and optimistically optimized update  it will not be executed if
          // not necessary (debounced to run at most once-per-tick)
          update: debounce$1(function () {
            return new Promise(function (resolve) {
              instance.forceUpdate();
              resolve(state);
            });
          }),
          destroy: function destroy() {
            cleanupModifierEffects();
            isDestroyed = true;
          }
        };

        if (!areValidElements(reference, popper)) {

          return instance;
        }

        instance.setOptions(options).then(function (state) {
          if (!isDestroyed && options.onFirstUpdate) {
            options.onFirstUpdate(state);
          }
        }); // Modifiers have the ability to execute arbitrary code before the first
        // update cycle runs. They will be executed in the same order as the update
        // cycle. This is useful when a modifier adds some persistent data that
        // other modifiers need to use, but the modifier is run after the dependent
        // one.

        function runModifierEffects() {
          state.orderedModifiers.forEach(function (_ref3) {
            var name = _ref3.name,
                _ref3$options = _ref3.options,
                options = _ref3$options === void 0 ? {} : _ref3$options,
                effect = _ref3.effect;

            if (typeof effect === 'function') {
              var cleanupFn = effect({
                state: state,
                name: name,
                instance: instance,
                options: options
              });

              var noopFn = function noopFn() {};

              effectCleanupFns.push(cleanupFn || noopFn);
            }
          });
        }

        function cleanupModifierEffects() {
          effectCleanupFns.forEach(function (fn) {
            return fn();
          });
          effectCleanupFns = [];
        }

        return instance;
      };
    }

    var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
    var createPopper = /*#__PURE__*/popperGenerator({
      defaultModifiers: defaultModifiers
    }); // eslint-disable-next-line import/no-unused-modules

    /**!
    * tippy.js v6.3.1
    * (c) 2017-2021 atomiks
    * MIT License
    */
    var BOX_CLASS = "tippy-box";
    var CONTENT_CLASS = "tippy-content";
    var BACKDROP_CLASS = "tippy-backdrop";
    var ARROW_CLASS = "tippy-arrow";
    var SVG_ARROW_CLASS = "tippy-svg-arrow";
    var TOUCH_OPTIONS = {
      passive: true,
      capture: true
    };
    function getValueAtIndexOrReturn(value, index, defaultValue) {
      if (Array.isArray(value)) {
        var v = value[index];
        return v == null ? Array.isArray(defaultValue) ? defaultValue[index] : defaultValue : v;
      }

      return value;
    }
    function isType(value, type) {
      var str = {}.toString.call(value);
      return str.indexOf('[object') === 0 && str.indexOf(type + "]") > -1;
    }
    function invokeWithArgsOrReturn(value, args) {
      return typeof value === 'function' ? value.apply(void 0, args) : value;
    }
    function debounce(fn, ms) {
      // Avoid wrapping in `setTimeout` if ms is 0 anyway
      if (ms === 0) {
        return fn;
      }

      var timeout;
      return function (arg) {
        clearTimeout(timeout);
        timeout = setTimeout(function () {
          fn(arg);
        }, ms);
      };
    }
    function removeProperties(obj, keys) {
      var clone = Object.assign({}, obj);
      keys.forEach(function (key) {
        delete clone[key];
      });
      return clone;
    }
    function splitBySpaces(value) {
      return value.split(/\s+/).filter(Boolean);
    }
    function normalizeToArray(value) {
      return [].concat(value);
    }
    function pushIfUnique(arr, value) {
      if (arr.indexOf(value) === -1) {
        arr.push(value);
      }
    }
    function unique$1(arr) {
      return arr.filter(function (item, index) {
        return arr.indexOf(item) === index;
      });
    }
    function getBasePlacement(placement) {
      return placement.split('-')[0];
    }
    function arrayFrom(value) {
      return [].slice.call(value);
    }
    function removeUndefinedProps(obj) {
      return Object.keys(obj).reduce(function (acc, key) {
        if (obj[key] !== undefined) {
          acc[key] = obj[key];
        }

        return acc;
      }, {});
    }

    function div() {
      return document.createElement('div');
    }
    function isElement(value) {
      return ['Element', 'Fragment'].some(function (type) {
        return isType(value, type);
      });
    }
    function isNodeList(value) {
      return isType(value, 'NodeList');
    }
    function isMouseEvent(value) {
      return isType(value, 'MouseEvent');
    }
    function isReferenceElement(value) {
      return !!(value && value._tippy && value._tippy.reference === value);
    }
    function getArrayOfElements(value) {
      if (isElement(value)) {
        return [value];
      }

      if (isNodeList(value)) {
        return arrayFrom(value);
      }

      if (Array.isArray(value)) {
        return value;
      }

      return arrayFrom(document.querySelectorAll(value));
    }
    function setTransitionDuration(els, value) {
      els.forEach(function (el) {
        if (el) {
          el.style.transitionDuration = value + "ms";
        }
      });
    }
    function setVisibilityState(els, state) {
      els.forEach(function (el) {
        if (el) {
          el.setAttribute('data-state', state);
        }
      });
    }
    function getOwnerDocument(elementOrElements) {
      var _element$ownerDocumen;

      var _normalizeToArray = normalizeToArray(elementOrElements),
          element = _normalizeToArray[0]; // Elements created via a <template> have an ownerDocument with no reference to the body


      return (element == null ? void 0 : (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body) ? element.ownerDocument : document;
    }
    function isCursorOutsideInteractiveBorder(popperTreeData, event) {
      var clientX = event.clientX,
          clientY = event.clientY;
      return popperTreeData.every(function (_ref) {
        var popperRect = _ref.popperRect,
            popperState = _ref.popperState,
            props = _ref.props;
        var interactiveBorder = props.interactiveBorder;
        var basePlacement = getBasePlacement(popperState.placement);
        var offsetData = popperState.modifiersData.offset;

        if (!offsetData) {
          return true;
        }

        var topDistance = basePlacement === 'bottom' ? offsetData.top.y : 0;
        var bottomDistance = basePlacement === 'top' ? offsetData.bottom.y : 0;
        var leftDistance = basePlacement === 'right' ? offsetData.left.x : 0;
        var rightDistance = basePlacement === 'left' ? offsetData.right.x : 0;
        var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;
        var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;
        var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;
        var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;
        return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
      });
    }
    function updateTransitionEndListener(box, action, listener) {
      var method = action + "EventListener"; // some browsers apparently support `transition` (unprefixed) but only fire
      // `webkitTransitionEnd`...

      ['transitionend', 'webkitTransitionEnd'].forEach(function (event) {
        box[method](event, listener);
      });
    }

    var currentInput = {
      isTouch: false
    };
    var lastMouseMoveTime = 0;
    /**
     * When a `touchstart` event is fired, it's assumed the user is using touch
     * input. We'll bind a `mousemove` event listener to listen for mouse input in
     * the future. This way, the `isTouch` property is fully dynamic and will handle
     * hybrid devices that use a mix of touch + mouse input.
     */

    function onDocumentTouchStart() {
      if (currentInput.isTouch) {
        return;
      }

      currentInput.isTouch = true;

      if (window.performance) {
        document.addEventListener('mousemove', onDocumentMouseMove);
      }
    }
    /**
     * When two `mousemove` event are fired consecutively within 20ms, it's assumed
     * the user is using mouse input again. `mousemove` can fire on touch devices as
     * well, but very rarely that quickly.
     */

    function onDocumentMouseMove() {
      var now = performance.now();

      if (now - lastMouseMoveTime < 20) {
        currentInput.isTouch = false;
        document.removeEventListener('mousemove', onDocumentMouseMove);
      }

      lastMouseMoveTime = now;
    }
    /**
     * When an element is in focus and has a tippy, leaving the tab/window and
     * returning causes it to show again. For mouse users this is unexpected, but
     * for keyboard use it makes sense.
     * TODO: find a better technique to solve this problem
     */

    function onWindowBlur() {
      var activeElement = document.activeElement;

      if (isReferenceElement(activeElement)) {
        var instance = activeElement._tippy;

        if (activeElement.blur && !instance.state.isVisible) {
          activeElement.blur();
        }
      }
    }
    function bindGlobalEventListeners() {
      document.addEventListener('touchstart', onDocumentTouchStart, TOUCH_OPTIONS);
      window.addEventListener('blur', onWindowBlur);
    }

    var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';
    var ua = isBrowser ? navigator.userAgent : '';
    var isIE = /MSIE |Trident\//.test(ua);

    var pluginProps = {
      animateFill: false,
      followCursor: false,
      inlinePositioning: false,
      sticky: false
    };
    var renderProps = {
      allowHTML: false,
      animation: 'fade',
      arrow: true,
      content: '',
      inertia: false,
      maxWidth: 350,
      role: 'tooltip',
      theme: '',
      zIndex: 9999
    };
    var defaultProps = Object.assign({
      appendTo: function appendTo() {
        return document.body;
      },
      aria: {
        content: 'auto',
        expanded: 'auto'
      },
      delay: 0,
      duration: [300, 250],
      getReferenceClientRect: null,
      hideOnClick: true,
      ignoreAttributes: false,
      interactive: false,
      interactiveBorder: 2,
      interactiveDebounce: 0,
      moveTransition: '',
      offset: [0, 10],
      onAfterUpdate: function onAfterUpdate() {},
      onBeforeUpdate: function onBeforeUpdate() {},
      onCreate: function onCreate() {},
      onDestroy: function onDestroy() {},
      onHidden: function onHidden() {},
      onHide: function onHide() {},
      onMount: function onMount() {},
      onShow: function onShow() {},
      onShown: function onShown() {},
      onTrigger: function onTrigger() {},
      onUntrigger: function onUntrigger() {},
      onClickOutside: function onClickOutside() {},
      placement: 'top',
      plugins: [],
      popperOptions: {},
      render: null,
      showOnCreate: false,
      touch: true,
      trigger: 'mouseenter focus',
      triggerTarget: null
    }, pluginProps, {}, renderProps);
    var defaultKeys = Object.keys(defaultProps);
    var setDefaultProps = function setDefaultProps(partialProps) {

      var keys = Object.keys(partialProps);
      keys.forEach(function (key) {
        defaultProps[key] = partialProps[key];
      });
    };
    function getExtendedPassedProps(passedProps) {
      var plugins = passedProps.plugins || [];
      var pluginProps = plugins.reduce(function (acc, plugin) {
        var name = plugin.name,
            defaultValue = plugin.defaultValue;

        if (name) {
          acc[name] = passedProps[name] !== undefined ? passedProps[name] : defaultValue;
        }

        return acc;
      }, {});
      return Object.assign({}, passedProps, {}, pluginProps);
    }
    function getDataAttributeProps(reference, plugins) {
      var propKeys = plugins ? Object.keys(getExtendedPassedProps(Object.assign({}, defaultProps, {
        plugins: plugins
      }))) : defaultKeys;
      var props = propKeys.reduce(function (acc, key) {
        var valueAsString = (reference.getAttribute("data-tippy-" + key) || '').trim();

        if (!valueAsString) {
          return acc;
        }

        if (key === 'content') {
          acc[key] = valueAsString;
        } else {
          try {
            acc[key] = JSON.parse(valueAsString);
          } catch (e) {
            acc[key] = valueAsString;
          }
        }

        return acc;
      }, {});
      return props;
    }
    function evaluateProps(reference, props) {
      var out = Object.assign({}, props, {
        content: invokeWithArgsOrReturn(props.content, [reference])
      }, props.ignoreAttributes ? {} : getDataAttributeProps(reference, props.plugins));
      out.aria = Object.assign({}, defaultProps.aria, {}, out.aria);
      out.aria = {
        expanded: out.aria.expanded === 'auto' ? props.interactive : out.aria.expanded,
        content: out.aria.content === 'auto' ? props.interactive ? null : 'describedby' : out.aria.content
      };
      return out;
    }

    var innerHTML = function innerHTML() {
      return 'innerHTML';
    };

    function dangerouslySetInnerHTML(element, html) {
      element[innerHTML()] = html;
    }

    function createArrowElement(value) {
      var arrow = div();

      if (value === true) {
        arrow.className = ARROW_CLASS;
      } else {
        arrow.className = SVG_ARROW_CLASS;

        if (isElement(value)) {
          arrow.appendChild(value);
        } else {
          dangerouslySetInnerHTML(arrow, value);
        }
      }

      return arrow;
    }

    function setContent(content, props) {
      if (isElement(props.content)) {
        dangerouslySetInnerHTML(content, '');
        content.appendChild(props.content);
      } else if (typeof props.content !== 'function') {
        if (props.allowHTML) {
          dangerouslySetInnerHTML(content, props.content);
        } else {
          content.textContent = props.content;
        }
      }
    }
    function getChildren(popper) {
      var box = popper.firstElementChild;
      var boxChildren = arrayFrom(box.children);
      return {
        box: box,
        content: boxChildren.find(function (node) {
          return node.classList.contains(CONTENT_CLASS);
        }),
        arrow: boxChildren.find(function (node) {
          return node.classList.contains(ARROW_CLASS) || node.classList.contains(SVG_ARROW_CLASS);
        }),
        backdrop: boxChildren.find(function (node) {
          return node.classList.contains(BACKDROP_CLASS);
        })
      };
    }
    function render(instance) {
      var popper = div();
      var box = div();
      box.className = BOX_CLASS;
      box.setAttribute('data-state', 'hidden');
      box.setAttribute('tabindex', '-1');
      var content = div();
      content.className = CONTENT_CLASS;
      content.setAttribute('data-state', 'hidden');
      setContent(content, instance.props);
      popper.appendChild(box);
      box.appendChild(content);
      onUpdate(instance.props, instance.props);

      function onUpdate(prevProps, nextProps) {
        var _getChildren = getChildren(popper),
            box = _getChildren.box,
            content = _getChildren.content,
            arrow = _getChildren.arrow;

        if (nextProps.theme) {
          box.setAttribute('data-theme', nextProps.theme);
        } else {
          box.removeAttribute('data-theme');
        }

        if (typeof nextProps.animation === 'string') {
          box.setAttribute('data-animation', nextProps.animation);
        } else {
          box.removeAttribute('data-animation');
        }

        if (nextProps.inertia) {
          box.setAttribute('data-inertia', '');
        } else {
          box.removeAttribute('data-inertia');
        }

        box.style.maxWidth = typeof nextProps.maxWidth === 'number' ? nextProps.maxWidth + "px" : nextProps.maxWidth;

        if (nextProps.role) {
          box.setAttribute('role', nextProps.role);
        } else {
          box.removeAttribute('role');
        }

        if (prevProps.content !== nextProps.content || prevProps.allowHTML !== nextProps.allowHTML) {
          setContent(content, instance.props);
        }

        if (nextProps.arrow) {
          if (!arrow) {
            box.appendChild(createArrowElement(nextProps.arrow));
          } else if (prevProps.arrow !== nextProps.arrow) {
            box.removeChild(arrow);
            box.appendChild(createArrowElement(nextProps.arrow));
          }
        } else if (arrow) {
          box.removeChild(arrow);
        }
      }

      return {
        popper: popper,
        onUpdate: onUpdate
      };
    } // Runtime check to identify if the render function is the default one; this
    // way we can apply default CSS transitions logic and it can be tree-shaken away

    render.$$tippy = true;

    var idCounter = 1;
    var mouseMoveListeners = []; // Used by `hideAll()`

    var mountedInstances = [];
    function createTippy(reference, passedProps) {
      var props = evaluateProps(reference, Object.assign({}, defaultProps, {}, getExtendedPassedProps(removeUndefinedProps(passedProps)))); // ===========================================================================
      //  Private members
      // ===========================================================================

      var showTimeout;
      var hideTimeout;
      var scheduleHideAnimationFrame;
      var isVisibleFromClick = false;
      var didHideDueToDocumentMouseDown = false;
      var didTouchMove = false;
      var ignoreOnFirstUpdate = false;
      var lastTriggerEvent;
      var currentTransitionEndListener;
      var onFirstUpdate;
      var listeners = [];
      var debouncedOnMouseMove = debounce(onMouseMove, props.interactiveDebounce);
      var currentTarget; // ===========================================================================
      //  Public members
      // ===========================================================================

      var id = idCounter++;
      var popperInstance = null;
      var plugins = unique$1(props.plugins);
      var state = {
        // Is the instance currently enabled?
        isEnabled: true,
        // Is the tippy currently showing and not transitioning out?
        isVisible: false,
        // Has the instance been destroyed?
        isDestroyed: false,
        // Is the tippy currently mounted to the DOM?
        isMounted: false,
        // Has the tippy finished transitioning in?
        isShown: false
      };
      var instance = {
        // properties
        id: id,
        reference: reference,
        popper: div(),
        popperInstance: popperInstance,
        props: props,
        state: state,
        plugins: plugins,
        // methods
        clearDelayTimeouts: clearDelayTimeouts,
        setProps: setProps,
        setContent: setContent,
        show: show,
        hide: hide,
        hideWithInteractivity: hideWithInteractivity,
        enable: enable,
        disable: disable,
        unmount: unmount,
        destroy: destroy
      }; // TODO: Investigate why this early return causes a TDZ error in the tests 
      // it doesn't seem to happen in the browser

      /* istanbul ignore if */

      if (!props.render) {

        return instance;
      } // ===========================================================================
      // Initial mutations
      // ===========================================================================


      var _props$render = props.render(instance),
          popper = _props$render.popper,
          onUpdate = _props$render.onUpdate;

      popper.setAttribute('data-tippy-root', '');
      popper.id = "tippy-" + instance.id;
      instance.popper = popper;
      reference._tippy = instance;
      popper._tippy = instance;
      var pluginsHooks = plugins.map(function (plugin) {
        return plugin.fn(instance);
      });
      var hasAriaExpanded = reference.hasAttribute('aria-expanded');
      addListeners();
      handleAriaExpandedAttribute();
      handleStyles();
      invokeHook('onCreate', [instance]);

      if (props.showOnCreate) {
        scheduleShow();
      } // Prevent a tippy with a delay from hiding if the cursor left then returned
      // before it started hiding


      popper.addEventListener('mouseenter', function () {
        if (instance.props.interactive && instance.state.isVisible) {
          instance.clearDelayTimeouts();
        }
      });
      popper.addEventListener('mouseleave', function (event) {
        if (instance.props.interactive && instance.props.trigger.indexOf('mouseenter') >= 0) {
          getDocument().addEventListener('mousemove', debouncedOnMouseMove);
          debouncedOnMouseMove(event);
        }
      });
      return instance; // ===========================================================================
      //  Private methods
      // ===========================================================================

      function getNormalizedTouchSettings() {
        var touch = instance.props.touch;
        return Array.isArray(touch) ? touch : [touch, 0];
      }

      function getIsCustomTouchBehavior() {
        return getNormalizedTouchSettings()[0] === 'hold';
      }

      function getIsDefaultRenderFn() {
        var _instance$props$rende;

        // @ts-ignore
        return !!((_instance$props$rende = instance.props.render) == null ? void 0 : _instance$props$rende.$$tippy);
      }

      function getCurrentTarget() {
        return currentTarget || reference;
      }

      function getDocument() {
        var parent = getCurrentTarget().parentNode;
        return parent ? getOwnerDocument(parent) : document;
      }

      function getDefaultTemplateChildren() {
        return getChildren(popper);
      }

      function getDelay(isShow) {
        // For touch or keyboard input, force `0` delay for UX reasons
        // Also if the instance is mounted but not visible (transitioning out),
        // ignore delay
        if (instance.state.isMounted && !instance.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === 'focus') {
          return 0;
        }

        return getValueAtIndexOrReturn(instance.props.delay, isShow ? 0 : 1, defaultProps.delay);
      }

      function handleStyles() {
        popper.style.pointerEvents = instance.props.interactive && instance.state.isVisible ? '' : 'none';
        popper.style.zIndex = "" + instance.props.zIndex;
      }

      function invokeHook(hook, args, shouldInvokePropsHook) {
        if (shouldInvokePropsHook === void 0) {
          shouldInvokePropsHook = true;
        }

        pluginsHooks.forEach(function (pluginHooks) {
          if (pluginHooks[hook]) {
            pluginHooks[hook].apply(void 0, args);
          }
        });

        if (shouldInvokePropsHook) {
          var _instance$props;

          (_instance$props = instance.props)[hook].apply(_instance$props, args);
        }
      }

      function handleAriaContentAttribute() {
        var aria = instance.props.aria;

        if (!aria.content) {
          return;
        }

        var attr = "aria-" + aria.content;
        var id = popper.id;
        var nodes = normalizeToArray(instance.props.triggerTarget || reference);
        nodes.forEach(function (node) {
          var currentValue = node.getAttribute(attr);

          if (instance.state.isVisible) {
            node.setAttribute(attr, currentValue ? currentValue + " " + id : id);
          } else {
            var nextValue = currentValue && currentValue.replace(id, '').trim();

            if (nextValue) {
              node.setAttribute(attr, nextValue);
            } else {
              node.removeAttribute(attr);
            }
          }
        });
      }

      function handleAriaExpandedAttribute() {
        if (hasAriaExpanded || !instance.props.aria.expanded) {
          return;
        }

        var nodes = normalizeToArray(instance.props.triggerTarget || reference);
        nodes.forEach(function (node) {
          if (instance.props.interactive) {
            node.setAttribute('aria-expanded', instance.state.isVisible && node === getCurrentTarget() ? 'true' : 'false');
          } else {
            node.removeAttribute('aria-expanded');
          }
        });
      }

      function cleanupInteractiveMouseListeners() {
        getDocument().removeEventListener('mousemove', debouncedOnMouseMove);
        mouseMoveListeners = mouseMoveListeners.filter(function (listener) {
          return listener !== debouncedOnMouseMove;
        });
      }

      function onDocumentPress(event) {
        // Moved finger to scroll instead of an intentional tap outside
        if (currentInput.isTouch) {
          if (didTouchMove || event.type === 'mousedown') {
            return;
          }
        } // Clicked on interactive popper


        if (instance.props.interactive && popper.contains(event.target)) {
          return;
        } // Clicked on the event listeners target


        if (getCurrentTarget().contains(event.target)) {
          if (currentInput.isTouch) {
            return;
          }

          if (instance.state.isVisible && instance.props.trigger.indexOf('click') >= 0) {
            return;
          }
        } else {
          invokeHook('onClickOutside', [instance, event]);
        }

        if (instance.props.hideOnClick === true) {
          instance.clearDelayTimeouts();
          instance.hide(); // `mousedown` event is fired right before `focus` if pressing the
          // currentTarget. This lets a tippy with `focus` trigger know that it
          // should not show

          didHideDueToDocumentMouseDown = true;
          setTimeout(function () {
            didHideDueToDocumentMouseDown = false;
          }); // The listener gets added in `scheduleShow()`, but this may be hiding it
          // before it shows, and hide()'s early bail-out behavior can prevent it
          // from being cleaned up

          if (!instance.state.isMounted) {
            removeDocumentPress();
          }
        }
      }

      function onTouchMove() {
        didTouchMove = true;
      }

      function onTouchStart() {
        didTouchMove = false;
      }

      function addDocumentPress() {
        var doc = getDocument();
        doc.addEventListener('mousedown', onDocumentPress, true);
        doc.addEventListener('touchend', onDocumentPress, TOUCH_OPTIONS);
        doc.addEventListener('touchstart', onTouchStart, TOUCH_OPTIONS);
        doc.addEventListener('touchmove', onTouchMove, TOUCH_OPTIONS);
      }

      function removeDocumentPress() {
        var doc = getDocument();
        doc.removeEventListener('mousedown', onDocumentPress, true);
        doc.removeEventListener('touchend', onDocumentPress, TOUCH_OPTIONS);
        doc.removeEventListener('touchstart', onTouchStart, TOUCH_OPTIONS);
        doc.removeEventListener('touchmove', onTouchMove, TOUCH_OPTIONS);
      }

      function onTransitionedOut(duration, callback) {
        onTransitionEnd(duration, function () {
          if (!instance.state.isVisible && popper.parentNode && popper.parentNode.contains(popper)) {
            callback();
          }
        });
      }

      function onTransitionedIn(duration, callback) {
        onTransitionEnd(duration, callback);
      }

      function onTransitionEnd(duration, callback) {
        var box = getDefaultTemplateChildren().box;

        function listener(event) {
          if (event.target === box) {
            updateTransitionEndListener(box, 'remove', listener);
            callback();
          }
        } // Make callback synchronous if duration is 0
        // `transitionend` won't fire otherwise


        if (duration === 0) {
          return callback();
        }

        updateTransitionEndListener(box, 'remove', currentTransitionEndListener);
        updateTransitionEndListener(box, 'add', listener);
        currentTransitionEndListener = listener;
      }

      function on(eventType, handler, options) {
        if (options === void 0) {
          options = false;
        }

        var nodes = normalizeToArray(instance.props.triggerTarget || reference);
        nodes.forEach(function (node) {
          node.addEventListener(eventType, handler, options);
          listeners.push({
            node: node,
            eventType: eventType,
            handler: handler,
            options: options
          });
        });
      }

      function addListeners() {
        if (getIsCustomTouchBehavior()) {
          on('touchstart', onTrigger, {
            passive: true
          });
          on('touchend', onMouseLeave, {
            passive: true
          });
        }

        splitBySpaces(instance.props.trigger).forEach(function (eventType) {
          if (eventType === 'manual') {
            return;
          }

          on(eventType, onTrigger);

          switch (eventType) {
            case 'mouseenter':
              on('mouseleave', onMouseLeave);
              break;

            case 'focus':
              on(isIE ? 'focusout' : 'blur', onBlurOrFocusOut);
              break;

            case 'focusin':
              on('focusout', onBlurOrFocusOut);
              break;
          }
        });
      }

      function removeListeners() {
        listeners.forEach(function (_ref) {
          var node = _ref.node,
              eventType = _ref.eventType,
              handler = _ref.handler,
              options = _ref.options;
          node.removeEventListener(eventType, handler, options);
        });
        listeners = [];
      }

      function onTrigger(event) {
        var _lastTriggerEvent;

        var shouldScheduleClickHide = false;

        if (!instance.state.isEnabled || isEventListenerStopped(event) || didHideDueToDocumentMouseDown) {
          return;
        }

        var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === 'focus';
        lastTriggerEvent = event;
        currentTarget = event.currentTarget;
        handleAriaExpandedAttribute();

        if (!instance.state.isVisible && isMouseEvent(event)) {
          // If scrolling, `mouseenter` events can be fired if the cursor lands
          // over a new target, but `mousemove` events don't get fired. This
          // causes interactive tooltips to get stuck open until the cursor is
          // moved
          mouseMoveListeners.forEach(function (listener) {
            return listener(event);
          });
        } // Toggle show/hide when clicking click-triggered tooltips


        if (event.type === 'click' && (instance.props.trigger.indexOf('mouseenter') < 0 || isVisibleFromClick) && instance.props.hideOnClick !== false && instance.state.isVisible) {
          shouldScheduleClickHide = true;
        } else {
          scheduleShow(event);
        }

        if (event.type === 'click') {
          isVisibleFromClick = !shouldScheduleClickHide;
        }

        if (shouldScheduleClickHide && !wasFocused) {
          scheduleHide(event);
        }
      }

      function onMouseMove(event) {
        var target = event.target;
        var isCursorOverReferenceOrPopper = getCurrentTarget().contains(target) || popper.contains(target);

        if (event.type === 'mousemove' && isCursorOverReferenceOrPopper) {
          return;
        }

        var popperTreeData = getNestedPopperTree().concat(popper).map(function (popper) {
          var _instance$popperInsta;

          var instance = popper._tippy;
          var state = (_instance$popperInsta = instance.popperInstance) == null ? void 0 : _instance$popperInsta.state;

          if (state) {
            return {
              popperRect: popper.getBoundingClientRect(),
              popperState: state,
              props: props
            };
          }

          return null;
        }).filter(Boolean);

        if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {
          cleanupInteractiveMouseListeners();
          scheduleHide(event);
        }
      }

      function onMouseLeave(event) {
        var shouldBail = isEventListenerStopped(event) || instance.props.trigger.indexOf('click') >= 0 && isVisibleFromClick;

        if (shouldBail) {
          return;
        }

        if (instance.props.interactive) {
          instance.hideWithInteractivity(event);
          return;
        }

        scheduleHide(event);
      }

      function onBlurOrFocusOut(event) {
        if (instance.props.trigger.indexOf('focusin') < 0 && event.target !== getCurrentTarget()) {
          return;
        } // If focus was moved to within the popper


        if (instance.props.interactive && event.relatedTarget && popper.contains(event.relatedTarget)) {
          return;
        }

        scheduleHide(event);
      }

      function isEventListenerStopped(event) {
        return currentInput.isTouch ? getIsCustomTouchBehavior() !== event.type.indexOf('touch') >= 0 : false;
      }

      function createPopperInstance() {
        destroyPopperInstance();
        var _instance$props2 = instance.props,
            popperOptions = _instance$props2.popperOptions,
            placement = _instance$props2.placement,
            offset = _instance$props2.offset,
            getReferenceClientRect = _instance$props2.getReferenceClientRect,
            moveTransition = _instance$props2.moveTransition;
        var arrow = getIsDefaultRenderFn() ? getChildren(popper).arrow : null;
        var computedReference = getReferenceClientRect ? {
          getBoundingClientRect: getReferenceClientRect,
          contextElement: getReferenceClientRect.contextElement || getCurrentTarget()
        } : reference;
        var tippyModifier = {
          name: '$$tippy',
          enabled: true,
          phase: 'beforeWrite',
          requires: ['computeStyles'],
          fn: function fn(_ref2) {
            var state = _ref2.state;

            if (getIsDefaultRenderFn()) {
              var _getDefaultTemplateCh = getDefaultTemplateChildren(),
                  box = _getDefaultTemplateCh.box;

              ['placement', 'reference-hidden', 'escaped'].forEach(function (attr) {
                if (attr === 'placement') {
                  box.setAttribute('data-placement', state.placement);
                } else {
                  if (state.attributes.popper["data-popper-" + attr]) {
                    box.setAttribute("data-" + attr, '');
                  } else {
                    box.removeAttribute("data-" + attr);
                  }
                }
              });
              state.attributes.popper = {};
            }
          }
        };
        var modifiers = [{
          name: 'offset',
          options: {
            offset: offset
          }
        }, {
          name: 'preventOverflow',
          options: {
            padding: {
              top: 2,
              bottom: 2,
              left: 5,
              right: 5
            }
          }
        }, {
          name: 'flip',
          options: {
            padding: 5
          }
        }, {
          name: 'computeStyles',
          options: {
            adaptive: !moveTransition
          }
        }, tippyModifier];

        if (getIsDefaultRenderFn() && arrow) {
          modifiers.push({
            name: 'arrow',
            options: {
              element: arrow,
              padding: 3
            }
          });
        }

        modifiers.push.apply(modifiers, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);
        instance.popperInstance = createPopper(computedReference, popper, Object.assign({}, popperOptions, {
          placement: placement,
          onFirstUpdate: onFirstUpdate,
          modifiers: modifiers
        }));
      }

      function destroyPopperInstance() {
        if (instance.popperInstance) {
          instance.popperInstance.destroy();
          instance.popperInstance = null;
        }
      }

      function mount() {
        var appendTo = instance.props.appendTo;
        var parentNode; // By default, we'll append the popper to the triggerTargets's parentNode so
        // it's directly after the reference element so the elements inside the
        // tippy can be tabbed to
        // If there are clipping issues, the user can specify a different appendTo
        // and ensure focus management is handled correctly manually

        var node = getCurrentTarget();

        if (instance.props.interactive && appendTo === defaultProps.appendTo || appendTo === 'parent') {
          parentNode = node.parentNode;
        } else {
          parentNode = invokeWithArgsOrReturn(appendTo, [node]);
        } // The popper element needs to exist on the DOM before its position can be
        // updated as Popper needs to read its dimensions


        if (!parentNode.contains(popper)) {
          parentNode.appendChild(popper);
        }

        createPopperInstance();
      }

      function getNestedPopperTree() {
        return arrayFrom(popper.querySelectorAll('[data-tippy-root]'));
      }

      function scheduleShow(event) {
        instance.clearDelayTimeouts();

        if (event) {
          invokeHook('onTrigger', [instance, event]);
        }

        addDocumentPress();
        var delay = getDelay(true);

        var _getNormalizedTouchSe = getNormalizedTouchSettings(),
            touchValue = _getNormalizedTouchSe[0],
            touchDelay = _getNormalizedTouchSe[1];

        if (currentInput.isTouch && touchValue === 'hold' && touchDelay) {
          delay = touchDelay;
        }

        if (delay) {
          showTimeout = setTimeout(function () {
            instance.show();
          }, delay);
        } else {
          instance.show();
        }
      }

      function scheduleHide(event) {
        instance.clearDelayTimeouts();
        invokeHook('onUntrigger', [instance, event]);

        if (!instance.state.isVisible) {
          removeDocumentPress();
          return;
        } // For interactive tippies, scheduleHide is added to a document.body handler
        // from onMouseLeave so must intercept scheduled hides from mousemove/leave
        // events when trigger contains mouseenter and click, and the tip is
        // currently shown as a result of a click.


        if (instance.props.trigger.indexOf('mouseenter') >= 0 && instance.props.trigger.indexOf('click') >= 0 && ['mouseleave', 'mousemove'].indexOf(event.type) >= 0 && isVisibleFromClick) {
          return;
        }

        var delay = getDelay(false);

        if (delay) {
          hideTimeout = setTimeout(function () {
            if (instance.state.isVisible) {
              instance.hide();
            }
          }, delay);
        } else {
          // Fixes a `transitionend` problem when it fires 1 frame too
          // late sometimes, we don't want hide() to be called.
          scheduleHideAnimationFrame = requestAnimationFrame(function () {
            instance.hide();
          });
        }
      } // ===========================================================================
      //  Public methods
      // ===========================================================================


      function enable() {
        instance.state.isEnabled = true;
      }

      function disable() {
        // Disabling the instance should also hide it
        // https://github.com/atomiks/tippy.js-react/issues/106
        instance.hide();
        instance.state.isEnabled = false;
      }

      function clearDelayTimeouts() {
        clearTimeout(showTimeout);
        clearTimeout(hideTimeout);
        cancelAnimationFrame(scheduleHideAnimationFrame);
      }

      function setProps(partialProps) {

        if (instance.state.isDestroyed) {
          return;
        }

        invokeHook('onBeforeUpdate', [instance, partialProps]);
        removeListeners();
        var prevProps = instance.props;
        var nextProps = evaluateProps(reference, Object.assign({}, instance.props, {}, partialProps, {
          ignoreAttributes: true
        }));
        instance.props = nextProps;
        addListeners();

        if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {
          cleanupInteractiveMouseListeners();
          debouncedOnMouseMove = debounce(onMouseMove, nextProps.interactiveDebounce);
        } // Ensure stale aria-expanded attributes are removed


        if (prevProps.triggerTarget && !nextProps.triggerTarget) {
          normalizeToArray(prevProps.triggerTarget).forEach(function (node) {
            node.removeAttribute('aria-expanded');
          });
        } else if (nextProps.triggerTarget) {
          reference.removeAttribute('aria-expanded');
        }

        handleAriaExpandedAttribute();
        handleStyles();

        if (onUpdate) {
          onUpdate(prevProps, nextProps);
        }

        if (instance.popperInstance) {
          createPopperInstance(); // Fixes an issue with nested tippies if they are all getting re-rendered,
          // and the nested ones get re-rendered first.
          // https://github.com/atomiks/tippyjs-react/issues/177
          // TODO: find a cleaner / more efficient solution(!)

          getNestedPopperTree().forEach(function (nestedPopper) {
            // React (and other UI libs likely) requires a rAF wrapper as it flushes
            // its work in one
            requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);
          });
        }

        invokeHook('onAfterUpdate', [instance, partialProps]);
      }

      function setContent(content) {
        instance.setProps({
          content: content
        });
      }

      function show() {


        var isAlreadyVisible = instance.state.isVisible;
        var isDestroyed = instance.state.isDestroyed;
        var isDisabled = !instance.state.isEnabled;
        var isTouchAndTouchDisabled = currentInput.isTouch && !instance.props.touch;
        var duration = getValueAtIndexOrReturn(instance.props.duration, 0, defaultProps.duration);

        if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) {
          return;
        } // Normalize `disabled` behavior across browsers.
        // Firefox allows events on disabled elements, but Chrome doesn't.
        // Using a wrapper element (i.e. <span>) is recommended.


        if (getCurrentTarget().hasAttribute('disabled')) {
          return;
        }

        invokeHook('onShow', [instance], false);

        if (instance.props.onShow(instance) === false) {
          return;
        }

        instance.state.isVisible = true;

        if (getIsDefaultRenderFn()) {
          popper.style.visibility = 'visible';
        }

        handleStyles();
        addDocumentPress();

        if (!instance.state.isMounted) {
          popper.style.transition = 'none';
        } // If flipping to the opposite side after hiding at least once, the
        // animation will use the wrong placement without resetting the duration


        if (getIsDefaultRenderFn()) {
          var _getDefaultTemplateCh2 = getDefaultTemplateChildren(),
              box = _getDefaultTemplateCh2.box,
              content = _getDefaultTemplateCh2.content;

          setTransitionDuration([box, content], 0);
        }

        onFirstUpdate = function onFirstUpdate() {
          var _instance$popperInsta2;

          if (!instance.state.isVisible || ignoreOnFirstUpdate) {
            return;
          }

          ignoreOnFirstUpdate = true; // reflow

          void popper.offsetHeight;
          popper.style.transition = instance.props.moveTransition;

          if (getIsDefaultRenderFn() && instance.props.animation) {
            var _getDefaultTemplateCh3 = getDefaultTemplateChildren(),
                _box = _getDefaultTemplateCh3.box,
                _content = _getDefaultTemplateCh3.content;

            setTransitionDuration([_box, _content], duration);
            setVisibilityState([_box, _content], 'visible');
          }

          handleAriaContentAttribute();
          handleAriaExpandedAttribute();
          pushIfUnique(mountedInstances, instance); // certain modifiers (e.g. `maxSize`) require a second update after the
          // popper has been positioned for the first time

          (_instance$popperInsta2 = instance.popperInstance) == null ? void 0 : _instance$popperInsta2.forceUpdate();
          instance.state.isMounted = true;
          invokeHook('onMount', [instance]);

          if (instance.props.animation && getIsDefaultRenderFn()) {
            onTransitionedIn(duration, function () {
              instance.state.isShown = true;
              invokeHook('onShown', [instance]);
            });
          }
        };

        mount();
      }

      function hide() {


        var isAlreadyHidden = !instance.state.isVisible;
        var isDestroyed = instance.state.isDestroyed;
        var isDisabled = !instance.state.isEnabled;
        var duration = getValueAtIndexOrReturn(instance.props.duration, 1, defaultProps.duration);

        if (isAlreadyHidden || isDestroyed || isDisabled) {
          return;
        }

        invokeHook('onHide', [instance], false);

        if (instance.props.onHide(instance) === false) {
          return;
        }

        instance.state.isVisible = false;
        instance.state.isShown = false;
        ignoreOnFirstUpdate = false;
        isVisibleFromClick = false;

        if (getIsDefaultRenderFn()) {
          popper.style.visibility = 'hidden';
        }

        cleanupInteractiveMouseListeners();
        removeDocumentPress();
        handleStyles();

        if (getIsDefaultRenderFn()) {
          var _getDefaultTemplateCh4 = getDefaultTemplateChildren(),
              box = _getDefaultTemplateCh4.box,
              content = _getDefaultTemplateCh4.content;

          if (instance.props.animation) {
            setTransitionDuration([box, content], duration);
            setVisibilityState([box, content], 'hidden');
          }
        }

        handleAriaContentAttribute();
        handleAriaExpandedAttribute();

        if (instance.props.animation) {
          if (getIsDefaultRenderFn()) {
            onTransitionedOut(duration, instance.unmount);
          }
        } else {
          instance.unmount();
        }
      }

      function hideWithInteractivity(event) {

        getDocument().addEventListener('mousemove', debouncedOnMouseMove);
        pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);
        debouncedOnMouseMove(event);
      }

      function unmount() {

        if (instance.state.isVisible) {
          instance.hide();
        }

        if (!instance.state.isMounted) {
          return;
        }

        destroyPopperInstance(); // If a popper is not interactive, it will be appended outside the popper
        // tree by default. This seems mainly for interactive tippies, but we should
        // find a workaround if possible

        getNestedPopperTree().forEach(function (nestedPopper) {
          nestedPopper._tippy.unmount();
        });

        if (popper.parentNode) {
          popper.parentNode.removeChild(popper);
        }

        mountedInstances = mountedInstances.filter(function (i) {
          return i !== instance;
        });
        instance.state.isMounted = false;
        invokeHook('onHidden', [instance]);
      }

      function destroy() {

        if (instance.state.isDestroyed) {
          return;
        }

        instance.clearDelayTimeouts();
        instance.unmount();
        removeListeners();
        delete reference._tippy;
        instance.state.isDestroyed = true;
        invokeHook('onDestroy', [instance]);
      }
    }

    function tippy(targets, optionalProps) {
      if (optionalProps === void 0) {
        optionalProps = {};
      }

      var plugins = defaultProps.plugins.concat(optionalProps.plugins || []);

      bindGlobalEventListeners();
      var passedProps = Object.assign({}, optionalProps, {
        plugins: plugins
      });
      var elements = getArrayOfElements(targets);

      var instances = elements.reduce(function (acc, reference) {
        var instance = reference && createTippy(reference, passedProps);

        if (instance) {
          acc.push(instance);
        }

        return acc;
      }, []);
      return isElement(targets) ? instances[0] : instances;
    }

    tippy.defaultProps = defaultProps;
    tippy.setDefaultProps = setDefaultProps;
    tippy.currentInput = currentInput;

    // every time the popper is destroyed (i.e. a new target), removing the styles
    // and causing transitions to break for singletons when the console is open, but
    // most notably for non-transform styles being used, `gpuAcceleration: false`.

    var applyStylesModifier = Object.assign({}, applyStyles$1, {
      effect: function effect(_ref) {
        var state = _ref.state;
        var initialStyles = {
          popper: {
            position: state.options.strategy,
            left: '0',
            top: '0',
            margin: '0'
          },
          arrow: {
            position: 'absolute'
          },
          reference: {}
        };
        Object.assign(state.elements.popper.style, initialStyles.popper);
        state.styles = initialStyles;

        if (state.elements.arrow) {
          Object.assign(state.elements.arrow.style, initialStyles.arrow);
        } // intentionally return no cleanup function
        // return () => { ... }

      }
    });

    var createSingleton = function createSingleton(tippyInstances, optionalProps) {
      var _optionalProps$popper;

      if (optionalProps === void 0) {
        optionalProps = {};
      }

      var individualInstances = tippyInstances;
      var references = [];
      var currentTarget;
      var overrides = optionalProps.overrides;
      var interceptSetPropsCleanups = [];
      var shownOnCreate = false;

      function setReferences() {
        references = individualInstances.map(function (instance) {
          return instance.reference;
        });
      }

      function enableInstances(isEnabled) {
        individualInstances.forEach(function (instance) {
          if (isEnabled) {
            instance.enable();
          } else {
            instance.disable();
          }
        });
      }

      function interceptSetProps(singleton) {
        return individualInstances.map(function (instance) {
          var originalSetProps = instance.setProps;

          instance.setProps = function (props) {
            originalSetProps(props);

            if (instance.reference === currentTarget) {
              singleton.setProps(props);
            }
          };

          return function () {
            instance.setProps = originalSetProps;
          };
        });
      } // have to pass singleton, as it maybe undefined on first call


      function prepareInstance(singleton, target) {
        var index = references.indexOf(target); // bail-out

        if (target === currentTarget) {
          return;
        }

        currentTarget = target;
        var overrideProps = (overrides || []).concat('content').reduce(function (acc, prop) {
          acc[prop] = individualInstances[index].props[prop];
          return acc;
        }, {});
        singleton.setProps(Object.assign({}, overrideProps, {
          getReferenceClientRect: typeof overrideProps.getReferenceClientRect === 'function' ? overrideProps.getReferenceClientRect : function () {
            return target.getBoundingClientRect();
          }
        }));
      }

      enableInstances(false);
      setReferences();
      var plugin = {
        fn: function fn() {
          return {
            onDestroy: function onDestroy() {
              enableInstances(true);
            },
            onHidden: function onHidden() {
              currentTarget = null;
            },
            onClickOutside: function onClickOutside(instance) {
              if (instance.props.showOnCreate && !shownOnCreate) {
                shownOnCreate = true;
                currentTarget = null;
              }
            },
            onShow: function onShow(instance) {
              if (instance.props.showOnCreate && !shownOnCreate) {
                shownOnCreate = true;
                prepareInstance(instance, references[0]);
              }
            },
            onTrigger: function onTrigger(instance, event) {
              prepareInstance(instance, event.currentTarget);
            }
          };
        }
      };
      var singleton = tippy(div(), Object.assign({}, removeProperties(optionalProps, ['overrides']), {
        plugins: [plugin].concat(optionalProps.plugins || []),
        triggerTarget: references,
        popperOptions: Object.assign({}, optionalProps.popperOptions, {
          modifiers: [].concat(((_optionalProps$popper = optionalProps.popperOptions) == null ? void 0 : _optionalProps$popper.modifiers) || [], [applyStylesModifier])
        })
      }));
      var originalShow = singleton.show;

      singleton.show = function (target) {
        originalShow(); // first time, showOnCreate or programmatic call with no params
        // default to showing first instance

        if (!currentTarget && target == null) {
          return prepareInstance(singleton, references[0]);
        } // triggered from event (do nothing as prepareInstance already called by onTrigger)
        // programmatic call with no params when already visible (do nothing again)


        if (currentTarget && target == null) {
          return;
        } // target is index of instance


        if (typeof target === 'number') {
          return references[target] && prepareInstance(singleton, references[target]);
        } // target is a child tippy instance


        if (individualInstances.includes(target)) {
          var ref = target.reference;
          return prepareInstance(singleton, ref);
        } // target is a ReferenceElement


        if (references.includes(target)) {
          return prepareInstance(singleton, target);
        }
      };

      singleton.showNext = function () {
        var first = references[0];

        if (!currentTarget) {
          return singleton.show(0);
        }

        var index = references.indexOf(currentTarget);
        singleton.show(references[index + 1] || first);
      };

      singleton.showPrevious = function () {
        var last = references[references.length - 1];

        if (!currentTarget) {
          return singleton.show(last);
        }

        var index = references.indexOf(currentTarget);
        var target = references[index - 1] || last;
        singleton.show(target);
      };

      var originalSetProps = singleton.setProps;

      singleton.setProps = function (props) {
        overrides = props.overrides || overrides;
        originalSetProps(props);
      };

      singleton.setInstances = function (nextInstances) {
        enableInstances(true);
        interceptSetPropsCleanups.forEach(function (fn) {
          return fn();
        });
        individualInstances = nextInstances;
        enableInstances(false);
        setReferences();
        interceptSetProps(singleton);
        singleton.setProps({
          triggerTarget: references
        });
      };

      interceptSetPropsCleanups = interceptSetProps(singleton);
      return singleton;
    };

    tippy.setDefaultProps({
      render: render
    });

    function useTooltip(selectors, ctx, options = {}) {
        const elementsRefs = selectors.map(selector => queryAll(selector));
        let singleton = null;
        let instances = null;
        const createTooltip = () => {
            const root = closestElement('.kderd-editor', ctx);
            const elements = [
                ...flat(elementsRefs.map(ref => ref.value).filter(elements => isArray$1(elements))),
            ];
            instances = tippy(elements, {
                appendTo: root !== null && root !== void 0 ? root : 'parent',
                trigger: 'manual',
            });
            singleton = createSingleton(instances, Object.assign({
                appendTo: root !== null && root !== void 0 ? root : 'parent',
                delay: [500, 100],
                moveTransition: 'transform 0.4s cubic-bezier(0.22, 1, 0.36, 1)',
            }, options));
        };
        const destroyTooltip = () => {
            singleton === null || singleton === void 0 ? void 0 : singleton.destroy();
            instances === null || instances === void 0 ? void 0 : instances.forEach(instance => instance.destroy());
            singleton = null;
            instances = null;
        };
        const resetTooltip = () => {
            destroyTooltip();
            createTooltip();
        };
        mounted(createTooltip);
        unmounted(destroyTooltip);
        return {
            resetTooltip,
        };
    }

    function useUnmounted() {
        const unmountedGroup = [];
        unmounted(() => {
            while (unmountedGroup.length) {
                const f = unmountedGroup.pop();
                isFunction$1(f) ? f() : f.unsubscribe();
            }
        });
        return {
            unmountedGroup,
        };
    }

    const ContextmenuStyle = css `
  .kderd-contextmenu {
    position: fixed;
    z-index: 1;
    opacity: 0.9;
    color: var(--kderd-color-font);
    fill: var(--kderd-color-font);
    background-color: var(--kderd-color-contextmenu);
    list-style: none;
    padding: 0;
    margin: 0;
    display: flex;
    flex-direction: column;
    font-family: var(--kderd-font-family) !important;
  }
  .kderd-contextmenu > li {
    height: ${SIZE_CONTEXTMENU_HEIGHT}px;
    padding: 10px 5px 10px 10px;
    box-sizing: border-box;
    cursor: pointer;
    font-size: ${SIZE_FONT}px;
    white-space: nowrap;
    display: flex;
    flex-direction: row;
    align-items: center;
  }
  .kderd-contextmenu > li:hover {
    color: var(--kderd-color-font-active);
    fill: var(--kderd-color-font-active);
    background-color: var(--kderd-color-contextmenu-active);
  }
  .kderd-contextmenu > li > span {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    padding-right: 5px;
  }
  .kderd-contextmenu > li > span.icon,
  .kderd-contextmenu > li > span.icon > img {
    width: 18px;
    display: flex;
    align-items: center;
  }
  .kderd-contextmenu > li > span.name {
    width: 70px;
    height: 17px;
  }
  .kderd-contextmenu > li > span.keymap {
    width: 60px;
    display: inline-block;
    padding-right: 0;
  }
  .kderd-contextmenu > li > span.arrow {
    width: 13px;
    padding-right: 0;
  }
`;

    const iconTpl = (menu) => menu.icon
        ? html `
        <span class="icon">
          <kderd-icon
            .prefix=${menu.icon.prefix}
            .size=${menu.icon.size || 14}
            name=${menu.icon.name}
          >
          </kderd-icon>
        </span>
      `
        : menu.iconBase64
            ? html `
        <span class="icon">
          <img src=${menu.iconBase64} />
        </span>
      `
            : html `<span class="icon"></span>`;

    const Contextmenu$1 = (props, ctx) => {
        const state = observable$1({ menu: null });
        const rootRef = query('.kderd-contextmenu');
        const { unmountedGroup } = useUnmounted();
        const { resetTooltip } = useTooltip(['.keymap'], ctx);
        const childrenX = () => {
            const ul = rootRef.value;
            return ul ? props.x + ul.clientWidth : props.x;
        };
        const childrenY = () => state.menu
            ? props.y + props.menus.indexOf(state.menu) * SIZE_CONTEXTMENU_HEIGHT
            : props.y;
        const onMouseover = (menu) => (state.menu = menu);
        const onClose = () => ctx.dispatchEvent(new CustomEvent('close'));
        const onExecute = (menu) => {
            var _a;
            if (!menu.execute || ((_a = menu.children) === null || _a === void 0 ? void 0 : _a.length))
                return;
            menu.execute();
            if (!menu.options || menu.options.close !== false) {
                onClose();
            }
        };
        const createContextmenuEvent = (eventName) => (event) => {
            event.stopPropagation();
            ctx.dispatchEvent(new CustomEvent(eventName, {
                composed: true,
                bubbles: true,
            }));
        };
        const onMousedown = createContextmenuEvent('kderd-contextmenu-mousedown');
        const onTouchstart = createContextmenuEvent('kderd-contextmenu-touchstart');
        unmountedGroup.push(watch(props, propName => {
            if (propName !== 'menus')
                return;
            state.menu = null;
            resetTooltip();
        }));
        unmounted(() => (state.menu = null));
        return () => {
            var _a, _b;
            return html `
      <ul
        class="kderd-contextmenu"
        style=${styleMap({
            left: `${props.x}px`,
            top: `${props.y}px`,
        })}
        @mousedown=${onMousedown}
        @touchstart=${onTouchstart}
      >
        ${props.menus.map(menu => {
            var _a, _b, _c, _d;
            return html `
            <li
              @mouseover=${() => onMouseover(menu)}
              @click=${() => onExecute(menu)}
            >
              ${iconTpl(menu)}
              <span
                class="name"
                style=${styleMap({
                width: `${(_b = (_a = menu.options) === null || _a === void 0 ? void 0 : _a.nameWidth) !== null && _b !== void 0 ? _b : 70}px`,
            })}
                title=${menu.name}
              >
                ${menu.name}
              </span>
              <span
                class="keymap"
                style=${styleMap({
                width: `${(_d = (_c = menu.options) === null || _c === void 0 ? void 0 : _c.keymapWidth) !== null && _d !== void 0 ? _d : 60}px`,
            })}
                data-tippy-content=${menu.keymapTooltip
                ? menu.keymapTooltip
                : ''}
              >
                ${menu.keymap}
              </span>
              ${menu.children && menu.children.length
                ? html `
                    <span class="arrow">
                      <kderd-icon size="13" name="chevron-right"></kderd-icon>
                    </span>
                  `
                : null}
            </li>
          `;
        })}
      </ul>
      ${((_b = (_a = state.menu) === null || _a === void 0 ? void 0 : _a.children) === null || _b === void 0 ? void 0 : _b.length)
            ? html `
            <kderd-contextmenu
              .menus=${state.menu.children}
              .x=${childrenX()}
              .y=${childrenY()}
              @close=${onClose}
            ></kderd-contextmenu>
          `
            : null}
    `;
        };
    };
    defineComponent('kderd-contextmenu', {
        observedProps: [
            {
                name: 'x',
                type: Number,
                default: 0,
            },
            {
                name: 'y',
                type: Number,
                default: 0,
            },
            'menus',
        ],
        style: ContextmenuStyle,
        render: Contextmenu$1,
    });

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spreadArray(to, from) {
        for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
            to[j] = from[i];
        return to;
    }

    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }

    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    }

    function __asyncValues(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    }

    function isFunction(value) {
        return typeof value === 'function';
    }

    function createErrorClass(createImpl) {
        var _super = function (instance) {
            Error.call(instance);
            instance.stack = new Error().stack;
        };
        var ctorFunc = createImpl(_super);
        ctorFunc.prototype = Object.create(Error.prototype);
        ctorFunc.prototype.constructor = ctorFunc;
        return ctorFunc;
    }

    var UnsubscriptionError = createErrorClass(function (_super) {
        return function UnsubscriptionErrorImpl(errors) {
            _super(this);
            this.message = errors
                ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) { return i + 1 + ") " + err.toString(); }).join('\n  ')
                : '';
            this.name = 'UnsubscriptionError';
            this.errors = errors;
        };
    });

    function arrRemove(arr, item) {
        if (arr) {
            var index = arr.indexOf(item);
            0 <= index && arr.splice(index, 1);
        }
    }

    var Subscription = (function () {
        function Subscription(initialTeardown) {
            this.initialTeardown = initialTeardown;
            this.closed = false;
            this._parentage = null;
            this._teardowns = null;
        }
        Subscription.prototype.unsubscribe = function () {
            var e_1, _a, e_2, _b;
            var errors;
            if (!this.closed) {
                this.closed = true;
                var _parentage = this._parentage;
                if (_parentage) {
                    this._parentage = null;
                    if (Array.isArray(_parentage)) {
                        try {
                            for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
                                var parent_1 = _parentage_1_1.value;
                                parent_1.remove(this);
                            }
                        }
                        catch (e_1_1) { e_1 = { error: e_1_1 }; }
                        finally {
                            try {
                                if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return)) _a.call(_parentage_1);
                            }
                            finally { if (e_1) throw e_1.error; }
                        }
                    }
                    else {
                        _parentage.remove(this);
                    }
                }
                var initialTeardown = this.initialTeardown;
                if (isFunction(initialTeardown)) {
                    try {
                        initialTeardown();
                    }
                    catch (e) {
                        errors = e instanceof UnsubscriptionError ? e.errors : [e];
                    }
                }
                var _teardowns = this._teardowns;
                if (_teardowns) {
                    this._teardowns = null;
                    try {
                        for (var _teardowns_1 = __values(_teardowns), _teardowns_1_1 = _teardowns_1.next(); !_teardowns_1_1.done; _teardowns_1_1 = _teardowns_1.next()) {
                            var teardown_1 = _teardowns_1_1.value;
                            try {
                                execTeardown(teardown_1);
                            }
                            catch (err) {
                                errors = errors !== null && errors !== void 0 ? errors : [];
                                if (err instanceof UnsubscriptionError) {
                                    errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
                                }
                                else {
                                    errors.push(err);
                                }
                            }
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (_teardowns_1_1 && !_teardowns_1_1.done && (_b = _teardowns_1.return)) _b.call(_teardowns_1);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                }
                if (errors) {
                    throw new UnsubscriptionError(errors);
                }
            }
        };
        Subscription.prototype.add = function (teardown) {
            var _a;
            if (teardown && teardown !== this) {
                if (this.closed) {
                    execTeardown(teardown);
                }
                else {
                    if (teardown instanceof Subscription) {
                        if (teardown.closed || teardown._hasParent(this)) {
                            return;
                        }
                        teardown._addParent(this);
                    }
                    (this._teardowns = (_a = this._teardowns) !== null && _a !== void 0 ? _a : []).push(teardown);
                }
            }
        };
        Subscription.prototype._hasParent = function (parent) {
            var _parentage = this._parentage;
            return _parentage === parent || (Array.isArray(_parentage) && _parentage.includes(parent));
        };
        Subscription.prototype._addParent = function (parent) {
            var _parentage = this._parentage;
            this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
        };
        Subscription.prototype._removeParent = function (parent) {
            var _parentage = this._parentage;
            if (_parentage === parent) {
                this._parentage = null;
            }
            else if (Array.isArray(_parentage)) {
                arrRemove(_parentage, parent);
            }
        };
        Subscription.prototype.remove = function (teardown) {
            var _teardowns = this._teardowns;
            _teardowns && arrRemove(_teardowns, teardown);
            if (teardown instanceof Subscription) {
                teardown._removeParent(this);
            }
        };
        Subscription.EMPTY = (function () {
            var empty = new Subscription();
            empty.closed = true;
            return empty;
        })();
        return Subscription;
    }());
    var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
    function isSubscription(value) {
        return (value instanceof Subscription ||
            (value && 'closed' in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe)));
    }
    function execTeardown(teardown) {
        if (isFunction(teardown)) {
            teardown();
        }
        else {
            teardown.unsubscribe();
        }
    }

    var config = {
        onUnhandledError: null,
        onStoppedNotification: null,
        Promise: undefined,
        useDeprecatedSynchronousErrorHandling: false,
        useDeprecatedNextContext: false,
    };

    var timeoutProvider = {
        setTimeout: function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var delegate = timeoutProvider.delegate;
            return ((delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) || setTimeout).apply(void 0, __spreadArray([], __read(args)));
        },
        clearTimeout: function (handle) {
            var delegate = timeoutProvider.delegate;
            return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
        },
        delegate: undefined,
    };

    function reportUnhandledError(err) {
        timeoutProvider.setTimeout(function () {
            {
                throw err;
            }
        });
    }

    function noop() { }

    var context = null;
    function errorContext(cb) {
        if (config.useDeprecatedSynchronousErrorHandling) {
            var isRoot = !context;
            if (isRoot) {
                context = { errorThrown: false, error: null };
            }
            cb();
            if (isRoot) {
                var _a = context, errorThrown = _a.errorThrown, error = _a.error;
                context = null;
                if (errorThrown) {
                    throw error;
                }
            }
        }
        else {
            cb();
        }
    }

    var Subscriber = (function (_super) {
        __extends(Subscriber, _super);
        function Subscriber(destination) {
            var _this = _super.call(this) || this;
            _this.isStopped = false;
            if (destination) {
                _this.destination = destination;
                if (isSubscription(destination)) {
                    destination.add(_this);
                }
            }
            else {
                _this.destination = EMPTY_OBSERVER;
            }
            return _this;
        }
        Subscriber.create = function (next, error, complete) {
            return new SafeSubscriber(next, error, complete);
        };
        Subscriber.prototype.next = function (value) {
            if (this.isStopped) ;
            else {
                this._next(value);
            }
        };
        Subscriber.prototype.error = function (err) {
            if (this.isStopped) ;
            else {
                this.isStopped = true;
                this._error(err);
            }
        };
        Subscriber.prototype.complete = function () {
            if (this.isStopped) ;
            else {
                this.isStopped = true;
                this._complete();
            }
        };
        Subscriber.prototype.unsubscribe = function () {
            if (!this.closed) {
                this.isStopped = true;
                _super.prototype.unsubscribe.call(this);
                this.destination = null;
            }
        };
        Subscriber.prototype._next = function (value) {
            this.destination.next(value);
        };
        Subscriber.prototype._error = function (err) {
            try {
                this.destination.error(err);
            }
            finally {
                this.unsubscribe();
            }
        };
        Subscriber.prototype._complete = function () {
            try {
                this.destination.complete();
            }
            finally {
                this.unsubscribe();
            }
        };
        return Subscriber;
    }(Subscription));
    var SafeSubscriber = (function (_super) {
        __extends(SafeSubscriber, _super);
        function SafeSubscriber(observerOrNext, error, complete) {
            var _this = _super.call(this) || this;
            var next;
            if (isFunction(observerOrNext)) {
                next = observerOrNext;
            }
            else if (observerOrNext) {
                (next = observerOrNext.next, error = observerOrNext.error, complete = observerOrNext.complete);
                var context_1;
                if (_this && config.useDeprecatedNextContext) {
                    context_1 = Object.create(observerOrNext);
                    context_1.unsubscribe = function () { return _this.unsubscribe(); };
                }
                else {
                    context_1 = observerOrNext;
                }
                next = next === null || next === void 0 ? void 0 : next.bind(context_1);
                error = error === null || error === void 0 ? void 0 : error.bind(context_1);
                complete = complete === null || complete === void 0 ? void 0 : complete.bind(context_1);
            }
            _this.destination = {
                next: next ? wrapForErrorHandling(next) : noop,
                error: wrapForErrorHandling(error !== null && error !== void 0 ? error : defaultErrorHandler),
                complete: complete ? wrapForErrorHandling(complete) : noop,
            };
            return _this;
        }
        return SafeSubscriber;
    }(Subscriber));
    function wrapForErrorHandling(handler, instance) {
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            try {
                handler.apply(void 0, __spreadArray([], __read(args)));
            }
            catch (err) {
                {
                    reportUnhandledError(err);
                }
            }
        };
    }
    function defaultErrorHandler(err) {
        throw err;
    }
    var EMPTY_OBSERVER = {
        closed: true,
        next: noop,
        error: defaultErrorHandler,
        complete: noop,
    };

    var observable = (function () { return (typeof Symbol === 'function' && Symbol.observable) || '@@observable'; })();

    function identity(x) {
        return x;
    }

    function pipeFromArray(fns) {
        if (fns.length === 0) {
            return identity;
        }
        if (fns.length === 1) {
            return fns[0];
        }
        return function piped(input) {
            return fns.reduce(function (prev, fn) { return fn(prev); }, input);
        };
    }

    var Observable = (function () {
        function Observable(subscribe) {
            if (subscribe) {
                this._subscribe = subscribe;
            }
        }
        Observable.prototype.lift = function (operator) {
            var observable = new Observable();
            observable.source = this;
            observable.operator = operator;
            return observable;
        };
        Observable.prototype.subscribe = function (observerOrNext, error, complete) {
            var _this = this;
            var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
            errorContext(function () {
                var _a = _this, operator = _a.operator, source = _a.source;
                subscriber.add(operator
                    ?
                        operator.call(subscriber, source)
                    : source
                        ?
                            _this._subscribe(subscriber)
                        :
                            _this._trySubscribe(subscriber));
            });
            return subscriber;
        };
        Observable.prototype._trySubscribe = function (sink) {
            try {
                return this._subscribe(sink);
            }
            catch (err) {
                sink.error(err);
            }
        };
        Observable.prototype.forEach = function (next, promiseCtor) {
            var _this = this;
            promiseCtor = getPromiseCtor(promiseCtor);
            return new promiseCtor(function (resolve, reject) {
                var subscription;
                subscription = _this.subscribe(function (value) {
                    try {
                        next(value);
                    }
                    catch (err) {
                        reject(err);
                        subscription === null || subscription === void 0 ? void 0 : subscription.unsubscribe();
                    }
                }, reject, resolve);
            });
        };
        Observable.prototype._subscribe = function (subscriber) {
            var _a;
            return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
        };
        Observable.prototype[observable] = function () {
            return this;
        };
        Observable.prototype.pipe = function () {
            var operations = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                operations[_i] = arguments[_i];
            }
            return pipeFromArray(operations)(this);
        };
        Observable.prototype.toPromise = function (promiseCtor) {
            var _this = this;
            promiseCtor = getPromiseCtor(promiseCtor);
            return new promiseCtor(function (resolve, reject) {
                var value;
                _this.subscribe(function (x) { return (value = x); }, function (err) { return reject(err); }, function () { return resolve(value); });
            });
        };
        Observable.create = function (subscribe) {
            return new Observable(subscribe);
        };
        return Observable;
    }());
    function getPromiseCtor(promiseCtor) {
        var _a;
        return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;
    }
    function isObserver(value) {
        return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
    }
    function isSubscriber(value) {
        return (value && value instanceof Subscriber) || (isObserver(value) && isSubscription(value));
    }

    function hasLift(source) {
        return isFunction(source === null || source === void 0 ? void 0 : source.lift);
    }
    function operate(init) {
        return function (source) {
            if (hasLift(source)) {
                return source.lift(function (liftedSource) {
                    try {
                        return init(liftedSource, this);
                    }
                    catch (err) {
                        this.error(err);
                    }
                });
            }
            throw new TypeError('Unable to lift unknown Observable type');
        };
    }

    var OperatorSubscriber = (function (_super) {
        __extends(OperatorSubscriber, _super);
        function OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
            var _this = _super.call(this, destination) || this;
            _this.onFinalize = onFinalize;
            _this._next = onNext
                ? function (value) {
                    try {
                        onNext(value);
                    }
                    catch (err) {
                        destination.error(err);
                    }
                }
                : _super.prototype._next;
            _this._error = onError
                ? function (err) {
                    try {
                        onError(err);
                    }
                    catch (err) {
                        destination.error(err);
                    }
                    finally {
                        this.unsubscribe();
                    }
                }
                : _super.prototype._error;
            _this._complete = onComplete
                ? function () {
                    try {
                        onComplete();
                    }
                    catch (err) {
                        destination.error(err);
                    }
                    finally {
                        this.unsubscribe();
                    }
                }
                : _super.prototype._complete;
            return _this;
        }
        OperatorSubscriber.prototype.unsubscribe = function () {
            var _a;
            var closed = this.closed;
            _super.prototype.unsubscribe.call(this);
            !closed && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
        };
        return OperatorSubscriber;
    }(Subscriber));

    var ObjectUnsubscribedError = createErrorClass(function (_super) {
        return function ObjectUnsubscribedErrorImpl() {
            _super(this);
            this.name = 'ObjectUnsubscribedError';
            this.message = 'object unsubscribed';
        };
    });

    var Subject = (function (_super) {
        __extends(Subject, _super);
        function Subject() {
            var _this = _super.call(this) || this;
            _this.closed = false;
            _this.observers = [];
            _this.isStopped = false;
            _this.hasError = false;
            _this.thrownError = null;
            return _this;
        }
        Subject.prototype.lift = function (operator) {
            var subject = new AnonymousSubject(this, this);
            subject.operator = operator;
            return subject;
        };
        Subject.prototype._throwIfClosed = function () {
            if (this.closed) {
                throw new ObjectUnsubscribedError();
            }
        };
        Subject.prototype.next = function (value) {
            var _this = this;
            errorContext(function () {
                var e_1, _a;
                _this._throwIfClosed();
                if (!_this.isStopped) {
                    var copy = _this.observers.slice();
                    try {
                        for (var copy_1 = __values(copy), copy_1_1 = copy_1.next(); !copy_1_1.done; copy_1_1 = copy_1.next()) {
                            var observer = copy_1_1.value;
                            observer.next(value);
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (copy_1_1 && !copy_1_1.done && (_a = copy_1.return)) _a.call(copy_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                }
            });
        };
        Subject.prototype.error = function (err) {
            var _this = this;
            errorContext(function () {
                _this._throwIfClosed();
                if (!_this.isStopped) {
                    _this.hasError = _this.isStopped = true;
                    _this.thrownError = err;
                    var observers = _this.observers;
                    while (observers.length) {
                        observers.shift().error(err);
                    }
                }
            });
        };
        Subject.prototype.complete = function () {
            var _this = this;
            errorContext(function () {
                _this._throwIfClosed();
                if (!_this.isStopped) {
                    _this.isStopped = true;
                    var observers = _this.observers;
                    while (observers.length) {
                        observers.shift().complete();
                    }
                }
            });
        };
        Subject.prototype.unsubscribe = function () {
            this.isStopped = this.closed = true;
            this.observers = null;
        };
        Object.defineProperty(Subject.prototype, "observed", {
            get: function () {
                var _a;
                return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
            },
            enumerable: false,
            configurable: true
        });
        Subject.prototype._trySubscribe = function (subscriber) {
            this._throwIfClosed();
            return _super.prototype._trySubscribe.call(this, subscriber);
        };
        Subject.prototype._subscribe = function (subscriber) {
            this._throwIfClosed();
            this._checkFinalizedStatuses(subscriber);
            return this._innerSubscribe(subscriber);
        };
        Subject.prototype._innerSubscribe = function (subscriber) {
            var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
            return hasError || isStopped
                ? EMPTY_SUBSCRIPTION
                : (observers.push(subscriber), new Subscription(function () { return arrRemove(observers, subscriber); }));
        };
        Subject.prototype._checkFinalizedStatuses = function (subscriber) {
            var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
            if (hasError) {
                subscriber.error(thrownError);
            }
            else if (isStopped) {
                subscriber.complete();
            }
        };
        Subject.prototype.asObservable = function () {
            var observable = new Observable();
            observable.source = this;
            return observable;
        };
        Subject.create = function (destination, source) {
            return new AnonymousSubject(destination, source);
        };
        return Subject;
    }(Observable));
    var AnonymousSubject = (function (_super) {
        __extends(AnonymousSubject, _super);
        function AnonymousSubject(destination, source) {
            var _this = _super.call(this) || this;
            _this.destination = destination;
            _this.source = source;
            return _this;
        }
        AnonymousSubject.prototype.next = function (value) {
            var _a, _b;
            (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
        };
        AnonymousSubject.prototype.error = function (err) {
            var _a, _b;
            (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
        };
        AnonymousSubject.prototype.complete = function () {
            var _a, _b;
            (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
        };
        AnonymousSubject.prototype._subscribe = function (subscriber) {
            var _a, _b;
            return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
        };
        return AnonymousSubject;
    }(Subject));

    var dateTimestampProvider = {
        now: function () {
            return (dateTimestampProvider.delegate || Date).now();
        },
        delegate: undefined,
    };

    var Action = (function (_super) {
        __extends(Action, _super);
        function Action(scheduler, work) {
            return _super.call(this) || this;
        }
        Action.prototype.schedule = function (state, delay) {
            return this;
        };
        return Action;
    }(Subscription));

    var intervalProvider = {
        setInterval: function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var delegate = intervalProvider.delegate;
            return ((delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) || setInterval).apply(void 0, __spreadArray([], __read(args)));
        },
        clearInterval: function (handle) {
            var delegate = intervalProvider.delegate;
            return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
        },
        delegate: undefined,
    };

    var AsyncAction = (function (_super) {
        __extends(AsyncAction, _super);
        function AsyncAction(scheduler, work) {
            var _this = _super.call(this, scheduler, work) || this;
            _this.scheduler = scheduler;
            _this.work = work;
            _this.pending = false;
            return _this;
        }
        AsyncAction.prototype.schedule = function (state, delay) {
            if (delay === void 0) { delay = 0; }
            if (this.closed) {
                return this;
            }
            this.state = state;
            var id = this.id;
            var scheduler = this.scheduler;
            if (id != null) {
                this.id = this.recycleAsyncId(scheduler, id, delay);
            }
            this.pending = true;
            this.delay = delay;
            this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
            return this;
        };
        AsyncAction.prototype.requestAsyncId = function (scheduler, _id, delay) {
            if (delay === void 0) { delay = 0; }
            return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);
        };
        AsyncAction.prototype.recycleAsyncId = function (_scheduler, id, delay) {
            if (delay === void 0) { delay = 0; }
            if (delay != null && this.delay === delay && this.pending === false) {
                return id;
            }
            intervalProvider.clearInterval(id);
            return undefined;
        };
        AsyncAction.prototype.execute = function (state, delay) {
            if (this.closed) {
                return new Error('executing a cancelled action');
            }
            this.pending = false;
            var error = this._execute(state, delay);
            if (error) {
                return error;
            }
            else if (this.pending === false && this.id != null) {
                this.id = this.recycleAsyncId(this.scheduler, this.id, null);
            }
        };
        AsyncAction.prototype._execute = function (state, _delay) {
            var errored = false;
            var errorValue;
            try {
                this.work(state);
            }
            catch (e) {
                errored = true;
                errorValue = (!!e && e) || new Error(e);
            }
            if (errored) {
                this.unsubscribe();
                return errorValue;
            }
        };
        AsyncAction.prototype.unsubscribe = function () {
            if (!this.closed) {
                var _a = this, id = _a.id, scheduler = _a.scheduler;
                var actions = scheduler.actions;
                this.work = this.state = this.scheduler = null;
                this.pending = false;
                arrRemove(actions, this);
                if (id != null) {
                    this.id = this.recycleAsyncId(scheduler, id, null);
                }
                this.delay = null;
                _super.prototype.unsubscribe.call(this);
            }
        };
        return AsyncAction;
    }(Action));

    var Scheduler = (function () {
        function Scheduler(schedulerActionCtor, now) {
            if (now === void 0) { now = Scheduler.now; }
            this.schedulerActionCtor = schedulerActionCtor;
            this.now = now;
        }
        Scheduler.prototype.schedule = function (work, delay, state) {
            if (delay === void 0) { delay = 0; }
            return new this.schedulerActionCtor(this, work).schedule(state, delay);
        };
        Scheduler.now = dateTimestampProvider.now;
        return Scheduler;
    }());

    var AsyncScheduler = (function (_super) {
        __extends(AsyncScheduler, _super);
        function AsyncScheduler(SchedulerAction, now) {
            if (now === void 0) { now = Scheduler.now; }
            var _this = _super.call(this, SchedulerAction, now) || this;
            _this.actions = [];
            _this._active = false;
            _this._scheduled = undefined;
            return _this;
        }
        AsyncScheduler.prototype.flush = function (action) {
            var actions = this.actions;
            if (this._active) {
                actions.push(action);
                return;
            }
            var error;
            this._active = true;
            do {
                if ((error = action.execute(action.state, action.delay))) {
                    break;
                }
            } while ((action = actions.shift()));
            this._active = false;
            if (error) {
                while ((action = actions.shift())) {
                    action.unsubscribe();
                }
                throw error;
            }
        };
        return AsyncScheduler;
    }(Scheduler));

    var asyncScheduler = new AsyncScheduler(AsyncAction);
    var async = asyncScheduler;

    var EMPTY = new Observable(function (subscriber) { return subscriber.complete(); });

    function scheduleArray(input, scheduler) {
        return new Observable(function (subscriber) {
            var i = 0;
            return scheduler.schedule(function () {
                if (i === input.length) {
                    subscriber.complete();
                }
                else {
                    subscriber.next(input[i++]);
                    if (!subscriber.closed) {
                        this.schedule();
                    }
                }
            });
        });
    }

    var isArrayLike = (function (x) { return x && typeof x.length === 'number' && typeof x !== 'function'; });

    function isPromise(value) {
        return isFunction(value === null || value === void 0 ? void 0 : value.then);
    }

    function getSymbolIterator() {
        if (typeof Symbol !== 'function' || !Symbol.iterator) {
            return '@@iterator';
        }
        return Symbol.iterator;
    }
    var iterator = getSymbolIterator();

    function isInteropObservable(input) {
        return isFunction(input[observable]);
    }

    function isIterable(input) {
        return isFunction(input === null || input === void 0 ? void 0 : input[iterator]);
    }

    function isAsyncIterable(obj) {
        return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
    }

    function createInvalidObservableTypeError(input) {
        return new TypeError("You provided " + (input !== null && typeof input === 'object' ? 'an invalid object' : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
    }

    function readableStreamLikeToAsyncGenerator(readableStream) {
        return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
            var reader, _a, value, done;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        reader = readableStream.getReader();
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, , 9, 10]);
                        _b.label = 2;
                    case 2:
                        return [4, __await(reader.read())];
                    case 3:
                        _a = _b.sent(), value = _a.value, done = _a.done;
                        if (!done) return [3, 5];
                        return [4, __await(void 0)];
                    case 4: return [2, _b.sent()];
                    case 5: return [4, __await(value)];
                    case 6: return [4, _b.sent()];
                    case 7:
                        _b.sent();
                        return [3, 2];
                    case 8: return [3, 10];
                    case 9:
                        reader.releaseLock();
                        return [7];
                    case 10: return [2];
                }
            });
        });
    }
    function isReadableStreamLike(obj) {
        return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
    }

    function innerFrom(input) {
        if (input instanceof Observable) {
            return input;
        }
        if (input != null) {
            if (isInteropObservable(input)) {
                return fromInteropObservable(input);
            }
            if (isArrayLike(input)) {
                return fromArrayLike(input);
            }
            if (isPromise(input)) {
                return fromPromise(input);
            }
            if (isAsyncIterable(input)) {
                return fromAsyncIterable(input);
            }
            if (isIterable(input)) {
                return fromIterable(input);
            }
            if (isReadableStreamLike(input)) {
                return fromReadableStreamLike(input);
            }
        }
        throw createInvalidObservableTypeError(input);
    }
    function fromInteropObservable(obj) {
        return new Observable(function (subscriber) {
            var obs = obj[observable]();
            if (isFunction(obs.subscribe)) {
                return obs.subscribe(subscriber);
            }
            throw new TypeError('Provided object does not correctly implement Symbol.observable');
        });
    }
    function fromArrayLike(array) {
        return new Observable(function (subscriber) {
            for (var i = 0; i < array.length && !subscriber.closed; i++) {
                subscriber.next(array[i]);
            }
            subscriber.complete();
        });
    }
    function fromPromise(promise) {
        return new Observable(function (subscriber) {
            promise
                .then(function (value) {
                if (!subscriber.closed) {
                    subscriber.next(value);
                    subscriber.complete();
                }
            }, function (err) { return subscriber.error(err); })
                .then(null, reportUnhandledError);
        });
    }
    function fromIterable(iterable) {
        return new Observable(function (subscriber) {
            var e_1, _a;
            try {
                for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
                    var value = iterable_1_1.value;
                    subscriber.next(value);
                    if (subscriber.closed) {
                        return;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) _a.call(iterable_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            subscriber.complete();
        });
    }
    function fromAsyncIterable(asyncIterable) {
        return new Observable(function (subscriber) {
            process$1(asyncIterable, subscriber).catch(function (err) { return subscriber.error(err); });
        });
    }
    function fromReadableStreamLike(readableStream) {
        return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
    }
    function process$1(asyncIterable, subscriber) {
        var asyncIterable_1, asyncIterable_1_1;
        var e_2, _a;
        return __awaiter(this, void 0, void 0, function () {
            var value, e_2_1;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 5, 6, 11]);
                        asyncIterable_1 = __asyncValues(asyncIterable);
                        _b.label = 1;
                    case 1: return [4, asyncIterable_1.next()];
                    case 2:
                        if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done)) return [3, 4];
                        value = asyncIterable_1_1.value;
                        subscriber.next(value);
                        if (subscriber.closed) {
                            return [2];
                        }
                        _b.label = 3;
                    case 3: return [3, 1];
                    case 4: return [3, 11];
                    case 5:
                        e_2_1 = _b.sent();
                        e_2 = { error: e_2_1 };
                        return [3, 11];
                    case 6:
                        _b.trys.push([6, , 9, 10]);
                        if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return))) return [3, 8];
                        return [4, _a.call(asyncIterable_1)];
                    case 7:
                        _b.sent();
                        _b.label = 8;
                    case 8: return [3, 10];
                    case 9:
                        if (e_2) throw e_2.error;
                        return [7];
                    case 10: return [7];
                    case 11:
                        subscriber.complete();
                        return [2];
                }
            });
        });
    }

    function internalFromArray(input, scheduler) {
        return scheduler ? scheduleArray(input, scheduler) : fromArrayLike(input);
    }

    function isScheduler(value) {
        return value && isFunction(value.schedule);
    }

    function last(arr) {
        return arr[arr.length - 1];
    }
    function popScheduler(args) {
        return isScheduler(last(args)) ? args.pop() : undefined;
    }
    function popNumber(args, defaultValue) {
        return typeof last(args) === 'number' ? args.pop() : defaultValue;
    }

    function isValidDate(value) {
        return value instanceof Date && !isNaN(value);
    }

    function map(project, thisArg) {
        return operate(function (source, subscriber) {
            var index = 0;
            source.subscribe(new OperatorSubscriber(subscriber, function (value) {
                subscriber.next(project.call(thisArg, value, index++));
            }));
        });
    }

    var isArray = Array.isArray;
    function callOrApply(fn, args) {
        return isArray(args) ? fn.apply(void 0, __spreadArray([], __read(args))) : fn(args);
    }
    function mapOneOrManyArgs(fn) {
        return map(function (args) { return callOrApply(fn, args); });
    }

    function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalTeardown) {
        var buffer = [];
        var active = 0;
        var index = 0;
        var isComplete = false;
        var checkComplete = function () {
            if (isComplete && !buffer.length && !active) {
                subscriber.complete();
            }
        };
        var outerNext = function (value) { return (active < concurrent ? doInnerSub(value) : buffer.push(value)); };
        var doInnerSub = function (value) {
            expand && subscriber.next(value);
            active++;
            var innerComplete = false;
            innerFrom(project(value, index++)).subscribe(new OperatorSubscriber(subscriber, function (innerValue) {
                onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
                if (expand) {
                    outerNext(innerValue);
                }
                else {
                    subscriber.next(innerValue);
                }
            }, function () {
                innerComplete = true;
            }, undefined, function () {
                if (innerComplete) {
                    try {
                        active--;
                        var _loop_1 = function () {
                            var bufferedValue = buffer.shift();
                            innerSubScheduler ? subscriber.add(innerSubScheduler.schedule(function () { return doInnerSub(bufferedValue); })) : doInnerSub(bufferedValue);
                        };
                        while (buffer.length && active < concurrent) {
                            _loop_1();
                        }
                        checkComplete();
                    }
                    catch (err) {
                        subscriber.error(err);
                    }
                }
            }));
        };
        source.subscribe(new OperatorSubscriber(subscriber, outerNext, function () {
            isComplete = true;
            checkComplete();
        }));
        return function () {
            additionalTeardown === null || additionalTeardown === void 0 ? void 0 : additionalTeardown();
        };
    }

    function mergeMap(project, resultSelector, concurrent) {
        if (concurrent === void 0) { concurrent = Infinity; }
        if (isFunction(resultSelector)) {
            return mergeMap(function (a, i) { return map(function (b, ii) { return resultSelector(a, b, i, ii); })(innerFrom(project(a, i))); }, concurrent);
        }
        else if (typeof resultSelector === 'number') {
            concurrent = resultSelector;
        }
        return operate(function (source, subscriber) { return mergeInternals(source, subscriber, project, concurrent); });
    }

    function mergeAll(concurrent) {
        if (concurrent === void 0) { concurrent = Infinity; }
        return mergeMap(identity, concurrent);
    }

    var nodeEventEmitterMethods = ['addListener', 'removeListener'];
    var eventTargetMethods = ['addEventListener', 'removeEventListener'];
    var jqueryMethods = ['on', 'off'];
    function fromEvent(target, eventName, options, resultSelector) {
        if (isFunction(options)) {
            resultSelector = options;
            options = undefined;
        }
        if (resultSelector) {
            return fromEvent(target, eventName, options).pipe(mapOneOrManyArgs(resultSelector));
        }
        var _a = __read(isEventTarget(target)
            ? eventTargetMethods.map(function (methodName) { return function (handler) { return target[methodName](eventName, handler, options); }; })
            :
                isNodeStyleEventEmitter(target)
                    ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName))
                    : isJQueryStyleEventEmitter(target)
                        ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName))
                        : [], 2), add = _a[0], remove = _a[1];
        if (!add) {
            if (isArrayLike(target)) {
                return mergeMap(function (subTarget) { return fromEvent(subTarget, eventName, options); })(internalFromArray(target));
            }
        }
        if (!add) {
            throw new TypeError('Invalid event target');
        }
        return new Observable(function (subscriber) {
            var handler = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return subscriber.next(1 < args.length ? args : args[0]);
            };
            add(handler);
            return function () { return remove(handler); };
        });
    }
    function toCommonHandlerRegistry(target, eventName) {
        return function (methodName) { return function (handler) { return target[methodName](eventName, handler); }; };
    }
    function isNodeStyleEventEmitter(target) {
        return isFunction(target.addListener) && isFunction(target.removeListener);
    }
    function isJQueryStyleEventEmitter(target) {
        return isFunction(target.on) && isFunction(target.off);
    }
    function isEventTarget(target) {
        return isFunction(target.addEventListener) && isFunction(target.removeEventListener);
    }

    function timer(dueTime, intervalOrScheduler, scheduler) {
        if (dueTime === void 0) { dueTime = 0; }
        if (scheduler === void 0) { scheduler = async; }
        var intervalDuration = -1;
        if (intervalOrScheduler != null) {
            if (isScheduler(intervalOrScheduler)) {
                scheduler = intervalOrScheduler;
            }
            else {
                intervalDuration = intervalOrScheduler;
            }
        }
        return new Observable(function (subscriber) {
            var due = isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
            if (due < 0) {
                due = 0;
            }
            var n = 0;
            return scheduler.schedule(function () {
                if (!subscriber.closed) {
                    subscriber.next(n++);
                    if (0 <= intervalDuration) {
                        this.schedule(undefined, intervalDuration);
                    }
                    else {
                        subscriber.complete();
                    }
                }
            }, due);
        });
    }

    function merge() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var scheduler = popScheduler(args);
        var concurrent = popNumber(args, Infinity);
        var sources = args;
        return !sources.length
            ?
                EMPTY
            : sources.length === 1
                ?
                    innerFrom(sources[0])
                :
                    mergeAll(concurrent)(internalFromArray(sources, scheduler));
    }

    function filter(predicate, thisArg) {
        return operate(function (source, subscriber) {
            var index = 0;
            source.subscribe(new OperatorSubscriber(subscriber, function (value) { return predicate.call(thisArg, value, index++) && subscriber.next(value); }));
        });
    }

    function buffer(closingNotifier) {
        return operate(function (source, subscriber) {
            var currentBuffer = [];
            source.subscribe(new OperatorSubscriber(subscriber, function (value) { return currentBuffer.push(value); }, function () {
                subscriber.next(currentBuffer);
                subscriber.complete();
            }));
            closingNotifier.subscribe(new OperatorSubscriber(subscriber, function () {
                var b = currentBuffer;
                currentBuffer = [];
                subscriber.next(b);
            }, noop));
            return function () {
                currentBuffer = null;
            };
        });
    }

    function debounceTime(dueTime, scheduler) {
        if (scheduler === void 0) { scheduler = asyncScheduler; }
        return operate(function (source, subscriber) {
            var activeTask = null;
            var lastValue = null;
            var lastTime = null;
            var emit = function () {
                if (activeTask) {
                    activeTask.unsubscribe();
                    activeTask = null;
                    var value = lastValue;
                    lastValue = null;
                    subscriber.next(value);
                }
            };
            function emitWhenIdle() {
                var targetTime = lastTime + dueTime;
                var now = scheduler.now();
                if (now < targetTime) {
                    activeTask = this.schedule(undefined, targetTime - now);
                    subscriber.add(activeTask);
                    return;
                }
                emit();
            }
            source.subscribe(new OperatorSubscriber(subscriber, function (value) {
                lastValue = value;
                lastTime = scheduler.now();
                if (!activeTask) {
                    activeTask = scheduler.schedule(emitWhenIdle, dueTime);
                    subscriber.add(activeTask);
                }
            }, function () {
                emit();
                subscriber.complete();
            }, undefined, function () {
                lastValue = activeTask = null;
            }));
        });
    }

    function groupBy(keySelector, elementOrOptions, duration, connector) {
        return operate(function (source, subscriber) {
            var element;
            if (!elementOrOptions || typeof elementOrOptions === 'function') {
                element = elementOrOptions;
            }
            else {
                (duration = elementOrOptions.duration, element = elementOrOptions.element, connector = elementOrOptions.connector);
            }
            var groups = new Map();
            var notify = function (cb) {
                groups.forEach(cb);
                cb(subscriber);
            };
            var handleError = function (err) { return notify(function (consumer) { return consumer.error(err); }); };
            var groupBySourceSubscriber = new GroupBySubscriber(subscriber, function (value) {
                try {
                    var key_1 = keySelector(value);
                    var group_1 = groups.get(key_1);
                    if (!group_1) {
                        groups.set(key_1, (group_1 = connector ? connector() : new Subject()));
                        var grouped = createGroupedObservable(key_1, group_1);
                        subscriber.next(grouped);
                        if (duration) {
                            var durationSubscriber_1 = new OperatorSubscriber(group_1, function () {
                                group_1.complete();
                                durationSubscriber_1 === null || durationSubscriber_1 === void 0 ? void 0 : durationSubscriber_1.unsubscribe();
                            }, undefined, undefined, function () { return groups.delete(key_1); });
                            groupBySourceSubscriber.add(innerFrom(duration(grouped)).subscribe(durationSubscriber_1));
                        }
                    }
                    group_1.next(element ? element(value) : value);
                }
                catch (err) {
                    handleError(err);
                }
            }, function () { return notify(function (consumer) { return consumer.complete(); }); }, handleError, function () { return groups.clear(); });
            source.subscribe(groupBySourceSubscriber);
            function createGroupedObservable(key, groupSubject) {
                var result = new Observable(function (groupSubscriber) {
                    groupBySourceSubscriber.activeGroups++;
                    var innerSub = groupSubject.subscribe(groupSubscriber);
                    return function () {
                        innerSub.unsubscribe();
                        --groupBySourceSubscriber.activeGroups === 0 &&
                            groupBySourceSubscriber.teardownAttempted &&
                            groupBySourceSubscriber.unsubscribe();
                    };
                });
                result.key = key;
                return result;
            }
        });
    }
    var GroupBySubscriber = (function (_super) {
        __extends(GroupBySubscriber, _super);
        function GroupBySubscriber() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.activeGroups = 0;
            _this.teardownAttempted = false;
            return _this;
        }
        GroupBySubscriber.prototype.unsubscribe = function () {
            this.teardownAttempted = true;
            this.activeGroups === 0 && _super.prototype.unsubscribe.call(this);
        };
        return GroupBySubscriber;
    }(OperatorSubscriber));

    function takeUntil(notifier) {
        return operate(function (source, subscriber) {
            innerFrom(notifier).subscribe(new OperatorSubscriber(subscriber, function () { return subscriber.complete(); }, noop));
            !subscriber.closed && source.subscribe(subscriber);
        });
    }

    var defaultThrottleConfig = {
        leading: true,
        trailing: false,
    };
    function throttle(durationSelector, _a) {
        var _b = _a === void 0 ? defaultThrottleConfig : _a, leading = _b.leading, trailing = _b.trailing;
        return operate(function (source, subscriber) {
            var hasValue = false;
            var sendValue = null;
            var throttled = null;
            var isComplete = false;
            var endThrottling = function () {
                throttled === null || throttled === void 0 ? void 0 : throttled.unsubscribe();
                throttled = null;
                if (trailing) {
                    send();
                    isComplete && subscriber.complete();
                }
            };
            var cleanupThrottling = function () {
                throttled = null;
                isComplete && subscriber.complete();
            };
            var startThrottle = function (value) {
                return (throttled = innerFrom(durationSelector(value)).subscribe(new OperatorSubscriber(subscriber, endThrottling, cleanupThrottling)));
            };
            var send = function () {
                if (hasValue) {
                    hasValue = false;
                    var value = sendValue;
                    sendValue = null;
                    subscriber.next(value);
                    !isComplete && startThrottle(value);
                }
            };
            source.subscribe(new OperatorSubscriber(subscriber, function (value) {
                hasValue = true;
                sendValue = value;
                !(throttled && !throttled.closed) && (leading ? send() : startThrottle(value));
            }, function () {
                isComplete = true;
                !(trailing && hasValue && throttled && !throttled.closed) && subscriber.complete();
            }));
        });
    }

    function throttleTime(duration, scheduler, config) {
        if (scheduler === void 0) { scheduler = asyncScheduler; }
        if (config === void 0) { config = defaultThrottleConfig; }
        var duration$ = timer(duration, scheduler);
        return throttle(function () { return duration$; }, config);
    }

    function onNumberOnly(event) {
        const input = event.target;
        input.value = input.value.replace(/[^0-9]/g, '');
    }
    function onPreventDefault(event) {
        event.preventDefault();
        return event;
    }
    function onStopPropagation(event) {
        event.stopPropagation();
        return event;
    }
    function onStopImmediatePropagation(event) {
        event.stopImmediatePropagation();
        return event;
    }
    pipe(onPreventDefault, onStopPropagation, onStopImmediatePropagation);
    function markToHTML(className, target, keyword) {
        const match = new RegExp(keyword.split('').join('|'), 'i');
        const list = target.split('');
        const buffer = [];
        while (list.length) {
            const cur = list.shift();
            match.test(cur)
                ? buffer.push(`<span class="${className}">${cur}</span>`)
                : buffer.push(cur);
        }
        return buffer.join('');
    }
    function lastCursorFocus(input) {
        const len = input.value.length;
        input.selectionStart = len;
        input.selectionEnd = len;
        input.focus();
    }
    function onInputClear(event) {
        const input = event.target;
        if (!input)
            return;
        input.value = '';
    }

    const TEXT_PADDING = 2;
    function createHelper() {
        let ghostText = null;
        let ghostTableHeadText = null;
        let ghostInput = null;
        const subscriptionHelper = createSubscriptionHelper();
        const keydown$ = new Subject();
        const setGhostText = (ghost) => {
            ghostText = ghost;
        };
        const setGhostTableHeadText = (ghost) => {
            ghostTableHeadText = ghost;
        };
        const setGhostInput = (ghost) => {
            ghostInput = ghost;
            subscriptionHelper.push(fromEvent(ghostInput, 'input').subscribe(onInputClear));
        };
        const getTableHeadTextWidth = (value) => {
            if (!ghostTableHeadText)
                return value.length * 10 + TEXT_PADDING;
            ghostTableHeadText.innerText = value;
            return ghostTableHeadText.offsetWidth + TEXT_PADDING;
        };
        const getTextWidth = (value) => {
            if (!ghostText)
                return value.length * 10 + TEXT_PADDING;
            ghostText.innerText = value;
            return ghostText.offsetWidth + TEXT_PADDING;
        };
        const focus = () => {
            if (!ghostInput)
                return;
            ghostInput.focus();
        };
        const blur = () => {
            if (!ghostInput)
                return;
            ghostInput.blur();
        };
        const destroy = () => subscriptionHelper.destroy();
        return {
            keydown$,
            setGhostText,
            setGhostTableHeadText,
            setGhostInput,
            getTextWidth,
            getTableHeadTextWidth,
            focus,
            blur,
            destroy,
        };
    }

    class Logger {
    }
    Logger.debug = (...args) => args.forEach(console.dir);
    Logger.log = console.log;
    Logger.warn = console.warn;
    Logger.error = console.error;

    const notEmptyCommands = filter(commands => !!commands.length);

    const commandsFilter = (commandTypes) => (source$) => new Observable(subscriber => source$.subscribe({
        next: commands => subscriber.next(commands.filter(command => commandTypes.includes(command.name))),
        error: value => subscriber.error(value),
        complete: () => subscriber.complete(),
    })).pipe(notEmptyCommands);

    const createCommand$1 = (name, data) => ({
        name,
        data,
        timestamp: Date.now(),
    });
    const changeCommandTypes = [
        // table
        'table.add',
        'table.move',
        'table.remove',
        'table.changeName',
        'table.changeComment',
        'table.sort',
        // column
        'column.add',
        'column.addCustom',
        'column.remove',
        'column.changeName',
        'column.changeComment',
        'column.changeDataType',
        'column.changeDefault',
        'column.changeAutoIncrement',
        'column.changePrimaryKey',
        'column.changeUnique',
        'column.changeNotNull',
        'column.move',
        // relationship
        'relationship.add',
        'relationship.remove',
        'relationship.changeRelationshipType',
        'relationship.changeStartRelationshipType',
        'relationship.changeIdentification',
        // index
        'index.add',
        'index.remove',
        'index.changeName',
        'index.changeUnique',
        'index.addColumn',
        'index.removeColumn',
        'index.moveColumn',
        'index.changeColumnOrderType',
        // memo
        'memo.add',
        'memo.move',
        'memo.remove',
        'memo.changeValue',
        'memo.resize',
        // canvas
        'canvas.move',
        'canvas.movement',
        'canvas.resize',
        'canvas.zoom',
        'canvas.movementZoom',
        'canvas.changeShow',
        'canvas.changeDatabase',
        'canvas.changeDatabaseName',
        'canvas.changeCanvasType',
        'canvas.changeLanguage',
        'canvas.changeTableCase',
        'canvas.changeColumnCase',
        'canvas.changeRelationshipDataTypeSync',
        'canvas.moveColumnOrder',
        'canvas.changeHighlightTheme',
        'canvas.changeBracketType',
        // editor
        'editor.loadJson',
        'editor.clear',
    ];
    const historyCommandTypes = [
        // table
        'table.add',
        'table.move',
        'table.remove',
        'table.changeName',
        'table.changeComment',
        'table.sort',
        // column
        'column.add',
        'column.addCustom',
        'column.remove',
        'column.changeName',
        'column.changeComment',
        'column.changeDataType',
        'column.changeDefault',
        'column.changeAutoIncrement',
        'column.changePrimaryKey',
        'column.changeUnique',
        'column.changeNotNull',
        'column.move',
        // relationship
        'relationship.add',
        'relationship.remove',
        'relationship.changeRelationshipType',
        'relationship.changeStartRelationshipType',
        'relationship.changeIdentification',
        // memo
        'memo.add',
        'memo.move',
        'memo.remove',
        'memo.changeValue',
        'memo.resize',
        // canvas
        'canvas.move',
        'canvas.movement',
        'canvas.resize',
        'canvas.zoom',
        'canvas.movementZoom',
        'canvas.changeShow',
        'canvas.changeDatabase',
        'canvas.changeDatabaseName',
        // editor
        'editor.loadJson',
        'editor.clear',
    ];
    const streamCommandTypes = [
        'table.move',
        'memo.move',
        'memo.resize',
        'canvas.movement',
        'canvas.movementZoom',
    ];
    const readonlyCommandTypes = [
        // table
        'table.select',
        'table.selectEnd',
        'table.selectAll',
        'table.dragSelect',
        // column
        'column.active',
        'column.activeEnd',
        // memo
        'memo.select',
        'memo.selectEnd',
        'memo.selectAll',
        'memo.dragSelect',
        // canvas
        'canvas.move',
        'canvas.movement',
        'canvas.zoom',
        'canvas.movementZoom',
        'canvas.changeShow',
        'canvas.changeDatabase',
        'canvas.changeCanvasType',
        'canvas.changeLanguage',
        'canvas.changeTableCase',
        'canvas.changeColumnCase',
        'canvas.moveColumnOrder',
        'canvas.changeHighlightTheme',
        'canvas.changeBracketType',
        // editor
        'editor.focusTable',
        'editor.focusColumn',
        'editor.focusTableEnd',
        'editor.focusMoveTable',
        'editor.editTableEnd',
        'editor.selectAllColumn',
        'editor.initLoadJson',
        'editor.initClear',
        'editor.changeViewport',
        'editor.findActive',
        'editor.findActiveEnd',
        'editor.readonly',
        // editor filter
        'editor.filter.active',
        'editor.filter.activeEnd',
        'editor.filter.add',
        'editor.filter.remove',
        'editor.filter.changeColumnType',
        'editor.filter.changeFilterCode',
        'editor.filter.changeValue',
        'editor.filter.move',
        'editor.filter.changeOperatorType',
        'editor.filter.focus',
        'editor.filter.focusFilter',
        'editor.filter.focusEnd',
        'editor.filter.focusMove',
        'editor.filter.edit',
        'editor.filter.editEnd',
        'editor.filter.selectAll',
        'editor.filter.draggable',
        'editor.filter.draggableEnd',
    ];
    const moveCommandTypes = [
        // table
        'table.move',
        // column
        // memo
        'memo.move',
        // canvas
        'canvas.move',
        // editor
        'editor.focusMoveTable',
        // editor filter
        'editor.filter.move',
        'editor.filter.focusMove',
    ];

    /** Used to match a single whitespace character. */

    var reWhitespace = /\s/;

    /**
     * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
     * character of `string`.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {number} Returns the index of the last non-whitespace character.
     */
    function trimmedEndIndex$1(string) {
      var index = string.length;

      while (index-- && reWhitespace.test(string.charAt(index))) {}
      return index;
    }

    var _trimmedEndIndex = trimmedEndIndex$1;

    var trimmedEndIndex = _trimmedEndIndex;

    /** Used to match leading whitespace. */
    var reTrimStart = /^\s+/;

    /**
     * The base implementation of `_.trim`.
     *
     * @private
     * @param {string} string The string to trim.
     * @returns {string} Returns the trimmed string.
     */
    function baseTrim$1(string) {
      return string
        ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
        : string;
    }

    var _baseTrim = baseTrim$1;

    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */

    function isObject$1(value) {
      var type = typeof value;
      return value != null && (type == 'object' || type == 'function');
    }

    var isObject_1 = isObject$1;

    var baseTrim = _baseTrim,
        isObject = isObject_1,
        isSymbol = isSymbol_1;

    /** Used as references for various `Number` constants. */
    var NAN = 0 / 0;

    /** Used to detect bad signed hexadecimal string values. */
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

    /** Used to detect binary string values. */
    var reIsBinary = /^0b[01]+$/i;

    /** Used to detect octal string values. */
    var reIsOctal = /^0o[0-7]+$/i;

    /** Built-in method references without a dependency on `root`. */
    var freeParseInt = parseInt;

    /**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */
    function toNumber$2(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject(other) ? (other + '') : other;
      }
      if (typeof value != 'string') {
        return value === 0 ? value : +value;
      }
      value = baseTrim(value);
      var isBinary = reIsBinary.test(value);
      return (isBinary || reIsOctal.test(value))
        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
        : (reIsBadHex.test(value) ? NAN : +value);
    }

    var toNumber_1 = toNumber$2;

    var toNumber$1 = toNumber_1;

    /** Used as references for various `Number` constants. */
    var INFINITY = 1 / 0,
        MAX_INTEGER = 1.7976931348623157e+308;

    /**
     * Converts `value` to a finite number.
     *
     * @static
     * @memberOf _
     * @since 4.12.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted number.
     * @example
     *
     * _.toFinite(3.2);
     * // => 3.2
     *
     * _.toFinite(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toFinite(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toFinite('3.2');
     * // => 3.2
     */
    function toFinite$1(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber$1(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = (value < 0 ? -1 : 1);
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }

    var toFinite_1 = toFinite$1;

    var toFinite = toFinite_1;

    /**
     * Converts `value` to an integer.
     *
     * **Note:** This method is loosely based on
     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3.2);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3.2');
     * // => 3
     */
    function toInteger$1(value) {
      var result = toFinite(value),
          remainder = result % 1;

      return result === result ? (remainder ? result - remainder : result) : 0;
    }

    var toInteger_1 = toInteger$1;

    var root = _root,
        toInteger = toInteger_1,
        toNumber = toNumber_1,
        toString = toString_1;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeIsFinite = root.isFinite,
        nativeMin = Math.min;

    /**
     * Creates a function like `_.round`.
     *
     * @private
     * @param {string} methodName The name of the `Math` method to use when rounding.
     * @returns {Function} Returns the new round function.
     */
    function createRound$1(methodName) {
      var func = Math[methodName];
      return function(number, precision) {
        number = toNumber(number);
        precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
        if (precision && nativeIsFinite(number)) {
          // Shift with exponential notation to avoid floating-point issues.
          // See [MDN](https://mdn.io/round#Examples) for more details.
          var pair = (toString(number) + 'e').split('e'),
              value = func(pair[0] + 'e' + (+pair[1] + precision));

          pair = (toString(value) + 'e').split('e');
          return +(pair[0] + 'e' + (+pair[1] - precision));
        }
        return func(number);
      };
    }

    var _createRound = createRound$1;

    var createRound = _createRound;

    /**
     * Computes `number` rounded to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round.
     * @param {number} [precision=0] The precision to round to.
     * @returns {number} Returns the rounded number.
     * @example
     *
     * _.round(4.006);
     * // => 4
     *
     * _.round(4.006, 2);
     * // => 4.01
     *
     * _.round(4060, -2);
     * // => 4100
     */
    var round = createRound('round');

    var round_1 = round;

    const canvasSizeBalanceRange = createBalanceRange(SIZE_CANVAS_MIN, SIZE_CANVAS_MAX);
    const zoomBalanceRange = createBalanceRange(SIZE_CANVAS_ZOOM_MIN, SIZE_CANVAS_ZOOM_MAX);
    const canvasSizeRange = (size) => canvasSizeBalanceRange((isString$1(size)
        ? Number(size.replace(/[^0-9]/g, ''))
        : size));
    const zoomLevelRange = (zoomLevel) => zoomBalanceRange((isString$1(zoomLevel)
        ? Number(zoomLevel.replace(/[^0-9]/g, ''))
        : zoomLevel));
    const zoomDisplayFormat = (zoomLevel) => `${(zoomLevel * 100).toFixed()}%`;

    function executeMoveCanvas$1({ canvasState, editorState: { viewport } }, data) {
        const scrollTopBalanceRange = createBalanceRange(viewport.height - canvasState.height, 0);
        const scrollLeftBalanceRange = createBalanceRange(viewport.width - canvasState.width, 0);
        canvasState.scrollTop = scrollTopBalanceRange(data.scrollTop);
        canvasState.scrollLeft = scrollLeftBalanceRange(data.scrollLeft);
    }
    function executeMovementCanvas$1({ canvasState, editorState: { viewport } }, data) {
        const scrollTopBalanceRange = createBalanceRange(viewport.height - canvasState.height, 0);
        const scrollLeftBalanceRange = createBalanceRange(viewport.width - canvasState.width, 0);
        canvasState.scrollTop = scrollTopBalanceRange(canvasState.scrollTop + data.movementY);
        canvasState.scrollLeft = scrollLeftBalanceRange(canvasState.scrollLeft + data.movementX);
    }
    function executeResizeCanvas$1({ canvasState }, data) {
        canvasState.width = data.width;
        canvasState.height = data.height;
    }
    function executeZoomCanvas$1({ canvasState }, data) {
        canvasState.zoomLevel = round_1(zoomBalanceRange(data.zoomLevel), 2);
    }
    function executeMovementZoomCanvas$1({ canvasState }, data) {
        canvasState.zoomLevel = round_1(zoomBalanceRange(canvasState.zoomLevel + data.movementZoomLevel), 2);
    }
    function executeChangeCanvasShow$1({ canvasState: { show } }, data) {
        show[data.showKey] = data.value;
    }
    function executeChangeDatabase$1({ canvasState }, data) {
        canvasState.database = data.database;
    }
    function executeChangeDatabaseName$1({ canvasState }, data) {
        canvasState.databaseName = data.value;
    }
    function executeChangeCanvasType({ canvasState }, data) {
        canvasState.canvasType = data.canvasType;
    }
    function executeChangeLanguage({ canvasState }, data) {
        canvasState.language = data.language;
    }
    function executeChangeTableCase({ canvasState }, data) {
        canvasState.tableCase = data.nameCase;
    }
    function executeChangeColumnCase({ canvasState }, data) {
        canvasState.columnCase = data.nameCase;
    }
    function executeChangeRelationshipDataTypeSync({ canvasState: { setting } }, data) {
        setting.relationshipDataTypeSync = data.value;
    }
    function executeMoveColumnOrder({ canvasState: { setting: { columnOrder }, }, }, data) {
        if (data.columnType === data.targetColumnType)
            return;
        const targetIndex = columnOrder.indexOf(data.targetColumnType);
        const currentIndex = columnOrder.indexOf(data.columnType);
        if (targetIndex === -1 || currentIndex === -1)
            return;
        columnOrder.splice(currentIndex, 1);
        columnOrder.splice(targetIndex, 0, data.columnType);
    }
    function executeChangeHighlightTheme({ canvasState }, data) {
        canvasState.highlightTheme = data.highlightTheme;
    }
    function executeChangeBracketType({ canvasState }, data) {
        canvasState.bracketType = data.bracketType;
    }
    const executeCanvasCommandMap$1 = {
        'canvas.move': executeMoveCanvas$1,
        'canvas.movement': executeMovementCanvas$1,
        'canvas.resize': executeResizeCanvas$1,
        'canvas.zoom': executeZoomCanvas$1,
        'canvas.movementZoom': executeMovementZoomCanvas$1,
        'canvas.changeShow': executeChangeCanvasShow$1,
        'canvas.changeDatabase': executeChangeDatabase$1,
        'canvas.changeDatabaseName': executeChangeDatabaseName$1,
        'canvas.changeCanvasType': executeChangeCanvasType,
        'canvas.changeLanguage': executeChangeLanguage,
        'canvas.changeTableCase': executeChangeTableCase,
        'canvas.changeColumnCase': executeChangeColumnCase,
        'canvas.changeRelationshipDataTypeSync': executeChangeRelationshipDataTypeSync,
        'canvas.moveColumnOrder': executeMoveColumnOrder,
        'canvas.changeHighlightTheme': executeChangeHighlightTheme,
        'canvas.changeBracketType': executeChangeBracketType,
    };

    const moveCanvas = (scrollTop, scrollLeft) => createCommand$1('canvas.move', { scrollTop, scrollLeft });
    const movementCanvas = (movementX, movementY) => createCommand$1('canvas.movement', { movementX, movementY });
    const resizeCanvas = (width, height) => createCommand$1('canvas.resize', { width, height });
    const zoomCanvas = (zoomLevel) => createCommand$1('canvas.zoom', {
        zoomLevel: zoomBalanceRange(zoomLevel),
    });
    const movementZoomCanvas = (movementZoomLevel) => createCommand$1('canvas.movementZoom', {
        movementZoomLevel,
    });
    const changeCanvasShow = ({ canvasState: { show } }, showKey) => createCommand$1('canvas.changeShow', { showKey, value: !show[showKey] });
    const changeDatabase = (database) => createCommand$1('canvas.changeDatabase', { database });
    const changeDatabaseName = (value) => createCommand$1('canvas.changeDatabaseName', { value });
    const changeCanvasType = (canvasType) => createCommand$1('canvas.changeCanvasType', { canvasType });
    const changeLanguage = (language) => createCommand$1('canvas.changeLanguage', { language });
    const changeTableCase = (nameCase) => createCommand$1('canvas.changeTableCase', { nameCase });
    const changeColumnCase = (nameCase) => createCommand$1('canvas.changeColumnCase', { nameCase });
    const changeRelationshipDataTypeSync = (value) => createCommand$1('canvas.changeRelationshipDataTypeSync', { value });
    const moveColumnOrder = (columnType, targetColumnType) => createCommand$1('canvas.moveColumnOrder', { columnType, targetColumnType });
    const changeHighlightTheme = (highlightTheme) => createCommand$1('canvas.changeHighlightTheme', { highlightTheme });
    const changeBracketType = (bracketType) => createCommand$1('canvas.changeBracketType', { bracketType });

    var canvasCommand = /*#__PURE__*/Object.freeze({
        __proto__: null,
        moveCanvas: moveCanvas,
        movementCanvas: movementCanvas,
        resizeCanvas: resizeCanvas,
        zoomCanvas: zoomCanvas,
        movementZoomCanvas: movementZoomCanvas,
        changeCanvasShow: changeCanvasShow,
        changeDatabase: changeDatabase,
        changeDatabaseName: changeDatabaseName,
        changeCanvasType: changeCanvasType,
        changeLanguage: changeLanguage,
        changeTableCase: changeTableCase,
        changeColumnCase: changeColumnCase,
        changeRelationshipDataTypeSync: changeRelationshipDataTypeSync,
        moveColumnOrder: moveColumnOrder,
        changeHighlightTheme: changeHighlightTheme,
        changeBracketType: changeBracketType
    });

    function getColumn(tables, tableId, columnId) {
        const table = getData(tables, tableId);
        return table ? getData(table.columns, columnId) : null;
    }
    function getDataTypeSyncColumns(stack, tables, relationships, targetColumns = []) {
        const target = stack.pop();
        if (target) {
            if (getIndex(targetColumns, target.id) === -1) {
                targetColumns.push(target);
                relationships.forEach(relationship => {
                    const { start, end } = relationship;
                    const index = start.columnIds.indexOf(target.id);
                    if (index !== -1) {
                        const columnId = end.columnIds[index];
                        const column = getColumn(tables, end.tableId, columnId);
                        column && stack.push(column);
                    }
                    else {
                        const index = end.columnIds.indexOf(target.id);
                        if (index !== -1) {
                            const columnId = start.columnIds[index];
                            const column = getColumn(tables, start.tableId, columnId);
                            column && stack.push(column);
                        }
                    }
                });
            }
            getDataTypeSyncColumns(stack, tables, relationships, targetColumns);
        }
        return targetColumns;
    }
    function getChangeOption(tables, tableId, columnId, columnOptionKey) {
        const column = getColumn(tables, tableId, columnId);
        return column ? !column.option[columnOptionKey] : false;
    }
    function getColumns(table, columnIds) {
        const columns = [];
        columnIds.forEach(columnId => {
            const column = getData(table.columns, columnId);
            if (!column)
                return;
            columns.push(column);
        });
        return columns;
    }
    const commentWidthBalanceRange = createBalanceRange(SIZE_MIN_WIDTH, SIZE_MAX_WIDTH_COMMENT);
    const widthBalanceRange = createBalanceRange(SIZE_MIN_WIDTH, 10000);

    const migrationRelationshipTypes = ['ZeroOneN', 'One', 'N'];
    const migrationRelationshipTypeMap = {
        ZeroOneN: 'ZeroN',
        One: 'OneOnly',
        N: 'OneN',
    };
    const migrationRelationshipType = (relationshipType) => migrationRelationshipTypes.includes(relationshipType)
        ? migrationRelationshipTypeMap[relationshipType]
        : relationshipType;

    const isLoadRelationship = (loadRelationship) => isString$1(loadRelationship.id) &&
        isBoolean(loadRelationship.identification) &&
        isString$1(loadRelationship.relationshipType) &&
        isObject$2(loadRelationship.start) &&
        isObject$2(loadRelationship.end) &&
        isString$1(loadRelationship.start.tableId) &&
        isNumber(loadRelationship.start.x) &&
        isNumber(loadRelationship.start.y) &&
        isString$1(loadRelationship.start.direction) &&
        isArray$1(loadRelationship.start.columnIds) &&
        isString$1(loadRelationship.end.tableId) &&
        isNumber(loadRelationship.end.x) &&
        isNumber(loadRelationship.end.y) &&
        isString$1(loadRelationship.end.direction) &&
        isArray$1(loadRelationship.end.columnIds);
    class RelationshipModel {
        constructor({ addRelationship, loadRelationship }) {
            this.identification = false;
            this.relationshipType = 'ZeroN';
            this.startRelationshipType = 'Dash';
            this.start = {
                tableId: '',
                columnIds: [],
                x: 0,
                y: 0,
                direction: 'bottom',
            };
            this.end = {
                tableId: '',
                columnIds: [],
                x: 0,
                y: 0,
                direction: 'bottom',
            };
            this.constraintName = '';
            if (addRelationship) {
                const { id, relationshipType, start, end, constraintName } = addRelationship;
                this.id = id;
                this.relationshipType = migrationRelationshipType(relationshipType);
                this.start.tableId = start.tableId;
                this.start.columnIds = [...start.columnIds];
                this.end.tableId = end.tableId;
                this.end.columnIds = [...end.columnIds];
                this.constraintName = constraintName;
            }
            else if (loadRelationship && isLoadRelationship(loadRelationship)) {
                const { id, identification, relationshipType, startRelationshipType, start, end, constraintName, } = cloneDeep(loadRelationship);
                this.id = id;
                this.identification = identification;
                this.relationshipType = migrationRelationshipType(relationshipType);
                this.start = start;
                this.end = end;
                this.constraintName = constraintName || '';
                if (startRelationshipType) {
                    this.startRelationshipType = startRelationshipType;
                }
            }
            else {
                throw new Error('not found relationship');
            }
        }
    }

    function executeAddRelationship$1({ relationshipState: { relationships }, tableState: { tables } }, data) {
        const { start, end } = data;
        const startTable = getData(tables, start.tableId);
        const endTable = getData(tables, end.tableId);
        if (!start.columnIds.length || !startTable || !endTable)
            return;
        relationships.push(new RelationshipModel({ addRelationship: data }));
    }
    function executeRemoveRelationship$1(state, data) {
        const { relationshipState: { relationships }, } = state;
        for (let i = 0; i < relationships.length; i++) {
            const relationship = relationships[i];
            if (data.relationshipIds.includes(relationship.id)) {
                relationships.splice(i, 1);
                i--;
                // TODO: Refactoring
                removeValidRelationshipColumnId(state, relationship.end.tableId, relationship.end.columnIds);
            }
        }
    }
    function executeChangeRelationshipType$1({ relationshipState: { relationships } }, data) {
        const relationship = getData(relationships, data.relationshipId);
        if (!relationship)
            return;
        relationship.relationshipType = data.relationshipType;
    }
    function executeChangeStartRelationshipType$1({ relationshipState: { relationships } }, data) {
        const relationship = getData(relationships, data.relationshipId);
        if (!relationship)
            return;
        relationship.startRelationshipType = data.startRelationshipType;
    }
    function executeChangeIdentification$1({ relationshipState: { relationships } }, data) {
        const relationship = getData(relationships, data.relationshipId);
        if (!relationship)
            return;
        relationship.identification = data.identification;
    }
    function executeLoadRelationship({ relationshipState: { relationships }, tableState: { tables } }, data) {
        relationships.push(new RelationshipModel({ loadRelationship: data }));
        // valid end column ui key
        const table = getData(tables, data.end.tableId);
        if (!table)
            return;
        data.end.columnIds.forEach(columnId => {
            const column = getData(table.columns, columnId);
            if (!column)
                return;
            if (column.option.primaryKey) {
                column.ui.pfk = true;
                column.ui.pk = false;
                column.ui.fk = false;
            }
            else {
                column.ui.pfk = false;
                column.ui.pk = false;
                column.ui.fk = true;
            }
        });
    }
    const executeRelationshipCommandMap$1 = {
        'relationship.add': executeAddRelationship$1,
        'relationship.remove': executeRemoveRelationship$1,
        'relationship.changeRelationshipType': executeChangeRelationshipType$1,
        'relationship.changeStartRelationshipType': executeChangeStartRelationshipType$1,
        'relationship.changeIdentification': executeChangeIdentification$1,
        'relationship.load': executeLoadRelationship,
    };

    /**
     * TODO: Refactoring
     */
    function validIdentification(state) {
        const { relationships } = state.relationshipState;
        const { tables } = state.tableState;
        relationships.forEach(relationship => {
            const { end } = relationship;
            const table = getData(tables, end.tableId);
            if (!table)
                return;
            const columns = getColumns(table, end.columnIds);
            const identification = columns.every(column => column.option.primaryKey);
            if (identification !== relationship.identification) {
                executeChangeIdentification$1(state, {
                    relationshipId: relationship.id,
                    identification,
                });
            }
        });
    }
    function validStartRelationship(state) {
        const { relationships } = state.relationshipState;
        const { tables } = state.tableState;
        relationships.forEach(relationship => {
            const { end } = relationship;
            const table = getData(tables, end.tableId);
            if (!table)
                return;
            const columns = getColumns(table, end.columnIds);
            const startRelationshipType = columns.every(column => column.option.notNull)
                ? 'Dash'
                : 'Ring';
            if (startRelationshipType !== relationship.startRelationshipType) {
                executeChangeStartRelationshipType$1(state, {
                    relationshipId: relationship.id,
                    startRelationshipType,
                });
            }
        });
    }
    function removeValidTableRelationship(state, tableIds) {
        const { relationships } = state.relationshipState;
        const removeRelationshipIds = [];
        relationships.forEach(relationship => {
            const { start, end } = relationship;
            if (!tableIds.some(tableId => tableId === start.tableId || tableId === end.tableId))
                return;
            removeRelationshipIds.push(relationship.id);
        });
        if (removeRelationshipIds.length !== 0) {
            executeRemoveRelationship$1(state, {
                relationshipIds: removeRelationshipIds,
            });
        }
    }
    function removeValidColumnRelationship(state, table, columnIds) {
        const { relationships } = state.relationshipState;
        const removeRelationshipIds = [];
        const validColumnUIKeyList = [];
        relationships.forEach(relationship => {
            const { start, end } = relationship;
            const validColumnUIKey = {
                startTableId: start.tableId,
                endTableId: end.tableId,
                columnIds: [],
            };
            if (table.id === start.tableId) {
                for (let i = 0; i < start.columnIds.length; i++) {
                    const id = start.columnIds[i];
                    if (!columnIds.includes(id))
                        return;
                    validColumnUIKey.columnIds.push(end.columnIds[i]);
                    start.columnIds.splice(i, 1);
                    end.columnIds.splice(i, 1);
                    i--;
                }
            }
            else if (table.id === end.tableId) {
                for (let i = 0; i < end.columnIds.length; i++) {
                    const id = end.columnIds[i];
                    if (!columnIds.includes(id))
                        return;
                    validColumnUIKey.columnIds.push(id);
                    start.columnIds.splice(i, 1);
                    end.columnIds.splice(i, 1);
                    i--;
                }
            }
            if (start.columnIds.length === 0) {
                removeRelationshipIds.push(relationship.id);
            }
            validColumnUIKeyList.push(validColumnUIKey);
        });
        if (removeRelationshipIds.length !== 0) {
            executeRemoveRelationship$1(state, {
                relationshipIds: removeRelationshipIds,
            });
        }
        validColumnUIKeyList.forEach(validColumnUIKey => {
            if (validColumnUIKey.columnIds.length === 0)
                return;
            removeValidRelationshipColumnId(state, validColumnUIKey.startTableId, validColumnUIKey.columnIds);
            removeValidRelationshipColumnId(state, validColumnUIKey.endTableId, validColumnUIKey.columnIds);
        });
    }
    function removeValidRelationshipColumnId(state, tableId, columnIds) {
        const { tables } = state.tableState;
        const table = getData(tables, tableId);
        if (!table)
            return;
        columnIds.forEach(columnId => {
            const column = getData(table.columns, columnId);
            if (!column)
                return;
            if (column.ui.fk) {
                column.ui.fk = false;
            }
            else if (column.ui.pfk) {
                column.ui.pfk = false;
                column.ui.pk = true;
            }
        });
    }
    function removeValidColumnIndex(state, table, columnIds) {
        const { indexes } = state.tableState;
        const tableIndexes = indexes.filter(index => index.tableId === table.id);
        tableIndexes.forEach(index => {
            for (let i = 0; i < index.columns.length; i++) {
                const id = index.columns[i].id;
                if (columnIds.includes(id)) {
                    index.columns.splice(i, 1);
                    i--;
                }
            }
        });
    }
    function removeValidTableIndex(state, tableIds) {
        const { indexes } = state.tableState;
        for (let i = 0; i < indexes.length; i++) {
            const id = indexes[i].tableId;
            if (tableIds.includes(id)) {
                indexes.splice(i, 1);
                i--;
            }
        }
    }

    class ColumnModel {
        constructor({ addColumn, addCustomColumn }) {
            this.name = '';
            this.comment = '';
            this.dataType = '';
            this.default = '';
            this.option = {
                autoIncrement: false,
                primaryKey: false,
                unique: false,
                notNull: false,
            };
            this.ui = {
                active: false,
                pk: false,
                fk: false,
                pfk: false,
                widthName: SIZE_MIN_WIDTH,
                widthComment: SIZE_MIN_WIDTH,
                widthDataType: SIZE_MIN_WIDTH,
                widthDefault: SIZE_MIN_WIDTH,
            };
            if (addColumn) {
                const { id } = addColumn;
                this.id = id;
            }
            else if (addCustomColumn) {
                const { id, option, ui, value } = cloneDeep(addCustomColumn);
                this.id = id;
                option && Object.assign(this.option, option);
                ui && Object.assign(this.ui, ui);
                if (value) {
                    this.name = value.name;
                    this.comment = value.comment;
                    this.dataType = value.dataType;
                    this.default = value.default;
                    this.ui.widthName = value.widthName;
                    this.ui.widthComment = value.widthComment;
                    this.ui.widthDataType = value.widthDataType;
                    this.ui.widthDefault = value.widthDefault;
                }
            }
            else {
                throw new Error('not found column');
            }
        }
    }

    function executeAddColumn$1({ tableState: { tables } }, data) {
        data.forEach((addColumn) => {
            const table = getData(tables, addColumn.tableId);
            table && table.columns.push(new ColumnModel({ addColumn }));
        });
    }
    function executeAddCustomColumn$1({ tableState: { tables } }, data) {
        data.forEach((addCustomColumn) => {
            const table = getData(tables, addCustomColumn.tableId);
            if (!table)
                return;
            table.columns.push(new ColumnModel({ addCustomColumn }));
        });
    }
    function executeRemoveColumn$1(state, data) {
        const { tableState: { tables }, } = state;
        const table = getData(tables, data.tableId);
        if (!table)
            return;
        for (let i = 0; i < table.columns.length; i++) {
            const column = table.columns[i];
            if (data.columnIds.includes(column.id)) {
                table.columns.splice(i, 1);
                i--;
            }
        }
        // TODO: Refactoring
        removeValidColumnIndex(state, table, data.columnIds);
        removeValidColumnRelationship(state, table, data.columnIds);
        validIdentification(state);
        validStartRelationship(state);
    }
    function executeRemoveOnlyColumn(state, data) {
        const { tableState: { tables }, } = state;
        const table = getData(tables, data.tableId);
        if (!table)
            return;
        for (let i = 0; i < table.columns.length; i++) {
            const column = table.columns[i];
            if (data.columnIds.includes(column.id)) {
                table.columns.splice(i, 1);
                i--;
            }
        }
    }
    function executeChangeColumnName$1({ tableState: { tables } }, data) {
        const column = getColumn(tables, data.tableId, data.columnId);
        if (!column)
            return;
        column.name = data.value;
        column.ui.widthName = data.width;
    }
    function executeChangeColumnComment$1({ tableState: { tables } }, data) {
        const column = getColumn(tables, data.tableId, data.columnId);
        if (!column)
            return;
        column.comment = data.value;
        column.ui.widthComment = commentWidthBalanceRange(data.width);
    }
    function executeChangeColumnDataType$1({ canvasState: { setting }, tableState: { tables }, relationshipState: { relationships }, }, data) {
        const targetColumn = getColumn(tables, data.tableId, data.columnId);
        if (!targetColumn)
            return;
        let columns = [targetColumn];
        if (setting.relationshipDataTypeSync) {
            columns = getDataTypeSyncColumns([targetColumn], tables, relationships);
        }
        columns.forEach(column => {
            column.dataType = data.value;
            column.ui.widthDataType = data.width;
        });
    }
    function executeChangeColumnDefault$1({ tableState: { tables } }, data) {
        const column = getColumn(tables, data.tableId, data.columnId);
        if (!column)
            return;
        column.default = data.value;
        column.ui.widthDefault = data.width;
    }
    function executeChangeColumnAutoIncrement$1({ tableState: { tables } }, data) {
        const column = getColumn(tables, data.tableId, data.columnId);
        if (!column)
            return;
        column.option.autoIncrement = data.value;
    }
    function executeChangeColumnPrimaryKey$1(state, data) {
        const { tableState: { tables }, } = state;
        const column = getColumn(tables, data.tableId, data.columnId);
        if (!column)
            return;
        if (data.value) {
            if (column.ui.fk) {
                column.ui.fk = false;
                column.ui.pfk = true;
            }
            else {
                column.ui.pk = true;
            }
        }
        else {
            if (column.ui.pfk) {
                column.ui.pfk = false;
                column.ui.fk = true;
            }
            else {
                column.ui.pk = false;
            }
        }
        column.option.primaryKey = data.value;
        // TODO: Refactoring
        validIdentification(state);
    }
    function executeChangeColumnUnique$1({ tableState: { tables } }, data) {
        const column = getColumn(tables, data.tableId, data.columnId);
        if (!column)
            return;
        column.option.unique = data.value;
    }
    function executeChangeColumnNotNull$1(state, data) {
        const { tableState: { tables }, } = state;
        const column = getColumn(tables, data.tableId, data.columnId);
        if (!column)
            return;
        column.option.notNull = data.value;
        // TODO: Refactoring
        validStartRelationship(state);
    }
    function executeMoveColumn$1(state, data) {
        const { tableState: { tables }, } = state;
        const currentTable = getData(tables, data.tableId);
        const currentColumns = [];
        data.columnIds.forEach(columnId => {
            const column = getColumn(tables, data.tableId, columnId);
            column && currentColumns.push(column);
        });
        const targetTable = getData(tables, data.targetTableId);
        const targetColumn = getColumn(tables, data.targetTableId, data.targetColumnId);
        if (!currentTable || !targetTable || !currentColumns.length || !targetColumn)
            return;
        if (data.tableId === data.targetTableId &&
            !data.columnIds.includes(data.targetColumnId)) {
            const targetIndex = getIndex(currentTable.columns, targetColumn.id);
            if (targetIndex === -1)
                return;
            currentColumns.forEach(currentColumn => {
                const currentIndex = getIndex(currentTable.columns, currentColumn.id);
                if (currentIndex === -1)
                    return;
                currentTable.columns.splice(currentIndex, 1);
            });
            currentTable.columns.splice(targetIndex, 0, ...currentColumns);
        }
        else if (data.tableId !== data.targetTableId &&
            !data.columnIds.includes(data.targetColumnId)) {
            const targetIndex = getIndex(targetTable.columns, targetColumn.id);
            if (targetIndex === -1)
                return;
            currentColumns.forEach(currentColumn => {
                const currentIndex = getIndex(currentTable.columns, currentColumn.id);
                if (currentIndex === -1)
                    return;
                currentTable.columns.splice(currentIndex, 1);
            });
            targetTable.columns.splice(targetIndex, 0, ...currentColumns);
            // TODO: Refactoring
            removeValidColumnIndex(state, currentTable, data.columnIds);
            removeValidColumnRelationship(state, currentTable, data.columnIds);
            validIdentification(state);
            validStartRelationship(state);
        }
    }
    function executeActiveColumn({ tableState: { tables } }, data) {
        data.forEach(activeColumn => {
            const table = getData(tables, activeColumn.tableId);
            if (!table)
                return;
            activeColumn.columnIds.forEach(columnId => {
                const column = getData(table.columns, columnId);
                column && (column.ui.active = true);
            });
        });
    }
    function executeActiveEndColumn({ tableState: { tables } }, data) {
        data.forEach(activeColumn => {
            const table = getData(tables, activeColumn.tableId);
            if (!table)
                return;
            activeColumn.columnIds.forEach(columnId => {
                const column = getData(table.columns, columnId);
                column && (column.ui.active = false);
            });
        });
    }
    function executeLoadColumn({ tableState: { tables } }, data) {
        const table = getData(tables, data.tableId);
        if (!table)
            return;
        data.columns.forEach((column, index) => {
            column.ui.active = false;
            table.columns.splice(data.indexList[index], 0, column);
        });
    }
    const executeColumnCommandMap$1 = {
        'column.add': executeAddColumn$1,
        'column.addCustom': executeAddCustomColumn$1,
        'column.remove': executeRemoveColumn$1,
        'column.removeOnly': executeRemoveOnlyColumn,
        'column.changeName': executeChangeColumnName$1,
        'column.changeComment': executeChangeColumnComment$1,
        'column.changeDataType': executeChangeColumnDataType$1,
        'column.changeDefault': executeChangeColumnDefault$1,
        'column.changeAutoIncrement': executeChangeColumnAutoIncrement$1,
        'column.changePrimaryKey': executeChangeColumnPrimaryKey$1,
        'column.changeUnique': executeChangeColumnUnique$1,
        'column.changeNotNull': executeChangeColumnNotNull$1,
        'column.move': executeMoveColumn$1,
        'column.active': executeActiveColumn,
        'column.activeEnd': executeActiveEndColumn,
        'column.load': executeLoadColumn,
    };

    const createFilterState = () => ({
        active: false,
        operatorType: 'OR',
        filters: [],
        focus: null,
        draggable: null,
    });
    const focusFilterTypes = [
        'columnType',
        'filterCode',
        'value',
    ];

    const createEditorState = () => ({
        panels: [],
        hasUndo: false,
        hasRedo: false,
        focusTable: null,
        drawRelationship: null,
        draggableColumn: null,
        viewport: {
            width: DEFAULT_WIDTH,
            height: DEFAULT_HEIGHT,
        },
        copyColumns: [],
        findActive: false,
        readonly: false,
        filterState: createFilterState(),
    });
    const moveKeys = [
        'ArrowDown',
        'ArrowLeft',
        'ArrowRight',
        'ArrowUp',
        'Tab',
    ];
    const tableTypes = ['tableName', 'tableComment'];

    const appendSelectColumns = (columnIds, columnId) => uniq$1([...columnIds, columnId]);
    function selectRangeColumns(columns, fromColumnId, toColumnId) {
        if (!fromColumnId || fromColumnId === toColumnId)
            return [toColumnId];
        const fromIndex = getIndex(columns, fromColumnId);
        const toIndex = getIndex(columns, toColumnId);
        if (fromIndex === -1)
            return [toColumnId];
        return range(fromIndex, toIndex).map(index => columns[index].id);
    }
    const appendSelectRangeColumns = (columns, columnIds, fromColumnId, toColumnId) => uniq$1([
        ...columnIds,
        ...selectRangeColumns(columns, fromColumnId, toColumnId),
    ]);

    function getColumnTypes({ canvasState: { show, setting: { columnOrder }, }, }) {
        const showKeys = [
            'columnName',
            ...Object.keys(show).filter(key => show[key]),
        ];
        const match = new RegExp(showKeys.join('|'), 'i');
        return [...columnOrder.filter(key => match.test(key))];
    }
    const isColumns = (focusTable) => !!focusTable.table.columns.length;
    function isLastColumn(state) {
        const { editorState: { focusTable }, } = state;
        if (!focusTable)
            return true;
        const columnTypes = getColumnTypes(state);
        const index = columnTypes.indexOf(focusTable.focusType);
        return index === columnTypes.length - 1;
    }
    function isFirstColumn(state) {
        const { editorState: { focusTable }, } = state;
        if (!focusTable)
            return true;
        const columnTypes = getColumnTypes(state);
        const index = columnTypes.indexOf(focusTable.focusType);
        return index === 0;
    }
    function isLastRowColumn({ table, columnId }) {
        if (!columnId)
            return true;
        const index = getIndex(table.columns, columnId);
        return index === table.columns.length - 1;
    }
    function isFirstRowColumn({ table, columnId }) {
        if (!columnId)
            return true;
        const index = getIndex(table.columns, columnId);
        return index === 0;
    }
    function getLastColumnType(state) {
        const columnTypes = getColumnTypes(state);
        return columnTypes[columnTypes.length - 1];
    }
    function getFirstColumnType(state) {
        const columnTypes = getColumnTypes(state);
        return columnTypes[0];
    }
    function getNextRightColumnType(state) {
        const { editorState: { focusTable }, } = state;
        if (!focusTable)
            return 'columnName';
        const columnTypes = getColumnTypes(state);
        const index = columnTypes.indexOf(focusTable.focusType);
        return isLastColumn(state) ? columnTypes[0] : columnTypes[index + 1];
    }
    function getNextLeftColumnType(state) {
        const { editorState: { focusTable }, } = state;
        if (!focusTable)
            return 'columnName';
        const columnTypes = getColumnTypes(state);
        const index = columnTypes.indexOf(focusTable.focusType);
        return isFirstColumn(state)
            ? columnTypes[columnTypes.length - 1]
            : columnTypes[index - 1];
    }
    function getRemoveFirstColumnId(focusTable, columnIds) {
        if (!focusTable.columnId)
            return null;
        const columnIndex = getIndex(focusTable.table.columns, focusTable.columnId);
        if (columnIndex <= 0)
            return null;
        let columnId = null;
        for (let i = columnIndex; i >= 0; i--) {
            const column = focusTable.table.columns[i];
            if (!columnIds.includes(column.id)) {
                columnId = column.id;
                break;
            }
        }
        return columnId;
    }
    function getTableTypes({ canvasState: { show } }) {
        return show.tableComment ? ['tableName', 'tableComment'] : ['tableName'];
    }
    function isLastTable(state) {
        const { editorState: { focusTable }, } = state;
        if (!focusTable)
            return true;
        const tableTypes = getTableTypes(state);
        const index = tableTypes.indexOf(focusTable.focusType);
        return index === tableTypes.length - 1;
    }
    function isFirstTable(state) {
        const { editorState: { focusTable }, } = state;
        if (!focusTable)
            return true;
        const tableTypes = getTableTypes(state);
        const index = tableTypes.indexOf(focusTable.focusType);
        return index === 0;
    }
    const isTableFocusType = (focusType) => tableTypes.includes(focusType);
    function getNextRightTableType(state) {
        const { editorState: { focusTable }, } = state;
        if (!focusTable)
            return 'tableName';
        const tableTypes = getTableTypes(state);
        const index = tableTypes.indexOf(focusTable.focusType);
        return isLastTable(state) ? tableTypes[0] : tableTypes[index + 1];
    }
    function getNextLeftTableType(state) {
        const { editorState: { focusTable }, } = state;
        if (!focusTable)
            return 'tableName';
        const tableTypes = getTableTypes(state);
        const index = tableTypes.indexOf(focusTable.focusType);
        return isFirstTable(state)
            ? tableTypes[tableTypes.length - 1]
            : tableTypes[index - 1];
    }
    function arrowUp$1(state, data) {
        const { editorState: { focusTable }, } = state;
        if (!focusTable)
            return;
        if (isTableFocusType(focusTable.focusType)) {
            if (isColumns(focusTable)) {
                const columnId = focusTable.table.columns[focusTable.table.columns.length - 1].id;
                focusTable.focusType = getLastColumnType(state);
                focusTable.columnId = columnId;
                focusTable.prevSelectColumnId = columnId;
                focusTable.selectColumnIds = [columnId];
            }
        }
        else {
            if (isFirstRowColumn(focusTable)) {
                focusTable.focusType = 'tableName';
                focusTable.columnId = null;
                focusTable.prevSelectColumnId = null;
                focusTable.selectColumnIds = [];
            }
            else if (focusTable.columnId) {
                const index = getIndex(focusTable.table.columns, focusTable.columnId);
                const column = focusTable.table.columns[index - 1];
                focusTable.columnId = column.id;
                focusTable.prevSelectColumnId = column.id;
                if (data.shiftKey && data.moveKey !== 'Tab') {
                    focusTable.selectColumnIds = appendSelectColumns(focusTable.selectColumnIds, column.id);
                }
                else {
                    focusTable.selectColumnIds = [column.id];
                }
            }
        }
    }
    function arrowDown$1(state, data) {
        const { editorState: { focusTable }, } = state;
        if (!focusTable)
            return;
        if (isTableFocusType(focusTable.focusType)) {
            if (isColumns(focusTable)) {
                const columnId = focusTable.table.columns[0].id;
                focusTable.focusType = getFirstColumnType(state);
                focusTable.columnId = columnId;
                focusTable.prevSelectColumnId = columnId;
                focusTable.selectColumnIds = [columnId];
            }
        }
        else {
            if (isLastRowColumn(focusTable)) {
                focusTable.focusType = 'tableName';
                focusTable.columnId = null;
                focusTable.prevSelectColumnId = null;
                focusTable.selectColumnIds = [];
            }
            else if (focusTable.columnId) {
                const index = getIndex(focusTable.table.columns, focusTable.columnId);
                const column = focusTable.table.columns[index + 1];
                focusTable.columnId = column.id;
                focusTable.prevSelectColumnId = column.id;
                if (data.shiftKey && data.moveKey !== 'Tab') {
                    focusTable.selectColumnIds = appendSelectColumns(focusTable.selectColumnIds, column.id);
                }
                else {
                    focusTable.selectColumnIds = [column.id];
                }
            }
        }
    }
    function arrowRight$1(state, data) {
        const { editorState: { focusTable }, } = state;
        if (!focusTable)
            return;
        if (isTableFocusType(focusTable.focusType)) {
            if (isLastTable(state)) {
                if (isColumns(focusTable)) {
                    const columnId = focusTable.table.columns[0].id;
                    focusTable.focusType = getFirstColumnType(state);
                    focusTable.columnId = columnId;
                    focusTable.prevSelectColumnId = columnId;
                    focusTable.selectColumnIds = [columnId];
                }
                else {
                    focusTable.focusType = getNextRightTableType(state);
                }
            }
            else {
                focusTable.focusType = getNextRightTableType(state);
            }
        }
        else {
            if (isLastColumn(state)) {
                if (isLastRowColumn(focusTable)) {
                    focusTable.focusType = 'tableName';
                    focusTable.columnId = null;
                    focusTable.prevSelectColumnId = null;
                    focusTable.selectColumnIds = [];
                }
                else if (focusTable.columnId) {
                    const index = getIndex(focusTable.table.columns, focusTable.columnId);
                    const column = focusTable.table.columns[index + 1];
                    focusTable.focusType = getFirstColumnType(state);
                    focusTable.columnId = column.id;
                    focusTable.prevSelectColumnId = column.id;
                    if (data.shiftKey && data.moveKey !== 'Tab') {
                        focusTable.selectColumnIds = appendSelectColumns(focusTable.selectColumnIds, column.id);
                    }
                    else {
                        focusTable.selectColumnIds = [column.id];
                    }
                }
            }
            else {
                focusTable.focusType = getNextRightColumnType(state);
                if (!data.shiftKey && focusTable.columnId) {
                    focusTable.prevSelectColumnId = focusTable.columnId;
                    focusTable.selectColumnIds = [focusTable.columnId];
                }
            }
        }
    }
    function arrowLeft$1(state, data) {
        const { editorState: { focusTable }, canvasState: { show }, } = state;
        if (!focusTable)
            return;
        if (isTableFocusType(focusTable.focusType)) {
            if (isFirstTable(state)) {
                if (isColumns(focusTable)) {
                    const columnId = focusTable.table.columns[focusTable.table.columns.length - 1].id;
                    focusTable.focusType = getLastColumnType(state);
                    focusTable.columnId = columnId;
                    focusTable.prevSelectColumnId = columnId;
                    focusTable.selectColumnIds = [columnId];
                }
                else {
                    focusTable.focusType = getNextLeftTableType(state);
                }
            }
            else {
                focusTable.focusType = getNextLeftTableType(state);
            }
        }
        else {
            if (isFirstColumn(state)) {
                if (isFirstRowColumn(focusTable)) {
                    focusTable.focusType = show.tableComment ? 'tableComment' : 'tableName';
                    focusTable.columnId = null;
                    focusTable.prevSelectColumnId = null;
                    focusTable.selectColumnIds = [];
                }
                else if (focusTable.columnId) {
                    const index = getIndex(focusTable.table.columns, focusTable.columnId);
                    const column = focusTable.table.columns[index - 1];
                    focusTable.focusType = getLastColumnType(state);
                    focusTable.columnId = column.id;
                    focusTable.prevSelectColumnId = column.id;
                    if (data.shiftKey && data.moveKey !== 'Tab') {
                        focusTable.selectColumnIds = appendSelectColumns(focusTable.selectColumnIds, column.id);
                    }
                    else {
                        focusTable.selectColumnIds = [column.id];
                    }
                }
            }
            else {
                focusTable.focusType = getNextLeftColumnType(state);
                if (!data.shiftKey && focusTable.columnId) {
                    focusTable.prevSelectColumnId = focusTable.columnId;
                    focusTable.selectColumnIds = [focusTable.columnId];
                }
            }
        }
    }

    const zIndexMap = (data) => data.ui.zIndex;
    const nextZIndex = (tables, memos) => Math.max(1, ...tables.map(zIndexMap), ...memos.map(zIndexMap)) + 1;
    const isDuplicatePosition = (ui, point) => ui.top === point.y && ui.left === point.x;
    function nextPoint({ canvasState: { scrollLeft, scrollTop }, tableState: { tables }, memoState: { memos }, }) {
        const point = {
            x: SIZE_START_X - scrollLeft,
            y: SIZE_START_Y - scrollTop,
        };
        let isPosition = false;
        do {
            isPosition = false;
            for (const table of tables) {
                if (isDuplicatePosition(table.ui, point)) {
                    point.x += SIZE_START_ADD;
                    point.y += SIZE_START_ADD;
                    isPosition = true;
                    break;
                }
            }
            for (const memo of memos) {
                if (isDuplicatePosition(memo.ui, point)) {
                    point.x += SIZE_START_ADD;
                    point.y += SIZE_START_ADD;
                    isPosition = true;
                    break;
                }
            }
        } while (isPosition);
        return point;
    }

    function addRelationship(relationshipType, startTable, endTableId, constraintName) {
        const columnIds = startTable.columns
            .filter(column => column.option.primaryKey)
            .map(column => column.id);
        return createCommand$1('relationship.add', {
            id: v4(),
            relationshipType,
            start: {
                tableId: startTable.id,
                columnIds,
            },
            end: {
                tableId: endTableId,
                columnIds: columnIds.map(() => v4()),
            },
            constraintName,
        });
    }
    const removeRelationship = (relationshipIds) => createCommand$1('relationship.remove', { relationshipIds });
    const changeRelationshipType = (relationshipId, relationshipType) => createCommand$1('relationship.changeRelationshipType', {
        relationshipId,
        relationshipType,
    });
    const changeStartRelationshipType = (relationshipId, startRelationshipType) => createCommand$1('relationship.changeStartRelationshipType', {
        relationshipId,
        startRelationshipType,
    });
    const changeIdentification = (relationshipId, identification) => createCommand$1('relationship.changeIdentification', {
        relationshipId,
        identification,
    });
    const loadRelationship = (relationship) => createCommand$1('relationship.load', relationship);

    var relationshipCommand = /*#__PURE__*/Object.freeze({
        __proto__: null,
        addRelationship: addRelationship,
        removeRelationship: removeRelationship,
        changeRelationshipType: changeRelationshipType,
        changeStartRelationshipType: changeStartRelationshipType,
        changeIdentification: changeIdentification,
        loadRelationship: loadRelationship
    });

    function* addTable$(store, active = true) {
        yield selectEndTable();
        yield selectEndMemo();
        const addTableCmd = addTable(store, active);
        yield addTableCmd;
        yield focusTable(addTableCmd.data.id);
    }
    function* selectTable$(store, ctrlKey, tableId) {
        const { editorState: { drawRelationship }, } = store;
        yield selectTable(store, ctrlKey, tableId);
        if (!ctrlKey) {
            yield selectEndMemo();
        }
        yield focusTable(tableId);
        if (!drawRelationship)
            return;
        if (drawRelationship.start) {
            const endTable = getData(store.tableState.tables, tableId);
            const fkName = `fk_${drawRelationship.start.table.name}_to_${endTable === null || endTable === void 0 ? void 0 : endTable.name}`.toLowerCase();
            const addRelationshipCmd = addRelationship(drawRelationship.relationshipType, drawRelationship.start.table, tableId, fkName);
            const startTable = drawRelationship.start.table;
            const { start, end } = addRelationshipCmd.data;
            const createEndColumns = [];
            start.columnIds.forEach((startColumnId, index) => {
                const startColumn = getData(startTable.columns, startColumnId);
                if (!startColumn)
                    return;
                createEndColumns.push({
                    tableId: end.tableId,
                    id: end.columnIds[index],
                    option: {
                        autoIncrement: false,
                        primaryKey: false,
                        unique: false,
                        notNull: true,
                    },
                    ui: {
                        active: false,
                        pk: false,
                        fk: true,
                        pfk: false,
                    },
                    value: {
                        name: startColumn.name,
                        comment: startColumn.comment,
                        dataType: startColumn.dataType,
                        default: startColumn.default,
                        widthName: startColumn.ui.widthName,
                        widthComment: startColumn.ui.widthComment,
                        widthDataType: startColumn.ui.widthDataType,
                        widthDefault: startColumn.ui.widthDefault,
                    },
                });
            });
            yield createCommand$1('column.addCustom', createEndColumns);
            yield addRelationshipCmd;
            yield drawEndRelationship();
        }
        else {
            yield drawStartAddRelationship$(store, tableId);
        }
    }
    function* selectEndTable$() {
        yield selectEndTable();
        yield focusTableEnd();
    }

    function addTable(store, active = true) {
        const { tableState, memoState } = store;
        const point = nextPoint(store);
        return createCommand$1('table.add', {
            id: v4(),
            ui: {
                active,
                left: point.x,
                top: point.y,
                zIndex: nextZIndex(tableState.tables, memoState.memos),
            },
        });
    }
    const moveTable = ({ tableState: { tables }, memoState: { memos }, canvasState: { zoomLevel }, }, ctrlKey, movementX, movementY, tableId) => createCommand$1('table.move', {
        movementX: movementX / zoomLevel,
        movementY: movementY / zoomLevel,
        tableIds: ctrlKey
            ? tables.filter(table => table.ui.active).map(table => table.id)
            : [tableId],
        memoIds: ctrlKey
            ? memos.filter(memo => memo.ui.active).map(memo => memo.id)
            : [],
    });
    const removeTable = ({ tableState: { tables } }, tableId) => createCommand$1('table.remove', {
        tableIds: tableId
            ? [tableId]
            : tables.filter(table => table.ui.active).map(table => table.id),
    });
    const selectTable = ({ tableState: { tables }, memoState: { memos }, }, ctrlKey, tableId) => createCommand$1('table.select', {
        ctrlKey,
        tableId,
        zIndex: nextZIndex(tables, memos),
    });
    const selectEndTable = () => createCommand$1('table.selectEnd', null);
    const selectAllTable = () => createCommand$1('table.selectAll', null);
    function changeTableName(helper, tableId, value) {
        const width = helper.getTableHeadTextWidth(value);
        return createCommand$1('table.changeName', {
            tableId,
            value,
            width: width < SIZE_MIN_WIDTH ? SIZE_MIN_WIDTH : width,
        });
    }
    function changeTableComment(helper, tableId, value) {
        const width = helper.getTableHeadTextWidth(value);
        return createCommand$1('table.changeComment', {
            tableId,
            value,
            width: width < SIZE_MIN_WIDTH ? SIZE_MIN_WIDTH : width,
        });
    }
    const dragSelectTable = (min, max) => createCommand$1('table.dragSelect', {
        min,
        max,
    });
    const sortTable = () => createCommand$1('table.sort', null);
    const loadTable = (table) => createCommand$1('table.load', table);

    var tableCommand = /*#__PURE__*/Object.freeze({
        __proto__: null,
        addTable: addTable,
        moveTable: moveTable,
        removeTable: removeTable,
        selectTable: selectTable,
        selectEndTable: selectEndTable,
        selectAllTable: selectAllTable,
        changeTableName: changeTableName,
        changeTableComment: changeTableComment,
        dragSelectTable: dragSelectTable,
        sortTable: sortTable,
        loadTable: loadTable,
        addTable$: addTable$,
        selectTable$: selectTable$,
        selectEndTable$: selectEndTable$
    });

    function* addMemo$(store, active = true) {
        yield selectEndTable$();
        yield selectEndMemo();
        yield addMemo(store, active);
    }
    function* selectMemo$(store, ctrlKey, memoId) {
        yield selectMemo(store, ctrlKey, memoId);
        if (!ctrlKey) {
            yield selectEndTable$();
        }
    }

    function addMemo(store, active = true) {
        const { tableState, memoState } = store;
        const point = nextPoint(store);
        return createCommand$1('memo.add', {
            id: v4(),
            ui: {
                active,
                left: point.x,
                top: point.y,
                zIndex: nextZIndex(tableState.tables, memoState.memos),
                width: SIZE_MEMO_WIDTH,
                height: SIZE_MEMO_HEIGHT,
            },
        });
    }
    const moveMemo = ({ tableState: { tables }, memoState: { memos }, canvasState: { zoomLevel }, }, ctrlKey, movementX, movementY, memoId) => createCommand$1('memo.move', {
        movementX: movementX / zoomLevel,
        movementY: movementY / zoomLevel,
        tableIds: ctrlKey
            ? tables.filter(table => table.ui.active).map(table => table.id)
            : [],
        memoIds: ctrlKey
            ? memos.filter(memo => memo.ui.active).map(memo => memo.id)
            : [memoId],
    });
    const removeMemo = ({ memoState: { memos } }, memoId) => createCommand$1('memo.remove', {
        memoIds: memoId
            ? [memoId]
            : memos.filter(memo => memo.ui.active).map(memo => memo.id),
    });
    const selectMemo = ({ tableState: { tables }, memoState: { memos }, }, ctrlKey, memoId) => createCommand$1('memo.select', {
        ctrlKey,
        memoId,
        zIndex: nextZIndex(tables, memos),
    });
    const selectEndMemo = () => createCommand$1('memo.selectEnd', null);
    const selectAllMemo = () => createCommand$1('memo.selectAll', null);
    const changeMemoValue = (memoId, value) => createCommand$1('memo.changeValue', { memoId, value });
    const resizeMemo = (memoId, top, left, width, height) => createCommand$1('memo.resize', {
        memoId,
        top,
        left,
        width,
        height,
    });
    const dragSelectMemo = (min, max) => createCommand$1('memo.dragSelect', { min, max });
    const loadMemo = (memo) => createCommand$1('memo.load', memo);

    var memoCommand = /*#__PURE__*/Object.freeze({
        __proto__: null,
        addMemo: addMemo,
        moveMemo: moveMemo,
        removeMemo: removeMemo,
        selectMemo: selectMemo,
        selectEndMemo: selectEndMemo,
        selectAllMemo: selectAllMemo,
        changeMemoValue: changeMemoValue,
        resizeMemo: resizeMemo,
        dragSelectMemo: dragSelectMemo,
        loadMemo: loadMemo,
        addMemo$: addMemo$,
        selectMemo$: selectMemo$
    });

    function* focusMoveTable$(store, moveKey, shiftKey) {
        const { editorState: { focusTable }, } = store;
        if (!focusTable)
            return;
        if (moveKey === 'Tab' &&
            !shiftKey &&
            ((isTableFocusType(focusTable.focusType) &&
                isLastTable(store) &&
                !isColumns(focusTable)) ||
                (!isTableFocusType(focusTable.focusType) &&
                    isLastColumn(store) &&
                    isLastRowColumn(focusTable)))) {
            yield addColumn$(store, focusTable.table.id);
        }
        else {
            yield focusMoveTable(moveKey, shiftKey);
        }
    }
    function* drawStartRelationship$({ editorState }, relationshipType) {
        var _a;
        if (((_a = editorState.drawRelationship) === null || _a === void 0 ? void 0 : _a.relationshipType) === relationshipType) {
            yield drawEndRelationship();
        }
        else {
            yield drawStartRelationship(relationshipType);
        }
    }
    function* drawStartAddRelationship$({ tableState: { tables } }, tableId) {
        const table = getData(tables, tableId);
        if (!table)
            return;
        if (!table.columns.some(column => column.option.primaryKey)) {
            const addCustomColumnCmd = addCustomColumn({
                autoIncrement: false,
                primaryKey: true,
                unique: false,
                notNull: true,
            }, {
                active: false,
                pk: true,
                fk: false,
                pfk: false,
            }, null, [tableId]);
            yield addCustomColumnCmd;
            const column = addCustomColumnCmd.data[0];
            yield focusColumn(tableId, column.id, 'columnName');
        }
        yield drawStartAddRelationship(tableId);
    }
    function* loadJson$(value) {
        yield clear();
        yield loadJson(value);
    }
    function* initLoadJson$(value) {
        yield initClear();
        yield initLoadJson(value);
    }
    function* pasteColumn$({ editorState, tableState: { tables } }) {
        const copyColumns = [...editorState.copyColumns];
        const tableIds = tables
            .filter(table => table.ui.active)
            .map(table => table.id);
        while (copyColumns.length && tableIds.length) {
            const column = copyColumns.shift();
            const { option, ui } = column;
            yield addCustomColumn({
                autoIncrement: option.autoIncrement,
                primaryKey: option.primaryKey,
                unique: option.unique,
                notNull: option.notNull,
            }, {
                active: false,
                pk: option.primaryKey,
                fk: false,
                pfk: false,
            }, {
                name: column.name,
                dataType: column.dataType,
                default: column.default,
                comment: column.comment,
                widthName: ui.widthName,
                widthDataType: ui.widthDataType,
                widthDefault: ui.widthDefault,
                widthComment: ui.widthComment,
            }, tableIds);
        }
    }
    function* findActive$() {
        yield findActive();
        yield selectEndTable$();
        yield selectEndMemo();
    }
    function* readonlyEditor$(readonly) {
        if (readonly) {
            yield editTableEnd();
            yield drawEndRelationship();
            yield draggableColumnEnd();
            yield readonlyEditor(readonly);
        }
        else {
            yield readonlyEditor(readonly);
        }
    }

    const appendSelectFilters = (filterIds, filterId) => uniq$1([...filterIds, filterId]);
    function selectRangeFilters(filters, fromFilterId, toFilterId) {
        if (!fromFilterId || fromFilterId === toFilterId)
            return [toFilterId];
        const fromIndex = getIndex(filters, fromFilterId);
        const toIndex = getIndex(filters, toFilterId);
        if (fromIndex === -1)
            return [toFilterId];
        return range(fromIndex, toIndex).map(index => filters[index].id);
    }
    const appendSelectRangeFilters = (filters, filterIds, fromFilterId, toFilterId) => uniq$1([
        ...filterIds,
        ...selectRangeFilters(filters, fromFilterId, toFilterId),
    ]);

    const isFilterFocusType = (focusType) => focusFilterTypes.includes(focusType);
    const isFilters = (state) => !!state.filters.length;
    function isFirstRowFilter({ filters, focus }) {
        if (!focus || !focus.filterId)
            return;
        const index = getIndex(filters, focus.filterId);
        return index === 0;
    }
    function isLastRowFilter({ filters, focus }) {
        if (!focus || !focus.filterId)
            return;
        const index = getIndex(filters, focus.filterId);
        return index === filters.length - 1;
    }
    function isLastFilterColumn({ focus }) {
        if (!focus || !focus.filterId)
            return;
        const index = focusFilterTypes.indexOf(focus.focusType);
        return index === focusFilterTypes.length - 1;
    }
    function isFirstFilterColumn({ focus }) {
        if (!focus || !focus.filterId)
            return;
        const index = focusFilterTypes.indexOf(focus.focusType);
        return index === 0;
    }
    function getNextRightFilterColumnType(state) {
        const { focus } = state;
        if (!focus || !focus.filterId)
            return 'columnType';
        const index = focusFilterTypes.indexOf(focus.focusType);
        return isLastFilterColumn(state)
            ? focusFilterTypes[0]
            : focusFilterTypes[index + 1];
    }
    function getNextLeftFilterColumnType(state) {
        const { focus } = state;
        if (!focus || !focus.filterId)
            return 'columnType';
        const index = focusFilterTypes.indexOf(focus.focusType);
        return isFirstFilterColumn(state)
            ? focusFilterTypes[focusFilterTypes.length - 1]
            : focusFilterTypes[index - 1];
    }
    function getRemoveFirstFilterId({ focus, filters }, filterIds) {
        if (!(focus === null || focus === void 0 ? void 0 : focus.filterId))
            return null;
        const filterIndex = getIndex(filters, focus.filterId);
        if (filterIndex <= 0)
            return null;
        let filterId = null;
        for (let i = filterIndex; i >= 0; i--) {
            const filter = filters[i];
            if (!filterIds.includes(filter.id)) {
                filterId = filter.id;
                break;
            }
        }
        return filterId;
    }
    function arrowUp(state, data) {
        const { focus, filters } = state;
        if (!focus)
            return;
        if (isFilterFocusType(focus.focusType)) {
            if (isFirstRowFilter(state)) {
                focus.focusType = 'operatorType';
                focus.filterId = null;
                focus.prevSelectFilterId = null;
                focus.selectFilterIds = [];
            }
            else if (focus.filterId) {
                const index = getIndex(filters, focus.filterId);
                const filter = filters[index - 1];
                focus.filterId = filter.id;
                focus.prevSelectFilterId = filter.id;
                if (data.shiftKey && data.moveKey !== 'Tab') {
                    focus.selectFilterIds = appendSelectFilters(focus.selectFilterIds, filter.id);
                }
                else {
                    focus.selectFilterIds = [filter.id];
                }
            }
        }
        else {
            if (isFilters(state)) {
                const filterId = filters[filters.length - 1].id;
                focus.focusType = 'value';
                focus.filterId = filterId;
                focus.prevSelectFilterId = filterId;
                focus.selectFilterIds = [filterId];
            }
        }
    }
    function arrowDown(state, data) {
        const { focus, filters } = state;
        if (!focus)
            return;
        if (isFilterFocusType(focus.focusType)) {
            if (isLastRowFilter(state)) {
                focus.focusType = 'operatorType';
                focus.filterId = null;
                focus.prevSelectFilterId = null;
                focus.selectFilterIds = [];
            }
            else if (focus.filterId) {
                const index = getIndex(filters, focus.filterId);
                const filter = filters[index + 1];
                focus.filterId = filter.id;
                focus.prevSelectFilterId = filter.id;
                if (data.shiftKey && data.moveKey !== 'Tab') {
                    focus.selectFilterIds = appendSelectFilters(focus.selectFilterIds, filter.id);
                }
                else {
                    focus.selectFilterIds = [filter.id];
                }
            }
        }
        else {
            if (isFilters(state)) {
                const filterId = filters[0].id;
                focus.focusType = 'columnType';
                focus.filterId = filterId;
                focus.prevSelectFilterId = filterId;
                focus.selectFilterIds = [filterId];
            }
        }
    }
    function arrowRight(state, data) {
        const { focus, filters } = state;
        if (!focus)
            return;
        if (isFilterFocusType(focus.focusType)) {
            if (isLastFilterColumn(state)) {
                if (isLastRowFilter(state)) {
                    focus.focusType = 'operatorType';
                    focus.filterId = null;
                    focus.prevSelectFilterId = null;
                    focus.selectFilterIds = [];
                }
                else if (focus.filterId) {
                    const index = getIndex(filters, focus.filterId);
                    const filter = filters[index + 1];
                    focus.focusType = 'columnType';
                    focus.filterId = filter.id;
                    focus.prevSelectFilterId = filter.id;
                    if (data.shiftKey && data.moveKey !== 'Tab') {
                        focus.selectFilterIds = appendSelectFilters(focus.selectFilterIds, filter.id);
                    }
                    else {
                        focus.selectFilterIds = [filter.id];
                    }
                }
            }
            else {
                focus.focusType = getNextRightFilterColumnType(state);
                if (!data.shiftKey && focus.filterId) {
                    focus.prevSelectFilterId = focus.filterId;
                    focus.selectFilterIds = [focus.filterId];
                }
            }
        }
        else {
            if (isFilters(state)) {
                const filterId = filters[0].id;
                focus.focusType = 'columnType';
                focus.filterId = filterId;
                focus.prevSelectFilterId = filterId;
                focus.selectFilterIds = [filterId];
            }
        }
    }
    function arrowLeft(state, data) {
        const { focus, filters } = state;
        if (!focus)
            return;
        if (isFilterFocusType(focus.focusType)) {
            if (isFirstFilterColumn(state)) {
                if (isFirstRowFilter(state)) {
                    focus.focusType = 'operatorType';
                    focus.filterId = null;
                    focus.prevSelectFilterId = null;
                    focus.selectFilterIds = [];
                }
                else if (focus.filterId) {
                    const index = getIndex(filters, focus.filterId);
                    const filter = filters[index - 1];
                    focus.focusType = 'value';
                    focus.filterId = filter.id;
                    focus.prevSelectFilterId = filter.id;
                    if (data.shiftKey && data.moveKey !== 'Tab') {
                        focus.selectFilterIds = appendSelectFilters(focus.selectFilterIds, filter.id);
                    }
                    else {
                        focus.selectFilterIds = [filter.id];
                    }
                }
            }
            else {
                focus.focusType = getNextLeftFilterColumnType(state);
                if (!data.shiftKey && focus.filterId) {
                    focus.prevSelectFilterId = focus.filterId;
                    focus.selectFilterIds = [focus.filterId];
                }
            }
        }
        else {
            if (isFilters(state)) {
                const filterId = filters[filters.length - 1].id;
                focus.focusType = 'value';
                focus.filterId = filterId;
                focus.prevSelectFilterId = filterId;
                focus.selectFilterIds = [filterId];
            }
        }
    }

    function* filterActive$() {
        yield filterActive();
        yield filterFocus();
    }
    function* filterActiveEnd$() {
        yield filterActiveEnd();
        yield focusFilterEnd();
    }
    function* addFilter$() {
        const addFilterCmd = addFilter();
        yield addFilterCmd;
        yield focusFilter(addFilterCmd.data.id, 'columnType');
    }
    function* removeFilter$({ editorState: { filterState } }, filterIds) {
        if (filterState.focus && filterState.focus.filterId) {
            const filterId = getRemoveFirstFilterId(filterState, filterIds);
            if (filterId) {
                yield focusFilter(filterId, filterState.focus.focusType);
            }
            else {
                yield filterFocus();
            }
        }
        yield removeFilter(filterIds);
    }
    function* focusMoveFilter$({ editorState: { filterState } }, moveKey, shiftKey) {
        const { focus } = filterState;
        if (!focus)
            return;
        if ((moveKey === 'Tab' &&
            !shiftKey &&
            isFilterFocusType(focus.focusType) &&
            isLastFilterColumn(filterState) &&
            isLastRowFilter(filterState)) ||
            (!isFilterFocusType(focus.focusType) && !isFilters(filterState))) {
            yield addFilter$();
        }
        else {
            yield focusMoveFilter(moveKey, shiftKey);
        }
    }

    const filterActive = () => createCommand$1('editor.filter.active', null);
    const filterActiveEnd = () => createCommand$1('editor.filter.activeEnd', null);
    const addFilter = () => createCommand$1('editor.filter.add', {
        id: v4(),
    });
    const removeFilter = (filterIds) => createCommand$1('editor.filter.remove', {
        filterIds,
    });
    const changeFilterColumnType = (filterId, columnType) => createCommand$1('editor.filter.changeColumnType', {
        filterId,
        columnType,
    });
    const changeFilterCode = (filterId, filterCode) => createCommand$1('editor.filter.changeFilterCode', {
        filterId,
        filterCode,
    });
    const changeFilterValue = (filterId, value) => createCommand$1('editor.filter.changeValue', {
        filterId,
        value,
    });
    const moveFilter = (filterIds, targetFilterId) => createCommand$1('editor.filter.move', {
        filterIds,
        targetFilterId,
    });
    const changeFilterOperatorType = (operatorType) => createCommand$1('editor.filter.changeOperatorType', {
        operatorType,
    });
    const filterFocus = (focusType) => createCommand$1('editor.filter.focus', {
        focusType,
    });
    const focusFilter = (filterId, focusType, ctrlKey = false, shiftKey = false) => createCommand$1('editor.filter.focusFilter', {
        filterId,
        focusType,
        ctrlKey,
        shiftKey,
    });
    const focusFilterEnd = () => createCommand$1('editor.filter.focusEnd', null);
    const focusMoveFilter = (moveKey, shiftKey) => createCommand$1('editor.filter.focusMove', {
        moveKey,
        shiftKey,
    });
    const editFilter = () => createCommand$1('editor.filter.edit', null);
    const editFilterEnd = () => createCommand$1('editor.filter.editEnd', null);
    const selectAllFilter = () => createCommand$1('editor.filter.selectAll', null);
    const draggableFilter = ({ editorState: { filterState: { focus }, }, }, filterId, ctrlKey) => createCommand$1('editor.filter.draggable', {
        filterIds: ctrlKey && focus ? [...focus.selectFilterIds] : [filterId],
    });
    const draggableFilterEnd = () => createCommand$1('editor.filter.draggableEnd', null);

    const hasUndoRedo = (hasUndo, hasRedo) => createCommand$1('editor.hasUndoRedo', { hasUndo, hasRedo });
    const focusTable = (tableId, focusType) => createCommand$1('editor.focusTable', { tableId, focusType });
    const focusColumn = (tableId, columnId, focusType, ctrlKey = false, shiftKey = false) => createCommand$1('editor.focusColumn', {
        tableId,
        columnId,
        focusType,
        ctrlKey,
        shiftKey,
    });
    const focusTableEnd = () => createCommand$1('editor.focusTableEnd', null);
    const focusMoveTable = (moveKey, shiftKey) => createCommand$1('editor.focusMoveTable', { moveKey, shiftKey });
    const editTable = () => createCommand$1('editor.editTable', null);
    const editTableEnd = () => createCommand$1('editor.editTableEnd', null);
    const selectAllColumn = () => createCommand$1('editor.selectAllColumn', null);
    const drawStartRelationship = (relationshipType) => createCommand$1('editor.drawStartRelationship', { relationshipType });
    const drawStartAddRelationship = (tableId) => createCommand$1('editor.drawStartAddRelationship', { tableId });
    const drawEndRelationship = () => createCommand$1('editor.drawEndRelationship', null);
    const drawRelationship = (x, y) => createCommand$1('editor.drawRelationship', { x, y });
    const draggableColumn = ({ editorState: { focusTable } }, tableId, columnId, ctrlKey) => createCommand$1('editor.draggableColumn', {
        tableId,
        columnIds: ctrlKey && focusTable ? [...focusTable.selectColumnIds] : [columnId],
    });
    const draggableColumnEnd = () => createCommand$1('editor.draggableColumnEnd', null);
    const loadJson = (value) => createCommand$1('editor.loadJson', { value });
    const initLoadJson = (value) => createCommand$1('editor.initLoadJson', { value });
    const clear = () => createCommand$1('editor.clear', null);
    const initClear = () => createCommand$1('editor.initClear', null);
    const changeViewport = (width, height) => createCommand$1('editor.changeViewport', { width, height });
    const copyColumn = (tableId, columnIds) => createCommand$1('editor.copyColumn', {
        tableId,
        columnIds,
    });
    const findActive = () => createCommand$1('editor.findActive', null);
    const findActiveEnd = () => createCommand$1('editor.findActiveEnd', null);
    const readonlyEditor = (readonly) => createCommand$1('editor.readonly', { readonly });

    var editorCommand = /*#__PURE__*/Object.freeze({
        __proto__: null,
        hasUndoRedo: hasUndoRedo,
        focusTable: focusTable,
        focusColumn: focusColumn,
        focusTableEnd: focusTableEnd,
        focusMoveTable: focusMoveTable,
        editTable: editTable,
        editTableEnd: editTableEnd,
        selectAllColumn: selectAllColumn,
        drawStartRelationship: drawStartRelationship,
        drawStartAddRelationship: drawStartAddRelationship,
        drawEndRelationship: drawEndRelationship,
        drawRelationship: drawRelationship,
        draggableColumn: draggableColumn,
        draggableColumnEnd: draggableColumnEnd,
        loadJson: loadJson,
        initLoadJson: initLoadJson,
        clear: clear,
        initClear: initClear,
        changeViewport: changeViewport,
        copyColumn: copyColumn,
        findActive: findActive,
        findActiveEnd: findActiveEnd,
        readonlyEditor: readonlyEditor,
        focusMoveTable$: focusMoveTable$,
        drawStartRelationship$: drawStartRelationship$,
        drawStartAddRelationship$: drawStartAddRelationship$,
        loadJson$: loadJson$,
        initLoadJson$: initLoadJson$,
        pasteColumn$: pasteColumn$,
        findActive$: findActive$,
        readonlyEditor$: readonlyEditor$,
        filterActive$: filterActive$,
        filterActiveEnd$: filterActiveEnd$,
        addFilter$: addFilter$,
        removeFilter$: removeFilter$,
        focusMoveFilter$: focusMoveFilter$,
        filterActive: filterActive,
        filterActiveEnd: filterActiveEnd,
        addFilter: addFilter,
        removeFilter: removeFilter,
        changeFilterColumnType: changeFilterColumnType,
        changeFilterCode: changeFilterCode,
        changeFilterValue: changeFilterValue,
        moveFilter: moveFilter,
        changeFilterOperatorType: changeFilterOperatorType,
        filterFocus: filterFocus,
        focusFilter: focusFilter,
        focusFilterEnd: focusFilterEnd,
        focusMoveFilter: focusMoveFilter,
        editFilter: editFilter,
        editFilterEnd: editFilterEnd,
        selectAllFilter: selectAllFilter,
        draggableFilter: draggableFilter,
        draggableFilterEnd: draggableFilterEnd
    });

    function* addColumn$(store, tableId) {
        const addColumnCmd = addColumn(store, tableId);
        yield addColumnCmd;
        const column = addColumnCmd.data[addColumnCmd.data.length - 1];
        yield focusColumn(column.tableId, column.id, 'columnName');
    }
    function* removeColumn$({ editorState }, tableId, columnIds) {
        if (editorState.focusTable && editorState.focusTable.columnId) {
            const columnId = getRemoveFirstColumnId(editorState.focusTable, columnIds);
            if (columnId) {
                yield focusColumn(editorState.focusTable.table.id, columnId, editorState.focusTable.focusType);
            }
            else {
                yield focusTable(editorState.focusTable.table.id, 'tableName');
            }
        }
        yield removeColumn(tableId, columnIds);
    }
    function* changeColumnPrimaryKey$(store, tableId, columnId) {
        const { tableState: { tables }, } = store;
        const changeColumnPrimaryKeyCmd = changeColumnPrimaryKey(store, tableId, columnId);
        yield changeColumnPrimaryKeyCmd;
        const column = getColumn(tables, tableId, columnId);
        if (!changeColumnPrimaryKeyCmd.data.value || !column || column.option.notNull)
            return;
        yield changeColumnNotNull(store, tableId, columnId);
    }
    function* moveColumn$(store, tableId, columnIds, targetTableId, targetColumnId) {
        yield moveColumn(tableId, columnIds, targetTableId, targetColumnId);
        if (tableId === targetTableId || columnIds.includes(targetColumnId))
            return;
        yield createCommand$1('editor.draggableColumn', {
            tableId: targetTableId,
            columnIds,
        });
        yield selectTable(store, false, targetTableId);
        yield focusColumn(targetTableId, columnIds[0], 'columnName');
    }

    const addColumn = (store, tableId) => createCommand$1('column.add', tableId
        ? [
            {
                id: v4(),
                tableId,
            },
        ]
        : store.tableState.tables
            .filter(table => table.ui.active)
            .map(table => {
            return {
                id: v4(),
                tableId: table.id,
            };
        }));
    const addCustomColumn = (option, ui, value, tableIds) => createCommand$1('column.addCustom', tableIds.map(tableId => ({
        tableId,
        id: v4(),
        option,
        ui,
        value,
    })));
    const removeColumn = (tableId, columnIds) => createCommand$1('column.remove', {
        tableId,
        columnIds,
    });
    const removeOnlyColumn = (tableId, columnIds) => createCommand$1('column.removeOnly', {
        tableId,
        columnIds,
    });
    function changeColumnName(helper, tableId, columnId, value) {
        const width = helper.getTextWidth(value);
        return createCommand$1('column.changeName', {
            tableId,
            columnId,
            value,
            width: width < SIZE_MIN_WIDTH ? SIZE_MIN_WIDTH : width,
        });
    }
    function changeColumnComment(helper, tableId, columnId, value) {
        const width = helper.getTextWidth(value);
        return createCommand$1('column.changeComment', {
            tableId,
            columnId,
            value,
            width: width < SIZE_MIN_WIDTH ? SIZE_MIN_WIDTH : width,
        });
    }
    function changeColumnDataType(helper, tableId, columnId, value) {
        const width = helper.getTextWidth(value);
        return createCommand$1('column.changeDataType', {
            tableId,
            columnId,
            value,
            width: width < SIZE_MIN_WIDTH ? SIZE_MIN_WIDTH : width,
        });
    }
    function changeColumnDefault(helper, tableId, columnId, value) {
        const width = helper.getTextWidth(value);
        return createCommand$1('column.changeDefault', {
            tableId,
            columnId,
            value,
            width: width < SIZE_MIN_WIDTH ? SIZE_MIN_WIDTH : width,
        });
    }
    const changeColumnAutoIncrement = ({ tableState: { tables } }, tableId, columnId) => createCommand$1('column.changeAutoIncrement', {
        tableId,
        columnId,
        value: getChangeOption(tables, tableId, columnId, 'autoIncrement'),
    });
    const changeColumnPrimaryKey = ({ tableState: { tables } }, tableId, columnId) => createCommand$1('column.changePrimaryKey', {
        tableId,
        columnId,
        value: getChangeOption(tables, tableId, columnId, 'primaryKey'),
    });
    const changeColumnUnique = ({ tableState: { tables } }, tableId, columnId) => createCommand$1('column.changeUnique', {
        tableId,
        columnId,
        value: getChangeOption(tables, tableId, columnId, 'unique'),
    });
    const changeColumnNotNull = ({ tableState: { tables } }, tableId, columnId) => createCommand$1('column.changeNotNull', {
        tableId,
        columnId,
        value: getChangeOption(tables, tableId, columnId, 'notNull'),
    });
    const moveColumn = (tableId, columnIds, targetTableId, targetColumnId) => createCommand$1('column.move', {
        tableId,
        columnIds,
        targetTableId,
        targetColumnId,
    });
    const activeColumn = ({ start, end }) => createCommand$1('column.active', [
        {
            tableId: start.tableId,
            columnIds: start.columnIds,
        },
        {
            tableId: end.tableId,
            columnIds: end.columnIds,
        },
    ]);
    const activeEndColumn = ({ start, end }) => createCommand$1('column.activeEnd', [
        {
            tableId: start.tableId,
            columnIds: start.columnIds,
        },
        {
            tableId: end.tableId,
            columnIds: end.columnIds,
        },
    ]);
    const loadColumn = (tableId, columns, indexList) => createCommand$1('column.load', {
        tableId,
        columns,
        indexList,
    });

    var columnCommand = /*#__PURE__*/Object.freeze({
        __proto__: null,
        addColumn: addColumn,
        addCustomColumn: addCustomColumn,
        removeColumn: removeColumn,
        removeOnlyColumn: removeOnlyColumn,
        changeColumnName: changeColumnName,
        changeColumnComment: changeColumnComment,
        changeColumnDataType: changeColumnDataType,
        changeColumnDefault: changeColumnDefault,
        changeColumnAutoIncrement: changeColumnAutoIncrement,
        changeColumnPrimaryKey: changeColumnPrimaryKey,
        changeColumnUnique: changeColumnUnique,
        changeColumnNotNull: changeColumnNotNull,
        moveColumn: moveColumn,
        activeColumn: activeColumn,
        activeEndColumn: activeEndColumn,
        loadColumn: loadColumn,
        addColumn$: addColumn$,
        removeColumn$: removeColumn$,
        changeColumnPrimaryKey$: changeColumnPrimaryKey$,
        moveColumn$: moveColumn$
    });

    const panels = observable$1([]);
    const addPanel = (...newPanels) => panels.push(...newPanels);

    const databaseList = [
        'KSQL',
        'MSSQL',
        'MySQL',
        'Oracle',
        'PostgreSQL',
    ];
    const languageList = [
        'GraphQL',
        'C#',
        'Java',
        'Kotlin',
        'TypeScript',
        'JPA',
        'Scala',
    ];
    const nameCaseList = [
        'none',
        'camelCase',
        'pascalCase',
        'snakeCase',
    ];
    const highlightThemes = [
        'MonokaiSublime',
        'VS2015',
        'AtomOneDark',
        'AtomOneLight',
        'GithubGist',
    ];
    const bracketTypes = [
        'none',
        'doubleQuote',
        'singleQuote',
        'backtick',
    ];
    const bracketTypeMap = {
        none: '',
        singleQuote: `'`,
        doubleQuote: `"`,
        backtick: '`',
    };
    const createCanvasState = () => ({
        version: "2.1.0",
        width: 2000,
        height: 2000,
        scrollTop: 0,
        scrollLeft: 0,
        zoomLevel: 1,
        readonly: true,
        show: {
            tableComment: true,
            columnComment: true,
            columnDataType: true,
            columnDefault: true,
            columnAutoIncrement: false,
            columnPrimaryKey: true,
            columnUnique: false,
            columnNotNull: true,
            relationship: true,
        },
        database: 'MySQL',
        databaseName: '',
        canvasType: 'ERD',
        language: 'GraphQL',
        tableCase: 'pascalCase',
        columnCase: 'camelCase',
        highlightTheme: 'VS2015',
        bracketType: 'none',
        setting: {
            relationshipDataTypeSync: true,
            columnOrder: [
                'columnName',
                'columnDataType',
                'columnNotNull',
                'columnUnique',
                'columnAutoIncrement',
                'columnDefault',
                'columnComment',
            ],
        },
    });

    class FilterModel {
        constructor({ addFilter }) {
            this.columnType = 'tableName';
            this.filterCode = 'contain';
            this.value = '';
            if (addFilter) {
                this.id = addFilter.id;
            }
            else {
                throw new Error('not found filter');
            }
        }
    }

    function executeFilterActive({ editorState: { filterState } }) {
        filterState.active = true;
    }
    function executeFilterActiveEnd({ editorState: { filterState }, }) {
        filterState.active = false;
    }
    function executeAddFilter({ editorState: { filterState: { filters }, }, }, data) {
        filters.push(new FilterModel({ addFilter: data }));
    }
    function executeRemoveFilter({ editorState: { filterState: { filters }, }, }, data) {
        for (let i = 0; i < filters.length; i++) {
            const filter = filters[i];
            if (data.filterIds.includes(filter.id)) {
                filters.splice(i, 1);
                i--;
            }
        }
    }
    function executeChangeFilterColumnType({ editorState: { filterState: { filters }, }, }, data) {
        const filter = getData(filters, data.filterId);
        if (!filter)
            return;
        filter.columnType = data.columnType;
    }
    function executeChangeFilterCode({ editorState: { filterState: { filters }, }, }, data) {
        const filter = getData(filters, data.filterId);
        if (!filter)
            return;
        filter.filterCode = data.filterCode;
    }
    function executeChangeFilterValue({ editorState: { filterState: { filters }, }, }, data) {
        const filter = getData(filters, data.filterId);
        if (!filter)
            return;
        filter.value = data.value;
    }
    function executeMoveFilter({ editorState: { filterState: { filters }, }, }, data) {
        const currentFilters = [];
        data.filterIds.forEach(filterId => {
            const filter = getData(filters, filterId);
            filter && currentFilters.push(filter);
        });
        const targetFilter = getData(filters, data.targetFilterId);
        if (!currentFilters.length ||
            !targetFilter ||
            data.filterIds.includes(data.targetFilterId))
            return;
        const targetIndex = getIndex(filters, targetFilter.id);
        if (targetIndex === -1)
            return;
        currentFilters.forEach(currentFilter => {
            const currentIndex = getIndex(filters, currentFilter.id);
            if (currentIndex === -1)
                return;
            filters.splice(currentIndex, 1);
        });
        filters.splice(targetIndex, 0, ...currentFilters);
    }
    function executeChangeFilterOperatorType({ editorState: { filterState } }, data) {
        filterState.operatorType = data.operatorType;
    }
    function executeFilterFocus({ editorState: { filterState } }, data) {
        if (filterState.focus) {
            filterState.focus.focusType = 'operatorType';
            filterState.focus.filterId = null;
            filterState.focus.prevSelectFilterId = null;
            filterState.focus.selectFilterIds = [];
        }
        else {
            filterState.focus = {
                focusType: 'operatorType',
                filterId: null,
                prevSelectFilterId: null,
                selectFilterIds: [],
                edit: false,
            };
        }
    }
    function executeFocusFilter({ editorState: { filterState } }, data) {
        if (filterState.focus) {
            const focus = filterState.focus;
            focus.filterId = data.filterId;
            focus.focusType = data.focusType;
            if (data.ctrlKey && data.shiftKey) {
                focus.selectFilterIds = appendSelectRangeFilters(filterState.filters, focus.selectFilterIds, focus.prevSelectFilterId, focus.filterId);
            }
            else if (data.shiftKey) {
                focus.selectFilterIds = selectRangeFilters(filterState.filters, focus.prevSelectFilterId, focus.filterId);
            }
            else if (data.ctrlKey) {
                focus.selectFilterIds = appendSelectFilters(focus.selectFilterIds, data.filterId);
            }
            else {
                focus.selectFilterIds = [data.filterId];
            }
            focus.prevSelectFilterId = data.filterId;
        }
        else {
            filterState.focus = {
                focusType: data.focusType,
                filterId: data.filterId,
                prevSelectFilterId: data.filterId,
                selectFilterIds: [data.filterId],
                edit: false,
            };
        }
    }
    function executeFocusFilterEnd({ editorState: { filterState } }) {
        filterState.focus = null;
    }
    function executeFocusMoveFilter({ editorState: { filterState } }, data) {
        if (!filterState.focus)
            return;
        filterState.focus.edit = false;
        switch (data.moveKey) {
            case 'ArrowUp':
                arrowUp(filterState, data);
                break;
            case 'ArrowDown':
                arrowDown(filterState, data);
                break;
            case 'ArrowLeft':
                arrowLeft(filterState, data);
                break;
            case 'ArrowRight':
                arrowRight(filterState, data);
                break;
            case 'Tab':
                data.shiftKey
                    ? arrowLeft(filterState, data)
                    : arrowRight(filterState, data);
                break;
        }
    }
    function executeEditFilter({ editorState: { filterState: { focus }, }, }) {
        if (!focus)
            return;
        focus.edit = true;
    }
    function executeEditFilterEnd({ editorState: { filterState: { focus }, }, }) {
        if (!focus)
            return;
        focus.edit = false;
    }
    function executeSelectAllFilter({ editorState: { filterState: { focus, filters }, }, }) {
        if (!focus)
            return;
        focus.selectFilterIds = filters.map(filter => filter.id);
    }
    function executeDraggableFilter({ editorState: { filterState } }, data) {
        filterState.draggable = data;
    }
    function executeDraggableFilterEnd({ editorState: { filterState }, }) {
        filterState.draggable = null;
    }
    const executeFilterCommandMap = {
        'editor.filter.active': executeFilterActive,
        'editor.filter.activeEnd': executeFilterActiveEnd,
        'editor.filter.add': executeAddFilter,
        'editor.filter.remove': executeRemoveFilter,
        'editor.filter.changeColumnType': executeChangeFilterColumnType,
        'editor.filter.changeFilterCode': executeChangeFilterCode,
        'editor.filter.changeValue': executeChangeFilterValue,
        'editor.filter.move': executeMoveFilter,
        'editor.filter.changeOperatorType': executeChangeFilterOperatorType,
        'editor.filter.focus': executeFilterFocus,
        'editor.filter.focusFilter': executeFocusFilter,
        'editor.filter.focusEnd': executeFocusFilterEnd,
        'editor.filter.focusMove': executeFocusMoveFilter,
        'editor.filter.edit': executeEditFilter,
        'editor.filter.editEnd': executeEditFilterEnd,
        'editor.filter.selectAll': executeSelectAllFilter,
        'editor.filter.draggable': executeDraggableFilter,
        'editor.filter.draggableEnd': executeDraggableFilterEnd,
    };

    const isLoadIndex = (loadIndex) => isString$1(loadIndex.id) &&
        isString$1(loadIndex.name) &&
        isString$1(loadIndex.tableId) &&
        isBoolean(loadIndex.unique) &&
        isArray$1(loadIndex.columns);
    class IndexModel {
        constructor({ addIndex, loadIndex }) {
            this.name = '';
            this.columns = [];
            this.unique = false;
            if (addIndex) {
                const { id, tableId } = addIndex;
                this.id = id;
                this.tableId = tableId;
            }
            else if (loadIndex && isLoadIndex(loadIndex)) {
                const { id, name, tableId, columns, unique } = cloneDeep(loadIndex);
                this.id = id;
                this.name = name;
                this.tableId = tableId;
                this.columns = columns;
                this.unique = unique;
            }
            else {
                throw new Error('not found index');
            }
        }
    }

    function executeAddIndex({ tableState: { indexes } }, data) {
        indexes.push(new IndexModel({ addIndex: data }));
    }
    function executeRemoveIndex({ tableState: { indexes } }, data) {
        for (let i = 0; i < indexes.length; i++) {
            const id = indexes[i].id;
            if (data.indexIds.includes(id)) {
                indexes.splice(i, 1);
                i--;
            }
        }
    }
    function executeChangeIndexName({ tableState: { indexes } }, data) {
        const index = getData(indexes, data.indexId);
        if (!index)
            return;
        index.name = data.value;
    }
    function executeChangeIndexUnique({ tableState: { indexes } }, data) {
        const index = getData(indexes, data.indexId);
        if (!index)
            return;
        index.unique = data.value;
    }
    function executeAddIndexColumn({ tableState: { indexes } }, data) {
        const index = getData(indexes, data.indexId);
        if (!index || index.columns.some(column => column.id === data.columnId))
            return;
        index.columns.push({
            id: data.columnId,
            orderType: 'ASC',
        });
    }
    function executeRemoveIndexColumn({ tableState: { indexes } }, data) {
        const index = getData(indexes, data.indexId);
        if (!index)
            return;
        const targetIndex = getIndex(index.columns, data.columnId);
        if (targetIndex === -1)
            return;
        index.columns.splice(targetIndex, 1);
    }
    function executeMoveIndexColumn({ tableState: { indexes } }, data) {
        const index = getData(indexes, data.indexId);
        if (!index || data.columnId === data.targetColumnId)
            return;
        const currentColumn = getData(index.columns, data.columnId);
        if (!currentColumn)
            return;
        const currentIndex = getIndex(index.columns, data.columnId);
        if (currentIndex === -1)
            return;
        const targetIndex = getIndex(index.columns, data.targetColumnId);
        if (targetIndex === -1)
            return;
        index.columns.splice(currentIndex, 1);
        index.columns.splice(targetIndex, 0, currentColumn);
    }
    function executeChangeIndexColumnOrderType({ tableState: { indexes } }, data) {
        const index = getData(indexes, data.indexId);
        if (!index)
            return;
        const column = getData(index.columns, data.columnId);
        if (!column)
            return;
        column.orderType = data.value;
    }
    function executeLoadIndex({ tableState: { indexes } }, data) {
        indexes.push(new IndexModel({ loadIndex: data }));
    }
    const executeIndexCommandMap = {
        'index.add': executeAddIndex,
        'index.remove': executeRemoveIndex,
        'index.changeName': executeChangeIndexName,
        'index.changeUnique': executeChangeIndexUnique,
        'index.addColumn': executeAddIndexColumn,
        'index.removeColumn': executeRemoveIndexColumn,
        'index.moveColumn': executeMoveIndexColumn,
        'index.changeColumnOrderType': executeChangeIndexColumnOrderType,
        'index.load': executeLoadIndex,
    };

    const isLoadMemo = (loadMemo) => isString$1(loadMemo.id) &&
        isString$1(loadMemo.value) &&
        isObject$2(loadMemo.ui) &&
        isBoolean(loadMemo.ui.active) &&
        isNumber(loadMemo.ui.top) &&
        isNumber(loadMemo.ui.left) &&
        isNumber(loadMemo.ui.width) &&
        isNumber(loadMemo.ui.height) &&
        isNumber(loadMemo.ui.zIndex);
    class MemoModel {
        constructor({ addMemo, loadMemo }) {
            this.value = '';
            this.ui = {
                active: false,
                left: SIZE_START_X,
                top: SIZE_START_Y,
                zIndex: 2,
                width: SIZE_MEMO_WIDTH,
                height: SIZE_MEMO_HEIGHT,
            };
            if (addMemo) {
                const { id, ui } = addMemo;
                this.id = id;
                this.ui = Object.assign(this.ui, ui);
            }
            else if (loadMemo && isLoadMemo(loadMemo)) {
                const { id, value, ui } = cloneDeep(loadMemo);
                this.id = id;
                this.value = value;
                this.ui = Object.assign(this.ui, ui);
            }
            else {
                throw new Error('not found memo');
            }
        }
    }

    const MEMO_PADDING$2 = SIZE_MEMO_PADDING * 2;
    function executeAddMemo$1({ memoState: { memos } }, data) {
        memos.push(new MemoModel({ addMemo: data }));
    }
    function executeMoveMemo$1({ tableState: { tables }, memoState: { memos } }, data) {
        data.tableIds.forEach(tableId => {
            const table = getData(tables, tableId);
            if (!table)
                return;
            table.ui.left += data.movementX;
            table.ui.top += data.movementY;
        });
        data.memoIds.forEach(memoId => {
            const memo = getData(memos, memoId);
            if (!memo)
                return;
            memo.ui.left += data.movementX;
            memo.ui.top += data.movementY;
        });
    }
    function executeRemoveMemo$1({ memoState: { memos } }, { memoIds }) {
        for (let i = 0; i < memos.length; i++) {
            const id = memos[i].id;
            if (memoIds.includes(id)) {
                memos.splice(i, 1);
                i--;
            }
        }
    }
    function executeSelectMemo({ memoState: { memos } }, data) {
        const targetMemo = getData(memos, data.memoId);
        if (!targetMemo)
            return;
        targetMemo.ui.zIndex = data.zIndex;
        data.ctrlKey
            ? (targetMemo.ui.active = true)
            : memos.forEach(memo => (memo.ui.active = memo.id === data.memoId));
    }
    function executeSelectEndMemo({ memoState: { memos } }) {
        memos.forEach(memo => (memo.ui.active = false));
    }
    function executeSelectAllMemo({ memoState: { memos } }) {
        memos.forEach(memo => (memo.ui.active = true));
    }
    function executeChangeMemoValue$1({ memoState: { memos } }, data) {
        const memo = getData(memos, data.memoId);
        if (!memo)
            return;
        memo.value = data.value;
    }
    function executeResizeMemo$1({ memoState: { memos } }, data) {
        const memo = getData(memos, data.memoId);
        if (!memo)
            return;
        memo.ui.top = data.top;
        memo.ui.left = data.left;
        memo.ui.width = data.width;
        memo.ui.height = data.height;
    }
    function executeDragSelectMemo({ memoState: { memos } }, data) {
        const { min, max } = data;
        memos.forEach(memo => {
            const centerX = memo.ui.left + memo.ui.width / 2 + MEMO_PADDING$2;
            const centerY = memo.ui.top + memo.ui.height / 2 + MEMO_PADDING$2;
            memo.ui.active =
                min.x <= centerX &&
                    max.x >= centerX &&
                    min.y <= centerY &&
                    max.y >= centerY;
        });
    }
    function executeLoadMemo({ memoState: { memos } }, data) {
        memos.push(new MemoModel({ loadMemo: data }));
    }
    const executeMemoCommandMap$1 = {
        'memo.add': executeAddMemo$1,
        'memo.move': executeMoveMemo$1,
        'memo.remove': executeRemoveMemo$1,
        'memo.select': executeSelectMemo,
        'memo.selectEnd': executeSelectEndMemo,
        'memo.selectAll': executeSelectAllMemo,
        'memo.changeValue': executeChangeMemoValue$1,
        'memo.resize': executeResizeMemo$1,
        'memo.dragSelect': executeDragSelectMemo,
        'memo.load': executeLoadMemo,
    };

    function getMaxWidthColumn(columns, show) {
        const columnWidth = {
            width: 0,
            name: 0,
            comment: 0,
            dataType: 0,
            default: 0,
            notNull: 0,
            autoIncrement: 0,
            unique: 0,
        };
        if (columns.length > 0) {
            columns.forEach(column => {
                columnWidth.name < column.ui.widthName &&
                    (columnWidth.name = column.ui.widthName);
                show.columnComment &&
                    columnWidth.comment < column.ui.widthComment &&
                    (columnWidth.comment = column.ui.widthComment);
                show.columnDataType &&
                    columnWidth.dataType < column.ui.widthDataType &&
                    (columnWidth.dataType = column.ui.widthDataType);
                show.columnDefault &&
                    columnWidth.default < column.ui.widthDefault &&
                    (columnWidth.default = column.ui.widthDefault);
            });
        }
        else {
            columnWidth.name < SIZE_MIN_WIDTH &&
                (columnWidth.name = SIZE_MIN_WIDTH);
            show.columnComment &&
                columnWidth.comment < SIZE_MIN_WIDTH &&
                (columnWidth.comment = SIZE_MIN_WIDTH);
            show.columnDataType &&
                columnWidth.dataType < SIZE_MIN_WIDTH &&
                (columnWidth.dataType = SIZE_MIN_WIDTH);
            show.columnDefault &&
                columnWidth.default < SIZE_MIN_WIDTH &&
                (columnWidth.default = SIZE_MIN_WIDTH);
        }
        show.columnNotNull && (columnWidth.notNull = SIZE_COLUMN_OPTION_NN);
        show.columnUnique && (columnWidth.unique = SIZE_COLUMN_OPTION_UQ);
        show.columnAutoIncrement &&
            (columnWidth.autoIncrement = SIZE_COLUMN_OPTION_AI);
        Object.keys(columnWidth)
            .filter(key => key !== 'width')
            .forEach(key => {
            const k = key;
            if (!columnWidth[k])
                return;
            columnWidth.width += columnWidth[k] + SIZE_COLUMN_MARGIN_RIGHT;
        });
        return columnWidth;
    }
    const defaultWidthColumnMap = [
        {
            key: 'columnComment',
            width: SIZE_MIN_WIDTH,
        },
        {
            key: 'columnDataType',
            width: SIZE_MIN_WIDTH,
        },
        {
            key: 'columnDefault',
            width: SIZE_MIN_WIDTH,
        },
        {
            key: 'columnNotNull',
            width: SIZE_COLUMN_OPTION_NN,
        },
        {
            key: 'columnAutoIncrement',
            width: SIZE_COLUMN_OPTION_AI,
        },
        {
            key: 'columnUnique',
            width: SIZE_COLUMN_OPTION_UQ,
        },
    ];
    function getDefaultWidthColumn(show) {
        let width = SIZE_MIN_WIDTH + SIZE_COLUMN_MARGIN_RIGHT;
        defaultWidthColumnMap.forEach(data => show[data.key] && (width += data.width + SIZE_COLUMN_MARGIN_RIGHT));
        return width;
    }

    const isLoadTable = (loadTable) => isString$1(loadTable.id) &&
        isString$1(loadTable.name) &&
        isString$1(loadTable.comment) &&
        isArray$1(loadTable.columns) &&
        isObject$2(loadTable.ui) &&
        isBoolean(loadTable.ui.active) &&
        isNumber(loadTable.ui.left) &&
        isNumber(loadTable.ui.top) &&
        isNumber(loadTable.ui.zIndex) &&
        isNumber(loadTable.ui.widthName) &&
        isNumber(loadTable.ui.widthComment);
    class TableModel {
        constructor({ addTable, loadTable }, show) {
            this.name = '';
            this.comment = '';
            this.columns = [];
            this.ui = {
                active: false,
                left: SIZE_START_X,
                top: SIZE_START_Y,
                zIndex: 2,
                widthName: SIZE_MIN_WIDTH,
                widthComment: SIZE_MIN_WIDTH,
            };
            this._show = show;
            if (addTable) {
                const { id, ui } = addTable;
                this.id = id;
                this.ui = Object.assign(this.ui, ui);
            }
            else if (loadTable && isLoadTable(loadTable)) {
                const { id, name, comment, columns, ui } = cloneDeep(loadTable);
                this.id = id;
                this.name = name;
                this.comment = comment;
                this.columns = columns;
                this.ui = Object.assign(this.ui, ui);
            }
            else {
                throw new Error('not found table');
            }
        }
        width() {
            // table header width
            let width = this.ui.widthName + SIZE_COLUMN_MARGIN_RIGHT;
            if (this._show.tableComment) {
                width += this.ui.widthComment + SIZE_COLUMN_MARGIN_RIGHT;
            }
            // default width column
            const defaultWidthColumn = getDefaultWidthColumn(this._show) +
                SIZE_COLUMN_CLOSE +
                SIZE_COLUMN_KEY +
                SIZE_COLUMN_MARGIN_RIGHT;
            if (width < defaultWidthColumn) {
                width = defaultWidthColumn;
            }
            // max width column
            const maxWidthColumn = this.maxWidthColumn().width +
                SIZE_COLUMN_CLOSE +
                SIZE_COLUMN_KEY +
                SIZE_COLUMN_MARGIN_RIGHT;
            if (width < maxWidthColumn) {
                width = maxWidthColumn;
            }
            if (this.columns.length > SIZE_MAX_ROW) {
                width = width + SIZE_COLUMN_MARGIN_RIGHT;
            }
            return width;
        }
        height() {
            return SIZE_TABLE_HEADER_HEIGHT + Math.min(SIZE_MAX_ROW, this.columns.length + 1) * SIZE_COLUMN_HEIGHT - SIZE_BORDER_BOTTOM;
        }
        maxWidthColumn() {
            return getMaxWidthColumn(this.columns, this._show);
        }
    }

    const TABLE_PADDING$3 = (SIZE_TABLE_PADDING + SIZE_TABLE_BORDER) * 2;
    const TABLE_SORT_PADDING = TABLE_PADDING$3 * 4;
    function executeAddTable$1({ tableState: { tables }, canvasState: { show } }, data) {
        tables.push(new TableModel({ addTable: data }, show));
    }
    function executeMoveTable$1({ tableState: { tables }, memoState: { memos } }, data) {
        data.tableIds.forEach(tableId => {
            const table = getData(tables, tableId);
            if (!table)
                return;
            table.ui.left += data.movementX;
            table.ui.top += data.movementY;
        });
        data.memoIds.forEach(memoId => {
            const memo = getData(memos, memoId);
            if (!memo)
                return;
            memo.ui.left += data.movementX;
            memo.ui.top += data.movementY;
        });
    }
    function executeRemoveTable$1(state, data) {
        const { tableState: { tables }, } = state;
        for (let i = 0; i < tables.length; i++) {
            const id = tables[i].id;
            if (data.tableIds.includes(id)) {
                tables.splice(i, 1);
                i--;
            }
        }
        // TODO: Refactoring
        removeValidTableIndex(state, data.tableIds);
        removeValidTableRelationship(state, data.tableIds);
    }
    function executeSelectTable({ tableState: { tables } }, data) {
        const targetTable = getData(tables, data.tableId);
        if (!targetTable)
            return;
        targetTable.ui.zIndex = data.zIndex;
        data.ctrlKey
            ? (targetTable.ui.active = true)
            : tables.forEach(table => (table.ui.active = table.id === data.tableId));
    }
    function executeSelectEndTable({ tableState: { tables } }) {
        tables.forEach(table => (table.ui.active = false));
    }
    function executeSelectAllTable({ tableState: { tables } }) {
        tables.forEach(table => (table.ui.active = true));
    }
    function executeChangeTableName$1({ tableState: { tables } }, data) {
        const table = getData(tables, data.tableId);
        if (!table)
            return;
        table.name = data.value;
        table.ui.widthName = data.width;
    }
    function executeChangeTableComment$1({ tableState: { tables } }, data) {
        const table = getData(tables, data.tableId);
        if (!table)
            return;
        table.comment = data.value;
        table.ui.widthComment = commentWidthBalanceRange(data.width);
    }
    function executeDragSelectTable({ tableState: { tables } }, data) {
        const { min, max } = data;
        tables.forEach(table => {
            const centerX = table.ui.left + table.width() / 2 + TABLE_PADDING$3;
            const centerY = table.ui.top + table.height() / 2 + TABLE_PADDING$3;
            table.ui.active =
                min.x <= centerX &&
                    max.x >= centerX &&
                    min.y <= centerY &&
                    max.y >= centerY;
        });
    }
    function executeSortTable$1({ tableState: { tables }, canvasState, }) {
        const canvasWidth = canvasState.width;
        tables.sort((a, b) => a.columns.length - b.columns.length);
        let widthSum = 50;
        let currentHeight = 50;
        let maxHeight = 50;
        tables.forEach(table => {
            const width = table.width() + TABLE_SORT_PADDING;
            const height = table.height() + TABLE_SORT_PADDING;
            if (widthSum + width > canvasWidth) {
                currentHeight += maxHeight;
                maxHeight = 0;
                widthSum = 50;
            }
            if (maxHeight < height) {
                maxHeight = height;
            }
            table.ui.top = currentHeight;
            table.ui.left = widthSum;
            widthSum += width;
        });
    }
    function executeLoadTable({ tableState: { tables }, canvasState: { show } }, data) {
        tables.push(new TableModel({ loadTable: data }, show));
    }
    const executeTableCommandMap$1 = {
        'table.add': executeAddTable$1,
        'table.move': executeMoveTable$1,
        'table.remove': executeRemoveTable$1,
        'table.select': executeSelectTable,
        'table.selectEnd': executeSelectEndTable,
        'table.selectAll': executeSelectAllTable,
        'table.changeName': executeChangeTableName$1,
        'table.changeComment': executeChangeTableComment$1,
        'table.dragSelect': executeDragSelectTable,
        'table.sort': executeSortTable$1,
        'table.load': executeLoadTable,
    };

    function executeHasUndoRedo({ editorState }, data) {
        editorState.hasUndo = data.hasUndo;
        editorState.hasRedo = data.hasRedo;
    }
    function executeFocusTable({ editorState, tableState: { tables } }, data) {
        var _a, _b;
        if (((_a = editorState.focusTable) === null || _a === void 0 ? void 0 : _a.table.id) === data.tableId && data.focusType) {
            editorState.focusTable.focusType = data.focusType;
            editorState.focusTable.columnId = null;
            editorState.focusTable.prevSelectColumnId = null;
            editorState.focusTable.selectColumnIds = [];
        }
        else if (data.focusType) {
            const table = getData(tables, data.tableId);
            if (!table)
                return;
            editorState.focusTable = {
                table,
                focusType: data.focusType,
                columnId: null,
                prevSelectColumnId: null,
                selectColumnIds: [],
                edit: false,
            };
        }
        else if (((_b = editorState.focusTable) === null || _b === void 0 ? void 0 : _b.table.id) !== data.tableId) {
            const table = getData(tables, data.tableId);
            if (!table)
                return;
            editorState.focusTable = {
                table,
                focusType: 'tableName',
                columnId: null,
                prevSelectColumnId: null,
                selectColumnIds: [],
                edit: false,
            };
        }
    }
    function executeFocusColumn({ editorState, tableState: { tables } }, data) {
        var _a;
        if (((_a = editorState.focusTable) === null || _a === void 0 ? void 0 : _a.table.id) === data.tableId) {
            const focusTable = editorState.focusTable;
            focusTable.columnId = data.columnId;
            focusTable.focusType = data.focusType;
            if (data.ctrlKey && data.shiftKey) {
                focusTable.selectColumnIds = appendSelectRangeColumns(focusTable.table.columns, focusTable.selectColumnIds, focusTable.prevSelectColumnId, focusTable.columnId);
            }
            else if (data.shiftKey) {
                focusTable.selectColumnIds = selectRangeColumns(focusTable.table.columns, focusTable.prevSelectColumnId, focusTable.columnId);
            }
            else if (data.ctrlKey) {
                focusTable.selectColumnIds = appendSelectColumns(focusTable.selectColumnIds, data.columnId);
            }
            else {
                focusTable.selectColumnIds = [data.columnId];
            }
            focusTable.prevSelectColumnId = data.columnId;
        }
        else {
            const table = getData(tables, data.tableId);
            if (!table)
                return;
            editorState.focusTable = {
                table,
                focusType: data.focusType,
                columnId: data.columnId,
                prevSelectColumnId: data.columnId,
                selectColumnIds: [data.columnId],
                edit: false,
            };
        }
    }
    function executeFocusTableEnd({ editorState }) {
        editorState.focusTable = null;
    }
    function executeFocusMoveTable(state, data) {
        const { editorState } = state;
        if (!editorState.focusTable)
            return;
        editorState.focusTable.edit = false;
        switch (data.moveKey) {
            case 'ArrowUp':
                arrowUp$1(state, data);
                break;
            case 'ArrowDown':
                arrowDown$1(state, data);
                break;
            case 'ArrowLeft':
                arrowLeft$1(state, data);
                break;
            case 'ArrowRight':
                arrowRight$1(state, data);
                break;
            case 'Tab':
                data.shiftKey ? arrowLeft$1(state, data) : arrowRight$1(state, data);
                break;
        }
    }
    function executeEditTable({ editorState: { focusTable } }) {
        if (!focusTable)
            return;
        focusTable.edit = true;
    }
    function executeEditTableEnd({ editorState: { focusTable } }) {
        if (!focusTable)
            return;
        focusTable.edit = false;
    }
    function executeSelectAllColumn({ editorState: { focusTable } }) {
        if (!focusTable)
            return;
        focusTable.selectColumnIds = focusTable.table.columns.map(column => column.id);
    }
    function executeDrawStartRelationship({ editorState }, data) {
        editorState.drawRelationship = {
            relationshipType: data.relationshipType,
            start: null,
            end: {
                x: 0,
                y: 0,
            },
        };
    }
    function executeDrawStartAddRelationship({ tableState: { tables }, editorState: { drawRelationship } }, data) {
        if (!drawRelationship)
            return;
        const table = getData(tables, data.tableId);
        if (!table)
            return;
        drawRelationship.start = {
            table,
            x: table.ui.left,
            y: table.ui.top,
        };
    }
    function executeDrawEndRelationship({ editorState }) {
        editorState.drawRelationship = null;
    }
    function executeDrawRelationship({ editorState: { drawRelationship }, canvasState: { scrollLeft, scrollTop }, }, data) {
        if (!(drawRelationship === null || drawRelationship === void 0 ? void 0 : drawRelationship.start))
            return;
        drawRelationship.end.x = data.x - scrollLeft;
        drawRelationship.end.y = data.y - scrollTop;
    }
    function executeDraggableColumn({ editorState }, data) {
        editorState.draggableColumn = data;
    }
    function executeDraggableColumnEnd({ editorState }) {
        editorState.draggableColumn = null;
    }
    // TODO: Refactoring
    function executeLoadJson$1(state, data) {
        const { canvasState, editorState, controlState } = state;
        const panelNames = [...panels, ...editorState.panels].map(panel => panel.key);
        const json = JSON.parse(data.value);
        const canvasStateAny = canvasState;
        const canvasJson = json.canvas;
        const controlJson = json.control;
        if (isObject$2(controlJson)) {
            Object.keys(controlState).forEach(key => {
                if (!isEmpty(controlJson[key])) {
                    switch (key) {
                        case 'allowEdit':
                            controlState.allowEdit = controlJson.allowEdit;
                            break;
                        case 'allowZoom':
                            controlState.allowZoom = controlJson.allowZoom;
                            break;
                        case 'allowMoveTable':
                            controlState.allowMoveTable = controlJson.allowMoveTable;
                            break;
                    }
                }
            });
        }
        if (isObject$2(canvasJson)) {
            Object.keys(canvasStateAny).forEach(key => {
                if (!isEmpty(canvasJson[key])) {
                    switch (key) {
                        case 'show':
                            Object.keys(canvasState.show).forEach(showKey => {
                                if (typeof canvasJson.show[showKey] === 'boolean') {
                                    canvasStateAny.show[showKey] = canvasJson.show[showKey];
                                }
                            });
                            break;
                        case 'database':
                            if (databaseList.includes(canvasJson.database)) {
                                canvasState.database = canvasJson.database;
                            }
                            break;
                        case 'canvasType':
                            if (panelNames.includes(canvasJson.canvasType)) {
                                canvasState.canvasType = canvasJson.canvasType;
                            }
                            break;
                        case 'language':
                            if (languageList.includes(canvasJson.language)) {
                                canvasState.language = canvasJson.language;
                            }
                            break;
                        case 'tableCase':
                            if (nameCaseList.includes(canvasJson.tableCase)) {
                                canvasState.tableCase = canvasJson.tableCase;
                            }
                            break;
                        case 'columnCase':
                            if (nameCaseList.includes(canvasJson.columnCase)) {
                                canvasState.columnCase = canvasJson.columnCase;
                            }
                            break;
                        case 'highlightTheme':
                            if (highlightThemes.includes(canvasJson.highlightTheme)) {
                                canvasState.highlightTheme = canvasJson.highlightTheme;
                            }
                            break;
                        case 'bracketType':
                            if (bracketTypes.includes(canvasJson.bracketType)) {
                                canvasState.bracketType = canvasJson.bracketType;
                            }
                            break;
                        case 'width':
                            let w = 0;
                            if (typeof canvasJson[key] === 'number' && canvasJson[key]) {
                                w = canvasJson[key];
                            }
                            let pw = document.documentElement.clientWidth;
                            w = Math.max(w, pw);
                            editorState.viewport.width = w;
                            canvasState.width = w;
                            break;
                        case 'height':
                            let h = 0;
                            if (typeof canvasJson[key] === 'number' && canvasJson[key]) {
                                h = canvasJson[key];
                            }
                            let ph = document.documentElement.clientHeight - SIZE_MENUBAR_HEIGHT;
                            h = Math.max(h, ph);
                            editorState.viewport.height = h;
                            canvasState.height = h;
                            break;
                        case 'scrollTop':
                        case 'scrollLeft':
                        case 'zoomLevel':
                            if (typeof canvasJson[key] === 'number') {
                                canvasState[key] = canvasJson[key];
                            }
                            break;
                        case 'databaseName':
                            if (typeof canvasJson[key] === 'string') {
                                canvasState[key] = canvasJson[key];
                            }
                            break;
                        case 'setting':
                            if (typeof canvasJson.setting.relationshipDataTypeSync === 'boolean') {
                                canvasState.setting.relationshipDataTypeSync =
                                    canvasJson.setting.relationshipDataTypeSync;
                            }
                            if (Array.isArray(canvasJson.setting.columnOrder) &&
                                canvasJson.setting.columnOrder.length === 7 &&
                                canvasJson.setting.columnOrder.indexOf('columnName') !== -1 &&
                                canvasJson.setting.columnOrder.indexOf('columnDataType') !== -1 &&
                                canvasJson.setting.columnOrder.indexOf('columnNotNull') !== -1 &&
                                canvasJson.setting.columnOrder.indexOf('columnDefault') !== -1 &&
                                canvasJson.setting.columnOrder.indexOf('columnComment') !== -1 &&
                                canvasJson.setting.columnOrder.indexOf('columnUnique') !== -1 &&
                                canvasJson.setting.columnOrder.indexOf('columnAutoIncrement') !==
                                    -1) {
                                canvasState.setting.columnOrder.splice(0, canvasState.setting.columnOrder.length);
                                canvasState.setting.columnOrder.push(...canvasJson.setting.columnOrder);
                            }
                            break;
                    }
                }
            });
        }
        const tableJson = json.table;
        if (isObject$2(tableJson)) {
            Array.isArray(tableJson.tables) &&
                tableJson.tables.forEach((loadTable) => executeLoadTable(state, loadTable));
            Array.isArray(tableJson.indexes) &&
                tableJson.indexes.forEach((loadIndex) => executeLoadIndex(state, loadIndex));
        }
        const memoJson = json.memo;
        if (isObject$2(memoJson) && Array.isArray(memoJson.memos)) {
            memoJson.memos.forEach((loadMemo) => executeLoadMemo(state, loadMemo));
        }
        const relationshipJson = json.relationship;
        if (isObject$2(relationshipJson) &&
            Array.isArray(relationshipJson.relationships)) {
            relationshipJson.relationships.forEach((loadRelationship) => {
                executeLoadRelationship(state, loadRelationship);
            });
            // migration version 2.0.3
            validStartRelationship(state);
        }
    }
    function executeClear$1({ tableState: { tables, indexes }, memoState: { memos }, relationshipState: { relationships }, }) {
        tables.splice(0, tables.length);
        indexes.splice(0, indexes.length);
        memos.splice(0, memos.length);
        relationships.splice(0, relationships.length);
    }
    function executeChangeViewport({ editorState: { viewport } }, data) {
        viewport.width = data.width;
        viewport.height = data.height;
    }
    function executeCopyColumn({ tableState: { tables }, editorState: { copyColumns } }, data) {
        const table = getData(tables, data.tableId);
        if (!table)
            return;
        copyColumns.splice(0, copyColumns.length);
        data.columnIds.forEach(columnId => {
            const column = getData(table.columns, columnId);
            if (!column)
                return;
            copyColumns.push(cloneDeep(column));
        });
    }
    function executeFindActive({ editorState }) {
        editorState.findActive = true;
    }
    function executeFindActiveEnd({ editorState }) {
        editorState.findActive = false;
    }
    function executeReadonlyEditor({ editorState }, data) {
        editorState.readonly = data.readonly;
    }
    const executeEditorCommandMap$1 = Object.assign({ 'editor.hasUndoRedo': executeHasUndoRedo, 'editor.focusTable': executeFocusTable, 'editor.focusColumn': executeFocusColumn, 'editor.focusTableEnd': executeFocusTableEnd, 'editor.focusMoveTable': executeFocusMoveTable, 'editor.editTable': executeEditTable, 'editor.editTableEnd': executeEditTableEnd, 'editor.selectAllColumn': executeSelectAllColumn, 'editor.drawStartRelationship': executeDrawStartRelationship, 'editor.drawStartAddRelationship': executeDrawStartAddRelationship, 'editor.drawEndRelationship': executeDrawEndRelationship, 'editor.drawRelationship': executeDrawRelationship, 'editor.draggableColumn': executeDraggableColumn, 'editor.draggableColumnEnd': executeDraggableColumnEnd, 'editor.loadJson': executeLoadJson$1, 'editor.initLoadJson': executeLoadJson$1, 'editor.clear': executeClear$1, 'editor.initClear': executeClear$1, 'editor.changeViewport': executeChangeViewport, 'editor.copyColumn': executeCopyColumn, 'editor.findActive': executeFindActive, 'editor.findActiveEnd': executeFindActiveEnd, 'editor.readonly': executeReadonlyEditor }, executeFilterCommandMap);

    const addIndex = (tableId) => createCommand$1('index.add', {
        id: v4(),
        tableId,
    });
    const removeIndex = (indexIds) => createCommand$1('index.remove', {
        indexIds,
    });
    const changeIndexName = (indexId, value) => createCommand$1('index.changeName', {
        indexId,
        value,
    });
    const changeIndexUnique = (indexId, value) => createCommand$1('index.changeUnique', {
        indexId,
        value,
    });
    const addIndexColumn = (indexId, columnId) => createCommand$1('index.addColumn', {
        indexId,
        columnId,
    });
    const removeIndexColumn = (indexId, columnId) => createCommand$1('index.removeColumn', {
        indexId,
        columnId,
    });
    const moveIndexColumn = (indexId, columnId, targetColumnId) => createCommand$1('index.moveColumn', {
        indexId,
        columnId,
        targetColumnId,
    });
    const changeIndexColumnOrderType = (indexId, columnId, value) => createCommand$1('index.changeColumnOrderType', {
        indexId,
        columnId,
        value,
    });
    const loadIndex = (index) => createCommand$1('index.load', index);

    var indexCommand = /*#__PURE__*/Object.freeze({
        __proto__: null,
        addIndex: addIndex,
        removeIndex: removeIndex,
        changeIndexName: changeIndexName,
        changeIndexUnique: changeIndexUnique,
        addIndexColumn: addIndexColumn,
        removeIndexColumn: removeIndexColumn,
        moveIndexColumn: moveIndexColumn,
        changeIndexColumnOrderType: changeIndexColumnOrderType,
        loadIndex: loadIndex
    });

    const executeCommandMap$1 = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, executeCanvasCommandMap$1), executeMemoCommandMap$1), executeTableCommandMap$1), executeColumnCommandMap$1), executeEditorCommandMap$1), executeRelationshipCommandMap$1), executeIndexCommandMap);
    const createCommand = () => ({
        canvas: canvasCommand,
        memo: memoCommand,
        table: tableCommand,
        column: columnCommand,
        editor: editorCommand,
        relationship: relationshipCommand,
        index: indexCommand,
    });
    function createStream() {
        const dispatch$ = new Subject();
        const history$ = new Subject();
        const change$ = merge(history$, dispatch$.pipe(commandsFilter(changeCommandTypes))).pipe(notEmptyCommands, debounceTime(200));
        const hook$ = merge(history$, dispatch$).pipe(notEmptyCommands);
        return {
            dispatch$,
            history$,
            change$,
            hook$,
        };
    }
    function executeCommand$(state, commands) {
        commands.forEach(command => {
            const execute = executeCommandMap$1[command.name];
            execute && execute(state, command.data);
        });
    }
    const executeCommand$1 = curry$1((state, commands) => {
        try {
            executeCommand$(state, commands);
        }
        catch (err) {
            Logger.error(err);
        }
    });

    function createHistory(effect) {
        let commands = [];
        let index = -1;
        let limit = 0;
        let run = false;
        const hasUndo = () => index !== -1;
        const hasRedo = () => index < commands.length - 1;
        const setLimit = (newLimit) => (limit = newLimit);
        const execute = (command, key) => {
            run = true;
            command[key]();
            run = false;
        };
        const push = (command) => {
            if (run)
                return;
            commands.splice(index + 1, commands.length - index);
            commands.push(command);
            if (limit !== 0 && commands.length > limit) {
                commands = commands.slice(commands.length - limit, commands.length);
            }
            index = commands.length - 1;
            effect();
        };
        const undo = () => {
            if (!hasUndo())
                return;
            const command = commands[index];
            execute(command, 'undo');
            index--;
            effect();
        };
        const redo = () => {
            if (!hasRedo())
                return;
            const command = commands[index + 1];
            execute(command, 'redo');
            index++;
            effect();
        };
        const clear = () => {
            const prevSize = commands.length;
            commands = [];
            index = -1;
            prevSize > 0 && effect();
        };
        return {
            hasUndo,
            hasRedo,
            push,
            undo,
            redo,
            clear,
            setLimit,
        };
    }

    const groupByStreamCommands = (source$) => new Observable(subscriber => source$.subscribe({
        next: commands => {
            const batchCommands = [];
            const streamCommands = [];
            commands.forEach(command => streamCommandTypes.includes(command.name)
                ? streamCommands.push(command)
                : batchCommands.push(command));
            subscriber.next(batchCommands);
            subscriber.next(streamCommands);
        },
        error: value => subscriber.error(value),
        complete: () => subscriber.complete(),
    })).pipe(notEmptyCommands, groupBy(commands => commands.some(command => streamCommandTypes.includes(command.name))), mergeMap(group$ => group$.key
        ? group$.pipe(buffer(group$.pipe(debounceTime(200))), map(buff => buff.reduce((acc, cur) => acc.concat(cur), [])))
        : group$));

    const readonlyCommands = ({ editorState, controlState }) => (source$) => new Observable(subscriber => source$.subscribe({
        next: commands => editorState.readonly
            ? subscriber.next(commands.filter(command => readonlyCommandTypes.includes(command.name) ||
                controlState.allowMoveTable && moveCommandTypes.includes(command.name)))
            : subscriber.next(commands),
        error: value => subscriber.error(value),
        complete: () => subscriber.complete(),
    })).pipe(notEmptyCommands);

    function executeMoveCanvas({ canvasState: { scrollTop, scrollLeft } }, batchUndoCommand) {
        batchUndoCommand.push(moveCanvas(scrollTop, scrollLeft));
    }
    function executeResizeCanvas({ canvasState: { width, height } }, batchUndoCommand) {
        batchUndoCommand.push(resizeCanvas(width, height));
    }
    function executeZoomCanvas({ canvasState: { zoomLevel } }, batchUndoCommand) {
        batchUndoCommand.push(zoomCanvas(zoomLevel));
    }
    function executeChangeCanvasShow(store, batchUndoCommand, data) {
        batchUndoCommand.push(createCommand$1('canvas.changeShow', {
            showKey: data.showKey,
            value: !data.value,
        }));
    }
    function executeChangeDatabase({ canvasState: { database } }, batchUndoCommand) {
        batchUndoCommand.push(changeDatabase(database));
    }
    function executeChangeDatabaseName({ canvasState: { databaseName } }, batchUndoCommand) {
        batchUndoCommand.push(changeDatabaseName(databaseName));
    }
    const executeCanvasCommandMap = {
        'canvas.move': executeMoveCanvas,
        'canvas.resize': executeResizeCanvas,
        'canvas.zoom': executeZoomCanvas,
        'canvas.changeShow': executeChangeCanvasShow,
        'canvas.changeDatabase': executeChangeDatabase,
        'canvas.changeDatabaseName': executeChangeDatabaseName,
    };

    function executeAddColumn(store, batchUndoCommand, data) {
        batchUndoCommand.push(...data.map(addColumn => removeColumn(addColumn.tableId, [addColumn.id])));
    }
    function executeAddCustomColumn(store, batchUndoCommand, data) {
        batchUndoCommand.push(...data.map(addColumn => removeColumn(addColumn.tableId, [addColumn.id])));
    }
    function executeRemoveColumn({ tableState: { tables, indexes }, relationshipState: { relationships }, }, batchUndoCommand, data) {
        const targetRelationships = [];
        const targetIndexes = [];
        const table = getData(tables, data.tableId);
        if (!table)
            return;
        relationships.forEach(relationship => {
            const { start, end } = relationship;
            if ((data.tableId === start.tableId &&
                data.columnIds.some(columnId => start.columnIds.includes(columnId))) ||
                (data.tableId === end.tableId &&
                    data.columnIds.some(columnId => end.columnIds.includes(columnId)))) {
                targetRelationships.push(cloneDeep(relationship));
            }
        });
        const tableIndexes = indexes.filter(index => index.tableId === table.id);
        tableIndexes.forEach(index => targetIndexes.push(cloneDeep(index)));
        const columns = [];
        const indexList = [];
        data.columnIds.forEach(columnId => {
            const column = getData(table.columns, columnId);
            const index = getIndex(table.columns, columnId);
            if (column && index !== -1) {
                columns.push(cloneDeep(column));
                indexList.push(index);
            }
        });
        batchUndoCommand.push(loadColumn(data.tableId, columns, indexList));
        if (targetRelationships.length) {
            batchUndoCommand.push(removeRelationship(targetRelationships.map(relationship => relationship.id)), ...targetRelationships.map(relationship => loadRelationship(relationship)));
        }
        if (targetIndexes.length) {
            batchUndoCommand.push(removeIndex(targetIndexes.map(index => index.id)), ...targetIndexes.map(index => loadIndex(index)));
        }
    }
    function executeChangeColumnName({ tableState: { tables } }, batchUndoCommand, data) {
        const column = getColumn(tables, data.tableId, data.columnId);
        if (!column)
            return;
        batchUndoCommand.push(createCommand$1('column.changeName', {
            tableId: data.tableId,
            columnId: data.columnId,
            value: column.name,
            width: column.ui.widthName,
        }));
    }
    function executeChangeColumnComment({ tableState: { tables } }, batchUndoCommand, data) {
        const column = getColumn(tables, data.tableId, data.columnId);
        if (!column)
            return;
        batchUndoCommand.push(createCommand$1('column.changeComment', {
            tableId: data.tableId,
            columnId: data.columnId,
            value: column.comment,
            width: column.ui.widthComment,
        }));
    }
    function executeChangeColumnDataType({ tableState: { tables } }, batchUndoCommand, data) {
        const column = getColumn(tables, data.tableId, data.columnId);
        if (!column)
            return;
        batchUndoCommand.push(createCommand$1('column.changeDataType', {
            tableId: data.tableId,
            columnId: data.columnId,
            value: column.dataType,
            width: column.ui.widthDataType,
        }));
    }
    function executeChangeColumnDefault({ tableState: { tables } }, batchUndoCommand, data) {
        const column = getColumn(tables, data.tableId, data.columnId);
        if (!column)
            return;
        batchUndoCommand.push(createCommand$1('column.changeDefault', {
            tableId: data.tableId,
            columnId: data.columnId,
            value: column.default,
            width: column.ui.widthDefault,
        }));
    }
    function executeChangeColumnAutoIncrement(store, batchUndoCommand, data) {
        batchUndoCommand.push(createCommand$1('column.changeAutoIncrement', {
            tableId: data.tableId,
            columnId: data.columnId,
            value: !data.value,
        }));
    }
    function executeChangeColumnPrimaryKey(store, batchUndoCommand, data) {
        batchUndoCommand.push(createCommand$1('column.changePrimaryKey', {
            tableId: data.tableId,
            columnId: data.columnId,
            value: !data.value,
        }));
    }
    function executeChangeColumnUnique(store, batchUndoCommand, data) {
        batchUndoCommand.push(createCommand$1('column.changeUnique', {
            tableId: data.tableId,
            columnId: data.columnId,
            value: !data.value,
        }));
    }
    function executeChangeColumnNotNull(store, batchUndoCommand, data) {
        batchUndoCommand.push(createCommand$1('column.changeNotNull', {
            tableId: data.tableId,
            columnId: data.columnId,
            value: !data.value,
        }));
    }
    function executeMoveColumn({ tableState: { tables, indexes }, relationshipState: { relationships }, }, batchUndoCommand, data) {
        const currentTable = getData(tables, data.tableId);
        const currentColumns = [];
        data.columnIds.forEach(columnId => {
            const column = getColumn(tables, data.tableId, columnId);
            if (!column)
                return;
            currentColumns.push(column);
        });
        const targetTable = getData(tables, data.targetTableId);
        const targetColumn = getColumn(tables, data.targetTableId, data.targetColumnId);
        if (currentTable && targetTable && currentColumns.length && targetColumn) {
            if (data.tableId === data.targetTableId &&
                !data.columnIds.includes(data.targetColumnId)) {
                const columns = [];
                const indexList = [];
                data.columnIds.forEach(columnId => {
                    const column = getData(currentTable.columns, columnId);
                    const index = getIndex(currentTable.columns, columnId);
                    if (column && index !== -1) {
                        columns.push(cloneDeep(column));
                        indexList.push(index);
                    }
                });
                batchUndoCommand.push(removeOnlyColumn(data.tableId, data.columnIds), loadColumn(data.tableId, columns, indexList));
            }
            else if (data.tableId !== data.targetTableId &&
                !data.columnIds.includes(data.targetColumnId)) {
                const targetRelationships = [];
                const targetIndexes = [];
                const columns = [];
                const indexList = [];
                data.columnIds.forEach(columnId => {
                    const column = getData(currentTable.columns, columnId);
                    const index = getIndex(currentTable.columns, columnId);
                    if (column && index !== -1) {
                        columns.push(cloneDeep(column));
                        indexList.push(index);
                    }
                });
                batchUndoCommand.push(removeOnlyColumn(data.targetTableId, data.columnIds), loadColumn(data.tableId, columns, indexList));
                relationships.forEach(relationship => {
                    const { start, end } = relationship;
                    if ((data.tableId === start.tableId &&
                        data.columnIds.some(columnId => start.columnIds.includes(columnId))) ||
                        (data.tableId === end.tableId &&
                            data.columnIds.some(columnId => end.columnIds.includes(columnId)))) {
                        targetRelationships.push(cloneDeep(relationship));
                    }
                });
                const tableIndexes = indexes.filter(index => index.tableId === data.tableId);
                tableIndexes.forEach(index => targetIndexes.push(cloneDeep(index)));
                if (targetRelationships.length) {
                    batchUndoCommand.push(removeRelationship(targetRelationships.map(relationship => relationship.id)), ...targetRelationships.map(relationship => loadRelationship(relationship)));
                }
                if (targetIndexes.length) {
                    batchUndoCommand.push(removeIndex(targetIndexes.map(index => index.id)), ...targetIndexes.map(index => loadIndex(index)));
                }
            }
        }
    }
    const executeColumnCommandMap = {
        'column.add': executeAddColumn,
        'column.addCustom': executeAddCustomColumn,
        'column.remove': executeRemoveColumn,
        'column.changeName': executeChangeColumnName,
        'column.changeComment': executeChangeColumnComment,
        'column.changeDataType': executeChangeColumnDataType,
        'column.changeDefault': executeChangeColumnDefault,
        'column.changeAutoIncrement': executeChangeColumnAutoIncrement,
        'column.changePrimaryKey': executeChangeColumnPrimaryKey,
        'column.changeUnique': executeChangeColumnUnique,
        'column.changeNotNull': executeChangeColumnNotNull,
        'column.move': executeMoveColumn,
    };

    /*!
     * @kderd/sql-ddl-parser
     * @version 0.2.1 | Wed Nov 17 2021
     * @author azer<linguoren@kingdee. com>
     * @license MIT
     */
    const KSqlTypes = [
        'BIGINT',
        'BINARY',
        'BIT',
        'BLOB',
        'BOOL',
        'BOOLEAN',
        'CHAR',
        'DATE',
        'DATETIME',
        'DEC',
        'DECIMAL',
        'DOUBLE PRECISION',
        'DOUBLE',
        'ENUM',
        'FIXED',
        'FLOAT',
        'GEOMETRY',
        'GEOMETRYCOLLECTION',
        'INT',
        'INTEGER',
        'JSON',
        'LINESTRING',
        'LONGBLOB',
        'LONGTEXT',
        'MEDIUMBLOB',
        'MEDIUMINT',
        'MEDIUMTEXT',
        'MULTILINESTRING',
        'MULTIPOINT',
        'MULTIPOLYGON',
        'NUMERIC',
        'POINT',
        'POLYGON',
        'REAL',
        'SET',
        'SMALLINT',
        'TEXT',
        'TIME',
        'TIMESTAMP',
        'TINYBLOB',
        'TINYINT',
        'TINYTEXT',
        'VARBINARY',
        'VARCHAR',
        'YEAR',
    ];

    /**
     * https://docs.microsoft.com/ko-kr/sql/t-sql/data-types/data-types-transact-sql?view=sql-server-ver15
     */
    const MSSQLTypes$1 = [
        'BIGINT',
        'BINARY',
        'BIT',
        'CHAR',
        'DATE',
        'DATETIME',
        'DATETIME2',
        'DATETIMEOFFSET',
        'DECIMAL',
        'FLOAT',
        'GEOGRAPHY',
        'GEOMETRY',
        'IMAGE',
        'INT',
        'MONEY',
        'NCHAR',
        'NTEXT',
        'NUMERIC',
        'NVARCHAR',
        'REAL',
        'SMALLDATETIME',
        'SMALLINT',
        'SMALLMONEY',
        'SQL_VARIANT',
        'TEXT',
        'TIME',
        'TINYINT',
        'UNIQUEIDENTIFIER',
        'VARBINARY',
        'VARCHAR',
        'XML',
    ];

    /**
     * https://dev.mysql.com/doc/refman/8.0/en/data-types.html
     */
    const MySQLTypes$1 = [
        'BIGINT',
        'BINARY',
        'BIT',
        'BLOB',
        'BOOL',
        'BOOLEAN',
        'CHAR',
        'DATE',
        'DATETIME',
        'DEC',
        'DECIMAL',
        'DOUBLE PRECISION',
        'DOUBLE',
        'ENUM',
        'FLOAT',
        'GEOMETRY',
        'GEOMETRYCOLLECTION',
        'INT',
        'INTEGER',
        'JSON',
        'LINESTRING',
        'LONGBLOB',
        'LONGTEXT',
        'MEDIUMBLOB',
        'MEDIUMINT',
        'MEDIUMTEXT',
        'MULTILINESTRING',
        'MULTIPOINT',
        'MULTIPOLYGON',
        'NUMERIC',
        'POINT',
        'POLYGON',
        'SET',
        'SMALLINT',
        'TEXT',
        'TIME',
        'TIMESTAMP',
        'TINYBLOB',
        'TINYINT',
        'TINYTEXT',
        'VARBINARY',
        'VARCHAR',
        'YEAR',
    ];

    /**
     * https://docs.oracle.com/cd/B28359_01/server.111/b28318/datatype.htm#CNCPT012
     */
    const OracleTypes$1 = [
        'BFILE',
        'BINARY_DOUBLE',
        'BINARY_FLOAT',
        'BLOB',
        'CHAR',
        'CLOB',
        'DATE',
        'DATETIME',
        'LONG RAW',
        'LONG',
        'NCHAR',
        'NCLOB',
        'NUMBER',
        'NVARCHAR2',
        'RAW',
        'TIMESTAMP WITH LOCAL TIME ZONE',
        'TIMESTAMP WITH TIME ZONE',
        'TIMESTAMP',
        'UriType',
        'VARCHAR',
        'VARCHAR2',
        'XMLType',
    ];

    /**
     * https://www.postgresql.org/docs/current/datatype.html
     */
    const PostgreSQLTypes$1 = [
        'BIGINT',
        'BIGSERIAL',
        'BIT VARYING',
        'BIT',
        'BOOL',
        'BOOLEAN',
        'BOX',
        'BYTEA',
        'CHAR',
        'CHARACTER VARYING',
        'CHARACTER',
        'CIDR',
        'CIRCLE',
        'DATE',
        'DECIMAL',
        'DOUBLE PRECISION',
        'FLOAT4',
        'FLOAT8',
        'INET',
        'INT',
        'INT2',
        'INT4',
        'INT8',
        'INTEGER',
        'INTERVAL',
        'JSON',
        'JSONB',
        'LINE',
        'LSEG',
        'MACADDR',
        'MACADDR8',
        'MONEY',
        'NUMERIC',
        'PATH',
        'PG_LSN',
        'POINT',
        'POLYGON',
        'REAL',
        'SERIAL',
        'SERIAL2',
        'SERIAL4',
        'SERIAL8',
        'SMALLINT',
        'SMALLSERIAL',
        'TEXT',
        'TIME WITH',
        'TIME',
        'TIMESTAMP WITH',
        'TIMESTAMP',
        'TIMESTAMPTZ',
        'TIMETZ',
        'TSQUERY',
        'TSVECTOR',
        'TXID_SNAPSHOT',
        'UUID',
        'VARBIT',
        'VARCHAR',
        'XML',
    ];

    const KSqlKeywords = [];

    const MSSQLKeywords = [];

    const MySQLKeywords = [
        'ADD',
        'ALTER',
        'AND',
        'AS',
        'ASC',
        'AUTO_INCREMENT',
        'BY',
        'CASCADE',
        'COLUMN',
        'COMMENT',
        'CONSTRAINT',
        'CREATE',
        'DATABASE',
        'DEFAULT',
        'DELETE',
        'DESC',
        'DROP',
        'EXISTS',
        'FOREIGN',
        'IF',
        'INDEX',
        'KEY',
        'LIKE',
        'NOT',
        'NULL',
        'ON',
        'OR',
        'PRIMARY',
        'REFERENCES',
        'RENAME',
        'SCHEMA',
        'SELECT',
        'SET',
        'TABLE',
        'UNION',
        'UNIQUE',
        'USE',
    ];

    const OracleKeywords = [];

    const PostgreSQLKeywords = [];

    const tokenMatch = {
        whiteSpace: /(?:\s+|#.*|-- +.*|\/\*(?:[\s\S])*?\*\/)+/,
        leftParen: '(',
        rightParen: ')',
        comma: ',',
        period: '.',
        equal: '=',
        semicolon: ';',
        doubleQuote: `"`,
        singleQuote: `'`,
        backtick: '`',
        keywords: getKeywords(),
        // number, english, korean, chinese, japanese
        string: /[a-z0-9_\u3131-\u314E\u314F-\u3163\uAC00-\uD7A3\u3040-\u309F\u30A0-\u30FF\u3400-\u4DB5\u4E00-\u9FCC]/i,
        unknown: /.+/,
        dataTypes: getDataTypes(),
    };
    function getDataTypes() {
        const keywords = [
            ...KSqlTypes,
            ...MSSQLTypes$1,
            ...MySQLTypes$1,
            ...OracleTypes$1,
            ...PostgreSQLTypes$1,
        ];
        return Array.from(new Set(keywords.map(keyword => keyword.toUpperCase())));
    }
    function getKeywords() {
        const keywords = [
            ...KSqlKeywords,
            ...MSSQLKeywords,
            ...MySQLKeywords,
            ...OracleKeywords,
            ...PostgreSQLKeywords,
            ...getDataTypes(),
        ];
        return Array.from(new Set(keywords.map(keyword => keyword.toUpperCase())));
    }
    function keywordEqual(token, value) {
        return (token.type === 'keyword' &&
            token.value.toUpperCase() === value.toUpperCase());
    }
    function isExtraString(token) {
        if (!token)
            return false;
        return (token.type === 'doubleQuoteString' ||
            token.type === 'singleQuoteString' ||
            token.type === 'backtickString');
    }
    function isStringKeyword(token) {
        if (!token)
            return false;
        const value = token.value.toUpperCase();
        return token.type === 'string' && tokenMatch.keywords.includes(value);
    }
    function isKeyword(token) {
        if (!token)
            return false;
        return token.type === 'keyword';
    }
    function isString(token) {
        if (!token)
            return false;
        return token.type === 'string';
    }
    function isPeriod(token) {
        if (!token)
            return false;
        return token.type === 'period';
    }
    function isLeftParen(token) {
        if (!token)
            return false;
        return token.type === 'leftParen';
    }
    function isRightParen(token) {
        if (!token)
            return false;
        return token.type === 'rightParen';
    }
    function isSemicolon(token) {
        if (!token)
            return false;
        return token.type === 'semicolon';
    }
    function isComma(token) {
        if (!token)
            return false;
        return token.type === 'comma';
    }
    function isCurrent(list, current) {
        return list.length > current;
    }
    function isNewStatement(token) {
        if (!token)
            return false;
        return (keywordEqual(token, 'CREATE') ||
            keywordEqual(token, 'ALTER') ||
            keywordEqual(token, 'DROP') ||
            keywordEqual(token, 'USE') ||
            keywordEqual(token, 'RENAME') ||
            keywordEqual(token, 'DELETE') ||
            keywordEqual(token, 'SELECT'));
    }
    function isCreateTable(tokens) {
        return (tokens.length > 2 &&
            keywordEqual(tokens[0], 'CREATE') &&
            keywordEqual(tokens[1], 'TABLE'));
    }
    function isCreateIndex(tokens) {
        return (tokens.length > 2 &&
            keywordEqual(tokens[0], 'CREATE') &&
            keywordEqual(tokens[1], 'INDEX'));
    }
    function isCreateUniqueIndex(tokens) {
        return (tokens.length > 3 &&
            keywordEqual(tokens[0], 'CREATE') &&
            keywordEqual(tokens[1], 'UNIQUE') &&
            keywordEqual(tokens[2], 'INDEX'));
    }
    function isAlterTableAddPrimaryKey(tokens) {
        return ((tokens.length > 6 &&
            keywordEqual(tokens[0], 'ALTER') &&
            keywordEqual(tokens[1], 'TABLE') &&
            keywordEqual(tokens[3], 'ADD') &&
            keywordEqual(tokens[4], 'PRIMARY') &&
            keywordEqual(tokens[5], 'KEY')) ||
            (tokens.length > 8 &&
                keywordEqual(tokens[0], 'ALTER') &&
                keywordEqual(tokens[1], 'TABLE') &&
                keywordEqual(tokens[3], 'ADD') &&
                keywordEqual(tokens[4], 'CONSTRAINT') &&
                keywordEqual(tokens[6], 'PRIMARY') &&
                keywordEqual(tokens[7], 'KEY')));
    }
    function isAlterTableAddForeignKey(tokens) {
        return ((tokens.length > 6 &&
            keywordEqual(tokens[0], 'ALTER') &&
            keywordEqual(tokens[1], 'TABLE') &&
            keywordEqual(tokens[3], 'ADD') &&
            keywordEqual(tokens[4], 'FOREIGN') &&
            keywordEqual(tokens[5], 'KEY')) ||
            (tokens.length > 8 &&
                keywordEqual(tokens[0], 'ALTER') &&
                keywordEqual(tokens[1], 'TABLE') &&
                keywordEqual(tokens[3], 'ADD') &&
                keywordEqual(tokens[4], 'CONSTRAINT') &&
                keywordEqual(tokens[6], 'FOREIGN') &&
                keywordEqual(tokens[7], 'KEY')));
    }
    function isAlterTableAddUnique(tokens) {
        return ((tokens.length > 5 &&
            keywordEqual(tokens[0], 'ALTER') &&
            keywordEqual(tokens[1], 'TABLE') &&
            keywordEqual(tokens[3], 'ADD') &&
            keywordEqual(tokens[4], 'UNIQUE')) ||
            (tokens.length > 7 &&
                keywordEqual(tokens[0], 'ALTER') &&
                keywordEqual(tokens[1], 'TABLE') &&
                keywordEqual(tokens[3], 'ADD') &&
                keywordEqual(tokens[4], 'CONSTRAINT') &&
                keywordEqual(tokens[6], 'UNIQUE')));
    }
    function isDataType(token) {
        if (!token)
            return false;
        const value = token.value.toUpperCase();
        return token.type === 'keyword' && tokenMatch.dataTypes.includes(value);
    }
    function isNot(token) {
        if (!token)
            return false;
        return keywordEqual(token, 'NOT');
    }
    function isNull(token) {
        if (!token)
            return false;
        return keywordEqual(token, 'NULL');
    }
    function isDefault(token) {
        if (!token)
            return false;
        return keywordEqual(token, 'DEFAULT');
    }
    function isComment(token) {
        if (!token)
            return false;
        return keywordEqual(token, 'COMMENT');
    }
    function isAutoIncrement(token) {
        if (!token)
            return false;
        return (keywordEqual(token, 'AUTO_INCREMENT') ||
            keywordEqual(token, 'AUTOINCREMENT'));
    }
    function isPrimary(token) {
        if (!token)
            return false;
        return keywordEqual(token, 'PRIMARY');
    }
    function isKey(token) {
        if (!token)
            return false;
        return keywordEqual(token, 'KEY');
    }
    function isUnique(token) {
        if (!token)
            return false;
        return keywordEqual(token, 'UNIQUE');
    }
    function isConstraint(token) {
        if (!token)
            return false;
        return keywordEqual(token, 'CONSTRAINT');
    }
    function isIndex(token) {
        if (!token)
            return false;
        return keywordEqual(token, 'INDEX');
    }
    function isForeign(token) {
        if (!token)
            return false;
        return keywordEqual(token, 'FOREIGN');
    }
    function isReferences(token) {
        if (!token)
            return false;
        return keywordEqual(token, 'REFERENCES');
    }
    function isDESC(token) {
        if (!token)
            return false;
        return keywordEqual(token, 'DESC');
    }
    function isOn(token) {
        if (!token)
            return false;
        return keywordEqual(token, 'ON');
    }
    function isTable(token) {
        if (!token)
            return false;
        return keywordEqual(token, 'TABLE');
    }

    function createTable$1(tokens) {
        const current = { value: 0 };
        const ast = {
            type: 'create.table',
            name: '',
            comment: '',
            columns: [],
            indexes: [],
            foreignKeys: [],
        };
        while (isCurrent(tokens, current.value)) {
            let token = tokens[current.value];
            if (isLeftParen(token)) {
                current.value++;
                const { columns, indexes, foreignKeys } = createTableColumns(tokens, current);
                ast.columns = columns;
                ast.indexes = indexes;
                ast.foreignKeys = foreignKeys;
                continue;
            }
            if (isString(token) && !ast.name) {
                ast.name = token.value;
                token = tokens[++current.value];
                if (isPeriod(token)) {
                    token = tokens[++current.value];
                    if (isString(token)) {
                        ast.name = token.value;
                        current.value++;
                    }
                }
                continue;
            }
            if (isComment(token)) {
                token = tokens[++current.value];
                if (isString(token)) {
                    ast.comment = token.value;
                    current.value++;
                }
                continue;
            }
            current.value++;
        }
        return ast;
    }
    function createTableColumns(tokens, current) {
        const columns = [];
        const indexes = [];
        const foreignKeys = [];
        const primaryKeyColumnNames = [];
        const uniqueColumnNames = [];
        let column = {
            name: '',
            dataType: '',
            default: '',
            comment: '',
            primaryKey: false,
            autoIncrement: false,
            unique: false,
            nullable: true,
        };
        while (isCurrent(tokens, current.value)) {
            let token = tokens[current.value];
            if (isString(token) && !column.name) {
                column.name = token.value;
                current.value++;
                continue;
            }
            if (isLeftParen(token)) {
                token = tokens[++current.value];
                while (isCurrent(tokens, current.value) && !isRightParen(token)) {
                    token = tokens[++current.value];
                }
                current.value++;
                continue;
            }
            if (isConstraint(token)) {
                token = tokens[++current.value];
                if (isString(token)) {
                    current.value++;
                }
                continue;
            }
            if (isPrimary(token)) {
                token = tokens[++current.value];
                if (isKey(token)) {
                    token = tokens[++current.value];
                    if (isLeftParen(token)) {
                        token = tokens[++current.value];
                        while (isCurrent(tokens, current.value) && !isRightParen(token)) {
                            if (isString(token)) {
                                primaryKeyColumnNames.push(token.value.toUpperCase());
                            }
                            token = tokens[++current.value];
                        }
                        current.value++;
                    }
                    else {
                        column.primaryKey = true;
                    }
                }
                continue;
            }
            if (isForeign(token)) {
                const foreignKey = parserForeignKey(tokens, current);
                if (foreignKey) {
                    foreignKeys.push(foreignKey);
                }
                continue;
            }
            if (isIndex(token)) {
                token = tokens[++current.value];
                if (isString(token)) {
                    const name = token.value;
                    const indexColumns = [];
                    token = tokens[++current.value];
                    if (isLeftParen(token)) {
                        token = tokens[++current.value];
                        let indexColumn = {
                            name: '',
                            sort: 'ASC',
                        };
                        while (isCurrent(tokens, current.value) && !isRightParen(token)) {
                            if (isString(token)) {
                                indexColumn.name = token.value;
                            }
                            if (isDESC(token)) {
                                indexColumn.sort = 'DESC';
                            }
                            if (isComma(token)) {
                                indexColumns.push(indexColumn);
                                indexColumn = {
                                    name: '',
                                    sort: 'ASC',
                                };
                            }
                            token = tokens[++current.value];
                        }
                        if (!indexColumns.includes(indexColumn) && indexColumn.name !== '') {
                            indexColumns.push(indexColumn);
                        }
                        if (indexColumns.length) {
                            indexes.push({
                                name,
                                unique: false,
                                columns: indexColumns,
                            });
                        }
                        current.value++;
                    }
                }
                continue;
            }
            if (isUnique(token)) {
                token = tokens[++current.value];
                if (isLeftParen(token)) {
                    token = tokens[++current.value];
                    while (isCurrent(tokens, current.value) && !isRightParen(token)) {
                        if (isString(token)) {
                            uniqueColumnNames.push(token.value.toUpperCase());
                        }
                        token = tokens[++current.value];
                    }
                    current.value++;
                }
                else {
                    column.unique = true;
                }
                continue;
            }
            if (isNot(token)) {
                token = tokens[++current.value];
                if (isNull(token)) {
                    column.nullable = false;
                    current.value++;
                }
                continue;
            }
            if (isDefault(token)) {
                token = tokens[++current.value];
                if (isString(token) || isKeyword(token)) {
                    column.default = token.value;
                    current.value++;
                }
                continue;
            }
            if (isComment(token)) {
                token = tokens[++current.value];
                if (isString(token)) {
                    column.comment = token.value;
                    current.value++;
                }
                continue;
            }
            if (isAutoIncrement(token)) {
                column.autoIncrement = true;
                current.value++;
                continue;
            }
            if (isDataType(token)) {
                let value = token.value;
                token = tokens[++current.value];
                if (isLeftParen(token)) {
                    value += '(';
                    token = tokens[++current.value];
                    while (isCurrent(tokens, current.value) && !isRightParen(token)) {
                        value += token.value;
                        token = tokens[++current.value];
                    }
                    value += ')';
                    current.value++;
                }
                column.dataType = value;
                continue;
            }
            if (isComma(token)) {
                if (column.name || column.dataType) {
                    columns.push(column);
                }
                column = {
                    name: '',
                    dataType: '',
                    default: '',
                    comment: '',
                    primaryKey: false,
                    autoIncrement: false,
                    unique: false,
                    nullable: true,
                };
                current.value++;
                continue;
            }
            if (isRightParen(token)) {
                current.value++;
                break;
            }
            current.value++;
        }
        if (!columns.includes(column) && (column.name || column.dataType)) {
            columns.push(column);
        }
        columns.forEach(column => {
            if (primaryKeyColumnNames.includes(column.name.toUpperCase())) {
                column.primaryKey = true;
            }
            if (uniqueColumnNames.includes(column.name.toUpperCase())) {
                column.unique = true;
            }
        });
        return {
            columns,
            indexes,
            foreignKeys,
        };
    }
    function parserForeignKey(tokens, current) {
        const foreignKey = {
            columnNames: [],
            refTableName: '',
            refColumnNames: [],
        };
        let token = tokens[++current.value];
        if (isKey(token)) {
            token = tokens[++current.value];
            if (isLeftParen(token)) {
                token = tokens[++current.value];
                while (isCurrent(tokens, current.value) && !isRightParen(token)) {
                    if (isString(token)) {
                        foreignKey.columnNames.push(token.value);
                    }
                    token = tokens[++current.value];
                }
                token = tokens[++current.value];
            }
            if (isReferences(token)) {
                token = tokens[++current.value];
                if (isString(token)) {
                    foreignKey.refTableName = token.value;
                    token = tokens[++current.value];
                    if (isPeriod(token)) {
                        token = tokens[++current.value];
                        if (isString(token)) {
                            foreignKey.refTableName = token.value;
                            token = tokens[++current.value];
                        }
                    }
                    if (isLeftParen(token)) {
                        token = tokens[++current.value];
                        while (isCurrent(tokens, current.value) && !isRightParen(token)) {
                            if (isString(token)) {
                                foreignKey.refColumnNames.push(token.value);
                            }
                            token = tokens[++current.value];
                        }
                        token = tokens[++current.value];
                    }
                }
            }
            if (foreignKey.columnNames.length &&
                foreignKey.columnNames.length === foreignKey.refColumnNames.length) {
                return foreignKey;
            }
        }
        return null;
    }

    function alterTableAddForeignKey(tokens) {
        const current = { value: 0 };
        const ast = {
            type: 'alter.table.add.foreignKey',
            name: '',
            columnNames: [],
            refTableName: '',
            refColumnNames: [],
        };
        while (isCurrent(tokens, current.value)) {
            let token = tokens[current.value];
            if (isTable(token)) {
                token = tokens[++current.value];
                if (isString(token)) {
                    ast.name = token.value;
                    token = tokens[++current.value];
                    if (isPeriod(token)) {
                        token = tokens[++current.value];
                        if (isString(token)) {
                            ast.name = token.value;
                            current.value++;
                        }
                    }
                }
                continue;
            }
            if (isConstraint(token)) {
                token = tokens[++current.value];
                if (isString(token)) {
                    current.value++;
                }
                continue;
            }
            if (isForeign(token)) {
                const foreignKey = parserForeignKey(tokens, current);
                if (foreignKey) {
                    ast.columnNames = foreignKey.columnNames;
                    ast.refTableName = foreignKey.refTableName;
                    ast.refColumnNames = foreignKey.refColumnNames;
                }
                continue;
            }
            current.value++;
        }
        return ast;
    }

    function alterTableAddPrimaryKey(tokens) {
        let current = 0;
        const ast = {
            type: 'alter.table.add.primaryKey',
            name: '',
            columnNames: [],
        };
        while (isCurrent(tokens, current)) {
            let token = tokens[current];
            if (isTable(token)) {
                token = tokens[++current];
                if (isString(token)) {
                    ast.name = token.value;
                    token = tokens[++current];
                    if (isPeriod(token)) {
                        token = tokens[++current];
                        if (isString(token)) {
                            ast.name = token.value;
                            current++;
                        }
                    }
                }
                continue;
            }
            if (isConstraint(token)) {
                token = tokens[++current];
                if (isString(token)) {
                    current++;
                }
                continue;
            }
            if (isPrimary(token)) {
                token = tokens[++current];
                if (isKey(token)) {
                    token = tokens[++current];
                    if (isLeftParen(token)) {
                        token = tokens[++current];
                        while (isCurrent(tokens, current) && !isRightParen(token)) {
                            if (isString(token)) {
                                ast.columnNames.push(token.value);
                            }
                            token = tokens[++current];
                        }
                        token = tokens[++current];
                    }
                }
                continue;
            }
            current++;
        }
        return ast;
    }

    function alterTableAddUnique(tokens) {
        let current = 0;
        const ast = {
            type: 'alter.table.add.unique',
            name: '',
            columnNames: [],
        };
        while (isCurrent(tokens, current)) {
            let token = tokens[current];
            if (isTable(token)) {
                token = tokens[++current];
                if (isString(token)) {
                    ast.name = token.value;
                    token = tokens[++current];
                    if (isPeriod(token)) {
                        token = tokens[++current];
                        if (isString(token)) {
                            ast.name = token.value;
                            current++;
                        }
                    }
                }
                continue;
            }
            if (isConstraint(token)) {
                token = tokens[++current];
                if (isString(token)) {
                    current++;
                }
                continue;
            }
            if (isUnique(token)) {
                token = tokens[++current];
                if (isLeftParen(token)) {
                    token = tokens[++current];
                    while (isCurrent(tokens, current) && !isRightParen(token)) {
                        if (isString(token)) {
                            ast.columnNames.push(token.value);
                        }
                        token = tokens[++current];
                    }
                    current++;
                }
                continue;
            }
            current++;
        }
        return ast;
    }

    function createIndex$1(tokens, unique = false) {
        let current = 0;
        const ast = {
            type: 'create.index',
            name: '',
            unique,
            tableName: '',
            columns: [],
        };
        while (isCurrent(tokens, current)) {
            let token = tokens[current];
            if (isIndex(token)) {
                token = tokens[++current];
                if (isString(token)) {
                    ast.name = token.value;
                }
                continue;
            }
            if (isOn(token)) {
                token = tokens[++current];
                if (isString(token)) {
                    ast.tableName = token.value;
                    token = tokens[++current];
                    if (isLeftParen(token)) {
                        token = tokens[++current];
                        let indexColumn = {
                            name: '',
                            sort: 'ASC',
                        };
                        while (isCurrent(tokens, current) && !isRightParen(token)) {
                            if (isString(token)) {
                                indexColumn.name = token.value;
                            }
                            if (isDESC(token)) {
                                indexColumn.sort = 'DESC';
                            }
                            if (isComma(token)) {
                                ast.columns.push(indexColumn);
                                indexColumn = {
                                    name: '',
                                    sort: 'ASC',
                                };
                            }
                            token = tokens[++current];
                        }
                        if (!ast.columns.includes(indexColumn) && indexColumn.name !== '') {
                            ast.columns.push(indexColumn);
                        }
                        current++;
                    }
                }
                continue;
            }
            current++;
        }
        return ast;
    }

    function createUniqueIndex(tokens) {
        return createIndex$1(tokens, true);
    }

    /**
     * https://github.com/jamiebuilds/the-super-tiny-compiler
     */
    function tokenizer(input) {
        let current = 0;
        const tokens = [];
        while (current < input.length) {
            let char = input[current];
            if (tokenMatch.whiteSpace.test(char)) {
                current++;
                continue;
            }
            if (char === tokenMatch.leftParen) {
                tokens.push({
                    type: 'leftParen',
                    value: '(',
                });
                current++;
                continue;
            }
            if (char === tokenMatch.rightParen) {
                tokens.push({
                    type: 'rightParen',
                    value: ')',
                });
                current++;
                continue;
            }
            if (char === tokenMatch.comma) {
                tokens.push({
                    type: 'comma',
                    value: ',',
                });
                current++;
                continue;
            }
            if (char === tokenMatch.period) {
                tokens.push({
                    type: 'period',
                    value: '.',
                });
                current++;
                continue;
            }
            if (char === tokenMatch.equal) {
                tokens.push({
                    type: 'equal',
                    value: '=',
                });
                current++;
                continue;
            }
            if (char === tokenMatch.semicolon) {
                tokens.push({
                    type: 'semicolon',
                    value: ';',
                });
                current++;
                continue;
            }
            if (char === tokenMatch.doubleQuote) {
                let value = '';
                char = input[++current];
                while (char !== tokenMatch.doubleQuote) {
                    value += char;
                    char = input[++current];
                }
                char = input[++current];
                tokens.push({ type: 'doubleQuoteString', value });
                continue;
            }
            if (char === tokenMatch.singleQuote) {
                let value = '';
                char = input[++current];
                while (char !== tokenMatch.singleQuote) {
                    value += char;
                    char = input[++current];
                }
                char = input[++current];
                tokens.push({ type: 'singleQuoteString', value });
                continue;
            }
            if (char === tokenMatch.backtick) {
                let value = '';
                char = input[++current];
                while (char !== tokenMatch.backtick) {
                    value += char;
                    char = input[++current];
                }
                char = input[++current];
                tokens.push({ type: 'backtickString', value });
                continue;
            }
            if (tokenMatch.string.test(char)) {
                let value = '';
                while (tokenMatch.string.test(char)) {
                    value += char;
                    char = input[++current];
                }
                tokens.push({ type: 'string', value });
                continue;
            }
            if (tokenMatch.unknown.test(char)) {
                let value = '';
                while (tokenMatch.unknown.test(char)) {
                    value += char;
                    char = input[++current];
                }
                tokens.push({ type: 'unknown', value });
                continue;
            }
            current++;
        }
        tokens.forEach(token => {
            if (isExtraString(token)) {
                token.type = 'string';
            }
            else if (isStringKeyword(token)) {
                token.type = 'keyword';
            }
        });
        return tokens;
    }
    function parser(tokens) {
        let current = 0;
        const tokenStatements = [];
        const statements = [];
        while (current < tokens.length) {
            let token = tokens[current];
            if (isNewStatement(token)) {
                const statement = [];
                statement.push(token);
                token = tokens[++current];
                while (current < tokens.length &&
                    !isNewStatement(token) &&
                    !isSemicolon(token)) {
                    statement.push(token);
                    token = tokens[++current];
                }
                tokenStatements.push(statement);
            }
            if (token && isNewStatement(token)) {
                continue;
            }
            current++;
        }
        tokenStatements.forEach(tokenStatement => {
            if (isCreateTable(tokenStatement)) {
                statements.push(createTable$1(tokenStatement));
            }
            else if (isCreateIndex(tokenStatement)) {
                statements.push(createIndex$1(tokenStatement));
            }
            else if (isCreateUniqueIndex(tokenStatement)) {
                statements.push(createUniqueIndex(tokenStatement));
            }
            else if (isAlterTableAddPrimaryKey(tokenStatement)) {
                statements.push(alterTableAddPrimaryKey(tokenStatement));
            }
            else if (isAlterTableAddForeignKey(tokenStatement)) {
                statements.push(alterTableAddForeignKey(tokenStatement));
            }
            else if (isAlterTableAddUnique(tokenStatement)) {
                statements.push(alterTableAddUnique(tokenStatement));
            }
        });
        return statements;
    }
    function DDLParser(input) {
        const tokens = tokenizer(input);
        return parser(tokens);
    }

    var domToImage$1 = {exports: {}};

    (function (module) {
    (function (global) {

        var util = newUtil();
        var inliner = newInliner();
        var fontFaces = newFontFaces();
        var images = newImages();

        // Default impl options
        var defaultOptions = {
            // Default is to fail on error, no placeholder
            imagePlaceholder: undefined,
            // Default cache bust is false, it will use the cache
            cacheBust: false
        };

        var domtoimage = {
            toSvg: toSvg,
            toPng: toPng,
            toJpeg: toJpeg,
            toBlob: toBlob,
            toPixelData: toPixelData,
            impl: {
                fontFaces: fontFaces,
                images: images,
                util: util,
                inliner: inliner,
                options: {}
            }
        };

        module.exports = domtoimage;


        /**
         * @param {Node} node - The DOM Node object to render
         * @param {Object} options - Rendering options
         * @param {Function} options.filter - Should return true if passed node should be included in the output
         *          (excluding node means excluding it's children as well). Not called on the root node.
         * @param {String} options.bgcolor - color for the background, any valid CSS color value.
         * @param {Number} options.width - width to be applied to node before rendering.
         * @param {Number} options.height - height to be applied to node before rendering.
         * @param {Object} options.style - an object whose properties to be copied to node's style before rendering.
         * @param {Number} options.quality - a Number between 0 and 1 indicating image quality (applicable to JPEG only),
                    defaults to 1.0.
         * @param {String} options.imagePlaceholder - dataURL to use as a placeholder for failed images, default behaviour is to fail fast on images we can't fetch
         * @param {Boolean} options.cacheBust - set to true to cache bust by appending the time to the request url
         * @return {Promise} - A promise that is fulfilled with a SVG image data URL
         * */
        function toSvg(node, options) {
            options = options || {};
            copyOptions(options);
            return Promise.resolve(node)
                .then(function (node) {
                    return cloneNode(node, options.filter, true);
                })
                .then(embedFonts)
                .then(inlineImages)
                .then(applyOptions)
                .then(function (clone) {
                    return makeSvgDataUri(clone,
                        options.width || util.width(node),
                        options.height || util.height(node)
                    );
                });

            function applyOptions(clone) {
                if (options.bgcolor) clone.style.backgroundColor = options.bgcolor;

                if (options.width) clone.style.width = options.width + 'px';
                if (options.height) clone.style.height = options.height + 'px';

                if (options.style)
                    Object.keys(options.style).forEach(function (property) {
                        clone.style[property] = options.style[property];
                    });

                return clone;
            }
        }

        /**
         * @param {Node} node - The DOM Node object to render
         * @param {Object} options - Rendering options, @see {@link toSvg}
         * @return {Promise} - A promise that is fulfilled with a Uint8Array containing RGBA pixel data.
         * */
        function toPixelData(node, options) {
            return draw(node, options || {})
                .then(function (canvas) {
                    return canvas.getContext('2d').getImageData(
                        0,
                        0,
                        util.width(node),
                        util.height(node)
                    ).data;
                });
        }

        /**
         * @param {Node} node - The DOM Node object to render
         * @param {Object} options - Rendering options, @see {@link toSvg}
         * @return {Promise} - A promise that is fulfilled with a PNG image data URL
         * */
        function toPng(node, options) {
            return draw(node, options || {})
                .then(function (canvas) {
                    return canvas.toDataURL();
                });
        }

        /**
         * @param {Node} node - The DOM Node object to render
         * @param {Object} options - Rendering options, @see {@link toSvg}
         * @return {Promise} - A promise that is fulfilled with a JPEG image data URL
         * */
        function toJpeg(node, options) {
            options = options || {};
            return draw(node, options)
                .then(function (canvas) {
                    return canvas.toDataURL('image/jpeg', options.quality || 1.0);
                });
        }

        /**
         * @param {Node} node - The DOM Node object to render
         * @param {Object} options - Rendering options, @see {@link toSvg}
         * @return {Promise} - A promise that is fulfilled with a PNG image blob
         * */
        function toBlob(node, options) {
            return draw(node, options || {})
                .then(util.canvasToBlob);
        }

        function copyOptions(options) {
            // Copy options to impl options for use in impl
            if(typeof(options.imagePlaceholder) === 'undefined') {
                domtoimage.impl.options.imagePlaceholder = defaultOptions.imagePlaceholder;
            } else {
                domtoimage.impl.options.imagePlaceholder = options.imagePlaceholder;
            }

            if(typeof(options.cacheBust) === 'undefined') {
                domtoimage.impl.options.cacheBust = defaultOptions.cacheBust;
            } else {
                domtoimage.impl.options.cacheBust = options.cacheBust;
            }
        }

        function draw(domNode, options) {
            return toSvg(domNode, options)
                .then(util.makeImage)
                .then(util.delay(100))
                .then(function (image) {
                    var canvas = newCanvas(domNode);
                    canvas.getContext('2d').drawImage(image, 0, 0);
                    return canvas;
                });

            function newCanvas(domNode) {
                var canvas = document.createElement('canvas');
                canvas.width = options.width || util.width(domNode);
                canvas.height = options.height || util.height(domNode);

                if (options.bgcolor) {
                    var ctx = canvas.getContext('2d');
                    ctx.fillStyle = options.bgcolor;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }

                return canvas;
            }
        }

        function cloneNode(node, filter, root) {
            if (!root && filter && !filter(node)) return Promise.resolve();

            return Promise.resolve(node)
                .then(makeNodeCopy)
                .then(function (clone) {
                    return cloneChildren(node, clone, filter);
                })
                .then(function (clone) {
                    return processClone(node, clone);
                });

            function makeNodeCopy(node) {
                if (node instanceof HTMLCanvasElement) return util.makeImage(node.toDataURL());
                return node.cloneNode(false);
            }

            function cloneChildren(original, clone, filter) {
                var children = original.childNodes;
                if (children.length === 0) return Promise.resolve(clone);

                return cloneChildrenInOrder(clone, util.asArray(children), filter)
                    .then(function () {
                        return clone;
                    });

                function cloneChildrenInOrder(parent, children, filter) {
                    var done = Promise.resolve();
                    children.forEach(function (child) {
                        done = done
                            .then(function () {
                                return cloneNode(child, filter);
                            })
                            .then(function (childClone) {
                                if (childClone) parent.appendChild(childClone);
                            });
                    });
                    return done;
                }
            }

            function processClone(original, clone) {
                if (!(clone instanceof Element)) return clone;

                return Promise.resolve()
                    .then(cloneStyle)
                    .then(clonePseudoElements)
                    .then(copyUserInput)
                    .then(fixSvg)
                    .then(function () {
                        return clone;
                    });

                function cloneStyle() {
                    copyStyle(window.getComputedStyle(original), clone.style);

                    function copyStyle(source, target) {
                        if (source.cssText) target.cssText = source.cssText;
                        else copyProperties(source, target);

                        function copyProperties(source, target) {
                            util.asArray(source).forEach(function (name) {
                                target.setProperty(
                                    name,
                                    source.getPropertyValue(name),
                                    source.getPropertyPriority(name)
                                );
                            });
                        }
                    }
                }

                function clonePseudoElements() {
                    [':before', ':after'].forEach(function (element) {
                        clonePseudoElement(element);
                    });

                    function clonePseudoElement(element) {
                        var style = window.getComputedStyle(original, element);
                        var content = style.getPropertyValue('content');

                        if (content === '' || content === 'none') return;

                        var className = util.uid();
                        clone.className = clone.className + ' ' + className;
                        var styleElement = document.createElement('style');
                        styleElement.appendChild(formatPseudoElementStyle(className, element, style));
                        clone.appendChild(styleElement);

                        function formatPseudoElementStyle(className, element, style) {
                            var selector = '.' + className + ':' + element;
                            var cssText = style.cssText ? formatCssText(style) : formatCssProperties(style);
                            return document.createTextNode(selector + '{' + cssText + '}');

                            function formatCssText(style) {
                                var content = style.getPropertyValue('content');
                                return style.cssText + ' content: ' + content + ';';
                            }

                            function formatCssProperties(style) {

                                return util.asArray(style)
                                    .map(formatProperty)
                                    .join('; ') + ';';

                                function formatProperty(name) {
                                    return name + ': ' +
                                        style.getPropertyValue(name) +
                                        (style.getPropertyPriority(name) ? ' !important' : '');
                                }
                            }
                        }
                    }
                }

                function copyUserInput() {
                    if (original instanceof HTMLTextAreaElement) clone.innerHTML = original.value;
                    if (original instanceof HTMLInputElement) clone.setAttribute("value", original.value);
                }

                function fixSvg() {
                    if (!(clone instanceof SVGElement)) return;
                    clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');

                    if (!(clone instanceof SVGRectElement)) return;
                    ['width', 'height'].forEach(function (attribute) {
                        var value = clone.getAttribute(attribute);
                        if (!value) return;

                        clone.style.setProperty(attribute, value);
                    });
                }
            }
        }

        function embedFonts(node) {
            return fontFaces.resolveAll()
                .then(function (cssText) {
                    var styleNode = document.createElement('style');
                    node.appendChild(styleNode);
                    styleNode.appendChild(document.createTextNode(cssText));
                    return node;
                });
        }

        function inlineImages(node) {
            return images.inlineAll(node)
                .then(function () {
                    return node;
                });
        }

        function makeSvgDataUri(node, width, height) {
            return Promise.resolve(node)
                .then(function (node) {
                    node.setAttribute('xmlns', 'http://www.w3.org/1999/xhtml');
                    return new XMLSerializer().serializeToString(node);
                })
                .then(util.escapeXhtml)
                .then(function (xhtml) {
                    return '<foreignObject x="0" y="0" width="100%" height="100%">' + xhtml + '</foreignObject>';
                })
                .then(function (foreignObject) {
                    return '<svg xmlns="http://www.w3.org/2000/svg" width="' + width + '" height="' + height + '">' +
                        foreignObject + '</svg>';
                })
                .then(function (svg) {
                    return 'data:image/svg+xml;charset=utf-8,' + svg;
                });
        }

        function newUtil() {
            return {
                escape: escape,
                parseExtension: parseExtension,
                mimeType: mimeType,
                dataAsUrl: dataAsUrl,
                isDataUrl: isDataUrl,
                canvasToBlob: canvasToBlob,
                resolveUrl: resolveUrl,
                getAndEncode: getAndEncode,
                uid: uid(),
                delay: delay,
                asArray: asArray,
                escapeXhtml: escapeXhtml,
                makeImage: makeImage,
                width: width,
                height: height
            };

            function mimes() {
                /*
                 * Only WOFF and EOT mime types for fonts are 'real'
                 * see http://www.iana.org/assignments/media-types/media-types.xhtml
                 */
                var WOFF = 'application/font-woff';
                var JPEG = 'image/jpeg';

                return {
                    'woff': WOFF,
                    'woff2': WOFF,
                    'ttf': 'application/font-truetype',
                    'eot': 'application/vnd.ms-fontobject',
                    'png': 'image/png',
                    'jpg': JPEG,
                    'jpeg': JPEG,
                    'gif': 'image/gif',
                    'tiff': 'image/tiff',
                    'svg': 'image/svg+xml'
                };
            }

            function parseExtension(url) {
                var match = /\.([^\.\/]*?)$/g.exec(url);
                if (match) return match[1];
                else return '';
            }

            function mimeType(url) {
                var extension = parseExtension(url).toLowerCase();
                return mimes()[extension] || '';
            }

            function isDataUrl(url) {
                return url.search(/^(data:)/) !== -1;
            }

            function toBlob(canvas) {
                return new Promise(function (resolve) {
                    var binaryString = window.atob(canvas.toDataURL().split(',')[1]);
                    var length = binaryString.length;
                    var binaryArray = new Uint8Array(length);

                    for (var i = 0; i < length; i++)
                        binaryArray[i] = binaryString.charCodeAt(i);

                    resolve(new Blob([binaryArray], {
                        type: 'image/png'
                    }));
                });
            }

            function canvasToBlob(canvas) {
                if (canvas.toBlob)
                    return new Promise(function (resolve) {
                        canvas.toBlob(resolve);
                    });

                return toBlob(canvas);
            }

            function resolveUrl(url, baseUrl) {
                var doc = document.implementation.createHTMLDocument();
                var base = doc.createElement('base');
                doc.head.appendChild(base);
                var a = doc.createElement('a');
                doc.body.appendChild(a);
                base.href = baseUrl;
                a.href = url;
                return a.href;
            }

            function uid() {
                var index = 0;

                return function () {
                    return 'u' + fourRandomChars() + index++;

                    function fourRandomChars() {
                        /* see http://stackoverflow.com/a/6248722/2519373 */
                        return ('0000' + (Math.random() * Math.pow(36, 4) << 0).toString(36)).slice(-4);
                    }
                };
            }

            function makeImage(uri) {
                return new Promise(function (resolve, reject) {
                    var image = new Image();
                    image.onload = function () {
                        resolve(image);
                    };
                    image.onerror = reject;
                    image.src = uri;
                });
            }

            function getAndEncode(url) {
                var TIMEOUT = 30000;
                if(domtoimage.impl.options.cacheBust) {
                    // Cache bypass so we dont have CORS issues with cached images
                    // Source: https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#Bypassing_the_cache
                    url += ((/\?/).test(url) ? "&" : "?") + (new Date()).getTime();
                }

                return new Promise(function (resolve) {
                    var request = new XMLHttpRequest();

                    request.onreadystatechange = done;
                    request.ontimeout = timeout;
                    request.responseType = 'blob';
                    request.timeout = TIMEOUT;
                    request.open('GET', url, true);
                    request.send();

                    var placeholder;
                    if(domtoimage.impl.options.imagePlaceholder) {
                        var split = domtoimage.impl.options.imagePlaceholder.split(/,/);
                        if(split && split[1]) {
                            placeholder = split[1];
                        }
                    }

                    function done() {
                        if (request.readyState !== 4) return;

                        if (request.status !== 200) {
                            if(placeholder) {
                                resolve(placeholder);
                            } else {
                                fail('cannot fetch resource: ' + url + ', status: ' + request.status);
                            }

                            return;
                        }

                        var encoder = new FileReader();
                        encoder.onloadend = function () {
                            var content = encoder.result.split(/,/)[1];
                            resolve(content);
                        };
                        encoder.readAsDataURL(request.response);
                    }

                    function timeout() {
                        if(placeholder) {
                            resolve(placeholder);
                        } else {
                            fail('timeout of ' + TIMEOUT + 'ms occured while fetching resource: ' + url);
                        }
                    }

                    function fail(message) {
                        console.error(message);
                        resolve('');
                    }
                });
            }

            function dataAsUrl(content, type) {
                return 'data:' + type + ';base64,' + content;
            }

            function escape(string) {
                return string.replace(/([.*+?^${}()|\[\]\/\\])/g, '\\$1');
            }

            function delay(ms) {
                return function (arg) {
                    return new Promise(function (resolve) {
                        setTimeout(function () {
                            resolve(arg);
                        }, ms);
                    });
                };
            }

            function asArray(arrayLike) {
                var array = [];
                var length = arrayLike.length;
                for (var i = 0; i < length; i++) array.push(arrayLike[i]);
                return array;
            }

            function escapeXhtml(string) {
                return string.replace(/#/g, '%23').replace(/\n/g, '%0A');
            }

            function width(node) {
                var leftBorder = px(node, 'border-left-width');
                var rightBorder = px(node, 'border-right-width');
                return node.scrollWidth + leftBorder + rightBorder;
            }

            function height(node) {
                var topBorder = px(node, 'border-top-width');
                var bottomBorder = px(node, 'border-bottom-width');
                return node.scrollHeight + topBorder + bottomBorder;
            }

            function px(node, styleProperty) {
                var value = window.getComputedStyle(node).getPropertyValue(styleProperty);
                return parseFloat(value.replace('px', ''));
            }
        }

        function newInliner() {
            var URL_REGEX = /url\(['"]?([^'"]+?)['"]?\)/g;

            return {
                inlineAll: inlineAll,
                shouldProcess: shouldProcess,
                impl: {
                    readUrls: readUrls,
                    inline: inline
                }
            };

            function shouldProcess(string) {
                return string.search(URL_REGEX) !== -1;
            }

            function readUrls(string) {
                var result = [];
                var match;
                while ((match = URL_REGEX.exec(string)) !== null) {
                    result.push(match[1]);
                }
                return result.filter(function (url) {
                    return !util.isDataUrl(url);
                });
            }

            function inline(string, url, baseUrl, get) {
                return Promise.resolve(url)
                    .then(function (url) {
                        return baseUrl ? util.resolveUrl(url, baseUrl) : url;
                    })
                    .then(get || util.getAndEncode)
                    .then(function (data) {
                        return util.dataAsUrl(data, util.mimeType(url));
                    })
                    .then(function (dataUrl) {
                        return string.replace(urlAsRegex(url), '$1' + dataUrl + '$3');
                    });

                function urlAsRegex(url) {
                    return new RegExp('(url\\([\'"]?)(' + util.escape(url) + ')([\'"]?\\))', 'g');
                }
            }

            function inlineAll(string, baseUrl, get) {
                if (nothingToInline()) return Promise.resolve(string);

                return Promise.resolve(string)
                    .then(readUrls)
                    .then(function (urls) {
                        var done = Promise.resolve(string);
                        urls.forEach(function (url) {
                            done = done.then(function (string) {
                                return inline(string, url, baseUrl, get);
                            });
                        });
                        return done;
                    });

                function nothingToInline() {
                    return !shouldProcess(string);
                }
            }
        }

        function newFontFaces() {
            return {
                resolveAll: resolveAll,
                impl: {
                    readAll: readAll
                }
            };

            function resolveAll() {
                return readAll()
                    .then(function (webFonts) {
                        return Promise.all(
                            webFonts.map(function (webFont) {
                                return webFont.resolve();
                            })
                        );
                    })
                    .then(function (cssStrings) {
                        return cssStrings.join('\n');
                    });
            }

            function readAll() {
                return Promise.resolve(util.asArray(document.styleSheets))
                    .then(getCssRules)
                    .then(selectWebFontRules)
                    .then(function (rules) {
                        return rules.map(newWebFont);
                    });

                function selectWebFontRules(cssRules) {
                    return cssRules
                        .filter(function (rule) {
                            return rule.type === CSSRule.FONT_FACE_RULE;
                        })
                        .filter(function (rule) {
                            return inliner.shouldProcess(rule.style.getPropertyValue('src'));
                        });
                }

                function getCssRules(styleSheets) {
                    var cssRules = [];
                    styleSheets.forEach(function (sheet) {
                        try {
                            util.asArray(sheet.cssRules || []).forEach(cssRules.push.bind(cssRules));
                        } catch (e) {
                            console.log('Error while reading CSS rules from ' + sheet.href, e.toString());
                        }
                    });
                    return cssRules;
                }

                function newWebFont(webFontRule) {
                    return {
                        resolve: function resolve() {
                            var baseUrl = (webFontRule.parentStyleSheet || {}).href;
                            return inliner.inlineAll(webFontRule.cssText, baseUrl);
                        },
                        src: function () {
                            return webFontRule.style.getPropertyValue('src');
                        }
                    };
                }
            }
        }

        function newImages() {
            return {
                inlineAll: inlineAll,
                impl: {
                    newImage: newImage
                }
            };

            function newImage(element) {
                return {
                    inline: inline
                };

                function inline(get) {
                    if (util.isDataUrl(element.src)) return Promise.resolve();

                    return Promise.resolve(element.src)
                        .then(get || util.getAndEncode)
                        .then(function (data) {
                            return util.dataAsUrl(data, util.mimeType(element.src));
                        })
                        .then(function (dataUrl) {
                            return new Promise(function (resolve, reject) {
                                element.onload = resolve;
                                element.onerror = reject;
                                element.src = dataUrl;
                            });
                        });
                }
            }

            function inlineAll(node) {
                if (!(node instanceof Element)) return Promise.resolve(node);

                return inlineBackground(node)
                    .then(function () {
                        if (node instanceof HTMLImageElement)
                            return newImage(node).inline();
                        else
                            return Promise.all(
                                util.asArray(node.childNodes).map(function (child) {
                                    return inlineAll(child);
                                })
                            );
                    });

                function inlineBackground(node) {
                    var background = node.style.getPropertyValue('background');

                    if (!background) return Promise.resolve(node);

                    return inliner.inlineAll(background)
                        .then(function (inlined) {
                            node.style.setProperty(
                                'background',
                                inlined,
                                node.style.getPropertyPriority('background')
                            );
                        })
                        .then(function () {
                            return node;
                        });
                }
            }
        }
    })();
    }(domToImage$1));

    var domToImage = domToImage$1.exports;

    const defaultOptions$b = {
        nameWidth: 60,
        keymapWidth: 0,
    };
    const getLatestSnapshot = (snapshots) => {
        return snapshots[snapshots.length - 1];
    };
    const createExportMenus = ({ store, snapshots }, canvas) => [
        {
            icon: {
                prefix: 'mdi',
                name: 'code-json',
                size: 18,
            },
            name: 'json',
            execute: () => exportJSON(createJsonStringify(store, 2), store.canvasState.databaseName),
        },
        // {
        //   icon: {
        //     prefix: 'mdi',
        //     name: 'database-export',
        //     size: 18,
        //   },
        //   name: 'SQL DDL',
        //   execute: () =>
        //     exportSQLDDL(createDDL(store), store.canvasState.databaseName),
        // },
        {
            icon: {
                prefix: 'fas',
                name: 'file-image',
            },
            name: 'png',
            execute: () => exportPNG(canvas, store.canvasState.databaseName),
        },
        // {
        //   icon: {
        //     prefix: 'mdi',
        //     name: 'xml',
        //     size: 18,
        //   },
        //   name: 'Liquibase',
        //   execute: () => {
        //     const liquibase = createLiquibase(store, getLatestSnapshot(snapshots));
        //     exportXML(liquibase, store.canvasState.databaseName);
        //     if (liquibase)
        //       // todo make it synchronous
        //       setTimeout(() => {
        //         snapshots.push(createStoreCopy(store));
        //         console.log('AFTER', snapshots);
        //       }, 50);
        //   },
        // },
    ].map(menu => (Object.assign(Object.assign({}, menu), { options: Object.assign({}, defaultOptions$b) })));

    const translations = [
        {
            Liquibase: 'boolean',
            MySQLDatabase: 'BIT(1)',
            H2Database: 'BOOLEAN',
            PostgresDatabase: 'BOOLEAN',
            UnsupportedDatabase: 'BOOLEAN',
            DB2Database: 'SMALLINT',
            MSSQLDatabase: 'BIT',
            OracleDatabase: 'NUMBER(1)',
            HsqlDatabase: 'BOOLEAN',
            FirebirdDatabase: 'SMALLINT',
            DerbyDatabase: 'SMALLINT',
            InformixDatabase: 'BOOLEAN',
            SybaseDatabase: 'BIT',
            SybaseASADatabase: 'BIT',
        },
        {
            Liquibase: 'tinyint',
            MySQLDatabase: 'TINYINT',
            H2Database: 'TINYINT',
            PostgresDatabase: 'SMALLINT',
            UnsupportedDatabase: 'TINYINT',
            DB2Database: 'SMALLINT',
            MSSQLDatabase: 'TINYINT',
            OracleDatabase: 'NUMBER(3)',
            HsqlDatabase: 'TINYINT',
            FirebirdDatabase: 'SMALLINT',
            DerbyDatabase: 'SMALLINT',
            InformixDatabase: 'TINYINT',
            SybaseDatabase: 'TINYINT',
            SybaseASADatabase: 'TINYINT',
        },
        {
            Liquibase: 'int',
            MySQLDatabase: 'INT',
            H2Database: 'INT',
            PostgresDatabase: 'INT',
            UnsupportedDatabase: 'INT',
            DB2Database: 'INTEGER',
            MSSQLDatabase: 'INT',
            OracleDatabase: 'INTEGER',
            HsqlDatabase: 'INT',
            FirebirdDatabase: 'INT',
            DerbyDatabase: 'INTEGER',
            InformixDatabase: 'INT',
            SybaseDatabase: 'INT',
            SybaseASADatabase: 'INT',
        },
        {
            Liquibase: 'mediumint',
            MySQLDatabase: 'MEDIUMINT',
            H2Database: 'MEDIUMINT',
            PostgresDatabase: 'MEDIUMINT',
            UnsupportedDatabase: 'MEDIUMINT',
            DB2Database: 'MEDIUMINT',
            MSSQLDatabase: 'INT',
            OracleDatabase: 'MEDIUMINT',
            HsqlDatabase: 'MEDIUMINT',
            FirebirdDatabase: 'MEDIUMINT',
            DerbyDatabase: 'MEDIUMINT',
            InformixDatabase: 'MEDIUMINT',
            SybaseDatabase: 'MEDIUMINT',
            SybaseASADatabase: 'MEDIUMINT',
        },
        {
            Liquibase: 'bigint',
            MySQLDatabase: 'BIGINT',
            H2Database: 'BIGINT',
            PostgresDatabase: 'BIGINT',
            UnsupportedDatabase: 'BIGINT',
            DB2Database: 'BIGINT',
            MSSQLDatabase: 'BIGINT',
            OracleDatabase: 'NUMBER(38, 0)',
            HsqlDatabase: 'BIGINT',
            FirebirdDatabase: 'BIGINT',
            DerbyDatabase: 'BIGINT',
            InformixDatabase: 'INT8',
            SybaseDatabase: 'BIGINT',
            SybaseASADatabase: 'BIGINT',
        },
        {
            Liquibase: 'float',
            MySQLDatabase: 'FLOAT',
            H2Database: 'FLOAT',
            PostgresDatabase: 'FLOAT',
            UnsupportedDatabase: 'FLOAT',
            DB2Database: 'FLOAT',
            MSSQLDatabase: 'FLOAT(53)',
            OracleDatabase: 'FLOAT',
            HsqlDatabase: 'FLOAT',
            FirebirdDatabase: 'FLOAT',
            DerbyDatabase: 'FLOAT',
            InformixDatabase: 'FLOAT',
            SybaseDatabase: 'FLOAT',
            SybaseASADatabase: 'FLOAT',
        },
        {
            Liquibase: 'double',
            MySQLDatabase: 'DOUBLE',
            H2Database: 'DOUBLE',
            PostgresDatabase: 'DOUBLE PRECISION',
            UnsupportedDatabase: 'DOUBLE',
            DB2Database: 'DOUBLE',
            MSSQLDatabase: 'FLOAT(53)',
            OracleDatabase: 'FLOAT(24)',
            HsqlDatabase: 'DOUBLE',
            FirebirdDatabase: 'DOUBLE PRECISION',
            DerbyDatabase: 'DOUBLE',
            InformixDatabase: 'DOUBLE PRECISION',
            SybaseDatabase: 'DOUBLE',
            SybaseASADatabase: 'DOUBLE',
        },
        {
            Liquibase: 'decimal',
            MySQLDatabase: 'DECIMAL',
            H2Database: 'DECIMAL',
            PostgresDatabase: 'DECIMAL',
            UnsupportedDatabase: 'DECIMAL',
            DB2Database: 'DECIMAL',
            MSSQLDatabase: 'DECIMAL(18, 0)',
            OracleDatabase: 'DECIMAL',
            HsqlDatabase: 'DECIMAL',
            FirebirdDatabase: 'DECIMAL',
            DerbyDatabase: 'DECIMAL',
            InformixDatabase: 'DECIMAL',
            SybaseDatabase: 'DECIMAL',
            SybaseASADatabase: 'DECIMAL',
        },
        {
            Liquibase: 'number',
            MySQLDatabase: 'numeric',
            H2Database: 'NUMBER',
            PostgresDatabase: 'numeric',
            UnsupportedDatabase: 'NUMBER',
            DB2Database: 'numeric',
            MSSQLDatabase: 'numeric(18, 0)',
            OracleDatabase: 'NUMBER',
            HsqlDatabase: 'numeric',
            FirebirdDatabase: 'numeric',
            DerbyDatabase: 'numeric',
            InformixDatabase: 'numeric',
            SybaseDatabase: 'numeric',
            SybaseASADatabase: 'numeric',
        },
        {
            Liquibase: 'blob',
            MySQLDatabase: 'LONGBLOB',
            H2Database: 'BLOB',
            PostgresDatabase: 'BYTEA',
            UnsupportedDatabase: 'BLOB',
            DB2Database: 'BLOB',
            MSSQLDatabase: 'varbinary(MAX)',
            OracleDatabase: 'BLOB',
            HsqlDatabase: 'BLOB',
            FirebirdDatabase: 'BLOB',
            DerbyDatabase: 'BLOB',
            InformixDatabase: 'BLOB',
            SybaseDatabase: 'IMAGE',
            SybaseASADatabase: 'LONG BINARY',
        },
        {
            Liquibase: 'function',
            MySQLDatabase: 'FUNCTION',
            H2Database: 'FUNCTION',
            PostgresDatabase: 'FUNCTION',
            UnsupportedDatabase: 'FUNCTION',
            DB2Database: 'FUNCTION',
            MSSQLDatabase: 'FUNCTION',
            OracleDatabase: 'FUNCTION',
            HsqlDatabase: 'FUNCTION',
            FirebirdDatabase: 'FUNCTION',
            DerbyDatabase: 'FUNCTION',
            InformixDatabase: 'FUNCTION',
            SybaseDatabase: 'FUNCTION',
            SybaseASADatabase: 'FUNCTION',
        },
        {
            Liquibase: 'UNKNOWN',
            MySQLDatabase: 'UNKNOWN',
            H2Database: 'UNKNOWN',
            PostgresDatabase: 'UNKNOWN',
            UnsupportedDatabase: 'UNKNOWN',
            DB2Database: 'UNKNOWN',
            MSSQLDatabase: 'UNKNOWN',
            OracleDatabase: 'UNKNOWN',
            HsqlDatabase: 'UNKNOWN',
            FirebirdDatabase: 'UNKNOWN',
            DerbyDatabase: 'UNKNOWN',
            InformixDatabase: 'UNKNOWN',
            SybaseDatabase: 'UNKNOWN',
            SybaseASADatabase: 'UNKNOWN',
        },
        {
            Liquibase: 'datetime',
            MySQLDatabase: 'datetime',
            H2Database: 'TIMESTAMP',
            PostgresDatabase: 'TIMESTAMP',
            UnsupportedDatabase: 'datetime',
            DB2Database: 'TIMESTAMP',
            MSSQLDatabase: 'datetime',
            OracleDatabase: 'TIMESTAMP',
            HsqlDatabase: 'TIMESTAMP',
            FirebirdDatabase: 'TIMESTAMP',
            DerbyDatabase: 'TIMESTAMP',
            InformixDatabase: 'DATETIME YEAR TO FRACTION(5)',
            SybaseDatabase: 'datetime',
            SybaseASADatabase: 'datetime',
        },
        {
            Liquibase: 'time',
            MySQLDatabase: 'time',
            H2Database: 'time',
            PostgresDatabase: 'TIME',
            UnsupportedDatabase: 'time',
            DB2Database: 'time',
            MSSQLDatabase: 'time(7)',
            OracleDatabase: 'DATE',
            HsqlDatabase: 'time',
            FirebirdDatabase: 'time',
            DerbyDatabase: 'time',
            InformixDatabase: 'INTERVAL HOUR TO FRACTION(5)',
            SybaseDatabase: 'time',
            SybaseASADatabase: 'time',
        },
        {
            Liquibase: 'timestamp',
            MySQLDatabase: 'timestamp',
            H2Database: 'TIMESTAMP',
            PostgresDatabase: 'TIMESTAMP',
            UnsupportedDatabase: 'timestamp',
            DB2Database: 'timestamp',
            MSSQLDatabase: 'datetime',
            OracleDatabase: 'TIMESTAMP',
            HsqlDatabase: 'TIMESTAMP',
            FirebirdDatabase: 'TIMESTAMP',
            DerbyDatabase: 'TIMESTAMP',
            InformixDatabase: 'DATETIME YEAR TO FRACTION(5)',
            SybaseDatabase: 'datetime',
            SybaseASADatabase: 'timestamp',
        },
        {
            Liquibase: 'date',
            MySQLDatabase: 'date',
            H2Database: 'date',
            PostgresDatabase: 'date',
            UnsupportedDatabase: 'date',
            DB2Database: 'date',
            MSSQLDatabase: 'date',
            OracleDatabase: 'date',
            HsqlDatabase: 'date',
            FirebirdDatabase: 'date',
            DerbyDatabase: 'date',
            InformixDatabase: 'date',
            SybaseDatabase: 'date',
            SybaseASADatabase: 'date',
        },
        {
            Liquibase: 'char',
            MySQLDatabase: 'CHAR',
            H2Database: 'CHAR',
            PostgresDatabase: 'CHAR',
            UnsupportedDatabase: 'CHAR',
            DB2Database: 'CHAR',
            MSSQLDatabase: 'CHAR(1)',
            OracleDatabase: 'CHAR',
            HsqlDatabase: 'CHAR',
            FirebirdDatabase: 'CHAR',
            DerbyDatabase: 'CHAR',
            InformixDatabase: 'CHAR',
            SybaseDatabase: 'CHAR',
            SybaseASADatabase: 'CHAR',
        },
        {
            Liquibase: 'varchar',
            MySQLDatabase: 'VARCHAR',
            H2Database: 'VARCHAR',
            PostgresDatabase: 'VARCHAR',
            UnsupportedDatabase: 'VARCHAR',
            DB2Database: 'VARCHAR',
            MSSQLDatabase: 'VARCHAR(1)',
            OracleDatabase: 'VARCHAR2',
            HsqlDatabase: 'VARCHAR',
            FirebirdDatabase: 'VARCHAR',
            DerbyDatabase: 'VARCHAR',
            InformixDatabase: 'VARCHAR',
            SybaseDatabase: 'VARCHAR',
            SybaseASADatabase: 'VARCHAR',
        },
        {
            Liquibase: 'nchar',
            MySQLDatabase: 'NCHAR',
            H2Database: 'NCHAR',
            PostgresDatabase: 'NCHAR',
            UnsupportedDatabase: 'NCHAR',
            DB2Database: 'NCHAR',
            MSSQLDatabase: 'NCHAR(1)',
            OracleDatabase: 'NCHAR',
            HsqlDatabase: 'CHAR',
            FirebirdDatabase: 'NCHAR',
            DerbyDatabase: 'NCHAR',
            InformixDatabase: 'NCHAR',
            SybaseDatabase: 'NCHAR',
            SybaseASADatabase: 'NCHAR',
        },
        {
            Liquibase: 'nvarchar',
            MySQLDatabase: 'NVARCHAR',
            H2Database: 'NVARCHAR',
            PostgresDatabase: 'VARCHAR',
            UnsupportedDatabase: 'NVARCHAR',
            DB2Database: 'NVARCHAR',
            MSSQLDatabase: 'NVARCHAR(1)',
            OracleDatabase: 'NVARCHAR2',
            HsqlDatabase: 'VARCHAR',
            FirebirdDatabase: 'NVARCHAR',
            DerbyDatabase: 'VARCHAR',
            InformixDatabase: 'NVARCHAR',
            SybaseDatabase: 'NVARCHAR',
            SybaseASADatabase: 'NVARCHAR',
        },
        {
            Liquibase: 'clob',
            MySQLDatabase: 'LONGTEXT',
            H2Database: 'CLOB',
            PostgresDatabase: 'TEXT',
            UnsupportedDatabase: 'CLOB',
            DB2Database: 'CLOB',
            MSSQLDatabase: 'VARCHAR(MAX)',
            OracleDatabase: 'CLOB',
            HsqlDatabase: 'CLOB',
            FirebirdDatabase: 'BLOB SUB_TYPE TEXT',
            DerbyDatabase: 'CLOB',
            InformixDatabase: 'CLOB',
            SybaseDatabase: 'TEXT',
            SybaseASADatabase: 'LONG VARCHAR',
        },
        {
            Liquibase: 'currency',
            MySQLDatabase: 'DECIMAL',
            H2Database: 'DECIMAL',
            PostgresDatabase: 'DECIMAL',
            UnsupportedDatabase: 'DECIMAL',
            DB2Database: 'DECIMAL(19, 4)',
            MSSQLDatabase: 'MONEY',
            OracleDatabase: 'NUMBER(15, 2)',
            HsqlDatabase: 'DECIMAL',
            FirebirdDatabase: 'DECIMAL(18, 4)',
            DerbyDatabase: 'DECIMAL',
            InformixDatabase: 'MONEY',
            SybaseDatabase: 'MONEY',
            SybaseASADatabase: 'MONEY',
        },
        {
            Liquibase: 'uuid',
            MySQLDatabase: 'char(36)',
            H2Database: 'UUID',
            PostgresDatabase: 'UUID',
            UnsupportedDatabase: 'char(36)',
            DB2Database: 'char(36)',
            MSSQLDatabase: 'UNIQUEIDENTIFIER',
            OracleDatabase: 'RAW(16)',
            HsqlDatabase: 'char(36)',
            FirebirdDatabase: 'char(36)',
            DerbyDatabase: 'char(36)',
            InformixDatabase: 'char(36)',
            SybaseDatabase: 'UNIQUEIDENTIFIER',
            SybaseASADatabase: 'UNIQUEIDENTIFIER',
        },
    ];

    /**
     * Translation between dialects for liquibase
     * @param dialectFrom Source dialect
     * @param dialectTo Destination dialect
     * @param value Value to be translated
     * @returns Translated string
     */
    const translate = (dialectFrom, dialectTo, value) => {
        var translation;
        switch (dialectFrom) {
            case 'postgresql':
                translation = findTranslationPostgreSQL(value);
                break;
            case 'oracle':
                translation = findTranslationOracle(value);
                break;
            case 'mssql':
                translation = findTranslationMSSQL(value);
                break;
            default:
                return value;
        }
        if (!translation) {
            return value;
        }
        switch (dialectTo) {
            case 'postgresql':
                return (translation === null || translation === void 0 ? void 0 : translation.PostgresDatabase) || '';
            case 'mssql':
                return (translation === null || translation === void 0 ? void 0 : translation.MSSQLDatabase) || '';
            case 'oracle':
                return (translation === null || translation === void 0 ? void 0 : translation.OracleDatabase) || '';
            default:
                return '';
        }
    };
    const findTranslationPostgreSQL = (value) => {
        return translations.find(trans => trans.PostgresDatabase.toLowerCase() === value.toLowerCase());
    };
    const findTranslationOracle = (value) => {
        return translations.find(trans => trans.OracleDatabase.toLowerCase() === value.toLowerCase());
    };
    const findTranslationMSSQL = (value) => {
        return translations.find(trans => trans.MSSQLDatabase.toLowerCase() === value.toLowerCase());
    };

    const dialectTo = 'postgresql';
    const defaultDialect = 'postgresql';
    /**
     * Parser for Liquibase XML file
     * @param input Entire XML file
     * @param dialect Dialect that the result will have datataypes in
     * @returns List of Statements to execute
     */
    const LiquibaseParser = (input, dialect = defaultDialect) => {
        var statements = [];
        var parser = new DOMParser();
        var xmlDoc = parser.parseFromString(input, 'text/xml');
        var changeSets = xmlDoc.getElementsByTagName('changeSet');
        // parse all changesets
        for (let i = 0; i < changeSets.length; i++) {
            const dbms = changeSets[i].getAttribute('dbms') || '';
            if (dbms === '' || dbms == dialect)
                parseChangeSet(changeSets[i], statements, dialect);
        }
        return statements;
    };
    const parseChangeSet = (changeSet, statements, dialect) => {
        parseElement('createTable', changeSet, statements, parseCreateTable, dialect);
        parseElement('createIndex', changeSet, statements, parseCreateIndex);
        parseElement('addForeignKeyConstraint', changeSet, statements, parseAddForeignKeyConstraint);
        parseElement('addPrimaryKey', changeSet, statements, parseAddPrimaryKey);
        parseElement('addColumn', changeSet, statements, parseAddColumn);
        parseElement('dropColumn', changeSet, statements, parseDropColumn);
        parseElement('dropTable', changeSet, statements, parseDropTable);
        parseElement('dropForeignKeyConstraint', changeSet, statements, parseDropForeignKeyConstraint);
    };
    const parseElement = (type, element, statements, parser, dialect) => {
        const elements = element.getElementsByTagName(type);
        for (let i = 0; i < elements.length; i++) {
            parser(elements[i], statements, dialect);
        }
    };
    const parseCreateTable = (createTable, statements, dialect = defaultDialect) => {
        var columns = parseColumns(createTable, dialect);
        statements.push({
            type: 'create.table',
            name: createTable.getAttribute('tableName') || '',
            comment: createTable.getAttribute('remarks') || '',
            columns: columns,
            indexes: [],
            foreignKeys: [],
        });
    };
    const parseColumns = (element, dialect) => {
        var columns = [];
        const cols = element.getElementsByTagName('column');
        for (let i = 0; i < cols.length; i++) {
            columns.push(parseSingleColumn(cols[i], dialect));
        }
        return columns;
    };
    const parseSingleColumn = (column, dialect) => {
        const constr = column.getElementsByTagName('constraints')[0];
        var constraints;
        if (constr) {
            constraints = {
                primaryKey: constr.getAttribute('primaryKey') === 'true',
                nullable: !(constr.getAttribute('nullable') === 'true'),
                unique: constr.getAttribute('unique') === 'true',
            };
        }
        else {
            constraints = {
                primaryKey: false,
                nullable: true,
                unique: false,
            };
        }
        var dataType = translate(dialect, dialectTo, column.getAttribute('type') || '');
        return {
            name: column.getAttribute('name') || '',
            dataType: dataType,
            default: column.getAttribute('defaultValue') || '',
            comment: column.getAttribute('remarks') || '',
            primaryKey: constraints.primaryKey,
            autoIncrement: column.getAttribute('autoIncrement') === 'true',
            unique: constraints.unique,
            nullable: constraints.nullable,
        };
    };
    const parseSingleIndexColumn = (column) => {
        return {
            name: column.getAttribute('name') || '',
            sort: column.getAttribute('descending') ? 'DESC' : 'ASC',
        };
    };
    const parseCreateIndex = (createIndex, statements) => {
        var indexColumns = [];
        const cols = createIndex.getElementsByTagName('column');
        for (let i = 0; i < cols.length; i++) {
            indexColumns.push(parseSingleIndexColumn(cols[i]));
        }
        statements.push({
            type: 'create.index',
            name: createIndex.getAttribute('indexName') || '',
            unique: createIndex.getAttribute('unique') === 'true',
            tableName: createIndex.getAttribute('tableName') || '',
            columns: indexColumns,
        });
    };
    const parseAddForeignKeyConstraint = (addForeignKey, statements) => {
        var _a, _b;
        var refColumnNames = ((_a = addForeignKey
            .getAttribute('referencedColumnNames')) === null || _a === void 0 ? void 0 : _a.split(',').map(item => item.trim())) || [];
        var columnNames = ((_b = addForeignKey
            .getAttribute('baseColumnNames')) === null || _b === void 0 ? void 0 : _b.split(',').map(item => item.trim())) || [];
        statements.push({
            type: 'alter.table.add.foreignKey',
            name: addForeignKey.getAttribute('baseTableName') || '',
            columnNames: columnNames,
            refTableName: addForeignKey.getAttribute('referencedTableName') || '',
            refColumnNames: refColumnNames,
            constraintName: addForeignKey.getAttribute('constraintName') || '',
        });
    };
    const parseAddPrimaryKey = (addPrimaryKey, statements) => {
        var _a;
        var columnNames = ((_a = addPrimaryKey
            .getAttribute('columnNames')) === null || _a === void 0 ? void 0 : _a.split(',').map(item => item.trim())) || [];
        statements.push({
            type: 'alter.table.add.primaryKey',
            name: addPrimaryKey.getAttribute('tableName') || '',
            columnNames: columnNames,
        });
    };
    const parseAddColumn = (addColumn, statements, dialect = defaultDialect) => {
        const tableName = addColumn.getAttribute('tableName') || '';
        statements.push({
            type: 'alter.table.add.column',
            name: tableName,
            columns: parseColumns(addColumn, dialect),
        });
    };
    const parseDropColumn = (dropColumn, statements, dialect = defaultDialect) => {
        const tableName = dropColumn.getAttribute('tableName') || '';
        const column = {
            name: dropColumn.getAttribute('columnName') || '',
            dataType: '',
            default: '',
            comment: '',
            primaryKey: false,
            autoIncrement: false,
            unique: false,
            nullable: false,
        };
        statements.push({
            type: 'alter.table.drop.column',
            name: tableName,
            columns: [column, ...parseColumns(dropColumn, dialect)],
        });
    };
    const parseDropTable = (dropTable, statements) => {
        const tableName = dropTable.getAttribute('tableName') || '';
        statements.push({
            type: 'drop.table',
            name: tableName,
        });
    };
    const parseDropForeignKeyConstraint = (dropFk, statements) => {
        statements.push({
            type: 'alter.table.drop.foreignKey',
            name: dropFk.getAttribute('constraintName') || '',
            baseTableName: dropFk.getAttribute('baseTableName') || '',
        });
    };

    const createControlState = () => ({
        allowEdit: false,
        allowZoom: false,
        allowMoveTable: true
    });

    const createMemoState = () => ({
        memos: [],
    });

    const createRelationshipState = () => ({
        relationships: [],
    });

    const createTableState = () => ({
        tables: [],
        indexes: [],
    });

    /**
     * Sorts statements and adds them to shape
     * @param statements List of statements
     * @param shape (optional) Already existing shape that will just add new statements to itself
     * @returns Shape with sorted statements
     */
    function reshape(statements, shape = {
        tables: [],
        indexes: [],
        primaryKeys: [],
        foreignKeys: [],
        dropForeignKeys: [],
        uniques: [],
        addColumns: [],
        dropColumns: [],
        dropTable: [],
    }) {
        statements.forEach(statement => {
            switch (statement.type) {
                case 'create.table':
                    const table = statement;
                    if (table.name) {
                        shape.tables.push(table);
                    }
                    break;
                case 'create.index':
                    const index = statement;
                    if (index.tableName && index.columns.length) {
                        shape.indexes.push(index);
                    }
                    break;
                case 'alter.table.add.primaryKey':
                    const primaryKey = statement;
                    if (primaryKey.name && primaryKey.columnNames.length) {
                        shape.primaryKeys.push(primaryKey);
                    }
                    break;
                case 'alter.table.add.foreignKey':
                    const foreignKey = statement;
                    if (foreignKey.name &&
                        foreignKey.columnNames.length &&
                        foreignKey.refTableName &&
                        foreignKey.refColumnNames.length &&
                        foreignKey.columnNames.length === foreignKey.refColumnNames.length) {
                        shape.foreignKeys.push(foreignKey);
                    }
                    break;
                case 'alter.table.add.unique':
                    const unique = statement;
                    if (unique.name && unique.columnNames.length) {
                        shape.uniques.push(unique);
                    }
                    break;
                case 'alter.table.add.column':
                    const addColumns = statement;
                    if (addColumns.name && addColumns.columns.length) {
                        shape.addColumns.push(addColumns);
                    }
                    break;
                case 'alter.table.drop.column':
                    const dropColumns = statement;
                    if (dropColumns.name && dropColumns.columns.length) {
                        shape.dropColumns.push(dropColumns);
                    }
                    break;
                case 'drop.table':
                    const dropTable = statement;
                    if (dropTable.name) {
                        shape.dropTable.push(dropTable);
                    }
                    break;
                case 'alter.table.drop.foreignKey':
                    const dropForeignKey = statement;
                    if (dropForeignKey.name && dropForeignKey.baseTableName) {
                        shape.dropForeignKeys.push(dropForeignKey);
                    }
                    break;
            }
        });
        return shape;
    }
    function findByName(list, name) {
        for (const item of list) {
            if (item.name.toUpperCase() === name.toUpperCase()) {
                return item;
            }
        }
        return null;
    }
    /**
     * Adds all statements to CreateTable[]
     * @param shape Shape with all statements
     * @returns Final list of CreateTable[]
     */
    function mergeTable(shape) {
        const { indexes, primaryKeys, foreignKeys, uniques, addColumns, dropColumns, dropForeignKeys, dropTable, } = shape;
        var { tables } = shape;
        indexes.forEach(index => {
            const table = findByName(tables, index.tableName);
            if (table) {
                table.indexes.push({
                    name: index.name,
                    unique: index.unique,
                    columns: index.columns,
                });
            }
        });
        primaryKeys.forEach(primaryKey => {
            const table = findByName(tables, primaryKey.name);
            if (table) {
                primaryKey.columnNames.forEach(columnName => {
                    const column = findByName(table.columns, columnName);
                    if (column) {
                        column.primaryKey = true;
                    }
                });
            }
        });
        uniques.forEach(unique => {
            const table = findByName(tables, unique.name);
            if (table) {
                unique.columnNames.forEach(columnName => {
                    const column = findByName(table.columns, columnName);
                    if (column) {
                        column.unique = true;
                    }
                });
            }
        });
        foreignKeys.forEach(foreignKey => {
            const table = findByName(tables, foreignKey.name);
            if (table) {
                table.foreignKeys.push({
                    columnNames: foreignKey.columnNames,
                    refTableName: foreignKey.refTableName,
                    refColumnNames: foreignKey.refColumnNames,
                    constraintName: foreignKey.constraintName,
                });
            }
        });
        addColumns.forEach(addColumn => {
            const table = findByName(tables, addColumn.name);
            if (table) {
                addColumn.columns.forEach(column => {
                    table.columns.push(column);
                });
            }
        });
        dropColumns.forEach(dropColumn => {
            const table = findByName(tables, dropColumn.name);
            if (table) {
                dropColumn.columns.forEach(columnToDrop => {
                    table.columns = table.columns.filter(column => columnToDrop.name !== column.name);
                });
            }
        });
        dropTable.forEach(dropTable => {
            tables = tables.filter(table => table.name !== dropTable.name);
        });
        dropForeignKeys.forEach(dropForeignKey => {
            const table = findByName(tables, dropForeignKey.baseTableName);
            if (table) {
                table.foreignKeys = table.foreignKeys.filter(fk => fk.constraintName !== dropForeignKey.name);
            }
        });
        return tables;
    }
    /**
     * Converts latest snapshot to shape, so there can be added more new statements
     * @param snaphot Latest snapshot
     * @returns Shape with all statements needed to replicate latest snapshot
     */
    function snapshotToShape({ canvas, memo, table, relationship, }) {
        const shape = {
            tables: [],
            indexes: [],
            primaryKeys: [],
            foreignKeys: [],
            dropForeignKeys: [],
            uniques: [],
            addColumns: [],
            dropColumns: [],
            dropTable: [],
        };
        shape.tables.push(...table.tables.map(table => {
            const columns = table.columns.map(column => {
                return {
                    name: column.name,
                    dataType: column.dataType,
                    default: column.default,
                    comment: column.comment,
                    primaryKey: column.option.primaryKey,
                    autoIncrement: column.option.autoIncrement,
                    unique: column.option.unique,
                    nullable: !column.option.notNull,
                };
            });
            var createTable = {
                type: 'create.table',
                columns: columns,
                comment: table.comment,
                foreignKeys: [],
                indexes: [],
                name: table.name,
            };
            return createTable;
        }));
        shape.indexes.push(...table.indexes.map(index => {
            const indexedTable = getData(table.tables, index.tableId);
            const indexedColumns = [];
            if (indexedTable) {
                index.columns.forEach(col => {
                    const column = getData(indexedTable.columns, col.id);
                    if (column)
                        indexedColumns.push({ name: column.name, sort: col.orderType });
                });
            }
            var createIndex = {
                type: 'create.index',
                name: index.name,
                unique: index.unique,
                tableName: (indexedTable === null || indexedTable === void 0 ? void 0 : indexedTable.name) || '',
                columns: indexedColumns,
            };
            return createIndex;
        }));
        shape.foreignKeys.push(...relationship.relationships.map(relationship => {
            const baseTable = getData(table.tables, relationship.end.tableId);
            const baseColumnNames = relationship.end.columnIds.map(colId => {
                var _a;
                return ((_a = getData((baseTable === null || baseTable === void 0 ? void 0 : baseTable.columns) || [], colId)) === null || _a === void 0 ? void 0 : _a.name) || '';
            });
            const refTable = getData(table.tables, relationship.start.tableId);
            const refColumnNames = relationship.start.columnIds.map(colId => {
                var _a;
                return ((_a = getData((refTable === null || refTable === void 0 ? void 0 : refTable.columns) || [], colId)) === null || _a === void 0 ? void 0 : _a.name) || '';
            });
            const fk = {
                type: 'alter.table.add.foreignKey',
                name: (baseTable === null || baseTable === void 0 ? void 0 : baseTable.name) || '',
                columnNames: baseColumnNames,
                refTableName: (refTable === null || refTable === void 0 ? void 0 : refTable.name) || '',
                refColumnNames: refColumnNames,
                constraintName: relationship.constraintName,
            };
            return fk;
        }));
        return shape;
    }
    function createJsonFormat$1(canvasSize, database, originalCanvas, originalMemo) {
        const canvas = createCanvasState();
        canvas.width = canvasSize;
        canvas.height = canvasSize;
        canvas.database = database;
        return {
            canvas: originalCanvas ? originalCanvas : canvas,
            table: createTableState(),
            memo: originalMemo ? originalMemo : createMemoState(),
            relationship: createRelationshipState(),
            control: createControlState()
        };
    }
    function createJson(statements, helper, database, snapshot) {
        var shape;
        if (snapshot) {
            shape = snapshotToShape(snapshot);
            shape = reshape(statements, shape);
        }
        else {
            shape = reshape(statements);
        }
        const tables = mergeTable(shape);
        let canvasSize = tables.length * 100;
        if (canvasSize < SIZE_CANVAS_MIN) {
            canvasSize = SIZE_CANVAS_MIN;
        }
        if (canvasSize > SIZE_CANVAS_MAX) {
            canvasSize = SIZE_CANVAS_MAX;
        }
        var store;
        if (snapshot) {
            store = createJsonFormat$1(canvasSize, database, snapshot.canvas, snapshot.memo);
        }
        else {
            store = createJsonFormat$1(canvasSize, database);
        }
        tables.forEach(table => {
            store.table.tables.push(createTable(helper, table, snapshot === null || snapshot === void 0 ? void 0 : snapshot.table.tables));
        });
        createRelationship(store, tables);
        createIndex(store, tables);
        return JSON.stringify(store);
    }
    function createTable(helper, table, snapTables) {
        const originalTable = findByName(snapTables || [], table.name);
        const newTable = {
            id: v4(),
            name: table.name,
            comment: table.comment,
            columns: [],
            ui: originalTable
                ? originalTable.ui
                : {
                    active: false,
                    top: 0,
                    left: 0,
                    widthName: SIZE_MIN_WIDTH,
                    widthComment: SIZE_MIN_WIDTH,
                    zIndex: 2,
                },
        };
        const widthName = helper.getTableHeadTextWidth(newTable.name);
        if (SIZE_MIN_WIDTH < widthName) {
            newTable.ui.widthName = widthName;
        }
        const widthComment = helper.getTableHeadTextWidth(newTable.comment);
        if (SIZE_MIN_WIDTH < widthComment) {
            newTable.ui.widthComment = widthComment;
        }
        table.columns.forEach(column => {
            newTable.columns.push(createColumn(helper, column));
        });
        return newTable;
    }
    function createColumn(helper, column) {
        const newColumn = {
            id: v4(),
            name: column.name,
            comment: column.comment,
            dataType: column.dataType,
            default: column.default,
            option: {
                autoIncrement: column.autoIncrement,
                primaryKey: column.primaryKey,
                unique: column.unique,
                notNull: !column.nullable,
            },
            ui: {
                active: false,
                pk: column.primaryKey,
                fk: false,
                pfk: false,
                widthName: SIZE_MIN_WIDTH,
                widthComment: SIZE_MIN_WIDTH,
                widthDataType: SIZE_MIN_WIDTH,
                widthDefault: SIZE_MIN_WIDTH,
            },
        };
        const widthName = helper.getTextWidth(newColumn.name);
        if (SIZE_MIN_WIDTH < widthName) {
            newColumn.ui.widthName = widthName;
        }
        const widthComment = helper.getTextWidth(newColumn.comment);
        if (SIZE_MIN_WIDTH < widthComment) {
            newColumn.ui.widthComment = widthComment;
        }
        const widthDataType = helper.getTextWidth(newColumn.dataType);
        if (SIZE_MIN_WIDTH < widthDataType) {
            newColumn.ui.widthDataType = widthDataType;
        }
        const widthDefault = helper.getTextWidth(newColumn.default);
        if (SIZE_MIN_WIDTH < widthDefault) {
            newColumn.ui.widthDefault = widthDefault;
        }
        return newColumn;
    }
    function createRelationship(data, tables) {
        tables.forEach(table => {
            if (table.foreignKeys) {
                const endTable = findByName(data.table.tables, table.name);
                if (endTable) {
                    table.foreignKeys.forEach(foreignKey => {
                        const startTable = findByName(data.table.tables, foreignKey.refTableName);
                        if (startTable) {
                            const startColumns = [];
                            const endColumns = [];
                            foreignKey.refColumnNames.forEach(refColumnName => {
                                const column = findByName(startTable.columns, refColumnName);
                                if (column) {
                                    startColumns.push(column);
                                }
                            });
                            foreignKey.columnNames.forEach(columnName => {
                                const column = findByName(endTable.columns, columnName);
                                if (column) {
                                    endColumns.push(column);
                                    if (column.ui.pk) {
                                        column.ui.pk = false;
                                        column.ui.pfk = true;
                                    }
                                    else {
                                        column.ui.fk = true;
                                    }
                                }
                            });
                            data.relationship.relationships.push({
                                id: v4(),
                                identification: !endColumns.some(column => !column.ui.pfk),
                                relationshipType: 'ZeroOneN',
                                start: {
                                    tableId: startTable.id,
                                    columnIds: startColumns.map(column => column.id),
                                    x: 0,
                                    y: 0,
                                    direction: 'top',
                                },
                                end: {
                                    tableId: endTable.id,
                                    columnIds: endColumns.map(column => column.id),
                                    x: 0,
                                    y: 0,
                                    direction: 'top',
                                },
                                constraintName: foreignKey.constraintName,
                            });
                        }
                    });
                }
            }
        });
    }
    function createIndex(data, tables) {
        tables.forEach(table => {
            if (table.indexes) {
                table.indexes.forEach(index => {
                    const targetTable = findByName(data.table.tables, table.name);
                    if (targetTable) {
                        const indexColumns = [];
                        index.columns.forEach(column => {
                            const targetColumn = findByName(targetTable.columns, column.name);
                            if (targetColumn) {
                                indexColumns.push({
                                    id: targetColumn.id,
                                    orderType: column.sort,
                                });
                            }
                        });
                        if (indexColumns.length !== 0) {
                            data.table.indexes.push({
                                id: v4(),
                                name: index.name,
                                tableId: targetTable.id,
                                columns: indexColumns,
                                unique: index.unique,
                            });
                        }
                    }
                });
            }
        });
    }

    let executeExportFileExtra = null;
    const createJsonFormat = ({ canvasState, tableState, memoState, relationshipState, controlState }) => ({
        canvas: canvasState,
        table: tableState,
        memo: memoState,
        relationship: relationshipState,
        control: controlState
    });
    const createJsonStringify = (store, space) => JSON.stringify(createJsonFormat(store), (key, value) => (key.startsWith('_') ? undefined : value), space);
    function exportPNG(root, name) {
        domToImage.toBlob(root).then(blob => {
            executeExport(blob, (name === null || name === void 0 ? void 0 : name.trim()) === ''
                ? `unnamed-${new Date().getTime()}.png`
                : `${name}-${new Date().getTime()}.png`);
        });
    }
    const exportJSON = (json, name) => executeExport(new Blob([json], { type: 'application/json' }), (name === null || name === void 0 ? void 0 : name.trim()) === ''
        ? `unnamed-${new Date().getTime()}.kderd.json`
        : `${name}-${new Date().getTime()}.kderd.json`);
    const executeExport = (blob, fileName) => executeExportFileExtra
        ? executeExportFileExtra(blob, fileName)
        : executeExportBuiltin(blob, fileName);
    function executeExportBuiltin(blob, fileName) {
        const exportHelper = document.createElement('a');
        exportHelper.href = window.URL.createObjectURL(blob);
        exportHelper.download = fileName;
        exportHelper.click();
    }
    function setExportFileCallback(callback) {
        executeExportFileExtra = callback;
    }
    function importJSON({ store }) {
        const importHelperJSON = document.createElement('input');
        importHelperJSON.setAttribute('type', 'file');
        importHelperJSON.setAttribute('accept', '.json');
        importHelperJSON.addEventListener('change', event => {
            const input = event.target;
            if (input.files && input.files.length) {
                const file = input.files[0];
                if (/\.(json)$/i.test(file.name)) {
                    const reader = new FileReader();
                    reader.readAsText(file);
                    reader.onload = () => {
                        const value = reader.result;
                        if (typeof value === 'string') {
                            store.dispatch(loadJson$(value));
                        }
                    };
                }
                else {
                    alert('Just upload the json file');
                }
            }
        });
        importHelperJSON.click();
    }
    function importSQLDDL(context) {
        // @ts-ignore
        importWrapper(context, 'sql', DDLParser);
    }
    function importLiquibase(context, dialect) {
        importWrapper(context, 'xml', LiquibaseParser, false, dialect);
    }
    function createStoreCopy(store) {
        return JSON.parse(createJsonStringify(store));
    }
    function importWrapper(context, type, parser, resetDiagram = true, dialect) {
        const { store, helper } = context;
        const importHelper = document.createElement('input');
        importHelper.setAttribute('type', 'file');
        importHelper.setAttribute('accept', `.${type}`);
        importHelper.addEventListener('change', event => {
            const input = event.target;
            if (input.files && input.files.length) {
                const file = input.files[0];
                const regex = new RegExp(`\.(${type})$`, 'i');
                if (regex.test(file.name)) {
                    const reader = new FileReader();
                    reader.readAsText(file);
                    reader.onload = () => {
                        const value = reader.result;
                        if (typeof value === 'string') {
                            const statements = parser(value, dialect);
                            if (resetDiagram) {
                                const json = createJson(statements, helper, store.canvasState.database);
                                store.dispatchSync(loadJson$(json), sortTable());
                            }
                            else {
                                var { snapshots } = context;
                                snapshots.push(createStoreCopy(store));
                                const json = createJson(statements, helper, store.canvasState.database, getLatestSnapshot(snapshots));
                                store.dispatchSync(loadJson$(json));
                            }
                            var { snapshots } = context;
                            snapshots.push(createStoreCopy(store));
                        }
                    };
                }
                else {
                    alert(`Just upload the ${type} file`);
                }
            }
        });
        importHelper.click();
    }

    function executeLoadJson(store, batchUndoCommand) {
        batchUndoCommand.push(loadJson$(createJsonStringify(store)));
    }
    function executeClear(store, batchUndoCommand) {
        batchUndoCommand.push(loadJson$(createJsonStringify(store)));
    }
    const executeEditorCommandMap = {
        'editor.loadJson': executeLoadJson,
        'editor.clear': executeClear,
    };

    function executeAddMemo(store, batchUndoCommand, data) {
        batchUndoCommand.push(removeMemo(store, data.id));
    }
    function executeRemoveMemo({ memoState: { memos } }, batchUndoCommand, { memoIds }) {
        const targetMemos = memoIds
            .map(memoId => getData(memos, memoId))
            .filter(memo => !!memo);
        if (!targetMemos.length)
            return;
        batchUndoCommand.push(...targetMemos.map(memo => loadMemo(cloneDeep(memo))));
    }
    function executeChangeMemoValue({ memoState: { memos } }, batchUndoCommand, data) {
        const memo = getData(memos, data.memoId);
        if (!memo)
            return;
        batchUndoCommand.push(changeMemoValue(memo.id, memo.value));
    }
    const executeMemoCommandMap = {
        'memo.add': executeAddMemo,
        'memo.remove': executeRemoveMemo,
        'memo.changeValue': executeChangeMemoValue,
    };

    function executeAddRelationship(store, batchUndoCommand, data) {
        batchUndoCommand.push(removeRelationship([data.id]));
    }
    function executeRemoveRelationship({ relationshipState: { relationships } }, batchUndoCommand, { relationshipIds }) {
        const targetRelationships = relationshipIds
            .map(id => getData(relationships, id))
            .filter(relationship => !!relationship);
        if (!targetRelationships.length)
            return;
        batchUndoCommand.push(...targetRelationships.map(relationship => loadRelationship(cloneDeep(relationship))));
    }
    function executeChangeRelationshipType({ relationshipState: { relationships } }, batchUndoCommand, data) {
        const relationship = getData(relationships, data.relationshipId);
        if (!relationship)
            return;
        batchUndoCommand.push(createCommand$1('relationship.changeRelationshipType', {
            relationshipId: relationship.id,
            relationshipType: relationship.relationshipType,
        }));
    }
    function executeChangeStartRelationshipType({ relationshipState: { relationships } }, batchUndoCommand, data) {
        var _a;
        const relationship = getData(relationships, data.relationshipId);
        if (!relationship)
            return;
        batchUndoCommand.push(createCommand$1('relationship.changeStartRelationshipType', {
            relationshipId: relationship.id,
            startRelationshipType: (_a = relationship.startRelationshipType) !== null && _a !== void 0 ? _a : 'Dash',
        }));
    }
    function executeChangeIdentification(store, batchUndoCommand, { relationshipId, identification }) {
        batchUndoCommand.push(changeIdentification(relationshipId, !identification));
    }
    const executeRelationshipCommandMap = {
        'relationship.add': executeAddRelationship,
        'relationship.remove': executeRemoveRelationship,
        'relationship.changeRelationshipType': executeChangeRelationshipType,
        'relationship.changeStartRelationshipType': executeChangeStartRelationshipType,
        'relationship.changeIdentification': executeChangeIdentification,
    };

    const MOVE_MIN = 20;
    function executeMoveTable(commands, batchUndoCommand, batchRedoCommand) {
        const moveTableCommands = commands.filter(command => command.name === 'table.move');
        if (!moveTableCommands.length)
            return;
        const data = moveTableCommands[0].data;
        const tableIds = data.tableIds;
        const memoIds = data.memoIds;
        let movementX = 0;
        let movementY = 0;
        moveTableCommands.forEach(moveTableCommand => {
            const data = moveTableCommand.data;
            movementX += data.movementX;
            movementY += data.movementY;
        });
        if (Math.abs(movementX) + Math.abs(movementY) < MOVE_MIN)
            return;
        batchUndoCommand.push(createCommand$1('table.move', {
            movementX: -1 * movementX,
            movementY: -1 * movementY,
            tableIds,
            memoIds,
        }));
        batchRedoCommand.push(createCommand$1('table.move', {
            movementX,
            movementY,
            tableIds,
            memoIds,
        }));
    }
    function executeMoveMemo(commands, batchUndoCommand, batchRedoCommand) {
        const moveMemoCommands = commands.filter(command => command.name === 'memo.move');
        if (!moveMemoCommands.length)
            return;
        const data = moveMemoCommands[0].data;
        const tableIds = data.tableIds;
        const memoIds = data.memoIds;
        let movementX = 0;
        let movementY = 0;
        moveMemoCommands.forEach(moveTableCommand => {
            const data = moveTableCommand.data;
            movementX += data.movementX;
            movementY += data.movementY;
        });
        if (Math.abs(movementX) + Math.abs(movementY) < MOVE_MIN)
            return;
        batchUndoCommand.push(createCommand$1('memo.move', {
            movementX: -1 * movementX,
            movementY: -1 * movementY,
            tableIds,
            memoIds,
        }));
        batchRedoCommand.push(createCommand$1('memo.move', {
            movementX,
            movementY,
            tableIds,
            memoIds,
        }));
    }
    function executeResizeMemo(commands, batchUndoCommand, batchRedoCommand) {
        const resizeMemoCommands = commands.filter(command => command.name === 'memo.resize');
        if (resizeMemoCommands.length < 2)
            return;
        batchUndoCommand.push(resizeMemoCommands[0]);
        batchRedoCommand.push(resizeMemoCommands[resizeMemoCommands.length - 1]);
    }
    function executeMovementCanvas(commands, batchUndoCommand, batchRedoCommand) {
        const moveCanvasCommands = commands.filter(command => command.name === 'canvas.movement');
        if (!moveCanvasCommands.length)
            return;
        let movementX = 0;
        let movementY = 0;
        moveCanvasCommands.forEach(moveCanvasCommand => {
            const data = moveCanvasCommand.data;
            movementX += data.movementX;
            movementY += data.movementY;
        });
        if (Math.abs(movementX) + Math.abs(movementY) < MOVE_MIN)
            return;
        batchUndoCommand.push(movementCanvas(-1 * movementX, -1 * movementY));
        batchRedoCommand.push(movementCanvas(movementX, movementY));
    }
    function executeMovementZoomCanvas(commands, batchUndoCommand, batchRedoCommand) {
        const zoomCanvasCommands = commands.filter(command => command.name === 'canvas.movementZoom');
        if (!zoomCanvasCommands.length)
            return;
        const movementZoomLevel = zoomCanvasCommands
            .map(zoomCanvasCommand => zoomCanvasCommand.data.movementZoomLevel)
            .reduce((acc, cur) => acc + cur, 0);
        batchUndoCommand.push(movementZoomCanvas(-1 * movementZoomLevel));
        batchRedoCommand.push(movementZoomCanvas(movementZoomLevel));
    }
    const executeStreamCommandMap = {
        'table.move': executeMoveTable,
        'memo.move': executeMoveMemo,
        'memo.resize': executeResizeMemo,
        'canvas.movement': executeMovementCanvas,
        'canvas.movementZoom': executeMovementZoomCanvas,
    };

    function executeAddTable(store, batchUndoCommand, data) {
        batchUndoCommand.push(removeTable(store, data.id));
    }
    function executeRemoveTable({ tableState: { tables, indexes }, relationshipState: { relationships }, }, batchUndoCommand, { tableIds }) {
        const targetTables = [];
        const targetRelationships = [];
        const targetIndexes = [];
        tableIds.forEach(tableId => {
            const table = getData(tables, tableId);
            if (!table)
                return;
            targetTables.push(cloneDeep(table));
            relationships.forEach(relationship => {
                const { start, end } = relationship;
                if (tableId === start.tableId || tableId === end.tableId) {
                    targetRelationships.push(cloneDeep(relationship));
                }
            });
            const tableIndexes = indexes.filter(index => index.tableId === table.id);
            tableIndexes.forEach(index => targetIndexes.push(cloneDeep(index)));
        });
        if (!targetTables.length)
            return;
        batchUndoCommand.push(...targetTables.map(table => loadTable(table)));
        if (targetRelationships.length) {
            batchUndoCommand.push(removeRelationship(targetRelationships.map(relationship => relationship.id)), ...targetRelationships.map(relationship => loadRelationship(relationship)));
        }
        if (targetIndexes.length) {
            batchUndoCommand.push(removeIndex(targetIndexes.map(index => index.id)), ...targetIndexes.map(index => loadIndex(index)));
        }
    }
    function executeChangeTableName({ tableState: { tables } }, batchUndoCommand, data) {
        const table = getData(tables, data.tableId);
        if (!table)
            return;
        batchUndoCommand.push(createCommand$1('table.changeName', {
            tableId: table.id,
            value: table.name,
            width: table.ui.widthName,
        }));
    }
    function executeChangeTableComment({ tableState: { tables } }, batchUndoCommand, data) {
        const table = getData(tables, data.tableId);
        if (!table)
            return;
        batchUndoCommand.push(createCommand$1('table.changeComment', {
            tableId: table.id,
            value: table.comment,
            width: table.ui.widthComment,
        }));
    }
    function executeSortTable(store, batchUndoCommand) {
        batchUndoCommand.push(loadJson$(createJsonStringify(store)));
    }
    const executeTableCommandMap = {
        'table.add': executeAddTable,
        'table.remove': executeRemoveTable,
        'table.changeName': executeChangeTableName,
        'table.changeComment': executeChangeTableComment,
        'table.sort': executeSortTable,
    };

    const executeCommandMap = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, executeCanvasCommandMap), executeMemoCommandMap), executeTableCommandMap), executeColumnCommandMap), executeEditorCommandMap), executeRelationshipCommandMap);
    function executeCommand(store, history, commands) {
        const batchUndoCommand = [];
        const batchRedoCommand = [];
        commands.forEach(command => {
            const execute = executeCommandMap[command.name];
            if (!execute)
                return;
            execute(store, batchUndoCommand, command.data);
            batchRedoCommand.push(command);
        });
        Object.keys(executeStreamCommandMap).forEach(key => executeStreamCommandMap[key](commands, batchUndoCommand, batchRedoCommand));
        if (!batchUndoCommand.length || !batchRedoCommand.length)
            return;
        history.push({
            undo: () => store.history$.next([...flat(batchUndoCommand)]),
            redo: () => store.history$.next([...flat(batchRedoCommand)]),
        });
    }
    const executeHistoryCommand = curry$1((store, history, commands) => {
        try {
            executeCommand(store, history, commands);
        }
        catch (err) {
            Logger.error(err);
        }
    });

    const TABLE_PADDING$2 = (SIZE_TABLE_PADDING + SIZE_TABLE_BORDER) * 2;
    const PATH_HEIGHT = 30;
    const PATH_END_HEIGHT = PATH_HEIGHT + 20;
    const PATH_LINE_HEIGHT = 35;
    const LINE_SIZE = 10;
    const LINE_HEIGHT = 16;
    const CIRCLE_HEIGHT = 26;
    const directions = ['top', 'bottom', 'left', 'right'];
    function getCoordinate(table) {
        const width = table.width() + TABLE_PADDING$2;
        const height = table.height() + TABLE_PADDING$2;
        const ui = table.ui;
        return {
            width,
            height,
            top: {
                x: ui.left + width / 2,
                y: ui.top,
            },
            bottom: {
                x: ui.left + width / 2,
                y: ui.top + height,
            },
            left: {
                x: ui.left,
                y: ui.top + height / 2,
            },
            right: {
                x: ui.left + width,
                y: ui.top + height / 2,
            },
            lt: {
                x: ui.left,
                y: ui.top,
            },
            rt: {
                x: ui.left + width,
                y: ui.top,
            },
            lb: {
                x: ui.left,
                y: ui.top + height,
            },
            rb: {
                x: ui.left + width,
                y: ui.top + height,
            },
        };
    }
    const getDistance = (a, b) => Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2);
    const directionFilter = (key) => directions.includes(key);
    function getDrawDirection(draw) {
        let direction = 'bottom';
        if (!draw.start)
            return direction;
        const start = getCoordinate(draw.start.table);
        let min = getDistance(start.bottom, draw.end);
        draw.start.x = start.bottom.x;
        draw.start.y = start.bottom.y;
        Object.keys(start)
            .filter(directionFilter)
            .forEach(key => {
            const k = key;
            const temp = getDistance(start[k], draw.end);
            if (min <= temp)
                return;
            min = temp;
            direction = k;
            if (!draw.start)
                return;
            draw.start.x = start[k].x;
            draw.start.y = start[k].y;
        });
        return direction;
    }
    function getDrawPath(direction, draw) {
        const line = {
            start: {
                x1: 0,
                y1: 0,
                x2: 0,
                y2: 0,
            },
        };
        const path = {
            M: { x: 0, y: 0 },
            L: { x: 0, y: 0 },
            Q: { x: 0, y: 0 },
            d() {
                return `M ${this.M.x} ${this.M.y} L ${this.L.x} ${this.L.y}`;
            },
        };
        if (draw.start) {
            line.start.x1 = draw.start.x;
            line.start.y1 = draw.start.y;
            line.start.x2 = draw.start.x;
            line.start.y2 = draw.start.y;
            let change = 1;
            if (direction === 'left' || direction === 'right') {
                if (direction === 'left') {
                    change *= -1;
                }
                line.start.x2 = draw.start.x + change * PATH_END_HEIGHT;
                line.start.x1 += change * PATH_LINE_HEIGHT;
                path.M.x = line.start.x2;
                path.M.y = draw.start.y;
            }
            else if (direction === 'top' || direction === 'bottom') {
                if (direction === 'top') {
                    change *= -1;
                }
                line.start.y2 = draw.start.y + change * PATH_END_HEIGHT;
                line.start.y1 += change * PATH_LINE_HEIGHT;
                path.M.x = draw.start.x;
                path.M.y = line.start.y2;
            }
        }
        path.L.x = draw.end.x;
        path.L.y = draw.end.y;
        return {
            path,
            line,
        };
    }
    function getDrawLine(direction, draw) {
        const line = {
            start: {
                base: {
                    x1: 0,
                    y1: 0,
                    x2: 0,
                    y2: 0,
                },
                base2: {
                    x1: 0,
                    y1: 0,
                    x2: 0,
                    y2: 0,
                },
                center: {
                    x1: 0,
                    y1: 0,
                    x2: 0,
                    y2: 0,
                },
                center2: {
                    x1: 0,
                    y1: 0,
                    x2: 0,
                    y2: 0,
                },
            },
        };
        if (!draw.start)
            return line;
        line.start.base.x1 =
            line.start.base2.x1 =
                line.start.center.x1 =
                    line.start.center2.x1 =
                        draw.start.x;
        line.start.base.x2 =
            line.start.base2.x2 =
                line.start.center.x2 =
                    line.start.center2.x2 =
                        draw.start.x;
        line.start.base.y1 =
            line.start.base2.y1 =
                line.start.center.y1 =
                    line.start.center2.y1 =
                        draw.start.y;
        line.start.base.y2 =
            line.start.base2.y2 =
                line.start.center.y2 =
                    line.start.center2.y2 =
                        draw.start.y;
        let change = 1;
        if (direction === 'left' || direction === 'right') {
            if (direction === 'left') {
                change *= -1;
            }
            line.start.base.x1 = line.start.base.x2 += change * LINE_HEIGHT;
            line.start.base2.x1 = line.start.base2.x2 +=
                change * (LINE_SIZE + LINE_HEIGHT);
            line.start.center.x1 = line.start.base.x1;
            line.start.base.y1 -= LINE_SIZE;
            line.start.base.y2 += LINE_SIZE;
            line.start.base2.y1 -= LINE_SIZE;
            line.start.base2.y2 += LINE_SIZE;
            line.start.center2.x1 += change * (LINE_HEIGHT + LINE_HEIGHT + 3);
        }
        else if (direction === 'top' || direction === 'bottom') {
            if (direction === 'top') {
                change *= -1;
            }
            line.start.base.y1 = line.start.base.y2 += change * LINE_HEIGHT;
            line.start.base2.y1 = line.start.base2.y2 +=
                change * (LINE_SIZE + LINE_HEIGHT);
            line.start.center.y1 = line.start.base.y1;
            line.start.base.x1 -= LINE_SIZE;
            line.start.base.x2 += LINE_SIZE;
            line.start.base2.x1 -= LINE_SIZE;
            line.start.base2.x2 += LINE_SIZE;
            line.start.center2.y1 += change * (LINE_HEIGHT + LINE_HEIGHT + 3);
        }
        return line;
    }
    function getDraw(draw) {
        const drawPath = {
            path: {
                path: {
                    M: { x: 0, y: 0 },
                    L: { x: 0, y: 0 },
                    Q: { x: 0, y: 0 },
                    d() {
                        return `M ${this.M.x} ${this.M.y} L ${this.L.x} ${this.L.y}`;
                    },
                },
                line: {
                    start: {
                        x1: 0,
                        y1: 0,
                        x2: 0,
                        y2: 0,
                    },
                },
            },
            line: {
                start: {
                    base: {
                        x1: 0,
                        y1: 0,
                        x2: 0,
                        y2: 0,
                    },
                    base2: {
                        x1: 0,
                        y1: 0,
                        x2: 0,
                        y2: 0,
                    },
                    center: {
                        x1: 0,
                        y1: 0,
                        x2: 0,
                        y2: 0,
                    },
                    center2: {
                        x1: 0,
                        y1: 0,
                        x2: 0,
                        y2: 0,
                    },
                },
            },
        };
        if (!draw.start)
            return drawPath;
        const direction = getDrawDirection(draw);
        drawPath.path = getDrawPath(direction, draw);
        drawPath.line = getDrawLine(direction, draw);
        return drawPath;
    }
    const getRelationshipGraph = (graphs, table) => graphs.find(graph => graph.table.id === table.id);
    function getDirection(start, end, relationship) {
        const direction = {
            start: 'bottom',
            end: 'bottom',
        };
        let min = getDistance(start.bottom, end.bottom);
        relationship.start.x = start.bottom.x;
        relationship.start.y = start.bottom.y;
        relationship.end.x = end.bottom.x;
        relationship.end.y = end.bottom.y;
        Object.keys(start)
            .filter(directionFilter)
            .forEach(key => {
            Object.keys(end)
                .filter(directionFilter)
                .forEach(key2 => {
                const k = key;
                const k2 = key2;
                const temp = getDistance(start[k], end[k2]);
                if (min <= temp)
                    return;
                min = temp;
                direction.start = k;
                direction.end = k2;
                relationship.start.x = start[k].x;
                relationship.start.y = start[k].y;
                relationship.end.x = end[k2].x;
                relationship.end.y = end[k2].y;
            });
        });
        return direction;
    }
    function relationshipOverlayPoint(direction, graph) {
        const len = graph[direction].length;
        const margin = {
            x: graph.coordinate.width / len,
            y: graph.coordinate.height / len,
        };
        const padding = {
            x: margin.x / 2,
            y: margin.y / 2,
        };
        const xArray = [];
        const yArray = [];
        if (direction === 'left' || direction === 'right') {
            let sum = graph.coordinate.lt.y - padding.y;
            for (let i = 0; i < len; i++) {
                sum += margin.y;
                yArray.push(sum);
            }
        }
        else if (direction === 'top' || direction === 'bottom') {
            let sum = graph.coordinate.lt.x - padding.x;
            for (let i = 0; i < len; i++) {
                sum += margin.x;
                xArray.push(sum);
            }
        }
        return {
            xArray,
            yArray,
        };
    }
    const sortDistance = (a, b) => a.distance - b.distance;
    function relationshipOverlayOrder(direction, table, relationships) {
        const startPoints = [];
        const endPoints = [];
        relationships.forEach(relationship => {
            if (relationship.start.tableId === relationship.end.tableId) {
                // self relationship
                if (direction === 'top') {
                    startPoints.push(relationship.start);
                    endPoints.push(relationship.end);
                }
                else if (direction === 'right') {
                    startPoints.push(relationship.end);
                    endPoints.push(relationship.start);
                }
            }
            else if (relationship.start.tableId === table.id) {
                startPoints.push(relationship.start);
                endPoints.push(relationship.end);
            }
            else {
                startPoints.push(relationship.end);
                endPoints.push(relationship.start);
            }
        });
        const start = {
            x: startPoints[0].x,
            y: startPoints[0].y,
        };
        const distances = [];
        endPoints.forEach((endPoint, index) => {
            distances.push({
                start: startPoints[index],
                end: endPoints[index],
                distance: getDistance(start, endPoint),
            });
        });
        distances.sort(sortDistance);
        return distances;
    }
    function relationshipOverlayFirstCheck(direction, order, point) {
        let result = true;
        if (direction === 'left' || direction === 'right') {
            result =
                getDistance({ x: order.start.x, y: point.yArray[0] }, order.end) <
                    getDistance({ x: order.start.x, y: point.yArray[point.yArray.length - 1] }, order.end);
        }
        else if (direction === 'top' || direction === 'bottom') {
            result =
                getDistance({ x: point.xArray[0], y: order.start.y }, order.end) <
                    getDistance({ x: point.xArray[point.xArray.length - 1], y: order.start.y }, order.end);
        }
        return result;
    }
    function relationshipOverlaySort(direction, graph) {
        const point = relationshipOverlayPoint(direction, graph);
        let distances = relationshipOverlayOrder(direction, graph.table, graph[direction]);
        if (distances.length > 1) {
            if (!relationshipOverlayFirstCheck(direction, distances[0], point)) {
                distances = distances.reverse();
            }
        }
        if (direction === 'left' || direction === 'right') {
            point.yArray.forEach((y, index) => {
                distances[index].start.y = y;
            });
        }
        else if (direction === 'top' || direction === 'bottom') {
            point.xArray.forEach((x, index) => {
                distances[index].start.x = x;
            });
        }
    }
    function relationshipSort(tables, relationships) {
        const graphs = [];
        relationships.forEach(relationship => {
            const tableStart = getData(tables, relationship.start.tableId);
            const tableEnd = getData(tables, relationship.end.tableId);
            if (tableStart && tableEnd) {
                if (relationship.start.tableId === relationship.end.tableId) {
                    relationship.start.direction = 'top';
                    relationship.end.direction = 'right';
                    const graph = getRelationshipGraph(graphs, tableStart);
                    if (graph) {
                        relationship.start.x = graph.coordinate.rt.x - 20;
                        relationship.start.y = graph.coordinate.rt.y;
                        relationship.end.x = graph.coordinate.rt.x;
                        relationship.end.y = graph.coordinate.rt.y + 20;
                        graph.top.push(relationship);
                        graph.right.push(relationship);
                    }
                    else {
                        const coordinate = getCoordinate(tableStart);
                        relationship.start.x = coordinate.rt.x - 20;
                        relationship.start.y = coordinate.rt.y;
                        relationship.end.x = coordinate.rt.x;
                        relationship.end.y = coordinate.rt.y + 20;
                        graphs.push({
                            table: tableStart,
                            coordinate,
                            top: [relationship],
                            bottom: [],
                            left: [],
                            right: [relationship],
                        });
                    }
                }
                else {
                    const coordinateStart = getCoordinate(tableStart);
                    const coordinateEnd = getCoordinate(tableEnd);
                    const direction = getDirection(coordinateStart, coordinateEnd, relationship);
                    const graphStart = getRelationshipGraph(graphs, tableStart);
                    const graphEnd = getRelationshipGraph(graphs, tableEnd);
                    relationship.start.direction = direction.start;
                    relationship.end.direction = direction.end;
                    if (graphStart) {
                        graphStart[direction.start].push(relationship);
                    }
                    else {
                        const graph = {
                            table: tableStart,
                            coordinate: coordinateStart,
                            top: [],
                            bottom: [],
                            left: [],
                            right: [],
                        };
                        graph[direction.start].push(relationship);
                        graphs.push(graph);
                    }
                    if (graphEnd) {
                        graphEnd[direction.end].push(relationship);
                    }
                    else {
                        const graph = {
                            table: tableEnd,
                            coordinate: coordinateEnd,
                            top: [],
                            bottom: [],
                            left: [],
                            right: [],
                        };
                        graph[direction.end].push(relationship);
                        graphs.push(graph);
                    }
                }
            }
        });
        graphs.forEach(graph => {
            directions.forEach(value => {
                const direction = value;
                const len = graph[direction].length;
                if (len < 2)
                    return;
                relationshipOverlaySort(direction, graph);
            });
        });
    }
    function getPath(start, end) {
        const line = {
            start: {
                x1: start.x,
                y1: start.y,
                x2: start.x,
                y2: start.y,
            },
            end: {
                x1: end.x,
                y1: end.y,
                x2: end.x,
                y2: end.y,
            },
        };
        const path = {
            M: { x: 0, y: 0 },
            L: { x: 0, y: 0 },
            Q: { x: 0, y: 0 },
            d() {
                return `M ${this.M.x} ${this.M.y} L ${this.L.x} ${this.L.y}`;
            },
        };
        let change = 1;
        if (start.direction === 'left' || start.direction === 'right') {
            if (start.direction === 'left') {
                change *= -1;
            }
            line.start.x2 = start.x + change * PATH_END_HEIGHT;
            line.start.x1 += change * PATH_LINE_HEIGHT;
            path.M.x = line.start.x2;
            path.M.y = start.y;
        }
        else if (start.direction === 'top' || start.direction === 'bottom') {
            if (start.direction === 'top') {
                change *= -1;
            }
            line.start.y2 = start.y + change * PATH_END_HEIGHT;
            line.start.y1 += change * PATH_LINE_HEIGHT;
            path.M.x = start.x;
            path.M.y = line.start.y2;
        }
        change = 1;
        if (end.direction === 'left' || end.direction === 'right') {
            if (end.direction === 'left') {
                change *= -1;
            }
            line.end.x2 = end.x + change * PATH_END_HEIGHT;
            line.end.x1 += change * PATH_LINE_HEIGHT;
            path.L.x = line.end.x2;
            path.L.y = end.y;
        }
        else if (end.direction === 'top' || end.direction === 'bottom') {
            if (end.direction === 'top') {
                change *= -1;
            }
            line.end.y2 = end.y + change * PATH_END_HEIGHT;
            line.end.y1 += change * PATH_LINE_HEIGHT;
            path.L.x = end.x;
            path.L.y = line.end.y2;
        }
        return {
            line,
            path,
        };
    }
    function getLine(start, end) {
        const line = {
            start: {
                base: {
                    x1: start.x,
                    y1: start.y,
                    x2: start.x,
                    y2: start.y,
                },
                base2: {
                    x1: start.x,
                    y1: start.y,
                    x2: start.x,
                    y2: start.y,
                },
                center: {
                    x1: start.x,
                    y1: start.y,
                    x2: start.x,
                    y2: start.y,
                },
                center2: {
                    x1: start.x,
                    y1: start.y,
                    x2: start.x,
                    y2: start.y,
                },
            },
            end: {
                base: {
                    x1: end.x,
                    y1: end.y,
                    x2: end.x,
                    y2: end.y,
                },
                base2: {
                    x1: end.x,
                    y1: end.y,
                    x2: end.x,
                    y2: end.y,
                },
                left: {
                    x1: end.x,
                    y1: end.y,
                    x2: end.x,
                    y2: end.y,
                },
                center: {
                    x1: end.x,
                    y1: end.y,
                    x2: end.x,
                    y2: end.y,
                },
                center2: {
                    x1: end.x,
                    y1: end.y,
                    x2: end.x,
                    y2: end.y,
                },
                right: {
                    x1: end.x,
                    y1: end.y,
                    x2: end.x,
                    y2: end.y,
                },
            },
        };
        const circle = {
            cx: end.x,
            cy: end.y,
        };
        const startCircle = {
            cx: start.x,
            cy: start.y,
        };
        let change = 1;
        if (start.direction === 'left' || start.direction === 'right') {
            if (start.direction === 'left') {
                change *= -1;
            }
            line.start.base.x1 = line.start.base.x2 += change * LINE_HEIGHT;
            line.start.base2.x1 = line.start.base2.x2 +=
                change * (LINE_SIZE + LINE_HEIGHT);
            line.start.center.x1 = line.start.base.x1;
            line.start.base.y1 -= LINE_SIZE;
            line.start.base.y2 += LINE_SIZE;
            line.start.base2.y1 -= LINE_SIZE;
            line.start.base2.y2 += LINE_SIZE;
            line.start.center2.x1 += change * (LINE_HEIGHT + LINE_HEIGHT + 3);
            startCircle.cx += change * CIRCLE_HEIGHT;
        }
        else if (start.direction === 'top' || start.direction === 'bottom') {
            if (start.direction === 'top') {
                change *= -1;
            }
            line.start.base.y1 = line.start.base.y2 += change * LINE_HEIGHT;
            line.start.base2.y1 = line.start.base2.y2 +=
                change * (LINE_SIZE + LINE_HEIGHT);
            line.start.center.y1 = line.start.base.y1;
            line.start.base.x1 -= LINE_SIZE;
            line.start.base.x2 += LINE_SIZE;
            line.start.base2.x1 -= LINE_SIZE;
            line.start.base2.x2 += LINE_SIZE;
            line.start.center2.y1 += change * (LINE_HEIGHT + LINE_HEIGHT + 3);
            startCircle.cy += change * CIRCLE_HEIGHT;
        }
        change = 1;
        if (end.direction === 'left' || end.direction === 'right') {
            if (end.direction === 'left') {
                change *= -1;
            }
            line.end.base.x1 = line.end.base.x2 += change * LINE_HEIGHT;
            line.end.base2.x1 = line.end.base2.x2 += change * (LINE_SIZE + LINE_HEIGHT);
            line.end.center.x1 =
                line.end.left.x1 =
                    line.end.right.x1 =
                        line.end.base.x1;
            line.end.base.y1 -= LINE_SIZE;
            line.end.base.y2 += LINE_SIZE;
            line.end.base2.y1 -= LINE_SIZE;
            line.end.base2.y2 += LINE_SIZE;
            line.end.left.y2 += LINE_SIZE;
            line.end.right.y2 -= LINE_SIZE;
            line.end.center2.x1 += change * (LINE_HEIGHT + LINE_HEIGHT + 3);
            circle.cx += change * CIRCLE_HEIGHT;
        }
        else if (end.direction === 'top' || end.direction === 'bottom') {
            if (end.direction === 'top') {
                change *= -1;
            }
            line.end.base.y1 = line.end.base.y2 += change * LINE_HEIGHT;
            line.end.base2.y1 = line.end.base2.y2 += change * (LINE_SIZE + LINE_HEIGHT);
            line.end.center.y1 =
                line.end.left.y1 =
                    line.end.right.y1 =
                        line.end.base.y1;
            line.end.base.x1 -= LINE_SIZE;
            line.end.base.x2 += LINE_SIZE;
            line.end.base2.x1 -= LINE_SIZE;
            line.end.base2.x2 += LINE_SIZE;
            line.end.left.x2 += LINE_SIZE;
            line.end.right.x2 -= LINE_SIZE;
            line.end.center2.y1 += change * (LINE_HEIGHT + LINE_HEIGHT + 3);
            circle.cy += change * CIRCLE_HEIGHT;
        }
        return {
            line,
            circle,
            startCircle,
        };
    }
    function getRelationshipPath(relationship) {
        return {
            path: getPath(relationship.start, relationship.end),
            line: getLine(relationship.start, relationship.end),
        };
    }

    function orderByNameASC(tables) {
        return [...tables].sort((a, b) => {
            const nameA = a.name.toLowerCase();
            const nameB = b.name.toLowerCase();
            if (nameA < nameB) {
                return -1;
            }
            else if (nameA > nameB) {
                return 1;
            }
            return 0;
        });
    }
    function recalculatingTableWidth(tables, helper) {
        tables.forEach(table => {
            table.ui.widthName = widthBalanceRange(helper.getTableHeadTextWidth(table.name));
            table.ui.widthComment = commentWidthBalanceRange(helper.getTableHeadTextWidth(table.comment));
            table.columns.forEach(column => {
                column.ui.widthName = widthBalanceRange(helper.getTextWidth(column.name));
                column.ui.widthDataType = widthBalanceRange(helper.getTextWidth(column.dataType));
                column.ui.widthDefault = widthBalanceRange(helper.getTextWidth(column.default));
                column.ui.widthComment = commentWidthBalanceRange(helper.getTextWidth(column.comment));
            });
        });
    }

    const hookKeys$2 = ['editor.loadJson', 'editor.initLoadJson'];
    const useRecalculatingTableWidth = (hook$, { tableState: { tables } }, helper) => hook$
        .pipe(commandsFilter(hookKeys$2))
        .subscribe(() => recalculatingTableWidth(tables, helper));

    const hookKeys$1 = [
        'canvas.changeShow',
        'relationship.add',
        'memo.move',
        'table.move',
        'table.changeName',
        'table.changeComment',
        'table.sort',
        'column.add',
        'column.addCustom',
        'column.remove',
        'column.changeName',
        'column.changeComment',
        'column.changeDataType',
        'column.changeDefault',
        'column.move',
        'editor.loadJson',
        'editor.initLoadJson',
    ];
    const useRelationshipSort = (hook$, { tableState: { tables }, relationshipState: { relationships } }, helper) => hook$
        .pipe(commandsFilter(hookKeys$1))
        .subscribe(() => relationshipSort(tables, relationships));

    const hookKeys = ['editor.loadJson', 'editor.initLoadJson'];
    const useResetZIndex = (hook$, { tableState: { tables }, memoState: { memos } }, helper) => hook$.pipe(commandsFilter(hookKeys)).subscribe(() => {
        const uiList = [
            ...tables.map(table => table.ui),
            ...memos.map(memo => memo.ui),
        ];
        uiList.sort((a, b) => a.zIndex - b.zIndex);
        uiList.forEach((ui, index) => (ui.zIndex = index + 1));
    });

    const useHooks = (hook$, state, helper) => [
        useRecalculatingTableWidth(hook$, state, helper),
        useRelationshipSort(hook$, state),
        useResetZIndex(hook$, state),
    ];

    const createState = () => {
        return observable$1({
            canvasState: createCanvasState(),
            tableState: createTableState(),
            relationshipState: createRelationshipState(),
            memoState: createMemoState(),
            editorState: createEditorState(),
            controlState: createControlState()
        });
    };
    function createStore(helper) {
        const subscriptionHelper = createSubscriptionHelper();
        const state = createState();
        const { dispatch$, history$, change$, hook$ } = createStream();
        const dispatchSync = (...commands) => dispatch$.next([...flat(commands)]);
        const dispatch = (...commands) => queueMicrotask(() => dispatchSync(...commands));
        const history = createHistory(() => dispatch(hasUndoRedo(history.hasUndo(), history.hasRedo())));
        const undo = () => {
            if (!history.hasUndo() || state.editorState.readonly)
                return;
            dispatch(focusTableEnd());
            history.undo();
        };
        const redo = () => {
            if (!history.hasRedo() || state.editorState.readonly)
                return;
            dispatch(focusTableEnd());
            history.redo();
        };
        const destroy = () => {
            subscriptionHelper.destroy();
            history.clear();
        };
        const store = Object.assign(Object.assign({}, state), { dispatch,
            dispatchSync,
            undo,
            redo,
            history$,
            change$,
            destroy });
        const command = executeCommand$1(state);
        const historyCommand = executeHistoryCommand(store, history);
        subscriptionHelper.push(history$.pipe(notEmptyCommands).subscribe(command), dispatch$
            .pipe(readonlyCommands(state), commandsFilter(historyCommandTypes), groupByStreamCommands)
            .subscribe(historyCommand), dispatch$.pipe(readonlyCommands(state)).subscribe(command), ...useHooks(hook$, state, helper));
        return store;
    }

    const userAgent = window.navigator.userAgent.toLowerCase();
    const isRatio = ['macintosh', 'firefox'].every(target => userAgent.indexOf(target) === -1);
    function createGlobalEventObservable() {
        const mousedown$ = fromEvent(window, 'mousedown');
        const mousemove$ = fromEvent(window, 'mousemove');
        const mouseup$ = fromEvent(window, 'mouseup');
        const touchstart$ = fromEvent(window, 'touchstart');
        const touchmove$ = fromEvent(window, 'touchmove');
        const touchend$ = fromEvent(window, 'touchend');
        let touchX = 0;
        let touchY = 0;
        const subscription = touchstart$.subscribe(event => {
            touchX = event.touches[0].clientX;
            touchY = event.touches[0].clientY;
        });
        const move$ = merge(mousemove$.pipe(map(event => {
            let movementX = event.movementX;
            let movementY = event.movementY;
            if (isRatio) {
                movementX = event.movementX / window.devicePixelRatio;
                movementY = event.movementY / window.devicePixelRatio;
            }
            return {
                event,
                movementX,
                movementY,
                x: event.clientX,
                y: event.clientY,
            };
        })), touchmove$.pipe(filter(event => event.touches.length === 1), map(event => {
            const movementX = event.touches[0].clientX - touchX;
            const movementY = event.touches[0].clientY - touchY;
            touchX = event.touches[0].clientX;
            touchY = event.touches[0].clientY;
            return {
                event,
                movementX,
                movementY,
                x: event.touches[0].clientX,
                y: event.touches[0].clientY,
            };
        })));
        const moveStart$ = merge(mousedown$, touchstart$);
        const moveEnd$ = merge(mouseup$, touchend$);
        const drag$ = move$.pipe(takeUntil(moveEnd$));
        return {
            mousedown$,
            mouseup$,
            mousemove$,
            touchstart$,
            touchend$,
            touchmove$,
            moveStart$,
            moveEnd$,
            move$,
            drag$,
            destroy() {
                subscription.unsubscribe();
            },
        };
    }

    function createEventBus() {
        const bus = document.createElement('div');
        const on = (eventName) => new Observable(subscriber => {
            const handler = (event) => subscriber.next(event.detail);
            bus.addEventListener(eventName, handler);
            return () => bus.removeEventListener(eventName, handler);
        });
        const emit = (eventName, detail) => {
            bus.dispatchEvent(new CustomEvent(eventName, {
                detail,
            }));
        };
        return {
            on,
            emit,
        };
    }
    var BalanceRange;
    (function (BalanceRange) {
        BalanceRange["move"] = "BalanceRange.move";
    })(BalanceRange || (BalanceRange = {}));
    var Drawer$1;
    (function (Drawer) {
        Drawer["openTableProperties"] = "Drawer.openTableProperties";
        Drawer["close"] = "Drawer.close";
    })(Drawer$1 || (Drawer$1 = {}));
    var Contextmenu;
    (function (Contextmenu) {
        Contextmenu["close"] = "Contextmenu.close";
    })(Contextmenu || (Contextmenu = {}));
    const Bus = {
        BalanceRange,
        Drawer: Drawer$1,
        Contextmenu,
    };

    const createKeymap = () => ({
        edit: [
            {
                key: 'Enter',
            },
        ],
        stop: [
            {
                key: 'Escape',
            },
        ],
        find: [
            {
                ctrlKey: true,
                key: 'F',
                preventDefault: true,
                stopPropagation: true,
            },
            {
                metaKey: true,
                key: 'F',
                preventDefault: true,
                stopPropagation: true,
            },
        ],
        undo: [
            {
                ctrlKey: true,
                key: 'Z',
                preventDefault: true,
            },
            {
                metaKey: true,
                key: 'Z',
                preventDefault: true,
            },
        ],
        redo: [
            {
                ctrlKey: true,
                shiftKey: true,
                key: 'Z',
                preventDefault: true,
            },
            {
                metaKey: true,
                shiftKey: true,
                key: 'Z',
                preventDefault: true,
            },
        ],
        addPackage: [
            {
                altKey: true,
                key: 'P',
            },
        ],
        addTable: [
            {
                altKey: true,
                key: 'N',
            },
        ],
        addColumn: [
            {
                altKey: true,
                key: 'Enter',
            },
        ],
        addMemo: [
            {
                altKey: true,
                key: 'M',
            },
        ],
        removePackage: [
            {
                ctrlKey: false,
                key: 'Delete',
            },
            {
                ctrlKey: false,
                key: 'Backspace',
            },
            {
                metaKey: false,
                key: 'Delete',
            },
            {
                metaKey: false,
                key: 'Backspace',
            },
        ],
        removeTable: [
            {
                ctrlKey: true,
                key: 'Delete',
            },
            {
                ctrlKey: true,
                key: 'Backspace',
            },
            {
                metaKey: true,
                key: 'Delete',
            },
            {
                metaKey: true,
                key: 'Backspace',
            },
        ],
        removeColumn: [
            {
                altKey: true,
                key: 'Delete',
            },
            {
                altKey: true,
                key: 'Backspace',
            },
        ],
        primaryKey: [
            {
                altKey: true,
                key: 'K',
            },
        ],
        selectAllTable: [
            {
                ctrlKey: true,
                altKey: true,
                key: 'A',
            },
            {
                metaKey: true,
                altKey: true,
                key: 'A',
            },
        ],
        selectAllColumn: [
            {
                altKey: true,
                key: 'A',
            },
        ],
        copyColumn: [
            {
                ctrlKey: true,
                key: 'C',
            },
            {
                metaKey: true,
                key: 'C',
            },
        ],
        pasteColumn: [
            {
                ctrlKey: true,
                key: 'V',
            },
            {
                metaKey: true,
                key: 'V',
            },
        ],
        relationshipZeroOne: [
            {
                ctrlKey: true,
                altKey: true,
                key: '1',
            },
            {
                metaKey: true,
                altKey: true,
                key: '1',
            },
        ],
        relationshipZeroN: [
            {
                ctrlKey: true,
                altKey: true,
                key: '2',
            },
            {
                metaKey: true,
                altKey: true,
                key: '2',
            },
        ],
        relationshipOneOnly: [
            {
                ctrlKey: true,
                altKey: true,
                key: '3',
            },
            {
                metaKey: true,
                altKey: true,
                key: '3',
            },
        ],
        relationshipOneN: [
            {
                ctrlKey: true,
                altKey: true,
                key: '4',
            },
            {
                metaKey: true,
                altKey: true,
                key: '4',
            },
        ],
        tableProperties: [
            {
                altKey: true,
                key: 'Space',
            },
            {
                ctrlKey: true,
                key: 'Space',
            },
        ],
        // zoomIn: [
        //   {
        //     ctrlKey: true,
        //     key: 'Equal',
        //     preventDefault: true,
        //     stopPropagation: true,
        //   },
        //   {
        //     metaKey: true,
        //     key: 'Equal',
        //     preventDefault: true,
        //     stopPropagation: true,
        //   },
        // ],
        // zoomOut: [
        //   {
        //     ctrlKey: true,
        //     key: 'Minus',
        //     preventDefault: true,
        //     stopPropagation: true,
        //   },
        //   {
        //     metaKey: true,
        //     key: 'Minus',
        //     preventDefault: true,
        //     stopPropagation: true,
        //   },
        // ],
    });
    const multipleKeys = [
        'altKey',
        'metaKey',
        'ctrlKey',
        'shiftKey',
    ];
    const keyEquals = (event, key) => event.key.toUpperCase() === key.toUpperCase() ||
        event.code.toUpperCase() === key.toUpperCase() ||
        event.code.toUpperCase() === `Key${key}`.toUpperCase() ||
        event.code.toUpperCase() === `Digit${key}`.toUpperCase();
    const getKeymap = (event, keymapOptions) => keymapOptions.find(keymapOption => {
        const isMultipleKey = multipleKeys.every(multipleKey => !!keymapOption[multipleKey] === event[multipleKey]);
        return keymapOption.key
            ? isMultipleKey && keyEquals(event, keymapOption.key)
            : isMultipleKey;
    });
    function keymapMatchAndStop(event, keymapOptions) {
        const current = getKeymap(event, keymapOptions);
        (current === null || current === void 0 ? void 0 : current.preventDefault) && event.preventDefault();
        (current === null || current === void 0 ? void 0 : current.stopPropagation) && event.stopPropagation();
        return !!current;
    }
    function keymapOptionToString(keymapOption) {
        if (!keymapOption)
            return '';
        const result = [];
        if (keymapOption.metaKey) {
            result.push('Cmd');
        }
        if (keymapOption.ctrlKey) {
            result.push('Ctrl');
        }
        if (keymapOption.altKey) {
            result.push('Alt');
        }
        if (keymapOption.shiftKey) {
            result.push('Shift');
        }
        if (keymapOption.key) {
            result.push(keymapOption.key);
        }
        return result.join(' + ');
    }
    const keymapOptionsToString = (keymapOptions) => keymapOptions.map(option => keymapOptionToString(option)).join(', ');
    const loadKeymap = (keymap, newKeymap) => Object.keys(keymap)
        .filter(key => isArray$1(newKeymap[key]))
        .forEach(key => (keymap[key] = newKeymap[key]));

    function createdERDEditorContext() {
        const helper = createHelper();
        return {
            theme: observable$1(createTheme()),
            keymap: observable$1(createKeymap()),
            globalEvent: createGlobalEventObservable(),
            eventBus: createEventBus(),
            store: createStore(helper),
            command: createCommand(),
            helper,
            snapshots: [],
        };
    }
    const omitERDEditorContext = pipe(omit$1(['globalEvent', 'eventBus']), dissocPath$1(['store', 'history$']), dissocPath$1(['store', 'change$']), dissocPath$1(['store', 'destroy']), dissocPath$1(['helper', 'keydown$']), dissocPath$1(['helper', 'setGhostText']), dissocPath$1(['helper', 'setGhostInput']), dissocPath$1(['helper', 'focus']), dissocPath$1(['helper', 'blur']), dissocPath$1(['helper', 'destroy']));

    defineComponent('kderd-panel-view', {
        observedProps: [
            'panel',
            {
                name: 'width',
                default: 0,
            },
            {
                name: 'height',
                default: 0,
            },
        ],
        styleMap: {
            height: '100%',
            display: 'flex',
            position: 'relative',
        },
        render(props, ctx) {
            const contextRef = useContext(ctx);
            const { unmountedGroup } = useUnmounted();
            let panelInstance = null;
            const setHeight = () => {
                ctx.style.height = `${props.height}px`;
            };
            beforeMount(() => {
                setHeight();
                const api = omitERDEditorContext(contextRef.value);
                panelInstance = new props.panel.type(props, api);
                panelInstance.beforeMount && panelInstance.beforeMount();
                unmountedGroup.push(watch(props, propName => {
                    if (propName !== 'height')
                        return;
                    setHeight();
                }));
            });
            mounted(() => (panelInstance === null || panelInstance === void 0 ? void 0 : panelInstance.mounted) && panelInstance.mounted());
            unmounted(() => (panelInstance === null || panelInstance === void 0 ? void 0 : panelInstance.unmounted) && panelInstance.unmounted());
            beforeFirstUpdate(() => (panelInstance === null || panelInstance === void 0 ? void 0 : panelInstance.beforeFirstUpdate) && panelInstance.beforeFirstUpdate());
            firstUpdated(() => (panelInstance === null || panelInstance === void 0 ? void 0 : panelInstance.firstUpdated) && panelInstance.firstUpdated());
            beforeUpdate(() => (panelInstance === null || panelInstance === void 0 ? void 0 : panelInstance.beforeUpdate) && panelInstance.beforeUpdate());
            updated(() => (panelInstance === null || panelInstance === void 0 ? void 0 : panelInstance.updated) && panelInstance.updated());
            return () => html `${panelInstance === null || panelInstance === void 0 ? void 0 : panelInstance.render()}`;
        },
    });

    const ERD$1 = {
        title: '',
        canvasType: 'ERD',
        icon: {
            prefix: 'fas',
            name: 'project-diagram',
            size: 0,
        },
    };
    const panelToMenu = (panel) => {
        var _a;
        return ({
            title: (_a = panel.name) !== null && _a !== void 0 ? _a : '',
            canvasType: panel.key,
            icon: Object.assign({
                size: 18,
            }, panel.icon),
        });
    };
    function useMenubarPanels(ctx) {
        const contextRef = useContext(ctx);
        const onChangeCanvasType = (canvasType) => {
            const { store } = contextRef.value;
            if (canvasType === store.canvasState.canvasType)
                return;
            store.dispatch(changeCanvasType(canvasType));
        };
        const getMenus = () => {
            const { editorState } = contextRef.value.store;
            const menus = [ERD$1];
            [...panels, ...editorState.panels].forEach(panel => menus.push(panelToMenu(panel)));
            return menus;
        };
        return {
            panelMenusTpl: () => {
                const { canvasState } = contextRef.value.store;
                return getMenus().map(menu => html `
          <div
            class=${classMap({
                'kderd-menubar-menu': true,
                active: canvasState.canvasType === menu.canvasType,
            })}
            data-tippy-content=${menu.title}
            @click=${() => onChangeCanvasType(menu.canvasType)}
          >
            <kderd-icon
              .prefix=${menu.icon.prefix}
              .name=${menu.icon.name}
              .size=${menu.icon.size}
            ></kderd-icon>
          </div>
        `);
            },
        };
    }

    const MenubarStyle = css `
  .kderd-menubar {
    height: ${SIZE_MENUBAR_HEIGHT}px;
    display: flex;
    align-items: center;
    overflow: hidden;
    background-color: var(--kderd-color-menubar);
    border-bottom: 1px solid #D9D9D9;
    box-sizing: border-box;
  }

  .kderd-editor-status {
    width: 10px;
    height: 10px;
    margin-left: 15px;
    border-radius: 50%;
    transition: box-shadow 0.4s ease-in-out, background-color 0.4s ease-in-out;
  }

  .kderd-editor-status.focus {
    background-color: var(--kderd-color-focus);
    box-shadow: 0 0 5px var(--kderd-color-focus);
  }

  .kderd-editor-status.edit {
    background-color: var(--kderd-color-edit);
    box-shadow: 0 0 5px var(--kderd-color-edit);
  }

  .kderd-menubar-input {
    margin-left: 15px;
    outline: none;
    border: none;
    opacity: 0.9;
    font-size: ${SIZE_FONT}px;
    font-family: var(--kderd-font-family);
    color: var(--kderd-color-font-active);
    background-color: var(--kderd-color-menubar);
  }

  .kderd-menubar-menu {
    cursor: pointer;
    fill: var(--kderd-color-font);
    margin-left: 10px;
    display: flex;
    align-items: center;
  }

  .kderd-menubar-menu.active,
  .kderd-menubar-menu:hover {
    fill: var(--kderd-color-font-active);
  }

  .kderd-menubar-menu.undo-redo {
    cursor: not-allowed;
    fill: var(--kderd-color-font);
  }

  .kderd-menubar-menu.undo-redo.active {
    cursor: pointer;
    fill: var(--kderd-color-font-active);
  }

  .kderd-menubar-menu-vertical {
    margin-left: 10px;
  }
`;

    const Menubar = (props, ctx) => {
        const contextRef = useContext(ctx);
        useMenubarPanels(ctx);
        const { resetTooltip } = useTooltip(['.kderd-menubar-input', '.kderd-menubar-menu', '.kderd-editor-status'], ctx);
        const { unmountedGroup } = useUnmounted();
        const onResizeCanvas = (event) => {
            const input = event.target;
            const size = canvasSizeRange(input.value);
            const { store } = contextRef.value;
            input.value = size.toString();
            store.dispatch(resizeCanvas(size, size));
        };
        const onZoomLevel = (event) => {
            const input = event.target;
            const zoomLevel = zoomLevelRange(Number(input.value.replace(/[^0-9]/g, '')) / 100);
            const { store } = contextRef.value;
            input.value = zoomDisplayFormat(zoomLevel);
            store.dispatch(zoomCanvas(zoomLevel));
        };
        const onFind = () => {
            const { store, eventBus } = contextRef.value;
            const { findActive } = store.editorState;
            if (findActive) {
                store.dispatch(findActiveEnd());
            }
            else {
                store.dispatch(findActive$());
            }
            eventBus.emit(Bus.Drawer.close);
        };
        const onUndo = () => {
            const { store } = contextRef.value;
            store.undo();
        };
        const onRedo = () => {
            const { store } = contextRef.value;
            store.redo();
        };
        const onOpenSetting = () => ctx.dispatchEvent(new CustomEvent('open-setting'));
        beforeMount(() => {
            const { editorState, canvasState } = contextRef.value.store;
            unmountedGroup.push(watch(editorState.panels, () => resetTooltip()), watch(panels, () => resetTooltip()), watch(canvasState, propName => {
                if (propName !== 'canvasType')
                    return;
                resetTooltip();
            }));
        });
        return () => {
            const { store, keymap } = contextRef.value;
            const { canvasState: { databaseName, width, zoomLevel, canvasType }, editorState: { hasUndo, hasRedo, filterState }, controlState: { allowEdit }, } = store;
            return html `
      <div class="kderd-menubar">
        ${allowEdit ?
            html `
            <div
              class=${classMap({
                'kderd-editor-status': true,
                focus: props.focusState && !allowEdit,
                edit: props.focusState && allowEdit,
            })}
              data-tippy-content=""
            ></div>
            <input
              class="kderd-menubar-input"
              style="width: 45px;"
              type="text"
              data-tippy-content=""
              spellcheck="false"
              placeholder=""
              ?disabled=${false}
              .value=${width.toString()}
              @input=${onNumberOnly}
              @change=${onResizeCanvas}
            />
          ` : null}

        <input
          class="kderd-menubar-input"
          style="width: 45px;"
          type="text"
          data-tippy-content=""
          spellcheck="false"
          placeholder=""
          .value=${zoomDisplayFormat(zoomLevel)}
          @input=${onNumberOnly}
          @change=${onZoomLevel}
        />

        <!-- <div
          class="kderd-menubar-menu"
          data-tippy-content=""
          @click=${onOpenSetting}
        > 
          <kderd-icon name="cog" size="16"></kderd-icon>-->
        <!-- <div class="kderd-menubar-menu-vertical"></div> -->
        <div
          class="kderd-menubar-menu"
          data-tippy-content=" [${keymapOptionsToString(keymap.find)}]"
          @click=${onFind}
        >
          <kderd-icon name="search" size="16"></kderd-icon>
        </div>

        ${allowEdit ?
            html `
            <div
              class=${classMap({
                'kderd-menubar-menu': true,
                'undo-redo': true,
                active: hasUndo && allowEdit,
            })}
              data-tippy-content=${` [${keymapOptionsToString(keymap.undo)}]`}
              @click=${onUndo}
            >
              <kderd-icon name="undo-alt" size="16"></kderd-icon>
            </div>
            <div
              class=${classMap({
                'kderd-menubar-menu': true,
                'undo-redo': true,
                active: hasRedo && allowEdit,
            })}
              data-tippy-content=${` [${keymapOptionsToString(keymap.redo)}]`}
              @click=${onRedo}
            >
              <kderd-icon name="redo-alt" size="16"></kderd-icon>
            </div>
          ` : null}
      </div>
    `;
        };
    };
    defineComponent('kderd-menubar', {
        observedProps: [
            {
                name: 'focusState',
                type: Boolean,
                default: false,
            },
        ],
        style: MenubarStyle,
        render: Menubar,
    });

    function useResizeMemo(props, ctx) {
        const contextRef = useContext(ctx);
        let clientX = 0;
        let clientY = 0;
        const resizeWidth = ({ movementX, x }, direction) => {
            const ui = Object.assign({ change: false }, props.memo.ui);
            const mouseDirection = movementX < 0 ? 'left' : 'right';
            const width = direction === 'left' ? ui.width - movementX : ui.width + movementX;
            switch (mouseDirection) {
                case 'left':
                    if (SIZE_MEMO_WIDTH < width && x < clientX) {
                        direction === 'left' && (ui.left += movementX);
                        clientX += movementX;
                        ui.width = width;
                        ui.change = true;
                    }
                    break;
                case 'right':
                    if (SIZE_MEMO_WIDTH < width && x > clientX) {
                        direction === 'left' && (ui.left += movementX);
                        clientX += movementX;
                        ui.width = width;
                        ui.change = true;
                    }
                    break;
            }
            return ui;
        };
        const resizeHeight = ({ movementY, y }, direction) => {
            const ui = Object.assign({ change: false }, props.memo.ui);
            const mouseDirection = movementY < 0 ? 'top' : 'bottom';
            const height = direction === 'top' ? ui.height - movementY : ui.height + movementY;
            switch (mouseDirection) {
                case 'top':
                    if (SIZE_MEMO_HEIGHT < height && y < clientY) {
                        direction === 'top' && (ui.top += movementY);
                        clientY += movementY;
                        ui.height = height;
                        ui.change = true;
                    }
                    break;
                case 'bottom':
                    if (SIZE_MEMO_HEIGHT < height && y > clientY) {
                        direction === 'top' && (ui.top += movementY);
                        clientY += movementY;
                        ui.height = height;
                        ui.change = true;
                    }
                    break;
            }
            return ui;
        };
        const onMousemoveSash = (move, position) => {
            move.event.preventDefault();
            const { store } = contextRef.value;
            let verticalUI = null;
            let horizontalUI = null;
            switch (position) {
                case 'left':
                case 'right':
                    verticalUI = resizeWidth(move, position);
                    break;
                case 'top':
                case 'bottom':
                    horizontalUI = resizeHeight(move, position);
                    break;
                case 'lt':
                    verticalUI = resizeWidth(move, 'left');
                    horizontalUI = resizeHeight(move, 'top');
                    break;
                case 'rt':
                    verticalUI = resizeWidth(move, 'right');
                    horizontalUI = resizeHeight(move, 'top');
                    break;
                case 'lb':
                    verticalUI = resizeWidth(move, 'left');
                    horizontalUI = resizeHeight(move, 'bottom');
                    break;
                case 'rb':
                    verticalUI = resizeWidth(move, 'right');
                    horizontalUI = resizeHeight(move, 'bottom');
                    break;
            }
            if ((verticalUI === null || verticalUI === void 0 ? void 0 : verticalUI.change) && (horizontalUI === null || horizontalUI === void 0 ? void 0 : horizontalUI.change)) {
                store.dispatch(resizeMemo(props.memo.id, horizontalUI.top, verticalUI.left, verticalUI.width, horizontalUI.height));
            }
            else if (verticalUI === null || verticalUI === void 0 ? void 0 : verticalUI.change) {
                store.dispatch(resizeMemo(props.memo.id, verticalUI.top, verticalUI.left, verticalUI.width, verticalUI.height));
            }
            else if (horizontalUI === null || horizontalUI === void 0 ? void 0 : horizontalUI.change) {
                store.dispatch(resizeMemo(props.memo.id, horizontalUI.top, horizontalUI.left, horizontalUI.width, horizontalUI.height));
            }
        };
        const onMousedownSash = (event, position) => {
            const { drag$ } = contextRef.value.globalEvent;
            clientX = event.clientX;
            clientY = event.clientY;
            drag$.subscribe(move => onMousemoveSash(move, position));
        };
        return {
            onMousedownSash,
        };
    }

    const createSash = (top, left) => [
        {
            vertical: true,
            position: 'left',
        },
        {
            vertical: true,
            position: 'right',
            left,
        },
        {
            horizontal: true,
            position: 'top',
        },
        {
            horizontal: true,
            position: 'bottom',
            top,
        },
        {
            edge: true,
            position: 'lt',
            cursor: 'nwse-resize',
        },
        {
            edge: true,
            position: 'rt',
            cursor: 'nesw-resize',
            left,
        },
        {
            edge: true,
            position: 'lb',
            cursor: 'nesw-resize',
            top,
        },
        {
            edge: true,
            position: 'rb',
            cursor: 'nwse-resize',
            top,
            left,
        },
    ];
    const sashTpl = (top, left, onMousedownSash) => createSash(top, left).map(sash => {
        var _a, _b;
        return html `
        <kderd-sash
          ?vertical=${sash.vertical}
          ?horizontal=${sash.horizontal}
          ?edge=${sash.edge}
          .cursor=${sash.cursor}
          .top=${(_a = sash.top) !== null && _a !== void 0 ? _a : 0}
          .left=${(_b = sash.left) !== null && _b !== void 0 ? _b : 0}
          @mousedown=${(event) => onMousedownSash(event, sash.position)}
        ></kderd-sash>
      `;
    });

    const MEMO_PADDING$1 = SIZE_MEMO_PADDING * 2;
    const MEMO_HEADER$1 = 6 + MEMO_PADDING$1;
    const ANIMATION_TIME$4 = 300;
    const Memo = (props, ctx) => {
        const contextRef = useContext(ctx);
        const { onMousedownSash } = useResizeMemo(props, ctx);
        const { unmountedGroup } = useUnmounted();
        const textareaRef = query('.kderd-memo-textarea');
        useTooltip(['.kderd-button'], ctx);
        let leftTween = null;
        let topTween = null;
        const onMove = ({ event, movementX, movementY }) => {
            event.type === 'mousemove' && event.preventDefault();
            const { store } = contextRef.value;
            store.dispatch(moveMemo(store, event.ctrlKey || event.metaKey, movementX, movementY, props.memo.id));
        };
        const onMoveStart = (event) => {
            const el = event.target;
            const { store, globalEvent, eventBus } = contextRef.value;
            const { drag$ } = globalEvent;
            if (!el.closest('.kderd-button') &&
                !el.closest('kderd-sash') &&
                !el.closest('.kderd-memo-textarea')) {
                leftTween === null || leftTween === void 0 ? void 0 : leftTween.stop();
                topTween === null || topTween === void 0 ? void 0 : topTween.stop();
                drag$.subscribe({
                    next: onMove,
                    complete: () => eventBus.emit(Bus.BalanceRange.move),
                });
            }
            store.dispatch(selectMemo$(store, event.ctrlKey || event.metaKey, props.memo.id));
        };
        const onRemoveMemo = () => {
            const { store } = contextRef.value;
            store.dispatch(removeMemo(store, props.memo.id));
        };
        const onInput = (event) => {
            const { store } = contextRef.value;
            const textarea = event.target;
            store.dispatch(changeMemoValue(props.memo.id, textarea.value));
        };
        const onBlur = () => ctx.dispatchEvent(new CustomEvent('kderd-input-blur', {
            composed: true,
            bubbles: true,
        }));
        const moveBalance = () => {
            const { canvasState: { width, height }, } = contextRef.value.store;
            const minWidth = width - (props.memo.ui.width + MEMO_PADDING$1);
            const minHeight = height - (props.memo.ui.height + MEMO_PADDING$1 + MEMO_HEADER$1);
            const x = props.memo.ui.left > minWidth ? minWidth : 0;
            const y = props.memo.ui.top > minHeight ? minHeight : 0;
            if (props.memo.ui.left < 0 || props.memo.ui.left > minWidth) {
                leftTween = new Tween(props.memo.ui)
                    .to({ left: x }, ANIMATION_TIME$4)
                    .easing(Easing.Quadratic.Out)
                    .onComplete(() => (leftTween = null))
                    .start();
            }
            if (props.memo.ui.top < 0 || props.memo.ui.top > minHeight) {
                topTween = new Tween(props.memo.ui)
                    .to({ top: y }, ANIMATION_TIME$4)
                    .easing(Easing.Quadratic.Out)
                    .onComplete(() => (topTween = null))
                    .start();
            }
        };
        beforeMount(() => {
            const { eventBus } = contextRef.value;
            unmountedGroup.push(eventBus.on(Bus.BalanceRange.move).subscribe(moveBalance));
        });
        mounted(() => {
            const textarea = textareaRef.value;
            if (!textarea || !props.memo.ui.active)
                return;
            textarea.focus();
        });
        return () => {
            const { keymap, store: { editorState: { readonly }, }, } = contextRef.value;
            const { memo } = props;
            const width = memo.ui.width + MEMO_PADDING$1;
            const height = memo.ui.height + MEMO_PADDING$1 + MEMO_HEADER$1;
            return html `
      <div
        class=${classMap({
            'kderd-memo': true,
            active: memo.ui.active,
        })}
        style=${styleMap({
            top: `${memo.ui.top}px`,
            left: `${memo.ui.left}px`,
            zIndex: `${memo.ui.zIndex}`,
            width: `${width}px`,
            height: `${height}px`,
        })}
        @mousedown=${onMoveStart}
        @touchstart=${onMoveStart}
      >
        <div class="kderd-memo-header">
          <kderd-icon
            class="kderd-button"
            name="times"
            size="12"
            data-tippy-content=${keymapOptionsToString(keymap.removeTable)}
            @click=${onRemoveMemo}
          ></kderd-icon>
        </div>
        <textarea
          class="kderd-memo-textarea kderd-scrollbar"
          style=${styleMap({
            width: `${memo.ui.width}px`,
            height: `${memo.ui.height}px`,
        })}
          spellcheck="false"
          ?disabled=${readonly}
          .value=${memo.value}
          @input=${onInput}
          @wheel=${onStopPropagation}
          @blur=${onBlur}
        ></textarea>
        ${sashTpl(height, width, onMousedownSash)}
      </div>
    `;
        };
    };
    defineComponent('kderd-memo', {
        shadow: false,
        observedProps: ['memo'],
        render: Memo,
    });

    const Input = (props, ctx) => {
        const { unmountedGroup } = useUnmounted();
        const inputRef = query('input');
        const getClassMap = () => {
            var _a;
            return ({
                'kderd-input': true,
                placeholder: ((_a = props.value) === null || _a === void 0 ? void 0 : _a.trim()) === '' && !props.edit,
                focus: props.focusState && !props.edit,
                edit: props.edit,
                select: props.select,
                active: props.active,
            });
        };
        const getPlaceholderValue = () => { var _a; return ((_a = props.value) === null || _a === void 0 ? void 0 : _a.trim()) === '' ? props.placeholder : props.value; };
        const onBlur = () => ctx.dispatchEvent(new CustomEvent('kderd-input-blur', {
            composed: true,
            bubbles: true,
        }));
        beforeMount(() => unmountedGroup.push(watch(props, propName => {
            const input = inputRef.value;
            if (propName !== 'edit' || !props.edit || !input)
                return;
            lastCursorFocus(input);
        }), 
        // firefox
        watch(props, propName => {
            if (propName !== 'edit')
                return;
            props.edit || onBlur();
        })));
        return () => props.edit
            ? html `
          <input
            class=${classMap(getClassMap())}
            style=${styleMap({
            width: `${props.width}px`,
        })}
            type="text"
            spellcheck="false"
            .value=${props.value}
            placeholder=${props.placeholder}
            @blur=${onBlur}
          />
        `
            : html `
          <div
            class=${classMap(getClassMap())}
            style=${styleMap({
            width: `${props.width}px`,
        })}
          >
            <span>${getPlaceholderValue()}</span>
          </div>
        `;
    };
    defineComponent('kderd-input', {
        observedProps: [
            {
                name: 'edit',
                type: Boolean,
                default: false,
            },
            {
                name: 'focusState',
                type: Boolean,
                default: false,
            },
            {
                name: 'select',
                type: Boolean,
                default: false,
            },
            {
                name: 'active',
                type: Boolean,
                default: false,
            },
            {
                name: 'width',
                type: Number,
                default: SIZE_MIN_WIDTH,
            },
            {
                name: 'value',
                default: '',
            },
            {
                name: 'placeholder',
                default: '',
            },
        ],
        shadow: false,
        styleMap: {
            display: 'inline-flex',
        },
        render: Input,
    });

    const ColumnKey = (props, ctx) => {
        return () => html `
    <div
      class=${classMap({
        'kderd-column-key': true,
        pk: props.ui.pk,
        fk: props.ui.fk,
        pfk: props.ui.pfk,
    })}
    >
      <kderd-icon size="12" name="key"></kderd-icon>
    </div>
  `;
    };
    defineComponent('kderd-column-key', {
        observedProps: ['ui'],
        shadow: false,
        styleMap: {
            display: 'flex',
            height: '100%',
            alignItems: 'center',
        },
        render: ColumnKey,
    });

    const KSqlDBTypes = [
        { name: 'CHAR', primitiveType: 'string' },
        { name: 'VARCHAR', primitiveType: 'string' },
        { name: 'NCHAR', primitiveType: 'string' },
        { name: 'NVARCHAR', primitiveType: 'string' },
        { name: 'INT', primitiveType: 'int' },
        { name: 'INTEGER', primitiveType: 'int' },
        { name: 'SMALLINT', primitiveType: 'int' },
        { name: 'BIGINT', primitiveType: 'long' },
        { name: 'DECIMAL', primitiveType: 'decimal' },
        { name: 'DATETIME', primitiveType: 'dateTime' },
        { name: 'BINARY', primitiveType: 'lob' },
        { name: 'VARBINARY', primitiveType: 'string' },
        { name: 'BLOB', primitiveType: 'lob' },
        { name: 'CLOB', primitiveType: 'lob' },
        { name: 'NCLOB', primitiveType: 'lob' },
    ];

    /**
     * https://docs.microsoft.com/ko-kr/sql/t-sql/data-types/data-types-transact-sql?view=sql-server-ver15
     */
    const MSSQLTypes = [
        { name: 'bigint', primitiveType: 'long' },
        { name: 'binary', primitiveType: 'lob' },
        { name: 'bit', primitiveType: 'int' },
        { name: 'char', primitiveType: 'string' },
        { name: 'date', primitiveType: 'date' },
        { name: 'datetime', primitiveType: 'dateTime' },
        { name: 'datetime2', primitiveType: 'dateTime' },
        { name: 'datetimeoffset', primitiveType: 'dateTime' },
        { name: 'decimal', primitiveType: 'decimal' },
        { name: 'float', primitiveType: 'double' },
        { name: 'geography', primitiveType: 'string' },
        { name: 'geometry', primitiveType: 'string' },
        { name: 'image', primitiveType: 'lob' },
        { name: 'int', primitiveType: 'int' },
        { name: 'money', primitiveType: 'double' },
        { name: 'nchar', primitiveType: 'string' },
        { name: 'ntext', primitiveType: 'lob' },
        { name: 'numeric', primitiveType: 'float' },
        { name: 'nvarchar', primitiveType: 'string' },
        { name: 'real', primitiveType: 'float' },
        { name: 'smalldatetime', primitiveType: 'dateTime' },
        { name: 'smallint', primitiveType: 'int' },
        { name: 'smallmoney', primitiveType: 'float' },
        { name: 'sql_variant', primitiveType: 'string' },
        { name: 'text', primitiveType: 'lob' },
        { name: 'time', primitiveType: 'time' },
        { name: 'tinyint', primitiveType: 'int' },
        { name: 'uniqueidentifier', primitiveType: 'string' },
        { name: 'varbinary', primitiveType: 'string' },
        { name: 'varchar', primitiveType: 'string' },
        { name: 'xml', primitiveType: 'lob' },
    ];

    /**
     * https://dev.mysql.com/doc/refman/8.0/en/data-types.html
     */
    const MySQLTypes = [
        { name: 'BIGINT', primitiveType: 'long' },
        { name: 'BINARY', primitiveType: 'string' },
        { name: 'BIT', primitiveType: 'int' },
        { name: 'BLOB', primitiveType: 'lob' },
        { name: 'BOOL', primitiveType: 'boolean' },
        { name: 'BOOLEAN', primitiveType: 'boolean' },
        { name: 'CHAR', primitiveType: 'string' },
        { name: 'DATE', primitiveType: 'date' },
        { name: 'DATETIME', primitiveType: 'dateTime' },
        { name: 'DEC', primitiveType: 'decimal' },
        { name: 'DECIMAL', primitiveType: 'decimal' },
        { name: 'DOUBLE PRECISION', primitiveType: 'double' },
        { name: 'DOUBLE', primitiveType: 'double' },
        { name: 'ENUM', primitiveType: 'string' },
        { name: 'FLOAT', primitiveType: 'float' },
        { name: 'GEOMETRY', primitiveType: 'string' },
        { name: 'GEOMETRYCOLLECTION', primitiveType: 'string' },
        { name: 'INT', primitiveType: 'int' },
        { name: 'INTEGER', primitiveType: 'int' },
        { name: 'JSON', primitiveType: 'lob' },
        { name: 'LINESTRING', primitiveType: 'string' },
        { name: 'LONGBLOB', primitiveType: 'lob' },
        { name: 'LONGTEXT', primitiveType: 'lob' },
        { name: 'MEDIUMBLOB', primitiveType: 'lob' },
        { name: 'MEDIUMINT', primitiveType: 'int' },
        { name: 'MEDIUMTEXT', primitiveType: 'lob' },
        { name: 'MULTILINESTRING', primitiveType: 'string' },
        { name: 'MULTIPOINT', primitiveType: 'string' },
        { name: 'MULTIPOLYGON', primitiveType: 'string' },
        { name: 'NUMERIC', primitiveType: 'decimal' },
        { name: 'POINT', primitiveType: 'string' },
        { name: 'POLYGON', primitiveType: 'string' },
        { name: 'SET', primitiveType: 'string' },
        { name: 'SMALLINT', primitiveType: 'int' },
        { name: 'TEXT', primitiveType: 'lob' },
        { name: 'TIME', primitiveType: 'time' },
        { name: 'TIMESTAMP', primitiveType: 'dateTime' },
        { name: 'TINYBLOB', primitiveType: 'lob' },
        { name: 'TINYINT', primitiveType: 'int' },
        { name: 'TINYTEXT', primitiveType: 'lob' },
        { name: 'VARBINARY', primitiveType: 'string' },
        { name: 'VARCHAR', primitiveType: 'string' },
        { name: 'YEAR', primitiveType: 'int' },
    ];

    /**
     * https://docs.oracle.com/cd/B28359_01/server.111/b28318/datatype.htm#CNCPT012
     */
    const OracleTypes = [
        { name: 'BFILE', primitiveType: 'lob' },
        { name: 'BINARY_DOUBLE', primitiveType: 'double' },
        { name: 'BINARY_FLOAT', primitiveType: 'float' },
        { name: 'BLOB', primitiveType: 'lob' },
        { name: 'CHAR', primitiveType: 'string' },
        { name: 'CLOB', primitiveType: 'lob' },
        { name: 'DATE', primitiveType: 'date' },
        { name: 'DATETIME', primitiveType: 'dateTime' },
        { name: 'LONG RAW', primitiveType: 'lob' },
        { name: 'LONG', primitiveType: 'lob' },
        { name: 'NCHAR', primitiveType: 'string' },
        { name: 'NCLOB', primitiveType: 'lob' },
        { name: 'NUMBER', primitiveType: 'long' },
        { name: 'NVARCHAR2', primitiveType: 'string' },
        { name: 'RAW', primitiveType: 'lob' },
        { name: 'TIMESTAMP WITH LOCAL TIME ZONE', primitiveType: 'dateTime' },
        { name: 'TIMESTAMP WITH TIME ZONE', primitiveType: 'dateTime' },
        { name: 'TIMESTAMP', primitiveType: 'dateTime' },
        { name: 'UriType', primitiveType: 'string' },
        { name: 'VARCHAR', primitiveType: 'string' },
        { name: 'VARCHAR2', primitiveType: 'string' },
        { name: 'XMLType', primitiveType: 'string' },
    ];

    /**
     * https://www.postgresql.org/docs/current/datatype.html
     */
    const PostgreSQLTypes = [
        { name: 'bigint', primitiveType: 'long' },
        { name: 'bigserial', primitiveType: 'long' },
        { name: 'bit varying', primitiveType: 'int' },
        { name: 'bit', primitiveType: 'int' },
        { name: 'bool', primitiveType: 'boolean' },
        { name: 'boolean', primitiveType: 'boolean' },
        { name: 'box', primitiveType: 'string' },
        { name: 'bytea', primitiveType: 'string' },
        { name: 'char', primitiveType: 'string' },
        { name: 'character varying', primitiveType: 'string' },
        { name: 'character', primitiveType: 'string' },
        { name: 'cidr', primitiveType: 'string' },
        { name: 'circle', primitiveType: 'string' },
        { name: 'date', primitiveType: 'date' },
        { name: 'decimal', primitiveType: 'decimal' },
        { name: 'double precision', primitiveType: 'double' },
        { name: 'float4', primitiveType: 'float' },
        { name: 'float8', primitiveType: 'double' },
        { name: 'inet', primitiveType: 'string' },
        { name: 'int', primitiveType: 'int' },
        { name: 'int2', primitiveType: 'int' },
        { name: 'int4', primitiveType: 'int' },
        { name: 'int8', primitiveType: 'long' },
        { name: 'integer', primitiveType: 'int' },
        { name: 'interval', primitiveType: 'time' },
        { name: 'json', primitiveType: 'lob' },
        { name: 'jsonb', primitiveType: 'lob' },
        { name: 'line', primitiveType: 'string' },
        { name: 'lseg', primitiveType: 'string' },
        { name: 'macaddr', primitiveType: 'string' },
        { name: 'macaddr8', primitiveType: 'string' },
        { name: 'money', primitiveType: 'double' },
        { name: 'numeric', primitiveType: 'decimal' },
        { name: 'path', primitiveType: 'string' },
        { name: 'pg_lsn', primitiveType: 'int' },
        { name: 'point', primitiveType: 'string' },
        { name: 'polygon', primitiveType: 'string' },
        { name: 'real', primitiveType: 'float' },
        { name: 'serial', primitiveType: 'int' },
        { name: 'serial2', primitiveType: 'int' },
        { name: 'serial4', primitiveType: 'int' },
        { name: 'serial8', primitiveType: 'long' },
        { name: 'smallint', primitiveType: 'int' },
        { name: 'smallserial', primitiveType: 'int' },
        { name: 'text', primitiveType: 'string' },
        { name: 'time with time zone', primitiveType: 'time' },
        { name: 'time', primitiveType: 'time' },
        { name: 'timestamp with time zone', primitiveType: 'dateTime' },
        { name: 'timestamp', primitiveType: 'dateTime' },
        { name: 'timestamptz', primitiveType: 'dateTime' },
        { name: 'timetz', primitiveType: 'time' },
        { name: 'tsquery', primitiveType: 'string' },
        { name: 'tsvector', primitiveType: 'string' },
        { name: 'txid_snapshot', primitiveType: 'string' },
        { name: 'uuid', primitiveType: 'string' },
        { name: 'varbit', primitiveType: 'int' },
        { name: 'varchar', primitiveType: 'string' },
        { name: 'xml', primitiveType: 'lob' },
    ];

    const databaseHints = [
        {
            database: 'KSQL',
            dataTypeHints: KSqlDBTypes,
        },
        {
            database: 'MSSQL',
            dataTypeHints: MSSQLTypes,
        },
        {
            database: 'MySQL',
            dataTypeHints: MySQLTypes,
        },
        {
            database: 'Oracle',
            dataTypeHints: OracleTypes,
        },
        {
            database: 'PostgreSQL',
            dataTypeHints: PostgreSQLTypes,
        },
    ];

    const findIndex$2 = findIndex$4(propEq$1('active', true));
    function useDataTypeHint(props, ctx) {
        const contextRef = useContext(ctx);
        const { unmountedGroup } = useUnmounted();
        const state = observable$1({
            hints: [],
            isFilter: true,
        });
        const getDataTypeHints = () => {
            const { store: { canvasState }, } = contextRef.value;
            const databaseHint = databaseHints.find(databaseHint => databaseHint.database === canvasState.database);
            return databaseHint ? databaseHint.dataTypeHints : [];
        };
        const getActiveIndex = () => findIndex$2(state.hints);
        const setHints = () => {
            var _a;
            if (!state.isFilter)
                return;
            const dataTypeHints = getDataTypeHints();
            state.hints =
                ((_a = props.value) === null || _a === void 0 ? void 0 : _a.trim()) === ''
                    ? dataTypeHints.map(dataTypeHint => ({
                        name: dataTypeHint.name,
                        html: dataTypeHint.name,
                        active: false,
                    }))
                    : dataTypeHints
                        .filter(dataTypeHint => dataTypeHint.name
                        .toLowerCase()
                        .indexOf(props.value.toLowerCase()) !== -1)
                        .map(dataTypeHint => {
                        return {
                            name: dataTypeHint.name,
                            html: markToHTML('kderd-data-type-hint-mark', dataTypeHint.name, props.value),
                            active: false,
                        };
                    });
        };
        const activeEnd = () => {
            state.hints.forEach(hint => (hint.active = false));
        };
        const onSelectHint = (hint) => {
            const { store, helper } = contextRef.value;
            activeEnd();
            state.isFilter = false;
            store.dispatch(changeColumnDataType(helper, props.tableId, props.columnId, hint.name));
        };
        const onArrowUp = (event) => {
            state.hints.length !== 0 && event.preventDefault();
            const index = getActiveIndex();
            if (index > 0) {
                state.hints[index].active = false;
                state.hints[index - 1].active = true;
            }
            else if (state.hints.length) {
                index === 0 && (state.hints[index].active = false);
                state.hints[state.hints.length - 1].active = true;
            }
        };
        const onArrowDown = (event) => {
            state.hints.length !== 0 && event.preventDefault();
            const index = getActiveIndex();
            if (index !== -1 && index !== state.hints.length - 1) {
                state.hints[index].active = false;
                state.hints[index + 1].active = true;
            }
            else if (state.hints.length) {
                index === state.hints.length - 1 && (state.hints[index].active = false);
                state.hints[0].active = true;
            }
        };
        const onArrowLeft = () => activeEnd();
        const onArrowRight = (event) => {
            const index = getActiveIndex();
            if (index < 0)
                return;
            event.preventDefault();
            const { store, helper } = contextRef.value;
            state.isFilter = false;
            store.dispatch(changeColumnDataType(helper, props.tableId, props.columnId, state.hints[index].name));
        };
        const arrowMap = {
            ArrowUp: onArrowUp,
            ArrowDown: onArrowDown,
            ArrowLeft: onArrowLeft,
            ArrowRight: onArrowRight,
        };
        const onKeydown = (event) => {
            switch (event.key) {
                case 'ArrowUp':
                case 'ArrowDown':
                case 'ArrowLeft':
                case 'ArrowRight':
                    arrowMap[event.key](event);
                    break;
            }
        };
        const onInput = () => (state.isFilter = true);
        beforeMount(() => {
            const { store: { canvasState }, } = contextRef.value;
            unmountedGroup.push(watch(props, propName => {
                if (propName !== 'value')
                    return;
                setHints();
            }), watch(canvasState, propName => {
                if (propName !== 'database')
                    return;
                state.isFilter = true;
                setHints();
            }));
        });
        return {
            hintState: state,
            onSelectHint,
            onKeydown,
            onInput,
        };
    }

    /**
     * FLIP stands for First, Last, Invert, Play.
     * https://aerotwist.com/blog/flip-your-animations/
     */
    class FlipAnimation {
        constructor(root, selector, animationName) {
            this.flipSnapshots = [];
            this.root = root;
            this.selector = selector;
            this.animationName = animationName;
        }
        snapshot() {
            this.flipSnapshots = [];
            this.root.querySelectorAll(this.selector).forEach(el => {
                // first
                const { top, left } = el.getBoundingClientRect();
                this.flipSnapshots.push({ el, top, left });
            });
        }
        play() {
            if (!this.flipSnapshots.length)
                return;
            this.flipSnapshots.forEach(snapshot => {
                // last
                const el = snapshot.el;
                const { top, left } = el.getBoundingClientRect();
                const dx = snapshot.left - left;
                const dy = snapshot.top - top;
                if (dx || dy) {
                    // invert
                    el.style.transform = `translate(${dx}px,${dy}px)`;
                    el.style.transitionDuration = '0s';
                    // play
                    requestAnimationFrame(() => {
                        el.classList.add(this.animationName);
                        el.style.transform = '';
                        el.style.transitionDuration = '';
                        const onTransitionend = () => {
                            el.classList.remove(this.animationName);
                            el.removeEventListener('transitionend', onTransitionend);
                        };
                        el.addEventListener('transitionend', onTransitionend);
                    });
                }
            });
            this.flipSnapshots = [];
        }
    }

    function useFlipAnimation(ctx, selector, animationName) {
        const flipAnimation = new FlipAnimation(ctx.shadowRoot ? ctx.shadowRoot : ctx, selector, animationName);
        beforeUpdate(() => flipAnimation.snapshot());
        updated(() => flipAnimation.play());
    }

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    // Helper functions for manipulating parts
    // TODO(kschaaf): Refactor into Part API?
    const createAndInsertPart = (containerPart, beforePart) => {
        const container = containerPart.startNode.parentNode;
        const beforeNode = beforePart === undefined ? containerPart.endNode :
            beforePart.startNode;
        const startNode = container.insertBefore(createMarker(), beforeNode);
        container.insertBefore(createMarker(), beforeNode);
        const newPart = new NodePart(containerPart.options);
        newPart.insertAfterNode(startNode);
        return newPart;
    };
    const updatePart = (part, value) => {
        part.setValue(value);
        part.commit();
        return part;
    };
    const insertPartBefore = (containerPart, part, ref) => {
        const container = containerPart.startNode.parentNode;
        const beforeNode = ref ? ref.startNode : containerPart.endNode;
        const endNode = part.endNode.nextSibling;
        if (endNode !== beforeNode) {
            reparentNodes(container, part.startNode, endNode, beforeNode);
        }
    };
    const removePart = (part) => {
        removeNodes(part.startNode.parentNode, part.startNode, part.endNode.nextSibling);
    };
    // Helper for generating a map of array item to its index over a subset
    // of an array (used to lazily generate `newKeyToIndexMap` and
    // `oldKeyToIndexMap`)
    const generateMap = (list, start, end) => {
        const map = new Map();
        for (let i = start; i <= end; i++) {
            map.set(list[i], i);
        }
        return map;
    };
    // Stores previous ordered list of parts and map of key to index
    const partListCache = new WeakMap();
    const keyListCache = new WeakMap();
    /**
     * A directive that repeats a series of values (usually `TemplateResults`)
     * generated from an iterable, and updates those items efficiently when the
     * iterable changes based on user-provided `keys` associated with each item.
     *
     * Note that if a `keyFn` is provided, strict key-to-DOM mapping is maintained,
     * meaning previous DOM for a given key is moved into the new position if
     * needed, and DOM will never be reused with values for different keys (new DOM
     * will always be created for new keys). This is generally the most efficient
     * way to use `repeat` since it performs minimum unnecessary work for insertions
     * and removals.
     *
     * IMPORTANT: If providing a `keyFn`, keys *must* be unique for all items in a
     * given call to `repeat`. The behavior when two or more items have the same key
     * is undefined.
     *
     * If no `keyFn` is provided, this directive will perform similar to mapping
     * items to values, and DOM will be reused against potentially different items.
     */
    const repeat = directive((items, keyFnOrTemplate, template) => {
        let keyFn;
        if (template === undefined) {
            template = keyFnOrTemplate;
        }
        else if (keyFnOrTemplate !== undefined) {
            keyFn = keyFnOrTemplate;
        }
        return (containerPart) => {
            if (!(containerPart instanceof NodePart)) {
                throw new Error('repeat can only be used in text bindings');
            }
            // Old part & key lists are retrieved from the last update
            // (associated with the part for this instance of the directive)
            const oldParts = partListCache.get(containerPart) || [];
            const oldKeys = keyListCache.get(containerPart) || [];
            // New part list will be built up as we go (either reused from
            // old parts or created for new keys in this update). This is
            // saved in the above cache at the end of the update.
            const newParts = [];
            // New value list is eagerly generated from items along with a
            // parallel array indicating its key.
            const newValues = [];
            const newKeys = [];
            let index = 0;
            for (const item of items) {
                newKeys[index] = keyFn ? keyFn(item, index) : index;
                newValues[index] = template(item, index);
                index++;
            }
            // Maps from key to index for current and previous update; these
            // are generated lazily only when needed as a performance
            // optimization, since they are only required for multiple
            // non-contiguous changes in the list, which are less common.
            let newKeyToIndexMap;
            let oldKeyToIndexMap;
            // Head and tail pointers to old parts and new values
            let oldHead = 0;
            let oldTail = oldParts.length - 1;
            let newHead = 0;
            let newTail = newValues.length - 1;
            // Overview of O(n) reconciliation algorithm (general approach
            // based on ideas found in ivi, vue, snabbdom, etc.):
            //
            // * We start with the list of old parts and new values (and
            //   arrays of their respective keys), head/tail pointers into
            //   each, and we build up the new list of parts by updating
            //   (and when needed, moving) old parts or creating new ones.
            //   The initial scenario might look like this (for brevity of
            //   the diagrams, the numbers in the array reflect keys
            //   associated with the old parts or new values, although keys
            //   and parts/values are actually stored in parallel arrays
            //   indexed using the same head/tail pointers):
            //
            //      oldHead v                 v oldTail
            //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]
            //   newParts: [ ,  ,  ,  ,  ,  ,  ]
            //   newKeys:  [0, 2, 1, 4, 3, 7, 6] <- reflects the user's new
            //                                      item order
            //      newHead ^                 ^ newTail
            //
            // * Iterate old & new lists from both sides, updating,
            //   swapping, or removing parts at the head/tail locations
            //   until neither head nor tail can move.
            //
            // * Example below: keys at head pointers match, so update old
            //   part 0 in-place (no need to move it) and record part 0 in
            //   the `newParts` list. The last thing we do is advance the
            //   `oldHead` and `newHead` pointers (will be reflected in the
            //   next diagram).
            //
            //      oldHead v                 v oldTail
            //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]
            //   newParts: [0,  ,  ,  ,  ,  ,  ] <- heads matched: update 0
            //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldHead
            //                                      & newHead
            //      newHead ^                 ^ newTail
            //
            // * Example below: head pointers don't match, but tail
            //   pointers do, so update part 6 in place (no need to move
            //   it), and record part 6 in the `newParts` list. Last,
            //   advance the `oldTail` and `oldHead` pointers.
            //
            //         oldHead v              v oldTail
            //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]
            //   newParts: [0,  ,  ,  ,  ,  , 6] <- tails matched: update 6
            //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldTail
            //                                      & newTail
            //         newHead ^              ^ newTail
            //
            // * If neither head nor tail match; next check if one of the
            //   old head/tail items was removed. We first need to generate
            //   the reverse map of new keys to index (`newKeyToIndexMap`),
            //   which is done once lazily as a performance optimization,
            //   since we only hit this case if multiple non-contiguous
            //   changes were made. Note that for contiguous removal
            //   anywhere in the list, the head and tails would advance
            //   from either end and pass each other before we get to this
            //   case and removals would be handled in the final while loop
            //   without needing to generate the map.
            //
            // * Example below: The key at `oldTail` was removed (no longer
            //   in the `newKeyToIndexMap`), so remove that part from the
            //   DOM and advance just the `oldTail` pointer.
            //
            //         oldHead v           v oldTail
            //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]
            //   newParts: [0,  ,  ,  ,  ,  , 6] <- 5 not in new map: remove
            //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    5 and advance oldTail
            //         newHead ^           ^ newTail
            //
            // * Once head and tail cannot move, any mismatches are due to
            //   either new or moved items; if a new key is in the previous
            //   "old key to old index" map, move the old part to the new
            //   location, otherwise create and insert a new part. Note
            //   that when moving an old part we null its position in the
            //   oldParts array if it lies between the head and tail so we
            //   know to skip it when the pointers get there.
            //
            // * Example below: neither head nor tail match, and neither
            //   were removed; so find the `newHead` key in the
            //   `oldKeyToIndexMap`, and move that old part's DOM into the
            //   next head position (before `oldParts[oldHead]`). Last,
            //   null the part in the `oldPart` array since it was
            //   somewhere in the remaining oldParts still to be scanned
            //   (between the head and tail pointers) so that we know to
            //   skip that old part on future iterations.
            //
            //         oldHead v        v oldTail
            //   oldKeys:  [0, 1, -, 3, 4, 5, 6]
            //   newParts: [0, 2,  ,  ,  ,  , 6] <- stuck: update & move 2
            //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    into place and advance
            //                                      newHead
            //         newHead ^           ^ newTail
            //
            // * Note that for moves/insertions like the one above, a part
            //   inserted at the head pointer is inserted before the
            //   current `oldParts[oldHead]`, and a part inserted at the
            //   tail pointer is inserted before `newParts[newTail+1]`. The
            //   seeming asymmetry lies in the fact that new parts are
            //   moved into place outside in, so to the right of the head
            //   pointer are old parts, and to the right of the tail
            //   pointer are new parts.
            //
            // * We always restart back from the top of the algorithm,
            //   allowing matching and simple updates in place to
            //   continue...
            //
            // * Example below: the head pointers once again match, so
            //   simply update part 1 and record it in the `newParts`
            //   array.  Last, advance both head pointers.
            //
            //         oldHead v        v oldTail
            //   oldKeys:  [0, 1, -, 3, 4, 5, 6]
            //   newParts: [0, 2, 1,  ,  ,  , 6] <- heads matched: update 1
            //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldHead
            //                                      & newHead
            //            newHead ^        ^ newTail
            //
            // * As mentioned above, items that were moved as a result of
            //   being stuck (the final else clause in the code below) are
            //   marked with null, so we always advance old pointers over
            //   these so we're comparing the next actual old value on
            //   either end.
            //
            // * Example below: `oldHead` is null (already placed in
            //   newParts), so advance `oldHead`.
            //
            //            oldHead v     v oldTail
            //   oldKeys:  [0, 1, -, 3, 4, 5, 6] <- old head already used:
            //   newParts: [0, 2, 1,  ,  ,  , 6]    advance oldHead
            //   newKeys:  [0, 2, 1, 4, 3, 7, 6]
            //               newHead ^     ^ newTail
            //
            // * Note it's not critical to mark old parts as null when they
            //   are moved from head to tail or tail to head, since they
            //   will be outside the pointer range and never visited again.
            //
            // * Example below: Here the old tail key matches the new head
            //   key, so the part at the `oldTail` position and move its
            //   DOM to the new head position (before `oldParts[oldHead]`).
            //   Last, advance `oldTail` and `newHead` pointers.
            //
            //               oldHead v  v oldTail
            //   oldKeys:  [0, 1, -, 3, 4, 5, 6]
            //   newParts: [0, 2, 1, 4,  ,  , 6] <- old tail matches new
            //   newKeys:  [0, 2, 1, 4, 3, 7, 6]   head: update & move 4,
            //                                     advance oldTail & newHead
            //               newHead ^     ^ newTail
            //
            // * Example below: Old and new head keys match, so update the
            //   old head part in place, and advance the `oldHead` and
            //   `newHead` pointers.
            //
            //               oldHead v oldTail
            //   oldKeys:  [0, 1, -, 3, 4, 5, 6]
            //   newParts: [0, 2, 1, 4, 3,   ,6] <- heads match: update 3
            //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance oldHead &
            //                                      newHead
            //                  newHead ^  ^ newTail
            //
            // * Once the new or old pointers move past each other then all
            //   we have left is additions (if old list exhausted) or
            //   removals (if new list exhausted). Those are handled in the
            //   final while loops at the end.
            //
            // * Example below: `oldHead` exceeded `oldTail`, so we're done
            //   with the main loop.  Create the remaining part and insert
            //   it at the new head position, and the update is complete.
            //
            //                   (oldHead > oldTail)
            //   oldKeys:  [0, 1, -, 3, 4, 5, 6]
            //   newParts: [0, 2, 1, 4, 3, 7 ,6] <- create and insert 7
            //   newKeys:  [0, 2, 1, 4, 3, 7, 6]
            //                     newHead ^ newTail
            //
            // * Note that the order of the if/else clauses is not
            //   important to the algorithm, as long as the null checks
            //   come first (to ensure we're always working on valid old
            //   parts) and that the final else clause comes last (since
            //   that's where the expensive moves occur). The order of
            //   remaining clauses is is just a simple guess at which cases
            //   will be most common.
            //
            // * TODO(kschaaf) Note, we could calculate the longest
            //   increasing subsequence (LIS) of old items in new position,
            //   and only move those not in the LIS set. However that costs
            //   O(nlogn) time and adds a bit more code, and only helps
            //   make rare types of mutations require fewer moves. The
            //   above handles removes, adds, reversal, swaps, and single
            //   moves of contiguous items in linear time, in the minimum
            //   number of moves. As the number of multiple moves where LIS
            //   might help approaches a random shuffle, the LIS
            //   optimization becomes less helpful, so it seems not worth
            //   the code at this point. Could reconsider if a compelling
            //   case arises.
            while (oldHead <= oldTail && newHead <= newTail) {
                if (oldParts[oldHead] === null) {
                    // `null` means old part at head has already been used
                    // below; skip
                    oldHead++;
                }
                else if (oldParts[oldTail] === null) {
                    // `null` means old part at tail has already been used
                    // below; skip
                    oldTail--;
                }
                else if (oldKeys[oldHead] === newKeys[newHead]) {
                    // Old head matches new head; update in place
                    newParts[newHead] =
                        updatePart(oldParts[oldHead], newValues[newHead]);
                    oldHead++;
                    newHead++;
                }
                else if (oldKeys[oldTail] === newKeys[newTail]) {
                    // Old tail matches new tail; update in place
                    newParts[newTail] =
                        updatePart(oldParts[oldTail], newValues[newTail]);
                    oldTail--;
                    newTail--;
                }
                else if (oldKeys[oldHead] === newKeys[newTail]) {
                    // Old head matches new tail; update and move to new tail
                    newParts[newTail] =
                        updatePart(oldParts[oldHead], newValues[newTail]);
                    insertPartBefore(containerPart, oldParts[oldHead], newParts[newTail + 1]);
                    oldHead++;
                    newTail--;
                }
                else if (oldKeys[oldTail] === newKeys[newHead]) {
                    // Old tail matches new head; update and move to new head
                    newParts[newHead] =
                        updatePart(oldParts[oldTail], newValues[newHead]);
                    insertPartBefore(containerPart, oldParts[oldTail], oldParts[oldHead]);
                    oldTail--;
                    newHead++;
                }
                else {
                    if (newKeyToIndexMap === undefined) {
                        // Lazily generate key-to-index maps, used for removals &
                        // moves below
                        newKeyToIndexMap = generateMap(newKeys, newHead, newTail);
                        oldKeyToIndexMap = generateMap(oldKeys, oldHead, oldTail);
                    }
                    if (!newKeyToIndexMap.has(oldKeys[oldHead])) {
                        // Old head is no longer in new list; remove
                        removePart(oldParts[oldHead]);
                        oldHead++;
                    }
                    else if (!newKeyToIndexMap.has(oldKeys[oldTail])) {
                        // Old tail is no longer in new list; remove
                        removePart(oldParts[oldTail]);
                        oldTail--;
                    }
                    else {
                        // Any mismatches at this point are due to additions or
                        // moves; see if we have an old part we can reuse and move
                        // into place
                        const oldIndex = oldKeyToIndexMap.get(newKeys[newHead]);
                        const oldPart = oldIndex !== undefined ? oldParts[oldIndex] : null;
                        if (oldPart === null) {
                            // No old part for this value; create a new one and
                            // insert it
                            const newPart = createAndInsertPart(containerPart, oldParts[oldHead]);
                            updatePart(newPart, newValues[newHead]);
                            newParts[newHead] = newPart;
                        }
                        else {
                            // Reuse old part
                            newParts[newHead] =
                                updatePart(oldPart, newValues[newHead]);
                            insertPartBefore(containerPart, oldPart, oldParts[oldHead]);
                            // This marks the old part as having been used, so that
                            // it will be skipped in the first two checks above
                            oldParts[oldIndex] = null;
                        }
                        newHead++;
                    }
                }
            }
            // Add parts for any remaining new values
            while (newHead <= newTail) {
                // For all remaining additions, we insert before last new
                // tail, since old pointers are no longer valid
                const newPart = createAndInsertPart(containerPart, newParts[newTail + 1]);
                updatePart(newPart, newValues[newHead]);
                newParts[newHead++] = newPart;
            }
            // Remove any remaining unused old parts
            while (oldHead <= oldTail) {
                const oldPart = oldParts[oldHead++];
                if (oldPart !== null) {
                    removePart(oldPart);
                }
            }
            // Save order of new parts for next round
            partListCache.set(containerPart, newParts);
            keyListCache.set(containerPart, newKeys);
        };
    });

    /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    // For each part, remember the value that was last rendered to the part by the
    // unsafeHTML directive, and the DocumentFragment that was last set as a value.
    // The DocumentFragment is used as a unique key to check if the last value
    // rendered to the part was with unsafeHTML. If not, we'll always re-render the
    // value passed to unsafeHTML.
    const previousValues = new WeakMap();
    /**
     * Renders the result as HTML, rather than text.
     *
     * Note, this is unsafe to use with any user-provided input that hasn't been
     * sanitized or escaped, as it may lead to cross-site-scripting
     * vulnerabilities.
     */
    const unsafeHTML = directive((value) => (part) => {
        if (!(part instanceof NodePart)) {
            throw new Error('unsafeHTML can only be used in text bindings');
        }
        const previousValue = previousValues.get(part);
        if (previousValue !== undefined && isPrimitive(value) &&
            value === previousValue.value && part.value === previousValue.fragment) {
            return;
        }
        const template = document.createElement('template');
        template.innerHTML = value; // innerHTML casts to string internally
        const fragment = document.importNode(template.content, true);
        part.setValue(fragment);
        previousValues.set(part, { value, fragment });
    });

    const dataTypeHintTpl = (props, state) => html `
  <ul class="kderd-column-data-type-hint">
    ${repeat(state.hints, hint => hint.name, hint => {
    return html `
          <li
            class=${classMap({
        'kderd-data-type-hint': true,
        active: hint.active,
    })}
            @click=${() => props.onSelectHint(hint)}
          >
            ${unsafeHTML(hint.html)}
          </li>
        `;
})}
  </ul>
`;

    const ColumnDataType = (props, ctx) => {
        const { hintState, onSelectHint, onKeydown, onInput } = useDataTypeHint(props, ctx);
        const { unmountedGroup } = useUnmounted();
        let subscription = null;
        useFlipAnimation(ctx, '.kderd-data-type-hint', 'kderd-data-type-hint-move');
        const emitBlur = () => ctx.dispatchEvent(new CustomEvent('kderd-input-blur', {
            composed: true,
            bubbles: true,
        }));
        const onBlur = (event) => {
            event.stopPropagation();
            const input = queryShadowSelector(['kderd-input', 'input'], ctx);
            input && props.edit ? setTimeout(lastCursorFocus, 0, input) : emitBlur();
        };
        const onMousedown = (event) => {
            const el = event.target;
            if (props.edit && !el.closest('.kderd-column-data-type')) {
                emitBlur();
            }
        };
        const offERDMousedown = () => {
            subscription === null || subscription === void 0 ? void 0 : subscription.unsubscribe();
            subscription = null;
        };
        const onERDMousedown = () => {
            const erd = closestElement('.kderd-erd', ctx);
            if (!erd)
                return;
            if (props.edit) {
                offERDMousedown();
                subscription = fromEvent(erd, 'mousedown').subscribe(onMousedown);
            }
        };
        beforeMount(() => {
            unmountedGroup.push(watch(props, propName => {
                if (propName !== 'edit')
                    return;
                props.edit ? onERDMousedown() : offERDMousedown();
            }));
            onERDMousedown();
        });
        unmounted(() => offERDMousedown());
        return () => html `
    <div class="kderd-column-data-type">
      <kderd-input
        .width=${props.width}
        .value=${props.value}
        .focusState=${props.focusState}
        .edit=${props.edit}
        .select=${props.select}
        .active=${props.active}
        placeholder="dataType"
        @keydown=${onKeydown}
        @input=${onInput}
        @kderd-input-blur=${onBlur}
      ></kderd-input>
      ${props.edit ? dataTypeHintTpl({ onSelectHint }, hintState) : null}
    </div>
  `;
    };
    defineComponent('kderd-column-data-type', {
        observedProps: [
            'edit',
            'focusState',
            'select',
            'active',
            'width',
            'value',
            'placeholder',
            'tableId',
            'columnId',
        ],
        shadow: false,
        render: ColumnDataType,
    });

    const ColumnNotNull = props => () => html `
    <div
      class=${classMap({
    'kderd-column-not-null': true,
    focus: props.focusState,
})}
      style=${styleMap({
    width: `${SIZE_COLUMN_OPTION_NN}px`,
})}
    >
      ${props.columnOption.notNull ? '' : ' '}
    </div>
  `;
    defineComponent('kderd-column-not-null', {
        observedProps: [
            {
                name: 'focusState',
                default: false,
            },
            'columnOption',
        ],
        shadow: false,
        render: ColumnNotNull,
    });

    const ColumnUnique = (props, ctx) => {
        useTooltip(['.kderd-column-unique'], ctx);
        return () => html `
    <div
      class=${classMap({
        'kderd-column-unique': true,
        focus: props.focusState,
        checked: props.columnOption.unique,
    })}
      style=${styleMap({
        width: `${SIZE_COLUMN_OPTION_UQ}px`,
    })}
      data-tippy-content=""
    >
      UQ
    </div>
  `;
    };
    defineComponent('kderd-column-unique', {
        observedProps: [
            {
                name: 'focusState',
                default: false,
            },
            'columnOption',
        ],
        shadow: false,
        render: ColumnUnique,
    });

    const ColumnAutoIncrement = (props, ctx) => {
        useTooltip(['.kderd-column-auto-increment'], ctx);
        return () => html `
    <div
      class=${classMap({
        'kderd-column-auto-increment': true,
        focus: props.focusState,
        checked: props.columnOption.autoIncrement,
    })}
      style=${styleMap({
        width: `${SIZE_COLUMN_OPTION_AI}px`,
    })}
      data-tippy-content=""
    >
      AI
    </div>
  `;
    };
    defineComponent('kderd-column-auto-increment', {
        observedProps: [
            {
                name: 'focusState',
                default: false,
            },
            'columnOption',
        ],
        shadow: false,
        render: ColumnAutoIncrement,
    });

    function columnTpl(props, { store, helper }, { onInput, onFocus, onBlur, onEdit }) {
        const { canvasState: { show, setting }, } = store;
        const { column } = props;
        const { ui } = column;
        const reshapeColumns = setting.columnOrder
            .map(columnType => {
            switch (columnType) {
                case 'columnName':
                    return {
                        columnType,
                        template: html `
              <kderd-input
                .width=${props.widthName}
                .value=${column.name}
                .active=${ui.active}
                .select=${props.select}
                .focusState=${props.focusName}
                .edit=${props.editName}
                placeholder="column"
                @kderd-input-blur=${onBlur}
                @input=${(event) => onInput(event, 'columnName')}
                @mousedown=${(event) => onFocus(event, 'columnName')}
                @dblclick=${() => onEdit('columnName')}
              ></kderd-input>
            `,
                    };
                case 'columnDefault':
                    return show.columnDefault
                        ? {
                            columnType,
                            template: html `
                  <kderd-input
                    .width=${props.widthDefault}
                    .value=${column.default}
                    .active=${ui.active}
                    .select=${props.select}
                    .focusState=${props.focusDefault}
                    .edit=${props.editDefault}
                    placeholder="default"
                    @kderd-input-blur=${onBlur}
                    @input=${(event) => onInput(event, 'columnDefault')}
                    @mousedown=${(event) => onFocus(event, 'columnDefault')}
                    @dblclick=${() => onEdit('columnDefault')}
                  ></kderd-input>
                `,
                        }
                        : null;
                case 'columnComment':
                    return show.columnComment
                        ? {
                            columnType,
                            template: html `
                  <kderd-input
                    class="kderd-column-comment"
                    .width=${props.widthComment}
                    .value=${column.comment}
                    .active=${ui.active}
                    .select=${props.select}
                    .edit=${props.editComment}
                    .focusState=${props.focusComment}
                    placeholder="comment"
                    data-tippy-content=${column.comment.trim()
                            ? column.comment
                            : 'comment'}
                    @kderd-input-blur=${onBlur}
                    @input=${(event) => onInput(event, 'columnComment')}
                    @mousedown=${(event) => onFocus(event, 'columnComment')}
                    @dblclick=${() => onEdit('columnComment')}
                  ></kderd-input>
                `,
                        }
                        : null;
                case 'columnDataType':
                    return show.columnDataType
                        ? {
                            columnType,
                            template: html `
                  <kderd-column-data-type
                    .width=${props.widthDataType}
                    .value=${column.dataType}
                    .active=${ui.active}
                    .tableId=${props.tableId}
                    .columnId=${column.id}
                    .select=${props.select}
                    .focusState=${props.focusDataType}
                    .edit=${props.editDataType}
                    @kderd-input-blur=${onBlur}
                    @input=${(event) => onInput(event, 'columnDataType')}
                    @mousedown=${(event) => onFocus(event, 'columnDataType')}
                    @dblclick=${() => onEdit('columnDataType')}
                  ></kderd-column-data-type>
                `,
                        }
                        : null;
                case 'columnNotNull':
                    return show.columnNotNull
                        ? {
                            columnType,
                            template: html `
                  <kderd-column-not-null
                    .columnOption=${column.option}
                    .focusState=${props.focusNotNull}
                    @mousedown=${(event) => onFocus(event, 'columnNotNull')}
                    @dblclick=${() => onEdit('columnNotNull')}
                  ></kderd-column-not-null>
                `,
                        }
                        : null;
                case 'columnUnique':
                    return show.columnUnique
                        ? {
                            columnType,
                            template: html `
                  <kderd-column-unique
                    .columnOption=${column.option}
                    .focusState=${props.focusUnique}
                    @mousedown=${(event) => onFocus(event, 'columnUnique')}
                    @dblclick=${() => onEdit('columnUnique')}
                  ></kderd-column-unique>
                `,
                        }
                        : null;
                case 'columnAutoIncrement':
                    return show.columnAutoIncrement
                        ? {
                            columnType,
                            template: html `
                  <kderd-column-auto-increment
                    .columnOption=${column.option}
                    .focusState=${props.focusAutoIncrement}
                    @mousedown=${(event) => onFocus(event, 'columnAutoIncrement')}
                    @dblclick=${() => onEdit('columnAutoIncrement')}
                  ></kderd-column-auto-increment>
                `,
                        }
                        : null;
                default:
                    return null;
            }
        })
            .filter(reshapeColumn => !!reshapeColumn);
        return repeat(reshapeColumns, reshapeColumn => reshapeColumn.columnType, reshapeColumn => reshapeColumn.template);
    }

    const changeColumnMap$1 = {
        columnName: changeColumnName,
        columnComment: changeColumnComment,
        columnDataType: changeColumnDataType,
        columnDefault: changeColumnDefault,
    };
    const changeColumnBooleanMap = {
        columnNotNull: changeColumnNotNull,
        columnUnique: changeColumnUnique,
        columnAutoIncrement: changeColumnAutoIncrement,
    };
    const changeColumnBooleanKeys = [
        'columnNotNull',
        'columnUnique',
        'columnAutoIncrement',
    ];
    const Column = (props, ctx) => {
        const contextRef = useContext(ctx);
        useTooltip(['.kderd-column-button'], ctx, { placement: 'right' });
        const { resetTooltip } = useTooltip(['.kderd-column-comment'], ctx, {
            placement: 'right',
        });
        const { unmountedGroup } = useUnmounted();
        const dragover$ = new Subject();
        const onRemoveColumn = () => {
            const { store } = contextRef.value;
            store.dispatch(removeColumn$(store, props.tableId, [props.column.id]));
        };
        const onDragstart = (event) => {
            const { store } = contextRef.value;
            store.dispatch(draggableColumn(store, props.tableId, props.column.id, event.ctrlKey || event.metaKey));
        };
        const onDragend = () => {
            const { store } = contextRef.value;
            store.dispatch(draggableColumnEnd());
        };
        const onDragover = () => dragover$.next(null);
        const onDragoverColumn = () => ctx.dispatchEvent(new CustomEvent('dragover-column', {
            detail: {
                tableId: props.tableId,
                columnId: props.column.id,
            },
        }));
        const onInput = (event, columnType) => {
            const { store, helper } = contextRef.value;
            const changeColumn = changeColumnMap$1[columnType];
            if (!changeColumn)
                return;
            const input = event.target;
            store.dispatch(changeColumn(helper, props.tableId, props.column.id, input.value));
        };
        const onFocus = (event, columnType) => {
            const { store } = contextRef.value;
            store.dispatch(focusColumn(props.tableId, props.column.id, columnType, event.ctrlKey || event.metaKey, event.shiftKey));
        };
        const onBlur = () => {
            const { store } = contextRef.value;
            store.dispatch(editTableEnd());
        };
        const onEdit = (columnType) => {
            const { store } = contextRef.value;
            const { controlState: { allowEdit } } = store;
            if (!allowEdit)
                return;
            if (changeColumnBooleanKeys.includes(columnType)) {
                const changeColumn = changeColumnBooleanMap[columnType];
                store.dispatch(changeColumn(store, props.tableId, props.column.id));
            }
            else {
                store.dispatch(editTable());
            }
        };
        dragover$.pipe(throttleTime(300)).subscribe(onDragoverColumn);
        beforeMount(() => {
            const { show } = contextRef.value.store.canvasState;
            unmountedGroup.push(watch(props.column, propName => {
                if (propName !== 'comment')
                    return;
                resetTooltip();
            }), watch(show, propName => {
                if (propName !== 'columnComment')
                    return;
                resetTooltip();
            }));
        });
        return () => {
            const { keymap } = contextRef.value;
            const { column } = props;
            const { ui } = column;
            return html `
      <div
        class=${classMap({
            'kderd-column': true,
            select: props.select,
            draggable: props.draggable,
            active: ui.active,
        })}
        data-id=${column.id}
        draggable=${contextRef.value.store.controlState.allowEdit}
        @dragstart=${onDragstart}
        @dragend=${onDragend}
        @dragover=${onDragover}
      >
        <kderd-column-key .ui=${ui}></kderd-column-key>
        ${columnTpl(props, contextRef.value, {
            onInput,
            onFocus,
            onBlur,
            onEdit,
        })}
        ${contextRef.value.store.controlState.allowEdit ?
            html `<kderd-icon
            class="kderd-button kderd-column-button"
            data-tippy-content=${`(${keymapOptionsToString(keymap.removeColumn)})`}
            name="times"
            size="9"
            @click=${onRemoveColumn}
          ></kderd-icon>` : null}
      </div>
    `;
        };
    };
    defineComponent('kderd-column', {
        observedProps: [
            'tableId',
            'column',
            'select',
            'draggable',
            'focusName',
            'focusDataType',
            'focusNotNull',
            'focusDefault',
            'focusComment',
            'focusUnique',
            'focusAutoIncrement',
            'editName',
            'editDataType',
            'editDefault',
            'editComment',
            'widthName',
            'widthDataType',
            'widthDefault',
            'widthComment',
        ],
        shadow: false,
        styleMap: {
            display: 'flex',
        },
        render: Column,
    });

    function columnHeadTpl(props, { store, helper }) {
        const { canvasState: { show, setting }, } = store;
        const reshapeColumns = setting.columnOrder
            .map(columnType => {
            switch (columnType) {
                case 'columnName':
                    return {
                        columnType,
                        template: html `
              <div
                style=${styleMap({
                        width: `${props.widthName + 5}px`,
                    })}
              >
              
            </div>
            `,
                    };
                case 'columnDefault':
                    return show.columnDefault
                        ? {
                            columnType,
                            template: html `
                  <div
                  style=${styleMap({
                            width: `${props.widthDefault + 5}px`,
                        })}
                >
                
              </div>
                `,
                        }
                        : null;
                case 'columnComment':
                    return show.columnComment
                        ? {
                            columnType,
                            template: html `
                  <div
                    class="kderd-column-comment"
                    style=${styleMap({
                            width: `${props.widthComment + 5}px`,
                        })}
                  >
                  
                </div>
                `,
                        }
                        : null;
                case 'columnDataType':
                    return show.columnDataType
                        ? {
                            columnType,
                            template: html `
                  <div
                      style=${styleMap({
                            width: `${props.widthDataType + 5}px`,
                        })}>
                    
                    </div>
                `,
                        }
                        : null;
                case 'columnNotNull':
                    return show.columnNotNull
                        ? {
                            columnType,
                            template: html `
                  <div
                  style=${styleMap({
                            width: `${SIZE_COLUMN_OPTION_NN + 5}px`,
                        })}
                  ></div>
                `,
                        }
                        : null;
                case 'columnUnique':
                    return show.columnUnique
                        ? {
                            columnType,
                            template: html `
                  <div
                  style=${styleMap({
                            width: `${SIZE_COLUMN_OPTION_UQ}px`,
                        })}
                  ></div>
                `,
                        }
                        : null;
                case 'columnAutoIncrement':
                    return show.columnAutoIncrement
                        ? {
                            columnType,
                            template: html `
                  <div
                  style=${styleMap({
                            width: `${SIZE_COLUMN_OPTION_AI}px`,
                        })}
                  ></div>
                `,
                        }
                        : null;
                default:
                    return null;
            }
        })
            .filter(reshapeColumn => !!reshapeColumn);
        return repeat(reshapeColumns, reshapeColumn => reshapeColumn.columnType, reshapeColumn => reshapeColumn.template);
    }

    const ColumnHead = (props, ctx) => {
        const contextRef = useContext(ctx);
        return () => {
            const ui = {
                active: false,
                pk: false,
                fk: false,
                pfk: false,
                widthName: props.widthName,
                widthComment: props.widthComment,
                widthDataType: props.widthDataType,
                widthDefault: props.widthDefault,
            };
            return html `
      <div
        class=${classMap({
            'kderd-column-head': true,
        })}
      >
        <kderd-column-key .ui=${ui}></kderd-column-key>
        ${columnHeadTpl(props, contextRef.value)}
      </div>
    `;
        };
    };
    defineComponent('kderd-column-head', {
        observedProps: [
            'widthName',
            'widthDataType',
            'widthDefault',
            'widthComment',
        ],
        shadow: false,
        styleMap: {
            display: 'flex',
        },
        render: ColumnHead,
    });

    function isFocus(focusTarget, focusType, targeId, columnId = null) {
        if (!focusTarget)
            return false;
        if ('table' in focusTarget &&
            focusTarget.table.id !== targeId)
            return false;
        switch (focusType) {
            case 'tableName':
            case 'tableComment':
                return focusType === focusTarget.focusType;
        }
        if ('table' in focusTarget &&
            focusTarget.columnId === columnId &&
            focusType === focusTarget.focusType)
            return true;
        return false;
    }
    const isSelectColumn = (focusTarget, targeId, columnId) => {
        if (!focusTarget)
            return false;
        if ('table' in focusTarget &&
            focusTarget.table.id !== targeId)
            return false;
        if ('table' in focusTarget &&
            focusTarget.selectColumnIds.includes(columnId))
            return true;
        return false;
    };
    function isEdit(focusTarget, focusType, targeId, columnId = null) {
        if (!focusTarget)
            return false;
        if ('table' in focusTarget &&
            focusTarget.table.id !== targeId)
            return false;
        switch (focusType) {
            case 'tableName':
            case 'tableComment':
            case 'tablePackage':
                return focusType === focusTarget.focusType && focusTarget.edit;
        }
        if ('table' in focusTarget &&
            focusTarget.columnId === columnId &&
            focusType === focusTarget.focusType &&
            focusTarget.edit)
            return true;
        return false;
    }
    const isDraggableColumn = (draggableColumn, tableId, columnId) => (draggableColumn === null || draggableColumn === void 0 ? void 0 : draggableColumn.tableId) === tableId &&
        draggableColumn.columnIds.includes(columnId);

    function useHasTable(props, ctx) {
        const contextRef = useContext(ctx);
        const getFocusTable = () => contextRef.value.store.editorState.focusTable;
        const hasFocusState = (focusType, columnId) => isFocus(getFocusTable(), focusType, props.table.id, columnId);
        const hasEdit = (focusType, columnId) => isEdit(getFocusTable(), focusType, props.table.id, columnId);
        const hasSelectColumn = (columnId) => isSelectColumn(getFocusTable(), props.table.id, columnId);
        const hasDraggableColumn = (columnId) => {
            const draggableColumn = contextRef.value.store.editorState.draggableColumn;
            return isDraggableColumn(draggableColumn, props.table.id, columnId);
        };
        return {
            hasFocusState,
            hasEdit,
            hasSelectColumn,
            hasDraggableColumn,
        };
    }

    const TABLE_PADDING$1 = (SIZE_TABLE_PADDING + SIZE_TABLE_BORDER) * 2;
    const ANIMATION_TIME$3 = 300;
    const Table = (props, ctx) => {
        const contextRef = useContext(ctx);
        const { hasFocusState, hasEdit, hasSelectColumn, hasDraggableColumn } = useHasTable(props, ctx);
        useTooltip(['.kderd-table-button'], ctx);
        const { resetTooltip } = useTooltip(['.kderd-table-comment'], ctx);
        const flipAnimation = new FlipAnimation(ctx.shadowRoot ? ctx.shadowRoot : ctx, 'kderd-column', 'kderd-column-move');
        const draggable$ = new Subject();
        const { unmountedGroup } = useUnmounted();
        let leftTween = null;
        let topTween = null;
        const onInput = (event, focusType) => {
            const { store, helper } = contextRef.value;
            const input = event.target;
            switch (focusType) {
                case 'tableName':
                    store.dispatch(changeTableName(helper, props.table.id, input.value));
                    break;
                case 'tableComment':
                    store.dispatch(changeTableComment(helper, props.table.id, input.value));
                    break;
            }
        };
        const onMove = ({ event, movementX, movementY }) => {
            event.type === 'mousemove' && event.preventDefault();
            const { store } = contextRef.value;
            store.dispatch(moveTable(store, event.ctrlKey || event.metaKey, movementX, movementY, props.table.id));
        };
        const onMoveStart = (event) => {
            const el = event.target;
            const { store, globalEvent, eventBus } = contextRef.value;
            const { drag$ } = globalEvent;
            if (!el.closest('.kderd-button') && !el.closest('kderd-input')) {
                leftTween === null || leftTween === void 0 ? void 0 : leftTween.stop();
                topTween === null || topTween === void 0 ? void 0 : topTween.stop();
                drag$.subscribe({
                    next: onMove,
                    complete: () => eventBus.emit(Bus.BalanceRange.move),
                });
            }
            store.dispatch(selectTable$(store, event.ctrlKey || event.metaKey, props.table.id));
        };
        const onRemoveTable = () => {
            const { store } = contextRef.value;
            store.dispatch(removeTable(store, props.table.id));
        };
        const onAddColumn = () => {
            const { store } = contextRef.value;
            store.dispatch(addColumn$(store, props.table.id));
        };
        const onFocus = (focusType) => {
            const { store } = contextRef.value;
            store.dispatch(focusTable(props.table.id, focusType));
        };
        const onBlur = () => {
            const { store } = contextRef.value;
            store.dispatch(editTableEnd());
        };
        const onEdit = () => {
            const { store } = contextRef.value;
            store.dispatch(editTable());
        };
        const onDragoverGroupColumn = (event) => draggable$.next(event);
        const onDraggableColumn = (event) => {
            const { store } = contextRef.value;
            const { editorState: { draggableColumn }, } = store;
            const { tableId, columnId } = event.detail;
            if (!draggableColumn || draggableColumn.columnIds.includes(columnId))
                return;
            flipAnimation.snapshot();
            store.dispatch(moveColumn$(store, draggableColumn.tableId, draggableColumn.columnIds, tableId, columnId));
        };
        const moveBalance = () => {
            const { canvasState: { width, height }, tableState: { tables }, relationshipState: { relationships }, } = contextRef.value.store;
            const minWidth = width - (props.table.width() + TABLE_PADDING$1);
            const minHeight = height - (props.table.height() + TABLE_PADDING$1);
            const x = props.table.ui.left > minWidth ? minWidth : 0;
            const y = props.table.ui.top > minHeight ? minHeight : 0;
            if (props.table.ui.left < 0 || props.table.ui.left > minWidth) {
                leftTween = new Tween(props.table.ui)
                    .to({ left: x }, ANIMATION_TIME$3)
                    .easing(Easing.Quadratic.Out)
                    .onUpdate(() => relationshipSort(tables, relationships))
                    .onComplete(() => (leftTween = null))
                    .start();
            }
            if (props.table.ui.top < 0 || props.table.ui.top > minHeight) {
                topTween = new Tween(props.table.ui)
                    .to({ top: y }, ANIMATION_TIME$3)
                    .easing(Easing.Quadratic.Out)
                    .onUpdate(() => relationshipSort(tables, relationships))
                    .onComplete(() => (topTween = null))
                    .start();
            }
        };
        updated(() => flipAnimation.play());
        beforeMount(() => {
            const { eventBus, store: { canvasState: { show }, }, } = contextRef.value;
            unmountedGroup.push(draggable$.pipe(debounceTime(50)).subscribe(onDraggableColumn), eventBus.on(Bus.BalanceRange.move).subscribe(moveBalance), watch(props.table, propName => {
                if (propName !== 'comment')
                    return;
                resetTooltip();
            }), watch(show, propName => {
                if (propName !== 'tableComment')
                    return;
                resetTooltip();
            }));
        });
        return () => {
            const { keymap, store: { canvasState: { show }, controlState: { allowEdit } }, } = contextRef.value;
            const { table } = props;
            const { ui, columns } = table;
            const widthColumn = table.maxWidthColumn();
            return html `
      <div
        class=${classMap({
            'kderd-table': true,
            active: ui.active,
        })}
        style=${styleMap({
            top: `${ui.top}px`,
            left: `${ui.left}px`,
            zIndex: `${ui.zIndex}`,
            width: `${table.width()}px`,
            height: `${table.height()}px`,
        })}
        data-id=${table.id}
        @mousedown=${onMoveStart}
        @touchstart=${onMoveStart}
      >
        <div class="kderd-table-header">
          <div class="kderd-table-header-top">
            ${allowEdit ?
            html `
                <kderd-icon
                  class="kderd-button kderd-table-button"
                  data-tippy-content=${`(${keymapOptionsToString(keymap.removeTable)})`}
                  name="times"
                  size="12"
                  @click=${onRemoveTable}
                ></kderd-icon>
                <kderd-icon
                  class="kderd-button kderd-table-button"
                  data-tippy-content=${`(${keymapOptionsToString(keymap.addColumn)})`}
                  name="plus"
                  size="12"
                  @click=${onAddColumn}
                ></kderd-icon>
              ` : null}

          </div>
          <div class="kderd-table-header-body">
            <kderd-input
              class="kderd-table-name"
              .width=${table.ui.widthName}
              .value=${table.name}
              .focusState=${hasFocusState('tableName')}
              .edit=${allowEdit && hasEdit('tableName')}
              placeholder="table"
              @input=${(event) => onInput(event, 'tableName')}
              @mousedown=${() => onFocus('tableName')}
              @dblclick=${onEdit}
              @kderd-input-blur=${onBlur}
            ></kderd-input>
            ${show.tableComment
            ? html `
                  <kderd-input
                    class="kderd-table-comment"
                    .width=${table.ui.widthComment}
                    .value=${table.comment}
                    .focusState=${hasFocusState('tableComment')}
                    .edit=${allowEdit && hasEdit('tableComment')}
                    placeholder="comment"
                    data-tippy-content=${table.comment.trim()
                ? table.comment
                : 'comment'}
                    @input=${(event) => onInput(event, 'tableComment')}
                    @mousedown=${() => onFocus('tableComment')}
                    @dblclick=${onEdit}
                    @kderd-input-blur=${onBlur}
                  ></kderd-input>
                `
            : null}
          </div>
        </div>
        <kderd-column-head
          .widthName=${widthColumn.name}
          .widthComment=${widthColumn.comment}
          .widthDataType=${widthColumn.dataType}
          .widthDefault=${widthColumn.default}
        >
        </kderd-column-head>
        <div
          class="kderd-table-body"
          @dragenter=${onPreventDefault}
          @dragover=${onPreventDefault}
        >
          ${repeat(columns, column => column.id, column => html `
                <kderd-column
                  .tableId=${table.id}
                  .column=${column}
                  .select=${hasSelectColumn(column.id)}
                  .draggable=${hasDraggableColumn(column.id)}
                  .focusName=${hasFocusState('columnName', column.id)}
                  .focusDataType=${hasFocusState('columnDataType', column.id)}
                  .focusNotNull=${hasFocusState('columnNotNull', column.id)}
                  .focusDefault=${hasFocusState('columnDefault', column.id)}
                  .focusComment=${hasFocusState('columnComment', column.id)}
                  .focusUnique=${hasFocusState('columnUnique', column.id)}
                  .focusAutoIncrement=${hasFocusState('columnAutoIncrement', column.id)}
                  .editName=${allowEdit && hasEdit('columnName', column.id)}
                  .editComment=${allowEdit && hasEdit('columnComment', column.id)}
                  .editDataType=${allowEdit && hasEdit('columnDataType', column.id)}
                  .editDefault=${allowEdit && hasEdit('columnDefault', column.id)}
                  .widthName=${widthColumn.name}
                  .widthComment=${widthColumn.comment}
                  .widthDataType=${widthColumn.dataType}
                  .widthDefault=${widthColumn.default}
                  @dragover-column=${onDragoverGroupColumn}
                ></kderd-column>
              `)}
        </div>
      </div>
    `;
        };
    };
    defineComponent('kderd-table', {
        observedProps: ['table', 'packages'],
        shadow: false,
        render: Table,
    });

    const TABLE_PADDING = (SIZE_TABLE_PADDING + SIZE_TABLE_BORDER) * 2;
    const ANIMATION_TIME$2 = 300;
    const HighLevelTable = (props, ctx) => {
        const contextRef = useContext(ctx);
        const { unmountedGroup } = useUnmounted();
        let leftTween = null;
        let topTween = null;
        const getFontSize = () => {
            const { zoomLevel } = contextRef.value.store.canvasState;
            let fontSize = 25;
            if (zoomLevel > 0.6) {
                fontSize = 25;
            }
            else if (zoomLevel > 0.5) {
                fontSize = 30;
            }
            else if (zoomLevel > 0.4) {
                fontSize = 35;
            }
            else if (zoomLevel > 0.3) {
                fontSize = 40;
            }
            else {
                fontSize = 45;
            }
            return fontSize;
        };
        const onMove = ({ event, movementX, movementY }) => {
            event.type === 'mousemove' && event.preventDefault();
            const { store } = contextRef.value;
            store.dispatch(moveTable(store, event.ctrlKey || event.metaKey, movementX, movementY, props.table.id));
        };
        const onMoveStart = (event) => {
            const el = event.target;
            const { store, globalEvent, eventBus } = contextRef.value;
            const { drag$ } = globalEvent;
            if (!el.closest('.kderd-button') && !el.closest('kderd-input')) {
                leftTween === null || leftTween === void 0 ? void 0 : leftTween.stop();
                topTween === null || topTween === void 0 ? void 0 : topTween.stop();
                drag$.subscribe({
                    next: onMove,
                    complete: () => eventBus.emit(Bus.BalanceRange.move),
                });
            }
            store.dispatch(selectTable$(store, event.ctrlKey || event.metaKey, props.table.id));
        };
        const moveBalance = () => {
            const { canvasState: { width, height }, tableState: { tables }, relationshipState: { relationships }, } = contextRef.value.store;
            const minWidth = width - (props.table.width() + TABLE_PADDING);
            const minHeight = height - (props.table.height() + TABLE_PADDING);
            const x = props.table.ui.left > minWidth ? minWidth : 0;
            const y = props.table.ui.top > minHeight ? minHeight : 0;
            if (props.table.ui.left < 0 || props.table.ui.left > minWidth) {
                leftTween = new Tween(props.table.ui)
                    .to({ left: x }, ANIMATION_TIME$2)
                    .easing(Easing.Quadratic.Out)
                    .onUpdate(() => relationshipSort(tables, relationships))
                    .onComplete(() => (leftTween = null))
                    .start();
            }
            if (props.table.ui.top < 0 || props.table.ui.top > minHeight) {
                topTween = new Tween(props.table.ui)
                    .to({ top: y }, ANIMATION_TIME$2)
                    .easing(Easing.Quadratic.Out)
                    .onUpdate(() => relationshipSort(tables, relationships))
                    .onComplete(() => (topTween = null))
                    .start();
            }
        };
        beforeMount(() => {
            const { eventBus } = contextRef.value;
            unmountedGroup.push(eventBus.on(Bus.BalanceRange.move).subscribe(moveBalance));
        });
        return () => {
            const { table } = props;
            const { ui } = table;
            table.maxWidthColumn();
            return html `
      <div
        class=${classMap({
            'kderd-table': true,
            active: ui.active,
        })}
        style=${styleMap({
            top: `${ui.top}px`,
            left: `${ui.left}px`,
            zIndex: `${ui.zIndex}`,
            width: `${table.width()}px`,
            height: `${table.height()}px`,
        })}
        @mousedown=${onMoveStart}
        @touchstart=${onMoveStart}
      >
        <div
          class="kderd-high-level-table kderd-scrollbar"
          style=${styleMap({
            fontSize: `${getFontSize()}px`,
        })}
        >
          ${table.name}
        </div>
      </div>
    `;
        };
    };
    defineComponent('kderd-high-level-table', {
        observedProps: ['table'],
        shadow: false,
        render: HighLevelTable,
    });

    const DrawRelationship = (props, ctx) => {
        const contextRef = useContext(ctx);
        const { unmountedGroup } = useUnmounted();
        beforeMount(() => {
            const { store } = contextRef.value;
            const erd = closestElement('.kderd-erd', ctx);
            if (!erd)
                return;
            unmountedGroup.push(fromEvent(erd, 'mousemove').subscribe(event => {
                event.preventDefault();
                const { x, y } = erd.getBoundingClientRect();
                store.dispatch(drawRelationship(event.clientX - x, event.clientY - y));
            }));
        });
        return () => {
            const { store: { canvasState }, } = contextRef.value;
            const { path, line } = getDraw(props.draw);
            return svg `
       <svg
        class="kderd-draw-relationship"
        style=${styleMap({
            width: `${canvasState.width}px`,
            height: `${canvasState.height}px`,
        })}
      >
        <g>
          <path
            d=${path.path.d()}
            stroke-dasharray="10"
            stroke-width="2"
            fill="transparent"
          ></path>
          <line
            x1=${path.line.start.x1} y1=${path.line.start.y1}
            x2=${path.line.start.x2} y2=${path.line.start.y2}
            stroke-width="2"
          ></line>
          <line
            x1=${line.start.base.x1} y1=${line.start.base.y1}
            x2=${line.start.base.x2} y2=${line.start.base.y2}
            stroke-width="2"
          ></line>
          <line
            x1=${line.start.base2.x1} y1=${line.start.base2.y1}
            x2=${line.start.base2.x2} y2=${line.start.base2.y2}
            stroke-width="2"
          ></line>
          <line
            x1=${line.start.center2.x1} y1=${line.start.center2.y1}
            x2=${line.start.center2.x2} y2=${line.start.center2.y2}
            stroke-width="2"
          ></line>
        </g>
      </svg>
  `;
        };
    };
    defineComponent('kderd-draw-relationship', {
        observedProps: ['draw'],
        shadow: false,
        render: DrawRelationship,
    });

    const relationshipZeroOneN = ({ path, line }) => svg `
    <line
      x1=${path.line.end.x1} y1=${path.line.end.y1}
      x2=${path.line.end.x2} y2=${path.line.end.y2}
      stroke-width="2"
    ></line>
    <circle
      cx=${line.circle.cx} cy=${line.circle.cy} r="8"
      fill-opacity="0.0"
      stroke-width="2"
    ></circle>
    <line
      x1=${line.line.end.base.x1} y1=${line.line.end.base.y1}
      x2=${line.line.end.base.x2} y2=${line.line.end.base.y2}
      stroke-width="2"
    ></line>
    <line
      x1=${line.line.end.left.x1} y1=${line.line.end.left.y1}
      x2=${line.line.end.left.x2} y2=${line.line.end.left.y2}
      stroke-width="2"
    ></line>
    <line
      x1=${line.line.end.center.x1} y1=${line.line.end.center.y1}
      x2=${line.line.end.center.x2} y2=${line.line.end.center.y2}
      stroke-width="2"
    ></line>
    <line
      x1=${line.line.end.right.x1} y1=${line.line.end.right.y1}
      x2=${line.line.end.right.x2} y2=${line.line.end.right.y2}
      stroke-width="2"
    ></line>
  `;
    const relationshipZeroOne = ({ path, line }) => svg `
    <line
      x1=${path.line.end.x1} y1=${path.line.end.y1}
      x2=${path.line.end.x2} y2=${path.line.end.y2}
      stroke-width="2"
    ></line>
    <circle
      cx=${line.circle.cx} cy=${line.circle.cy} r="8"
      fill-opacity="0.0"
      stroke-width="2"
    ></circle>
    <line
      x1=${line.line.end.base.x1} y1=${line.line.end.base.y1}
      x2=${line.line.end.base.x2} y2=${line.line.end.base.y2}
      stroke-width="2"
    ></line>
    <line
      x1=${line.line.end.center.x1} y1=${line.line.end.center.y1}
      x2=${line.line.end.center.x2} y2=${line.line.end.center.y2}
      stroke-width="2"
    ></line>
  `;
    const relationshipZeroN = ({ path, line }) => svg `
    <line
      x1=${path.line.end.x1} y1=${path.line.end.y1}
      x2=${path.line.end.x2} y2=${path.line.end.y2}
      stroke-width="2"
    ></line>
    <circle
      cx=${line.circle.cx} cy=${line.circle.cy} r="8"
      fill-opacity="0.0"
      stroke-width="2"
    ></circle>
    <line
      x1=${line.line.end.left.x1} y1=${line.line.end.left.y1}
      x2=${line.line.end.left.x2} y2=${line.line.end.left.y2}
      stroke-width="2"
    ></line>
    <line
      x1=${line.line.end.center.x1} y1=${line.line.end.center.y1}
      x2=${line.line.end.center.x2} y2=${line.line.end.center.y2}
      stroke-width="2"
    ></line>
    <line
      x1=${line.line.end.right.x1} y1=${line.line.end.right.y1}
      x2=${line.line.end.right.x2} y2=${line.line.end.right.y2}
      stroke-width="2"
    ></line>
  `;
    const relationshipOneOnly = ({ path, line }) => svg `
    <line
      x1=${path.line.end.x1} y1=${path.line.end.y1}
      x2=${path.line.end.x2} y2=${path.line.end.y2}
      stroke-width="2"
    ></line>
    <line
      x1=${line.line.end.base.x1} y1=${line.line.end.base.y1}
      x2=${line.line.end.base.x2} y2=${line.line.end.base.y2}
      stroke-width="2"
    ></line>
    <line
      x1=${line.line.end.base2.x1} y1=${line.line.end.base2.y1}
      x2=${line.line.end.base2.x2} y2=${line.line.end.base2.y2}
      stroke-width="2"
    ></line>
    <line
      x1=${line.line.end.center2.x1} y1=${line.line.end.center2.y1}
      x2=${line.line.end.center2.x2} y2=${line.line.end.center2.y2}
      stroke-width="2"
    ></line>
  `;
    const relationshipOneN = ({ path, line }) => svg `
    <line
      x1=${path.line.end.x1} y1=${path.line.end.y1}
      x2=${path.line.end.x2} y2=${path.line.end.y2}
      stroke-width="2"
    ></line>
    <line
      x1=${line.line.end.base.x1} y1=${line.line.end.base.y1}
      x2=${line.line.end.base.x2} y2=${line.line.end.base.y2}
      stroke-width="2"
    ></line>
    <line
      x1=${line.line.end.left.x1} y1=${line.line.end.left.y1}
      x2=${line.line.end.left.x2} y2=${line.line.end.left.y2}
      stroke-width="2"
    ></line>
    <line
      x1=${line.line.end.center2.x1} y1=${line.line.end.center2.y1}
      x2=${line.line.end.center2.x2} y2=${line.line.end.center2.y2}
      stroke-width="2"
    ></line>
    <line
      x1=${line.line.end.right.x1} y1=${line.line.end.right.y1}
      x2=${line.line.end.right.x2} y2=${line.line.end.right.y2}
      stroke-width="2"
    ></line>
  `;
    const relationshipOne = ({ path, line }) => svg `
    <line
      x1=${path.line.end.x1} y1=${path.line.end.y1}
      x2=${path.line.end.x2} y2=${path.line.end.y2}
      stroke-width="2"
    ></line>
    <line
      x1=${line.line.end.base.x1} y1=${line.line.end.base.y1}
      x2=${line.line.end.base.x2} y2=${line.line.end.base.y2}
      stroke-width="2"
    ></line>
    <line
      x1=${line.line.end.center2.x1} y1=${line.line.end.center2.y1}
      x2=${line.line.end.center2.x2} y2=${line.line.end.center2.y2}
      stroke-width="2"
    ></line>
  `;
    const relationshipN = ({ path, line }) => svg `
    <line
      x1=${path.line.end.x1} y1=${path.line.end.y1}
      x2=${path.line.end.x2} y2=${path.line.end.y2}
      stroke-width="2"
    ></line>
    <line
      x1=${line.line.end.left.x1} y1=${line.line.end.left.y1}
      x2=${line.line.end.left.x2} y2=${line.line.end.left.y2}
      stroke-width="2"
    ></line>
    <line
      x1=${line.line.end.center2.x1} y1=${line.line.end.center2.y1}
      x2=${line.line.end.center2.x2} y2=${line.line.end.center2.y2}
      stroke-width="2"
    ></line>
    <line
      x1=${line.line.end.right.x1} y1=${line.line.end.right.y1}
      x2=${line.line.end.right.x2} y2=${line.line.end.right.y2}
      stroke-width="2"
    ></line>
  `;
    const relationshipShapeMap = {
        ZeroOneN: relationshipZeroOneN,
        ZeroOne: relationshipZeroOne,
        ZeroN: relationshipZeroN,
        OneOnly: relationshipOneOnly,
        OneN: relationshipOneN,
        One: relationshipOne,
        N: relationshipN,
    };
    function relationshipTpl(relationship, strokeWidth = 2) {
        const relationshipPath = getRelationshipPath(relationship);
        const { path, line } = relationshipPath;
        const relationshipShapeTpl = relationshipShapeMap[relationship.relationshipType];
        const shape = relationshipShapeTpl
            ? relationshipShapeTpl(relationshipPath)
            : null;
        return relationship.startRelationshipType === 'Ring'
            ? svg `
        <path
          d=${path.path.d()}
          stroke-dasharray=${relationship.identification ? 0 : 10}
          stroke-width=${strokeWidth}
          fill="transparent"
        ></path>
        <line
          x1=${path.line.start.x1} y1=${path.line.start.y1}
          x2=${path.line.start.x2} y2=${path.line.start.y2}
          stroke-width="2"
        ></line>
        <circle
          cx=${line.startCircle.cx} cy=${line.startCircle.cy} r="8"
          fill-opacity="0.0"
          stroke-width="2"
        ></circle>
        <line
          x1=${line.line.start.base.x1} y1=${line.line.start.base.y1}
          x2=${line.line.start.base.x2} y2=${line.line.start.base.y2}
          stroke-width="2"
        ></line>
        <line
          x1=${line.line.start.center.x1} y1=${line.line.start.center.y1}
          x2=${line.line.start.center.x2} y2=${line.line.start.center.y2}
          stroke-width="2"
        ></line>
        ${shape}
    `
            : svg `
        <path
          d=${path.path.d()}
          stroke-dasharray=${relationship.identification ? 0 : 10}
          stroke-width=${strokeWidth}
          fill="transparent"
        ></path>
        <line
          x1=${path.line.start.x1} y1=${path.line.start.y1}
          x2=${path.line.start.x2} y2=${path.line.start.y2}
          stroke-width="2"
        ></line>
        <line
          x1=${line.line.start.base.x1} y1=${line.line.start.base.y1}
          x2=${line.line.start.base.x2} y2=${line.line.start.base.y2}
          stroke-width="2"
        ></line>
        <line
          x1=${line.line.start.base2.x1} y1=${line.line.start.base2.y1}
          x2=${line.line.start.base2.x2} y2=${line.line.start.base2.y2}
          stroke-width="2"
        ></line>
        <line
          x1=${line.line.start.center2.x1} y1=${line.line.start.center2.y1}
          x2=${line.line.start.center2.x2} y2=${line.line.start.center2.y2}
          stroke-width="2"
        ></line>
        ${shape}
    `;
    }

    const CanvasSVG = (props, ctx) => {
        const contextRef = useContext(ctx);
        const state = observable$1({ activeId: '' });
        const onMouseover = (relationship) => {
            const { store } = contextRef.value;
            store.dispatch(activeColumn(relationship));
            state.activeId = relationship.id;
        };
        const onMouseleave = (relationship) => {
            const { store } = contextRef.value;
            store.dispatch(activeEndColumn(relationship));
            state.activeId = '';
        };
        return () => {
            const { store: { canvasState: { width, height }, relationshipState: { relationships }, }, } = contextRef.value;
            return svg `
      <svg 
        class="kderd-canvas-svg"
        style=${styleMap({
            width: `${width}px`,
            height: `${height}px`,
        })}
      >
      ${repeat(relationships, relationship => relationship.id, relationship => svg `
            <g class=${classMap({
            'kderd-relationship': true,
            identification: relationship.identification &&
                state.activeId !== relationship.id,
            active: state.activeId === relationship.id,
        })}
              data-id=${relationship.id}
              @mouseover=${() => onMouseover(relationship)}
              @mouseleave=${() => onMouseleave(relationship)}
            >
              ${relationshipTpl(relationship)}
            </g>
          `)}
    </svg>
`;
        };
    };
    defineComponent('kderd-canvas-svg', {
        shadow: false,
        render: CanvasSVG,
    });

    /**
     * @license
     * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */
    const templateCaches = new WeakMap();
    /**
     * Enables fast switching between multiple templates by caching the DOM nodes
     * and TemplateInstances produced by the templates.
     *
     * Example:
     *
     * ```
     * let checked = false;
     *
     * html`
     *   ${cache(checked ? html`input is checked` : html`input is not checked`)}
     * `
     * ```
     */
    const cache = directive((value) => (part) => {
        if (!(part instanceof NodePart)) {
            throw new Error('cache can only be used in text bindings');
        }
        let templateCache = templateCaches.get(part);
        if (templateCache === undefined) {
            templateCache = new WeakMap();
            templateCaches.set(part, templateCache);
        }
        const previousValue = part.value;
        // First, can we update the current TemplateInstance, or do we need to move
        // the current nodes into the cache?
        if (previousValue instanceof TemplateInstance) {
            if (value instanceof TemplateResult &&
                previousValue.template === part.options.templateFactory(value)) {
                // Same Template, just trigger an update of the TemplateInstance
                part.setValue(value);
                return;
            }
            else {
                // Not the same Template, move the nodes from the DOM into the cache.
                let cachedTemplate = templateCache.get(previousValue.template);
                if (cachedTemplate === undefined) {
                    cachedTemplate = {
                        instance: previousValue,
                        nodes: document.createDocumentFragment(),
                    };
                    templateCache.set(previousValue.template, cachedTemplate);
                }
                reparentNodes(cachedTemplate.nodes, part.startNode.nextSibling, part.endNode);
            }
        }
        // Next, can we reuse nodes from the cache?
        if (value instanceof TemplateResult) {
            const template = part.options.templateFactory(value);
            const cachedTemplate = templateCache.get(template);
            if (cachedTemplate !== undefined) {
                // Move nodes out of cache
                part.setValue(cachedTemplate.nodes);
                part.commit();
                // Set the Part value to the TemplateInstance so it'll update it.
                part.value = cachedTemplate.instance;
            }
        }
        part.setValue(value);
    });

    function useRenderTrigger() {
        const state = observable$1({ count: 0 });
        const renderTrigger = () => state.count++;
        beforeFirstUpdate(() => state.count);
        beforeUpdate(() => state.count);
        return {
            renderTrigger,
        };
    }

    const Canvas = (props, ctx) => {
        const contextRef = useContext(ctx);
        const { unmountedGroup } = useUnmounted();
        const { renderTrigger } = useRenderTrigger();
        beforeMount(() => {
            const { memoState: { memos }, tableState: { tables }, } = contextRef.value.store;
            unmountedGroup.push(watch(tables, renderTrigger), watch(memos, renderTrigger));
        });
        return () => {
            const { canvasState: { width, height, scrollTop, scrollLeft, zoomLevel, show }, memoState: { memos }, tableState: { tables }, editorState: { drawRelationship }, } = contextRef.value.store;
            return html `
      <div
        class="kderd-canvas"
        style=${styleMap({
            width: `${width}px`,
            height: `${height}px`,
            top: `${scrollTop}px`,
            left: `${scrollLeft}px`,
            transform: `scale(${zoomLevel})`,
        })}
      >
        ${repeat(tables, pkg => pkg.id, pkg => html `<kderd-package .pkg=${pkg} .tables=${tables}></kderd-package>`)}
        ${cache(zoomLevel > 0.7
            ? repeat(tables, table => table.id, table => html `<kderd-table
                    .table=${table}
                  ></kderd-table>`)
            : repeat(tables, table => table.id, table => html `
                    <kderd-high-level-table
                      .table=${table}
                    ></kderd-high-level-table>
                  `))}
        ${repeat(memos, memo => memo.id, memo => html `<kderd-memo .memo=${memo}></kderd-memo>`)}
        ${show.relationship
            ? html `<kderd-canvas-svg></kderd-canvas-svg>`
            : null}
        ${(drawRelationship === null || drawRelationship === void 0 ? void 0 : drawRelationship.start)
            ? html `
              <kderd-draw-relationship
                .draw=${drawRelationship}
              ></kderd-draw-relationship>
            `
            : null}
      </div>
    `;
        };
    };
    defineComponent('kderd-canvas', {
        shadow: false,
        render: Canvas,
    });

    function getOverlapPosition(dragRect, rect) {
        if (dragRect.x > rect.x + rect.w ||
            dragRect.x + dragRect.w < rect.x ||
            dragRect.y > rect.y + rect.h ||
            dragRect.y + dragRect.h < rect.y)
            return null;
        const target = { x1: 0, y1: 0, x2: 0, y2: 0 };
        target.x1 = Math.max(dragRect.x, rect.x);
        target.y1 = Math.max(dragRect.y, rect.y);
        target.x2 = Math.min(dragRect.x + dragRect.w, rect.x + rect.w) - rect.x;
        target.y2 = Math.min(dragRect.y + dragRect.h, rect.y + rect.h) - rect.y;
        return target;
    }
    function getZoomViewport(width, height, zoomLevel) {
        const viewport = { x: 0, y: 0, w: 0, h: 0 };
        viewport.w = width * zoomLevel;
        viewport.h = height * zoomLevel;
        viewport.x = (width - viewport.w) / 2;
        viewport.y = (height - viewport.h) / 2;
        return viewport;
    }
    const getAbsolutePosition = (overlapPosition, zoomViewport, zoomLevel) => ({
        x1: (overlapPosition.x1 - zoomViewport.x) / zoomLevel,
        y1: (overlapPosition.y1 - zoomViewport.y) / zoomLevel,
        x2: overlapPosition.x2 / zoomLevel,
        y2: overlapPosition.y2 / zoomLevel,
    });

    const DragSelect = (props, ctx) => {
        const contextRef = useContext(ctx);
        const state = observable$1({ width: 0, height: 0, top: 0, left: 0 });
        const { unmountedGroup } = useUnmounted();
        const onGlobalMouseup = () => {
            ctx.dispatchEvent(new CustomEvent('drag-select-end'));
        };
        beforeMount(() => {
            const { store, globalEvent: { mouseup$ }, } = contextRef.value;
            const { canvasState } = store;
            const erd = closestElement('.kderd-erd', ctx);
            if (!erd)
                return;
            unmountedGroup.push(mouseup$.subscribe(onGlobalMouseup), fromEvent(erd, 'mousemove').subscribe(event => {
                event.preventDefault();
                const rect = erd.getBoundingClientRect();
                const currentX = event.clientX - rect.x;
                const currentY = event.clientY - rect.y;
                const min = {
                    x: props.x < currentX ? props.x : currentX,
                    y: props.y < currentY ? props.y : currentY,
                };
                const max = {
                    x: props.x > currentX ? props.x : currentX,
                    y: props.y > currentY ? props.y : currentY,
                };
                state.left = min.x;
                state.width = max.x - min.x;
                if (state.width < 0) {
                    state.width = 0;
                }
                state.top = min.y;
                state.height = max.y - min.y;
                if (state.height < 0) {
                    state.height = 0;
                }
                const ghostMin = Object.assign({}, min);
                const ghostMax = Object.assign({}, max);
                ghostMin.x -= canvasState.scrollLeft;
                ghostMin.y -= canvasState.scrollTop;
                ghostMax.x -= canvasState.scrollLeft;
                ghostMax.y -= canvasState.scrollTop;
                const zoomViewportRect = getZoomViewport(canvasState.width, canvasState.height, canvasState.zoomLevel);
                const overlapPosition = getOverlapPosition(Object.assign(Object.assign({}, ghostMin), { w: ghostMax.x - ghostMin.x, h: ghostMax.y - ghostMin.y }), zoomViewportRect);
                if (!overlapPosition)
                    return;
                const absolutePosition = getAbsolutePosition(overlapPosition, zoomViewportRect, canvasState.zoomLevel);
                ghostMin.x = absolutePosition.x1;
                ghostMin.y = absolutePosition.y1;
                ghostMax.x = absolutePosition.x2;
                ghostMax.y = absolutePosition.y2;
                store.dispatch(dragSelectTable(ghostMin, ghostMax), dragSelectMemo(ghostMin, ghostMax));
            }));
        });
        return () => {
            return svg `
      <svg 
        class="kderd-drag-select" 
        style=${styleMap({
            top: `${state.top}px`,
            left: `${state.left}px`,
            width: `${state.width}px`,
            height: `${state.height}px`,
        })}
      >
        <rect
          width=${state.width}
          height=${state.height}
          stroke-width="1"
          stroke-opacity="0.9"
          stroke-dasharray="3"
          fill-opacity="0.3"
        >
        </rect>
      </svg>    
    `;
        };
    };
    defineComponent('kderd-drag-select', {
        observedProps: ['x', 'y'],
        shadow: false,
        render: DragSelect,
    });

    const MinimapTable = (props, ctx) => () => {
        const { table } = props;
        const { ui } = table;
        table.maxWidthColumn();
        return html `
    <div
      class="kderd-table"
      style=${styleMap({
        top: `${ui.top}px`,
        left: `${ui.left}px`,
        zIndex: `${ui.zIndex}`,
        width: `${table.width()}px`,
        height: `${table.height()}px`,
    })}
    ></div>
  `;
    };
    defineComponent('kderd-minimap-table', {
        observedProps: ['table'],
        shadow: false,
        render: MinimapTable,
    });

    const MEMO_PADDING = SIZE_MEMO_PADDING * 2;
    const MEMO_HEADER = 6 + MEMO_PADDING;
    const MinimapMemo = (props, ctx) => () => {
        const { memo } = props;
        const width = memo.ui.width + MEMO_PADDING;
        const height = memo.ui.height + MEMO_PADDING + MEMO_HEADER;
        return html `
      <div
        class="kderd-memo"
        style=${styleMap({
        top: `${memo.ui.top}px`,
        left: `${memo.ui.left}px`,
        zIndex: `${memo.ui.zIndex}`,
        width: `${width}px`,
        height: `${height}px`,
    })}
      ></div>
    `;
    };
    defineComponent('kderd-minimap-memo', {
        observedProps: ['memo'],
        shadow: false,
        render: MinimapMemo,
    });

    const MinimapHandle = (props, ctx) => {
        const contextRef = useContext(ctx);
        const getRatio = () => {
            const { width } = contextRef.value.store.canvasState;
            return SIZE_MINIMAP_WIDTH / width;
        };
        const getStyleMap = () => {
            const { scrollLeft, scrollTop } = contextRef.value.store.canvasState;
            const ratio = getRatio();
            const x = scrollLeft * ratio;
            const y = scrollTop * ratio;
            const left = props.width - SIZE_MINIMAP_WIDTH - SIZE_MINIMAP_MARGIN - x;
            const top = SIZE_MINIMAP_MARGIN - y;
            return {
                width: `${props.width * ratio}px`,
                height: `${props.height * ratio}px`,
                left: `${left}px`,
                top: `${top}px`,
            };
        };
        const onMove = ({ event, movementX, movementY }) => {
            event.type === 'mousemove' && event.preventDefault();
            const { store } = contextRef.value;
            const ratio = getRatio();
            store.dispatch(movementCanvas((movementX / ratio) * -1, (movementY / ratio) * -1));
        };
        const onMoveStart = () => {
            const { globalEvent: { drag$ }, } = contextRef.value;
            drag$.subscribe(onMove);
        };
        return () => html `
    <div
      class="kderd-minimap-handle"
      style=${styleMap(getStyleMap())}
      @mousedown=${onMoveStart}
      @touchstart=${onMoveStart}
    ></div>
  `;
    };
    defineComponent('kderd-minimap-handle', {
        observedProps: ['width', 'height'],
        shadow: false,
        render: MinimapHandle,
    });

    const Minimap = (props, ctx) => {
        const contextRef = useContext(ctx);
        const { unmountedGroup } = useUnmounted();
        const { renderTrigger } = useRenderTrigger();
        const getStyleMap = () => {
            const { width, height } = contextRef.value.store.canvasState;
            const ratio = SIZE_MINIMAP_WIDTH / width;
            const x = (-1 * width) / 2 + SIZE_MINIMAP_WIDTH / 2;
            const y = (-1 * height) / 2 + (height * ratio) / 2;
            const left = x - SIZE_MINIMAP_WIDTH - SIZE_MINIMAP_MARGIN + props.width;
            const top = y + SIZE_MINIMAP_MARGIN;
            return {
                transform: `scale(${ratio}, ${ratio})`,
                width: `${width}px`,
                height: `${height}px`,
                left: `${left}px`,
                top: `${top}px`,
            };
        };
        const getShadowStyle = () => {
            const left = props.width - SIZE_MINIMAP_WIDTH - SIZE_MINIMAP_MARGIN;
            const top = SIZE_MINIMAP_MARGIN;
            return {
                width: `${SIZE_MINIMAP_WIDTH}px`,
                height: `${SIZE_MINIMAP_WIDTH}px`,
                left: `${left}px`,
                top: `${top}px`,
            };
        };
        beforeMount(() => {
            const { memoState: { memos }, tableState: { tables }, relationshipState: { relationships }, } = contextRef.value.store;
            unmountedGroup.push(watch(tables, renderTrigger), watch(memos, renderTrigger), watch(relationships, renderTrigger));
        });
        return () => {
            const { canvasState: { width, height, zoomLevel, show }, tableState: { tables }, memoState: { memos }, relationshipState: { relationships }, } = contextRef.value.store;
            return html `
      <div
        class="kderd-minimap-shadow"
        style=${styleMap(getShadowStyle())}
      ></div>
      <div class="kderd-minimap" style=${styleMap(getStyleMap())}>
        <div class="kderd-erd-background"></div>
        <div
          class="kderd-canvas"
          style=${styleMap({
            width: `${width}px`,
            height: `${height}px`,
            transform: `scale(${zoomLevel})`,
        })}
        >
          ${repeat(tables, table => table.id, table => html `
                <kderd-minimap-table .table=${table}></kderd-minimap-table>
              `)}
          ${repeat(memos, memo => memo.id, memo => html `<kderd-minimap-memo .memo=${memo}></kderd-minimap-memo>`)}
          ${show.relationship
            ? svg `
              <svg
                class="kderd-canvas-svg"
                style=${styleMap({
                width: `${width}px`,
                height: `${height}px`,
            })}
              >
              ${repeat(relationships, relationship => relationship.id, relationship => {
                const shape = relationshipTpl(relationship, 12);
                return svg `
                  <g
                    class=${classMap({
                    'kderd-relationship': true,
                    identification: relationship.identification,
                })}
                  >
                    ${shape}
                  </g>
                `;
            })}
              </svg>
          `
            : null}
        </div>
      </div>
      <kderd-minimap-handle
        .width=${props.width}
        .height=${props.height}
      ></kderd-minimap-handle>
    `;
        };
    };
    defineComponent('kderd-minimap', {
        observedProps: ['width', 'height'],
        shadow: false,
        render: Minimap,
    });

    const findIndex$1 = findIndex$4(propEq$1('active', true));
    function useTableHint(ctx) {
        const contextRef = useContext(ctx);
        const { unmountedGroup } = useUnmounted();
        const state = observable$1({
            value: '',
            hints: [],
            isFilter: true,
            focus: false,
        });
        const inputRef = query('input');
        const getActiveIndex = () => findIndex$1(state.hints);
        const setHints = () => {
            if (!state.isFilter)
                return;
            const { store: { tableState: { tables }, }, } = contextRef.value;
            state.hints =
                state.value.trim().length < 1
                    ? []
                    : tables
                        .filter(table => table.name.toLowerCase().indexOf(state.value.toLowerCase()) !==
                        -1)
                        .map(column => {
                        return {
                            id: column.id,
                            name: column.name,
                            html: markToHTML('kderd-find-table-hint-mark', column.name, state.value),
                            active: false,
                        };
                    });
        };
        const activeEnd = () => {
            state.hints.forEach(hint => (hint.active = false));
        };
        const moveCanvasFindTable = (table) => {
            const { store } = contextRef.value;
            store.dispatch(moveCanvas((table.ui.top - SIZE_START_Y) * -1, (table.ui.left - SIZE_START_X) * -1), selectTable(store, false, table.id));
        };
        const onSelectHint = (hint) => {
            activeEnd();
            state.isFilter = false;
            lastCursorFocus(inputRef.value);
            const { tables } = contextRef.value.store.tableState;
            const table = getData(tables, hint.id);
            if (table) {
                moveCanvasFindTable(table);
            }
        };
        const onArrowUp = (event) => {
            state.hints.length !== 0 && event.preventDefault();
            const index = getActiveIndex();
            if (index > 0) {
                state.hints[index].active = false;
                state.hints[index - 1].active = true;
            }
            else if (state.hints.length) {
                index === 0 && (state.hints[index].active = false);
                state.hints[state.hints.length - 1].active = true;
            }
        };
        const onArrowDown = (event) => {
            state.hints.length !== 0 && event.preventDefault();
            const index = getActiveIndex();
            if (index !== -1 && index !== state.hints.length - 1) {
                state.hints[index].active = false;
                state.hints[index + 1].active = true;
            }
            else if (state.hints.length) {
                index === state.hints.length - 1 && (state.hints[index].active = false);
                state.hints[0].active = true;
            }
        };
        const onArrowLeft = () => activeEnd();
        const onArrowRight = (event) => {
            const index = getActiveIndex();
            if (index < 0)
                return;
            event.preventDefault();
            state.isFilter = false;
            const { tables } = contextRef.value.store.tableState;
            const table = getData(tables, state.hints[index].id);
            if (table) {
                moveCanvasFindTable(table);
            }
        };
        const arrowMap = {
            ArrowUp: onArrowUp,
            ArrowDown: onArrowDown,
            ArrowLeft: onArrowLeft,
            ArrowRight: onArrowRight,
        };
        const onKeydown = (event) => {
            switch (event.key) {
                case 'ArrowUp':
                case 'ArrowDown':
                case 'ArrowLeft':
                case 'ArrowRight':
                    arrowMap[event.key](event);
                    break;
                case 'Enter':
                    arrowMap.ArrowRight(event);
                    break;
            }
        };
        const onInput = (event) => {
            const input = event.target;
            state.value = input.value;
            state.isFilter = true;
        };
        const initHints = () => {
            state.isFilter = true;
            setHints();
        };
        beforeMount(() => unmountedGroup.push(watch(state, propName => {
            if (propName !== 'value')
                return;
            setHints();
        })));
        return {
            hintState: state,
            onSelectHint,
            onKeydown,
            onInput,
            initHints,
        };
    }

    const hintTpl$1 = (props, state) => html `
  <ul class="kderd-find-table-list">
    ${repeat(state.hints, hint => hint.id, hint => {
    return html `
          <li
            class=${classMap({
        'kderd-find-table-hint': true,
        active: hint.active,
    })}
            @click=${() => props.onSelectHint(hint)}
          >
            ${unsafeHTML(hint.html)}
          </li>
        `;
})}
  </ul>
`;

    const ANIMATION_TIME$1 = 200;
    const HEIGHT = 33;
    const Find = (props, ctx) => {
        const contextRef = useContext(ctx);
        const { unmountedGroup } = useUnmounted();
        const { resetTooltip } = useTooltip(['.kderd-button'], ctx);
        const { hintState, onSelectHint, onKeydown, onInput, initHints } = useTableHint(ctx);
        const inputRef = query('input');
        const state = observable$1({ top: 0, visible: false });
        let openTween = null;
        let closeTween = null;
        useFlipAnimation(ctx, '.kderd-find-table-hint', 'kderd-find-table-hint-move');
        const emitBlur = () => ctx.dispatchEvent(new CustomEvent('kderd-input-blur', {
            composed: true,
            bubbles: true,
        }));
        const onOpen = () => {
            if (openTween)
                return;
            closeTween === null || closeTween === void 0 ? void 0 : closeTween.stop();
            closeTween = null;
            state.visible = true;
            state.top = state.top === 0 ? -1 * HEIGHT : state.top;
            openTween = new Tween(state)
                .to({ top: 0 }, ANIMATION_TIME$1)
                .easing(Easing.Quadratic.Out)
                .onComplete(() => (openTween = null))
                .start();
        };
        const onClose = () => {
            if (closeTween)
                return;
            openTween === null || openTween === void 0 ? void 0 : openTween.stop();
            openTween = null;
            closeTween = new Tween(state)
                .to({ top: -1 * HEIGHT }, ANIMATION_TIME$1)
                .easing(Easing.Quadratic.In)
                .onComplete(() => {
                closeTween = null;
                state.visible = false;
                ctx.dispatchEvent(new CustomEvent('close'));
                emitBlur();
            })
                .start();
        };
        const focus = () => {
            const input = inputRef.value;
            input === null || input === void 0 ? void 0 : input.focus();
        };
        const onFocus = () => {
            hintState.focus = true;
        };
        const onBlur = () => {
            hintState.focus = false;
            setTimeout(() => {
                if (hintState.focus)
                    return;
                hintState.hints = [];
            }, 200);
        };
        beforeMount(() => unmountedGroup.push(watch(props, propName => {
            if (propName !== 'visible')
                return;
            props.visible ? onOpen() : onClose();
            props.visible &&
                setTimeout(() => {
                    resetTooltip();
                    focus();
                    initHints();
                }, 0);
        })));
        return () => {
            const { keymap } = contextRef.value;
            const keymapStop = keymapOptionsToString(keymap.stop);
            return state.visible
                ? html `
          <div
            class="kderd-find"
            style=${styleMap({
                top: `${state.top}px`,
                height: `${HEIGHT}px`,
            })}
          >
            <div class="kderd-find-table">
              <input
                type="text"
                spellcheck="false"
                placeholder="table"
                .value=${hintState.value}
                @keydown=${onKeydown}
                @input=${onInput}
                @focus=${onFocus}
                @blur=${onBlur}
              />
              ${hintTpl$1({ onSelectHint }, hintState)}
            </div>
            <kderd-icon
              class="kderd-button"
              data-tippy-content=${keymapStop}
              name="times"
              size="12"
              @click=${onClose}
            ></kderd-icon>
          </div>
        `
                : null;
        };
    };
    defineComponent('kderd-find', {
        observedProps: [
            {
                name: 'visible',
                type: Boolean,
                default: false,
            },
        ],
        shadow: false,
        render: Find,
    });

    const defaultOptions$a = {
        nameWidth: 80,
        keymapWidth: 0,
        close: false,
    };
    const createDatabaseMenus = ({ store }) => databaseList.map(databaseType => ({
        icon: store.canvasState.database === databaseType
            ? {
                prefix: 'fas',
                name: 'check',
            }
            : undefined,
        name: databaseType,
        execute: () => store.dispatch(changeDatabase(databaseType)),
        options: Object.assign({}, defaultOptions$a),
    }));

    const relationshipMenus = [
        {
            name: 'Zero One',
            relationshipType: 'ZeroOne',
            keymapName: 'relationshipZeroOne',
        },
        {
            name: 'Zero N',
            relationshipType: 'ZeroN',
            keymapName: 'relationshipZeroN',
        },
        {
            name: 'One Only',
            relationshipType: 'OneOnly',
            keymapName: 'relationshipOneOnly',
        },
        {
            name: 'One N',
            relationshipType: 'OneN',
            keymapName: 'relationshipOneN',
        },
    ];
    const defaultOptions$9 = {
        nameWidth: 75,
        keymapWidth: 85,
    };
    const createDrawRelationshipMenus = ({ keymap, store, }) => relationshipMenus.map(relationshipMenu => ({
        iconBase64: getBase64Icon(relationshipMenu.relationshipType),
        name: relationshipMenu.name,
        keymap: keymapOptionToString(keymap[relationshipMenu.keymapName][0]),
        keymapTooltip: keymapOptionsToString(keymap[relationshipMenu.keymapName]),
        execute: () => store.dispatch(drawStartRelationship$(store, relationshipMenu.relationshipType)),
        options: Object.assign({}, defaultOptions$9),
    }));

    const defaultOptions$8 = {
        nameWidth: 60,
        keymapWidth: 0,
    };
    const liquibaseOptions = {
        nameWidth: 75,
        keymapWidth: 0,
    };
    const createImportMenus = (context) => [
        {
            icon: {
                prefix: 'mdi',
                name: 'code-json',
                size: 18,
            },
            name: 'json',
            execute: () => importJSON(context),
        },
        {
            icon: {
                prefix: 'mdi',
                name: 'database-import',
                size: 18,
            },
            name: 'SQL DDL',
            execute: () => importSQLDDL(context),
        },
        {
            icon: {
                prefix: 'mdi',
                name: 'xml',
                size: 18,
            },
            name: 'Liquibase',
            children: [
                {
                    icon: {
                        prefix: 'mdi',
                        name: 'xml',
                        size: 18,
                    },
                    name: 'PostgreSQL',
                    execute: () => importLiquibase(context, 'postgresql'),
                },
                {
                    icon: {
                        prefix: 'mdi',
                        name: 'xml',
                        size: 18,
                    },
                    name: 'Oracle',
                    execute: () => importLiquibase(context, 'oracle'),
                },
                {
                    icon: {
                        prefix: 'mdi',
                        name: 'xml',
                        size: 18,
                    },
                    name: 'MSSQL',
                    execute: () => importLiquibase(context, 'mssql'),
                },
            ].map(menu => (Object.assign(Object.assign({}, menu), { options: Object.assign({}, liquibaseOptions) }))),
        },
    ].map(menu => (Object.assign(Object.assign({}, menu), { options: Object.assign({}, defaultOptions$8) })));

    const showMenus = [
        {
            name: '',
            showKey: 'tableComment',
        },
        {
            name: '',
            showKey: 'columnComment',
        },
        {
            name: '',
            showKey: 'columnDataType',
        },
        {
            name: '',
            showKey: 'columnDefault',
        },
        {
            name: '',
            showKey: 'columnNotNull',
        },
        {
            name: '',
            showKey: 'relationship',
        },
    ];
    const defaultOptions$7 = {
        nameWidth: 115,
        keymapWidth: 0,
        close: false,
    };
    const createShowMenus = ({ store }) => showMenus.map(showMenu => ({
        icon: store.canvasState.show[showMenu.showKey]
            ? {
                prefix: 'fas',
                name: 'check',
            }
            : undefined,
        name: showMenu.name,
        execute: () => store.dispatch(changeCanvasShow(store, showMenu.showKey)),
        options: Object.assign({}, defaultOptions$7),
    }));

    const defaultOptions$6 = {
        nameWidth: 75,
        keymapWidth: 50,
    };
    function createERDMenus(context, canvas) {
        const { store, keymap } = context;
        const { controlState: { allowEdit } } = store;
        if (allowEdit) {
            return [
                {
                    icon: {
                        prefix: 'fas',
                        name: 'table',
                    },
                    name: '',
                    keymap: keymapOptionToString(keymap.addTable[0]),
                    keymapTooltip: keymapOptionsToString(keymap.addTable),
                    execute: () => store.dispatch(addTable$(store)),
                },
                {
                    icon: {
                        prefix: 'mdi',
                        name: 'vector-line',
                        size: 18,
                    },
                    name: '',
                    children: createDrawRelationshipMenus(context),
                },
                {
                    icon: {
                        prefix: 'fas',
                        name: 'eye',
                    },
                    name: '',
                    children: createShowMenus(context),
                },
                {
                    icon: {
                        prefix: 'mdi',
                        name: 'database',
                        size: 18,
                    },
                    name: '',
                    children: createDatabaseMenus(context),
                },
                {
                    icon: {
                        prefix: 'fas',
                        name: 'file-import',
                    },
                    name: '',
                    children: createImportMenus(context),
                },
                {
                    icon: {
                        prefix: 'fas',
                        name: 'file-export',
                    },
                    name: '',
                    children: createExportMenus(context, canvas),
                },
            ].map(menu => (Object.assign(Object.assign({}, menu), { options: Object.assign({}, defaultOptions$6) })));
        }
        else {
            return [
                // {
                //   icon: {
                //     prefix: 'fas',
                //     name: 'folder',
                //   },
                //   name: '(package)',
                //   keymap: keymapOptionToString(keymap.addPackage[0]),
                //   keymapTooltip: keymapOptionsToString(keymap.addPackage),
                //   execute: () => store.dispatch(addPackage$(store)),
                // },
                // {
                //   icon: {
                //     prefix: 'fas',
                //     name: 'table',
                //   },
                //   name: '',
                //   keymap: keymapOptionToString(keymap.addTable[0]),
                //   keymapTooltip: keymapOptionsToString(keymap.addTable),
                //   execute: () => store.dispatch(addTable$(store)),
                // },
                // {
                //   icon: {
                //     prefix: 'fas',
                //     name: 'sticky-note',
                //   },
                //   name: '',
                //   keymap: keymapOptionToString(keymap.addMemo[0]),
                //   keymapTooltip: keymapOptionsToString(keymap.addMemo),
                //   execute: () => store.dispatch(addMemo$(store)),
                // },
                // {
                //   icon: {
                //     prefix: 'mdi',
                //     name: 'vector-line',
                //     size: 18,
                //   },
                //   name: '',
                //   children: createDrawRelationshipMenus(context),
                // },
                {
                    icon: {
                        prefix: 'fas',
                        name: 'eye',
                    },
                    name: '',
                    children: createShowMenus(context),
                },
                // {
                //   icon: {
                //     prefix: 'mdi',
                //     name: 'database',
                //     size: 18,
                //   },
                //   name: '',
                //   children: createDatabaseMenus(context),
                // },
                // {
                //   icon: {
                //     prefix: 'fas',
                //     name: 'file-import',
                //   },
                //   name: '',
                //   children: createImportMenus(context),
                // },
                {
                    icon: {
                        prefix: 'fas',
                        name: 'file-export',
                    },
                    name: '',
                    children: createExportMenus(context, canvas),
                },
            ].map(menu => (Object.assign(Object.assign({}, menu), { options: Object.assign({}, defaultOptions$6) })));
        }
    }

    const defaultOptions$5 = {
        nameWidth: 75,
        keymapWidth: 0,
        close: false,
    };
    const createSingleRelationship = ({ store }, relationship) => relationshipMenus.map(relationshipMenu => ({
        icon: relationship.relationshipType === relationshipMenu.relationshipType
            ? {
                prefix: 'fas',
                name: 'check',
            }
            : undefined,
        name: relationshipMenu.name,
        execute: () => store.dispatch(changeRelationshipType(relationship.id, relationshipMenu.relationshipType)),
        options: Object.assign({}, defaultOptions$5),
    }));

    const defaultOptions$4 = {
        nameWidth: 110,
        keymapWidth: 0,
    };
    function createRelationshipMenus(context, relationship) {
        const { store } = context;
        return [
            {
                icon: {
                    prefix: 'mdi',
                    name: 'vector-line',
                    size: 18,
                },
                name: 'Relationship Type',
                children: createSingleRelationship(context, relationship),
            },
            {
                name: 'Delete',
                execute: () => store.dispatch(removeRelationship([relationship.id])),
            },
        ].map(menu => (Object.assign(Object.assign({}, menu), { options: Object.assign({}, defaultOptions$4) })));
    }

    const defaultOptions$3 = {
        nameWidth: 100,
        keymapWidth: 75,
    };
    const createTableMenus = ({ keymap, eventBus, store }, tableId) => [
        {
            icon: {
                prefix: 'fas',
                name: 'key',
            },
            name: 'Primary Key',
            keymap: keymapOptionToString(keymap.primaryKey[0]),
            keymapTooltip: keymapOptionsToString(keymap.primaryKey),
            execute() {
                const { editorState } = store;
                if (editorState.focusTable &&
                    !editorState.focusTable.edit &&
                    editorState.focusTable.columnId) {
                    store.dispatch(changeColumnPrimaryKey$(store, editorState.focusTable.table.id, editorState.focusTable.columnId));
                }
            },
        },
        {
            icon: {
                prefix: 'mdi',
                name: 'table-cog',
                size: 18,
            },
            name: 'Table Properties',
            keymap: keymapOptionToString(keymap.tableProperties[0]),
            keymapTooltip: keymapOptionsToString(keymap.tableProperties),
            execute: () => eventBus.emit(Bus.Drawer.openTableProperties, {
                tableId,
            }),
        },
    ].map(menu => (Object.assign(Object.assign({}, menu), { options: Object.assign({}, defaultOptions$3) })));

    const changeColumnMap = {
        columnNotNull: changeColumnNotNull,
        columnUnique: changeColumnUnique,
        columnAutoIncrement: changeColumnAutoIncrement,
    };
    const changeColumnKeys = [
        'columnNotNull',
        'columnUnique',
        'columnAutoIncrement',
    ];
    function useERDKeymap(ctx) {
        const contextRef = useContext(ctx);
        const { unmountedGroup } = useUnmounted();
        const onKeydown = (event) => {
            const { keymap, store, eventBus } = contextRef.value;
            const { tableState, memoState, editorState } = store;
            if (!editorState.focusTable || !editorState.focusTable.edit) {
                keymapMatchAndStop(event, keymap.addTable) &&
                    store.dispatch(addTable$(store));
                keymapMatchAndStop(event, keymap.addColumn) &&
                    tableState.tables.some(table => table.ui.active) &&
                    store.dispatch(addColumn$(store));
                keymapMatchAndStop(event, keymap.addMemo) &&
                    store.dispatch(addMemo$(store));
                keymapMatchAndStop(event, keymap.selectAllTable) &&
                    store.dispatch(selectAllTable(), selectAllMemo());
                relationshipMenus.forEach(relationshipMenu => keymapMatchAndStop(event, keymap[relationshipMenu.keymapName]) &&
                    store.dispatch(drawStartRelationship$(store, relationshipMenu.relationshipType)));
                if (keymapMatchAndStop(event, keymap.removeTable) &&
                    (store.tableState.tables.some(table => table.ui.active) ||
                        store.memoState.memos.some(memo => memo.ui.active))) {
                    const commands = [];
                    tableState.tables.some(table => table.ui.active) &&
                        commands.push(removeTable(store));
                    memoState.memos.some(memo => memo.ui.active) &&
                        commands.push(removeMemo(store));
                    store.dispatch(...commands);
                }
                if (keymapMatchAndStop(event, keymap.tableProperties) &&
                    store.tableState.tables.some(table => table.ui.active)) {
                    const table = store.tableState.tables.find(table => table.ui.active);
                    if (!table)
                        return;
                    eventBus.emit(Bus.Drawer.openTableProperties, {
                        tableId: editorState.focusTable
                            ? editorState.focusTable.table.id
                            : table.id,
                    });
                }
                if (keymapMatchAndStop(event, keymap.find)) {
                    if (editorState.findActive) {
                        store.dispatch(findActiveEnd());
                    }
                    else {
                        store.dispatch(findActive$());
                    }
                    eventBus.emit(Bus.Drawer.close);
                }
                // keymapMatchAndStop(event, keymap.zoomIn) &&
                //   store.dispatch(movementZoomCanvas(0.1));
                // keymapMatchAndStop(event, keymap.zoomOut) &&
                //   store.dispatch(movementZoomCanvas(-0.1));
            }
            if (editorState.focusTable && !editorState.focusTable.edit) {
                keymapMatchAndStop(event, keymap.selectAllColumn) &&
                    store.dispatch(selectAllColumn());
                editorState.focusTable.selectColumnIds.length &&
                    keymapMatchAndStop(event, keymap.removeColumn) &&
                    store.dispatch(removeColumn$(store, editorState.focusTable.table.id, editorState.focusTable.selectColumnIds));
                editorState.focusTable.selectColumnIds.length &&
                    keymapMatchAndStop(event, keymap.copyColumn) &&
                    store.dispatch(copyColumn(editorState.focusTable.table.id, editorState.focusTable.selectColumnIds));
                keymapMatchAndStop(event, keymap.pasteColumn) &&
                    store.dispatch(pasteColumn$(store));
                editorState.focusTable.columnId &&
                    keymapMatchAndStop(event, keymap.primaryKey) &&
                    store.dispatch(changeColumnPrimaryKey$(store, editorState.focusTable.table.id, editorState.focusTable.columnId));
                event.key !== 'Tab' &&
                    moveKeys.includes(event.key) &&
                    store.dispatch(focusMoveTable(event.key, event.shiftKey));
            }
            if (editorState.focusTable && event.key === 'Tab') {
                event.preventDefault();
                store.dispatch(focusMoveTable$(store, event.key, event.shiftKey));
                setTimeout(() => {
                    if (!editorState.focusTable ||
                        changeColumnKeys.includes(editorState.focusTable.focusType))
                        return;
                    store.dispatch(editTable());
                }, 0);
            }
            if (editorState.focusTable && keymapMatchAndStop(event, keymap.edit)) {
                const focusTable = editorState.focusTable;
                if (focusTable.edit) {
                    store.dispatch(editTableEnd());
                }
                else if (focusTable.columnId &&
                    changeColumnKeys.includes(focusTable.focusType)) {
                    const changeColumn = changeColumnMap[focusTable.focusType];
                    store.dispatch(changeColumn(store, focusTable.table.id, focusTable.columnId));
                }
                else {
                    store.dispatch(editTable());
                }
            }
            if (keymapMatchAndStop(event, keymap.stop)) {
                const commands = [drawEndRelationship(), findActiveEnd()];
                if (editorState.findActive) {
                    const table = store.tableState.tables.find(table => table.ui.active);
                    if (table) {
                        commands.push(selectTable$(store, false, table.id));
                    }
                }
                else {
                    commands.push(selectEndMemo(), selectEndTable$());
                }
                store.dispatch(...commands);
            }
            keymapMatchAndStop(event, keymap.undo) && store.undo();
            keymapMatchAndStop(event, keymap.redo) && store.redo();
        };
        beforeMount(() => {
            const { helper } = contextRef.value;
            unmountedGroup.push(helper.keydown$.subscribe(onKeydown));
        });
    }

    function useMousePosition(selector) {
        const elementRef = query(selector);
        const getPosition = (event) => {
            const { x, y } = elementRef.value.getBoundingClientRect();
            return {
                x: event.clientX - x,
                y: event.clientY - y,
            };
        };
        return {
            getPosition,
        };
    }

    const ScrollbarStyle = css `
  ::-webkit-scrollbar {
    width: 12px;
    height: 12px;
  }
  ::-webkit-scrollbar-track {
    background: #fff0;
  }
  ::-webkit-scrollbar-corner {
    background: #fff0;
  }
  ::-webkit-scrollbar-thumb {
    background: var(--kderd-color-scrollbar-thumb);
  }
  ::-webkit-scrollbar-thumb:hover {
    background: var(--kderd-color-scrollbar-thumb-active);
  }

  /* firefox */
  .kderd-scrollbar {
    scrollbar-color: var(--kderd-color-scrollbar-thumb) #fff0;
    scrollbar-width: auto;
  }
`;

    const DefaultStyle = css `
  .kderd-button {
    cursor: pointer;
  }
  .kderd-button:hover {
    fill: var(--kderd-color-font-active);
  }

  ${ScrollbarStyle}
`;

    const IconStyle = css `
  .kderd-icon {
    transition: fill 0.15s;
  }
`;

    const CanvasStyle = css `
  .kderd-canvas {
    position: relative;
    background-color: var(--kderd-color-canvas);
    cursor: move;
  }
`;

    const CanvasSVGStyle = css `
  .kderd-canvas-svg {
    position: absolute;
    top: 0;
    left: 0;
    overflow: visible;
  }

  .kderd-relationship {
    stroke: var(--kderd-color-key-fk);
  }

  .kderd-relationship.identification {
    stroke: var(--kderd-color-key-pfk);
  }

  .kderd-relationship.active {
    stroke: var(--kderd-color-edit);
  }
`;

    const DragSelectStyle = css `
  .kderd-drag-select {
    position: absolute;
    stroke: var(--kderd-color-focus);
    pointer-events: none;
  }
`;

    const DrawRelationshipStyle = css `
  .kderd-draw-relationship {
    position: absolute;
    top: 0;
    left: 0;
    stroke: var(--kderd-color-key-fk);
    pointer-events: none;
  }
`;

    const ERDStyle = css `
  .kderd-erd {
    overflow: hidden;
    position: relative;
  }

  .kderd-erd-background {
    width: 100%;
    height: 100%;
    pointer-events: none;
    float: left;
    background-color: var(--kderd-color-contextmenu);
  }
`;

    const FindStyle = css `
  .kderd-find {
    width: 225px;
    display: flex;
    align-items: center;
    padding: 0 10px;
    box-sizing: border-box;
    position: absolute;
    right: 190px;
    color: var(--kderd-color-font);
    background-color: var(--kderd-color-menubar);
    opacity: 0.9;
    fill: #fff0;
  }

  .kderd-find:hover {
    fill: var(--kderd-color-font);
  }

  .kderd-find-table {
    position: relative;
  }

  .kderd-find-table input {
    display: flex;
    width: 193px;
    vertical-align: middle;
    align-items: center;
    margin-right: ${SIZE_COLUMN_MARGIN_RIGHT}px;
    color: var(--kderd-color-font-active);
    background-color: var(--kderd-color-menubar);
    outline: none;
    border: none;
    opacity: 0.9;
    padding: 1px 0 1px 0;
    height: 17px;
    font-size: ${SIZE_FONT}px;
    font-family: var(--kderd-font-family);
    border-bottom: solid #fff0 1.5px;
  }

  .kderd-find-table input:focus {
    border-bottom: solid var(--kderd-color-edit) 1.5px;
  }

  .kderd-find-table-list {
    position: absolute;
    top: 27px;
    left: 0;
    z-index: 100;
    color: var(--kderd-color-font);
    background-color: var(--kderd-color-contextmenu);
    opacity: 0.9;
    list-style: none;
    padding: 0;
    margin: 0;
  }
  .kderd-find-table-list > li {
    padding: 5px;
    cursor: pointer;
    font-size: ${SIZE_FONT}px;
  }
  .kderd-find-table-list > li:hover,
  .kderd-find-table-hint.active {
    color: var(--kderd-color-font-active);
    background-color: var(--kderd-color-contextmenu-active);
  }
  .kderd-find-table-list > li:hover .kderd-find-table-hint-mark,
  .kderd-find-table-hint.active .kderd-find-table-hint-mark {
    color: var(--kderd-color-font-active);
  }
  /* animation flip */
  .kderd-find-table-hint-move {
    transition: transform 0.2s;
  }

  .kderd-find-table-hint-mark {
    color: var(--kderd-color-edit);
  }
`;

    const InputStyle = css `
  .kderd-input {
    display: inline-flex;
    vertical-align: middle;
    align-items: center;
    margin-right: ${SIZE_COLUMN_MARGIN_RIGHT}px;
    color: var(--kderd-color-font-active);
    background-color: var(--kderd-color-table);
  }

  input.kderd-input {
    outline: none;
    border: none;
    opacity: 0.9;
    padding: 1px 0 1px 0;
    height: 17px;
    font-size: ${SIZE_FONT}px;
    font-family: var(--kderd-font-family);
  }

  div.kderd-input {
    border-bottom: solid #fff0 1.5px;
    height: ${SIZE_INPUT_EDIT_HEIGHT}px;
    cursor: default;
  }

  .kderd-input > span {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .kderd-input.select {
    background-color: var(--kderd-color-column-select);
  }

  .kderd-input.active {
    background-color: var(--kderd-color-column-active);
  }

  .kderd-input.focus {
    border-bottom: solid var(--kderd-color-focus) 1.5px;
  }

  .kderd-input.edit {
    border-bottom: solid var(--kderd-color-edit) 1.5px;
  }

  .kderd-input.placeholder {
    color: var(--kderd-color-font-placeholder);
  }
`;

    const MemoStyle = css `
  .kderd-memo {
    position: absolute;
    opacity: 0.9;
    fill: #fff0;
    background-color: var(--kderd-color-table);
    border-radius: 5px;
  }

  .kderd-memo:hover {
    fill: var(--kderd-color-font);
  }

  .kderd-memo.active {
    border: solid var(--kderd-color-table-active) 1px;
    box-shadow: 0 1px 6px var(--kderd-color-table-active);
  }

  .kderd-memo-header {
    padding: ${SIZE_MEMO_PADDING}px;
    cursor: move;
  }

  .kderd-memo-header .kderd-button {
    float: right;
  }

  .kderd-memo-textarea {
    padding: ${SIZE_MEMO_PADDING}px;
    opacity: 0.9;
    border: none;
    resize: none;
    outline: none;
    font-size: ${SIZE_FONT}px;
    font-family: var(--kderd-font-family);
    color: var(--kderd-color-font-active);
    background-color: var(--kderd-color-table);
  }
`;

    const MinimapStyle = css `
  .kderd-minimap {
    position: absolute;
    overflow: hidden;
  }

  .kderd-minimap-shadow {
    position: absolute;
    box-shadow: 0 1px 6px var(--kderd-color-minimap-shadow);
    pointer-events: none;
  }
`;

    const MinimapHandleStyle = css `
  .kderd-minimap-handle {
    position: absolute;
    border: solid var(--kderd-color-edit) 1px;
    cursor: pointer;
    opacity: 0.7;
  }

  .kderd-minimap-handle:hover {
    opacity: 1;
  }
`;

    const ColumnStyle = css `
  .kderd-column {
    height: ${SIZE_COLUMN_HEIGHT}px;
    fill: #fff0;
    display: flex;
    flex-flow: row nowrap;
  }

  .kderd-column:hover {
    fill: var(--kderd-color-font);
  }

  .kderd-column.select {
    background-color: var(--kderd-color-column-select);
  }

  .kderd-column.active {
    background-color: var(--kderd-color-column-active);
  }

  .kderd-column.draggable {
    opacity: 0.5;
  }

  .kderd-column > kderd-icon,
  .kderd-column > kderd-input,
  kderd-column-key,
  kderd-column-not-null,
  kderd-column-data-type,
  kderd-column-auto-increment,
  kderd-column-unique {
    float: left;
  }
`;

    const ColumnHeadStyle = css `
  .kderd-column-head {
    height: ${SIZE_COLUMN_HEIGHT}px;
    fill: #fff0;
    display: flex;
    flex-flow: row nowrap;
    color: var(--kderd-color-font);
  }

  .kderd-column-head:hover {
    fill: var(--kderd-color-font);
  }

  .kderd-column-head.select {
    background-color: var(--kderd-color-column-select);
  }

  .kderd-column-head.active {
    background-color: var(--kderd-color-column-active);
  }


  .kderd-column-head > kderd-icon,
  .kderd-column-head > kderd-input,
  kderd-column-key,
  kderd-column-not-null,
  kderd-column-data-type,
  kderd-column-auto-increment,
  kderd-column-unique {
    float: left;
  }
`;

    const ColumnAutoIncrementStyle = css `
  .kderd-column-auto-increment {
    display: flex;
    vertical-align: middle;
    align-items: center;
    border-bottom: solid #fff0 1.5px;
    cursor: default;
    height: ${SIZE_INPUT_EDIT_HEIGHT}px;
    margin-right: ${SIZE_COLUMN_MARGIN_RIGHT}px;
    color: var(--kderd-color-font-placeholder);
  }

  .kderd-column-auto-increment.focus {
    border-bottom: solid var(--kderd-color-focus) 1.5px;
  }

  .kderd-column-auto-increment.checked {
    color: var(--kderd-color-font-active);
  }
`;

    const ColumnDataTypeStyle = css `
  .kderd-column-data-type {
    display: flex;
    vertical-align: middle;
    align-items: center;
    position: relative;
  }

  .kderd-column-data-type-hint {
    position: absolute;
    z-index: 1;
    opacity: 0.9;
    top: ${SIZE_COLUMN_HEIGHT}px;
    left: 0;
    color: var(--kderd-color-font);
    background-color: var(--kderd-color-contextmenu);
    list-style: none;
    padding: 0;
    margin: 0;
    white-space: nowrap;
  }

  .kderd-column-data-type-hint > li {
    padding: 5px;
    cursor: pointer;
    font-size: ${SIZE_FONT}px;
  }

  .kderd-column-data-type-hint > li:hover,
  .kderd-data-type-hint.active {
    color: var(--kderd-color-font-active);
    background-color: var(--kderd-color-contextmenu-active);
  }

  .kderd-column-data-type-hint > li:hover .kderd-data-type-hint-mark,
  .kderd-data-type-hint.active .kderd-data-type-hint-mark {
    color: var(--kderd-color-font-active);
  }

  /* animation flip */
  .kderd-data-type-hint-move {
    transition: transform 0.2s;
  }

  .kderd-data-type-hint-mark {
    color: var(--kderd-color-edit);
  }
`;

    const ColumnKeyStyle = css `
  .kderd-column-key {
    display: flex;
    vertical-align: middle;
    align-items: center;
    fill: #fff0;
    margin-right: ${SIZE_COLUMN_MARGIN_RIGHT}px;
  }

  .kderd-column-key.pk {
    fill: var(--kderd-color-key-pk);
  }

  .kderd-column-key.fk {
    fill: var(--kderd-color-key-fk);
  }

  .kderd-column-key.pfk {
    fill: var(--kderd-color-key-pfk);
  }
`;

    const ColumnNotNullStyle = css `
  .kderd-column-not-null {
    display: flex;
    vertical-align: middle;
    align-items: center;
    border-bottom: solid #fff0 1.5px;
    cursor: default;
    height: ${SIZE_INPUT_EDIT_HEIGHT}px;
    margin-right: ${SIZE_COLUMN_MARGIN_RIGHT}px;
    color: var(--kderd-color-font-active);
  }

  .kderd-column-not-null.focus {
    border-bottom: solid var(--kderd-color-focus) 1.5px;
  }
`;

    const ColumnUniqueStyle = css `
  .kderd-column-unique {
    display: flex;
    vertical-align: middle;
    align-items: center;
    border-bottom: solid #fff0 1.5px;
    cursor: default;
    height: ${SIZE_INPUT_EDIT_HEIGHT}px;
    margin-right: ${SIZE_COLUMN_MARGIN_RIGHT}px;
    color: var(--kderd-color-font-placeholder);
  }

  .kderd-column-unique.focus {
    border-bottom: solid var(--kderd-color-focus) 1.5px;
  }

  .kderd-column-unique.checked {
    color: var(--kderd-color-font-active);
  }
`;

    const HighLevelTableStyle = css `
  .kderd-high-level-table {
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: auto;
    color: var(--kderd-color-font-active);
    font-weight: bold;
    font-size: 20px;
    word-break: break-all;
  }
`;

    const TableStyle = css `
  .kderd-table {
    position: absolute;
    opacity: 0.9;
    padding: ${SIZE_TABLE_PADDING}px;
    font-size: ${SIZE_FONT}px;
    fill: #fff0;
    background-color: var(--kderd-color-table);
    border: solid #fff0 ${SIZE_TABLE_BORDER}px;
    border-radius: 5px;
    box-shadow: 3px 3px 5px #5a5959;
    box-shadow: 0px 4px 10px 0px rgba(0, 0, 0, 0.2);
  }

  .kderd-table:hover {
    fill: var(--kderd-color-font);
  }

  .kderd-table.active {
    border: solid var(--kderd-color-table-active) ${SIZE_TABLE_BORDER}px;
    box-shadow: 0 1px 6px var(--kderd-color-table-active);
  }

  .kderd-table .kderd-table-header-top {
    overflow: hidden;
    cursor: move;
  }

  .kderd-table .kderd-table-header-top .kderd-button {
    margin-left: 8px;
    float: right;
  }

  .kderd-table .kderd-table-header-body {
    height: ${SIZE_TABLE_HEADER_BODY_HEIGHT}px;
  }

  .kderd-table .kderd-table-header-body > kderd-input {
    float: left;
  }
  .kderd-table .kderd-table-header-body .kderd-input {
    font-size: ${SIZE_FONT_TABLE_HEAD}px;
    font-weight: bold;
    color: #212121;
    line-height: 21px;
  }
  .kderd-table .kderd-table-header-body .kderd-table-header-body-package {
    display: flex;
    vertical-align: middle;
    align-items: center;
    position: relative;
  }

  .kderd-table .kderd-table-header-body .kderd-table-package {
    color: var(--kderd-color-font-active);
    background-color: var(--kderd-color-contextmenu);
    border-color: var(--kderd-color-table);
  }

  .kderd-table .kderd-table-header-body .kderd-table-header-body-package-hint {
    position: absolute;
    z-index: 1;
    opacity: 0.9;
    top: ${SIZE_TABLE_HEADER_HEIGHT}px;
    left: 0;
    color: var(--kderd-color-font);
    background-color: var(--kderd-color-contextmenu);
    list-style: none;
    padding: 0;
    margin: 0;
    white-space: nowrap;
  }

  .kderd-table .kderd-table-body {
    overflow-y: auto;
    overflow-x: visible;
    max-height: ${SIZE_MAX_ROW * SIZE_COLUMN_HEIGHT}px;
  }

  /* animation flip */
  .kderd-column-move {
    transition: transform 0.3s;
  }
`;

    const IndexStyle$2 = [
        DefaultStyle,
        ERDStyle,
        CanvasStyle,
        MemoStyle,
        TableStyle,
        HighLevelTableStyle,
        InputStyle,
        ColumnStyle,
        ColumnHeadStyle,
        ColumnKeyStyle,
        ColumnDataTypeStyle,
        ColumnNotNullStyle,
        ColumnUniqueStyle,
        ColumnAutoIncrementStyle,
        DrawRelationshipStyle,
        CanvasSVGStyle,
        DragSelectStyle,
        MinimapStyle,
        MinimapHandleStyle,
        FindStyle,
        IconStyle,
    ].join('');

    const ERD = (props, ctx) => {
        const state = observable$1({
            contextmenuX: 0,
            contextmenuY: 0,
            menus: null,
            dragSelect: false,
            dragSelectX: 0,
            dragSelectY: 0,
        });
        const contextRef = useContext(ctx);
        const { unmountedGroup } = useUnmounted();
        const { getPosition } = useMousePosition('.kderd-erd');
        const canvasRef = query('.kderd-canvas');
        const erdRef = query('.kderd-erd');
        useERDKeymap(ctx);
        let relationshipUnsubscribe = null;
        const resetScroll = () => {
            if (erdRef.value.scrollTop === 0 && erdRef.value.scrollLeft === 0)
                return;
            erdRef.value.scrollTop = 0;
            erdRef.value.scrollLeft = 0;
        };
        const onContextmenu = (event) => {
            event.preventDefault();
            const el = event.target;
            const context = contextRef.value;
            const { relationships } = context.store.relationshipState;
            state.contextmenuX = event.clientX;
            state.contextmenuY = event.clientY;
            const { store: { controlState: { allowEdit } }, } = context;
            const $table = el.closest('.kderd-table');
            const $relationship = el.closest('.kderd-relationship');
            if ($table) {
                const tableId = $table.dataset.id;
                if (!allowEdit)
                    return;
                state.menus = createTableMenus(context, tableId);
            }
            else if ($relationship) {
                const relationshipId = $relationship.dataset.id;
                const relationship = getData(relationships, relationshipId);
                if (!relationship)
                    return;
                if (!allowEdit)
                    return;
                state.menus = createRelationshipMenus(context, relationship);
                relationshipUnsubscribe = watch(relationship, propName => {
                    var _a;
                    if (propName !== 'relationshipType')
                        return;
                    const menue = (_a = state.menus) === null || _a === void 0 ? void 0 : _a.find(menu => menu.name === 'Relationship Type');
                    if (!menue)
                        return;
                    menue.children = createSingleRelationship(context, relationship);
                });
            }
            else {
                state.menus = createERDMenus(context, canvasRef.value);
            }
        };
        const onCloseContextmenu = () => {
            state.menus = null;
            relationshipUnsubscribe && relationshipUnsubscribe();
            relationshipUnsubscribe = null;
        };
        const onCloseFind = () => {
            const { store } = contextRef.value;
            store.dispatch(findActiveEnd());
        };
        const onMove = ({ event, movementX, movementY }) => {
            const { store } = contextRef.value;
            event.type === 'mousemove' && event.preventDefault();
            store.dispatch(movementCanvas(movementX, movementY));
            resetScroll();
        };
        const onDragSelect = (event) => {
            const el = event.target;
            const { store, globalEvent: { drag$ }, } = contextRef.value;
            onCloseContextmenu();
            if (!el.closest('.kderd-find')) {
                onCloseFind();
            }
            if (!el.closest('.kderd-table') &&
                !el.closest('.kderd-package') &&
                !el.closest('.kderd-memo') &&
                !el.closest('.kderd-input')) {
                store.dispatch(selectEndTable$(), selectEndMemo());
                if (event.type === 'mousedown' && (event.ctrlKey || event.metaKey)) {
                    const position = getPosition(event);
                    state.dragSelect = true;
                    state.dragSelectX = position.x;
                    state.dragSelectY = position.y;
                }
                else {
                    drag$.subscribe(onMove);
                }
            }
        };
        const onWheel = (event) => {
            const { store } = contextRef.value;
            const { controlState: { allowZoom } } = store;
            if (!allowZoom)
                return;
            store.dispatch(movementZoomCanvas(event.deltaY < 0 ? 0.1 : -0.1));
        };
        const onDragSelectEnd = () => (state.dragSelect = false);
        beforeMount(() => {
            const { store: { canvasState }, eventBus, } = contextRef.value;
            unmountedGroup.push(watch(canvasState.show, () => {
                var _a;
                const menue = (_a = state.menus) === null || _a === void 0 ? void 0 : _a.find(menu => menu.name === 'View Option');
                if (!menue)
                    return;
                menue.children = createShowMenus(contextRef.value);
            }), watch(canvasState, propName => {
                var _a;
                if (propName !== 'database')
                    return;
                const menue = (_a = state.menus) === null || _a === void 0 ? void 0 : _a.find(menu => menu.name === 'Database');
                if (!menue)
                    return;
                menue.children = createDatabaseMenus(contextRef.value);
            }), eventBus.on(Bus.Contextmenu.close).subscribe(onCloseContextmenu));
        });
        unmounted(() => onCloseContextmenu());
        return () => {
            const { store: { editorState: { drawRelationship, findActive }, }, } = contextRef.value;
            return html `
      <div
        class="kderd-erd"
        style=${styleMap({
            width: `${props.width}px`,
            height: `${props.height}px`,
            cursor: drawRelationship
                ? `url("${getBase64Icon(drawRelationship.relationshipType)}") 16 16, auto`
                : '',
        })}
        @mousedown=${onDragSelect}
        @touchstart=${onDragSelect}
        @contextmenu=${onContextmenu}
        @wheel=${onWheel}
      >
        <div class="kderd-erd-background"></div>
        <kderd-canvas></kderd-canvas>
        ${state.dragSelect
            ? html `
              <kderd-drag-select
                .x=${state.dragSelectX}
                .y=${state.dragSelectY}
                @drag-select-end=${onDragSelectEnd}
              ></kderd-drag-select>
            `
            : null}
        ${state.menus
            ? html `
              <kderd-contextmenu
                .menus=${state.menus}
                .x=${state.contextmenuX}
                .y=${state.contextmenuY}
                @close=${onCloseContextmenu}
              ></kderd-contextmenu>
            `
            : null}
        <kderd-find .visible=${findActive} @close=${onCloseFind}></kderd-find>
      </div>
    `;
        };
    };
    defineComponent('kderd-erd', {
        observedProps: [
            {
                name: 'width',
                default: 0,
            },
            {
                name: 'height',
                default: 0,
            },
        ],
        styleMap: {
            height: '100%',
        },
        style: IndexStyle$2,
        render: ERD,
    });

    const MAX_WIDTH = 800;
    const ANIMATION_TIME = 300;
    function useDrawerAnimation(props, ctx) {
        const state = observable$1({ right: 0, visible: false });
        let openTween = null;
        let closeTween = null;
        const getWidth = () => {
            let width = props.width / 2;
            if (width > MAX_WIDTH) {
                width = MAX_WIDTH;
            }
            return width;
        };
        const onOpen = () => {
            if (openTween)
                return;
            closeTween === null || closeTween === void 0 ? void 0 : closeTween.stop();
            closeTween = null;
            state.visible = true;
            state.right = state.right === 0 ? -1 * getWidth() : state.right;
            openTween = new Tween(state)
                .to({ right: 0 }, ANIMATION_TIME)
                .easing(Easing.Quadratic.Out)
                .onComplete(() => (openTween = null))
                .start();
        };
        const onClose = () => {
            if (closeTween)
                return;
            openTween === null || openTween === void 0 ? void 0 : openTween.stop();
            openTween = null;
            closeTween = new Tween(state)
                .to({ right: -1 * getWidth() }, ANIMATION_TIME)
                .easing(Easing.Quadratic.In)
                .onComplete(() => {
                closeTween = null;
                state.visible = false;
                ctx.dispatchEvent(new CustomEvent('close'));
            })
                .start();
        };
        return {
            drawerState: state,
            getWidth,
            onOpen,
            onClose,
        };
    }

    const DrawerStyle = css `
  .kderd-drawer {
    position: absolute;
    top: ${SIZE_MENUBAR_HEIGHT}px;
    height: calc(100% - ${SIZE_MENUBAR_HEIGHT}px);
    color: var(--kderd-color-font);
    opacity: 0.9;
    background-color: var(--kderd-color-contextmenu);
    fill: #fff0;
    padding: 20px;
    box-sizing: border-box;
    z-index: 100;
  }

  .kderd-drawer:hover {
    fill: var(--kderd-color-font);
  }

  .kderd-drawer-header {
    height: 30px;
    margin-bottom: 10px;
    overflow: hidden;
  }

  .kderd-drawer-header > h3 {
    display: inline-block;
    margin: 0;
  }

  .kderd-drawer-header > .kderd-button {
    float: right;
  }

  .kderd-drawer-body {
    height: calc(100% - 40px);
    overflow: auto;
    box-sizing: border-box;
  }

  ${DefaultStyle}
`;

    const Drawer = (props, ctx) => {
        const contextRef = useContext(ctx);
        const { drawerState, getWidth, onOpen, onClose } = useDrawerAnimation(props, ctx);
        const { unmountedGroup } = useUnmounted();
        const { resetTooltip } = useTooltip(['.kderd-button'], ctx);
        beforeMount(() => unmountedGroup.push(watch(props, propName => {
            if (propName !== 'visible')
                return;
            props.visible ? onOpen() : onClose();
            props.visible && setTimeout(resetTooltip, 0);
        })));
        return () => {
            const { keymap } = contextRef.value;
            const keymapStop = keymapOptionsToString(keymap.stop);
            return drawerState.visible
                ? html `
          <div
            class="kderd-drawer"
            style=${styleMap({
                width: `${getWidth()}px`,
                right: `${drawerState.right}px`,
            })}
          >
            <div class="kderd-drawer-header">
              <h3>${props.name}</h3>
              <kderd-icon
                class="kderd-button"
                name="times"
                size="16"
                data-tippy-content=${keymapStop}
                @click=${onClose}
              ></kderd-icon>
            </div>
            <div class="kderd-drawer-body kderd-scrollbar">
              <slot></slot>
            </div>
          </div>
        `
                : null;
        };
    };
    defineComponent('kderd-drawer', {
        observedProps: [
            {
                name: 'name',
                default: '',
            },
            {
                name: 'width',
                type: Number,
                default: DEFAULT_WIDTH,
            },
            {
                name: 'visible',
                type: Boolean,
                default: false,
            },
        ],
        style: [DrawerStyle, IconStyle].join(''),
        render: Drawer,
    });

    const HelpDrawer = (props, ctx) => {
        const contextRef = useContext(ctx);
        const getHelpDescribe = () => {
            const { keymap } = contextRef.value;
            return [
                {
                    name: 'Editing - ERD',
                    keymap: `dblclick, ${keymapOptionsToString(keymap.edit)}`,
                },
                {
                    name: 'Editing - Grid',
                    keymap: 'dblclick, Enter',
                },
                {
                    name: 'All Stop',
                    keymap: keymapOptionsToString(keymap.stop),
                },
                {
                    name: 'Search - find, filter',
                    keymap: keymapOptionsToString(keymap.find),
                },
                {
                    name: 'Undo - ERD',
                    keymap: keymapOptionsToString(keymap.undo),
                },
                {
                    name: 'Redo - ERD',
                    keymap: keymapOptionsToString(keymap.redo),
                },
                {
                    name: 'Selection - table, memo',
                    keymap: `Ctrl + Drag, Click, Ctrl + Click, Cmd + Drag, Cmd + Click, ${keymapOptionsToString(keymap.selectAllTable)}`,
                },
                {
                    name: 'Selection - column, filter',
                    keymap: `Click, Ctrl + Click, Cmd + Click, Shift + Click, Shift + Arrow key(up, down), ${keymapOptionsToString(keymap.selectAllColumn)}`,
                },
                {
                    name: 'Movement - table, memo, column, filter',
                    keymap: 'Drag, Ctrl + Drag, Cmd + Drag',
                },
                {
                    name: 'Copy - column',
                    keymap: keymapOptionsToString(keymap.copyColumn),
                },
                {
                    name: 'Paste - column',
                    keymap: keymapOptionsToString(keymap.pasteColumn),
                },
                {
                    name: 'Contextmenu - ERD, Table, Relationship, SQL DDL, Generator Code',
                    keymap: 'Right-click',
                },
                {
                    name: 'Table Properties',
                    keymap: keymapOptionsToString(keymap.tableProperties),
                },
                {
                    name: 'New Table',
                    keymap: keymapOptionsToString(keymap.addTable),
                },
                {
                    name: 'New Memo',
                    keymap: keymapOptionsToString(keymap.addMemo),
                },
                {
                    name: 'New - column, filter',
                    keymap: keymapOptionsToString(keymap.addColumn),
                },
                {
                    name: 'Delete - table, memo',
                    keymap: keymapOptionsToString(keymap.removeTable),
                },
                {
                    name: 'Delete - column, filter',
                    keymap: keymapOptionsToString(keymap.removeColumn),
                },
                {
                    name: 'Select Hint - dataType, find',
                    keymap: 'Arrow key(right), Click',
                },
                {
                    name: 'Move Hint - dataType, find',
                    keymap: 'Arrow key(up, down)',
                },
                {
                    name: 'Primary Key',
                    keymap: keymapOptionsToString(keymap.primaryKey),
                },
                {
                    name: 'checkbox - Grid, filter',
                    keymap: 'Space, Click',
                },
                {
                    name: 'Move checkbox - Grid, filter',
                    keymap: 'Arrow key(up, down, left, right)',
                },
                {
                    name: 'Relationship - Zero One',
                    keymap: keymapOptionsToString(keymap.relationshipZeroOne),
                },
                {
                    name: 'Relationship - Zero N',
                    keymap: keymapOptionsToString(keymap.relationshipZeroN),
                },
                {
                    name: 'Relationship - One Only',
                    keymap: keymapOptionsToString(keymap.relationshipOneOnly),
                },
                {
                    name: 'Relationship - One N',
                    keymap: keymapOptionsToString(keymap.relationshipOneN),
                },
                // {
                //   name: 'Zoom In - ERD',
                //   keymap: keymapOptionsToString(keymap.zoomIn),
                // },
                // {
                //   name: 'Zoom Out - ERD',
                //   keymap: keymapOptionsToString(keymap.zoomOut),
                // },
            ];
        };
        const onClose = () => ctx.dispatchEvent(new CustomEvent('close'));
        return () => html `
    <kderd-drawer
      name="Help"
      .width=${props.width}
      .visible=${props.visible}
      @close=${onClose}
    >
      <table>
        <thead>
          <th>Name</th>
          <th>Keymap</th>
        </thead>
        <tbody>
          ${getHelpDescribe().map(describe => html `
              <tr>
                <td>${describe.name}</td>
                <td>${describe.keymap}</td>
              </tr>
            `)}
        </tbody>
      </table>
    </kderd-drawer>
  `;
    };
    defineComponent('kderd-help-drawer', {
        observedProps: ['width', 'visible'],
        shadow: false,
        render: HelpDrawer,
    });

    const fromShadowDraggable = (elements) => merge(...elements.map(el => fromEvent(el, 'dragover').pipe(throttleTime(300), map(() => el.dataset.id)))).pipe(debounceTime(50), takeUntil(merge(...elements.map(el => fromEvent(el, 'dragend')))));

    const SettingDrawer = (props, ctx) => {
        const contextRef = useContext(ctx);
        const state = observable$1({
            currentColumnType: null,
        });
        const columnsOrderRef = queryAll('.kderd-column-order');
        const flipAnimation = new FlipAnimation(ctx.shadowRoot ? ctx.shadowRoot : ctx, '.kderd-column-order', 'kderd-column-order-move');
        const onClose = () => ctx.dispatchEvent(new CustomEvent('close'));
        const onChangeRelationshipDataTypeSync = (event) => {
            const checkbox = event.target;
            const { store } = contextRef.value;
            store.dispatch(changeRelationshipDataTypeSync(checkbox.checked));
        };
        const onMoveColumnOrder = (currentColumnType, targetColumnType) => {
            const { store } = contextRef.value;
            if (currentColumnType && currentColumnType !== targetColumnType) {
                flipAnimation.snapshot();
                store.dispatch(moveColumnOrder(currentColumnType, targetColumnType));
            }
        };
        const onDragstartColumnOrder = (currentColumnType) => {
            state.currentColumnType = currentColumnType;
            columnsOrderRef.value.forEach(el => el.classList.add('none-hover'));
            fromShadowDraggable(columnsOrderRef.value).subscribe({
                next: id => onMoveColumnOrder(currentColumnType, id),
                complete: () => {
                    state.currentColumnType = null;
                    columnsOrderRef.value.forEach(el => el.classList.remove('none-hover'));
                },
            });
        };
        const onSyncTableWidth = () => {
            const { store: { tableState: { tables }, relationshipState: { relationships }, }, helper, } = contextRef.value;
            recalculatingTableWidth(tables, helper);
            relationshipSort(tables, relationships);
        };
        updated(() => flipAnimation.play());
        return () => {
            const { canvasState: { setting }, editorState: { readonly }, } = contextRef.value.store;
            return html `
      <kderd-drawer
        name="Setting"
        .width=${props.width}
        .visible=${props.visible}
        @close=${onClose}
      >
        <table class="kderd-setting-drawer">
          <colgroup>
            <col width="190px" />
          </colgroup>
          <tbody>
            <tr>
              <td>Relationship DataType Sync</td>
              <td>
                <input
                  type="checkbox"
                  ?checked=${setting.relationshipDataTypeSync}
                  ?disabled=${readonly}
                  @change=${onChangeRelationshipDataTypeSync}
                />
              </td>
            </tr>
            <tr>
              <td>ColumnType Order</td>
              <td @dragenter=${onPreventDefault} @dragover=${onPreventDefault}>
                ${repeat(setting.columnOrder, columnType => columnType, columnType => html `
                      <div
                        class=${classMap({
            'kderd-column-order': true,
            draggable: state.currentColumnType === columnType,
        })}
                        data-id=${columnType}
                        draggable="true"
                        @dragstart=${() => onDragstartColumnOrder(columnType)}
                      >
                        ${columnType}
                      </div>
                    `)}
              </td>
            </tr>
            <tr>
              <td>Recalculating table width</td>
              <td>
                <div
                  class="kderd-recalculating-table-width-button"
                  @click=${onSyncTableWidth}
                >
                  <span>Sync</span>
                  <kderd-icon name="sync-alt" size="12"></kderd-icon>
                </div>
              </td>
            </tr>
          </tbody>
        </table>
      </kderd-drawer>
    `;
        };
    };
    defineComponent('kderd-setting-drawer', {
        observedProps: ['width', 'visible'],
        shadow: false,
        render: SettingDrawer,
    });

    const defaultOptions$2 = {
        nameWidth: 85,
        keymapWidth: 0,
        close: false,
    };
    const bracketTypeMenus = [
        {
            name: '',
            bracketType: 'singleQuote',
        },
        {
            name: '',
            bracketType: 'doubleQuote',
        },
        {
            name: '',
            bracketType: 'backtick',
        },
        {
            name: '',
            bracketType: 'none',
        },
    ];
    const createBracketTypeMenus = ({ store }) => bracketTypeMenus.map(menu => ({
        icon: store.canvasState.bracketType === menu.bracketType
            ? {
                prefix: 'fas',
                name: 'check',
            }
            : undefined,
        name: menu.name,
        execute: () => store.dispatch(changeBracketType(menu.bracketType)),
        options: Object.assign({}, defaultOptions$2),
    }));

    const defaultOptions$1 = {
        nameWidth: 105,
        keymapWidth: 0,
        close: false,
    };
    const createHighlightThemeMenus = ({ store, }) => highlightThemes.map(highlightTheme => ({
        icon: store.canvasState.highlightTheme === highlightTheme
            ? {
                prefix: 'fas',
                name: 'check',
            }
            : undefined,
        name: highlightTheme,
        execute: () => store.dispatch(changeHighlightTheme(highlightTheme)),
        options: Object.assign({}, defaultOptions$1),
    }));

    const defaultOptions = {
        nameWidth: 100,
        keymapWidth: 0,
    };
    const createSQLDDLMenus = (context) => [
        {
            icon: {
                prefix: 'mdi',
                name: 'database',
                size: 18,
            },
            name: 'Database',
            children: createDatabaseMenus(context),
        },
        {
            icon: {
                prefix: 'mdi',
                name: 'code-brackets',
                size: 18,
            },
            name: '',
            children: createBracketTypeMenus(context),
        },
        // {
        //   icon: {
        //     prefix: 'mdi',
        //     name: 'palette',
        //     size: 18,
        //   },
        //   name: 'Highlight Theme',
        //   children: createHighlightThemeMenus(context),
        // },
    ].map(menu => (Object.assign(Object.assign({}, menu), { options: Object.assign({}, defaultOptions) })));

    const AtomOneDarkStyle = css `
  /*
  Atom One Dark by Daniel Gamage
  Original One Dark Syntax theme from https://github.com/atom/one-dark-syntax

  base:    #282c34
  mono-1:  #abb2bf
  mono-2:  #818896
  mono-3:  #5c6370
  hue-1:   #56b6c2
  hue-2:   #61aeee
  hue-3:   #c678dd
  hue-4:   #98c379
  hue-5:   #e06c75
  hue-5-2: #be5046
  hue-6:   #d19a66
  hue-6-2: #e6c07b
  */

  .hljs {
    display: block;
    overflow-x: auto;
    padding: 0.5em;
    color: #abb2bf;
    background: #282c34;
  }

  .hljs-comment,
  .hljs-quote {
    color: #5c6370;
    font-style: italic;
  }

  .hljs-doctag,
  .hljs-keyword,
  .hljs-formula {
    color: #c678dd;
  }

  .hljs-section,
  .hljs-name,
  .hljs-selector-tag,
  .hljs-deletion,
  .hljs-subst {
    color: #e06c75;
  }

  .hljs-literal {
    color: #56b6c2;
  }

  .hljs-string,
  .hljs-regexp,
  .hljs-addition,
  .hljs-attribute,
  .hljs-meta-string {
    color: #98c379;
  }

  .hljs-built_in,
  .hljs-class .hljs-title {
    color: #e6c07b;
  }

  .hljs-attr,
  .hljs-variable,
  .hljs-template-variable,
  .hljs-type,
  .hljs-selector-class,
  .hljs-selector-attr,
  .hljs-selector-pseudo,
  .hljs-number {
    color: #d19a66;
  }

  .hljs-symbol,
  .hljs-bullet,
  .hljs-link,
  .hljs-meta,
  .hljs-selector-id,
  .hljs-title {
    color: #61aeee;
  }

  .hljs-emphasis {
    font-style: italic;
  }

  .hljs-strong {
    font-weight: bold;
  }

  .hljs-link {
    text-decoration: underline;
  }
`;

    const AtomOneLightStyle = css `
  /*
  Atom One Light by Daniel Gamage
  Original One Light Syntax theme from https://github.com/atom/one-light-syntax

  base:    #fafafa
  mono-1:  #383a42
  mono-2:  #686b77
  mono-3:  #a0a1a7
  hue-1:   #0184bb
  hue-2:   #4078f2
  hue-3:   #a626a4
  hue-4:   #50a14f
  hue-5:   #e45649
  hue-5-2: #c91243
  hue-6:   #986801
  hue-6-2: #c18401
  */

  .hljs {
    display: block;
    overflow-x: auto;
    padding: 0.5em;
    color: #383a42;
    background: #fafafa;
  }

  .hljs-comment,
  .hljs-quote {
    color: #a0a1a7;
    font-style: italic;
  }

  .hljs-doctag,
  .hljs-keyword,
  .hljs-formula {
    color: #a626a4;
  }

  .hljs-section,
  .hljs-name,
  .hljs-selector-tag,
  .hljs-deletion,
  .hljs-subst {
    color: #e45649;
  }

  .hljs-literal {
    color: #0184bb;
  }

  .hljs-string,
  .hljs-regexp,
  .hljs-addition,
  .hljs-attribute,
  .hljs-meta-string {
    color: #50a14f;
  }

  .hljs-built_in,
  .hljs-class .hljs-title {
    color: #c18401;
  }

  .hljs-attr,
  .hljs-variable,
  .hljs-template-variable,
  .hljs-type,
  .hljs-selector-class,
  .hljs-selector-attr,
  .hljs-selector-pseudo,
  .hljs-number {
    color: #986801;
  }

  .hljs-symbol,
  .hljs-bullet,
  .hljs-link,
  .hljs-meta,
  .hljs-selector-id,
  .hljs-title {
    color: #4078f2;
  }

  .hljs-emphasis {
    font-style: italic;
  }

  .hljs-strong {
    font-weight: bold;
  }

  .hljs-link {
    text-decoration: underline;
  }
`;

    const GithubGistStyle = css `
  /**
   * GitHub Gist Theme
   * Author : Anthony Attard - https://github.com/AnthonyAttard
   * Author : Louis Barranqueiro - https://github.com/LouisBarranqueiro
   */

  .hljs {
    display: block;
    background: white;
    padding: 0.5em;
    color: #333333;
    overflow-x: auto;
  }

  .hljs-comment,
  .hljs-meta {
    color: #969896;
  }

  .hljs-variable,
  .hljs-template-variable,
  .hljs-strong,
  .hljs-emphasis,
  .hljs-quote {
    color: #df5000;
  }

  .hljs-keyword,
  .hljs-selector-tag,
  .hljs-type {
    color: #d73a49;
  }

  .hljs-literal,
  .hljs-symbol,
  .hljs-bullet,
  .hljs-attribute {
    color: #0086b3;
  }

  .hljs-section,
  .hljs-name {
    color: #63a35c;
  }

  .hljs-tag {
    color: #333333;
  }

  .hljs-title,
  .hljs-attr,
  .hljs-selector-id,
  .hljs-selector-class,
  .hljs-selector-attr,
  .hljs-selector-pseudo {
    color: #6f42c1;
  }

  .hljs-addition {
    color: #55a532;
    background-color: #eaffea;
  }

  .hljs-deletion {
    color: #bd2c00;
    background-color: #ffecec;
  }

  .hljs-link {
    text-decoration: underline;
  }

  .hljs-number {
    color: #005cc5;
  }

  .hljs-string {
    color: #032f62;
  }
`;

    const MonokaiSublimeStyle = css `
  /*
    Monokai Sublime style. Derived from Monokai by noformnocontent http://nn.mit-license.org/
  */
  .hljs {
    display: block;
    overflow-x: auto;
    padding: 0.5em;
    background: #23241f;
  }

  .hljs,
  .hljs-tag,
  .hljs-subst {
    color: #f8f8f2;
  }

  .hljs-strong,
  .hljs-emphasis {
    color: #a8a8a2;
  }

  .hljs-bullet,
  .hljs-quote,
  .hljs-number,
  .hljs-regexp,
  .hljs-literal,
  .hljs-link {
    color: #ae81ff;
  }

  .hljs-code,
  .hljs-title,
  .hljs-section,
  .hljs-selector-class {
    color: #a6e22e;
  }

  .hljs-strong {
    font-weight: bold;
  }

  .hljs-emphasis {
    font-style: italic;
  }

  .hljs-keyword,
  .hljs-selector-tag,
  .hljs-name,
  .hljs-attr {
    color: #f92672;
  }

  .hljs-symbol,
  .hljs-attribute {
    color: #66d9ef;
  }

  .hljs-params,
  .hljs-class .hljs-title {
    color: #f8f8f2;
  }

  .hljs-string,
  .hljs-type,
  .hljs-built_in,
  .hljs-builtin-name,
  .hljs-selector-id,
  .hljs-selector-attr,
  .hljs-selector-pseudo,
  .hljs-addition,
  .hljs-variable,
  .hljs-template-variable {
    color: #e6db74;
  }

  .hljs-comment,
  .hljs-deletion,
  .hljs-meta {
    color: #75715e;
  }
`;

    const VS2015Style = css `
  /*
  * Visual Studio 2015 dark style
  * Author: Nicolas LLOBERA <nllobera@gmail.com>
  */

  .hljs {
    display: block;
    overflow-x: auto;
    padding: 0.5em;
    background: #1e1e1e;
    color: #dcdcdc;
  }

  .hljs-keyword,
  .hljs-literal,
  .hljs-symbol,
  .hljs-name {
    color: #569cd6;
  }
  .hljs-link {
    color: #569cd6;
    text-decoration: underline;
  }

  .hljs-built_in,
  .hljs-type {
    color: #4ec9b0;
  }

  .hljs-number,
  .hljs-class {
    color: #b8d7a3;
  }

  .hljs-string,
  .hljs-meta-string {
    color: #d69d85;
  }

  .hljs-regexp,
  .hljs-template-tag {
    color: #9a5334;
  }

  .hljs-subst,
  .hljs-function,
  .hljs-title,
  .hljs-params,
  .hljs-formula {
    color: #dcdcdc;
  }

  .hljs-comment,
  .hljs-quote {
    color: #57a64a;
    font-style: italic;
  }

  .hljs-doctag {
    color: #608b4e;
  }

  .hljs-meta,
  .hljs-meta-keyword,
  .hljs-tag {
    color: #9b9b9b;
  }

  .hljs-variable,
  .hljs-template-variable {
    color: #bd63c5;
  }

  .hljs-attr,
  .hljs-attribute,
  .hljs-builtin-name {
    color: #9cdcfe;
  }

  .hljs-section {
    color: gold;
  }

  .hljs-emphasis {
    font-style: italic;
  }

  .hljs-strong {
    font-weight: bold;
  }

  /*.hljs-code {
  font-family:'Monospace';
}*/

  .hljs-bullet,
  .hljs-selector-tag,
  .hljs-selector-id,
  .hljs-selector-class,
  .hljs-selector-attr,
  .hljs-selector-pseudo {
    color: #d7ba7d;
  }

  .hljs-addition {
    background-color: #144212;
    display: inline-block;
    width: 100%;
  }

  .hljs-deletion {
    background-color: #600;
    display: inline-block;
    width: 100%;
  }
`;

    const highlightThemeMap = {
        AtomOneDark: AtomOneDarkStyle,
        AtomOneLight: AtomOneLightStyle,
        MonokaiSublime: MonokaiSublimeStyle,
        GithubGist: GithubGistStyle,
        VS2015: VS2015Style,
    };

    function formatNames(list, backtick, backtick2) {
        const buf = [];
        list.forEach((v, i) => {
            if (backtick) {
                if (backtick2) {
                    buf.push(`${backtick}${v.name}${backtick2}`);
                }
                else {
                    buf.push(`${backtick}${v.name}${backtick}`);
                }
            }
            else {
                buf.push(v.name);
            }
            if (list.length !== i + 1) {
                buf.push(', ');
            }
        });
        return buf.join('');
    }
    function formatSize(columns) {
        let name = 0;
        let dataType = 0;
        columns.forEach(column => {
            if (name < column.name.length) {
                name = column.name.length;
            }
            if (dataType < column.dataType.length) {
                dataType = column.dataType.length;
            }
        });
        return {
            name,
            dataType,
        };
    }
    function formatSpace(size) {
        const buf = [];
        for (let i = 0; i < size; i++) {
            buf.push(' ');
        }
        return buf.join('');
    }
    function primaryKey(columns) {
        return columns.some(column => column.option.primaryKey);
    }
    function primaryKeyColumns(columns) {
        return columns.filter(column => column.option.primaryKey);
    }
    function unique(columns) {
        return columns.some(column => column.option.unique);
    }
    function uniqueColumns(columns) {
        return columns.filter(column => column.option.unique);
    }
    function getBracket(bracketType) {
        var _a;
        return (_a = bracketTypeMap[bracketType]) !== null && _a !== void 0 ? _a : '';
    }

    function createDDL$5({ tableState, relationshipState, canvasState, }) {
        const fkNames = [];
        const indexNames = [];
        const stringBuffer = [''];
        const bracket = getBracket(canvasState.bracketType);
        const tables = orderByNameASC(tableState.tables);
        const relationships = relationshipState.relationships;
        const indexes = tableState.indexes;
        tables.forEach(table => {
            formatTable$4({ table, buffer: stringBuffer, bracket });
            stringBuffer.push('');
            // unique
            if (unique(table.columns)) {
                const uqColumns = uniqueColumns(table.columns);
                uqColumns.forEach(column => {
                    stringBuffer.push(`ALTER TABLE ${bracket}${table.name}${bracket}`);
                    stringBuffer.push(`  ADD CONSTRAINT ${bracket}UQ_${column.name}${bracket} UNIQUE (${bracket}${column.name}${bracket});`);
                    stringBuffer.push('');
                });
            }
        });
        relationships.forEach(relationship => {
            formatRelation$4({
                tables,
                relationship,
                buffer: stringBuffer,
                fkNames,
                bracket,
            });
            stringBuffer.push('');
        });
        indexes.forEach(index => {
            const table = getData(tables, index.tableId);
            if (table) {
                formatIndex$4({
                    table,
                    index,
                    buffer: stringBuffer,
                    indexNames,
                    bracket,
                });
                stringBuffer.push('');
            }
        });
        return stringBuffer.join('\n');
    }
    function formatTable$4({ table, buffer, bracket }) {
        if (table.comment.trim()) {
            buffer.push(`-- ${table.comment}`);
        }
        buffer.push(`CREATE TABLE ${bracket}${table.name}${bracket}`);
        buffer.push(`(`);
        const pk = primaryKey(table.columns);
        const spaceSize = formatSize(table.columns);
        table.columns.forEach((column, i) => {
            if (pk) {
                formatColumn$4({
                    column,
                    isComma: true,
                    spaceSize,
                    buffer,
                    bracket,
                });
            }
            else {
                formatColumn$4({
                    column,
                    isComma: table.columns.length !== i + 1,
                    spaceSize,
                    buffer,
                    bracket,
                });
            }
        });
        if (pk) {
            const pkColumns = primaryKeyColumns(table.columns);
            buffer.push(`  PRIMARY KEY (${formatNames(pkColumns, bracket)})`);
        }
        buffer.push(`);`);
    }
    function formatColumn$4({ column, isComma, spaceSize, buffer, bracket, }) {
        const stringBuffer = [];
        stringBuffer.push(`  ${bracket}${column.name}${bracket}` +
            formatSpace(spaceSize.name - column.name.length));
        stringBuffer.push(`${column.dataType}` +
            formatSpace(spaceSize.dataType - column.dataType.length));
        stringBuffer.push(`${column.option.notNull ? 'NOT NULL' : 'NULL    '}`);
        if (column.option.autoIncrement) {
            stringBuffer.push(`AUTO_INCREMENT`);
        }
        else {
            if (column.default.trim() !== '') {
                stringBuffer.push(`DEFAULT ${column.default}`);
            }
        }
        if (column.comment.trim() !== '') {
            stringBuffer.push(`/* ${column.comment}*/`);
        }
        buffer.push(stringBuffer.join(' ') + `${isComma ? ',' : ''}`);
    }
    function formatRelation$4({ tables, relationship, buffer, fkNames, bracket, }) {
        const startTable = getData(tables, relationship.start.tableId);
        const endTable = getData(tables, relationship.end.tableId);
        if (startTable && endTable) {
            buffer.push(`ALTER TABLE ${bracket}${endTable.name}${bracket}`);
            // FK
            let fkName = `FK_${startTable.name}_TO_${endTable.name}`;
            fkName = autoName(fkNames, '', fkName);
            fkNames.push({
                id: v4(),
                name: fkName,
            });
            buffer.push(`  ADD CONSTRAINT ${bracket}${fkName}${bracket}`);
            // key
            const columns = {
                start: [],
                end: [],
            };
            relationship.end.columnIds.forEach(columnId => {
                const column = getData(endTable.columns, columnId);
                if (column) {
                    columns.end.push(column);
                }
            });
            relationship.start.columnIds.forEach(columnId => {
                const column = getData(startTable.columns, columnId);
                if (column) {
                    columns.start.push(column);
                }
            });
            buffer.push(`    FOREIGN KEY (${formatNames(columns.end, bracket)})`);
            buffer.push(`    REFERENCES ${bracket}${startTable.name}${bracket} (${formatNames(columns.start, bracket)});`);
        }
    }
    function formatIndex$4({ table, index, buffer, indexNames, bracket, }) {
        const columnNames = index.columns
            .map(indexColumn => {
            const column = getData(table.columns, indexColumn.id);
            if (column) {
                return {
                    name: `${bracket}${column.name}${bracket} ${indexColumn.orderType}`,
                };
            }
            return null;
        })
            .filter(columnName => columnName !== null);
        if (columnNames.length !== 0) {
            let indexName = index.name;
            if (index.name.trim() === '') {
                indexName = `IDX_${table.name}`;
                indexName = autoName(indexNames, '', indexName);
                indexNames.push({
                    id: v4(),
                    name: indexName,
                });
            }
            if (index.unique) {
                buffer.push(`CREATE UNIQUE INDEX ${bracket}${indexName}${bracket}`);
            }
            else {
                buffer.push(`CREATE INDEX ${bracket}${indexName}${bracket}`);
            }
            buffer.push(`  ON ${bracket}${table.name}${bracket} (${formatNames(columnNames)});`);
        }
    }

    function createDDL$4({ tableState, relationshipState, canvasState, }) {
        const fkNames = [];
        const indexNames = [];
        const stringBuffer = [''];
        const bracket = getBracket(canvasState.bracketType);
        const tables = orderByNameASC(tableState.tables);
        const relationships = relationshipState.relationships;
        const indexes = tableState.indexes;
        tables.forEach(table => {
            formatTable$3({ table, buffer: stringBuffer, bracket });
            stringBuffer.push('');
            // unique
            if (unique(table.columns)) {
                const uqColumns = uniqueColumns(table.columns);
                uqColumns.forEach(column => {
                    stringBuffer.push(`ALTER TABLE ${bracket}${table.name}${bracket}`);
                    stringBuffer.push(`  ADD CONSTRAINT ${bracket}UQ_${column.name}${bracket} UNIQUE (${bracket}${column.name}${bracket})\nGO`);
                    stringBuffer.push('');
                });
            }
            formatComment$2({ table, buffer: stringBuffer, bracket });
        });
        relationships.forEach(relationship => {
            formatRelation$3({
                tables,
                relationship,
                buffer: stringBuffer,
                fkNames,
                bracket,
            });
            stringBuffer.push('');
        });
        indexes.forEach(index => {
            const table = getData(tables, index.tableId);
            if (table) {
                formatIndex$3({ table, index, buffer: stringBuffer, indexNames, bracket });
                stringBuffer.push('');
            }
        });
        return stringBuffer.join('\n');
    }
    function formatTable$3({ table, buffer, bracket }) {
        buffer.push(`CREATE TABLE ${bracket}${table.name}${bracket}`);
        buffer.push(`(`);
        const pk = primaryKey(table.columns);
        const spaceSize = formatSize(table.columns);
        table.columns.forEach((column, i) => {
            if (pk) {
                formatColumn$3({ column, isComma: true, spaceSize, buffer, bracket });
            }
            else {
                formatColumn$3({
                    column,
                    isComma: table.columns.length !== i + 1,
                    spaceSize,
                    buffer,
                    bracket,
                });
            }
        });
        // PK
        if (pk) {
            const pkColumns = primaryKeyColumns(table.columns);
            buffer.push(`  CONSTRAINT ${bracket}PK_${table.name}${bracket} PRIMARY KEY (${formatNames(pkColumns, bracket)})`);
        }
        buffer.push(`)\nGO`);
    }
    function formatColumn$3({ column, isComma, spaceSize, buffer, bracket, }) {
        const stringBuffer = [];
        stringBuffer.push(`  ${bracket}${column.name}${bracket}` +
            formatSpace(spaceSize.name - column.name.length));
        stringBuffer.push(`${column.dataType}` +
            formatSpace(spaceSize.dataType - column.dataType.length));
        if (column.option.notNull) {
            stringBuffer.push(`NOT NULL`);
        }
        if (column.option.autoIncrement) {
            stringBuffer.push(`IDENTITY(1,1)`);
        }
        else {
            if (column.default.trim() !== '') {
                stringBuffer.push(`DEFAULT ${column.default}`);
            }
        }
        buffer.push(stringBuffer.join(' ') + `${isComma ? ',' : ''}`);
    }
    function formatComment$2({ table, buffer }) {
        if (table.comment.trim() !== '') {
            buffer.push(`EXECUTE sys.sp_addextendedproperty 'MS_Description',`);
            buffer.push(`  '${table.comment}', 'user', dbo, 'table', '${table.name}'\nGO`);
            buffer.push('');
        }
        table.columns.forEach(column => {
            if (column.comment.trim() !== '') {
                buffer.push(`EXECUTE sys.sp_addextendedproperty 'MS_Description',`);
                buffer.push(`  '${column.comment}', 'user', dbo, 'table', '${table.name}', 'column', '${column.name}'\nGO`);
                buffer.push('');
            }
        });
    }
    function formatRelation$3({ tables, relationship, buffer, fkNames, bracket, }) {
        const startTable = getData(tables, relationship.start.tableId);
        const endTable = getData(tables, relationship.end.tableId);
        if (startTable && endTable) {
            buffer.push(`ALTER TABLE ${bracket}${endTable.name}${bracket}`);
            // FK
            let fkName = `FK_${startTable.name}_TO_${endTable.name}`;
            fkName = autoName(fkNames, '', fkName);
            fkNames.push({
                id: v4(),
                name: fkName,
            });
            buffer.push(`  ADD CONSTRAINT ${bracket}${fkName}${bracket}`);
            // key
            const columns = {
                start: [],
                end: [],
            };
            relationship.end.columnIds.forEach(columnId => {
                const column = getData(endTable.columns, columnId);
                if (column) {
                    columns.end.push(column);
                }
            });
            relationship.start.columnIds.forEach(columnId => {
                const column = getData(startTable.columns, columnId);
                if (column) {
                    columns.start.push(column);
                }
            });
            buffer.push(`    FOREIGN KEY (${formatNames(columns.end, bracket)})`);
            buffer.push(`    REFERENCES ${bracket}${startTable.name}${bracket} (${formatNames(columns.start, bracket)})\nGO`);
        }
    }
    function formatIndex$3({ table, index, buffer, indexNames, bracket, }) {
        const columnNames = index.columns
            .map(indexColumn => {
            const column = getData(table.columns, indexColumn.id);
            if (column) {
                return {
                    name: `${bracket}${column.name}${bracket} ${indexColumn.orderType}`,
                };
            }
            return null;
        })
            .filter(columnName => columnName !== null);
        if (columnNames.length !== 0) {
            let indexName = index.name;
            if (indexName.trim() === '') {
                indexName = `IDX_${table.name}`;
                indexName = autoName(indexNames, '', indexName);
                indexNames.push({
                    id: v4(),
                    name: indexName,
                });
            }
            if (index.unique) {
                buffer.push(`CREATE UNIQUE INDEX ${bracket}${indexName}${bracket}`);
            }
            else {
                buffer.push(`CREATE INDEX ${bracket}${indexName}${bracket}`);
            }
            buffer.push(`  ON ${bracket}${table.name}${bracket} (${formatNames(columnNames)})\nGO`);
        }
    }

    function createDDL$3({ tableState, relationshipState, canvasState, }) {
        const fkNames = [];
        const indexNames = [];
        const stringBuffer = [''];
        const bracket = getBracket(canvasState.bracketType);
        const tables = orderByNameASC(tableState.tables);
        const relationships = relationshipState.relationships;
        const indexes = tableState.indexes;
        tables.forEach(table => {
            formatTable$2({ table, buffer: stringBuffer, bracket });
            stringBuffer.push('');
            // unique
            if (unique(table.columns)) {
                const uqColumns = uniqueColumns(table.columns);
                uqColumns.forEach(column => {
                    stringBuffer.push(`ALTER TABLE ${bracket}${table.name}${bracket}`);
                    stringBuffer.push(`  ADD CONSTRAINT ${bracket}UQ_${column.name}${bracket} UNIQUE (${bracket}${column.name}${bracket});`);
                    stringBuffer.push('');
                });
            }
        });
        relationships.forEach(relationship => {
            formatRelation$2({
                tables,
                relationship,
                buffer: stringBuffer,
                fkNames,
                bracket,
            });
            stringBuffer.push('');
        });
        indexes.forEach(index => {
            const table = getData(tables, index.tableId);
            if (table) {
                formatIndex$2({
                    table,
                    index,
                    buffer: stringBuffer,
                    indexNames,
                    bracket,
                });
                stringBuffer.push('');
            }
        });
        return stringBuffer.join('\n');
    }
    function formatTable$2({ table, buffer, bracket }) {
        buffer.push(`CREATE TABLE ${bracket}${table.name}${bracket}`);
        buffer.push(`(`);
        const pk = primaryKey(table.columns);
        const spaceSize = formatSize(table.columns);
        table.columns.forEach((column, i) => {
            if (pk) {
                formatColumn$2({
                    column,
                    isComma: true,
                    spaceSize,
                    buffer,
                    bracket,
                });
            }
            else {
                formatColumn$2({
                    column,
                    isComma: table.columns.length !== i + 1,
                    spaceSize,
                    buffer,
                    bracket,
                });
            }
        });
        // PK
        if (pk) {
            const pkColumns = primaryKeyColumns(table.columns);
            buffer.push(`  PRIMARY KEY (${formatNames(pkColumns, bracket)})`);
        }
        if (table.comment.trim() === '') {
            buffer.push(`);`);
        }
        else {
            buffer.push(`) COMMENT '${table.comment}';`);
        }
    }
    function formatColumn$2({ column, isComma, spaceSize, buffer, bracket, }) {
        const stringBuffer = [];
        stringBuffer.push(`  ${bracket}${column.name}${bracket}` +
            formatSpace(spaceSize.name - column.name.length));
        stringBuffer.push(`${column.dataType}` +
            formatSpace(spaceSize.dataType - column.dataType.length));
        stringBuffer.push(`${column.option.notNull ? 'NOT NULL' : 'NULL    '}`);
        if (column.option.autoIncrement) {
            stringBuffer.push(`AUTO_INCREMENT`);
        }
        else {
            if (column.default.trim() !== '') {
                stringBuffer.push(`DEFAULT ${column.default}`);
            }
        }
        if (column.comment.trim() !== '') {
            stringBuffer.push(`COMMENT '${column.comment}'`);
        }
        buffer.push(stringBuffer.join(' ') + `${isComma ? ',' : ''}`);
    }
    function formatRelation$2({ tables, relationship, buffer, fkNames, bracket, }) {
        const startTable = getData(tables, relationship.start.tableId);
        const endTable = getData(tables, relationship.end.tableId);
        if (startTable && endTable) {
            buffer.push(`ALTER TABLE ${bracket}${endTable.name}${bracket}`);
            // FK
            let fkName = `FK_${startTable.name}_TO_${endTable.name}`;
            fkName = autoName(fkNames, '', fkName);
            fkNames.push({
                id: v4(),
                name: fkName,
            });
            buffer.push(`  ADD CONSTRAINT ${bracket}${fkName}${bracket}`);
            // key
            const columns = {
                start: [],
                end: [],
            };
            relationship.end.columnIds.forEach(columnId => {
                const column = getData(endTable.columns, columnId);
                if (column) {
                    columns.end.push(column);
                }
            });
            relationship.start.columnIds.forEach(columnId => {
                const column = getData(startTable.columns, columnId);
                if (column) {
                    columns.start.push(column);
                }
            });
            buffer.push(`    FOREIGN KEY (${formatNames(columns.end, bracket)})`);
            buffer.push(`    REFERENCES ${bracket}${startTable.name}${bracket} (${formatNames(columns.start, bracket)});`);
        }
    }
    function formatIndex$2({ table, index, buffer, indexNames, bracket, }) {
        const columnNames = index.columns
            .map(indexColumn => {
            const column = getData(table.columns, indexColumn.id);
            if (column) {
                return {
                    name: `${bracket}${column.name}${bracket} ${indexColumn.orderType}`,
                };
            }
            return null;
        })
            .filter(columnName => columnName !== null);
        if (columnNames.length !== 0) {
            let indexName = index.name;
            if (index.name.trim() === '') {
                indexName = `IDX_${table.name}`;
                indexName = autoName(indexNames, '', indexName);
                indexNames.push({
                    id: v4(),
                    name: indexName,
                });
            }
            if (index.unique) {
                buffer.push(`CREATE UNIQUE INDEX ${bracket}${indexName}${bracket}`);
            }
            else {
                buffer.push(`CREATE INDEX ${bracket}${indexName}${bracket}`);
            }
            buffer.push(`  ON ${bracket}${table.name}${bracket} (${formatNames(columnNames)});`);
        }
    }

    function createDDL$2({ tableState, relationshipState, canvasState, }) {
        const fkNames = [];
        const aiNames = [];
        const trgNames = [];
        const indexNames = [];
        const stringBuffer = [''];
        const bracket = getBracket(canvasState.bracketType);
        const tables = orderByNameASC(tableState.tables);
        const relationships = relationshipState.relationships;
        const indexes = tableState.indexes;
        tables.forEach(table => {
            formatTable$1({ table, buffer: stringBuffer, bracket });
            stringBuffer.push('');
            // unique
            if (unique(table.columns)) {
                const uqColumns = uniqueColumns(table.columns);
                uqColumns.forEach(column => {
                    stringBuffer.push(`ALTER TABLE ${bracket}${table.name}${bracket}`);
                    stringBuffer.push(`  ADD CONSTRAINT ${bracket}UQ_${column.name}${bracket} UNIQUE (${bracket}${column.name}${bracket});`);
                    stringBuffer.push('');
                });
            }
            // Sequence
            table.columns.forEach(column => {
                if (column.option.autoIncrement) {
                    let aiName = `SEQ_${table.name}`;
                    aiName = autoName(aiNames, '', aiName);
                    aiNames.push({
                        id: v4(),
                        name: aiName,
                    });
                    stringBuffer.push(`CREATE SEQUENCE ${aiName}`);
                    stringBuffer.push(`START WITH 1`);
                    stringBuffer.push(`INCREMENT BY 1;`);
                    stringBuffer.push('');
                    let trgName = `SEQ_TRG_${table.name}`;
                    trgName = autoName(aiNames, '', trgName);
                    trgNames.push({
                        id: v4(),
                        name: trgName,
                    });
                    stringBuffer.push(`CREATE OR REPLACE TRIGGER ${trgName}`);
                    stringBuffer.push(`BEFORE INSERT ON ${table.name}`);
                    stringBuffer.push(`REFERENCING NEW AS NEW FOR EACH ROW`);
                    stringBuffer.push(`BEGIN`);
                    stringBuffer.push(`  SELECT ${aiName}.NEXTVAL`);
                    stringBuffer.push(`  INTO: NEW.${column.name}`);
                    stringBuffer.push(`  FROM DUAL;`);
                    stringBuffer.push(`END;`);
                    stringBuffer.push('');
                }
            });
            formatComment$1({ table, buffer: stringBuffer, bracket });
        });
        relationships.forEach(relationship => {
            formatRelation$1({
                tables,
                relationship,
                buffer: stringBuffer,
                fkNames,
                bracket,
            });
            stringBuffer.push('');
        });
        indexes.forEach(index => {
            const table = getData(tables, index.tableId);
            if (table) {
                formatIndex$1({ table, index, buffer: stringBuffer, indexNames, bracket });
                stringBuffer.push('');
            }
        });
        return stringBuffer.join('\n');
    }
    function formatTable$1({ table, buffer, bracket }) {
        buffer.push(`CREATE TABLE ${bracket}${table.name}${bracket}`);
        buffer.push(`(`);
        const pk = primaryKey(table.columns);
        const spaceSize = formatSize(table.columns);
        table.columns.forEach((column, i) => {
            if (pk) {
                formatColumn$1({ column, isComma: true, spaceSize, buffer, bracket });
            }
            else {
                formatColumn$1({
                    column,
                    isComma: table.columns.length !== i + 1,
                    spaceSize,
                    buffer,
                    bracket,
                });
            }
        });
        // PK
        if (pk) {
            const pkColumns = primaryKeyColumns(table.columns);
            buffer.push(`  CONSTRAINT ${bracket}PK_${table.name}${bracket} PRIMARY KEY (${formatNames(pkColumns, bracket)})`);
        }
        buffer.push(`);`);
    }
    function formatColumn$1({ column, isComma, spaceSize, buffer, bracket, }) {
        const stringBuffer = [];
        stringBuffer.push(`  ${bracket}${column.name}${bracket}` +
            formatSpace(spaceSize.name - column.name.length));
        stringBuffer.push(`${column.dataType}` +
            formatSpace(spaceSize.dataType - column.dataType.length));
        if (column.default.trim() !== '') {
            stringBuffer.push(`DEFAULT ${column.default}`);
        }
        if (column.option.notNull) {
            stringBuffer.push(`NOT NULL`);
        }
        buffer.push(stringBuffer.join(' ') + `${isComma ? ',' : ''}`);
    }
    function formatComment$1({ table, buffer, bracket }) {
        if (table.comment.trim() !== '') {
            buffer.push(`COMMENT ON TABLE ${bracket}${table.name}${bracket} IS '${table.comment}';`);
            buffer.push('');
        }
        table.columns.forEach(column => {
            if (column.comment.trim() !== '') {
                buffer.push(`COMMENT ON COLUMN ${bracket}${table.name}${bracket}.${bracket}${column.name}${bracket} IS '${column.comment}';`);
                buffer.push('');
            }
        });
    }
    function formatRelation$1({ tables, relationship, buffer, fkNames, bracket, }) {
        const startTable = getData(tables, relationship.start.tableId);
        const endTable = getData(tables, relationship.end.tableId);
        if (startTable && endTable) {
            buffer.push(`ALTER TABLE ${bracket}${endTable.name}${bracket}`);
            // FK
            let fkName = `FK_${startTable.name}_TO_${endTable.name}`;
            fkName = autoName(fkNames, '', fkName);
            fkNames.push({
                id: v4(),
                name: fkName,
            });
            buffer.push(`  ADD CONSTRAINT ${bracket}${fkName}${bracket}`);
            // key
            const columns = {
                start: [],
                end: [],
            };
            relationship.end.columnIds.forEach(columnId => {
                const column = getData(endTable.columns, columnId);
                if (column) {
                    columns.end.push(column);
                }
            });
            relationship.start.columnIds.forEach(columnId => {
                const column = getData(startTable.columns, columnId);
                if (column) {
                    columns.start.push(column);
                }
            });
            buffer.push(`    FOREIGN KEY (${formatNames(columns.end, bracket)})`);
            buffer.push(`    REFERENCES ${bracket}${startTable.name}${bracket} (${formatNames(columns.start, bracket)});`);
        }
    }
    function formatIndex$1({ table, index, buffer, indexNames, bracket, }) {
        const columnNames = index.columns
            .map(indexColumn => {
            const column = getData(table.columns, indexColumn.id);
            if (column) {
                return {
                    name: `${bracket}${column.name}${bracket} ${indexColumn.orderType}`,
                };
            }
            return null;
        })
            .filter(columnName => columnName !== null);
        if (columnNames.length !== 0) {
            let indexName = index.name;
            if (index.name.trim() === '') {
                indexName = `IDX_${table.name}`;
                indexName = autoName(indexNames, '', indexName);
                indexNames.push({
                    id: v4(),
                    name: indexName,
                });
            }
            if (index.unique) {
                buffer.push(`CREATE UNIQUE INDEX ${bracket}${indexName}${bracket}`);
            }
            else {
                buffer.push(`CREATE INDEX ${bracket}${indexName}${bracket}`);
            }
            buffer.push(`  ON ${bracket}${table.name}${bracket} (${formatNames(columnNames)});`);
        }
    }

    function createDDL$1({ tableState, relationshipState, canvasState, }) {
        const fkNames = [];
        const indexNames = [];
        const stringBuffer = [''];
        const bracket = getBracket(canvasState.bracketType);
        const tables = orderByNameASC(tableState.tables);
        const relationships = relationshipState.relationships;
        const indexes = tableState.indexes;
        tables.forEach(table => {
            formatTable({ table, buffer: stringBuffer, bracket });
            stringBuffer.push('');
            formatComment({ table, buffer: stringBuffer, bracket });
        });
        relationships.forEach(relationship => {
            formatRelation({
                tables,
                relationship,
                buffer: stringBuffer,
                fkNames,
                bracket,
            });
            stringBuffer.push('');
        });
        indexes.forEach(index => {
            const table = getData(tables, index.tableId);
            if (table) {
                formatIndex({ table, index, buffer: stringBuffer, indexNames, bracket });
                stringBuffer.push('');
            }
        });
        return stringBuffer.join('\n');
    }
    function formatTable({ table, buffer, bracket }) {
        buffer.push(`CREATE TABLE ${bracket}${table.name}${bracket}`);
        buffer.push(`(`);
        const pk = primaryKey(table.columns);
        const spaceSize = formatSize(table.columns);
        table.columns.forEach((column, i) => {
            if (pk) {
                formatColumn({ column, isComma: true, spaceSize, buffer, bracket });
            }
            else {
                formatColumn({
                    column,
                    isComma: table.columns.length !== i + 1,
                    spaceSize,
                    buffer,
                    bracket,
                });
            }
        });
        // PK
        if (pk) {
            const pkColumns = primaryKeyColumns(table.columns);
            buffer.push(`  PRIMARY KEY (${formatNames(pkColumns, bracket)})`);
        }
        buffer.push(`);`);
    }
    function formatColumn({ column, isComma, spaceSize, buffer, bracket, }) {
        const stringBuffer = [];
        stringBuffer.push(`  ${bracket}${column.name}${bracket}` +
            formatSpace(spaceSize.name - column.name.length));
        stringBuffer.push(`${column.dataType}` +
            formatSpace(spaceSize.dataType - column.dataType.length));
        if (column.option.notNull) {
            stringBuffer.push(`NOT NULL`);
        }
        if (column.option.autoIncrement) {
            stringBuffer.push(`GENERATED ALWAYS AS IDENTITY`);
        }
        else {
            if (column.default.trim() !== '') {
                stringBuffer.push(`DEFAULT ${column.default}`);
            }
        }
        if (column.option.unique) {
            stringBuffer.push(`UNIQUE`);
        }
        buffer.push(stringBuffer.join(' ') + `${isComma ? ',' : ''}`);
    }
    function formatComment({ table, buffer, bracket }) {
        if (table.comment.trim() !== '') {
            buffer.push(`COMMENT ON TABLE ${bracket}${table.name}${bracket} IS '${table.comment}';`);
            buffer.push('');
        }
        table.columns.forEach(column => {
            if (column.comment.trim() !== '') {
                buffer.push(`COMMENT ON COLUMN ${bracket}${table.name}${bracket}.${bracket}${column.name}${bracket} IS '${column.comment}';`);
                buffer.push('');
            }
        });
    }
    function formatRelation({ tables, relationship, buffer, fkNames, bracket, }) {
        const startTable = getData(tables, relationship.start.tableId);
        const endTable = getData(tables, relationship.end.tableId);
        if (startTable && endTable) {
            buffer.push(`ALTER TABLE ${bracket}${endTable.name}${bracket}`);
            // FK  
            let fkName = `FK_${startTable.name}_TO_${endTable.name}`;
            fkName = autoName(fkNames, '', fkName);
            fkNames.push({
                id: v4(),
                name: fkName,
            });
            buffer.push(`  ADD CONSTRAINT ${bracket}${fkName}${bracket}`);
            // key
            const columns = {
                start: [],
                end: [],
            };
            relationship.end.columnIds.forEach(columnId => {
                const column = getData(endTable.columns, columnId);
                if (column) {
                    columns.end.push(column);
                }
            });
            relationship.start.columnIds.forEach(columnId => {
                const column = getData(startTable.columns, columnId);
                if (column) {
                    columns.start.push(column);
                }
            });
            buffer.push(`    FOREIGN KEY (${formatNames(columns.end, bracket)})`);
            buffer.push(`    REFERENCES ${bracket}${startTable.name}${bracket} (${formatNames(columns.start, bracket)});`);
        }
    }
    function formatIndex({ table, index, buffer, indexNames, bracket, }) {
        const columnNames = index.columns
            .map(indexColumn => {
            const column = getData(table.columns, indexColumn.id);
            if (column) {
                return {
                    name: `${bracket}${column.name}${bracket} ${indexColumn.orderType}`,
                };
            }
            return null;
        })
            .filter(columnName => columnName !== null);
        if (columnNames.length !== 0) {
            let indexName = index.name;
            if (index.name.trim() === '') {
                indexName = `IDX_${table.name}`;
                indexName = autoName(indexNames, '', indexName);
                indexNames.push({
                    id: v4(),
                    name: indexName,
                });
            }
            if (index.unique) {
                buffer.push(`CREATE UNIQUE INDEX ${bracket}${indexName}${bracket}`);
            }
            else {
                buffer.push(`CREATE INDEX ${bracket}${indexName}${bracket}`);
            }
            buffer.push(`  ON ${bracket}${table.name}${bracket} (${formatNames(columnNames)});`);
        }
    }

    function createDDL(store, database) {
        const currentDatabase = database ? database : store.canvasState.database;
        switch (currentDatabase) {
            case 'KSQL':
                return createDDL$5(store);
            case 'MSSQL':
                return createDDL$4(store);
            case 'MySQL':
                return createDDL$3(store);
            case 'Oracle':
                return createDDL$2(store);
            case 'PostgreSQL':
                return createDDL$1(store);
        }
        return '';
    }
    function createDDLTable({ canvasState, tableState, relationshipState }, table) {
        const stringBuffer = [''];
        const database = canvasState.database;
        const indexNames = [];
        const indexes = tableState.indexes.filter(index => index.tableId === table.id);
        relationshipState.relationships;
        tableState.tables;
        const bracket = getBracket(canvasState.bracketType);
        switch (database) {
            case 'KSQL':
                formatTable$4({ table, buffer: stringBuffer, bracket });
                stringBuffer.push('');
                indexes.forEach(index => {
                    formatIndex$4({
                        table,
                        index,
                        buffer: stringBuffer,
                        indexNames,
                        bracket,
                    });
                    stringBuffer.push('');
                });
                break;
            case 'MSSQL':
                formatTable$3({ table, buffer: stringBuffer, bracket });
                stringBuffer.push('');
                indexes.forEach(index => {
                    formatIndex$3({
                        table,
                        index,
                        buffer: stringBuffer,
                        indexNames,
                        bracket,
                    });
                    stringBuffer.push('');
                });
                break;
            case 'MySQL':
                formatTable$2({ table, buffer: stringBuffer, bracket });
                stringBuffer.push('');
                indexes.forEach(index => {
                    formatIndex$2({
                        table,
                        index,
                        buffer: stringBuffer,
                        indexNames,
                        bracket,
                    });
                    stringBuffer.push('');
                });
                break;
            case 'Oracle':
                formatTable$1({ table, buffer: stringBuffer, bracket });
                stringBuffer.push('');
                indexes.forEach(index => {
                    formatIndex$1({
                        table,
                        index,
                        buffer: stringBuffer,
                        indexNames,
                        bracket,
                    });
                    stringBuffer.push('');
                });
                break;
            case 'PostgreSQL':
                formatTable({ table, buffer: stringBuffer, bracket });
                stringBuffer.push('');
                indexes.forEach(index => {
                    formatIndex({
                        table,
                        index,
                        buffer: stringBuffer,
                        indexNames,
                        bracket,
                    });
                    stringBuffer.push('');
                });
                break;
        }
        return stringBuffer.join('\n');
    }

    const SQLDDLStyle = css `
  .kderd-sql-ddl {
    height: 100%;
    white-space: pre;
    box-sizing: border-box;
    overflow: auto;
    font-family: monospace !important;
    outline: none;
  }
`;

    const SQLDDL = (props, ctx) => {
        const contextRef = useContext(ctx);
        const state = observable$1({
            menus: null,
            contextmenuX: 0,
            contextmenuY: 0,
        });
        const { unmountedGroup } = useUnmounted();
        const onContextmenu = (event) => {
            event.preventDefault();
            state.contextmenuX = event.clientX;
            state.contextmenuY = event.clientY;
            state.menus = createSQLDDLMenus(contextRef.value);
        };
        const onCloseContextmenu = () => (state.menus = null);
        const onMousedown = () => onCloseContextmenu();
        beforeMount(() => {
            const context = contextRef.value;
            const { store: { canvasState }, eventBus, } = context;
            unmountedGroup.push(watch(canvasState, propName => {
                var _a;
                if (propName !== 'database')
                    return;
                const menue = (_a = state.menus) === null || _a === void 0 ? void 0 : _a.find(menu => menu.name === 'Database');
                if (!menue)
                    return;
                menue.children = createDatabaseMenus(context);
            }), watch(canvasState, propName => {
                var _a;
                if (propName !== 'highlightTheme')
                    return;
                const menue = (_a = state.menus) === null || _a === void 0 ? void 0 : _a.find(menu => menu.name === 'Highlight Theme');
                if (!menue)
                    return;
                menue.children = createHighlightThemeMenus(context);
            }), watch(canvasState, propName => {
                var _a;
                if (propName !== 'bracketType')
                    return;
                const menue = (_a = state.menus) === null || _a === void 0 ? void 0 : _a.find(menu => menu.name === 'Bracket');
                if (!menue)
                    return;
                menue.children = createBracketTypeMenus(context);
            }), eventBus.on(Bus.Contextmenu.close).subscribe(onCloseContextmenu));
        });
        return () => {
            const { store } = contextRef.value;
            const { canvasState: { highlightTheme }, } = store;
            const sql = props.mode === 'all' || !props.table
                ? createDDL(store)
                : createDDLTable(store, props.table);
            const sqlHTML = core.highlight(sql, {
                language: 'sql',
            }).value;
            return html `
      <style type="text/css">
        ${highlightThemeMap[highlightTheme]}
      </style>
      <div
        class="kderd-sql-ddl kderd-scrollbar hljs"
        contenteditable="true"
        spellcheck="false"
        @mousedown=${onMousedown}
        @contextmenu=${onContextmenu}
      >
        ${unsafeHTML(sqlHTML)}
        ${state.menus
            ? html `
              <kderd-contextmenu
                .menus=${state.menus}
                .x=${state.contextmenuX}
                .y=${state.contextmenuY}
                @close=${onCloseContextmenu}
              >
              </kderd-contextmenu>
            `
            : null}
      </div>
    `;
        };
    };
    defineComponent('kderd-sql-ddl', {
        observedProps: [
            {
                name: 'table',
                default: null,
            },
            {
                name: 'mode',
                default: 'all',
            },
        ],
        styleMap: {
            width: '100%',
            height: '100%',
        },
        style: [SQLDDLStyle, ScrollbarStyle].join(''),
        render: SQLDDL,
    });

    const findIndex = findIndex$4(propEq$1('active', true));
    function useColumnHint(props, ctx) {
        const contextRef = useContext(ctx);
        const { unmountedGroup } = useUnmounted();
        const state = observable$1({
            value: '',
            hints: [],
            isFilter: true,
            focus: false,
        });
        const inputRef = query('input');
        const getActiveIndex = () => findIndex(state.hints);
        const setHints = () => {
            if (!state.isFilter)
                return;
            const columns = props.table.columns;
            state.hints =
                state.value.trim().length < 1
                    ? []
                    : columns
                        .filter(column => column.name.toLowerCase().indexOf(state.value.toLowerCase()) !==
                        -1)
                        .map(column => {
                        return {
                            id: column.id,
                            name: column.name,
                            html: markToHTML('kderd-index-add-column-hint-mark', column.name, state.value),
                            active: false,
                        };
                    });
        };
        const activeEnd = () => {
            state.hints.forEach(hint => (hint.active = false));
        };
        const onSelectHint = (hint) => {
            const { store } = contextRef.value;
            const { indexes } = store.tableState;
            const columns = props.table.columns;
            activeEnd();
            state.isFilter = false;
            lastCursorFocus(inputRef.value);
            const indexModel = getData(indexes, props.indexId);
            const targetColumn = getData(columns, hint.id);
            if (targetColumn &&
                indexModel &&
                !indexModel.columns.some(column => column.id === targetColumn.id)) {
                store.dispatch(addIndexColumn(props.indexId, targetColumn.id));
            }
        };
        const onArrowUp = (event) => {
            state.hints.length !== 0 && event.preventDefault();
            const index = getActiveIndex();
            if (index > 0) {
                state.hints[index].active = false;
                state.hints[index - 1].active = true;
            }
            else if (state.hints.length) {
                index === 0 && (state.hints[index].active = false);
                state.hints[state.hints.length - 1].active = true;
            }
        };
        const onArrowDown = (event) => {
            state.hints.length !== 0 && event.preventDefault();
            const index = getActiveIndex();
            if (index !== -1 && index !== state.hints.length - 1) {
                state.hints[index].active = false;
                state.hints[index + 1].active = true;
            }
            else if (state.hints.length) {
                index === state.hints.length - 1 && (state.hints[index].active = false);
                state.hints[0].active = true;
            }
        };
        const onArrowLeft = () => activeEnd();
        const onArrowRight = (event) => {
            const index = getActiveIndex();
            if (index < 0)
                return;
            event.preventDefault();
            const { store } = contextRef.value;
            const { indexes } = store.tableState;
            const columns = props.table.columns;
            state.isFilter = false;
            const indexModel = getData(indexes, props.indexId);
            const targetColumn = getData(columns, state.hints[index].id);
            if (targetColumn &&
                indexModel &&
                !indexModel.columns.some(column => column.id === targetColumn.id)) {
                store.dispatch(addIndexColumn(props.indexId, targetColumn.id));
            }
        };
        const arrowMap = {
            ArrowUp: onArrowUp,
            ArrowDown: onArrowDown,
            ArrowLeft: onArrowLeft,
            ArrowRight: onArrowRight,
        };
        const onKeydown = (event) => {
            switch (event.key) {
                case 'ArrowUp':
                case 'ArrowDown':
                case 'ArrowLeft':
                case 'ArrowRight':
                    arrowMap[event.key](event);
                    break;
            }
        };
        const onInput = (event) => {
            const input = event.target;
            state.value = input.value;
            state.isFilter = true;
        };
        beforeMount(() => unmountedGroup.push(watch(state, propName => {
            if (propName !== 'value')
                return;
            setHints();
        })));
        return {
            hintState: state,
            onSelectHint,
            onKeydown,
            onInput,
        };
    }

    const hintTpl = (props, state) => html `
  <ul class="kderd-index-add-column-list">
    ${repeat(state.hints, hint => hint.id, hint => {
    return html `
          <li
            class=${classMap({
        'kderd-index-add-column-hint': true,
        active: hint.active,
    })}
            @click=${() => props.onSelectHint(hint)}
          >
            ${unsafeHTML(hint.html)}
          </li>
        `;
})}
  </ul>
`;

    const IndexAddColumn = (props, ctx) => {
        const contextRef = useContext(ctx);
        const { hintState, onSelectHint, onKeydown, onInput } = useColumnHint(props, ctx);
        useFlipAnimation(ctx, '.kderd-index-add-column-hint', 'kderd-index-add-column-hint-move');
        const onFocus = () => {
            hintState.focus = true;
        };
        const onBlur = () => {
            hintState.focus = false;
            setTimeout(() => {
                if (hintState.focus)
                    return;
                hintState.hints = [];
            }, 200);
        };
        return () => {
            const { store: { editorState: { readonly }, }, } = contextRef.value;
            return html `
      <div class="kderd-index-add-column">
        <input
          style="width: 80px;"
          type="text"
          placeholder="add column"
          spellcheck="false"
          ?disabled=${readonly}
          .value=${hintState.value}
          @keydown=${onKeydown}
          @input=${onInput}
          @focus=${onFocus}
          @blur=${onBlur}
        />
        ${hintTpl({ onSelectHint }, hintState)}
      </div>
    `;
        };
    };
    defineComponent('kderd-index-add-column', {
        observedProps: ['table', 'indexId'],
        shadow: false,
        render: IndexAddColumn,
    });

    const IndexColumn = (props, ctx) => {
        const contextRef = useContext(ctx);
        const state = observable$1({ currentColumnId: '' });
        const columnsRef = queryAll('.kderd-index-column');
        const columnNamesRef = queryAll('.kderd-index-column-name');
        const flipAnimation = new FlipAnimation(ctx.shadowRoot ? ctx.shadowRoot : ctx, '.kderd-index-column', 'kderd-index-column-move');
        const { unmountedGroup } = useUnmounted();
        const { resetTooltip } = useTooltip(['.kderd-index-column-button'], ctx);
        const getIndex = () => {
            const { indexes } = contextRef.value.store.tableState;
            const index = getData(indexes, props.indexId);
            if (!index)
                return null;
            return {
                id: index.id,
                columns: index.columns
                    .map(column => {
                    const data = getData(props.table.columns, column.id);
                    if (!data)
                        return null;
                    const newData = cloneDeep(data);
                    newData.orderType = column.orderType;
                    return newData;
                })
                    .filter(column => !!column),
            };
        };
        const onChangeColumnOrderType = (column) => {
            const { store } = contextRef.value;
            let value = 'ASC';
            if (column.orderType === 'ASC') {
                value = 'DESC';
            }
            store.dispatch(changeIndexColumnOrderType(props.indexId, column.id, value));
        };
        const onRemoveColumn = (column) => {
            const { store } = contextRef.value;
            store.dispatch(removeIndexColumn(props.indexId, column.id));
        };
        const onMoveIndexColumn = (currentId, targetId) => {
            const { store } = contextRef.value;
            if (currentId === targetId)
                return;
            flipAnimation.snapshot();
            store.dispatch(moveIndexColumn(props.indexId, currentId, targetId));
        };
        const onDragstart = (currentId) => {
            state.currentColumnId = currentId;
            columnNamesRef.value.forEach(el => el.classList.add('none-hover'));
            fromShadowDraggable(columnsRef.value).subscribe({
                next: id => onMoveIndexColumn(currentId, id),
                complete: () => {
                    state.currentColumnId = '';
                    columnNamesRef.value.forEach(el => el.classList.remove('none-hover'));
                },
            });
        };
        beforeMount(() => {
            const { indexes } = contextRef.value.store.tableState;
            const index = getData(indexes, props.indexId);
            unmountedGroup.push(watch(index.columns, () => resetTooltip()));
        });
        updated(() => flipAnimation.play());
        return () => {
            const index = getIndex();
            return index
                ? html `
          ${repeat(index.columns, column => column.id, column => html `
              <div
                class=${classMap({
                'kderd-index-column': true,
                draggable: state.currentColumnId === column.id,
            })}
                data-id=${column.id}
                draggable="true"
                @dragstart=${() => onDragstart(column.id)}
              >
                <div class="kderd-index-column-name">${column.name}</div>
                <div
                  class="kderd-index-column-order"
                  @click=${() => onChangeColumnOrderType(column)}
                >
                  ${column.orderType}
                </div>
                <div style="display: inline-block;">
                  <kderd-icon
                    class="kderd-button kderd-index-column-button"
                    data-tippy-content=""
                    name="times"
                    size="9"
                    @click=${() => onRemoveColumn(column)}
                  ></kderd-icon>
                </div>
              </div>
            `)}
        `
                : null;
        };
    };
    defineComponent('kderd-index-column', {
        observedProps: ['table', 'indexId'],
        shadow: false,
        render: IndexColumn,
    });

    const IndexesStyle = css `
  .kderd-indexes {
    display: flex;
    flex-direction: column;
    height: 100%;
  }

  .kderd-indexes input {
    display: inline-flex;
    vertical-align: middle;
    align-items: center;
    margin-right: ${SIZE_COLUMN_MARGIN_RIGHT}px;
    color: var(--kderd-color-font-active);
    background-color: var(--kderd-color-contextmenu);
    outline: none;
    border: none;
    opacity: 0.9;
    padding: 1px 0 1px 0;
    height: 23.5px;
    font-size: ${SIZE_FONT}px;
    font-family: var(--kderd-font-family);
    border-bottom: solid #fff0 1.5px;
  }
  .kderd-indexes input:focus {
    border-bottom: solid var(--kderd-color-edit) 1.5px;
  }
  .kderd-index {
    fill: #fff0;
    color: var(--kderd-color-font-active);
  }
  .kderd-index:hover,
  .kderd-index-column:hover {
    fill: var(--kderd-color-font);
  }
  .kderd-index-column {
    fill: #fff0;
    display: inline-block;
  }
  .kderd-index-column.draggable {
    opacity: 0.5;
  }
  .kderd-index-unique {
    display: inline-block;
    cursor: pointer;
    color: var(--kderd-color-font-placeholder);
  }
  .kderd-index-unique.checked {
    color: var(--kderd-color-font-active);
  }
  .kderd-index-column-name {
    display: inline-block;
    cursor: move;
    padding: 5px;
  }
  .kderd-index-column-name:hover {
    background-color: var(--kderd-color-contextmenu-active);
  }
  .kderd-index-column-name.none-hover:hover {
    background-color: var(--kderd-color-contextmenu);
  }
  .kderd-index-column-order {
    display: inline-block;
    cursor: pointer;
  }
  .kderd-index-add-column {
    display: inline-block;
    position: relative;
  }
  .kderd-index-add-column-list {
    position: absolute;
    top: 27px;
    left: 0;
    z-index: 100;
    color: var(--kderd-color-font);
    background-color: var(--kderd-color-contextmenu);
    opacity: 0.9;
    list-style: none;
    padding: 0;
    margin: 0;
  }
  .kderd-index-add-column-list > li {
    padding: 5px;
    cursor: pointer;
    font-size: ${SIZE_FONT}px;
  }
  .kderd-index-add-column-list > li:hover,
  .kderd-index-add-column-hint.active {
    color: var(--kderd-color-font-active);
    background-color: var(--kderd-color-contextmenu-active);
  }
  .kderd-index-add-column-list > li:hover .kderd-index-add-column-hint-mark,
  .kderd-index-add-column-hint.active .kderd-index-add-column-hint-mark {
    color: var(--kderd-color-font-active);
  }
  /* animation flip */
  .kderd-index-add-column-hint-move {
    transition: transform 0.2s;
  }
  .kderd-index-column-move {
    transition: transform 0.3s;
  }

  .kderd-index-add-column-hint-mark {
    color: var(--kderd-color-edit);
  }
`;

    const IndexStyle$1 = [DefaultStyle, IndexesStyle].join('');

    const Indexes = (props, ctx) => {
        const contextRef = useContext(ctx);
        const { resetTooltip } = useTooltip(['.kderd-indexes-button', '.kderd-index-unique'], ctx);
        const { unmountedGroup } = useUnmounted();
        const getIndexes = () => {
            const { indexes } = contextRef.value.store.tableState;
            return indexes.filter(index => { var _a; return index.tableId === ((_a = props.table) === null || _a === void 0 ? void 0 : _a.id); });
        };
        const onAddIndex = () => {
            if (!props.table)
                return;
            const { store } = contextRef.value;
            store.dispatch(addIndex(props.table.id));
        };
        const onRemoveIndex = (index) => {
            const { store } = contextRef.value;
            store.dispatch(removeIndex([index.id]));
        };
        const onChangeIndexUnique = (index) => {
            const { store } = contextRef.value;
            store.dispatch(changeIndexUnique(index.id, !index.unique));
        };
        const onInput = (event, index) => {
            const { store } = contextRef.value;
            const input = event.target;
            store.dispatch(changeIndexName(index.id, input.value));
        };
        beforeMount(() => {
            const { indexes } = contextRef.value.store.tableState;
            unmountedGroup.push(watch(indexes, () => resetTooltip()));
        });
        return () => {
            const { store: { editorState: { readonly }, }, } = contextRef.value;
            const { table } = props;
            const indexes = getIndexes();
            return table
                ? html `
          <div class="kderd-indexes">
            <div style="display: inline-block;">
              <kderd-icon
                class="kderd-button kderd-indexes-button"
                data-tippy-content=""
                name="plus"
                size="12"
                @click=${onAddIndex}
              ></kderd-icon>
            </div>
            <div class="kderd-scrollbar" style="height: 100%; overflow: auto;">
              ${repeat(indexes, index => index.id, index => html `
                  <div class="kderd-index">
                    <div style="display: inline-block;">
                      <kderd-icon
                        class="kderd-button kderd-indexes-button"
                        data-tippy-content=""
                        name="times"
                        size="9"
                        @click=${() => onRemoveIndex(index)}
                      ></kderd-icon>
                    </div>
                    <div
                      class=${classMap({
                'kderd-index-unique': true,
                checked: index.unique,
            })}
                      style="width: 22px;"
                      data-tippy-content=""
                      @click=${() => onChangeIndexUnique(index)}
                    >
                      UQ
                    </div>
                    <input
                      type="text"
                      placeholder="index name"
                      spellcheck="false"
                      ?disabled=${readonly}
                      .value=${index.name}
                      @input=${(event) => onInput(event, index)}
                    />
                    <kderd-index-add-column
                      .table=${table}
                      .indexId=${index.id}
                    ></kderd-index-add-column>
                    <kderd-index-column
                      .table=${table}
                      .indexId=${index.id}
                      @dragenter=${onPreventDefault}
                      @dragover=${onPreventDefault}
                    ></kderd-index-column>
                  </div>
                `)}
            </div>
          </div>
        `
                : null;
        };
    };
    defineComponent('kderd-indexes', {
        observedProps: [
            {
                name: 'table',
                default: null,
            },
        ],
        styleMap: {
            width: '100%',
            height: '100%',
        },
        style: IndexStyle$1,
        render: Indexes,
    });

    const tabs = [
        {
            name: '',
            type: 'indexes',
        },
        {
            name: 'SQL DDL',
            type: 'SQL',
        },
    ];
    const TablePropertiesDrawer = (props, ctx) => {
        const state = observable$1({
            tabType: 'indexes',
        });
        const contextRef = useContext(ctx);
        const onClose = () => ctx.dispatchEvent(new CustomEvent('close'));
        const onChangeTab = (tabType) => (state.tabType = tabType);
        return () => {
            var _a;
            const { tables } = contextRef.value.store.tableState;
            const table = getData(tables, props.tableId);
            return html `
      <kderd-drawer
        .name=${`Table Properties "${(_a = table === null || table === void 0 ? void 0 : table.name) !== null && _a !== void 0 ? _a : ''}"`}
        .width=${props.width}
        .visible=${props.visible}
        @close=${onClose}
      >
        <div class="kderd-table-properties">
          <ul class="kderd-table-properties-tab">
            ${tabs.map(tab => html `
                  <li
                    class=${classMap({
            active: tab.type === state.tabType,
        })}
                    @click=${() => onChangeTab(tab.type)}
                  >
                    ${tab.name}
                  </li>
                `)}
          </ul>
          <div class="kderd-table-properties-body">
            ${table
            ? state.tabType === 'indexes'
                ? html `<kderd-indexes .table=${table}></kderd-indexes>`
                : state.tabType === 'SQL'
                    ? html `<kderd-sql-ddl
                    mode="table"
                    .table=${table}
                  ></kderd-sql-ddl>`
                    : state.tabType === 'GeneratorCode'
                        ? html `
                    <kderd-generator-code
                      mode="table"
                      .table=${table}
                    ></kderd-generator-code>
                  `
                        : null
            : null}
          </div>
        </div>
      </kderd-drawer>
    `;
        };
    };
    defineComponent('kderd-table-properties-drawer', {
        observedProps: ['width', 'visible', 'tableId'],
        shadow: false,
        render: TablePropertiesDrawer,
    });

    function useERDEditorDrawer(props, { eventBus, store }) {
        const state = observable$1({
            help: false,
            setting: false,
            tableProperties: false,
        });
        const { unmountedGroup } = useUnmounted();
        let tableId = '';
        const createOpen = (key) => () => {
            Object.keys(state).forEach(stateKey => {
                if (stateKey === key)
                    return;
                state[stateKey] = false;
            });
            store.dispatch(findActiveEnd(), filterActiveEnd());
            state[key] = !state[key];
        };
        const createClose = (key) => () => (state[key] = false);
        const openHelp = createOpen('help');
        const closeHelp = createClose('help');
        const openSetting = createOpen('setting');
        const closeSetting = createClose('setting');
        const openTableProperties = createOpen('tableProperties');
        const closeTableProperties = createClose('tableProperties');
        const closeDrawer = () => {
            if (state.tableProperties && tableId) {
                store.dispatch(selectTable$(store, false, tableId));
            }
            closeHelp();
            closeSetting();
            closeTableProperties();
            tableId = '';
        };
        beforeMount(() => unmountedGroup.push(eventBus.on(Bus.Drawer.openTableProperties).subscribe(data => {
            store.dispatch(selectEndMemo(), drawEndRelationship(), selectEndTable$());
            tableId = data.tableId;
            openTableProperties();
        }), eventBus.on(Bus.Drawer.close).subscribe(closeDrawer)));
        return {
            drawerTpl: () => html `
      <kderd-help-drawer
        .width=${props.width}
        .visible=${state.help}
        @close=${closeHelp}
      ></kderd-help-drawer>
      <kderd-setting-drawer
        .width=${props.width}
        .visible=${state.setting}
        @close=${closeSetting}
      ></kderd-setting-drawer>
      <kderd-table-properties-drawer
        .width=${props.width}
        .visible=${state.tableProperties}
        .tableId=${tableId}
        @close=${closeTableProperties}
      >
      </kderd-table-properties-drawer>
    `,
            closeDrawer,
            openHelp,
            closeHelp,
            openSetting,
            closeSetting,
            openTableProperties,
            closeTableProperties,
        };
    }

    function useERDEditorElement(context, ctx, { setFocus }) {
        const { store, helper } = context;
        const { editorState } = store;
        const { unmountedGroup } = useUnmounted();
        Object.defineProperty(ctx, 'value', {
            get() {
                const { store } = context;
                return createJsonStringify(store);
            },
            set(json) {
                const { store } = context;
                isString$1(json) && json.trim()
                    ? store.dispatch(loadJson$(json))
                    : store.dispatch(clear());
            },
        });
        ctx.focus = () => {
            helper.focus();
            setFocus();
        };
        ctx.blur = () => {
            helper.blur();
            setFocus();
        };
        ctx.clear = () => {
            store.dispatch(clear());
        };
        ctx.initLoadJson = (json) => {
            if (isString$1(json) && json.trim()) {
                store.dispatch(initLoadJson$(json));
            }
        };
        ctx.loadSQLDDL = (sql) => {
            if (isString$1(sql) && sql.trim()) {
                const statements = DDLParser(sql);
                // @ts-ignore
                const json = createJson(statements, helper, store.canvasState.database);
                store.dispatch(loadJson$(json), sortTable());
            }
        };
        ctx.getSQLDDL = (database) => {
            return database && databaseList.includes(database)
                ? createDDL(store, database)
                : createDDL(store);
        };
        ctx.setTheme = (theme) => loadTheme(context.theme, theme);
        ctx.setKeymap = (keymap) => loadKeymap(context.keymap, keymap);
        ctx.extension = (config) => {
            isArray$1(config.panels) &&
                editorState.panels.push(...config.panels);
        };
        beforeMount(() => unmountedGroup.push(store.change$.subscribe(() => editorState.readonly || ctx.dispatchEvent(new CustomEvent('change')))));
    }

    const FOCUS_TIME = 50;
    function useERDEditorGhost({ helper, globalEvent: { moveStart$ } }, ctx) {
        const editorRef = query('.kderd-editor');
        const ghostTextRef = query('.kderd-ghost-text-helper');
        const ghostTableHeadTextRef = query('.kderd-ghost-talbe-head-text-helper');
        const ghostInputRef = query('.kderd-ghost-focus-helper');
        const state = observable$1({ focus: false });
        const { unmountedGroup } = useUnmounted();
        let timerId = null;
        const setFocus = () => {
            state.focus = document.activeElement === ctx && document.hasFocus();
        };
        const onFocus = () => {
            setTimeout(() => {
                document.activeElement !== ctx && helper.focus();
                setFocus();
            }, 0);
        };
        mounted(() => {
            helper.setGhostText(ghostTextRef.value);
            helper.setGhostTableHeadText(ghostTableHeadTextRef.value);
            helper.setGhostInput(ghostInputRef.value);
            helper.focus();
            setFocus();
            timerId = setInterval(() => setFocus(), 200);
            unmountedGroup.push(merge(fromEvent(editorRef.value, 'mousedown'), fromEvent(editorRef.value, 'touchstart'), fromEvent(editorRef.value, 'kderd-contextmenu-mousedown'), fromEvent(editorRef.value, 'kderd-contextmenu-touchstart'), fromEvent(editorRef.value, 'kderd-input-blur'))
                .pipe(throttleTime(FOCUS_TIME))
                .subscribe(onFocus), moveStart$
                .pipe(throttleTime(FOCUS_TIME))
                .subscribe(() => setTimeout(setFocus, 0)), () => clearInterval(timerId));
        });
        return {
            ghostTpl: html `
      <input class="kderd-ghost-focus-helper" type="text" />
      <span class="kderd-ghost-text-helper"></span>
      <span class="kderd-ghost-talbe-head-text-helper"></span>      
    `,
            ghostState: state,
            setFocus,
            onFocus,
        };
    }

    function usePanelView(props, { store: { editorState, canvasState } }) {
        const state = observable$1({ count: 0 });
        const data = {
            isPanel: false,
            canvasType: '',
        };
        const hasPanel = () => {
            const canvasType = canvasState.canvasType;
            const panels$1 = [...panels, ...editorState.panels];
            return (canvasType !== 'ERD' && panels$1.some(panel => panel.key === canvasType));
        };
        const renderPanel = () => queueMicrotask(() => {
            data.isPanel = true;
            state.count++;
        });
        beforeFirstUpdate(() => state.count);
        beforeUpdate(() => state.count);
        return {
            hasPanel,
            panelTpl() {
                const width = props.width;
                const height = props.height - SIZE_MENUBAR_HEIGHT;
                const canvasType = canvasState.canvasType;
                const panels$1 = [...panels, ...editorState.panels];
                const isPanel = hasPanel();
                data.isPanel = isPanel;
                if (isPanel && data.canvasType != canvasType) {
                    data.isPanel = false;
                    renderPanel();
                }
                data.canvasType = canvasType;
                return data.isPanel
                    ? html `
            <kderd-panel-view
              .width=${width}
              .height=${height}
              .panel=${panels$1.find(panel => panel.key === canvasType)}
            ></kderd-panel-view>
          `
                    : null;
            },
        };
    }

    const ignoreEnterProcess = (source$) => new Observable(subscriber => source$
        .pipe(groupBy(event => event.code === 'Enter'), mergeMap(group$ => group$.key
        ? group$.pipe(filter(event => event.key !== 'Process'), throttleTime(100))
        : group$))
        .subscribe(subscriber));

    /**
     * https://github.com/atomiks/tippyjs
     */
    const TippyStyle = css `
  .tippy-box[data-animation='fade'][data-state='hidden'] {
    opacity: 0;
  }
  [data-tippy-root] {
    max-width: calc(100vw - 10px);
  }
  .tippy-box {
    position: relative;
    background-color: black;
    color: #fff;
    border-radius: 4px;
    font-size: 14px;
    line-height: 1.4;
    outline: 0;
    transition-property: transform, visibility, opacity;
  }
  .tippy-box[data-placement^='top'] > .tippy-arrow {
    bottom: 0;
  }
  .tippy-box[data-placement^='top'] > .tippy-arrow:before {
    bottom: -7px;
    left: 0;
    border-width: 8px 8px 0;
    border-top-color: initial;
    transform-origin: center top;
  }
  .tippy-box[data-placement^='bottom'] > .tippy-arrow {
    top: 0;
  }
  .tippy-box[data-placement^='bottom'] > .tippy-arrow:before {
    top: -7px;
    left: 0;
    border-width: 0 8px 8px;
    border-bottom-color: initial;
    transform-origin: center bottom;
  }
  .tippy-box[data-placement^='left'] > .tippy-arrow {
    right: 0;
  }
  .tippy-box[data-placement^='left'] > .tippy-arrow:before {
    border-width: 8px 0 8px 8px;
    border-left-color: initial;
    right: -7px;
    transform-origin: center left;
  }
  .tippy-box[data-placement^='right'] > .tippy-arrow {
    left: 0;
  }
  .tippy-box[data-placement^='right'] > .tippy-arrow:before {
    left: -7px;
    border-width: 8px 8px 8px 0;
    border-right-color: initial;
    transform-origin: center right;
  }
  .tippy-box[data-inertia][data-state='visible'] {
    transition-timing-function: cubic-bezier(0.54, 1.5, 0.38, 1.11);
  }
  .tippy-arrow {
    width: 16px;
    height: 16px;
    color: black;
  }
  .tippy-arrow:before {
    content: '';
    position: absolute;
    border-color: transparent;
    border-style: solid;
  }
  .tippy-content {
    position: relative;
    padding: 5px 9px;
    z-index: 1;
    word-break: break-all;
  }
`;

    const SettingDrawerStyle = css `
  .kderd-setting-drawer tbody tr td {
    padding-right: 20px;
    padding-bottom: 10px;
  }

  .kderd-setting-drawer .kderd-column-order {
    cursor: move;
    box-sizing: border-box;
    padding: 5px;
    display: inline-block;
  }
  .kderd-setting-drawer .kderd-column-order:hover {
    color: var(--kderd-color-font-active);
    background-color: var(--kderd-color-contextmenu-active);
  }
  .kderd-setting-drawer .kderd-column-order.draggable {
    opacity: 0.5;
  }
  .kderd-setting-drawer .kderd-column-order.none-hover:hover {
    color: var(--kderd-color-font);
    background-color: var(--kderd-color-contextmenu);
  }

  /* animation flip */
  .kderd-setting-drawer .kderd-column-order-move {
    transition: transform 0.3s;
  }

  .kderd-setting-drawer .kderd-recalculating-table-width-button {
    box-sizing: border-box;
    padding: 5px;
    display: inline-block;
    cursor: pointer;
    fill: var(--kderd-color-font);
    font-size: 15px;
  }
  .kderd-setting-drawer .kderd-recalculating-table-width-button:hover {
    color: var(--kderd-color-font-active);
    background-color: var(--kderd-color-contextmenu-active);
    fill: var(--kderd-color-font-active);
  }
`;

    const TablePropertiesDrawerStyle = css `
  .kderd-table-properties {
    display: flex;
    flex-direction: column;
    height: 100%;
  }

  .kderd-table-properties-tab {
    list-style: none;
    padding: 0;
    margin: 0;
    display: flex;
    margin-bottom: 10px;
  }
  .kderd-table-properties-tab > li {
    padding: 10px;
    box-sizing: border-box;
    cursor: pointer;
    font-size: ${SIZE_FONT}px;
    white-space: nowrap;
    display: inline-block;
  }
  .kderd-table-properties-tab > li:hover {
    color: var(--kderd-color-font-active);
    background-color: var(--kderd-color-contextmenu-active);
  }
  .kderd-table-properties-tab > li.active {
    color: var(--kderd-color-font-active);
    background-color: var(--kderd-color-contextmenu-active);
  }

  .kderd-table-properties-body {
    width: 100%;
    height: 100%;
    overflow: hidden;
  }
`;

    const ERDEditorStyle = css `
  .kderd-editor {
    display: flex;
    flex-direction: column;
    overflow: hidden;
    background-color: #f8f8f8;
    box-sizing: border-box;
    border: 1px solid #D9D9D9;
    position: relative;
  }

  .kderd-ghost-text-helper {
    visibility: hidden;
    position: fixed;
    top: -100px;
    font-size: ${SIZE_FONT}px;
    font-family: var(--kderd-font-family);
    white-space: nowrap;
  }

  .kderd-ghost-talbe-head-text-helper {
    visibility: hidden;
    position: fixed;
    top: -100px;
    font-size: ${SIZE_FONT_TABLE_HEAD}px;
    font-weight: bold;
    font-family: var(--kderd-font-family);
    white-space: nowrap;
  }

  .kderd-ghost-focus-helper {
    position: fixed;
    top: -100px;
  }
`;

    const IndexStyle = [
        TippyStyle,
        ERDEditorStyle,
        TablePropertiesDrawerStyle,
        SettingDrawerStyle,
        IconStyle,
    ].join('');

    const ERDEditor = (props, ctx) => {
        const context = createdERDEditorContext();
        const { store, helper, keymap, eventBus } = context;
        const editorRef = query('.kderd-editor');
        const { ghostTpl, ghostState, setFocus, onFocus } = useERDEditorGhost(context, ctx);
        const { drawerTpl, closeDrawer, openHelp, openSetting } = useERDEditorDrawer(props, context);
        const { hasPanel, panelTpl } = usePanelView(props, context);
        const { unmountedGroup } = useUnmounted();
        useERDEditorElement(context, ctx, { setFocus });
        // @ts-ignore
        const resizeObserver = new ResizeObserver(entries => {
            entries.forEach((entry) => {
                const { width, height } = entry.contentRect;
                ctx.setAttribute('width', width);
                ctx.setAttribute('height', height);
            });
        });
        const onOutside = (event) => {
            const el = event.target;
            if (el.closest('kderd-menubar') || el.closest('kderd-drawer')) {
                store.dispatch(editTableEnd(), editFilterEnd());
            }
            if (!el.closest('kderd-menubar') && !el.closest('kderd-drawer')) {
                closeDrawer();
            }
        };
        mounted(() => {
            props.automaticLayout && resizeObserver.observe(editorRef.value);
            store.dispatch(readonlyEditor$(props.readonly));
            unmountedGroup.push(watch(props, propName => {
                if (propName !== 'automaticLayout')
                    return;
                if (props.automaticLayout) {
                    resizeObserver.observe(editorRef.value);
                }
                else {
                    resizeObserver.disconnect();
                }
            }), watch(props, propName => {
                if (propName !== 'width' && propName !== 'height')
                    return;
                store.dispatch(changeViewport(props.width, props.height));
            }), watch(props, propName => {
                if (propName !== 'readonly')
                    return;
                store.dispatch(readonlyEditor$(props.readonly));
            }), fromEvent(editorRef.value, 'keydown')
                .pipe(ignoreEnterProcess)
                .subscribe(event => {
                helper.keydown$.next(event);
                if (keymapMatchAndStop(event, keymap.stop)) {
                    eventBus.emit(Bus.Contextmenu.close);
                    closeDrawer();
                    onFocus();
                }
            }));
        });
        unmounted(() => {
            // globalEvent.destroy();
            // store.destroy();
            // helper.destroy();
            resizeObserver.disconnect();
        });
        const getParentHeight = () => {
            const editor = document.querySelector('erd-editor');
            if (editor && editor.height) {
                return props.automaticLayout ? editor.height - SIZE_MENUBAR_HEIGHT : props.height;
            }
            return props.automaticLayout ? document.documentElement.clientHeight - SIZE_MENUBAR_HEIGHT : props.height;
        };
        const getParentWidth = () => {
            const editor = document.querySelector('erd-editor');
            if (editor && editor.width) {
                return props.automaticLayout ? editor.width : props.width;
            }
            return props.automaticLayout ? document.documentElement.clientWidth : props.width;
        };
        return () => {
            props.width;
            props.height - SIZE_MENUBAR_HEIGHT;
            return html `
      <kderd-provider .value=${context}>
        <div
          class="kderd-editor"
          style=${styleMap({
            width: props.automaticLayout ? `100%` : `${props.width}px`,
            height: props.automaticLayout ? `100%` : `${props.height}px`,
        })}
          @mousedown=${onOutside}
          @touchstart=${onOutside}
        >
          <kderd-menubar
            .focusState=${ghostState.focus}
            @open-help=${openHelp}
            @open-setting=${openSetting}
          ></kderd-menubar>
          ${cache(!hasPanel()
            ? html `<kderd-erd .width=${getParentWidth()} .height=${getParentHeight()}></kderd-erd>`
            : null)}
          ${panelTpl()} ${drawerTpl()} ${ghostTpl}
        </div>
      </kderd-provider>
    `;
        };
    };
    const componentOptions = {
        observedProps: [
            {
                name: 'width',
                type: Number,
                default: DEFAULT_WIDTH,
            },
            {
                name: 'height',
                type: Number,
                default: DEFAULT_HEIGHT,
            },
            {
                name: 'automaticLayout',
                type: Boolean,
                default: false,
            },
            {
                name: 'readonly',
                type: Boolean,
                default: false,
            },
        ],
        style: IndexStyle,
        render: ERDEditor,
    };
    defineComponent('kderd-editor', componentOptions);
    defineComponent('erd-editor', componentOptions);

    function extension(config) {
        config.panels && addPanel(...config.panels);
    }

    extension({
        panels: [
        // SQLDDLPanel()
        ],
    });

    exports.addIcon = addIcon;
    exports.extension = extension;
    exports.observable = observable$1;
    exports.observer = observer;
    exports.setExportFileCallback = setExportFileCallback;
    exports.watch = watch;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
